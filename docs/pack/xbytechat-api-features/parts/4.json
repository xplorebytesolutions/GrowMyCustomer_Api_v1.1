{
  "name": "xbytechat-api/Features",
  "part": 4,
  "of": 6,
  "generatedAt": "2026-02-11 19:15:17 +00:00",
  "files": [
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Services/CTAFlowService.cs",
      "sha256": "02e12f43b542244885559938ed0d53600df3c26ba2554eb1e09890d3eaa77934",
      "language": "csharp",
      "size": 128433,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing System.Text.RegularExpressions;\nusing System.Text.Json;\nusing xbytechat.api.Features.CTAFlowBuilder.DTOs;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.Features.Tracking.Models;\nusing xbytechat.api.Helpers;\nusing xbytechat_api.WhatsAppSettings.Services;\nusing xbytechat.api.WhatsAppSettings.DTOs;\nusing xbytechat.api.Features.CRM.Models;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Services\n{\n    public class CTAFlowService : ICTAFlowService\n    {\n        private readonly AppDbContext _context;\n        private readonly IMessageEngineService _messageEngineService;\n        private readonly IWhatsAppTemplateFetcherService _templateFetcherService;\n\n        public CTAFlowService(\n            AppDbContext context,\n            IMessageEngineService messageEngineService,\n            IWhatsAppTemplateFetcherService templateFetcherService)\n        {\n            _context = context;\n            _messageEngineService = messageEngineService;\n            _templateFetcherService = templateFetcherService;\n        }\n\n        // ---------------------------\n        // CREATE (draft-only, no edit)\n        // ---------------------------\n        public async Task<ResponseResult> SaveVisualFlowAsync(\n            SaveVisualFlowDto dto,\n            Guid businessId,\n            string createdBy)\n        {\n            try\n            {\n                Log.Information(\"üß† SaveVisualFlow (create-only) | FlowName: {FlowName} | Biz: {BusinessId}\",\n                    dto.FlowName, businessId);\n\n                // 0) Validate\n                if (dto.Nodes == null || !dto.Nodes.Any())\n                    return ResponseResult.ErrorInfo(\"‚ùå Cannot save an empty flow. Please add at least one step.\");\n\n                var trimmedName = (dto.FlowName ?? \"\").Trim();\n                if (trimmedName.Length == 0)\n                    return ResponseResult.ErrorInfo(\"‚ùå Flow name is required.\");\n\n                // 1) Enforce unique active name per business (create-only)\n                var nameExists = await _context.CTAFlowConfigs\n                    .AnyAsync(f => f.BusinessId == businessId && f.FlowName == trimmedName && f.IsActive);\n                if (nameExists)\n                {\n                    Log.Warning(\"‚ö†Ô∏è Duplicate flow name '{Name}' for business {Biz}.\", trimmedName, businessId);\n                    return ResponseResult.ErrorInfo(\"‚ùå A flow with this name already exists.\");\n                }\n\n                await using var tx = await _context.Database.BeginTransactionAsync();\n\n                // 2) Insert FlowConfig AS DRAFT (force IsPublished=false)\n                var flow = new CTAFlowConfig\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    FlowName = trimmedName,\n                    CreatedBy = createdBy,\n                    CreatedAt = DateTime.UtcNow,\n                    UpdatedAt = DateTime.UtcNow,\n                    IsActive = true,\n                    IsPublished = false // << always draft on create\n                };\n                _context.CTAFlowConfigs.Add(flow);\n\n                // 3) Steps (map incoming node ids so we can wire links)\n                var stepMap = new Dictionary<string, CTAFlowStep>(StringComparer.OrdinalIgnoreCase);\n                var orderIndex = 0;\n\n                foreach (var node in dto.Nodes)\n                {\n                    if (string.IsNullOrWhiteSpace(node.Id)) continue;\n\n                    var step = new CTAFlowStep\n                    {\n                        Id = Guid.NewGuid(),\n                        CTAFlowConfigId = flow.Id,\n                        StepOrder = orderIndex++,\n                        TemplateToSend = node.TemplateName,\n                        TemplateType = node.TemplateType ?? \"UNKNOWN\",\n                        HeaderMediaUrl = string.IsNullOrWhiteSpace(node.HeaderMediaUrl) ? null : node.HeaderMediaUrl.Trim(),\n                        BodyParamsJson = SerializeBodyParams(node.BodyParams),\n                        UrlButtonParamsJson = SerializeUrlButtonParams(node.UrlButtonParams),\n                        TriggerButtonText = node.TriggerButtonText ?? \"\",\n                        TriggerButtonType = node.TriggerButtonType ?? \"cta\",\n                        PositionX = node.PositionX == 0 ? Random.Shared.Next(100, 600) : node.PositionX,\n                        PositionY = node.PositionY == 0 ? Random.Shared.Next(100, 400) : node.PositionY,\n                        UseProfileName = node.UseProfileName,\n                        ProfileNameSlot = node.ProfileNameSlot,\n                        ButtonLinks = new List<FlowButtonLink>()\n                    };\n\n                    // Only text templates may use profile name slot\n                    var isTextTemplate = string.Equals(step.TemplateType, \"text_template\", StringComparison.OrdinalIgnoreCase);\n                    if (!isTextTemplate)\n                    {\n                        step.UseProfileName = false;\n                        step.ProfileNameSlot = null;\n                    }\n                    else if (!step.UseProfileName)\n                    {\n                        step.ProfileNameSlot = null;\n                    }\n                    else if (!step.ProfileNameSlot.HasValue || step.ProfileNameSlot.Value < 1)\n                    {\n                        step.ProfileNameSlot = 1;\n                    }\n\n                    stepMap[node.Id] = step;\n                    _context.CTAFlowSteps.Add(step);\n                }\n\n                // 4) Wire links per node via edges (SourceHandle == button text)\n                var edges = dto.Edges ?? new List<FlowEdgeDto>();\n\n                foreach (var node in dto.Nodes)\n                {\n                    if (string.IsNullOrWhiteSpace(node.Id) || !stepMap.TryGetValue(node.Id, out var fromStep))\n                        continue;\n\n                    var outEdges = edges\n                        .Where(e => string.Equals(e.FromNodeId, node.Id, StringComparison.OrdinalIgnoreCase))\n                        .ToList();\n\n                    var seenTexts = new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n                    var orderedButtons = (node.Buttons ?? new List<LinkButtonDto>())\n                        .OrderBy(b => b.Index < 0 ? int.MaxValue : b.Index)\n                        .ThenBy(b => b.Text ?? string.Empty)\n                        .ToList();\n\n                    short nextIdx = 0;\n\n                    foreach (var btn in orderedButtons)\n                    {\n                        var text = (btn.Text ?? string.Empty).Trim();\n                        if (string.IsNullOrEmpty(text)) continue;\n                        if (!seenTexts.Add(text)) continue; // dedupe\n\n                        var edge = outEdges.FirstOrDefault(e =>\n                            string.Equals(e.SourceHandle ?? string.Empty, text, StringComparison.OrdinalIgnoreCase));\n                        if (edge == null) continue;\n\n                        if (!stepMap.TryGetValue(edge.ToNodeId, out var toStep)) continue;\n\n                        var finalIndex = btn.Index >= 0 ? btn.Index : nextIdx;\n                        nextIdx = (short)(finalIndex + 1);\n\n                        var link = new FlowButtonLink\n                        {\n                            Id = Guid.NewGuid(),\n                            CTAFlowStepId = fromStep.Id,\n                            NextStepId = toStep.Id,\n                            ButtonText = text,\n                            ButtonType = string.IsNullOrWhiteSpace(btn.Type) ? \"QUICK_REPLY\" : btn.Type,\n                            ButtonSubType = btn.SubType ?? string.Empty,\n                            ButtonValue = btn.Value ?? string.Empty,\n                            ButtonIndex = (short)finalIndex\n                        };\n\n                        _context.FlowButtonLinks.Add(link);\n                        fromStep.ButtonLinks.Add(link);\n\n                        // convenience: populate target's trigger info\n                        toStep.TriggerButtonText = text;\n                        toStep.TriggerButtonType = (btn.Type ?? \"QUICK_REPLY\").ToLowerInvariant();\n                    }\n                }\n\n                await _context.SaveChangesAsync();\n                await tx.CommitAsync();\n\n                Log.Information(\"‚úÖ Flow created '{Flow}' | Steps: {Steps} | Links: {Links}\",\n                    flow.FlowName, stepMap.Count, stepMap.Values.Sum(s => s.ButtonLinks.Count));\n\n                return ResponseResult.SuccessInfo(\"‚úÖ Flow created.\", new { flowId = flow.Id });\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Exception while saving (create) flow\");\n                return ResponseResult.ErrorInfo(\"‚ùå Internal error while saving flow.\");\n            }\n        }\n\n        // ---------------------------\n        // LISTS\n        // ---------------------------\n        public async Task<List<VisualFlowSummaryDto>> GetAllPublishedFlowsAsync(Guid businessId)\n        {\n            return await _context.CTAFlowConfigs\n                .Where(f => f.BusinessId == businessId && f.IsPublished)\n                .OrderByDescending(f => f.CreatedAt)\n                .Select(f => new VisualFlowSummaryDto\n                {\n                    Id = f.Id,\n                    FlowName = f.FlowName,\n                    IsPublished = f.IsPublished,\n                    CreatedAt = f.CreatedAt\n                })\n                .ToListAsync();\n        }\n\n        public async Task<List<VisualFlowSummaryDto>> GetAllDraftFlowsAsync(Guid businessId)\n        {\n            return await _context.CTAFlowConfigs\n                .Where(f => f.BusinessId == businessId && !f.IsPublished && f.IsActive)\n                .OrderByDescending(f => f.CreatedAt)\n                .Select(f => new VisualFlowSummaryDto\n                {\n                    Id = f.Id,\n                    FlowName = f.FlowName,\n                    CreatedAt = f.CreatedAt,\n                    IsPublished = f.IsPublished\n                })\n                .ToListAsync();\n        }\n\n        // ---------------------------\n        // DETAIL LOADERS\n        // ---------------------------\n        public async Task<SaveVisualFlowDto?> GetVisualFlowByIdAsync(Guid flowId, Guid businessId)\n        {\n            var flow = await _context.CTAFlowConfigs\n                .Include(c => c.Steps)\n                    .ThenInclude(s => s.ButtonLinks)\n                .FirstOrDefaultAsync(c => c.Id == flowId && c.BusinessId == businessId && c.IsActive);\n\n            if (flow == null) return null;\n\n            // Prefetch template metadata\n            var templateMap = new Dictionary<string, TemplateMetadataDto>(StringComparer.OrdinalIgnoreCase);\n            var uniqueNames = flow.Steps\n                .Select(s => s.TemplateToSend)\n                .Where(n => !string.IsNullOrWhiteSpace(n))\n                .Distinct(StringComparer.OrdinalIgnoreCase)\n                .ToList();\n\n            foreach (var name in uniqueNames)\n            {\n                try\n                {\n                    var tpl = await _templateFetcherService.GetTemplateByNameAsync(\n                        businessId, name!, includeButtons: true);\n                    if (tpl != null) templateMap[name!] = tpl;\n                }\n                catch (Exception ex)\n                {\n                    Log.Warning(ex, \"‚ö†Ô∏è Failed to fetch template metadata for {Template}\", name);\n                }\n            }\n\n                var nodes = flow.Steps.Select(step =>\n                {\n                    templateMap.TryGetValue(step.TemplateToSend ?? \"\", out var tpl);\n\n                var dbLinks = step.ButtonLinks ?? new List<FlowButtonLink>();\n                var linkByIndex = dbLinks.ToDictionary(l => (int)l.ButtonIndex, l => l);\n\n                // Canonical button list (max 3) in index order. This is important for dynamic URL button params,\n                // which are indexed by button position (\"0\",\"1\",\"2\") in Meta payloads.\n                // For linked buttons, preserve stored ButtonText so ReactFlow edges rehydrate (SourceHandle matches).\n                var buttons = (tpl?.ButtonParams ?? new List<ButtonMetadataDto>())\n                    .OrderBy(b => b.Index)\n                    .Take(3)\n                    .Select(btn =>\n                    {\n                        var idx = btn.Index;\n                        if (idx < 0 || idx > 2) return null;\n\n                        if (linkByIndex.TryGetValue(idx, out var link))\n                        {\n                            return new LinkButtonDto\n                            {\n                                Text = link.ButtonText,\n                                Type = link.ButtonType,\n                                SubType = link.ButtonSubType,\n                                Value = link.ButtonValue,\n                                Index = link.ButtonIndex,\n                                TargetNodeId = link.NextStepId?.ToString()\n                            };\n                        }\n\n                        return new LinkButtonDto\n                        {\n                            Text = btn.Text,\n                            Type = btn.Type,\n                            SubType = btn.SubType,\n                            Value = btn.ParameterValue,\n                            Index = idx,\n                            TargetNodeId = null\n                        };\n                    })\n                    .Where(x => x != null)\n                    .Select(x => x!)\n                    .ToList();\n\n                return new FlowNodeDto\n                {\n                    Id = step.Id.ToString(),\n                    TemplateName = step.TemplateToSend,\n                    TemplateType = step.TemplateType,\n                    HeaderMediaUrl = step.HeaderMediaUrl,\n                    BodyParams = TryParseBodyParams(step.BodyParamsJson),\n                    UrlButtonParams = TryParseUrlButtonParams(step.UrlButtonParamsJson),\n                    MessageBody = string.IsNullOrWhiteSpace(tpl?.Body) ? \"‚Äî no body found ‚Äî\" : tpl!.Body,\n                    TriggerButtonText = step.TriggerButtonText,\n                    TriggerButtonType = step.TriggerButtonType,\n                    PositionX = step.PositionX ?? 100,\n                    PositionY = step.PositionY ?? 100,\n                    RequiredTag = step.RequiredTag,\n                    RequiredSource = step.RequiredSource,\n                    UseProfileName = step.UseProfileName,\n                    ProfileNameSlot = step.ProfileNameSlot,\n                    Buttons = buttons\n                };\n            }).ToList();\n\n            var edges = flow.Steps\n                .SelectMany(step =>\n                    (step.ButtonLinks ?? Enumerable.Empty<FlowButtonLink>())\n                    .Where(l => l.NextStepId.HasValue)\n                    .Select(l => new FlowEdgeDto\n                    {\n                        FromNodeId = step.Id.ToString(),\n                        ToNodeId = l.NextStepId!.Value.ToString(),\n                        SourceHandle = l.ButtonText\n                    }))\n                .ToList();\n\n            return new SaveVisualFlowDto\n            {\n                FlowName = flow.FlowName,\n                IsPublished = flow.IsPublished,\n                Nodes = nodes,\n                Edges = edges\n            };\n        }\n\n        public async Task<ResponseResult> GetVisualFlowAsync(Guid flowId, Guid businessId)\n        {\n            try\n            {\n                var flow = await _context.CTAFlowConfigs\n                    .AsNoTracking()\n                    .Where(f => f.IsActive && f.BusinessId == businessId && f.Id == flowId)\n                    .Select(f => new\n                    {\n                        f.Id,\n                        f.FlowName,\n                        f.IsPublished,\n                        Steps = _context.CTAFlowSteps\n                            .Where(s => s.CTAFlowConfigId == f.Id)\n                            .OrderBy(s => s.StepOrder)\n                            .Select(s => new\n                            {\n                                s.Id,\n                                s.StepOrder,\n                                s.TemplateToSend,\n                                s.TemplateType,\n                                s.HeaderMediaUrl,\n                                s.BodyParamsJson,\n                                s.UrlButtonParamsJson,\n                                s.TriggerButtonText,\n                                s.TriggerButtonType,\n                                s.PositionX,\n                                s.PositionY,\n                                s.UseProfileName,\n                                s.ProfileNameSlot,\n                                Buttons = _context.FlowButtonLinks\n                                    .Where(b => b.CTAFlowStepId == s.Id)\n                                    .OrderBy(b => b.ButtonIndex)\n                                    .Select(b => new\n                                    {\n                                        b.ButtonText,\n                                        b.ButtonType,\n                                        b.ButtonSubType,\n                                        b.ButtonValue,\n                                        b.ButtonIndex,\n                                        b.NextStepId\n                                    })\n                                    .ToList()\n                            })\n                            .ToList()\n                    })\n                    .FirstOrDefaultAsync();\n\n                if (flow == null)\n                    return ResponseResult.ErrorInfo(\"Flow not found.\");\n\n                var nodes = flow.Steps.Select(s => new\n                {\n                    id = s.Id.ToString(),\n                    positionX = s.PositionX ?? 0,\n                    positionY = s.PositionY ?? 0,\n                    templateName = s.TemplateToSend,\n                    templateType = s.TemplateType,\n                    headerMediaUrl = s.HeaderMediaUrl,\n                    bodyParams = TryParseBodyParams(s.BodyParamsJson),\n                    urlButtonParams = TryParseUrlButtonParams(s.UrlButtonParamsJson),\n                    triggerButtonText = s.TriggerButtonText ?? string.Empty,\n                    triggerButtonType = s.TriggerButtonType ?? \"cta\",\n                    requiredTag = string.Empty,\n                    requiredSource = string.Empty,\n                    useProfileName = s.UseProfileName,\n                    profileNameSlot = (s.ProfileNameSlot.HasValue && s.ProfileNameSlot.Value > 0) ? s.ProfileNameSlot.Value : 1,\n                    buttons = s.Buttons.Select(b => new\n                    {\n                        text = b.ButtonText,\n                        type = b.ButtonType,\n                        subType = b.ButtonSubType,\n                        value = b.ButtonValue,\n                        targetNodeId = b.NextStepId == Guid.Empty ? null : b.NextStepId.ToString(),\n                        index = (int)(b.ButtonIndex)\n                    })\n                });\n\n                var edges = flow.Steps\n                    .SelectMany(s => s.Buttons\n                        .Where(b => b.NextStepId != Guid.Empty)\n                        .Select(b => new\n                        {\n                            fromNodeId = s.Id.ToString(),\n                            toNodeId = b.NextStepId.ToString(),\n                            sourceHandle = b.ButtonText\n                        }));\n\n                var payload = new\n                {\n                    flowName = flow.FlowName,\n                    isPublished = flow.IsPublished,\n                    nodes,\n                    edges\n                };\n\n                return ResponseResult.SuccessInfo(\"Flow loaded.\", payload);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Exception while loading visual flow {FlowId}\", flowId);\n                return ResponseResult.ErrorInfo(\"Internal error while loading flow.\");\n            }\n        }\n\n        private static string? SerializeBodyParams(List<string>? bodyParams)\n        {\n            if (bodyParams == null || bodyParams.Count == 0) return null;\n\n            // Persist trimmed values; keep empty strings (runtime/publish validation decides if that's allowed).\n            var cleaned = bodyParams.Select(x => (x ?? string.Empty).Trim()).ToList();\n            return JsonSerializer.Serialize(cleaned);\n        }\n\n        private static List<string> TryParseBodyParams(string? json)\n        {\n            if (string.IsNullOrWhiteSpace(json)) return new List<string>();\n            try\n            {\n                var list = JsonSerializer.Deserialize<List<string>>(json);\n                return list ?? new List<string>();\n            }\n            catch\n            {\n                // Keep flow load resilient even if older rows contain malformed data.\n                return new List<string>();\n            }\n        }\n\n        private static string? SerializeUrlButtonParams(List<string>? urlButtonParams)\n        {\n            if (urlButtonParams == null || urlButtonParams.Count == 0) return null;\n\n            // Meta supports up to 3 buttons. Persist trimmed values; keep empty strings (validation decides if that's allowed).\n            var cleaned = urlButtonParams\n                .Take(3)\n                .Select(x => (x ?? string.Empty).Trim())\n                .ToList();\n\n            return JsonSerializer.Serialize(cleaned);\n        }\n\n        private static List<string> TryParseUrlButtonParams(string? json)\n        {\n            if (string.IsNullOrWhiteSpace(json)) return new List<string>();\n            try\n            {\n                var list = JsonSerializer.Deserialize<List<string>>(json);\n                return list ?? new List<string>();\n            }\n            catch\n            {\n                return new List<string>();\n            }\n        }\n\n        // ---------------------------\n        // DELETE (only if not attached)\n        // ---------------------------\n        public async Task<ResponseResult> DeleteFlowAsync(Guid flowId, Guid businessId, string deletedBy)\n        {\n            var flow = await _context.CTAFlowConfigs\n                .Include(f => f.Steps)\n                    .ThenInclude(s => s.ButtonLinks)\n                .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId);\n\n            if (flow == null)\n                return ResponseResult.ErrorInfo(\"‚ùå Flow not found or does not belong to you.\");\n\n            var inUseQuery = _context.Campaigns\n                .Where(c => c.BusinessId == businessId &&\n                            !c.IsDeleted &&\n                            c.CTAFlowConfigId == flowId);\n\n            var inUseCount = await inUseQuery.CountAsync();\n            if (inUseCount > 0)\n            {\n                Log.Warning(\"‚ùå Delete flow blocked. Flow {FlowId} is used by {Count} campaigns.\", flowId, inUseCount);\n                // Keep message; controller will fetch campaigns for modal\n                return ResponseResult.ErrorInfo(\n                    $\"‚ùå Cannot delete. This flow is attached to {inUseCount} campaign(s). Delete those campaigns first.\");\n            }\n\n            foreach (var step in flow.Steps)\n                _context.FlowButtonLinks.RemoveRange(step.ButtonLinks);\n\n            _context.CTAFlowSteps.RemoveRange(flow.Steps);\n            _context.CTAFlowConfigs.Remove(flow);\n\n            await _context.SaveChangesAsync();\n            return ResponseResult.SuccessInfo(\"‚úÖ Flow deleted.\");\n        }\n\n        public async Task<IReadOnlyList<AttachedCampaignDto>> GetAttachedCampaignsAsync(Guid flowId, Guid businessId)\n        {\n            var q = _context.Campaigns\n                .Where(c => c.BusinessId == businessId && !c.IsDeleted && c.CTAFlowConfigId == flowId);\n\n            var firstSends = await _context.CampaignSendLogs\n                .Where(s => s.BusinessId == businessId && s.CampaignId != Guid.Empty)\n                .GroupBy(s => s.CampaignId)\n                .Select(g => new { CampaignId = g.Key, FirstSentAt = (DateTime?)g.Min(s => s.CreatedAt) })\n                .ToListAsync();\n\n            var firstSendMap = firstSends.ToDictionary(x => x.CampaignId, x => x.FirstSentAt);\n\n            var list = await q\n                .OrderByDescending(c => c.CreatedAt)\n                .Select(c => new\n                {\n                    c.Id,\n                    c.Name,\n                    c.Status,\n                    c.ScheduledAt,\n                    c.CreatedAt,\n                    c.CreatedBy\n                })\n                .ToListAsync();\n\n            return list.Select(x => new AttachedCampaignDto(\n                x.Id,\n                x.Name,\n                x.Status,\n                x.ScheduledAt,\n                x.CreatedAt,\n                x.CreatedBy,\n                firstSendMap.TryGetValue(x.Id, out var ts) ? ts : null\n            )).ToList();\n        }\n\n        public async Task<bool> HardDeleteFlowIfUnusedAsync(Guid flowId, Guid businessId)\n        {\n            var flow = await _context.CTAFlowConfigs\n                .Include(f => f.Steps)\n                    .ThenInclude(s => s.ButtonLinks)\n                .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId);\n\n            if (flow is null) return false;\n\n            var attached = await _context.Campaigns\n                .Where(c => c.BusinessId == businessId && !c.IsDeleted && c.CTAFlowConfigId == flowId)\n                .AnyAsync();\n            if (attached) return false;\n\n            foreach (var step in flow.Steps)\n                _context.FlowButtonLinks.RemoveRange(step.ButtonLinks);\n            _context.CTAFlowSteps.RemoveRange(flow.Steps);\n            _context.CTAFlowConfigs.Remove(flow);\n\n            await _context.SaveChangesAsync();\n            return true;\n        }\n\n        // ---------------------------\n        // PUBLISH (by id, flip flag)\n        // ---------------------------\n        public async Task<ResponseResult> PublishFlowAsync(Guid flowId, Guid businessId, string user)\n        {\n            var flow = await _context.CTAFlowConfigs\n                .Include(f => f.Steps)\n                .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId && f.IsActive);\n\n            if (flow is null) return ResponseResult.NotFound(\"‚ùå Flow not found.\");\n\n            // Server-side guardrails: publishing must be safe even if UI validation is bypassed.\n            // Validate required media header URL, body placeholder params, and dynamic URL button params.\n            var issues = await ValidateFlowForPublishAsync(flow, businessId);\n            if (issues.Count > 0)\n            {\n                Log.Warning(\n                    \"‚ùå CTAFlow publish blocked: validation failed biz={Biz} flow={Flow} issues={Count} first='{First}'\",\n                    businessId, flowId, issues.Count, issues[0]);\n\n                return ResponseResult.BadRequest(\n                    \"‚ùå Publish blocked: fix configuration issues in one or more steps.\",\n                    payload: issues);\n            }\n\n            flow.IsPublished = true;\n            flow.UpdatedAt = DateTime.UtcNow;\n            await _context.SaveChangesAsync();\n            return ResponseResult.Ok(\"‚úÖ Flow published.\");\n        }\n\n        // ----- Publish-time validation helpers (best-effort; must not throw) -----\n        private static readonly Regex PositionalToken =\n            new(@\"\\{\\{\\s*\\d+\\s*\\}\\}\", RegexOptions.Compiled); // {{1}}, {{ 2 }}, etc.\n\n        private static readonly Regex NamedToken =\n            new(@\"\\{\\{\\s*\\}\\}\", RegexOptions.Compiled);        // {{}} (NAMED format slot)\n\n        private static int CountBodyTokensFlexible(string? text)\n        {\n            if (string.IsNullOrEmpty(text)) return 0;\n            return PositionalToken.Matches(text).Count + NamedToken.Matches(text).Count;\n        }\n\n        private static bool IsValidHttpsUrl(string? input)\n        {\n            if (string.IsNullOrWhiteSpace(input)) return false;\n            if (!Uri.TryCreate(input.Trim(), UriKind.Absolute, out var u)) return false;\n            return string.Equals(u.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase);\n        }\n\n        private async Task<List<string>> ValidateFlowForPublishAsync(CTAFlowConfig flow, Guid businessId)\n        {\n            var issues = new List<string>();\n\n            try\n            {\n                var steps = (flow.Steps ?? new List<CTAFlowStep>())\n                    .OrderBy(s => s.StepOrder)\n                    .ToList();\n\n                if (steps.Count == 0)\n                {\n                    issues.Add(\"Flow has no steps.\");\n                    return issues;\n                }\n\n                var templateNames = steps\n                    .Select(s => (s.TemplateToSend ?? string.Empty).Trim())\n                    .Where(s => !string.IsNullOrWhiteSpace(s))\n                    .Distinct(StringComparer.OrdinalIgnoreCase)\n                    .ToList();\n\n                // Load template meta (buttons, header kind, body text) once per template.\n                var metaMap = new Dictionary<string, TemplateMetadataDto>(StringComparer.OrdinalIgnoreCase);\n                foreach (var name in templateNames)\n                {\n                    try\n                    {\n                        var meta = await _templateFetcherService.GetTemplateByNameAsync(\n                            businessId, name, includeButtons: true);\n                        if (meta != null) metaMap[name] = meta;\n                    }\n                    catch (Exception ex)\n                    {\n                        Log.Warning(ex, \"‚ö†Ô∏è CTAFlow publish validation: failed to fetch meta for {Template}\", name);\n                    }\n                }\n\n                // Canonical body var counts (buttons are separate). If missing, fall back to token counting.\n                var bodyCounts = await _context.WhatsAppTemplates\n                    .AsNoTracking()\n                    .Where(t => t.BusinessId == businessId && t.IsActive && templateNames.Contains(t.Name))\n                    .GroupBy(t => t.Name)\n                    .Select(g => new { Name = g.Key, BodyVarCount = g.Max(x => x.BodyVarCount) })\n                    .ToListAsync();\n\n                var bodyCountMap = bodyCounts.ToDictionary(x => x.Name, x => x.BodyVarCount, StringComparer.OrdinalIgnoreCase);\n\n                foreach (var step in steps)\n                {\n                    var stepLabel = $\"Step {step.StepOrder + 1}\";\n                    var templateName = (step.TemplateToSend ?? string.Empty).Trim();\n\n                    if (string.IsNullOrWhiteSpace(templateName))\n                    {\n                        issues.Add($\"{stepLabel}: missing template.\");\n                        continue;\n                    }\n\n                    if (!metaMap.TryGetValue(templateName, out var meta) || meta == null)\n                    {\n                        issues.Add($\"{stepLabel} ({templateName}): template not found/approved for this business.\");\n                        continue;\n                    }\n\n                    // Header media URL required for image/video/document templates\n                    var headerKind = (meta.HeaderKind ?? \"none\").Trim().ToLowerInvariant();\n                    var requiresMediaHeader = headerKind is \"image\" or \"video\" or \"document\";\n                    if (requiresMediaHeader && !IsValidHttpsUrl(step.HeaderMediaUrl))\n                    {\n                        issues.Add($\"{stepLabel} ({templateName}): header media URL required (https) for {headerKind} template.\");\n                    }\n\n                    // Body placeholder params\n                    var bodyVarCount = 0;\n                    if (bodyCountMap.TryGetValue(templateName, out var c) && c > 0) bodyVarCount = c;\n                    else bodyVarCount = CountBodyTokensFlexible(meta.Body);\n\n                    if (bodyVarCount > 0)\n                    {\n                        var args = TryParseBodyParams(step.BodyParamsJson);\n                        var slot = step.UseProfileName ? (step.ProfileNameSlot ?? 0) : 0;\n\n                        for (var i = 1; i <= bodyVarCount; i++)\n                        {\n                            if (slot == i) continue; // profile name slot is runtime-filled\n\n                            var v = (i - 1) < args.Count ? args[i - 1] : null;\n                            if (string.IsNullOrWhiteSpace(v))\n                            {\n                                issues.Add($\"{stepLabel} ({templateName}): missing body value for {{{{{i}}}}}.\");\n                                break;\n                            }\n                        }\n                    }\n\n                    // Dynamic URL button params\n                    if (meta.ButtonParams is { Count: > 0 })\n                    {\n                        var stored = TryParseUrlButtonParams(step.UrlButtonParamsJson);\n                        var buttons = meta.ButtonParams\n                            .OrderBy(b => b.Index)\n                            .Take(3)\n                            .ToList();\n\n                        foreach (var b in buttons)\n                        {\n                            var idx = b.Index;\n                            if (idx < 0 || idx > 2) continue;\n\n                            var isUrl =\n                                string.Equals(b.Type, \"URL\", StringComparison.OrdinalIgnoreCase) ||\n                                string.Equals(b.SubType, \"url\", StringComparison.OrdinalIgnoreCase);\n                            if (!isUrl) continue;\n\n                            var mask = (b.ParameterValue ?? string.Empty).Trim();\n                            var isDynamic = mask.Contains(\"{{\", StringComparison.Ordinal);\n                            if (!isDynamic) continue;\n\n                            var value = (idx < stored.Count ? stored[idx] : null) ?? string.Empty;\n                            if (string.IsNullOrWhiteSpace(value))\n                            {\n                                var bt = string.IsNullOrWhiteSpace(b.Text) ? $\"button {idx + 1}\" : $\"'{b.Text}'\";\n                                issues.Add($\"{stepLabel} ({templateName}): missing dynamic URL param for {bt}.\");\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            catch (Exception ex)\n            {\n                // Never block publish due to validation code crashing; instead, allow publish and log loudly.\n                // (Runtime still has hard checks + FlowExecutionLogs failures.)\n                Log.Error(ex, \"‚ùå CTAFlow publish validation crashed; allowing publish as fallback biz={Biz} flow={Flow}\", businessId, flow.Id);\n                issues.Clear();\n            }\n\n            return issues;\n        }\n\n        // ---------------------------\n        // UPDATE (save as draft by id)\n        // ---------------------------\n        public async Task<FlowUpdateResult> UpdateVisualFlowAsync(\n            Guid flowId,\n            SaveVisualFlowDto dto,\n            Guid businessId,\n            string user)\n        {\n            try\n            {\n                if (dto.Nodes == null || !dto.Nodes.Any())\n                    return new FlowUpdateResult { Status = \"error\", Message = \"‚ùå Cannot save an empty flow. Please add at least one step.\" };\n\n                var trimmedName = (dto.FlowName ?? string.Empty).Trim();\n                if (trimmedName.Length == 0)\n                    return new FlowUpdateResult { Status = \"error\", Message = \"‚ùå Flow name is required.\" };\n\n                var flow = await _context.CTAFlowConfigs\n                    .Include(f => f.Steps)\n                        .ThenInclude(s => s.ButtonLinks)\n                    .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId && f.IsActive);\n\n                if (flow == null)\n                    return new FlowUpdateResult { Status = \"notFound\", Message = \"‚ùå Flow not found.\" };\n\n                // If a live/published flow is attached, force fork to avoid changing active campaigns.\n                if (flow.IsPublished)\n                {\n                    var attachedCount = await _context.Campaigns\n                        .Where(c => c.BusinessId == businessId && !c.IsDeleted && c.CTAFlowConfigId == flowId)\n                        .CountAsync();\n\n                    if (attachedCount > 0)\n                    {\n                        var campaigns = await GetAttachedCampaignsAsync(flowId, businessId);\n                        return new FlowUpdateResult\n                        {\n                            Status = \"requiresFork\",\n                            Message = \"‚ùå This published flow is attached to campaign(s). Create a new draft version to edit.\",\n                            Campaigns = campaigns\n                        };\n                    }\n                }\n\n                // Enforce unique active name per business (excluding current flow)\n                var nameExists = await _context.CTAFlowConfigs\n                    .AnyAsync(f => f.BusinessId == businessId &&\n                                   f.IsActive &&\n                                   f.FlowName == trimmedName &&\n                                   f.Id != flowId);\n\n                if (nameExists)\n                    return new FlowUpdateResult { Status = \"error\", Message = \"‚ùå A flow with this name already exists.\" };\n\n                var needsRepublish = flow.IsPublished;\n\n                await using var tx = await _context.Database.BeginTransactionAsync();\n\n                // Update config and flip to draft on any edit\n                flow.FlowName = trimmedName;\n                flow.IsPublished = false;\n                flow.UpdatedAt = DateTime.UtcNow;\n\n                // Remove existing steps + links (we re-materialize from the visual payload)\n                foreach (var s in flow.Steps)\n                    _context.FlowButtonLinks.RemoveRange(s.ButtonLinks);\n\n                _context.CTAFlowSteps.RemoveRange(flow.Steps);\n                await _context.SaveChangesAsync();\n\n                // Recreate steps from nodes (preserve ids when possible)\n                var stepMap = new Dictionary<string, CTAFlowStep>(StringComparer.OrdinalIgnoreCase);\n                var orderIndex = 0;\n\n                foreach (var node in dto.Nodes)\n                {\n                    if (string.IsNullOrWhiteSpace(node.Id)) continue;\n\n                    var stepId = Guid.TryParse(node.Id, out var gid) ? gid : Guid.NewGuid();\n\n                    var step = new CTAFlowStep\n                    {\n                        Id = stepId,\n                        CTAFlowConfigId = flow.Id,\n                        StepOrder = orderIndex++,\n                        TemplateToSend = node.TemplateName,\n                        TemplateType = node.TemplateType ?? \"UNKNOWN\",\n                        HeaderMediaUrl = string.IsNullOrWhiteSpace(node.HeaderMediaUrl) ? null : node.HeaderMediaUrl.Trim(),\n                        BodyParamsJson = SerializeBodyParams(node.BodyParams),\n                        UrlButtonParamsJson = SerializeUrlButtonParams(node.UrlButtonParams),\n                        TriggerButtonText = node.TriggerButtonText ?? \"\",\n                        TriggerButtonType = node.TriggerButtonType ?? \"cta\",\n                        PositionX = node.PositionX == 0 ? Random.Shared.Next(100, 600) : node.PositionX,\n                        PositionY = node.PositionY == 0 ? Random.Shared.Next(100, 400) : node.PositionY,\n                        UseProfileName = node.UseProfileName,\n                        ProfileNameSlot = node.ProfileNameSlot,\n                        ButtonLinks = new List<FlowButtonLink>()\n                    };\n\n                    // Only text templates may use profile name slot\n                    var isTextTemplate = string.Equals(step.TemplateType, \"text_template\", StringComparison.OrdinalIgnoreCase);\n                    if (!isTextTemplate)\n                    {\n                        step.UseProfileName = false;\n                        step.ProfileNameSlot = null;\n                    }\n                    else if (!step.UseProfileName)\n                    {\n                        step.ProfileNameSlot = null;\n                    }\n                    else if (!step.ProfileNameSlot.HasValue || step.ProfileNameSlot.Value < 1)\n                    {\n                        step.ProfileNameSlot = 1;\n                    }\n\n                    stepMap[node.Id] = step;\n                    _context.CTAFlowSteps.Add(step);\n                }\n\n                // Wire links per node via edges (SourceHandle == button text)\n                var edges = dto.Edges ?? new List<FlowEdgeDto>();\n\n                foreach (var node in dto.Nodes)\n                {\n                    if (string.IsNullOrWhiteSpace(node.Id) || !stepMap.TryGetValue(node.Id, out var fromStep))\n                        continue;\n\n                    var outEdges = edges\n                        .Where(e => string.Equals(e.FromNodeId, node.Id, StringComparison.OrdinalIgnoreCase))\n                        .ToList();\n\n                    var seenTexts = new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n                    var orderedButtons = (node.Buttons ?? new List<LinkButtonDto>())\n                        .OrderBy(b => b.Index < 0 ? int.MaxValue : b.Index)\n                        .ThenBy(b => b.Text ?? string.Empty)\n                        .ToList();\n\n                    short nextIdx = 0;\n\n                    foreach (var btn in orderedButtons)\n                    {\n                        var text = (btn.Text ?? string.Empty).Trim();\n                        if (string.IsNullOrEmpty(text)) continue;\n                        if (!seenTexts.Add(text)) continue; // dedupe\n\n                        var edge = outEdges.FirstOrDefault(e =>\n                            string.Equals(e.SourceHandle ?? string.Empty, text, StringComparison.OrdinalIgnoreCase));\n                        if (edge == null) continue;\n\n                        if (!stepMap.TryGetValue(edge.ToNodeId, out var toStep)) continue;\n\n                        var finalIndex = btn.Index >= 0 ? btn.Index : nextIdx;\n                        nextIdx = (short)(finalIndex + 1);\n\n                        var link = new FlowButtonLink\n                        {\n                            Id = Guid.NewGuid(),\n                            CTAFlowStepId = fromStep.Id,\n                            NextStepId = toStep.Id,\n                            ButtonText = text,\n                            ButtonType = string.IsNullOrWhiteSpace(btn.Type) ? \"QUICK_REPLY\" : btn.Type,\n                            ButtonSubType = btn.SubType ?? string.Empty,\n                            ButtonValue = btn.Value ?? string.Empty,\n                            ButtonIndex = (short)finalIndex\n                        };\n\n                        _context.FlowButtonLinks.Add(link);\n                        fromStep.ButtonLinks.Add(link);\n\n                        // convenience: populate target's trigger info\n                        toStep.TriggerButtonText = text;\n                        toStep.TriggerButtonType = (btn.Type ?? \"QUICK_REPLY\").ToLowerInvariant();\n                    }\n                }\n\n                await _context.SaveChangesAsync();\n                await tx.CommitAsync();\n\n                return new FlowUpdateResult\n                {\n                    Status = \"ok\",\n                    NeedsRepublish = needsRepublish,\n                    Message = \"‚úÖ Flow updated (draft).\"\n                };\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Exception while updating visual flow {FlowId}\", flowId);\n                return new FlowUpdateResult { Status = \"error\", Message = \"‚ùå Internal error while updating flow.\" };\n            }\n        }\n\n        // ---------------------------\n        // FORK (create new draft copy)\n        // ---------------------------\n        public async Task<Guid> ForkFlowAsync(Guid flowId, Guid businessId, string user)\n        {\n            try\n            {\n                var src = await _context.CTAFlowConfigs\n                    .Include(f => f.Steps)\n                        .ThenInclude(s => s.ButtonLinks)\n                    .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId && f.IsActive);\n\n                if (src == null) return Guid.Empty;\n\n                // Ensure unique name (unique index on BusinessId+FlowName+IsActive)\n                var baseName = $\"{src.FlowName} (Copy)\";\n                var candidate = baseName;\n                var n = 2;\n                while (await _context.CTAFlowConfigs.AnyAsync(f =>\n                           f.BusinessId == businessId && f.IsActive && f.FlowName == candidate))\n                {\n                    candidate = $\"{baseName} {n++}\";\n                }\n\n                await using var tx = await _context.Database.BeginTransactionAsync();\n\n                var dst = new CTAFlowConfig\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    FlowName = candidate,\n                    CreatedBy = user,\n                    CreatedAt = DateTime.UtcNow,\n                    UpdatedAt = DateTime.UtcNow,\n                    IsActive = true,\n                    IsPublished = false\n                };\n                _context.CTAFlowConfigs.Add(dst);\n\n                var stepIdMap = new Dictionary<Guid, Guid>();\n                foreach (var s in src.Steps.OrderBy(x => x.StepOrder))\n                    stepIdMap[s.Id] = Guid.NewGuid();\n\n                var newSteps = src.Steps.OrderBy(x => x.StepOrder).Select(s => new CTAFlowStep\n                {\n                    Id = stepIdMap[s.Id],\n                    CTAFlowConfigId = dst.Id,\n                    StepOrder = s.StepOrder,\n                    TemplateToSend = s.TemplateToSend,\n                    TemplateType = s.TemplateType,\n                    HeaderMediaUrl = s.HeaderMediaUrl,\n                    BodyParamsJson = s.BodyParamsJson,\n                    UrlButtonParamsJson = s.UrlButtonParamsJson,\n                    TriggerButtonText = s.TriggerButtonText,\n                    TriggerButtonType = s.TriggerButtonType,\n                    RequiredTag = s.RequiredTag,\n                    RequiredSource = s.RequiredSource,\n                    PositionX = s.PositionX,\n                    PositionY = s.PositionY,\n                    UseProfileName = s.UseProfileName,\n                    ProfileNameSlot = s.ProfileNameSlot\n                }).ToList();\n\n                _context.CTAFlowSteps.AddRange(newSteps);\n\n                foreach (var srcStep in src.Steps)\n                {\n                    foreach (var b in srcStep.ButtonLinks)\n                    {\n                        var newLink = new FlowButtonLink\n                        {\n                            Id = Guid.NewGuid(),\n                            CTAFlowStepId = stepIdMap[srcStep.Id],\n                            NextStepId = (b.NextStepId.HasValue && stepIdMap.TryGetValue(b.NextStepId.Value, out var mapped))\n                                ? mapped\n                                : (Guid?)null,\n                            ButtonText = b.ButtonText,\n                            ButtonType = b.ButtonType,\n                            ButtonSubType = b.ButtonSubType,\n                            ButtonValue = b.ButtonValue,\n                            ButtonIndex = b.ButtonIndex\n                        };\n                        _context.FlowButtonLinks.Add(newLink);\n                    }\n                }\n\n                await _context.SaveChangesAsync();\n                await tx.CommitAsync();\n\n                return dst.Id;\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Exception while forking flow {FlowId}\", flowId);\n                return Guid.Empty;\n            }\n        }\n\n        // ---------------------------\n        // RUNTIME / Matching / Execute\n        // ---------------------------\n        public async Task<CTAFlowStep?> MatchStepByButtonAsync(\n            Guid businessId,\n            string buttonText,\n            string buttonType,\n            string templateName,\n            Guid? campaignId = null)\n        {\n            var normalizedButtonText = buttonText?.Trim().ToLower() ?? \"\";\n            var normalizedButtonType = buttonType?.Trim().ToLower() ?? \"\";\n            var normalizedTemplateName = templateName?.Trim().ToLower() ?? \"\";\n\n            if (campaignId.HasValue)\n            {\n                var overrideStep = await _context.CampaignFlowOverrides\n                    .Where(o =>\n                        o.CampaignId == campaignId &&\n                        o.ButtonText.ToLower() == normalizedButtonText &&\n                        o.TemplateName.ToLower() == normalizedTemplateName)\n                    .FirstOrDefaultAsync();\n\n                if (overrideStep != null)\n                {\n                    var overrideTemplate = overrideStep.OverrideNextTemplate?.ToLower();\n                    var matched = await _context.CTAFlowSteps\n                        .Include(s => s.Flow)\n                        .FirstOrDefaultAsync(s => s.TemplateToSend.ToLower() == overrideTemplate);\n                    if (matched != null) return matched;\n                }\n            }\n\n            var fallbackStep = await _context.CTAFlowSteps\n                .Include(s => s.Flow)\n                .Where(s =>\n                    s.Flow.BusinessId == businessId &&\n                    s.Flow.IsActive &&\n                    s.Flow.IsPublished &&\n                    s.TriggerButtonText.ToLower() == normalizedButtonText &&\n                    s.TriggerButtonType.ToLower() == normalizedButtonType)\n                .FirstOrDefaultAsync();\n\n            return fallbackStep;\n        }\n\n        public async Task<ResponseResult> ExecuteVisualFlowAsync(Guid businessId, Guid startStepId, Guid trackingLogId, Guid? campaignSendLogId)\n        {\n            try\n            {\n                var log = await _context.TrackingLogs\n                    .Include(l => l.Contact)\n                        .ThenInclude(c => c.ContactTags)\n                            .ThenInclude(ct => ct.Tag)\n                    .FirstOrDefaultAsync(l => l.Id == trackingLogId);\n\n                if (log == null) return ResponseResult.ErrorInfo(\"Tracking log not found.\");\n\n                var step = await GetChainedStepAsync(businessId, startStepId, log, log?.Contact);\n                if (step == null) return ResponseResult.ErrorInfo(\"Step conditions not satisfied.\");\n\n                var args = new List<string>();\n                if (step.UseProfileName && step.ProfileNameSlot is int slot && slot >= 1)\n                {\n                    var contact = log.Contact ?? await _context.Contacts\n                        .AsNoTracking()\n                        .FirstOrDefaultAsync(c => c.BusinessId == businessId && c.PhoneNumber == (log.ContactPhone ?? \"\"));\n                    var greet = (contact?.ProfileName ?? contact?.Name)?.Trim();\n                    if (string.IsNullOrEmpty(greet)) greet = \"there\";\n                    while (args.Count < slot) args.Add(string.Empty);\n                    args[slot - 1] = greet;\n                }\n\n                ResponseResult sendResult;\n                switch (step.TemplateType?.ToLower())\n                {\n                    case \"image_template\":\n                        var imageDto = new ImageTemplateMessageDto\n                        {\n                            BusinessId = businessId,\n                            RecipientNumber = log.ContactPhone ?? \"\",\n                            TemplateName = step.TemplateToSend,\n                            LanguageCode = \"en_US\"\n                        };\n                        sendResult = await _messageEngineService.SendImageTemplateMessageAsync(imageDto, businessId);\n                        break;\n                    case \"text_template\":\n                    default:\n                        var textDto = new SimpleTemplateMessageDto\n                        {\n                            RecipientNumber = log.ContactPhone ?? \"\",\n                            TemplateName = step.TemplateToSend,\n                            TemplateParameters = args\n                        };\n                        sendResult = await _messageEngineService.SendTemplateMessageSimpleAsync(businessId, textDto);\n                        break;\n                }\n\n                var executionLog = new FlowExecutionLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    StepId = step.Id,\n                    FlowId = step.CTAFlowConfigId,\n                    Origin = FlowExecutionOrigin.Campaign, // added fro autoreply flow\n                    CampaignSendLogId = campaignSendLogId,\n                    TrackingLogId = trackingLogId,\n                    ContactPhone = log.ContactPhone,\n                    TriggeredByButton = step.TriggerButtonText,\n                    TemplateName = step.TemplateToSend,\n                    TemplateType = step.TemplateType,\n                    Success = sendResult.Success,\n                    ErrorMessage = sendResult.ErrorMessage,\n                    RawResponse = sendResult.RawResponse,\n                    ExecutedAt = DateTime.UtcNow\n                };\n\n                _context.FlowExecutionLogs.Add(executionLog);\n                await _context.SaveChangesAsync();\n\n                return ResponseResult.SuccessInfo($\"Flow step executed. Sent: {sendResult.Success}\", null, sendResult.RawResponse);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Exception during ExecuteVisualFlowAsync()\");\n                return ResponseResult.ErrorInfo(\"Internal error during flow execution.\");\n            }\n        }\n\n        public Task<CTAFlowStep?> GetChainedStepAsync(Guid businessId, Guid? nextStepId)\n            => GetChainedStepAsync(businessId, nextStepId, null, null);\n\n        public async Task<CTAFlowStep?> GetChainedStepAsync(Guid businessId, Guid? nextStepId, TrackingLog? trackingLog, Contact? contact)\n        {\n            if (nextStepId == null) return null;\n\n            var flow = await _context.CTAFlowConfigs\n                .Include(f => f.Steps)\n                .FirstOrDefaultAsync(f =>\n                    f.BusinessId == businessId &&\n                    f.Steps.Any(s => s.Id == nextStepId));\n\n            var followUpStep = flow?.Steps.FirstOrDefault(s => s.Id == nextStepId);\n            if (followUpStep == null) return null;\n\n            if (trackingLog != null)\n            {\n                var isMatch = StepMatchingHelper.IsStepMatched(followUpStep, trackingLog, contact);\n                if (!isMatch) return null;\n            }\n\n            return followUpStep;\n        }\n\n        public async Task<CTAFlowStep?> GetChainedStepWithContextAsync(Guid businessId, Guid? nextStepId, Guid? trackingLogId)\n        {\n            var log = await _context.TrackingLogs\n                .Include(l => l.Contact)\n                    .ThenInclude(c => c.ContactTags)\n                        .ThenInclude(ct => ct.Tag)\n                .FirstOrDefaultAsync(l => l.Id == trackingLogId);\n\n            return await GetChainedStepAsync(businessId, nextStepId, log, log?.Contact);\n        }\n\n        // ‚úÖ MISSING IMPLEMENTATION (to satisfy the interface)\n        public async Task<FlowButtonLink?> GetLinkAsync(Guid flowId, Guid sourceStepId, short buttonIndex)\n        {\n            return await _context.FlowButtonLinks\n                .Where(l => l.CTAFlowStepId == sourceStepId\n                            && l.NextStepId != null\n                            && l.Step.CTAFlowConfigId == flowId\n                            && l.ButtonIndex == buttonIndex)\n                .SingleOrDefaultAsync();\n        }\n    }\n}\n\n\n//using Microsoft.AspNetCore.Authorization;\n//using Microsoft.AspNetCore.Mvc;\n//using Microsoft.EntityFrameworkCore;\n//using Serilog;\n//using xbytechat.api.AuthModule.Models;\n//using xbytechat.api.CRM.Models;\n//using xbytechat.api.Features.CTAFlowBuilder.DTOs;\n//using xbytechat.api.Features.CTAFlowBuilder.Models;\n//using xbytechat.api.Features.MessagesEngine.DTOs;\n//using xbytechat.api.Features.MessagesEngine.Services;\n//using xbytechat.api.Features.Tracking.Models;\n//using xbytechat.api.Helpers;\n//using xbytechat.api.WhatsAppSettings.DTOs;\n//using xbytechat_api.WhatsAppSettings.Services;\n\n//namespace xbytechat.api.Features.CTAFlowBuilder.Services\n//{\n//    public class CTAFlowService : ICTAFlowService\n//    {\n//        private readonly AppDbContext _context;\n//        private readonly IMessageEngineService _messageEngineService;\n//        private readonly IWhatsAppTemplateFetcherService _templateFetcherService;\n\n//        public CTAFlowService(AppDbContext context, IMessageEngineService messageEngineService,\n//            IWhatsAppTemplateFetcherService templateFetcherService\n//            )\n//        {\n//            _context = context;\n//            _messageEngineService = messageEngineService;\n//            _templateFetcherService = templateFetcherService;\n//        }\n\n//        public async Task<Guid> CreateFlowWithStepsAsync(CreateFlowDto dto, Guid businessId, string createdBy)\n//        {\n//            var flow = new CTAFlowConfig\n//            {\n//                Id = Guid.NewGuid(),\n//                FlowName = dto.FlowName,\n//                BusinessId = businessId,\n//                CreatedAt = DateTime.UtcNow,\n//                CreatedBy = createdBy,\n//                IsPublished = dto.IsPublished\n//            };\n\n//            foreach (var stepDto in dto.Steps)\n//            {\n//                var step = new CTAFlowStep\n//                {\n//                    Id = Guid.NewGuid(),\n//                    CTAFlowConfigId = flow.Id,\n//                    TriggerButtonText = stepDto.TriggerButtonText,\n//                    TriggerButtonType = stepDto.TriggerButtonType,\n//                    TemplateToSend = stepDto.TemplateToSend,\n//                    StepOrder = stepDto.StepOrder,\n//                    ButtonLinks = stepDto.ButtonLinks?.Select(link => new FlowButtonLink\n//                    {\n//                        ButtonText = link.ButtonText,\n//                        NextStepId = link.NextStepId\n//                    }).ToList() ?? new List<FlowButtonLink>()\n//                };\n\n//                flow.Steps.Add(step);\n//            }\n\n//            _context.CTAFlowConfigs.Add(flow);\n//            await _context.SaveChangesAsync();\n\n//            return flow.Id;\n//        }\n\n//        public async Task<CTAFlowConfig?> GetFlowByBusinessAsync(Guid businessId)\n//        {\n//            return await _context.CTAFlowConfigs\n//                .Include(f => f.Steps.OrderBy(s => s.StepOrder))\n//                .Where(f => f.BusinessId == businessId && f.IsActive && f.IsPublished)\n//                .FirstOrDefaultAsync();\n//        }\n\n//        public async Task<CTAFlowConfig?> GetDraftFlowByBusinessAsync(Guid businessId)\n//        {\n//            return await _context.CTAFlowConfigs\n//                .Include(f => f.Steps)\n//                    .ThenInclude(s => s.ButtonLinks)\n//                .Where(f => f.BusinessId == businessId && f.IsPublished == false)\n//                .OrderByDescending(f => f.CreatedAt)\n//                .FirstOrDefaultAsync();\n//        }\n\n\n\n//        public async Task<List<CTAFlowStep>> GetStepsForFlowAsync(Guid flowId)\n//        {\n//            return await _context.CTAFlowSteps\n//                .Where(s => s.CTAFlowConfigId == flowId)\n//                .OrderBy(s => s.StepOrder)\n//                .ToListAsync();\n//        }\n\n//        public async Task<CTAFlowStep?> MatchStepByButtonAsync(\n//            Guid businessId,\n//            string buttonText,\n//            string buttonType,\n//            string TemplateName,\n//            Guid? campaignId = null)\n//        {\n//            var normalizedButtonText = buttonText?.Trim().ToLower() ?? \"\";\n//            var normalizedButtonType = buttonType?.Trim().ToLower() ?? \"\";\n//            var normalizedTemplateName = TemplateName?.Trim().ToLower() ?? \"\";\n\n//            // 1Ô∏è‚É£ Try campaign-specific override\n//            if (campaignId.HasValue)\n//            {\n//                var overrideStep = await _context.CampaignFlowOverrides\n//                    .Where(o =>\n//                        o.CampaignId == campaignId &&\n//                        o.ButtonText.ToLower() == normalizedButtonText &&\n//                        o.TemplateName.ToLower() == normalizedTemplateName)\n//                    .FirstOrDefaultAsync();\n\n//                if (overrideStep != null)\n//                {\n//                    var overrideTemplate = overrideStep.OverrideNextTemplate?.ToLower();\n\n//                    var matched = await _context.CTAFlowSteps\n//                        .Include(s => s.Flow)\n//                        .FirstOrDefaultAsync(s => s.TemplateToSend.ToLower() == overrideTemplate);\n\n//                    if (matched != null)\n//                    {\n//                        Log.Information(\"üîÅ Override matched: Template '{Template}' ‚Üí Step '{StepId}'\", overrideStep.OverrideNextTemplate, matched.Id);\n//                        return matched;\n//                    }\n\n//                    Log.Warning(\"‚ö†Ô∏è Override found for button '{Button}' but no matching step for template '{Template}'\", normalizedButtonText, overrideStep.OverrideNextTemplate);\n//                }\n\n//                else\n//                {\n//                    Log.Information(\"üü° No campaign override found for button '{Button}' on template '{Template}'\", normalizedButtonText, normalizedTemplateName);\n//                }\n//            }\n\n//            // 2Ô∏è‚É£ Fallback to standard flow logic\n//            var fallbackStep = await _context.CTAFlowSteps\n//                .Include(s => s.Flow)\n//                .Where(s =>\n//                    s.Flow.BusinessId == businessId &&\n//                    s.Flow.IsActive &&\n//                    s.Flow.IsPublished &&\n//                    s.TriggerButtonText.ToLower() == normalizedButtonText &&\n//                    s.TriggerButtonType.ToLower() == normalizedButtonType)\n//                .FirstOrDefaultAsync();\n\n//            if (fallbackStep != null)\n//            {\n//                Log.Information(\"‚úÖ Fallback flow step matched: StepId = {StepId}, Flow = {FlowName}\", fallbackStep.Id, fallbackStep.Flow?.FlowName);\n//            }\n//            else\n//            {\n//                Log.Warning(\"‚ùå No fallback step matched for button '{ButtonText}' of type '{ButtonType}' in BusinessId: {BusinessId}\", normalizedButtonText, normalizedButtonType, businessId);\n//            }\n\n//            return fallbackStep;\n//        }\n\n\n//        public async Task<bool> PublishFlowAsync(Guid flowId, Guid businessId, string user)\n//        {\n//            var flow = await _context.CTAFlowConfigs\n//                .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId && f.IsActive);\n\n//            if (flow is null) return false;\n\n//            // Optional validation: ensure it has at least 1 step, etc.\n//            flow.IsPublished = true;\n//            flow.UpdatedAt = DateTime.UtcNow;\n//            await _context.SaveChangesAsync();\n//            return true;\n//        }\n\n//        //public async Task<ResponseResult> PublishFlowAsync(Guid businessId, List<FlowStepDto> steps, string createdBy)\n//        //{\n//        //    try\n//        //    {\n//        //        // üî• 1. Remove existing published flow for this business\n//        //        var existingFlows = await _context.CTAFlowConfigs\n//        //            .Where(f => f.BusinessId == businessId && f.IsPublished)\n//        //            .ToListAsync();\n\n//        //        if (existingFlows.Any())\n//        //        {\n//        //            _context.CTAFlowConfigs.RemoveRange(existingFlows);\n//        //        }\n\n//        //        // üå± 2. Create new flow config\n//        //        var flowConfig = new CTAFlowConfig\n//        //        {\n//        //            Id = Guid.NewGuid(),\n//        //            BusinessId = businessId,\n//        //            FlowName = \"Published Flow - \" + DateTime.UtcNow.ToString(\"yyyyMMdd-HHmm\"),\n//        //            IsPublished = true,\n//        //            IsActive = true,\n//        //            CreatedBy = createdBy,\n//        //            CreatedAt = DateTime.UtcNow,\n//        //            Steps = new List<CTAFlowStep>()\n//        //        };\n\n//        //        // üîÅ 3. Convert each step DTO to model\n//        //        foreach (var stepDto in steps)\n//        //        {\n//        //            var step = new CTAFlowStep\n//        //            {\n//        //                Id = Guid.NewGuid(),\n//        //                CTAFlowConfigId = flowConfig.Id,\n//        //                TriggerButtonText = stepDto.TriggerButtonText,\n//        //                TriggerButtonType = stepDto.TriggerButtonType,\n//        //                TemplateToSend = stepDto.TemplateToSend,\n//        //                StepOrder = stepDto.StepOrder,\n//        //                ButtonLinks = stepDto.ButtonLinks.Select(bl => new FlowButtonLink\n//        //                {\n//        //                    Id = Guid.NewGuid(),\n//        //                    ButtonText = bl.ButtonText,\n//        //                    NextStepId = bl.NextStepId,\n//        //                }).ToList()\n//        //            };\n\n//        //            flowConfig.Steps.Add(step);\n//        //        }\n\n//        //        // üíæ 4. Save to DB\n//        //        await _context.CTAFlowConfigs.AddAsync(flowConfig);\n//        //        await _context.SaveChangesAsync();\n\n//        //        return ResponseResult.SuccessInfo(\"‚úÖ Flow published successfully.\");\n//        //    }\n//        //    catch (Exception ex)\n//        //    {\n//        //        Log.Error(ex, \"‚ùå Error while publishing CTA flow.\");\n//        //        return ResponseResult.ErrorInfo(\"‚ùå Could not publish flow.\");\n//        //    }\n//        //}\n\n\n//        private static int CountBodyPlaceholders(string? body)\n//        {\n//            if (string.IsNullOrWhiteSpace(body)) return 0;\n//            // counts {{1}}, {{2}}, ... ; ignores any non-numeric moustaches\n//            var m = System.Text.RegularExpressions.Regex.Matches(body, @\"\\{\\{\\s*\\d+\\s*\\}\\}\");\n//            return m.Count;\n//        }\n//        public async Task<ResponseResult> SaveVisualFlowAsync(\n//    SaveVisualFlowDto dto,\n//    Guid businessId,\n//    string createdBy)\n//        {\n//            try\n//            {\n//                Log.Information(\"üß† SaveVisualFlow (create-only) | FlowName: {FlowName} | Biz: {BusinessId}\",\n//                    dto.FlowName, businessId);\n\n//                // 0) Basic validation\n//                if (dto.Nodes == null || !dto.Nodes.Any())\n//                    return ResponseResult.ErrorInfo(\"‚ùå Cannot save an empty flow. Please add at least one step.\");\n\n//                var trimmedName = (dto.FlowName ?? \"\").Trim();\n//                if (trimmedName.Length == 0)\n//                    return ResponseResult.ErrorInfo(\"‚ùå Flow name is required.\");\n\n//                // 1) CREATE-ONLY: refuse duplicate name for this business\n//                var nameExists = await _context.CTAFlowConfigs\n//                    .AnyAsync(f => f.BusinessId == businessId && f.FlowName == trimmedName && f.IsActive);\n\n//                if (nameExists)\n//                {\n//                    // IMPORTANT: this method is only for *new* flows.\n//                    // If the user is editing an existing flow, the UI should call PUT /cta-flow/{id}.\n//                    Log.Warning(\"‚ö†Ô∏è Duplicate flow name '{Name}' for business {Biz}.\", trimmedName, businessId);\n//                    return ResponseResult.ErrorInfo(\n//                        \"‚ùå A flow with this name already exists. Open that flow and edit it, or choose a different name.\");\n//                }\n\n//                await using var tx = await _context.Database.BeginTransactionAsync();\n\n//                // 2) Insert FlowConfig\n//                var flow = new CTAFlowConfig\n//                {\n//                    Id = Guid.NewGuid(),\n//                    BusinessId = businessId,\n//                    FlowName = trimmedName,\n//                    CreatedBy = createdBy,\n//                    CreatedAt = DateTime.UtcNow,\n//                    UpdatedAt = DateTime.UtcNow,\n//                    IsActive = true,\n//                    // You *can* allow creating as published, but most teams prefer create-as-draft:\n//                    IsPublished = dto.IsPublished\n//                };\n//                _context.CTAFlowConfigs.Add(flow);\n\n//                // 3) Build Steps\n//                var stepMap = new Dictionary<string, CTAFlowStep>(StringComparer.OrdinalIgnoreCase);\n//                var orderIndex = 0;\n\n//                foreach (var node in dto.Nodes)\n//                {\n//                    if (string.IsNullOrWhiteSpace(node.Id)) continue;\n\n//                    var step = new CTAFlowStep\n//                    {\n//                        Id = Guid.NewGuid(),\n//                        CTAFlowConfigId = flow.Id,\n//                        StepOrder = orderIndex++,\n//                        TemplateToSend = node.TemplateName,\n//                        TemplateType = node.TemplateType ?? \"UNKNOWN\",\n//                        TriggerButtonText = node.TriggerButtonText ?? \"\",\n//                        TriggerButtonType = node.TriggerButtonType ?? \"cta\",\n//                        PositionX = node.PositionX == 0 ? Random.Shared.Next(100, 600) : node.PositionX,\n//                        PositionY = node.PositionY == 0 ? Random.Shared.Next(100, 400) : node.PositionY,\n//                        UseProfileName = node.UseProfileName,\n//                        ProfileNameSlot = node.ProfileNameSlot,\n//                        ButtonLinks = new List<FlowButtonLink>()\n//                    };\n\n//                    // Harden profile-name config per template type\n//                    var isTextTemplate = string.Equals(step.TemplateType, \"text_template\", StringComparison.OrdinalIgnoreCase);\n//                    if (!isTextTemplate)\n//                    {\n//                        step.UseProfileName = false;\n//                        step.ProfileNameSlot = null;\n//                    }\n//                    else\n//                    {\n//                        if (!step.UseProfileName)\n//                        {\n//                            step.ProfileNameSlot = null;\n//                        }\n//                        else\n//                        {\n//                            if (!step.ProfileNameSlot.HasValue || step.ProfileNameSlot.Value < 1)\n//                                step.ProfileNameSlot = 1;\n//                        }\n//                    }\n\n//                    stepMap[node.Id] = step;\n//                    _context.CTAFlowSteps.Add(step);\n//                }\n\n//                // 4) Build Links (per-node buttons, matched by SourceHandle == button text)\n//                var edges = dto.Edges ?? new List<FlowEdgeDto>();\n\n//                foreach (var node in dto.Nodes)\n//                {\n//                    if (string.IsNullOrWhiteSpace(node.Id) || !stepMap.TryGetValue(node.Id, out var fromStep))\n//                        continue;\n\n//                    var outEdges = edges.Where(e => string.Equals(e.FromNodeId, node.Id, StringComparison.OrdinalIgnoreCase)).ToList();\n//                    var seenTexts = new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n\n//                    var orderedButtons = (node.Buttons ?? new List<LinkButtonDto>())\n//                        .OrderBy(b => b.Index < 0 ? int.MaxValue : b.Index)\n//                        .ThenBy(b => b.Text ?? string.Empty)\n//                        .ToList();\n\n//                    short nextIdx = 0;\n\n//                    foreach (var btn in orderedButtons)\n//                    {\n//                        var text = (btn.Text ?? string.Empty).Trim();\n//                        if (string.IsNullOrEmpty(text)) continue;\n\n//                        if (!seenTexts.Add(text))\n//                        {\n//                            Log.Warning(\"‚ö†Ô∏è Duplicate button text '{Text}' on node {NodeId}; first wins.\", text, node.Id);\n//                            continue;\n//                        }\n\n//                        var edge = outEdges.FirstOrDefault(e =>\n//                            string.Equals(e.SourceHandle ?? string.Empty, text, StringComparison.OrdinalIgnoreCase));\n//                        if (edge == null) continue;\n\n//                        if (!stepMap.TryGetValue(edge.ToNodeId, out var toStep)) continue;\n\n//                        var finalIndex = btn.Index >= 0 ? btn.Index : nextIdx;\n//                        nextIdx = (short)(finalIndex + 1);\n\n//                        var link = new FlowButtonLink\n//                        {\n//                            Id = Guid.NewGuid(),\n//                            CTAFlowStepId = fromStep.Id,\n//                            NextStepId = toStep.Id,\n//                            ButtonText = text,\n//                            ButtonType = string.IsNullOrWhiteSpace(btn.Type) ? \"QUICK_REPLY\" : btn.Type,\n//                            ButtonSubType = btn.SubType ?? string.Empty,\n//                            ButtonValue = btn.Value ?? string.Empty,\n//                            ButtonIndex = (short)finalIndex\n//                        };\n\n//                        _context.FlowButtonLinks.Add(link);\n//                        fromStep.ButtonLinks.Add(link);\n\n//                        // convenience: target step \"entry trigger\"\n//                        toStep.TriggerButtonText = text;\n//                        toStep.TriggerButtonType = (btn.Type ?? \"QUICK_REPLY\").ToLowerInvariant();\n//                    }\n//                }\n\n//                await _context.SaveChangesAsync();\n//                await tx.CommitAsync();\n\n//                Log.Information(\"‚úÖ Flow created '{Flow}' | Steps: {Steps} | Links: {Links}\",\n//                    flow.FlowName, stepMap.Count, stepMap.Values.Sum(s => s.ButtonLinks.Count));\n\n//                // Return new flowId so the FE can redirect/open it if desired\n//                return ResponseResult.SuccessInfo(\"‚úÖ Flow created.\", new { flowId = flow.Id });\n//            }\n//            catch (Exception ex)\n//            {\n//                Log.Error(ex, \"‚ùå Exception while saving (create) flow\");\n//                return ResponseResult.ErrorInfo(\"‚ùå Internal error while saving flow.\");\n//            }\n//        }\n\n//        //public async Task<ResponseResult> SaveVisualFlowAsync(SaveVisualFlowDto dto, Guid businessId, string createdBy)\n//        //{\n//        //    try\n//        //    {\n//        //        Log.Information(\"üß† SaveVisualFlow started | FlowName: {FlowName} | BusinessId: {BusinessId}\", dto.FlowName, businessId);\n\n//        //        if (dto.Nodes == null || !dto.Nodes.Any())\n//        //        {\n//        //            Log.Warning(\"‚ùå No nodes found in flow. Aborting save.\");\n//        //            return ResponseResult.ErrorInfo(\"‚ùå Cannot save an empty flow. Please add at least one step.\");\n//        //        }\n\n//        //        // 1) Upsert FlowConfig\n//        //        var flow = await _context.CTAFlowConfigs\n//        //            .FirstOrDefaultAsync(f => f.FlowName == dto.FlowName && f.BusinessId == businessId);\n\n//        //        if (flow == null)\n//        //        {\n//        //            flow = new CTAFlowConfig\n//        //            {\n//        //                Id = Guid.NewGuid(),\n//        //                BusinessId = businessId,\n//        //                FlowName = dto.FlowName,\n//        //                CreatedBy = createdBy,\n//        //                CreatedAt = DateTime.UtcNow,\n//        //                UpdatedAt = DateTime.UtcNow,\n//        //                IsActive = true,\n//        //                IsPublished = dto.IsPublished\n//        //            };\n//        //            _context.CTAFlowConfigs.Add(flow);\n//        //            Log.Information(\"‚úÖ New FlowConfig created with ID: {Id}\", flow.Id);\n//        //        }\n//        //        else\n//        //        {\n//        //            // wipe old steps+links for a clean replace\n//        //            var oldSteps = await _context.CTAFlowSteps\n//        //                .Where(s => s.CTAFlowConfigId == flow.Id)\n//        //                .Include(s => s.ButtonLinks)\n//        //                .ToListAsync();\n\n//        //            foreach (var step in oldSteps)\n//        //                _context.FlowButtonLinks.RemoveRange(step.ButtonLinks);\n\n//        //            _context.CTAFlowSteps.RemoveRange(oldSteps);\n\n//        //            flow.IsPublished = dto.IsPublished;\n//        //            flow.UpdatedAt = DateTime.UtcNow;\n//        //        }\n\n//        //        // 2) Build Steps (map by incoming node.Id string)\n//        //        var stepMap = new Dictionary<string, CTAFlowStep>(StringComparer.OrdinalIgnoreCase);\n\n//        //        foreach (var (node, index) in dto.Nodes.Select((n, i) => (n, i)))\n//        //        {\n//        //            if (string.IsNullOrWhiteSpace(node.Id))\n//        //                continue;\n\n//        //            var step = new CTAFlowStep\n//        //            {\n//        //                Id = Guid.NewGuid(),\n//        //                CTAFlowConfigId = flow.Id,\n//        //                StepOrder = index,\n//        //                TemplateToSend = node.TemplateName,\n//        //                TemplateType = node.TemplateType ?? \"UNKNOWN\",\n//        //                TriggerButtonText = node.TriggerButtonText ?? \"\",\n//        //                TriggerButtonType = node.TriggerButtonType ?? \"cta\",\n//        //                PositionX = node.PositionX == 0 ? Random.Shared.Next(100, 600) : node.PositionX,\n//        //                PositionY = node.PositionY == 0 ? Random.Shared.Next(100, 400) : node.PositionY,\n//        //                UseProfileName = node.UseProfileName,\n//        //                ProfileNameSlot = node.ProfileNameSlot,\n//        //                //ProfileNameSlot = node.ProfileNameSlot ?? 1,\n//        //                ButtonLinks = new List<FlowButtonLink>()\n//        //            };\n\n//        //            // ‚úÖ Harden profile-name config per step\n//        //            var isTextTemplate = string.Equals(step.TemplateType, \"text_template\", StringComparison.OrdinalIgnoreCase);\n//        //            if (!isTextTemplate)\n//        //            {\n//        //                // Only text templates support body placeholders; disable on others\n//        //                step.UseProfileName = false;\n//        //                step.ProfileNameSlot = null;\n//        //            }\n//        //            //else if (step.UseProfileName)\n//        //            //{\n//        //            //    // Clamp to minimum valid slot\n//        //            //    if (!step.ProfileNameSlot.HasValue || step.ProfileNameSlot.Value < 1)\n//        //            //        step.ProfileNameSlot = 1;\n//        //            //}\n//        //            else\n//        //            {\n//        //                // Text template:\n//        //                if (!step.UseProfileName)\n//        //                {\n//        //                    // Toggle OFF ‚Üí always null the slot\n//        //                    step.ProfileNameSlot = null;\n//        //                }\n//        //                else\n//        //                {\n//        //                    // Toggle ON ‚Üí clamp to minimum valid\n//        //                    if (!step.ProfileNameSlot.HasValue || step.ProfileNameSlot.Value < 1)\n//        //                        step.ProfileNameSlot = 1;\n//        //                    // (Optional) upper clamp if you want: e.g., step.ProfileNameSlot = Math.Min(step.ProfileNameSlot.Value, 50);\n//        //                }\n//        //            }\n//        //            stepMap[node.Id] = step;\n//        //            _context.CTAFlowSteps.Add(step);\n//        //        }\n\n//        //        // 3) Build Links PER NODE using buttons order (with Index), not per-edge blindly\n//        //        foreach (var node in dto.Nodes)\n//        //        {\n//        //            if (string.IsNullOrWhiteSpace(node.Id) || !stepMap.TryGetValue(node.Id, out var fromStep))\n//        //                continue;\n\n//        //            // outgoing edges from this node\n//        //            var outEdges = dto.Edges?.Where(e => string.Equals(e.FromNodeId, node.Id, StringComparison.OrdinalIgnoreCase)).ToList()\n//        //                           ?? new List<FlowEdgeDto>();\n\n//        //            // dedupe by button text to avoid ambiguous routing\n//        //            var seenTexts = new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n\n//        //            // stable ordering: by provided Index (0..N), then by Text\n//        //            var orderedButtons = (node.Buttons ?? new List<LinkButtonDto>())\n//        //                .OrderBy(b => b.Index < 0 ? int.MaxValue : b.Index)\n//        //                .ThenBy(b => b.Text ?? string.Empty)\n//        //                .ToList();\n\n//        //            short nextIdx = 0;\n\n//        //            foreach (var btn in orderedButtons)\n//        //            {\n//        //                var text = (btn.Text ?? string.Empty).Trim();\n//        //                if (string.IsNullOrEmpty(text))\n//        //                    continue;\n\n//        //                if (!seenTexts.Add(text))\n//        //                {\n//        //                    Log.Warning(\"‚ö†Ô∏è Duplicate button text '{Text}' on node {NodeId}; keeping first, skipping duplicates.\", text, node.Id);\n//        //                    continue;\n//        //                }\n\n//        //                // match edge by SourceHandle == button text (how ReactFlow wires handles)\n//        //                var edge = outEdges.FirstOrDefault(e =>\n//        //                    string.Equals(e.SourceHandle ?? string.Empty, text, StringComparison.OrdinalIgnoreCase));\n//        //                if (edge == null)\n//        //                {\n//        //                    // no wire from this button ‚Üí skip link creation but keep button metadata in UI on reload\n//        //                    continue;\n//        //                }\n\n//        //                if (!stepMap.TryGetValue(edge.ToNodeId, out var toStep))\n//        //                    continue;\n\n//        //                // final index: prefer incoming payload Index; else fallback to a sequential counter\n//        //                var finalIndex = btn.Index >= 0 ? btn.Index : nextIdx;\n//        //                nextIdx = (short)(finalIndex + 1);\n\n//        //                var link = new FlowButtonLink\n//        //                {\n//        //                    Id = Guid.NewGuid(),\n//        //                    CTAFlowStepId = fromStep.Id,\n//        //                    NextStepId = toStep.Id,\n//        //                    ButtonText = text,\n//        //                    ButtonType = string.IsNullOrWhiteSpace(btn.Type) ? \"QUICK_REPLY\" : btn.Type,\n//        //                    ButtonSubType = btn.SubType ?? string.Empty,\n//        //                    ButtonValue = btn.Value ?? string.Empty,\n//        //                    ButtonIndex = (short)finalIndex // üîë persist the index\n//        //                };\n\n//        //                _context.FlowButtonLinks.Add(link);\n//        //                fromStep.ButtonLinks.Add(link);\n\n//        //                // propagate trigger info on the target step for convenience\n//        //                toStep.TriggerButtonText = text;\n//        //                toStep.TriggerButtonType = (btn.Type ?? \"QUICK_REPLY\").ToLowerInvariant();\n//        //            }\n//        //        }\n\n//        //        await _context.SaveChangesAsync();\n\n//        //        Log.Information(\"‚úÖ Flow '{Flow}' saved | Steps: {StepCount} | Links: {LinkCount}\",\n//        //            dto.FlowName, stepMap.Count, stepMap.Values.Sum(s => s.ButtonLinks.Count));\n\n//        //        return ResponseResult.SuccessInfo(\"‚úÖ Flow saved successfully.\");\n//        //    }\n//        //    catch (Exception ex)\n//        //    {\n//        //        Log.Error(ex, \"‚ùå Exception while saving flow\");\n//        //        return ResponseResult.ErrorInfo(\"‚ùå Internal error while saving flow.\");\n//        //    }\n//        //}\n\n\n//        //public async Task<SaveVisualFlowDto?> GetVisualFlowByIdAsync(Guid flowId, Guid businessId)\n//        //{\n//        //    var flow = await _context.CTAFlowConfigs\n//        //        .Include(c => c.Steps)\n//        //            .ThenInclude(s => s.ButtonLinks)\n//        //        .FirstOrDefaultAsync(c =>\n//        //            c.Id == flowId &&\n//        //            c.BusinessId == businessId &&   // üëà tenant scoping\n//        //            c.IsActive);\n\n//        //    if (flow == null) return null;\n\n//        //    // ---- Pre-fetch unique template names (defensive) ----\n//        //    var templateMap = new Dictionary<string, TemplateMetadataDto>(StringComparer.OrdinalIgnoreCase);\n//        //    foreach (var name in flow.Steps\n//        //                             .Select(s => s.TemplateToSend)\n//        //                             .Where(n => !string.IsNullOrWhiteSpace(n))\n//        //                             .Distinct(StringComparer.OrdinalIgnoreCase))\n//        //    {\n//        //        try\n//        //        {\n//        //            var tpl = await _templateFetcherService.GetTemplateByNameAsync(\n//        //                businessId, name!, includeButtons: true);\n//        //            if (tpl != null) templateMap[name!] = tpl;\n//        //        }\n//        //        catch (Exception ex)\n//        //        {\n//        //            Log.Warning(ex, \"‚ö†Ô∏è Failed to fetch template from Meta for {Template}\", name);\n//        //        }\n//        //    }\n\n//        //    // ---- Nodes ----\n//        //    var nodes = flow.Steps.Select(step =>\n//        //    {\n//        //        templateMap.TryGetValue(step.TemplateToSend ?? \"\", out var template);\n\n//        //        IEnumerable<FlowButtonLink> links =\n//        //            step.ButtonLinks ?? Enumerable.Empty<FlowButtonLink>();\n\n//        //        var dbButtons = links.Select(link => new LinkButtonDto\n//        //        {\n//        //            Text = link.ButtonText,\n//        //            Type = link.ButtonType,\n//        //            SubType = link.ButtonSubType,\n//        //            Value = link.ButtonValue,\n//        //            TargetNodeId = link.NextStepId?.ToString() // null-safe\n//        //        });\n\n//        //        var templateButtons = (template?.ButtonParams ?? new List<ButtonMetadataDto>())\n//        //            .Where(btn => !links.Any(bl =>\n//        //                        string.Equals(bl.ButtonText, btn.Text, StringComparison.OrdinalIgnoreCase)))\n//        //            .Select(btn => new LinkButtonDto\n//        //            {\n//        //                Text = btn.Text,\n//        //                TargetNodeId = null\n//        //            });\n\n//        //        return new FlowNodeDto\n//        //        {\n//        //            Id = step.Id.ToString(),\n//        //            TemplateName = step.TemplateToSend,\n//        //            TemplateType = step.TemplateType,\n//        //            MessageBody = template?.Body ?? \"Message body preview...\",\n//        //            TriggerButtonText = step.TriggerButtonText,\n//        //            TriggerButtonType = step.TriggerButtonType,\n//        //            PositionX = step.PositionX ?? 100,\n//        //            PositionY = step.PositionY ?? 100,\n\n//        //            // Conditional logic\n//        //            RequiredTag = step.RequiredTag,\n//        //            RequiredSource = step.RequiredSource,\n\n//        //            UseProfileName = step.UseProfileName,\n//        //            ProfileNameSlot = step.ProfileNameSlot,\n\n//        //            Buttons = dbButtons.Concat(templateButtons).ToList()\n//        //        };\n//        //    }).ToList();\n\n//        //    // ---- Edges (skip links without a target) ----\n//        //    var edges = flow.Steps\n//        //        .SelectMany(step =>\n//        //            (step.ButtonLinks ?? Enumerable.Empty<FlowButtonLink>())\n//        //            .Where(link => link.NextStepId.HasValue)\n//        //            .Select(link => new FlowEdgeDto\n//        //            {\n//        //                FromNodeId = step.Id.ToString(),\n//        //                ToNodeId = link.NextStepId!.Value.ToString(),\n//        //                SourceHandle = link.ButtonText\n//        //            }))\n//        //        .ToList();\n\n//        //    return new SaveVisualFlowDto\n//        //    {\n//        //        FlowName = flow.FlowName,\n//        //        IsPublished = flow.IsPublished,\n//        //        Nodes = nodes,\n//        //        Edges = edges\n//        //    };\n//        //}\n\n//        public async Task<SaveVisualFlowDto?> GetVisualFlowByIdAsync(Guid flowId, Guid businessId)\n//        {\n//            var flow = await _context.CTAFlowConfigs\n//                .Include(c => c.Steps)\n//                    .ThenInclude(s => s.ButtonLinks)\n//                .FirstOrDefaultAsync(c => c.Id == flowId && c.BusinessId == businessId && c.IsActive);\n\n//            if (flow == null) return null;\n\n//            // 1) Prefetch template metadata for all unique names (defensive, fast)\n//            var templateMap = new Dictionary<string, TemplateMetadataDto>(StringComparer.OrdinalIgnoreCase);\n//            var uniqueNames = flow.Steps\n//                .Select(s => s.TemplateToSend)\n//                .Where(n => !string.IsNullOrWhiteSpace(n))\n//                .Distinct(StringComparer.OrdinalIgnoreCase)\n//                .ToList();\n\n//            foreach (var name in uniqueNames)\n//            {\n//                try\n//                {\n//                    var tpl = await _templateFetcherService.GetTemplateByNameAsync(\n//                        businessId, name!, includeButtons: true);\n//                    if (tpl != null) templateMap[name!] = tpl;\n//                }\n//                catch (Exception ex)\n//                {\n//                    Log.Warning(ex, \"‚ö†Ô∏è Failed to fetch template from provider for {Template}\", name);\n//                }\n//            }\n\n//            // 2) Build nodes with real body + merged buttons (DB links first, then any unlinked template buttons)\n//            var nodes = flow.Steps.Select(step =>\n//            {\n//                templateMap.TryGetValue(step.TemplateToSend ?? \"\", out var tpl);\n\n//                var dbLinks = step.ButtonLinks ?? new List<FlowButtonLink>();\n\n//                var dbButtons = dbLinks\n//                    .OrderBy(b => b.ButtonIndex)\n//                    .Select(link => new LinkButtonDto\n//                    {\n//                        Text = link.ButtonText,\n//                        Type = link.ButtonType,\n//                        SubType = link.ButtonSubType,\n//                        Value = link.ButtonValue,\n//                        Index = link.ButtonIndex,\n//                        TargetNodeId = link.NextStepId?.ToString()\n//                    });\n\n//                var templateButtons = (tpl?.ButtonParams ?? new List<ButtonMetadataDto>())\n//                    .Where(btn => !dbLinks.Any(bl => string.Equals(bl.ButtonText, btn.Text, StringComparison.OrdinalIgnoreCase)))\n//                    .Select(btn => new LinkButtonDto\n//                    {\n//                        Text = btn.Text,\n//                        // no TargetNodeId: not wired\n//                    });\n\n//                return new FlowNodeDto\n//                {\n//                    Id = step.Id.ToString(),\n//                    TemplateName = step.TemplateToSend,\n//                    TemplateType = step.TemplateType,\n//                    MessageBody = string.IsNullOrWhiteSpace(tpl?.Body) ? \"‚Äî no body found ‚Äî\" : tpl!.Body, // ‚Üê REAL BODY\n//                    TriggerButtonText = step.TriggerButtonText,\n//                    TriggerButtonType = step.TriggerButtonType,\n//                    PositionX = step.PositionX ?? 100,\n//                    PositionY = step.PositionY ?? 100,\n//                    RequiredTag = step.RequiredTag,\n//                    RequiredSource = step.RequiredSource,\n//                    UseProfileName = step.UseProfileName,\n//                    ProfileNameSlot = step.ProfileNameSlot,\n//                    Buttons = dbButtons.Concat(templateButtons).ToList()\n//                };\n//            }).ToList();\n\n//            // 3) Build edges\n//            var edges = flow.Steps\n//                .SelectMany(step => (step.ButtonLinks ?? Enumerable.Empty<FlowButtonLink>())\n//                    .Where(l => l.NextStepId.HasValue)\n//                    .Select(l => new FlowEdgeDto\n//                    {\n//                        FromNodeId = step.Id.ToString(),\n//                        ToNodeId = l.NextStepId!.Value.ToString(),\n//                        SourceHandle = l.ButtonText\n//                    }))\n//                .ToList();\n\n//            return new SaveVisualFlowDto\n//            {\n//                FlowName = flow.FlowName,\n//                IsPublished = flow.IsPublished,\n//                Nodes = nodes,\n//                Edges = edges\n//            };\n//        }\n\n//        public async Task<ResponseResult> DeleteFlowAsync(Guid flowId, Guid businessId, string deletedBy)\n//        {\n//            // Load flow with children so we can remove in the right order\n//            var flow = await _context.CTAFlowConfigs\n//                .Include(f => f.Steps)\n//                    .ThenInclude(s => s.ButtonLinks)\n//                .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId);\n\n//            if (flow == null)\n//                return ResponseResult.ErrorInfo(\"‚ùå Flow not found or does not belong to you.\");\n\n//            // Is this flow used by any active campaign?\n//            var inUseQuery = _context.Campaigns\n//                .Where(c => c.BusinessId == businessId &&\n//                            !c.IsDeleted &&\n//                            c.CTAFlowConfigId == flowId);\n\n//            var inUseCount = await inUseQuery.CountAsync();\n//            if (inUseCount > 0)\n//            {\n//                // Optional: show a few campaign names in the error for the UI\n//                var sample = await inUseQuery\n//                    .OrderByDescending(c => c.CreatedAt)\n//                    .Select(c => new { c.Id, c.Name, c.Status })\n//                    .Take(5)\n//                    .ToListAsync();\n\n//                Log.Warning(\"‚ùå Delete flow blocked. Flow {FlowId} is used by {Count} campaigns: {@Sample}\",\n//                    flowId, inUseCount, sample);\n\n//                return ResponseResult.ErrorInfo(\n//                    $\"‚ùå Cannot delete. This flow is attached to {inUseCount} campaign(s). \" +\n//                    $\"Delete those campaigns first.\"\n//                );\n//            }\n\n//            // Safe to remove: delete children first, then the flow\n//            foreach (var step in flow.Steps)\n//                _context.FlowButtonLinks.RemoveRange(step.ButtonLinks);\n\n//            _context.CTAFlowSteps.RemoveRange(flow.Steps);\n//            _context.CTAFlowConfigs.Remove(flow);\n\n//            await _context.SaveChangesAsync();\n//            return ResponseResult.SuccessInfo(\"‚úÖ Flow deleted.\");\n//        }\n\n\n//        public async Task<List<VisualFlowSummaryDto>> GetAllPublishedFlowsAsync(Guid businessId)\n//        {\n//            return await _context.CTAFlowConfigs\n//                .Where(f => f.BusinessId == businessId && f.IsPublished)\n//                .OrderByDescending(f => f.CreatedAt)\n//                .Select(f => new VisualFlowSummaryDto\n//                {\n//                    Id = f.Id,\n//                    FlowName = f.FlowName,\n//                    IsPublished = f.IsPublished,\n//                    CreatedAt = f.CreatedAt\n//                })\n//                .ToListAsync();\n//        }\n\n//        public async Task<List<VisualFlowSummaryDto>> GetAllDraftFlowsAsync(Guid businessId)\n//        {\n//            return await _context.CTAFlowConfigs\n//                .Where(f => f.BusinessId == businessId && !f.IsPublished && f.IsActive)\n//                .OrderByDescending(f => f.CreatedAt)\n//                .Select(f => new VisualFlowSummaryDto\n//                {\n//                    Id = f.Id,\n//                    FlowName = f.FlowName,\n//                    CreatedAt = f.CreatedAt,\n//                    IsPublished = f.IsPublished\n//                })\n//                .ToListAsync();\n//        }\n\n//        public async Task<ResponseResult> ExecuteFollowUpStepAsync(Guid businessId, CTAFlowStep? currentStep, string recipientNumber)\n//        {\n//            // Log.Information(\"üöÄ Executing follow-up for BusinessId: {BusinessId}, CurrentStepId: {StepId}\", businessId);\n//            if (currentStep == null)\n//            {\n//                Log.Warning(\"‚ö†Ô∏è Cannot execute follow-up. Current step is null.\");\n//                return ResponseResult.ErrorInfo(\"Current step not found.\");\n//            }\n\n//            // üß† Step: Look through all button links for a valid NextStepId\n//            var nextLink = currentStep.ButtonLinks.FirstOrDefault(link => link.NextStepId != null);\n\n//            if (nextLink == null)\n//            {\n//                Log.Information(\"‚ÑπÔ∏è No NextStepId defined in any ButtonLinks for StepId: {StepId}\", currentStep.Id);\n//                return ResponseResult.SuccessInfo(\"No follow-up step to execute.\");\n//            }\n\n//            // üîç Fetch the next step using new logic (via CTAFlowConfig + Steps)\n//            // 1Ô∏è‚É£ Try to resolve with smart condition check\n//            var followUpStep = await GetChainedStepAsync(businessId, nextLink.NextStepId, null, null);\n\n//            if (followUpStep == null)\n//            {\n//                Log.Warning(\"‚ùå Follow-up step skipped due to condition mismatch ‚Üí StepId: {StepId}\", nextLink.NextStepId);\n\n//                // 2Ô∏è‚É£ Optional fallback: Try same flow ‚Üí Any step without conditions\n//                var flow = await _context.CTAFlowConfigs\n//                    .Include(f => f.Steps)\n//                    .FirstOrDefaultAsync(f => f.BusinessId == businessId && f.IsPublished);\n\n//                followUpStep = flow?.Steps\n//                    .Where(s => string.IsNullOrEmpty(s.RequiredTag) && string.IsNullOrEmpty(s.RequiredSource))\n//                    .OrderBy(s => s.StepOrder)\n//                    .FirstOrDefault();\n\n//                if (followUpStep != null)\n//                {\n//                    Log.Information(\"üîÅ Fallback step selected ‚Üí StepId: {StepId}, Template: {Template}\",\n//                        followUpStep.Id, followUpStep.TemplateToSend);\n//                }\n//                else\n//                {\n//                    Log.Warning(\"üö´ No suitable fallback found in flow. Skipping follow-up.\");\n//                    return ResponseResult.SuccessInfo(\"No matching follow-up step based on user context.\");\n//                }\n//            }\n\n\n//            // üì® Send the follow-up message using the TemplateToSend field\n//            try\n//            {\n//                var template = followUpStep.TemplateToSend;\n\n//                Log.Information(\"üì§ Sending follow-up message ‚Üí Template: {Template}, To: {Recipient}\", template, recipientNumber);\n\n//                // üß™ Replace this with actual message engine call\n//                var sendDto = new SimpleTemplateMessageDto\n//                {\n//                    RecipientNumber = recipientNumber,\n//                    TemplateName = template,\n//                    TemplateParameters = new List<string>() // Add dynamic params later if needed\n//                };\n\n//                var sendResult = await _messageEngineService\n//     .SendTemplateMessageSimpleAsync(businessId, sendDto);\n\n//                if (!sendResult.Success)\n//                {\n//                    Log.Warning(\"‚ùå Follow-up message send failed ‚Üí {Template}\", template);\n//                    return ResponseResult.ErrorInfo(\"Follow-up send failed.\", sendResult.ErrorMessage);\n//                }\n\n\n//                return ResponseResult.SuccessInfo($\"Follow-up message sent using template: {template}\", null, sendResult.RawResponse);\n\n//            }\n//            catch (Exception ex)\n//            {\n//                Log.Error(ex, \"‚ùå Error sending follow-up message for StepId: {StepId}\", followUpStep.Id);\n//                return ResponseResult.ErrorInfo(\"Failed to send follow-up.\");\n//            }\n//        }\n//        public Task<CTAFlowStep?> GetChainedStepAsync(Guid businessId, Guid? nextStepId)\n//        {\n//            return GetChainedStepAsync(businessId, nextStepId, null, null); // Forward to full logic\n//        }\n\n//        // ‚úÖ Extended logic with condition check (Tag + Source)\n//        public async Task<CTAFlowStep?> GetChainedStepAsync(\n//            Guid businessId,\n//            Guid? nextStepId,\n//            TrackingLog? trackingLog = null,\n//            Contact? contact = null)\n//        {\n//            if (nextStepId == null)\n//            {\n//                Log.Information(\"‚ÑπÔ∏è No NextStepId provided ‚Äî skipping follow-up.\");\n//                return null;\n//            }\n\n//            try\n//            {\n//                var flow = await _context.CTAFlowConfigs\n//                    .Include(f => f.Steps)\n//                    .FirstOrDefaultAsync(f =>\n//                        f.BusinessId == businessId &&\n//                        f.Steps.Any(s => s.Id == nextStepId));\n\n//                if (flow == null)\n//                {\n//                    Log.Warning(\"‚ö†Ô∏è No flow found containing NextStepId: {NextStepId} for business: {BusinessId}\", nextStepId, businessId);\n//                    return null;\n//                }\n\n//                var followUpStep = flow.Steps.FirstOrDefault(s => s.Id == nextStepId);\n\n//                if (followUpStep == null)\n//                {\n//                    Log.Warning(\"‚ùå Step matched in flow but not found in step list: {NextStepId}\", nextStepId);\n//                    return null;\n//                }\n\n//                // ‚úÖ Check RequiredTag / Source match\n//                if (trackingLog != null)\n//                {\n//                    var isMatch = StepMatchingHelper.IsStepMatched(followUpStep, trackingLog, contact);\n\n//                    if (!isMatch)\n//                    {\n//                        Log.Information(\"üö´ Step {StepId} skipped due to condition mismatch [Tag: {Tag}, Source: {Source}]\",\n//                            followUpStep.Id, followUpStep.RequiredTag, followUpStep.RequiredSource);\n//                        return null;\n//                    }\n//                }\n\n//                Log.Information(\"‚úÖ Follow-up step found and matched ‚Üí StepId: {StepId}, Template: {Template}\",\n//                    followUpStep.Id, followUpStep.TemplateToSend);\n\n//                return followUpStep;\n//            }\n//            catch (Exception ex)\n//            {\n//                Log.Error(ex, \"‚ùå Exception while fetching chained step for NextStepId: {NextStepId}\", nextStepId);\n//                throw;\n//            }\n//        }\n\n//        // ‚úÖ Optional helper for resolving from TrackingLogId\n//        public async Task<CTAFlowStep?> GetChainedStepWithContextAsync(\n//            Guid businessId,\n//            Guid? nextStepId,\n//            Guid? trackingLogId)\n//        {\n//            var log = await _context.TrackingLogs\n//                .Include(l => l.Contact)\n//                    .ThenInclude(c => c.ContactTags)\n//                        .ThenInclude(ct => ct.Tag)\n//                .FirstOrDefaultAsync(l => l.Id == trackingLogId);\n\n//            return await GetChainedStepAsync(businessId, nextStepId, log, log?.Contact);\n//        }\n\n\n//        public async Task<ResponseResult> ExecuteVisualFlowAsync(Guid businessId, Guid startStepId, Guid trackingLogId, Guid? campaignSendLogId)\n//        {\n//            try\n//            {\n//                Log.Information(\"üö¶ Executing Visual Flow ‚Üí StepId: {StepId} | TrackingLogId: {TrackingLogId}\", startStepId, trackingLogId);\n\n//                // ‚îÄ‚îÄ local helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n//                static string ResolveGreeting(string? profileName, string? contactName)\n//                {\n//                    var s = (profileName ?? contactName)?.Trim();\n//                    return string.IsNullOrEmpty(s) ? \"there\" : s;\n//                }\n//                static void EnsureArgsLength(List<string> args, int slot1Based)\n//                {\n//                    while (args.Count < slot1Based) args.Add(string.Empty);\n//                }\n//                // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n//                var log = await _context.TrackingLogs\n//                    .Include(l => l.Contact)\n//                        .ThenInclude(c => c.ContactTags)\n//                            .ThenInclude(ct => ct.Tag)\n//                    .FirstOrDefaultAsync(l => l.Id == trackingLogId);\n\n//                if (log == null)\n//                {\n//                    Log.Warning(\"‚ùå TrackingLog not found for ID: {TrackingLogId}\", trackingLogId);\n//                    return ResponseResult.ErrorInfo(\"Tracking log not found.\");\n//                }\n\n//                var step = await GetChainedStepAsync(businessId, startStepId, log, log?.Contact);\n\n//                if (step == null)\n//                {\n//                    Log.Warning(\"‚ùå No flow step matched or conditions failed ‚Üí StepId: {StepId}\", startStepId);\n//                    return ResponseResult.ErrorInfo(\"Step conditions not satisfied.\");\n//                }\n\n//                // ‚úÖ Build profile-aware args for this step (used for text templates)\n//                var args = new List<string>();\n//                if (step.UseProfileName && step.ProfileNameSlot is int slot && slot >= 1)\n//                {\n//                    // Prefer the already-loaded contact on the tracking log; fallback to DB lookup\n//                    var contact = log.Contact ?? await _context.Contacts\n//                        .AsNoTracking()\n//                        .FirstOrDefaultAsync(c => c.BusinessId == businessId && c.PhoneNumber == (log.ContactPhone ?? \"\"));\n\n//                    var greet = ResolveGreeting(contact?.ProfileName, contact?.Name);\n//                    EnsureArgsLength(args, slot);\n//                    args[slot - 1] = greet; // 1-based slot -> 0-based index\n//                }\n\n//                ResponseResult sendResult;\n\n//                // This switch block remains unchanged, except we pass args for text templates\n//                switch (step.TemplateType?.ToLower())\n//                {\n//                    case \"image_template\":\n//                        var imageDto = new ImageTemplateMessageDto\n//                        {\n//                            BusinessId = businessId,\n//                            RecipientNumber = log.ContactPhone ?? \"\",\n//                            TemplateName = step.TemplateToSend,\n//                            LanguageCode = \"en_US\"\n//                            // If your image templates support body params, you can also pass args here.\n//                        };\n//                        sendResult = await _messageEngineService.SendImageTemplateMessageAsync(imageDto, businessId);\n//                        break;\n\n//                    case \"text_template\":\n//                    default:\n//                        var textDto = new SimpleTemplateMessageDto\n//                        {\n//                            RecipientNumber = log.ContactPhone ?? \"\",\n//                            TemplateName = step.TemplateToSend,\n//                            TemplateParameters = args // ‚úÖ inject ProfileName here when configured\n//                        };\n//                        sendResult = await _messageEngineService.SendTemplateMessageSimpleAsync(businessId, textDto);\n//                        break;\n//                }\n\n//                // ‚úÖ 2. SAVE the new ID to the log\n//                var executionLog = new FlowExecutionLog\n//                {\n//                    Id = Guid.NewGuid(),\n//                    BusinessId = businessId,\n//                    StepId = step.Id,\n//                    FlowId = step.CTAFlowConfigId,\n//                    CampaignSendLogId = campaignSendLogId, // <-- THE NEW VALUE IS SAVED HERE\n//                    TrackingLogId = trackingLogId,\n//                    ContactPhone = log.ContactPhone,\n//                    TriggeredByButton = step.TriggerButtonText,\n//                    TemplateName = step.TemplateToSend,\n//                    TemplateType = step.TemplateType,\n//                    Success = sendResult.Success,\n//                    ErrorMessage = sendResult.ErrorMessage,\n//                    RawResponse = sendResult.RawResponse,\n//                    ExecutedAt = DateTime.UtcNow\n//                };\n\n//                _context.FlowExecutionLogs.Add(executionLog);\n//                await _context.SaveChangesAsync();\n\n//                if (sendResult.Success)\n//                {\n//                    Log.Information(\"‚úÖ Flow step executed ‚Üí Template: {Template} sent to {To}\", step.TemplateToSend, log.ContactPhone);\n//                }\n//                else\n//                {\n//                    Log.Warning(\"‚ùå Failed to send template from flow ‚Üí {Reason}\", sendResult.ErrorMessage);\n//                }\n\n//                return ResponseResult.SuccessInfo($\"Flow step executed. Sent: {sendResult.Success}\", null, sendResult.RawResponse);\n//            }\n//            catch (Exception ex)\n//            {\n//                Log.Error(ex, \"‚ùå Exception during ExecuteVisualFlowAsync()\");\n//                return ResponseResult.ErrorInfo(\"Internal error during flow execution.\");\n//            }\n//        }\n\n//        public async Task<FlowButtonLink?> GetLinkAsync(Guid flowId, Guid sourceStepId, short buttonIndex)\n//        {\n//            return await _context.FlowButtonLinks\n//                 .Where(l => l.CTAFlowStepId == sourceStepId\n//              && l.NextStepId != null\n//              && l.Step.CTAFlowConfigId == flowId\n//              && l.ButtonIndex == buttonIndex)\n//                .SingleOrDefaultAsync();\n\n//        }\n//        //public async Task<IReadOnlyList<AttachedCampaignDto>> GetAttachedCampaignsAsync(Guid flowId, Guid businessId)\n//        //{\n//        //    return await _context.Campaigns\n//        //        .Where(c => c.BusinessId == businessId\n//        //                    && !c.IsDeleted\n//        //                    && c.CTAFlowConfigId == flowId)\n//        //        .OrderByDescending(c => c.CreatedAt)\n//        //        .Select(c => new AttachedCampaignDto(c.Id, c.Name, c.Status, c.ScheduledAt))\n//        //        .ToListAsync();\n//        //}\n\n//        public async Task<ResponseResult> GetVisualFlowAsync(Guid flowId, Guid businessId)\n//        {\n//            try\n//            {\n//                // Load the flow + steps + button links (no tracking for view)\n//                var flow = await _context.CTAFlowConfigs\n//                    .AsNoTracking()\n//                    .Where(f => f.IsActive && f.BusinessId == businessId && f.Id == flowId)\n//                    .Select(f => new\n//                    {\n//                        f.Id,\n//                        f.FlowName,\n//                        f.IsPublished,\n//                        Steps = _context.CTAFlowSteps\n//                            .Where(s => s.CTAFlowConfigId == f.Id)\n//                            .OrderBy(s => s.StepOrder)\n//                            .Select(s => new\n//                            {\n//                                s.Id,\n//                                s.StepOrder,\n//                                s.TemplateToSend,\n//                                s.TemplateType,\n//                                s.TriggerButtonText,\n//                                s.TriggerButtonType,\n//                                s.PositionX,\n//                                s.PositionY,\n//                                s.UseProfileName,\n//                                s.ProfileNameSlot,\n//                                Buttons = _context.FlowButtonLinks\n//                                    .Where(b => b.CTAFlowStepId == s.Id)\n//                                    .OrderBy(b => b.ButtonIndex)\n//                                    .Select(b => new\n//                                    {\n//                                        b.ButtonText,\n//                                        b.ButtonType,\n//                                        b.ButtonSubType,\n//                                        b.ButtonValue,\n//                                        b.ButtonIndex,\n//                                        b.NextStepId\n//                                    })\n//                                    .ToList()\n//                            })\n//                            .ToList()\n//                    })\n//                    .FirstOrDefaultAsync();\n\n//                if (flow == null)\n//                {\n//                    return ResponseResult.ErrorInfo(\"Flow not found.\");\n//                }\n\n//                // Map to FE shape\n//                var nodes = flow.Steps.Select(s => new\n//                {\n//                    id = s.Id.ToString(), // node id = step id\n//                    positionX = s.PositionX ?? 0,\n//                    positionY = s.PositionY ?? 0,\n//                    templateName = s.TemplateToSend,\n//                    templateType = s.TemplateType,\n//                    triggerButtonText = s.TriggerButtonText ?? string.Empty,\n//                    triggerButtonType = s.TriggerButtonType ?? \"cta\",\n//                    requiredTag = string.Empty,       // not used in your model; keep empty\n//                    requiredSource = string.Empty,    // not used; keep empty\n//                    useProfileName = s.UseProfileName,\n//                    profileNameSlot = (s.ProfileNameSlot.HasValue && s.ProfileNameSlot.Value > 0) ? s.ProfileNameSlot.Value : 1,\n//                    buttons = s.Buttons.Select(b => new\n//                    {\n//                        text = b.ButtonText,\n//                        type = b.ButtonType,\n//                        subType = b.ButtonSubType,\n//                        value = b.ButtonValue,\n//                        targetNodeId = b.NextStepId == Guid.Empty ? null : b.NextStepId.ToString(),\n//                        index = (int)(b.ButtonIndex)\n//                    })\n//                });\n\n//                // Build edges from button links\n//                var edges = flow.Steps\n//                    .SelectMany(s => s.Buttons\n//                        .Where(b => b.NextStepId != Guid.Empty)\n//                        .Select(b => new\n//                        {\n//                            fromNodeId = s.Id.ToString(),\n//                            toNodeId = b.NextStepId.ToString(),\n//                            sourceHandle = b.ButtonText // label/handle = button text\n//                        }));\n\n//                var payload = new\n//                {\n//                    flowName = flow.FlowName,\n//                    isPublished = flow.IsPublished,\n//                    nodes,\n//                    edges\n//                };\n\n//                return ResponseResult.SuccessInfo(\"Flow loaded.\", payload);\n//            }\n//            catch (Exception ex)\n//            {\n//                Log.Error(ex, \"‚ùå Exception while loading visual flow {FlowId}\", flowId);\n//                return ResponseResult.ErrorInfo(\"Internal error while loading flow.\");\n//            }\n//        }\n//        public async Task<IReadOnlyList<AttachedCampaignDto>> GetAttachedCampaignsAsync(Guid flowId, Guid businessId)\n//        {\n//            // base query: attached, non-deleted\n//            var q = _context.Campaigns\n//                .Where(c => c.BusinessId == businessId && !c.IsDeleted && c.CTAFlowConfigId == flowId);\n\n//            // earliest send per campaign\n//            var firstSends = await _context.CampaignSendLogs\n//                .Where(s => s.BusinessId == businessId && s.CampaignId != Guid.Empty)\n//                .GroupBy(s => s.CampaignId)\n//                .Select(g => new { CampaignId = g.Key, FirstSentAt = (DateTime?)g.Min(s => s.CreatedAt) })\n//                .ToListAsync();\n\n//            var firstSendMap = firstSends.ToDictionary(x => x.CampaignId, x => x.FirstSentAt);\n\n//            var list = await q\n//                .OrderByDescending(c => c.CreatedAt)\n//                .Select(c => new\n//                {\n//                    c.Id,\n//                    c.Name,\n//                    c.Status,\n//                    c.ScheduledAt,\n//                    c.CreatedAt,\n//                    c.CreatedBy\n//                })\n//                .ToListAsync();\n\n//            return list.Select(x => new AttachedCampaignDto(\n//                x.Id,\n//                x.Name,\n//                x.Status,\n//                x.ScheduledAt,\n//                x.CreatedAt,\n//                x.CreatedBy,\n//                firstSendMap.TryGetValue(x.Id, out var ts) ? ts : null\n//            )).ToList();\n//        }\n//        public async Task<bool> HardDeleteFlowIfUnusedAsync(Guid flowId, Guid businessId)\n//        {\n//            // Load flow + children\n//            var flow = await _context.CTAFlowConfigs\n//                .Include(f => f.Steps)\n//                    .ThenInclude(s => s.ButtonLinks)\n//                .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId);\n\n//            if (flow is null) return false;\n\n//            // Guard: any active campaign still attached?\n//            var attached = await _context.Campaigns\n//                .Where(c => c.BusinessId == businessId\n//                            && !c.IsDeleted\n//                            && c.CTAFlowConfigId == flowId)\n//                .Select(c => c.Id)\n//                .Take(1)\n//                .AnyAsync();\n\n//            if (attached) return false;\n\n//            // Hard delete (children first; FK-safe)\n//            foreach (var step in flow.Steps)\n//                _context.FlowButtonLinks.RemoveRange(step.ButtonLinks);\n\n//            _context.CTAFlowSteps.RemoveRange(flow.Steps);\n//            _context.CTAFlowConfigs.Remove(flow);\n\n//            await _context.SaveChangesAsync();\n//            return true;\n//        }\n\n//        //public async Task<FlowUpdateResult> UpdateVisualFlowAsync(Guid flowId, SaveVisualFlowDto dto, Guid businessId, string user)\n//        //{\n//        //    var flow = await _context.CTAFlowConfigs\n//        //        .Include(f => f.Steps)\n//        //            .ThenInclude(s => s.ButtonLinks)\n//        //        .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId);\n\n//        //    if (flow is null)\n//        //        return new FlowUpdateResult { Status = \"notFound\", Message = \"Flow not found.\" };\n\n//        //    var attached = await _context.Campaigns\n//        //        .Where(c => !c.IsDeleted && c.BusinessId == businessId && c.CTAFlowConfigId == flowId)\n//        //        .Select(c => new { c.Id, c.Name, c.Status, c.ScheduledAt, c.CreatedAt, c.CreatedBy })\n//        //        .ToListAsync();\n\n//        //    if (flow.IsPublished && attached.Count > 0)\n//        //    {\n//        //        return new FlowUpdateResult\n//        //        {\n//        //            Status = \"requiresFork\",\n//        //            Message = \"This flow is published and attached to campaign(s). Create a new draft version.\",\n//        //            Campaigns = attached\n//        //        };\n//        //    }\n\n//        //    var needsRepublish = flow.IsPublished && attached.Count == 0;\n//        //    if (needsRepublish) flow.IsPublished = false; // flip to draft during edit\n\n//        //    // wipe & rebuild steps (simplest and consistent with your builder payload)\n//        //    _context.FlowButtonLinks.RemoveRange(flow.Steps.SelectMany(s => s.ButtonLinks));\n//        //    _context.CTAFlowSteps.RemoveRange(flow.Steps);\n//        //    await _context.SaveChangesAsync();\n\n//        //    flow.FlowName = string.IsNullOrWhiteSpace(dto.FlowName) ? flow.FlowName : dto.FlowName.Trim();\n//        //    flow.UpdatedAt = DateTime.UtcNow;\n\n//        //    var newSteps = new List<CTAFlowStep>();\n//        //    var nodeIdToNewGuid = new Dictionary<string, Guid>();\n\n//        //    // 1) create steps with new IDs but keep mapping from incoming node.Id\n//        //    foreach (var n in dto.Nodes)\n//        //    {\n//        //        var stepId = Guid.TryParse(n.Id, out var parsed) ? parsed : Guid.NewGuid();\n//        //        nodeIdToNewGuid[n.Id] = stepId;\n\n//        //        var s = new CTAFlowStep\n//        //        {\n//        //            Id = stepId,\n//        //            CTAFlowConfigId = flow.Id,\n//        //            TemplateToSend = n.TemplateName ?? string.Empty,\n//        //            TemplateType = n.TemplateType,\n//        //            TriggerButtonText = n.TriggerButtonText ?? \"\",\n//        //            TriggerButtonType = n.TriggerButtonType ?? \"\",\n//        //            StepOrder = 0,\n//        //            RequiredTag = n.RequiredTag,\n//        //            RequiredSource = n.RequiredSource,\n//        //            PositionX = n.PositionX,\n//        //            PositionY = n.PositionY,\n//        //            UseProfileName = n.UseProfileName,\n//        //            ProfileNameSlot = n.ProfileNameSlot\n//        //        };\n\n//        //        s.ButtonLinks = (n.Buttons ?? new List<LinkButtonDto>())\n//        //            .Select((b, idx) => new FlowButtonLink\n//        //            {\n//        //                Id = Guid.NewGuid(),\n//        //                CTAFlowStepId = s.Id,\n//        //                Step = s,\n//        //                ButtonText = b.Text ?? \"\",\n//        //                ButtonType = b.Type ?? \"QUICK_REPLY\",\n//        //                ButtonSubType = b.SubType ?? \"\",\n//        //                ButtonValue = b.Value ?? \"\",\n//        //                ButtonIndex = (short)(b.Index >= 0 ? b.Index : idx),\n//        //                NextStepId = string.IsNullOrWhiteSpace(b.TargetNodeId) ? null :\n//        //                             (Guid.TryParse(b.TargetNodeId, out var t) ? t : null)\n//        //            }).ToList();\n\n//        //        newSteps.Add(s);\n//        //    }\n\n//        //    flow.Steps = newSteps;\n//        //    await _context.SaveChangesAsync();\n\n//        //    return new FlowUpdateResult { Status = \"ok\", NeedsRepublish = needsRepublish };\n//        //}\n\n//        //public async Task<bool> PublishFlowAsync(Guid flowId, Guid businessId, string user)\n//        //{\n//        //    var flow = await _context.CTAFlowConfigs\n//        //        .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId);\n\n//        //    if (flow is null) return false;\n\n//        //    // sanity: basic validation can be added here (has steps, etc.)\n//        //    flow.IsPublished = true;\n//        //    flow.UpdatedAt = DateTime.UtcNow;\n//        //    await _context.SaveChangesAsync();\n//        //    return true;\n//        //}\n\n//        // ---------- FORK (create draft copy) ----------\n//        //public async Task<Guid> ForkFlowAsync(Guid flowId, Guid businessId, string user)\n//        //{\n//        //    var src = await _context.CTAFlowConfigs\n//        //        .Include(f => f.Steps)\n//        //            .ThenInclude(s => s.ButtonLinks)\n//        //        .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId);\n\n//        //    if (src is null) return Guid.Empty;\n\n//        //    var dst = new CTAFlowConfig\n//        //    {\n//        //        Id = Guid.NewGuid(),\n//        //        BusinessId = src.BusinessId,\n//        //        FlowName = src.FlowName + \" (copy)\",\n//        //        IsActive = true,\n//        //        IsPublished = false, // new draft\n//        //        CreatedAt = DateTime.UtcNow,\n//        //        CreatedBy = user,\n//        //        UpdatedAt = DateTime.UtcNow\n//        //    };\n\n//        //    var oldToNew = new Dictionary<Guid, Guid>();\n\n//        //    // Clone steps first\n//        //    foreach (var s in src.Steps)\n//        //    {\n//        //        var nsId = Guid.NewGuid();\n//        //        oldToNew[s.Id] = nsId;\n\n//        //        var ns = new CTAFlowStep\n//        //        {\n//        //            Id = nsId,\n//        //            CTAFlowConfigId = dst.Id,\n//        //            TriggerButtonText = s.TriggerButtonText,\n//        //            TriggerButtonType = s.TriggerButtonType,\n//        //            TemplateToSend = s.TemplateToSend,\n//        //            TemplateType = s.TemplateType,\n//        //            StepOrder = s.StepOrder,\n//        //            RequiredTag = s.RequiredTag,\n//        //            RequiredSource = s.RequiredSource,\n//        //            PositionX = s.PositionX,\n//        //            PositionY = s.PositionY,\n//        //            UseProfileName = s.UseProfileName,\n//        //            ProfileNameSlot = s.ProfileNameSlot,\n//        //            ButtonLinks = new List<FlowButtonLink>()\n//        //        };\n\n//        //        dst.Steps.Add(ns);\n//        //    }\n\n//        //    // Clone links and rewire targets if possible\n//        //    foreach (var s in src.Steps)\n//        //    {\n//        //        var ns = dst.Steps.First(x => x.Id == oldToNew[s.Id]);\n//        //        foreach (var b in s.ButtonLinks.OrderBy(x => x.ButtonIndex))\n//        //        {\n//        //            ns.ButtonLinks.Add(new FlowButtonLink\n//        //            {\n//        //                Id = Guid.NewGuid(),\n//        //                CTAFlowStepId = ns.Id,\n//        //                Step = ns,\n//        //                ButtonText = b.ButtonText,\n//        //                ButtonType = b.ButtonType,\n//        //                ButtonSubType = b.ButtonSubType,\n//        //                ButtonValue = b.ButtonValue,\n//        //                ButtonIndex = b.ButtonIndex,\n//        //                NextStepId = b.NextStepId.HasValue && oldToNew.ContainsKey(b.NextStepId.Value)\n//        //                    ? oldToNew[b.NextStepId.Value]\n//        //                    : null\n//        //            });\n//        //        }\n//        //    }\n\n//        //    _context.CTAFlowConfigs.Add(dst);\n//        //    await _context.SaveChangesAsync();\n//        //    return dst.Id;\n//        //}\n\n\n//    }\n//}\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Services/ExtrackAllFiles.bat",
      "sha256": "3d14ccc013b9fd82ff0759820acc71da52821878e664cb4daa9418062278e799",
      "language": "bat",
      "size": 922,
      "content": "@echo off\nREM This script will find all files and output their name and content into one file.\nREM The output file will be named [FolderName]_AllFileDump.txt.\n\nREM Get the current folder's name and set it as the output file name with the custom suffix\nfor %%I in (\"%cd%\") do set \"outputFile=%%~nI_AllFileDump.txt\"\n\nREM Clear the output file to start fresh\n> \"%outputFile%\" (echo Folder and File Content Report)\necho. >> \"%outputFile%\"\n\nREM Loop through all files in the current directory and subdirectories\nfor /R . %%F in (*.*) do (\n    echo ====================================================== >> \"%outputFile%\"\n    echo FILE: %%F >> \"%outputFile%\"\n    echo ====================================================== >> \"%outputFile%\"\n    echo. >> \"%outputFile%\"\n    type \"%%F\" >> \"%outputFile%\" 2>nul\n    echo. >> \"%outputFile%\"\n    echo. >> \"%outputFile%\"\n)\n\necho Finished! All content has been extracted to %outputFile%"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Services/FlowExecutionLogger.cs",
      "sha256": "3b6ad9e86868b5c7f7f39fca399fb43a86693d088ae149f2ea9d14b7adb7a933",
      "language": "csharp",
      "size": 6046,
      "content": "// üìÑ xbytechat-api/Features/CTAFlowBuilder/Services/FlowExecutionLogger.cs\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Serilog;\nusing xbytechat.api; // ‚úÖ Needed so AppDbContext is in scope\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Services\n{\n    /// <summary>\n    /// Default implementation of IFlowExecutionLogger.\n    /// Writes origin-tagged rows into FlowExecutionLogs.\n    /// </summary>\n    public sealed class FlowExecutionLogger : IFlowExecutionLogger\n    {\n        private readonly AppDbContext _db;\n\n        public FlowExecutionLogger(AppDbContext db)\n        {\n            _db = db ?? throw new ArgumentNullException(nameof(db));\n        }\n\n        public async Task LogStepAsync(FlowExecutionContext context, CancellationToken cancellationToken = default)\n        {\n            if (context == null) throw new ArgumentNullException(nameof(context));\n\n            try\n            {\n                var entity = new FlowExecutionLog\n                {\n                    Id = Guid.NewGuid(),\n\n                    // core identifiers\n                    RunId = context.RunId,\n                    BusinessId = context.BusinessId,\n                    FlowId = context.FlowId,\n                    StepId = context.StepId,\n                    StepName = context.StepName ?? string.Empty,\n\n                    // origin + linkage\n                    Origin = context.Origin,\n                    CampaignId = context.CampaignId,\n                    AutoReplyFlowId = context.AutoReplyFlowId,\n                    CampaignSendLogId = context.CampaignSendLogId,\n                    TrackingLogId = context.TrackingLogId,\n                    MessageLogId = context.MessageLogId,\n\n                    // contact + button context\n                    ContactPhone = context.ContactPhone,\n                    TriggeredByButton = context.TriggeredByButton,\n                    ButtonIndex = context.ButtonIndex,\n\n                    // template / execution info\n                    TemplateName = context.TemplateName,\n                    TemplateType = context.TemplateType,\n                    Success = context.Success,\n                    ErrorMessage = context.ErrorMessage,\n                    RawResponse = context.RawResponse,\n\n                    // timestamps + tracing\n                    ExecutedAt = context.ExecutedAtUtc ?? DateTime.UtcNow,\n                    RequestId = context.RequestId\n                };\n\n                _db.FlowExecutionLogs.Add(entity);\n                await _db.SaveChangesAsync(cancellationToken);\n            }\n            catch (Exception ex)\n            {\n                // Never let logging failures break main flow execution.\n                Log.Error(\n                    ex,\n                    \"‚ùå Failed to write FlowExecutionLog | Biz={BusinessId} Origin={Origin} Flow={FlowId} Step={StepId}\",\n                    context.BusinessId,\n                    context.Origin,\n                    context.FlowId,\n                    context.StepId\n                );\n            }\n        }\n    }\n}\n\n\n//using System;\n//using System.Threading;\n//using System.Threading.Tasks;\n//using Serilog;\n//using xbytechat.api.Features.AutoReplyBuilder.DTOs;\n//using xbytechat.api.Features.CTAFlowBuilder.Models;\n\n//namespace xbytechat.api.Features.CTAFlowBuilder.Services\n//{\n//    /// <summary>\n//    /// Default implementation of IFlowExecutionLogger.\n//    /// Writes origin-tagged rows into FlowExecutionLogs.\n//    /// </summary>\n//    public sealed class FlowExecutionLogger : IFlowExecutionLogger\n//    {\n//        private readonly AppDbContext _db;\n\n//        public FlowExecutionLogger(AppDbContext db)\n//        {\n//            _db = db ?? throw new ArgumentNullException(nameof(db));\n//        }\n\n//        public async Task LogStepAsync(FlowExecutionContext context, CancellationToken cancellationToken = default)\n//        {\n//            if (context == null) throw new ArgumentNullException(nameof(context));\n\n//            try\n//            {\n//                var entity = new FlowExecutionLog\n//                {\n//                    Id = Guid.NewGuid(),\n//                    RunId = context.RunId,\n//                    BusinessId = context.BusinessId,\n//                    StepId = context.StepId,\n//                    StepName = context.StepName ?? string.Empty,\n//                    FlowId = context.FlowId,\n//                    Origin = context.Origin,\n//                    CampaignId = context.CampaignId,\n//                    AutoReplyFlowId = context.AutoReplyFlowId,\n//                    CampaignSendLogId = context.CampaignSendLogId,\n//                    TrackingLogId = context.TrackingLogId,\n//                    ContactPhone = context.ContactPhone,\n//                    TriggeredByButton = context.TriggeredByButton,\n//                    TemplateName = context.TemplateName,\n//                    TemplateType = context.TemplateType,\n//                    Success = context.Success,\n//                    ErrorMessage = context.ErrorMessage,\n//                    RawResponse = context.RawResponse,\n//                    ExecutedAt = context.ExecutedAtUtc ?? DateTime.UtcNow,\n//                    MessageLogId = context.MessageLogId,\n//                    ButtonIndex = context.ButtonIndex,\n//                    RequestId = context.RequestId\n//                };\n\n//                _db.FlowExecutionLogs.Add(entity);\n//                await _db.SaveChangesAsync(cancellationToken);\n//            }\n//            catch (Exception ex)\n//            {\n//                // We never want logging failures to break the main flow.\n//                Log.Error(ex,\n//                    \"‚ùå Failed to write FlowExecutionLog | Biz={BusinessId} Origin={Origin} Flow={FlowId} Step={StepId}\",\n//                    context.BusinessId,\n//                    context.Origin,\n//                    context.FlowId,\n//                    context.StepId);\n//            }\n//        }\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Services/FlowRuntimeService.cs",
      "sha256": "87e5773c5b57ae97fec595755c6c89b12b7c48122ec7925bf2a926dcfe591f57",
      "language": "csharp",
      "size": 50764,
      "content": "using Microsoft.EntityFrameworkCore;\nusing System.Text.Json;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.Features.Webhooks.Services.Processors;\nusing xbytechat.api.WhatsAppSettings.Services;\nusing xbytechat_api.WhatsAppSettings.Services;\nusing xbytechat.api.Features.CustomeApi.Services;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Services\n{\n    public class FlowRuntimeService : IFlowRuntimeService\n    {\n        private readonly AppDbContext _dbContext;\n        private readonly IMessageEngineService _messageEngineService;\n        private readonly IWhatsAppTemplateFetcherService _templateFetcherService;\n        private readonly ILogger<FlowRuntimeService> _logger;\n        private readonly ICtaJourneyPublisher _ctaPublisher;\n        private readonly IWhatsAppSettingsService _whatsAppSettingsService;\n        private readonly IWhatsAppSenderService _whatsAppSenderService;\n        public FlowRuntimeService(\n            AppDbContext dbContext,\n            IMessageEngineService messageEngineService,\n            IWhatsAppTemplateFetcherService templateFetcherService,\n            ILogger<FlowRuntimeService> logger,\n            ICtaJourneyPublisher ctaPublisher,\n            IWhatsAppSettingsService whatsAppSettingsService,\n            IWhatsAppSenderService whatsAppSenderService)\n        {\n            _dbContext = dbContext;\n            _messageEngineService = messageEngineService;\n            _templateFetcherService = templateFetcherService;\n            _logger = logger;\n            _ctaPublisher = ctaPublisher;\n            _whatsAppSettingsService = whatsAppSettingsService;\n            _whatsAppSenderService = whatsAppSenderService;\n        }\n\n        private static string ResolveGreeting(string? profileName, string? contactName)\n        {\n            var s = (profileName ?? contactName)?.Trim();\n            return string.IsNullOrEmpty(s) ? \"there\" : s;\n        }\n        private static void EnsureArgsLength(List<string> args, int slot1Based)\n        {\n            while (args.Count < slot1Based) args.Add(string.Empty);\n        }\n\n        // NOTE: Keep provider normalization consistent across settings/campaign/webhook/runtime paths.\n        // Also enforces \"META\" -> \"META_CLOUD\" canonical mapping.\n        private static string NormalizeProvider(string? raw)\n        {\n            if (string.IsNullOrWhiteSpace(raw)) return string.Empty;\n            var p = raw.Trim().Replace(\"-\", \"_\").Replace(\" \", \"_\").ToUpperInvariant();\n            return p == \"META\" ? \"META_CLOUD\" : p;\n        }\n\n\n        //public async Task<NextStepResult> ExecuteNextAsync(NextStepContext context)\n        //{\n        //    try\n        //    {\n        //        // ‚îÄ‚îÄ local helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n        //        string ResolveGreeting(string? profileName, string? contactName)\n        //        {\n        //            var s = (profileName ?? contactName)?.Trim();\n        //            return string.IsNullOrEmpty(s) ? \"there\" : s;\n        //        }\n        //        void EnsureArgsLength(List<string> args, int slot1Based)\n        //        {\n        //            while (args.Count < slot1Based) args.Add(string.Empty);\n        //        }\n        //        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n        //        // 1) URL-only buttons ‚Üí no WA send, just record and return redirect\n        //        if (context.ClickedButton != null &&\n        //            context.ClickedButton.ButtonType?.Equals(\"URL\", StringComparison.OrdinalIgnoreCase) == true)\n        //        {\n        //            _dbContext.FlowExecutionLogs.Add(new FlowExecutionLog\n        //            {\n        //                Id = Guid.NewGuid(),\n        //                BusinessId = context.BusinessId,\n        //                FlowId = context.FlowId,\n        //                StepId = context.SourceStepId,\n        //                StepName = \"URL_REDIRECT\",\n        //                MessageLogId = context.MessageLogId,\n        //                ButtonIndex = context.ButtonIndex,\n        //                ContactPhone = context.ContactPhone,\n        //                Success = true,\n        //                ExecutedAt = DateTime.UtcNow,\n        //                RequestId = context.RequestId\n        //            });\n        //            await _dbContext.SaveChangesAsync();\n\n        //            return new NextStepResult { Success = true, RedirectUrl = context.ClickedButton.ButtonValue };\n\n\n\n        //        }\n\n        //        // 2) Load next step in the same flow (no dedupe/loop guard ‚Äî always proceed)\n        //        var targetStep = await _dbContext.CTAFlowSteps\n        //            .Include(s => s.ButtonLinks)\n        //            .FirstOrDefaultAsync(s => s.Id == context.TargetStepId &&\n        //                                      s.CTAFlowConfigId == context.FlowId);\n\n        //        if (targetStep == null)\n        //            return new NextStepResult { Success = false, Error = \"Target step not found.\" };\n\n        //        if (string.IsNullOrWhiteSpace(targetStep.TemplateToSend))\n        //            return new NextStepResult { Success = false, Error = \"Target step has no template assigned.\" };\n\n        //        var templateName = targetStep.TemplateToSend.Trim();\n\n        //        // 3) Preflight the template (resolve language and catch 132001 early)\n        //        var meta = await _templateFetcherService.GetTemplateByNameAsync(\n        //            context.BusinessId, templateName, includeButtons: true);\n\n        //        if (meta == null)\n        //        {\n        //            _dbContext.FlowExecutionLogs.Add(new FlowExecutionLog\n        //            {\n        //                Id = Guid.NewGuid(),\n        //                BusinessId = context.BusinessId,\n        //                FlowId = context.FlowId,\n        //                StepId = targetStep.Id,\n        //                StepName = templateName,\n        //                MessageLogId = null,\n        //                ButtonIndex = context.ButtonIndex,\n        //                ContactPhone = context.ContactPhone,\n        //                Success = false,\n        //                ErrorMessage = $\"Template '{templateName}' not found for this WABA.\",\n        //                RawResponse = null,\n        //                ExecutedAt = DateTime.UtcNow,\n        //                RequestId = context.RequestId\n        //            });\n        //            await _dbContext.SaveChangesAsync();\n\n        //            return new NextStepResult { Success = false, Error = $\"Template '{templateName}' not found or not approved.\" };\n        //        }\n\n        //        var languageCode = string.IsNullOrWhiteSpace(meta.Language) ? \"en_US\" : meta.Language;\n\n        //        // 3.1) üî• Determine sender with failsafes (NO early return for missing context)\n        //        var provider = (context.Provider ?? string.Empty).Trim().ToUpperInvariant();\n        //        var phoneNumberId = context.PhoneNumberId;\n\n        //        // If provider missing/invalid ‚Üí try active WhatsAppSettings (fast path)\n        //        if (provider != \"PINNACLE\" && provider != \"META_CLOUD\")\n        //        {\n        //            var w = await _dbContext.WhatsAppSettings\n        //                .AsNoTracking()\n        //                .Where(x => x.BusinessId == context.BusinessId && x.IsActive)\n        //                .OrderByDescending(x => x.UpdatedAt ?? x.CreatedAt)\n        //                .FirstOrDefaultAsync();\n\n        //            if (w != null)\n        //            {\n        //                provider = (w.Provider ?? \"\").Trim().ToUpperInvariant();\n        //                if (string.IsNullOrWhiteSpace(phoneNumberId))\n        //                    phoneNumberId = null; // legacy WhatsAppSettings.PhoneNumberId is intentionally not used (ESU split)\n        //            }\n        //        }\n\n        //        // If still missing provider ‚Üí hard resolve via numbers table\n        //        if (provider != \"PINNACLE\" && provider != \"META_CLOUD\")\n        //        {\n        //            var pn = await _dbContext.WhatsAppPhoneNumbers\n        //                .AsNoTracking()\n        //                .Where(n => n.BusinessId == context.BusinessId && n.IsActive)\n        //                .OrderByDescending(n => n.IsDefault)\n        //                .ThenBy(n => n.WhatsAppBusinessNumber)\n        //                .Select(n => new { n.Provider, n.PhoneNumberId })\n        //                .FirstOrDefaultAsync();\n\n        //            if (pn != null)\n        //            {\n        //                provider = (pn.Provider ?? \"\").Trim().ToUpperInvariant();\n        //                if (string.IsNullOrWhiteSpace(phoneNumberId))\n        //                    phoneNumberId = pn.PhoneNumberId;\n        //            }\n        //        }\n\n        //        if (provider != \"PINNACLE\" && provider != \"META_CLOUD\")\n        //            return new NextStepResult { Success = false, Error = \"No active WhatsApp sender configured (provider could not be resolved).\" };\n\n        //        // Ensure we have a sender id\n        //        if (string.IsNullOrWhiteSpace(phoneNumberId))\n        //        {\n        //            phoneNumberId = await _dbContext.WhatsAppPhoneNumbers\n        //                .AsNoTracking()\n        //                .Where(n => n.BusinessId == context.BusinessId\n        //                            && n.IsActive\n        //                            && n.Provider.ToUpper() == provider)\n        //                .OrderByDescending(n => n.IsDefault)\n        //                .ThenBy(n => n.WhatsAppBusinessNumber)\n        //                .Select(n => n.PhoneNumberId)\n        //                .FirstOrDefaultAsync();\n\n        //            if (string.IsNullOrWhiteSpace(phoneNumberId))\n        //                return new NextStepResult { Success = false, Error = \"Missing PhoneNumberId (no default sender configured for this provider).\" };\n        //        }\n\n        //        // ‚îÄ‚îÄ Profile-name injection into body params (optional) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n        //        var args = new List<string>();\n        //        if (targetStep.UseProfileName && targetStep.ProfileNameSlot is int slot && slot >= 1)\n        //        {\n        //            var contact = await _dbContext.Contacts\n        //                .AsNoTracking()\n        //                .FirstOrDefaultAsync(c => c.BusinessId == context.BusinessId\n        //                                          && c.PhoneNumber == context.ContactPhone);\n\n        //            var greet = ResolveGreeting(contact?.ProfileName, contact?.Name);\n        //            EnsureArgsLength(args, slot);\n        //            args[slot - 1] = greet;\n        //        }\n\n        //        var components = new List<object>();\n        //        if (args.Count > 0)\n        //        {\n        //            components.Add(new\n        //            {\n        //                type = \"body\",\n        //                parameters = args.Select(a => new { type = \"text\", text = a ?? string.Empty }).ToList()\n        //            });\n        //        }\n        //        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n        //        var payload = new\n        //        {\n        //            messaging_product = \"whatsapp\",\n        //            to = context.ContactPhone,\n        //            type = \"template\",\n        //            template = new\n        //            {\n        //                name = templateName,\n        //                language = new { code = languageCode },\n        //                components\n        //            }\n        //        };\n\n        //        // 4) SEND (explicit provider + sender) ‚Äî always attempt the POST\n        //        _logger.LogInformation(\"‚û°Ô∏è SEND-INTENT flow={Flow} step={Step} tmpl={T} to={To} provider={Prov}/{Pnid}\",\n        //            context.FlowId, targetStep.Id, templateName, context.ContactPhone, provider, phoneNumberId);\n\n        //        var sendResult = await _messageEngineService.SendPayloadAsync(\n        //            context.BusinessId,\n        //            provider,               // explicit\n        //            payload,\n        //            phoneNumberId           // explicit\n        //        );\n\n        //        // 5) Snapshot buttons for robust click mapping later\n        //        string? buttonBundleJson = null;\n        //        if (targetStep.ButtonLinks?.Count > 0)\n        //        {\n        //            var bundle = targetStep.ButtonLinks\n        //                .OrderBy(b => b.ButtonIndex)\n        //                .Select(b => new\n        //                {\n        //                    i = b.ButtonIndex,\n        //                    t = b.ButtonText ?? \"\",\n        //                    ty = b.ButtonType ?? \"QUICK_REPLY\",\n        //                    v = b.ButtonValue ?? \"\",\n        //                    ns = b.NextStepId\n        //                })\n        //                .ToList();\n\n        //            buttonBundleJson = JsonSerializer.Serialize(bundle);\n        //        }\n\n        //        // 6) Write MessageLog\n        //        var messageLog = new MessageLog\n        //        {\n        //            Id = Guid.NewGuid(),\n        //            BusinessId = context.BusinessId,\n        //            RecipientNumber = context.ContactPhone,\n        //            CTAFlowConfigId = context.FlowId,\n        //            CTAFlowStepId = targetStep.Id,\n        //            FlowVersion = context.Version,\n        //            Source = \"flow\",\n        //            RefMessageId = context.MessageLogId,\n        //            CreatedAt = DateTime.UtcNow,\n        //            Status = sendResult.Success ? \"Sent\" : \"Failed\",\n        //            MessageId = sendResult.MessageId,\n        //            ErrorMessage = sendResult.ErrorMessage,\n        //            RawResponse = sendResult.RawResponse,\n        //            ButtonBundleJson = buttonBundleJson,\n        //            MessageContent = templateName,\n        //            SentAt = sendResult.Success ? DateTime.UtcNow : (DateTime?)null\n        //        };\n\n        //        _dbContext.MessageLogs.Add(messageLog);\n\n        //        // 7) Flow execution audit row\n        //        _dbContext.FlowExecutionLogs.Add(new FlowExecutionLog\n        //        {\n        //            Id = Guid.NewGuid(),\n        //            BusinessId = context.BusinessId,\n        //            FlowId = context.FlowId,\n        //            StepId = targetStep.Id,\n        //            StepName = templateName,\n        //            MessageLogId = messageLog.Id,\n        //            ButtonIndex = context.ButtonIndex,\n        //            ContactPhone = context.ContactPhone,\n        //            Success = sendResult.Success,\n        //            ErrorMessage = sendResult.ErrorMessage,\n        //            RawResponse = sendResult.RawResponse,\n        //            ExecutedAt = DateTime.UtcNow,\n        //            RequestId = context.RequestId\n        //        });\n\n        //        await _dbContext.SaveChangesAsync();\n\n        //        return new NextStepResult\n        //        {\n        //            Success = sendResult.Success,\n        //            Error = sendResult.ErrorMessage,\n        //            RedirectUrl = null\n        //        };\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        return new NextStepResult { Success = false, Error = ex.Message };\n        //    }\n        //}\n        public async Task<NextStepResult> ExecuteNextAsync(NextStepContext context)\n        {\n            // Capture state for exception logging + failure persistence (updated as we resolve sender/template).\n            var providerForLog = NormalizeProvider(context.Provider);\n            string? phoneNumberIdForLog = string.IsNullOrWhiteSpace(context.PhoneNumberId) ? null : context.PhoneNumberId!.Trim();\n            string? templateNameForLog = null;\n            Guid? targetStepIdForLog = context.TargetStepId;\n\n            try\n            {\n                // ‚îÄ‚îÄ local helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n                string ResolveGreeting(string? profileName, string? contactName)\n                {\n                    var s = (profileName ?? contactName)?.Trim();\n                    return string.IsNullOrEmpty(s) ? \"there\" : s;\n                }\n                void EnsureArgsLength(List<string> args, int slot1Based)\n                {\n                    while (args.Count < slot1Based) args.Add(string.Empty);\n                }\n                // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n                // 1) URL-only buttons ‚Üí no WA send, just record and return redirect\n                if (context.ClickedButton != null &&\n                    context.ClickedButton.ButtonType?.Equals(\"URL\", StringComparison.OrdinalIgnoreCase) == true)\n                {\n                    _dbContext.FlowExecutionLogs.Add(new FlowExecutionLog\n                    {\n                        Id = Guid.NewGuid(),\n                        BusinessId = context.BusinessId,\n                        FlowId = context.FlowId,\n                        StepId = context.SourceStepId,\n                        StepName = \"URL_REDIRECT\",\n                        MessageLogId = context.MessageLogId,\n                        ButtonIndex = context.ButtonIndex,\n                        ContactPhone = context.ContactPhone,\n                        Success = true,\n                        ExecutedAt = DateTime.UtcNow,\n                        RequestId = context.RequestId\n                    });\n                    await _dbContext.SaveChangesAsync();\n\n                    return new NextStepResult { Success = true, RedirectUrl = context.ClickedButton.ButtonValue };\n                }\n\n                // Helpful for webhook-click observability (may be null for non-click paths).\n                var clickedBtnText = context.ClickedButton?.ButtonText;\n\n                // 2) Load next step in the same flow\n                var targetStep = await _dbContext.CTAFlowSteps\n                    .Include(s => s.ButtonLinks)\n                    .FirstOrDefaultAsync(s => s.Id == context.TargetStepId &&\n                                              s.CTAFlowConfigId == context.FlowId);\n\n                if (targetStep == null)\n                {\n                    // NOTE: Added for ESU-era click-triggered flows so failures are observable (not silent).\n                    var err = \"Target step not found.\";\n                    _logger.LogWarning(\n                        \"CTAFlow ExecuteNextAsync failed: {Error} biz={Biz} flow={Flow} srcStep={Src} targetStep={Target} to={To} btnIdx={BtnIdx} btnText='{BtnText}' providerHint={Provider}/{PhoneNumberId}\",\n                        err, context.BusinessId, context.FlowId, context.SourceStepId, context.TargetStepId, context.ContactPhone, context.ButtonIndex, clickedBtnText, context.Provider, context.PhoneNumberId);\n\n                    await RecordFailureAsync(\n                        context,\n                        // TargetStepId is nullable; store failure against SourceStepId and include target in the error message/logs.\n                        stepId: context.SourceStepId,\n                        stepName: \"TARGET_STEP_NOT_FOUND\",\n                        error: err);\n\n                    return new NextStepResult { Success = false, Error = err };\n                }\n\n                if (string.IsNullOrWhiteSpace(targetStep.TemplateToSend))\n                {\n                    var err = \"Target step has no template assigned.\";\n                    _logger.LogWarning(\n                        \"CTAFlow ExecuteNextAsync failed: {Error} biz={Biz} flow={Flow} srcStep={Src} targetStep={Target} to={To} btnIdx={BtnIdx} btnText='{BtnText}' providerHint={Provider}/{PhoneNumberId}\",\n                        err, context.BusinessId, context.FlowId, context.SourceStepId, context.TargetStepId, context.ContactPhone, context.ButtonIndex, clickedBtnText, context.Provider, context.PhoneNumberId);\n\n                    await RecordFailureAsync(\n                        context,\n                        stepId: targetStep.Id,\n                        stepName: \"NO_TEMPLATE_ASSIGNED\",\n                        error: err);\n\n                    return new NextStepResult { Success = false, Error = err };\n                }\n\n                var templateName = targetStep.TemplateToSend.Trim();\n                templateNameForLog = templateName;\n                targetStepIdForLog = targetStep.Id;\n\n                // 3) Preflight the template (you can replace with a DB read later if desired)\n                var meta = await _templateFetcherService.GetTemplateByNameAsync(\n                    context.BusinessId, templateName, includeButtons: true);\n\n                if (meta == null)\n                {\n                    _dbContext.FlowExecutionLogs.Add(new FlowExecutionLog\n                    {\n                        Id = Guid.NewGuid(),\n                        BusinessId = context.BusinessId,\n                        FlowId = context.FlowId,\n                        StepId = targetStep.Id,\n                        StepName = templateName,\n                        MessageLogId = null,\n                        ButtonIndex = context.ButtonIndex,\n                        ContactPhone = context.ContactPhone,\n                        Success = false,\n                        ErrorMessage = $\"Template '{templateName}' not found for this WABA.\",\n                        RawResponse = null,\n                        ExecutedAt = DateTime.UtcNow,\n                        RequestId = context.RequestId\n                    });\n                    await _dbContext.SaveChangesAsync();\n\n                    return new NextStepResult { Success = false, Error = $\"Template '{templateName}' not found or not approved.\" };\n                }\n\n                var languageCode = string.IsNullOrWhiteSpace(meta.Language) ? \"en_US\" : meta.Language;\n\n                // 3.1) Sender resolution (single source of truth via DTO, with context overrides)\n                string provider = NormalizeProvider(context.Provider);\n                string? phoneNumberId = string.IsNullOrWhiteSpace(context.PhoneNumberId) ? null : context.PhoneNumberId!.Trim();\n                providerForLog = provider;\n                phoneNumberIdForLog = phoneNumberId;\n\n                if (provider != \"PINNACLE\" && provider != \"META_CLOUD\" || string.IsNullOrWhiteSpace(phoneNumberId))\n                {\n                    // Pull unified settings (provider + default phone for that provider)\n                    var wa = await _whatsAppSettingsService.GetSettingsByBusinessIdAsync(context.BusinessId);\n                    if (wa == null)\n                    {\n                        var err = \"No active WhatsApp settings found.\";\n                        _logger.LogWarning(\n                            \"CTAFlow ExecuteNextAsync failed: {Error} biz={Biz} flow={Flow} srcStep={Src} targetStep={Target} tmpl={T} to={To} btnIdx={BtnIdx} btnText='{BtnText}' providerHint={Provider}/{PhoneNumberId}\",\n                            err, context.BusinessId, context.FlowId, context.SourceStepId, context.TargetStepId, templateName, context.ContactPhone, context.ButtonIndex, clickedBtnText, context.Provider, context.PhoneNumberId);\n\n                        await RecordFailureAsync(context, stepId: targetStep.Id, stepName: templateName, error: err);\n                        return new NextStepResult { Success = false, Error = err };\n                    }\n\n                    // Context wins if valid, else fall back to DTO\n                    if (provider != \"PINNACLE\" && provider != \"META_CLOUD\")\n                    {\n                        var key = (wa.Provider ?? string.Empty).Trim().ToLowerInvariant();\n                        provider = key switch\n                        {\n                            \"meta\" => \"META_CLOUD\",\n                            \"meta_cloud\" => \"META_CLOUD\",\n                            \"meta-cloud\" => \"META_CLOUD\",\n                            \"meta cloud\" => \"META_CLOUD\",\n                            \"pinnacle\" => \"PINNACLE\",\n                            _ => NormalizeProvider(wa.Provider)\n                        };\n                        providerForLog = provider;\n                    }\n\n                    if (string.IsNullOrWhiteSpace(phoneNumberId))\n                    {\n                        // ESU constraint: PhoneNumberId must come ONLY from WhatsAppPhoneNumbers.\n                        // Never read WhatsAppSettings.PhoneNumberId (legacy column).\n                        var sender = await _whatsAppSenderService.ResolveDefaultSenderAsync(\n                            context.BusinessId,\n                            providerHint: provider,\n                            ct: default);\n\n                        if (!sender.Success)\n                        {\n                            var err = sender.Error ?? \"Failed to resolve WhatsApp sender.\";\n                            _logger.LogWarning(\n                                \"CTAFlow ExecuteNextAsync failed: {Error} biz={Biz} flow={Flow} srcStep={Src} targetStep={Target} tmpl={T} to={To} btnIdx={BtnIdx} btnText='{BtnText}' provider={Provider}\",\n                                err, context.BusinessId, context.FlowId, context.SourceStepId, context.TargetStepId, templateName, context.ContactPhone, context.ButtonIndex, clickedBtnText, provider);\n\n                            await RecordFailureAsync(context, stepId: targetStep.Id, stepName: templateName, error: err);\n                            return new NextStepResult { Success = false, Error = err };\n                        }\n\n                        // Keep provider stable if already known; if not known, align to the resolved sender provider.\n                        if (provider != \"PINNACLE\" && provider != \"META_CLOUD\" && !string.IsNullOrWhiteSpace(sender.Provider))\n                            provider = NormalizeProvider(sender.Provider);\n\n                        phoneNumberId = sender.PhoneNumberId;\n                        providerForLog = provider;\n                        phoneNumberIdForLog = phoneNumberId;\n                    }\n                }\n\n                if (provider != \"PINNACLE\" && provider != \"META_CLOUD\")\n                {\n                    var err = \"No active WhatsApp sender configured (provider could not be resolved).\";\n                    _logger.LogWarning(\n                        \"CTAFlow ExecuteNextAsync failed: {Error} biz={Biz} flow={Flow} srcStep={Src} targetStep={Target} tmpl={T} to={To} btnIdx={BtnIdx} btnText='{BtnText}' provider={Provider}/{PhoneNumberId}\",\n                        err, context.BusinessId, context.FlowId, context.SourceStepId, context.TargetStepId, templateName, context.ContactPhone, context.ButtonIndex, clickedBtnText, provider, phoneNumberId);\n\n                    await RecordFailureAsync(context, stepId: targetStep.Id, stepName: templateName, error: err);\n                    return new NextStepResult { Success = false, Error = err };\n                }\n\n                if (provider == \"META_CLOUD\" && string.IsNullOrWhiteSpace(phoneNumberId))\n                {\n                    // This should only happen if WhatsAppPhoneNumbers has no active sender; log + persist to avoid silent click failures.\n                    var err = \"Missing PhoneNumberId (no default Meta sender configured).\";\n                    _logger.LogWarning(\n                        \"CTAFlow ExecuteNextAsync failed: {Error} biz={Biz} flow={Flow} srcStep={Src} targetStep={Target} tmpl={T} to={To} btnIdx={BtnIdx} btnText='{BtnText}' provider={Provider}\",\n                        err, context.BusinessId, context.FlowId, context.SourceStepId, context.TargetStepId, templateName, context.ContactPhone, context.ButtonIndex, clickedBtnText, provider);\n\n                    await RecordFailureAsync(context, stepId: targetStep.Id, stepName: templateName, error: err);\n                    return new NextStepResult { Success = false, Error = err };\n                }\n\n                // ‚îÄ‚îÄ BODY placeholder resolution (static step params + optional profile-name injection) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n                // CTA flows run from webhook clicks and do not have campaign-time personalization context, so\n                // we persist body parameter values per step (CTAFlowSteps.BodyParamsJson).\n                // NOTE: TemplateMetadataDto.PlaceholderCount includes button tokens too; use WhatsAppTemplates.BodyVarCount.\n                var bodyVarCount = await ResolveBodyVarCountAsync(context.BusinessId, templateName, meta);\n                var args = new List<string>(Math.Max(0, bodyVarCount));\n                if (bodyVarCount > 0)\n                {\n                    args.AddRange(Enumerable.Repeat(string.Empty, bodyVarCount));\n                    var stored = TryParseBodyParams(targetStep.BodyParamsJson);\n                    for (var i = 0; i < bodyVarCount && i < stored.Count; i++)\n                        args[i] = (stored[i] ?? string.Empty).Trim();\n                }\n\n                if (targetStep.UseProfileName && targetStep.ProfileNameSlot is int slot && slot >= 1)\n                {\n                    if (bodyVarCount <= 0)\n                    {\n                        _logger.LogWarning(\n                            \"CTAFlow profile-name slot configured but template has no body vars biz={Biz} flow={Flow} step={Step} tmpl={T} slot={Slot}\",\n                            context.BusinessId, context.FlowId, targetStep.Id, templateName, slot);\n                    }\n                    else if (slot <= bodyVarCount)\n                    {\n                        var contact = await _dbContext.Contacts\n                            .AsNoTracking()\n                            .FirstOrDefaultAsync(c => c.BusinessId == context.BusinessId\n                                                      && c.PhoneNumber == context.ContactPhone);\n\n                        var greet = ResolveGreeting(contact?.ProfileName, contact?.Name);\n                        args[slot - 1] = greet;\n                    }\n                }\n\n                if (bodyVarCount > 0 && args.Any(a => string.IsNullOrWhiteSpace(a)))\n                {\n                    var err = $\"Template '{templateName}' requires {bodyVarCount} body parameter(s), but one or more values are missing.\";\n                    _logger.LogWarning(\n                        \"CTAFlow ExecuteNextAsync failed: {Error} biz={Biz} flow={Flow} srcStep={Src} targetStep={Target} tmpl={T} to={To} btnIdx={BtnIdx} btnText='{BtnText}'\",\n                        err, context.BusinessId, context.FlowId, context.SourceStepId, targetStep.Id, templateName, context.ContactPhone, context.ButtonIndex, clickedBtnText);\n\n                    await RecordFailureAsync(context, stepId: targetStep.Id, stepName: templateName, error: err);\n                    return new NextStepResult { Success = false, Error = err };\n                }\n\n                var components = new List<object>();\n\n                // ‚îÄ‚îÄ Media header support (phase 1) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n                // CTA flow runtime previously sent only BODY components. For templates whose header kind is\n                // image/video/document, WhatsApp (Meta Cloud) requires a header component with a media link.\n                // Phase 2: HeaderMediaUrl is persisted per step (CTAFlowSteps.HeaderMediaUrl). We still accept an\n                // execution-context override (e.g., campaign/runtime) and keep a temporary fallback from clicked\n                // button value to avoid breaking older flows until the UI starts populating the step field.\n                var headerKind = (meta.HeaderKind ?? \"none\").Trim().ToLowerInvariant();\n                var requiresMediaHeader = headerKind is \"image\" or \"video\" or \"document\";\n                string? headerMediaUrl = string.IsNullOrWhiteSpace(context.HeaderMediaUrl) ? null : context.HeaderMediaUrl!.Trim();\n\n                if (requiresMediaHeader && string.IsNullOrWhiteSpace(headerMediaUrl))\n                {\n                    // Phase 2: Prefer persisted per-step configuration.\n                    headerMediaUrl = string.IsNullOrWhiteSpace(targetStep.HeaderMediaUrl) ? null : targetStep.HeaderMediaUrl!.Trim();\n                }\n\n                if (requiresMediaHeader && string.IsNullOrWhiteSpace(headerMediaUrl))\n                {\n                    // Temporary fallback: treat a clicked button value that looks like a URL as the media link.\n                    // This is best-effort for backward compatibility; UI should persist HeaderMediaUrl on the step.\n                    if (TryGetHttpUrl(context.ClickedButton?.ButtonValue, out var fallbackUrl))\n                    {\n                        headerMediaUrl = fallbackUrl;\n                        _logger.LogInformation(\n                            \"CTAFlow header media URL sourced from clicked button value biz={Biz} flow={Flow} srcStep={Src} targetStep={Target} tmpl={T} kind={Kind}\",\n                            context.BusinessId, context.FlowId, context.SourceStepId, targetStep.Id, templateName, headerKind);\n                    }\n                }\n\n                if (requiresMediaHeader)\n                {\n                    if (!string.Equals(provider, \"META_CLOUD\", StringComparison.OrdinalIgnoreCase))\n                    {\n                        var err = $\"CTAFlow media-header templates are not supported for provider '{provider}' yet.\";\n                        _logger.LogWarning(\n                            \"CTAFlow ExecuteNextAsync failed: {Error} biz={Biz} flow={Flow} srcStep={Src} targetStep={Target} tmpl={T} to={To} btnIdx={BtnIdx} btnText='{BtnText}' provider={Prov}\",\n                            err, context.BusinessId, context.FlowId, context.SourceStepId, targetStep.Id, templateName, context.ContactPhone, context.ButtonIndex, clickedBtnText, provider);\n\n                        await RecordFailureAsync(context, stepId: targetStep.Id, stepName: templateName, error: err);\n                        return new NextStepResult { Success = false, Error = err };\n                    }\n\n                    if (string.IsNullOrWhiteSpace(headerMediaUrl))\n                    {\n                        var err = $\"Template '{templateName}' requires a {headerKind} header, but no HeaderMediaUrl was provided.\";\n                        _logger.LogWarning(\n                            \"CTAFlow ExecuteNextAsync failed: {Error} biz={Biz} flow={Flow} srcStep={Src} targetStep={Target} tmpl={T} to={To} btnIdx={BtnIdx} btnText='{BtnText}' provider={Prov}/{Pnid}\",\n                            err, context.BusinessId, context.FlowId, context.SourceStepId, targetStep.Id, templateName, context.ContactPhone, context.ButtonIndex, clickedBtnText, provider, phoneNumberId);\n\n                        await RecordFailureAsync(context, stepId: targetStep.Id, stepName: templateName, error: err);\n                        return new NextStepResult { Success = false, Error = err };\n                    }\n\n                    object mediaParam = headerKind switch\n                    {\n                        \"image\" => new { type = \"image\", image = new { link = headerMediaUrl } },\n                        \"video\" => new { type = \"video\", video = new { link = headerMediaUrl } },\n                        \"document\" => new { type = \"document\", document = new { link = headerMediaUrl } },\n                        _ => new { type = \"text\", text = \"\" } // should not happen due to requiresMediaHeader guard\n                    };\n\n                    components.Add(new\n                    {\n                        type = \"header\",\n                        parameters = new object[] { mediaParam }\n                    });\n                }\n                // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n                if (bodyVarCount > 0)\n                {\n                    components.Add(new\n                    {\n                        type = \"body\",\n                        parameters = args.Select(a => new { type = \"text\", text = a ?? string.Empty }).ToList()\n                    });\n                }\n                // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n                // ‚îÄ‚îÄ Dynamic URL button parameters (Meta Cloud) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n                // WhatsApp Cloud requires \"button\" components when a template has dynamic URL buttons.\n                // We store per-step values in CTAFlowSteps.UrlButtonParamsJson (index 0 => button index \"0\").\n                if (string.Equals(provider, \"META_CLOUD\", StringComparison.OrdinalIgnoreCase) &&\n                    meta.ButtonParams is { Count: > 0 })\n                {\n                    var storedUrlParams = TryParseUrlButtonParams(targetStep.UrlButtonParamsJson);\n\n                    var buttons = meta.ButtonParams\n                        .OrderBy(b => b.Index)\n                        .Take(3)\n                        .ToList();\n\n                    foreach (var b in buttons)\n                    {\n                        var idx = b.Index;\n                        if (idx < 0 || idx > 2) continue;\n\n                        var isUrl =\n                            string.Equals(b.Type, \"URL\", StringComparison.OrdinalIgnoreCase) ||\n                            string.Equals(b.SubType, \"url\", StringComparison.OrdinalIgnoreCase);\n                        if (!isUrl) continue;\n\n                        var mask = (b.ParameterValue ?? string.Empty).Trim();\n                        var isDynamic = mask.Contains(\"{{\", StringComparison.Ordinal);\n                        if (!isDynamic) continue;\n\n                        var param = (idx < storedUrlParams.Count ? storedUrlParams[idx] : null) ?? string.Empty;\n                        param = param.Trim();\n\n                        if (string.IsNullOrWhiteSpace(param))\n                        {\n                            var err = $\"Template '{templateName}' requires a dynamic URL parameter for button {idx + 1} ('{b.Text}').\";\n                            _logger.LogWarning(\n                                \"CTAFlow ExecuteNextAsync failed: {Error} biz={Biz} flow={Flow} srcStep={Src} targetStep={Target} tmpl={T} to={To} btnIdx={BtnIdx} btnText='{BtnText}' provider={Prov}/{Pnid} urlBtnIdx={UrlIdx} urlBtnText='{UrlText}'\",\n                                err, context.BusinessId, context.FlowId, context.SourceStepId, targetStep.Id, templateName, context.ContactPhone, context.ButtonIndex, clickedBtnText, provider, phoneNumberId, idx, b.Text);\n\n                            await RecordFailureAsync(context, stepId: targetStep.Id, stepName: templateName, error: err);\n                            return new NextStepResult { Success = false, Error = err };\n                        }\n\n                        components.Add(new\n                        {\n                            type = \"button\",\n                            sub_type = \"url\",\n                            index = idx.ToString(),\n                            parameters = new object[]\n                            {\n                                new { type = \"text\", text = param }\n                            }\n                        });\n                    }\n                }\n\n\n                var payload = new\n                {\n                    messaging_product = \"whatsapp\",\n                    to = context.ContactPhone,\n                    type = \"template\",\n                    template = new\n                    {\n                        name = templateName,\n                        language = new { code = languageCode },\n                        components\n                    }\n                };\n\n                // 4) SEND (explicit provider + sender)\n                _logger.LogInformation(\"‚û°Ô∏è SEND-INTENT flow={Flow} step={Step} tmpl={T} to={To} provider={Prov}/{Pnid}\",\n                    context.FlowId, targetStep.Id, templateName, context.ContactPhone, provider, phoneNumberId);\n\n                var sendResult = await _messageEngineService.SendPayloadAsync(\n                    context.BusinessId,\n                    provider,\n                    payload,\n                    phoneNumberId\n                );\n\n                if (!sendResult.Success)\n                {\n                    // NOTE: Added so webhook-driven flows can't fail silently; DB already captures Status=Failed below.\n                    _logger.LogWarning(\n                        \"CTAFlow send failed biz={Biz} flow={Flow} srcStep={Src} targetStep={Target} tmpl={T} to={To} btnIdx={BtnIdx} btnText='{BtnText}' provider={Prov}/{Pnid} err={Err}\",\n                        context.BusinessId, context.FlowId, context.SourceStepId, targetStep.Id, templateName, context.ContactPhone, context.ButtonIndex, clickedBtnText, provider, phoneNumberId, sendResult.ErrorMessage);\n                }\n\n                // 5) Snapshot buttons for click mapping\n                string? buttonBundleJson = null;\n                if (targetStep.ButtonLinks?.Count > 0)\n                {\n                    var bundle = targetStep.ButtonLinks\n                        .OrderBy(b => b.ButtonIndex)\n                        .Select(b => new\n                        {\n                            i = b.ButtonIndex,\n                            t = b.ButtonText ?? \"\",\n                            ty = b.ButtonType ?? \"QUICK_REPLY\",\n                            v = b.ButtonValue ?? \"\",\n                            ns = b.NextStepId\n                        })\n                        .ToList();\n\n                    buttonBundleJson = JsonSerializer.Serialize(bundle);\n                }\n\n                // 6) MessageLog\n                var messageLog = new MessageLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = context.BusinessId,\n                    RecipientNumber = context.ContactPhone,\n                    CTAFlowConfigId = context.FlowId,\n                    CTAFlowStepId = targetStep.Id,\n                    FlowVersion = context.Version,\n                    Source = \"flow\",\n                    RefMessageId = context.MessageLogId,\n                    CreatedAt = DateTime.UtcNow,\n                    Status = sendResult.Success ? \"Sent\" : \"Failed\",\n                    MessageId = sendResult.MessageId,\n                    ErrorMessage = sendResult.ErrorMessage,\n                    RawResponse = sendResult.RawResponse,\n                    ButtonBundleJson = buttonBundleJson,\n                    MessageContent = templateName,\n                    SentAt = sendResult.Success ? DateTime.UtcNow : (DateTime?)null\n                };\n\n                _dbContext.MessageLogs.Add(messageLog);\n\n                // 7) Flow execution audit\n                _dbContext.FlowExecutionLogs.Add(new FlowExecutionLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = context.BusinessId,\n                    FlowId = context.FlowId,\n                    StepId = targetStep.Id,\n                    StepName = templateName,\n                    MessageLogId = messageLog.Id,\n                    ButtonIndex = context.ButtonIndex,\n                    ContactPhone = context.ContactPhone,\n                    Success = sendResult.Success,\n                    ErrorMessage = sendResult.ErrorMessage,\n                    RawResponse = sendResult.RawResponse,\n                    ExecutedAt = DateTime.UtcNow,\n                    RequestId = context.RequestId\n                });\n\n                await _dbContext.SaveChangesAsync();\n\n                return new NextStepResult\n                {\n                    Success = sendResult.Success,\n                    Error = sendResult.ErrorMessage\n                };\n            }\n            catch (Exception ex)\n            {\n                var err = ex.Message;\n                _logger.LogError(ex,\n                    \"CTAFlow ExecuteNextAsync exception biz={Biz} flow={Flow} srcStep={Src} targetStep={Target} tmpl={T} to={To} btnIdx={BtnIdx} provider={Provider}/{PhoneNumberId}\",\n                    context.BusinessId, context.FlowId, context.SourceStepId, targetStepIdForLog, templateNameForLog, context.ContactPhone, context.ButtonIndex, providerForLog, phoneNumberIdForLog);\n\n                await RecordFailureAsync(\n                    context,\n                    stepId: targetStepIdForLog ?? context.SourceStepId,\n                    stepName: templateNameForLog ?? \"EXCEPTION\",\n                    error: err);\n\n                return new NextStepResult { Success = false, Error = err };\n            }\n        }\n\n        private static readonly System.Text.RegularExpressions.Regex PositionalToken =\n            new(@\"\\{\\{\\s*\\d+\\s*\\}\\}\", System.Text.RegularExpressions.RegexOptions.Compiled); // {{1}}, {{ 2 }}, etc.\n\n        private static readonly System.Text.RegularExpressions.Regex NamedToken =\n            new(@\"\\{\\{\\s*\\}\\}\", System.Text.RegularExpressions.RegexOptions.Compiled);        // {{}} (NAMED format slot)\n\n        private static int CountBodyTokensFlexible(string? text)\n        {\n            if (string.IsNullOrEmpty(text)) return 0;\n            return PositionalToken.Matches(text).Count + NamedToken.Matches(text).Count;\n        }\n\n        private static List<string> TryParseBodyParams(string? json)\n        {\n            if (string.IsNullOrWhiteSpace(json)) return new List<string>();\n            try\n            {\n                var list = JsonSerializer.Deserialize<List<string>>(json);\n                return list ?? new List<string>();\n            }\n            catch\n            {\n                return new List<string>();\n            }\n        }\n\n        private static List<string> TryParseUrlButtonParams(string? json)\n        {\n            if (string.IsNullOrWhiteSpace(json)) return new List<string>();\n            try\n            {\n                var list = JsonSerializer.Deserialize<List<string>>(json);\n                return list ?? new List<string>();\n            }\n            catch\n            {\n                return new List<string>();\n            }\n        }\n\n        private async Task<int> ResolveBodyVarCountAsync(Guid businessId, string templateName, xbytechat.api.WhatsAppSettings.DTOs.TemplateMetadataDto meta)\n        {\n            try\n            {\n                // WhatsAppTemplates.BodyVarCount is the canonical body placeholder count (buttons are separate).\n                var count = await _dbContext.WhatsAppTemplates\n                    .AsNoTracking()\n                    .Where(t => t.BusinessId == businessId && t.IsActive && t.Name == templateName)\n                    .OrderByDescending(t => t.UpdatedAt)\n                    .Select(t => t.BodyVarCount)\n                    .FirstOrDefaultAsync();\n\n                if (count > 0) return count;\n            }\n            catch (Exception ex)\n            {\n                // Best-effort; fall back to counting tokens in the template preview body.\n                _logger.LogWarning(ex,\n                    \"CTAFlow ResolveBodyVarCountAsync failed, falling back to token count biz={Biz} tmpl={T}\",\n                    businessId, templateName);\n            }\n\n            return CountBodyTokensFlexible(meta?.Body);\n        }\n\n        private static bool TryGetHttpUrl(string? maybeUrl, out string url)\n        {\n            url = string.Empty;\n            if (string.IsNullOrWhiteSpace(maybeUrl)) return false;\n            if (!Uri.TryCreate(maybeUrl.Trim(), UriKind.Absolute, out var u)) return false;\n            if (!string.Equals(u.Scheme, Uri.UriSchemeHttp, StringComparison.OrdinalIgnoreCase) &&\n                !string.Equals(u.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n                return false;\n            url = u.ToString();\n            return true;\n        }\n\n        private async Task RecordFailureAsync(NextStepContext context, Guid stepId, string stepName, string error)\n        {\n            try\n            {\n                _dbContext.FlowExecutionLogs.Add(new FlowExecutionLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = context.BusinessId,\n                    FlowId = context.FlowId,\n                    StepId = stepId,\n                    StepName = stepName,\n                    MessageLogId = context.MessageLogId == Guid.Empty ? null : context.MessageLogId,\n                    ButtonIndex = context.ButtonIndex,\n                    ContactPhone = context.ContactPhone,\n                    Success = false,\n                    ErrorMessage = error,\n                    ExecutedAt = DateTime.UtcNow,\n                    RequestId = context.RequestId\n                });\n\n                await _dbContext.SaveChangesAsync();\n            }\n            catch (Exception ex)\n            {\n                // NOTE: Do not throw from webhook runtime; log only (best-effort observability).\n                _logger.LogError(ex,\n                    \"CTAFlow RecordFailureAsync failed biz={Biz} flow={Flow} step={Step} to={To} error={Err}\",\n                    context.BusinessId, context.FlowId, stepId, context.ContactPhone, error);\n            }\n        }\n\n\n    }\n}\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Services/ICtaFlowRuntimeService.cs",
      "sha256": "ba7f6a253e9b5e3af197db5060f0879595cef09e7e8e7e796b9fae4028c0f284",
      "language": "csharp",
      "size": 1518,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CTAFlowBuilder.DTOs;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Services\n{\n    /// <summary>\n    /// Runtime engine for executing CTA flows (journey flows).\n    /// \n    /// This is the single entry point used by other modules:\n    /// - AutoReply (CTA_FLOW nodes)\n    /// - Campaigns (button-click journeys)\n    /// - Future JourneyBot / Inbox actions\n    /// </summary>\n    public interface ICtaFlowRuntimeService\n    {\n        /// <summary>\n        /// Starts a CTA flow journey for a given contact.\n        /// </summary>\n        /// <param name=\"businessId\">Tenant business id.</param>\n        /// <param name=\"contactId\">Contact id in CRM (if known).</param>\n        /// <param name=\"contactPhone\">Contact phone number (WhatsApp).</param>\n        /// <param name=\"configId\">CTA flow config id (visual flow definition).</param>\n        /// <param name=\"origin\">Where this journey was triggered from.</param>\n        /// <param name=\"autoReplyFlowId\">\n        /// Optional AutoReplyFlow id when origin = AutoReply; otherwise null.\n        /// </param>\n        Task<CtaFlowRunResult> StartFlowAsync(\n            Guid businessId,\n            Guid contactId,\n            string contactPhone,\n            Guid configId,\n            FlowExecutionOrigin origin,\n            Guid? autoReplyFlowId,\n            CancellationToken cancellationToken = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Services/ICTAFlowService.cs",
      "sha256": "ea564ff162310a68224cdc57a047aa45a900fc613e40a06e7d0a22780ef35ee2",
      "language": "csharp",
      "size": 5223,
      "content": "using xbytechat.api.Features.CTAFlowBuilder.DTOs;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Services\n{\n    public interface ICTAFlowService\n    {\n        // Create-only (draft)\n        Task<ResponseResult> SaveVisualFlowAsync(SaveVisualFlowDto dto, Guid businessId, string createdBy);\n\n        // Load flows (lists)\n        Task<List<VisualFlowSummaryDto>> GetAllPublishedFlowsAsync(Guid businessId);\n        Task<List<VisualFlowSummaryDto>> GetAllDraftFlowsAsync(Guid businessId);\n\n        // Load flow (detail)\n        Task<SaveVisualFlowDto?> GetVisualFlowByIdAsync(Guid flowId, Guid businessId);  // for editor/view\n        Task<ResponseResult> GetVisualFlowAsync(Guid flowId, Guid businessId);          // alt payload\n\n        // Runtime\n        Task<CTAFlowStep?> MatchStepByButtonAsync(Guid businessId, string buttonText, string buttonType, string currentTemplateName, Guid? campaignId = null);\n        Task<ResponseResult> ExecuteVisualFlowAsync(Guid businessId, Guid startStepId, Guid trackingLogId, Guid? campaignSendLogId);\n        Task<CTAFlowStep?> GetChainedStepAsync(Guid businessId, Guid? nextStepId);\n        Task<CTAFlowStep?> GetChainedStepWithContextAsync(Guid businessId, Guid? nextStepId, Guid? trackingLogId);\n        Task<FlowButtonLink?> GetLinkAsync(Guid flowId, Guid sourceStepId, short buttonIndex);\n\n        // Delete (only if not attached)\n        Task<ResponseResult> DeleteFlowAsync(Guid flowId, Guid businessId, string deletedBy);\n\n        // Publish\n        Task<ResponseResult> PublishFlowAsync(Guid flowId, Guid businessId, string user);\n\n        // Update (save as draft) + fork (create new draft copy)\n        Task<FlowUpdateResult> UpdateVisualFlowAsync(Guid flowId, SaveVisualFlowDto dto, Guid businessId, string user);\n        Task<Guid> ForkFlowAsync(Guid flowId, Guid businessId, string user);\n\n        // Attached campaigns (for usage checks / modal)\n        Task<IReadOnlyList<AttachedCampaignDto>> GetAttachedCampaignsAsync(Guid flowId, Guid businessId);\n\n        // (Optional utility)\n        Task<bool> HardDeleteFlowIfUnusedAsync(Guid flowId, Guid businessId);\n    }\n}\n\n\n//using xbytechat.api.Features.CTAFlowBuilder.DTOs;\n//using xbytechat.api.Features.CTAFlowBuilder.Models;\n//using xbytechat.api.Helpers;\n\n//namespace xbytechat.api.Features.CTAFlowBuilder.Services\n//{\n//    public interface ICTAFlowService\n//    {\n//        // ‚úÖ Used for flow creation and saving\n//        Task<Guid> CreateFlowWithStepsAsync(CreateFlowDto dto, Guid businessId, string createdBy);\n//        Task<ResponseResult> SaveVisualFlowAsync(SaveVisualFlowDto dto, Guid businessId, string createdBy);\n\n//        // ‚úÖ Load flows\n//        Task<CTAFlowConfig?> GetFlowByBusinessAsync(Guid businessId);\n//        Task<CTAFlowConfig?> GetDraftFlowByBusinessAsync(Guid businessId);\n//        Task<List<VisualFlowSummaryDto>> GetAllPublishedFlowsAsync(Guid businessId);\n//        Task<List<VisualFlowSummaryDto>> GetAllDraftFlowsAsync(Guid businessId);\n\n//        // ‚úÖ Load and manage flow steps\n//        Task<List<CTAFlowStep>> GetStepsForFlowAsync(Guid flowId);\n\n\n//        Task<CTAFlowStep?> MatchStepByButtonAsync(Guid businessId, string buttonText,string buttonType,string currentTemplateName,Guid? campaignId = null);\n\n\n//        Task<CTAFlowStep?> GetChainedStepAsync(Guid businessId, Guid? nextStepId);\n//        Task<CTAFlowStep?> GetChainedStepWithContextAsync(Guid businessId, Guid? nextStepId, Guid? trackingLogId);\n//        // ‚úÖ Runtime logic\n//        Task<ResponseResult> ExecuteFollowUpStepAsync(Guid businessId, CTAFlowStep? currentStep, string recipientNumber);\n\n//        // ‚úÖ Flow management\n//        Task<ResponseResult> PublishFlowAsync(Guid businessId, List<FlowStepDto> steps, string createdBy);\n\n//        Task<ResponseResult> DeleteFlowAsync(Guid flowId, Guid businessId, string deletedBy);\n\n//        // ‚úÖ Editor loading (visual builder)\n//       // Task<SaveVisualFlowDto?> GetVisualFlowByIdAsync(Guid id, Guid businessId);\n//        Task<SaveVisualFlowDto?> GetVisualFlowByIdAsync(Guid flowId, Guid businessId);\n//        Task<ResponseResult> GetVisualFlowAsync(Guid flowId, Guid businessId);\n//        Task<ResponseResult> ExecuteVisualFlowAsync(Guid businessId, Guid startStepId, Guid trackingLogId, Guid? campaignSendLogId);\n//        Task<FlowButtonLink?> GetLinkAsync(Guid flowId, Guid sourceStepId, short buttonIndex);\n\n//        public interface IFlowRuntimeService\n//        {\n//            Task<NextStepResult> ExecuteNextAsync(NextStepContext context);\n//        }\n//        Task<IReadOnlyList<AttachedCampaignDto>> GetAttachedCampaignsAsync(Guid flowId, Guid businessId);\n//        Task<bool> HardDeleteFlowIfUnusedAsync(Guid flowId, Guid businessId);\n//        //Task<FlowUpdateResult> UpdateVisualFlowAsync(Guid flowId, SaveVisualFlowDto dto, Guid businessId, string user);\n\n//        // Explicit publish after edits\n//        Task<bool> PublishFlowAsync(Guid flowId, Guid businessId, string user);\n\n//        // Create a new draft copy when live flow is attached\n//        Task<Guid> ForkFlowAsync(Guid flowId, Guid businessId, string user);\n//    }\n//}\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Services/IFlowExecutionLogger.cs",
      "sha256": "f55acecb74866f1c84445d8583541fd60f0436c02f1f1e87815fce4ce5acf9b9",
      "language": "csharp",
      "size": 717,
      "content": "using System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.AutoReplyBuilder.DTOs;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\n\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Services\n{\n    /// <summary>\n    /// Abstraction for writing origin-tagged FlowExecutionLog rows.\n    /// Different engines (Campaign, AutoReply, Inbox, JourneyBot)\n    /// will call this with a FlowExecutionContext.\n    /// </summary>\n    public interface IFlowExecutionLogger\n    {\n        /// <summary>\n        /// Persist a single step execution into FlowExecutionLogs.\n        /// </summary>\n        Task LogStepAsync(FlowExecutionContext context, CancellationToken cancellationToken = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Services/IFlowRuntimeService.cs",
      "sha256": "02883161ca81dc88c13dcc8d599794a62f59a3641643696423a75cca4c36b1e7",
      "language": "csharp",
      "size": 1573,
      "content": "using xbytechat.api.Features.CTAFlowBuilder.Models;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Services\n{\n    public interface IFlowRuntimeService\n    {\n        Task<NextStepResult> ExecuteNextAsync(NextStepContext context);\n\n    }\n    public record NextStepContext\n    {\n        public Guid BusinessId { get; set; }\n        public Guid FlowId { get; set; }\n        public int Version { get; set; }\n        public Guid SourceStepId { get; set; }\n        public Guid? TargetStepId { get; set; }\n        public short ButtonIndex { get; set; }\n        public Guid MessageLogId { get; set; }\n        public string ContactPhone { get; set; } = string.Empty;\n        public Guid RequestId { get; set; }\n        public FlowButtonLink? ClickedButton { get; set; }\n        public string? Provider { get; set; }          // \"META_CLOUD\" | \"PINNACLE\"\n        public string? PhoneNumberId { get; set; }\n            public bool AlwaysSend { get; set; } = true;\n\n        // CTA media-header support (step 1/phase 1):\n        // When a template requires a media header (image/video/document), WhatsApp requires a header component with a link.\n        // In phase 2/3 we will persist this per-step (CTAFlowStep.HeaderMediaUrl) via UI + DB.\n        // For now this is an optional override input so runtime can attach the header when available.\n        public string? HeaderMediaUrl { get; set; }\n    }\n\n    public record NextStepResult\n    {\n        public bool Success { get; set; }\n        public string? Error { get; set; }\n        public string? RedirectUrl { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Services/StepMatchingHelper.cs",
      "sha256": "4bd66fa2f33211a05e7a5a3c49de0886ae0859cbb081cacd2f4dd431be005182",
      "language": "csharp",
      "size": 1827,
      "content": "using Serilog;\nusing xbytechat.api.Features.CRM.Models;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\nusing xbytechat.api.Features.Tracking.Models;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Services\n{\n    public static class StepMatchingHelper\n    {\n        public static bool IsStepMatched(CTAFlowStep step, TrackingLog log, Contact? contact)\n        {\n            if (!string.IsNullOrWhiteSpace(step.RequiredSource) &&\n                !string.Equals(step.RequiredSource, log.SourceType, StringComparison.OrdinalIgnoreCase))\n            {\n                Log.Information(\"üö´ Step [{StepId}] skipped: RequiredSource '{Required}' ‚â† ClickedSource '{Actual}'\",\n                    step.Id, step.RequiredSource, log.SourceType);\n                return false;\n            }\n\n            if (!string.IsNullOrWhiteSpace(step.RequiredTag))\n            {\n                if (contact == null || contact.ContactTags == null || !contact.ContactTags.Any())\n                {\n                    Log.Information(\"üö´ Step [{StepId}] skipped: Contact or Tags missing (RequiredTag: {RequiredTag})\",\n                        step.Id, step.RequiredTag);\n                    return false;\n                }\n\n                var hasTag = contact.ContactTags.Any(ct =>\n                    string.Equals(ct.Tag.Name, step.RequiredTag, StringComparison.OrdinalIgnoreCase));\n\n                if (!hasTag)\n                {\n                    var contactTags = string.Join(\", \", contact.ContactTags.Select(ct => ct.Tag.Name));\n                    Log.Information(\"üö´ Step [{StepId}] skipped: Contact tags [{Tags}] do not include RequiredTag '{Required}'\",\n                        step.Id, contactTags, step.RequiredTag);\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAManagement/Controllers/CTAManagementController.cs",
      "sha256": "3d06022ca06d6b4e214bf6e571b79d311da0902eeadebddc1f7d48c18a1ecb99",
      "language": "csharp",
      "size": 2535,
      "content": "using Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.CTAManagement.DTOs;\nusing xbytechat.api.Features.CTAManagement.Services;\n\nnamespace xbytechat.api.Features.CTAManagement.Controllers\n{\n    [ApiController]\n    [Route(\"api/ctamanagement\")]\n    [Authorize] // ‚úÖ Ensures only authenticated users can access\n    public class CTAManagementController : ControllerBase\n    {\n        private readonly ICTAManagementService _ctaService;\n\n        public CTAManagementController(ICTAManagementService ctaService)\n        {\n            _ctaService = ctaService;\n        }\n\n        // ‚úÖ GET: api/ctamanagement/get-all\n        [HttpGet(\"get-all\")]\n        public async Task<IActionResult> GetAll()\n        {\n            var data = await _ctaService.GetAllAsync();\n            return Ok(data);\n        }\n\n        // üìå GET: api/ctamanagement/get/{id}\n        [HttpGet(\"get/{id}\")]\n        public async Task<IActionResult> GetById(Guid id)\n        {\n            var result = await _ctaService.GetByIdAsync(id);\n            return result == null ? NotFound(\"CTA not found\") : Ok(result);\n        }\n\n        // ‚úÖ POST: api/ctamanagement/create\n        [HttpPost(\"create\")]\n        public async Task<IActionResult> Create([FromBody] CTADefinitionDto dto)\n        {\n            if (!ModelState.IsValid)\n                return BadRequest(\"‚ùå Invalid CTA payload.\");\n\n            var success = await _ctaService.AddAsync(dto);\n            return success\n                ? Ok(new { message = \"‚úÖ CTA created.\" })\n                : StatusCode(500, \"‚ùå Failed to create CTA.\");\n        }\n\n        // ‚úèÔ∏è PUT: api/ctamanagement/update/{id}\n        [HttpPut(\"update/{id}\")]\n        public async Task<IActionResult> Update(Guid id, [FromBody] CTADefinitionDto dto)\n        {\n            if (!ModelState.IsValid)\n                return BadRequest(\"‚ùå Invalid CTA payload.\");\n\n            var success = await _ctaService.UpdateAsync(id, dto);\n            return success\n                ? Ok(new { message = \"‚úÖ CTA updated.\" })\n                : NotFound(\"CTA not found or update failed.\");\n        }\n\n        // üóëÔ∏è DELETE: api/ctamanagement/delete/{id}\n        [HttpDelete(\"delete/{id}\")]\n        public async Task<IActionResult> Delete(Guid id)\n        {\n            var success = await _ctaService.DeleteAsync(id);\n            return success\n                ? Ok(new { message = \"‚úÖ CTA deleted (soft).\" })\n                : NotFound(\"CTA not found or delete failed.\");\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAManagement/DTOs/CTADefinitionDto.cs",
      "sha256": "1472d3694a4cebf363c3a632675fe61b8646f610f7a96a2687286bfb47d8eacf",
      "language": "csharp",
      "size": 707,
      "content": "namespace xbytechat.api.Features.CTAManagement.DTOs\n{\n    public class CTADefinitionDto\n    {\n        public Guid Id { get; set; }\n\n        public string Title { get; set; } = string.Empty; // üè∑Ô∏è CTA label (e.g., \"Buy Now\")\n\n        public string ButtonText { get; set; } = string.Empty; // üí¨ Visible button label (e.g., \"Buy Now\")\n\n        public string ButtonType { get; set; } = \"url\"; // üîò Expected values: \"url\", \"quick_reply\", etc.\n\n        public string TargetUrl { get; set; } = string.Empty; // üåê Redirect or action target\n\n        public string? Description { get; set; } // üìù Optional description (for context/tooltip)\n\n        public bool IsActive { get; set; } = true;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAManagement/Models/CTADefinition.cs",
      "sha256": "96216798bd31e2098b9a2ba43dac62e067f7062f5e5c36bb318a8dab2f74da38",
      "language": "csharp",
      "size": 913,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CTAManagement.Models\n{\n    public class CTADefinition\n    {\n        public Guid Id { get; set; }\n\n        public Guid BusinessId { get; set; } // üîó Business that owns this CTA\n\n        public string Title { get; set; } = string.Empty; // üè∑Ô∏è CTA label/title, e.g., \"Buy Now\"\n\n        public string ButtonText { get; set; } = string.Empty; // üí¨ Visible button label\n\n        public string ButtonType { get; set; } = \"url\"; // üîò Options: \"url\", \"quick_reply\", etc.\n\n        public string TargetUrl { get; set; } = string.Empty; // üåê Action URL or value (depending on type)\n\n        public string Description { get; set; } = string.Empty; // üìù Optional additional context\n\n        public bool IsActive { get; set; } = true;\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n        public DateTime? UpdatedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAManagement/Services/CTAManagementService.cs",
      "sha256": "a9388986726208c45f05afa2bd4ed3c74b33d7d79eb0e5863b7256e061ba4081",
      "language": "csharp",
      "size": 4621,
      "content": "using Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.CTAManagement.DTOs;\nusing xbytechat.api.Features.CTAManagement.Models;\n\nnamespace xbytechat.api.Features.CTAManagement.Services\n{\n    public class CTAManagementService : ICTAManagementService\n    {\n        private readonly AppDbContext _dbContext;\n        private readonly IHttpContextAccessor _httpContextAccessor;\n\n        public CTAManagementService(AppDbContext dbContext, IHttpContextAccessor httpContextAccessor)\n        {\n            _dbContext = dbContext;\n            _httpContextAccessor = httpContextAccessor;\n        }\n\n        // üîÑ Get all active CTAs for the current business\n        public async Task<List<CTADefinitionDto>> GetAllAsync()\n        {\n            var businessId = GetBusinessIdFromClaims();\n\n            return await _dbContext.CTADefinitions\n                .Where(c => c.IsActive && c.BusinessId == businessId)\n                .Select(c => new CTADefinitionDto\n                {\n                    Id = c.Id,\n                    Title = c.Title,\n                    ButtonText = c.ButtonText,\n                    ButtonType = c.ButtonType,\n                    TargetUrl = c.TargetUrl,\n                    Description = c.Description,\n                    IsActive = c.IsActive\n                }).ToListAsync();\n        }\n\n        // ‚úÖ Add new CTA\n        public async Task<bool> AddAsync(CTADefinitionDto dto)\n        {\n            var businessId = GetBusinessIdFromClaims();\n\n            var cta = new CTADefinition\n            {\n                Id = Guid.NewGuid(),\n                BusinessId = businessId,\n                Title = dto.Title,\n                ButtonText = dto.ButtonText,\n                ButtonType = dto.ButtonType,\n                TargetUrl = dto.TargetUrl,\n                Description = dto.Description ?? \"\",\n                IsActive = true,\n                CreatedAt = DateTime.UtcNow\n            };\n\n            await _dbContext.CTADefinitions.AddAsync(cta);\n            await _dbContext.SaveChangesAsync();\n            return true;\n        }\n\n        // üìå Get CTA by ID\n        public async Task<CTADefinitionDto?> GetByIdAsync(Guid id)\n        {\n            var businessId = GetBusinessIdFromClaims();\n\n            var cta = await _dbContext.CTADefinitions\n                .FirstOrDefaultAsync(c => c.Id == id && c.IsActive && c.BusinessId == businessId);\n\n            if (cta == null) return null;\n\n            return new CTADefinitionDto\n            {\n                Id = cta.Id,\n                Title = cta.Title,\n                ButtonText = cta.ButtonText,\n                ButtonType = cta.ButtonType,\n                TargetUrl = cta.TargetUrl,\n                Description = cta.Description,\n                IsActive = cta.IsActive\n            };\n        }\n\n\n        // ‚úèÔ∏è Update CTA\n        public async Task<bool> UpdateAsync(Guid id, CTADefinitionDto dto)\n        {\n            var cta = await _dbContext.CTADefinitions.FindAsync(id);\n            if (cta == null) return false;\n\n            var businessId = GetBusinessIdFromClaims();\n            if (cta.BusinessId != businessId) throw new UnauthorizedAccessException(\"Unauthorized to modify this CTA.\");\n\n            cta.Title = dto.Title;\n            cta.ButtonText = dto.ButtonText;\n            cta.ButtonType = dto.ButtonType;\n            cta.TargetUrl = dto.TargetUrl;\n            cta.Description = dto.Description ?? \"\";\n            cta.IsActive = dto.IsActive;\n            cta.UpdatedAt = DateTime.UtcNow;\n\n            await _dbContext.SaveChangesAsync();\n            return true;\n        }\n\n        // üóëÔ∏è Soft Delete CTA\n        public async Task<bool> DeleteAsync(Guid id)\n        {\n            var cta = await _dbContext.CTADefinitions.FindAsync(id);\n            if (cta == null) return false;\n\n            var businessId = GetBusinessIdFromClaims();\n            if (cta.BusinessId != businessId) throw new UnauthorizedAccessException(\"Unauthorized to delete this CTA.\");\n\n            cta.IsActive = false;\n            cta.UpdatedAt = DateTime.UtcNow;\n\n            await _dbContext.SaveChangesAsync();\n            return true;\n        }\n\n        // üîê Reusable method to extract BusinessId\n        private Guid GetBusinessIdFromClaims()\n        {\n            var claim = _httpContextAccessor.HttpContext?.User?.FindFirst(\"businessId\");\n            if (claim == null || string.IsNullOrWhiteSpace(claim.Value) || !Guid.TryParse(claim.Value, out var businessId))\n                throw new UnauthorizedAccessException(\"‚ùå Invalid or missing BusinessId claim.\");\n\n            return businessId;\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAManagement/Services/ICTAManagementService.cs",
      "sha256": "f05abf40bdd4a593e8c8f8980c288884dc5701a5c9ba29261588816002758bcd",
      "language": "csharp",
      "size": 814,
      "content": "using xbytechat.api.Features.CTAManagement.DTOs;\n\nnamespace xbytechat.api.Features.CTAManagement.Services\n{\n    public interface ICTAManagementService\n    {\n        /// <summary>Returns all active CTAs for the current business.</summary>\n        Task<List<CTADefinitionDto>> GetAllAsync();\n\n        /// <summary>Returns a single CTA by ID (if exists).</summary>\n        Task<CTADefinitionDto?> GetByIdAsync(Guid id);\n\n        /// <summary>Adds a new CTA for the logged-in business.</summary>\n        Task<bool> AddAsync(CTADefinitionDto dto);\n\n        /// <summary>Updates an existing CTA if it belongs to the business.</summary>\n        Task<bool> UpdateAsync(Guid id, CTADefinitionDto dto);\n\n        /// <summary>Soft deletes (deactivates) a CTA entry.</summary>\n        Task<bool> DeleteAsync(Guid id);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomeApi/Auth/StaticApiKeyOptions.cs",
      "sha256": "ecf8c607a6022271bcd7228448d61a6fc16c9422cd51362b665a875413409fb9",
      "language": "csharp",
      "size": 196,
      "content": "namespace xbytechat.api.Features.CustomeApi.Auth\n{\n    public sealed class StaticApiKeyOptions\n    {\n        public string? Key { get; set; }\n        public Guid? BusinessId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomeApi/Controllers/CustomApiController.cs",
      "sha256": "bfd039e2c624dbefbd14dbaef2d68318799fee81a833094d7bd401b6b1c8a995",
      "language": "csharp",
      "size": 2694,
      "content": "using System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Options;\nusing xbytechat.api.Features.CustomeApi.Auth;\nusing xbytechat.api.Features.CustomeApi.DTOs;\nusing xbytechat.api.Features.CustomeApi.Services;\n\nnamespace xbytechat.api.Features.CustomeApi.Controllers\n{\n    [ApiController]\n    [Route(\"api/custom\")]\n    public sealed class CustomApiController : ControllerBase\n    {\n        private readonly ICustomApiService _service;\n        private readonly StaticApiKeyOptions _api;\n        private readonly CtaJourneyPublisher _journeyPublisher;\n        public CustomApiController(ICustomApiService service, IOptions<StaticApiKeyOptions> api, CtaJourneyPublisher journeyPublisher)\n        {\n            _service = service;\n            _api = api.Value;\n            _journeyPublisher = journeyPublisher;\n        }\n\n        /// <summary>\n        /// Sends a WhatsApp template (optionally with VIDEO header) by phoneNumberId.\n        /// Body: { phoneNumberId, to, templateId, variables:{ \"1\":\"...\" }, videoUrl, flowConfigId }\n        /// </summary>\n        [HttpPost(\"sendflow\")]\n        [Consumes(\"application/json\")]\n        [Produces(\"application/json\")]\n        [ProducesResponseType(typeof(object), 200)]\n        [ProducesResponseType(typeof(object), 400)]\n        [ProducesResponseType(401)]\n        public async Task<IActionResult> SendTemplate([FromBody] DirectTemplateSendRequest req, CancellationToken ct = default)\n        {\n            if (!ModelState.IsValid)\n                return BadRequest(new { success = false, message = \"‚ùå Invalid request body.\", errors = ModelState });\n\n            // Minimal shared-secret auth\n            var provided = Request.Headers[\"X-Auth-Key\"].FirstOrDefault()\n                           ?? Request.Headers[\"Authorization\"].FirstOrDefault();\n\n            if (string.IsNullOrWhiteSpace(_api.Key) ||\n                string.IsNullOrWhiteSpace(provided) ||\n                !string.Equals(provided, _api.Key, System.StringComparison.Ordinal))\n            {\n                return Unauthorized(new { success = false, message = \"üîí Invalid or missing key.\" });\n            }\n\n            var result = await _service.SendTemplateAsync(req, ct);\n            return result.Success ? Ok(result) : BadRequest(result);\n        }\n        [HttpPost(\"test-webhook\")]\n        public async Task<IActionResult> TestWebhook([FromQuery] Guid businessId, CancellationToken ct)\n        {\n            var (ok, msg) = await _journeyPublisher.ValidateAndPingAsync(businessId, ct);\n            return ok ? Ok(new { ok, message = msg }) : BadRequest(new { ok, message = msg });\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomeApi/Controllers/DevCustomerWebhookConfigController.cs",
      "sha256": "91f4787045211df3c7a8dea1c7dce85901295b74050cad5ddf9c55c6b72f100e",
      "language": "csharp",
      "size": 674,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api;\n\n[ApiController]\n[Route(\"api/getflow\")]\npublic class DevCustomerWebhookConfigController : ControllerBase\n{\n    private readonly AppDbContext _db;\n    public DevCustomerWebhookConfigController(AppDbContext db) => _db = db;\n\n    [HttpGet(\"{businessId:guid}\")]\n    public async Task<IActionResult> Get(Guid businessId)\n    {\n        var cfg = await _db.CustomerWebhookConfigs\n            .AsNoTracking()\n            .FirstOrDefaultAsync(x => x.BusinessId == businessId && x.IsActive);\n        return Ok(cfg is null ? new { found = false } : new { found = true, url = cfg.Url });\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomeApi/DTOs/CtaJourneyEventDto.cs",
      "sha256": "460d6c60802762d203fe59b21a58b49a9cdc29cb9758edb878da461b5bf22f4c",
      "language": "csharp",
      "size": 964,
      "content": "using System.Text.Json.Serialization;\n\nnamespace xbytechat.api.Features.CustomeApi.Models\n{\n    public sealed class CtaJourneyEventDto\n    {\n        // User‚Äôs expected fields (nulls allowed when we don‚Äôt have them)\n        public string? userId { get; set; }            // we don‚Äôt have this ‚Üí null\n        public string? userName { get; set; }          // our Contact.ProfileName or Contact.Name\n        public string? userPhone { get; set; }         // digits only\n        public string? botId { get; set; }             // your WA PhoneNumberId or BusinessNumber (see 2.4)\n        public string? categoryBrowsed { get; set; }   // optional, keep null\n        public string? productBrowsed { get; set; }    // optional, keep null\n\n        // REQUIRED by partner: this is the key we must match\n        //public string CTAJourney { get; set; } = string.Empty;\n        [JsonPropertyName(\"CTAJourney\")]\n        public string? CTAJourney { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomeApi/DTOs/DirectTemplateSendRequest.cs",
      "sha256": "d6d17b04a27f1798034ac60813911ab6b34f19e39a5ee69b272d8c88da4f85f1",
      "language": "csharp",
      "size": 2015,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.CustomeApi.DTOs\n{\n    public sealed class DirectTemplateSendRequest\n    {\n        [Required] public string PhoneNumberId { get; set; } = string.Empty;\n        [Required] public string To { get; set; } = string.Empty;\n        [Required] public string TemplateId { get; set; } = string.Empty;\n\n        /// <summary>Body variable map for {{1}}, {{2}}, ...</summary>\n        public Dictionary<string, string>? Variables { get; set; }\n\n        /// <summary>Optional: provide a https .mp4 to attach a VIDEO header.</summary>\n        public string? VideoUrl { get; set; }\n\n        /// <summary>Optional CTA flow to link with this send (for click‚Üínext-step mapping and analytics).</summary>\n        public Guid? FlowConfigId { get; set; }\n    }\n}\n\n\n//using System; // <-- needed for Guid\n//using System.Collections.Generic;\n//using System.ComponentModel.DataAnnotations;\n\n//namespace xbytechat.api.Features.CustomeApi.DTOs\n//{\n//    public sealed class DirectTemplateSendRequest\n//    {\n//        [Required] public string PhoneNumberId { get; set; } = string.Empty;\n//        [Required] public string To { get; set; } = string.Empty;\n//        [Required] public string TemplateId { get; set; } = string.Empty;\n\n//        // Optional: start (link) a CTA flow on this send (we'll stamp CTAFlowConfigId/StepId on MessageLog)\n//        public Guid? FlowConfigId { get; set; }   // <---- add this\n\n//        // Body variables as WhatsApp {{1}}, {{2}}, ...\n//        public Dictionary<string, string>? Variables { get; set; }\n\n//        // Optional header media, validated based on template header type:\n//        public string? ImageUrl { get; set; } // IMAGE header\n//        public string? VideoUrl { get; set; } // VIDEO header\n//        public string? DocumentUrl { get; set; } // DOCUMENT/PDF header\n//        public string? DocumentFilename { get; set; } // optional nice filename\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomeApi/DTOs/DirectTemplateSendRequestValidator.cs",
      "sha256": "613a944117e95f84b8286c1d19d3945f5d54eb046324aba873d203a3893ec584",
      "language": "csharp",
      "size": 629,
      "content": "using FluentValidation;\n\nnamespace xbytechat.api.Features.CustomeApi.DTOs\n{\n    public sealed class DirectTemplateSendRequestValidator : AbstractValidator<DirectTemplateSendRequest>\n    {\n        public DirectTemplateSendRequestValidator()\n        {\n            RuleFor(x => x.PhoneNumberId).NotEmpty().WithMessage(\"phoneNumberId is required.\");\n            RuleFor(x => x.To).NotEmpty().WithMessage(\"'to' (recipient) is required.\");\n            RuleFor(x => x.TemplateId).NotEmpty().WithMessage(\"templateId is required.\");\n            // videoUrl required only if template header == VIDEO (checked in service)\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomeApi/Models/ContactJourneyState.cs",
      "sha256": "133720f1453770ad09bd2c9bd2551f343f20df6ce27a0b88a2a7234a20e3157c",
      "language": "csharp",
      "size": 1101,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing Microsoft.EntityFrameworkCore;\n\nnamespace xbytechat.api.Features.CustomeApi.Models\n{\n    // One row per (business, flow, contact). Enforce single row via unique index.\n    [Index(nameof(BusinessId), nameof(FlowId), nameof(ContactPhone), IsUnique = true)]\n    public class ContactJourneyState\n    {\n        [Key] public Guid Id { get; set; }\n\n        [Required] public Guid BusinessId { get; set; }\n\n        [Required] public Guid FlowId { get; set; }\n\n        // Store digits-only (same as your click processor does).\n        [Required, MaxLength(32)]\n        public string ContactPhone { get; set; } = default!;\n\n        // Running journey like: \"Yes/No/Bahut Achha\"\n        [Required] public string JourneyText { get; set; } = string.Empty;\n\n        public int ClickCount { get; set; } = 0;\n\n        [MaxLength(256)]\n        public string? LastButtonText { get; set; }\n\n        [Required] public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n        [Required] public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomeApi/Models/CustomerWebhookConfig.cs",
      "sha256": "c08fa705d23cd231999b48da0668ec8e9aef6db72aec24a10a7c583ee7db94e4",
      "language": "csharp",
      "size": 693,
      "content": "using System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.CustomeApi.Models\n{\n    public class CustomerWebhookConfig\n    {\n        [Key] public Guid Id { get; set; }\n\n        [Required] public Guid BusinessId { get; set; }\n\n        [Required, MaxLength(1024)]\n        public string Url { get; set; } = default!;  // customer API endpoint to receive CTAJourney\n\n        [MaxLength(2048)]\n        public string? BearerToken { get; set; }     // optional \"Authorization: Bearer <token>\"\n\n        public bool IsActive { get; set; } = true;\n\n        [Required] public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n        public DateTime? UpdatedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomeApi/Services/CtaJourneyMapper.cs",
      "sha256": "6a97ebadd1575997d1bd2a675cfde50b63361d45137b66242e90672084bc21b5",
      "language": "csharp",
      "size": 1719,
      "content": "using System.Text.RegularExpressions;\nusing xbytechat.api.Features.CRM.Models;\n\nnamespace xbytechat.api.Features.CustomeApi.Services\n{\n    public static class CtaJourneyMapper\n    {\n        private static string Digits(string? s) =>\n            string.IsNullOrWhiteSpace(s) ? \"\" : Regex.Replace(s, \"[^0-9]\", \"\");\n\n    \n        public static Models.CtaJourneyEventDto Build(\n            string journeyKey,          // REQUIRED -> \"product_view_to_interest\" (your must-match)\n            Contact? contact = null,\n            string? profileName = null,\n            string? userId = null,      // we don‚Äôt have: pass null\n            string? phoneNumberId = null,   // Meta phone_number_id\n            string? businessDisplayPhone = null, // WhatsAppBusinessNumber\n            string? categoryBrowsed = null,\n            string? productBrowsed = null\n        )\n        {\n            // Choose botId priority: phoneNumberId (Meta) -> business WA number -> null\n            var botId = !string.IsNullOrWhiteSpace(phoneNumberId)\n                ? phoneNumberId!.Trim()\n                : (!string.IsNullOrWhiteSpace(businessDisplayPhone) ? Digits(businessDisplayPhone) : null);\n\n            return new Models.CtaJourneyEventDto\n            {\n                userId = userId, // normally null (we don‚Äôt store)\n                userName = profileName ?? contact?.ProfileName ?? contact?.Name,\n                userPhone = Digits(contact?.PhoneNumber),\n                botId = botId,\n                categoryBrowsed = categoryBrowsed,   // keep null \n                productBrowsed = productBrowsed,     // keep null \n                CTAJourney = journeyKey               // e.g. \"Button Name\"\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomeApi/Services/CtaJourneyPublisher.cs",
      "sha256": "d6cc88d790dc147459324a25a78082d154f457abec1fd7011683edc9e77994b9",
      "language": "csharp",
      "size": 13867,
      "content": "using System;\nusing System.Linq;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Text;\nusing System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\n\nnamespace xbytechat.api.Features.CustomeApi.Services\n{\n    public class CtaJourneyPublisher : ICtaJourneyPublisher\n    {\n        private readonly AppDbContext _db;\n        private readonly IHttpClientFactory _httpFactory;\n        private readonly ILogger<CtaJourneyPublisher> _log;\n\n        private static readonly JsonSerializerOptions _json = new(JsonSerializerDefaults.Web);\n\n        public CtaJourneyPublisher(\n            AppDbContext db,\n            IHttpClientFactory httpFactory,\n            ILogger<CtaJourneyPublisher> log)\n        {\n            _db = db;\n            _httpFactory = httpFactory;\n            _log = log;\n        }\n\n        public async Task PublishAsync(Guid businessId, Models.CtaJourneyEventDto dto, CancellationToken ct = default)\n        {\n            // Load all active endpoints (only for this one customer right now)\n            var endpoints = await _db.CustomerWebhookConfigs\n                .AsNoTracking()\n                .Where(x => x.BusinessId == businessId && x.IsActive)\n                .ToListAsync(ct);\n\n            if (endpoints.Count == 0)\n            {\n                _log.LogInformation(\"CTA Journey: no active endpoints for business {Biz}\", businessId);\n                return;\n            }\n\n            var client = _httpFactory.CreateClient(\"customapi-webhooks\"); // registered in DI\n\n            foreach (var ep in endpoints)\n            {\n                // Serialize once per endpoint\n                var body = JsonSerializer.Serialize(dto, _json);\n\n                const int maxAttempts = 3;\n                for (int attempt = 1; attempt <= maxAttempts; attempt++)\n                {\n                    try\n                    {\n                        using var req = new HttpRequestMessage(HttpMethod.Post, ep.Url)\n                        {\n                            Content = new StringContent(body, Encoding.UTF8, \"application/json\")\n                        };\n\n                        if (!string.IsNullOrWhiteSpace(ep.BearerToken))\n                            req.Headers.Authorization = new AuthenticationHeaderValue(\"Bearer\", ep.BearerToken);\n\n                        var resp = await client.SendAsync(req, ct);\n                        var code = (int)resp.StatusCode;\n\n                        if (code >= 200 && code < 300)\n                        {\n                            _log.LogInformation(\"CTA Journey posted to {Url} | {Status}\", ep.Url, code);\n                            break; // success; stop retrying this endpoint\n                        }\n\n                        var errText = await resp.Content.ReadAsStringAsync(ct);\n                        _log.LogWarning(\"CTA Journey post failed ({Code}) to {Url}: {Body}\", code, ep.Url, errText);\n\n                        if (attempt == maxAttempts) break;\n                        await Task.Delay(TimeSpan.FromSeconds(2 * attempt), ct); // 2s, 4s backoff\n                    }\n                    catch (Exception ex)\n                    {\n                        _log.LogWarning(ex, \"CTA Journey post exception to {Url} (attempt {Attempt})\", ep.Url, attempt);\n                        if (attempt == maxAttempts) break;\n                        await Task.Delay(TimeSpan.FromSeconds(2 * attempt), ct);\n                    }\n                }\n            }\n        }\n\n        public async Task<(bool ok, string message)> ValidateAndPingAsync(Guid businessId, CancellationToken ct = default)\n        {\n            var ep = await _db.CustomerWebhookConfigs\n                .AsNoTracking()\n                .Where(x => x.BusinessId == businessId && x.IsActive)\n                .OrderByDescending(x => x.UpdatedAt ?? x.CreatedAt)\n                .FirstOrDefaultAsync(ct);\n\n            if (ep == null) return (false, \"No active CustomerWebhookConfig found for this business.\");\n            if (string.IsNullOrWhiteSpace(ep.Url)) return (false, \"Endpoint URL is empty.\");\n            if (!Uri.TryCreate(ep.Url, UriKind.Absolute, out var uri) || uri.Scheme != Uri.UriSchemeHttps)\n                return (false, \"Endpoint URL must be an absolute https URL.\");\n\n            var probe = new Models.CtaJourneyEventDto\n            {\n                userId = null,\n                userName = \"probe\",\n                userPhone = \"0000000000\",\n                botId = \"0000000000\",\n                categoryBrowsed = null,\n                productBrowsed = null,\n                CTAJourney = \"probe_to_probe\"\n            };\n\n            var client = _httpFactory.CreateClient(\"customapi-webhooks\");\n            var body = JsonSerializer.Serialize(probe, _json);\n\n            using var req = new HttpRequestMessage(HttpMethod.Post, ep.Url)\n            {\n                Content = new StringContent(body, Encoding.UTF8, \"application/json\")\n            };\n\n            req.Headers.TryAddWithoutValidation(\"X-XBS-Test\", \"1\");\n\n            if (!string.IsNullOrWhiteSpace(ep.BearerToken))\n                req.Headers.Authorization = new AuthenticationHeaderValue(\"Bearer\", ep.BearerToken);\n\n            try\n            {\n                var resp = await client.SendAsync(req, ct);\n                var code = (int)resp.StatusCode;\n\n                if (code >= 200 && code < 300) return (true, $\"OK ({code})\");\n\n                var text = await resp.Content.ReadAsStringAsync(ct);\n                return (false, $\"HTTP {code}: {text}\");\n            }\n            catch (Exception ex)\n            {\n                return (false, $\"Exception: {ex.Message}\");\n            }\n        }\n    }\n}\n\n\n//using System;\n//using System.Linq;\n//using System.Net.Http;\n//using System.Net.Http.Headers;\n//using System.Text;\n//using System.Text.Json;\n//using System.Threading;\n//using System.Threading.Tasks;\n//using Microsoft.EntityFrameworkCore;\n//using Microsoft.Extensions.Logging;\n\n//namespace xbytechat.api.Features.CustomeApi.Services\n//{\n//    public class CtaJourneyPublisher : ICtaJourneyPublisher\n//    {\n//        private readonly AppDbContext _db;\n//        private readonly IHttpClientFactory _httpFactory;\n//        private readonly ILogger<CtaJourneyPublisher> _log;\n\n//        private static readonly JsonSerializerOptions _json =\n//            new(JsonSerializerDefaults.Web);\n\n//        public CtaJourneyPublisher(AppDbContext db, IHttpClientFactory httpFactory, ILogger<CtaJourneyPublisher> log)\n//        {\n//            _db = db;\n//            _httpFactory = httpFactory;\n//            _log = log;\n//        }\n\n\n//        public async Task PublishAsync(Guid businessId, Models.CtaJourneyEventDto dto, CancellationToken ct = default)\n//        {\n//            // load all active endpoints (only for this one customer right now)\n//            var endpoints = await _db.CustomerWebhookConfigs\n//                .AsNoTracking()\n//                .Where(x => x.BusinessId == businessId && x.IsActive)\n//                .ToListAsync(ct);\n\n//            if (endpoints.Count == 0)\n//            {\n//                _log.LogInformation(\"CTA Journey: no active endpoints for business {Biz}\", businessId);\n//                return;\n//            }\n\n//            var client = _httpFactory.CreateClient(\"customapi-webhooks\"); // registered in DI\n//            var body = JsonSerializer.Serialize(dto, _json);\n//            using var content = new StringContent(body, Encoding.UTF8, \"application/json\");\n//            foreach (var ep in endpoints)\n//            {\n//                // simple retry (3 attempts, 2s/4s backoff)\n//                const int maxAttempts = 3;\n//                for (int attempt = 1; attempt <= maxAttempts; attempt++)\n//                {\n//                    try\n//                    {\n//                        using var req = new HttpRequestMessage(HttpMethod.Post, ep.Url)\n//                        {\n//                            Content = new StringContent(\n//                                JsonSerializer.Serialize(dto, _json),   // fresh content every send\n//                                Encoding.UTF8,\n//                                \"application/json\")\n//                        };\n\n//                        if (!string.IsNullOrWhiteSpace(ep.BearerToken))\n//                            req.Headers.Authorization = new AuthenticationHeaderValue(\"Bearer\", ep.BearerToken);\n\n//                        var resp = await client.SendAsync(req, ct);\n//                        if ((int)resp.StatusCode >= 200 && (int)resp.StatusCode < 300)\n//                        {\n//                            _log.LogInformation(\"CTA Journey posted to {Url} | {Status}\", ep.Url, (int)resp.StatusCode);\n//                            break;\n//                        }\n\n//                        var bodyText = await resp.Content.ReadAsStringAsync(ct);\n//                        _log.LogWarning(\"CTA Journey post failed ({Code}) to {Url}: {Body}\",\n//                            (int)resp.StatusCode, ep.Url, bodyText);\n\n//                        if (attempt == maxAttempts) break;\n//                        await Task.Delay(TimeSpan.FromSeconds(2 * attempt), ct);\n//                    }\n//                    catch (Exception ex)\n//                    {\n//                        _log.LogWarning(ex, \"CTA Journey post exception to {Url} (attempt {Attempt})\", ep.Url, attempt);\n//                        if (attempt == maxAttempts) break;\n//                        await Task.Delay(TimeSpan.FromSeconds(2 * attempt), ct);\n//                    }\n//                }\n//            }\n\n//            //foreach (var ep in endpoints)\n//            //{\n//            //    using var req = new HttpRequestMessage(HttpMethod.Post, ep.Url) { Content = content };\n\n//            //    // optional Bearer only (we're keeping it simple)\n//            //    if (!string.IsNullOrWhiteSpace(ep.BearerToken))\n//            //        req.Headers.Authorization = new AuthenticationHeaderValue(\"Bearer\", ep.BearerToken);\n\n//            //    // simple retry (3 attempts, 2s/4s backoff)\n//            //    const int maxAttempts = 3;\n//            //    for (int attempt = 1; attempt <= maxAttempts; attempt++)\n//            //    {\n//            //        try\n//            //        {\n//            //            var resp = await client.SendAsync(req, ct);\n//            //            if ((int)resp.StatusCode >= 200 && (int)resp.StatusCode < 300)\n//            //            {\n//            //                _log.LogInformation(\"CTA Journey posted to {Url} | {Status}\", ep.Url, (int)resp.StatusCode);\n//            //                break;\n//            //            }\n\n//            //            var bodyText = await resp.Content.ReadAsStringAsync(ct);\n//            //            _log.LogWarning(\"CTA Journey post failed ({Code}) to {Url}: {Body}\",\n//            //                (int)resp.StatusCode, ep.Url, bodyText);\n\n//            //            if (attempt == maxAttempts) break;\n//            //            await Task.Delay(TimeSpan.FromSeconds(2 * attempt), ct);\n//            //        }\n//            //        catch (Exception ex)\n//            //        {\n//            //            _log.LogWarning(ex, \"CTA Journey post exception to {Url} (attempt {Attempt})\", ep.Url, attempt);\n//            //            if (attempt == maxAttempts) break;\n//            //            await Task.Delay(TimeSpan.FromSeconds(2 * attempt), ct);\n//            //        }\n//            //    }\n//            //}\n//        }\n//        public async Task<(bool ok, string message)> ValidateAndPingAsync(Guid businessId, CancellationToken ct = default)\n//        {\n//            var ep = await _db.CustomerWebhookConfigs\n//                .AsNoTracking()\n//                .Where(x => x.BusinessId == businessId && x.IsActive)\n//                .OrderByDescending(x => x.UpdatedAt ?? x.CreatedAt)\n//                .FirstOrDefaultAsync(ct);\n\n//            if (ep == null) return (false, \"No active CustomerWebhookConfig found for this business.\");\n//            if (string.IsNullOrWhiteSpace(ep.Url)) return (false, \"Endpoint URL is empty.\");\n//            if (!Uri.TryCreate(ep.Url, UriKind.Absolute, out var uri) || uri.Scheme != Uri.UriSchemeHttps)\n//                return (false, \"Endpoint URL must be an absolute https URL.\");\n\n//            var probe = new Models.CtaJourneyEventDto\n//            {\n//                userId = null,\n//                userName = \"probe\",\n//                userPhone = \"0000000000\",\n//                botId = \"0000000000\",\n//                categoryBrowsed = null,\n//                productBrowsed = null,\n//                CTAJourney = \"probe_to_probe\"\n//            };\n\n//            var client = _httpFactory.CreateClient(\"customapi-webhooks\");\n//            var body = JsonSerializer.Serialize(probe, _json);\n\n//            using var req = new HttpRequestMessage(HttpMethod.Post, ep.Url)\n//            {\n//                Content = new StringContent(body, Encoding.UTF8, \"application/json\")\n//            };\n//            req.Headers.TryAddWithoutValidation(\"X-XBS-Test\", \"1\");\n\n//            if (!string.IsNullOrWhiteSpace(ep.BearerToken))\n//                req.Headers.Authorization = new AuthenticationHeaderValue(\"Bearer\", ep.BearerToken);\n\n//            try\n//            {\n//                var resp = await client.SendAsync(req, ct);\n//                var code = (int)resp.StatusCode;\n//                if (code >= 200 && code < 300) return (true, $\"OK ({code})\");\n//                var text = await resp.Content.ReadAsStringAsync(ct);\n//                return (false, $\"HTTP {code}: {text}\");\n//            }\n//            catch (Exception ex)\n//            {\n//                return (false, $\"Exception: {ex.Message}\");\n//            }\n//        }\n\n//    }\n//}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CustomeApi/Services/CustomApiService.cs",
      "sha256": "78a7353f5a8e6c720e2640c507df52730cd9b75e8803abe3590bf51c67a63259",
      "language": "csharp",
      "size": 27860,
      "content": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Newtonsoft.Json; \nusing xbytechat.api.Features.CustomeApi.DTOs;\nusing xbytechat.api.Features.MessagesEngine.Services;                       \nusing xbytechat_api.Features.Billing.Services;\nusing xbytechat_api.WhatsAppSettings.Services;\nusing xbytechat.api.Helpers;\nusing System.Text.RegularExpressions;      \n\nnamespace xbytechat.api.Features.CustomeApi.Services\n{\n    public sealed class CustomApiService : ICustomApiService\n    {\n        private readonly AppDbContext _context;\n        private readonly IWhatsAppTemplateFetcherService _templateFetcher;\n        private readonly IMessageEngineService _messageEngine;\n        private readonly IBillingIngestService _billingIngest;\n        private readonly ILogger<CustomApiService> _logger;\n\n        public CustomApiService(\n            AppDbContext context,\n            IWhatsAppTemplateFetcherService templateFetcher,\n            IMessageEngineService messageEngine,\n            IBillingIngestService billingIngest,\n            ILogger<CustomApiService> logger)\n        {\n            _context = context;\n            _templateFetcher = templateFetcher;\n            _messageEngine = messageEngine;\n            _billingIngest = billingIngest;\n            _logger = logger;\n        }\n\n        public async Task<ResponseResult> SendTemplateAsync(DirectTemplateSendRequest req, CancellationToken ct = default)\n        {\n            try\n            {\n                var toNormalized = NormalizePhone(req.To);\n                var reqId = Guid.NewGuid();\n\n                // 1) Resolve WhatsApp sender by phoneNumberId (across all businesses)\n                //var ws = await _context.WhatsAppPhoneNumbers.AsNoTracking()\n                //    .Where(s => s.IsActive && s.PhoneNumberId == req.PhoneNumberId)\n                //    .OrderByDescending(s => s.UpdatedAt ?? s.CreatedAt)\n                //    .FirstOrDefaultAsync(ct);\n\n                var ws = await _context.WhatsAppPhoneNumbers.AsNoTracking()\n                    .Where(s =>  s.IsActive && s.PhoneNumberId == req.PhoneNumberId)\n                    .OrderByDescending(s => s.UpdatedAt ?? s.CreatedAt)\n                   .FirstOrDefaultAsync(ct);\n\n\n\n                if (ws == null)\n                    return ResponseResult.ErrorInfo(\"‚ùå Active WhatsApp sender (phoneNumberId) not found.\");\n\n                var businessId = ws.BusinessId;\n                var provider = (ws.Provider ?? \"\").Trim().ToUpperInvariant(); // \"META_CLOUD\" | \"PINNACLE\"\n                if (provider != \"META_CLOUD\" && provider != \"PINNACLE\")\n                    return ResponseResult.ErrorInfo($\"‚ùå Unsupported provider: {provider}\");\n\n                _logger.LogInformation(\n                    \"[CustomAPI:{ReqId}] Begin send. biz={BusinessId} pnid={PhoneNumberId} to={MaskedTo} template={TemplateId}\",\n                    reqId, businessId, req.PhoneNumberId, Mask(toNormalized), req.TemplateId);\n\n                // 2) Fetch template meta (for language + buttons)\n                var meta = await _templateFetcher.GetTemplateByNameAsync(businessId, req.TemplateId, includeButtons: true);\n                if (meta == null)\n                    return ResponseResult.ErrorInfo(\"‚ùå Template metadata not found for the given templateId.\");\n\n                var languageCode = (meta.Language ?? \"\").Trim();\n                if (string.IsNullOrWhiteSpace(languageCode))\n                    return ResponseResult.ErrorInfo(\"‚ùå Template language not resolved from provider metadata.\");\n\n                // 3) Header decision\n                var isVideoHeader = !string.IsNullOrWhiteSpace(req.VideoUrl);\n                if (isVideoHeader && !IsHttpsMp4Url(req.VideoUrl, out var vErr))\n                    return ResponseResult.ErrorInfo(\"üö´ Invalid VideoUrl.\", vErr);\n\n                // 4) Build components\n                var (components, whyBuildFail) = BuildComponents(isVideoHeader, req.Variables, req.VideoUrl);\n                if (components == null)\n                {\n                    _logger.LogWarning(\"[CustomAPI:{ReqId}] Component build failed: {Err}\", reqId, whyBuildFail);\n                    return ResponseResult.ErrorInfo($\"üö´ Component build failed: {whyBuildFail}\");\n                }\n\n                // 5) Snapshot first 3 buttons (optional analytics)\n                string? buttonBundleJson = null;\n                try\n                {\n                    if (meta.ButtonParams is { Count: > 0 })\n                    {\n                        var bundle = meta.ButtonParams.Take(3)\n                            .Select((b, i) => new\n                            {\n                                i,\n                                position = i + 1,\n                                text = (b.Text ?? \"\").Trim(),\n                                type = b.Type,\n                                subType = b.SubType\n                            }).ToList();\n                        buttonBundleJson = JsonConvert.SerializeObject(bundle);\n                    }\n                }\n                catch { /* best-effort snapshot */ }\n\n                // 6) Entry step for linked flow (optional)\n                Guid? entryStepId = null;\n                if (req.FlowConfigId.HasValue)\n                {\n                    entryStepId = await _context.CTAFlowSteps\n                        .Where(s => s.CTAFlowConfigId == req.FlowConfigId.Value)\n                        .OrderBy(s => s.StepOrder)\n                        .Select(s => (Guid?)s.Id)\n                        .FirstOrDefaultAsync(ct);\n                }\n\n                // 7) Build provider payload\n                var languageField = new { policy = \"deterministic\", code = string.IsNullOrWhiteSpace(languageCode) ? \"en_US\" : languageCode };\n                var payload = new\n                {\n                    messaging_product = \"whatsapp\",\n                    to = toNormalized,\n                    type = \"template\",\n                    template = new\n                    {\n                        name = req.TemplateId,\n                        language = languageField,\n                        components\n                    }\n                };\n\n                _logger.LogInformation(\"[CustomAPI:{ReqId}] Sending {Template} to {To} via {Provider} (PNID={PNID}) video={Video}\",\n                    reqId, req.TemplateId, Mask(toNormalized), provider, req.PhoneNumberId, isVideoHeader);\n\n                // 8) Send\n                var result = await _messageEngine.SendPayloadAsync(\n                    businessId: businessId,\n                    provider: provider,\n                    payload: payload,\n                    phoneNumberId: req.PhoneNumberId\n                );\n\n                // 9) Log + billing\n                var now = DateTime.UtcNow;\n                var logId = Guid.NewGuid();\n\n                _context.MessageLogs.Add(new MessageLog\n                {\n                    Id = logId,\n                    BusinessId = businessId,\n                    CampaignId = null,\n                    RecipientNumber = toNormalized,\n                    MessageContent = req.TemplateId,\n                    MediaUrl = isVideoHeader ? req.VideoUrl : null,\n                    Status = result.Success ? \"Sent\" : \"Failed\",\n                    MessageId = result.MessageId,          // or just ProviderMessageId; keep one if you want to de-dup\n                    ProviderMessageId = result.MessageId,\n                    ErrorMessage = result.ErrorMessage,\n                    RawResponse = result.RawResponse,\n                    CreatedAt = now,\n                    SentAt = result.Success ? now : (DateTime?)null,\n                    Source = \"custom_api\",\n                    Provider = provider,\n                    CTAFlowConfigId = req.FlowConfigId,\n                    CTAFlowStepId = entryStepId,\n                    ButtonBundleJson = buttonBundleJson\n                });\n\n                await _context.SaveChangesAsync(ct);\n\n                await _billingIngest.IngestFromSendResponseAsync(\n                    businessId: businessId,\n                    messageLogId: logId,\n                    provider: provider,\n                    rawResponseJson: result.RawResponse ?? \"{}\"\n                );\n\n                _logger.LogInformation(\"[CustomAPI:{ReqId}] Done. success={Success} msgId={MessageId} flow={Flow} step={Step}\",\n                    reqId, result.Success, result.MessageId, req.FlowConfigId, entryStepId);\n\n                return result.Success\n                    ? ResponseResult.SuccessInfo(\"üöÄ Template sent.\",\n                        new\n                        {\n                            messageId = result.MessageId,\n                            to = toNormalized,\n                            templateId = req.TemplateId,\n                            flowConfigId = req.FlowConfigId,\n                            flowEntryStepId = entryStepId\n                        })\n                    : ResponseResult.ErrorInfo(\"‚ùå Send failed.\", result.ErrorMessage);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Exception in CustomApiService.SendTemplateAsync\");\n                return ResponseResult.ErrorInfo(\"üö® Server error while sending template.\", ex.ToString());\n            }\n        }\n\n        // ===== helpers (unchanged) =====\n        private static string NormalizePhone(string raw) => raw.StartsWith(\"+\") ? raw[1..] : raw;\n        private static string Mask(string phone) => phone.Length <= 6 ? phone : $\"{new string('*', phone.Length - 4)}{phone[^4..]}\";\n        private static bool IsHttpsMp4Url(string? url, out string? err)\n        {\n            err = null;\n            if (string.IsNullOrWhiteSpace(url)) { err = \"VideoUrl is required when sending a VIDEO header.\"; return false; }\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var u)) { err = \"VideoUrl must be an absolute URL.\"; return false; }\n            if (u.Scheme != Uri.UriSchemeHttps) { err = \"VideoUrl must be HTTPS.\"; return false; }\n            if (!u.AbsolutePath.EndsWith(\".mp4\", StringComparison.OrdinalIgnoreCase)) { err = \"VideoUrl must point to an .mp4 file.\"; return false; }\n            return true;\n        }\n        //private static (List<object>? components, string? whyFail) BuildComponents(bool addVideoHeader, Dictionary<string, string>? variables, string? videoUrl)\n        //{\n        //    try\n        //    {\n        //        var components = new List<object>();\n        //        if (addVideoHeader)\n        //        {\n        //            components.Add(new\n        //            {\n        //                type = \"header\",\n        //                parameters = new object[] { new { type = \"video\", video = new { link = videoUrl } } }\n        //            });\n        //        }\n        //        if (variables is { Count: > 0 })\n        //        {\n        //            var bodyParams = variables\n        //                .Select(kv => (Index: int.TryParse(kv.Key, out var n) ? n : int.MaxValue, Text: kv.Value ?? string.Empty))\n        //                .OrderBy(x => x.Index)\n        //                .Select(x => new { type = \"text\", text = x.Text })\n        //                .ToArray();\n\n        //            if (bodyParams.Length > 0)\n        //                components.Add(new { type = \"body\", parameters = bodyParams });\n        //        }\n        //        return (components, null);\n        //    }\n        //    catch (Exception ex) { return (null, ex.Message); }\n        //}\n        private static (List<object>? components, string? whyFail) BuildComponents(\n         bool addVideoHeader,\n         Dictionary<string, string>? variables,\n         string? videoUrl)\n        {\n            try\n            {\n                var components = new List<object>();\n\n                // Header (optional video)\n                if (addVideoHeader)\n                {\n                    components.Add(new\n                    {\n                        type = \"header\",\n                        parameters = new object[]\n                        {\n                    new { type = \"video\", video = new { link = videoUrl } }\n                        }\n                    });\n                }\n\n                // Body params ({{1}}, {{2}}, ...) ‚Äî tolerate keys like \"1\", \"2\", \"para1\", \"foo2\"\n                if (variables is { Count: > 0 })\n                {\n                    var list = variables.ToList(); // preserves insertion order for non-numbered keys\n\n                    var bodyParams = list\n                        .Select((kv, idx) =>\n                        {\n                            var m = Regex.Match(kv.Key ?? string.Empty, @\"\\d+\");\n\n                            int n = 0; // declare first so it's always definitely assigned\n                            bool hasNum = m.Success && int.TryParse(m.Value, out n) && n > 0;\n\n                            // Numbered keys come first ordered by n; others follow in insertion order\n                            int orderKey = hasNum ? n : int.MaxValue - (list.Count - idx);\n\n                            return new { Order = orderKey, Text = kv.Value ?? string.Empty };\n                        })\n                        .OrderBy(x => x.Order)\n                        .Select(x => new { type = \"text\", text = x.Text })\n                        .ToArray();\n\n                    if (bodyParams.Length > 0)\n                        components.Add(new { type = \"body\", parameters = bodyParams });\n                }\n\n\n                return (components, null);\n            }\n            catch (Exception ex)\n            {\n                return (null, ex.Message);\n            }\n        }\n\n\n    }\n}\n\n//using System;\n//using System.Linq;\n//using System.Collections.Generic;\n//using System.Security.Claims;\n//using System.Threading;\n//using System.Threading.Tasks;\n//using Microsoft.EntityFrameworkCore;\n//using Microsoft.Extensions.Logging;\n//using Microsoft.AspNetCore.Http;\n//using Newtonsoft.Json;\n//using xbytechat.api.Features.CustomeApi.DTOs;\n//using xbytechat.api.Features.MessagesEngine.Services; // IMessageEngineService\n//using xbytechat.api.Features.TemplateModule.Services; // IWhatsAppTemplateFetcherService\n//using xbytechat.api.Models;                         // MessageLog\n//using xbytechat.api.Shared;                         // ResponseResult\n//using xbytechat_api.Features.Billing.Services;\n//using xbytechat.api.Helpers;      // IBillingIngestService\n//using xbytechat.api.WhatsAppSettings;\n//using xbytechat_api.WhatsAppSettings.Services;\n//namespace xbytechat.api.Features.CustomeApi.Services\n//{\n//    public sealed class CustomApiService : ICustomApiService\n//    {\n//        private readonly AppDbContext _context;\n//        private readonly IHttpContextAccessor _http;\n//        private readonly IWhatsAppTemplateFetcherService _templateFetcher;\n//        private readonly IMessageEngineService _messageEngine;\n//        private readonly IBillingIngestService _billingIngest;\n//        private readonly ILogger<CustomApiService> _logger;\n\n//        public CustomApiService(\n//            AppDbContext context,\n//            IHttpContextAccessor http,\n//            IWhatsAppTemplateFetcherService templateFetcher,\n//            IMessageEngineService messageEngine,\n//            IBillingIngestService billingIngest,\n//            ILogger<CustomApiService> logger)\n//        {\n//            _context = context;\n//            _http = http;\n//            _templateFetcher = templateFetcher;\n//            _messageEngine = messageEngine;\n//            _billingIngest = billingIngest;\n//            _logger = logger;\n//        }\n\n//        public async Task<ResponseResult> SendTemplateAsync(DirectTemplateSendRequest req, CancellationToken ct = default)\n//        {\n//            try\n//            {\n//                // --- 0) Basic validation\n//                if (string.IsNullOrWhiteSpace(req.PhoneNumberId))\n//                    return ResponseResult.ErrorInfo(\"‚ùå phoneNumberId is required.\");\n//                if (string.IsNullOrWhiteSpace(req.To))\n//                    return ResponseResult.ErrorInfo(\"‚ùå 'to' (recipient) is required.\");\n//                if (string.IsNullOrWhiteSpace(req.TemplateId))\n//                    return ResponseResult.ErrorInfo(\"‚ùå templateId is required.\");\n\n//                var businessId = GetBusinessIdOrThrow();\n//                var toNormalized = NormalizePhone(req.To);\n\n//                var reqId = Guid.NewGuid();\n//                _logger.LogInformation(\n//                    \"[CustomAPI:{ReqId}] Begin send. biz={BusinessId} pnid={PhoneNumberId} to={MaskedTo} template={TemplateId}\",\n//                    reqId, businessId, req.PhoneNumberId, Mask(toNormalized), req.TemplateId);\n\n//                // --- 1) Resolve provider by phoneNumberId for this Business\n//                var ws = await _context.WhatsAppSettings.AsNoTracking()\n//                    .Where(s => s.BusinessId == businessId && s.IsActive && s.PhoneNumberId == req.PhoneNumberId)\n//                    .OrderByDescending(s => s.UpdatedAt ?? s.CreatedAt)\n//                    .FirstOrDefaultAsync(ct);\n\n//                if (ws == null)\n//                    return ResponseResult.ErrorInfo(\"‚ùå Active WhatsApp sender (phoneNumberId) not found for this Business.\");\n\n//                var provider = (ws.Provider ?? \"\").Trim().ToUpperInvariant(); // \"META_CLOUD\" | \"PINNACLE\"\n//                if (provider != \"META_CLOUD\" && provider != \"PINNACLE\")\n//                    return ResponseResult.ErrorInfo($\"‚ùå Unsupported provider configured for this sender: {provider}\");\n\n//                // --- 2) Fetch template meta\n//                // NOTE: your metadata doesn't expose HeaderType; we just read language & buttons. \n//                var meta = await _templateFetcher.GetTemplateByNameAsync(businessId, req.TemplateId, includeButtons: true);\n//                if (meta == null)\n//                    return ResponseResult.ErrorInfo(\"‚ùå Template metadata not found for the given templateId.\");\n\n//                var languageCode = (meta.Language ?? \"\").Trim();\n//                if (string.IsNullOrWhiteSpace(languageCode))\n//                    return ResponseResult.ErrorInfo(\"‚ùå Template language not resolved from provider metadata.\");\n\n//                // Decide header by request: if VideoUrl present -> add VIDEO header; otherwise TEXT-only\n//                var isVideoHeader = !string.IsNullOrWhiteSpace(req.VideoUrl);\n//                if (isVideoHeader && !IsHttpsMp4Url(req.VideoUrl, out var vErr))\n//                    return ResponseResult.ErrorInfo(\"üö´ Invalid VideoUrl.\", vErr);\n\n//                // --- 3) Build components (TEXT or VIDEO)\n//                var (components, whyBuildFail) = BuildComponents(isVideoHeader, req.Variables, req.VideoUrl);\n//                if (components == null)\n//                {\n//                    _logger.LogWarning(\"[CustomAPI:{ReqId}] Component build failed: {Err}\", reqId, whyBuildFail);\n//                    return ResponseResult.ErrorInfo($\"üö´ Component build failed: {whyBuildFail}\");\n//                }\n\n//                // Snapshot first 3 buttons (if any) for analytics/click mapping (same as campaigns)\n//                string? buttonBundleJson = null;\n//                try\n//                {\n//                    if (meta.ButtonParams is { Count: > 0 })\n//                    {\n//                        var bundle = meta.ButtonParams.Take(3)\n//                            .Select((b, i) => new\n//                            {\n//                                i,\n//                                position = i + 1,\n//                                text = (b.Text ?? \"\").Trim(),\n//                                type = b.Type,\n//                                subType = b.SubType\n//                            }).ToList();\n//                        buttonBundleJson = JsonConvert.SerializeObject(bundle);\n//                    }\n//                }\n//                catch { /* best-effort snapshot */ }\n\n//                // Find entry step of the linked flow (if provided)\n//                Guid? entryStepId = null;\n//                if (req.FlowConfigId.HasValue)\n//                {\n//                    entryStepId = await _context.CTAFlowSteps\n//                        .Where(s => s.CTAFlowConfigId == req.FlowConfigId.Value)\n//                        .OrderBy(s => s.StepOrder)\n//                        .Select(s => (Guid?)s.Id)\n//                        .FirstOrDefaultAsync(ct);\n//                }\n\n\n//                // Always object. Meta accepts { code: \"en_US\" } and ignores policy if present.\n//                // Pinnacle REQUIRES an object.\n//                var languageField = new\n//                {\n//                    policy = \"deterministic\",\n//                    code = string.IsNullOrWhiteSpace(languageCode) ? \"en_US\" : languageCode\n//                };\n\n//                var payload = new\n//                {\n//                    messaging_product = \"whatsapp\",\n//                    to = toNormalized,\n//                    type = \"template\",\n//                    template = new\n//                    {\n//                        name = req.TemplateId,\n//                        language = languageField,\n//                        components\n//                    }\n//                };\n\n\n//                _logger.LogInformation(\"[CustomAPI:{ReqId}] Sending {Template} to {To} via {Provider} (PNID={PNID}) video={Video}\",\n//                    reqId, req.TemplateId, Mask(toNormalized), provider, req.PhoneNumberId, isVideoHeader);\n\n//                var result = await _messageEngine.SendPayloadAsync(\n//                    businessId: businessId,\n//                    provider: provider,\n//                    payload: payload,\n//                    phoneNumberId: req.PhoneNumberId   // ‚úÖ correct parameter\n//                );\n\n//                // --- 5) Persist MessageLog (and flow linkage), then billing\n//                var now = DateTime.UtcNow;\n//                var logId = Guid.NewGuid();\n\n//                _context.MessageLogs.Add(new MessageLog\n//                {\n//                    Id = logId,\n//                    BusinessId = businessId,\n//                    CampaignId = null,                         // direct API path\n//                    RecipientNumber = toNormalized,\n//                    MessageContent = req.TemplateId,\n//                    MediaUrl = isVideoHeader ? req.VideoUrl : null,\n//                    Status = result.Success ? \"Sent\" : \"Failed\",\n//                    MessageId = result.MessageId,\n//                    ErrorMessage = result.ErrorMessage,\n//                    RawResponse = result.RawResponse,\n//                    CreatedAt = now,\n//                    SentAt = result.Success ? now : (DateTime?)null,\n//                    Source = \"custom_api\",\n//                    Provider = provider,\n//                    ProviderMessageId = result.MessageId,\n\n//                    // üîó Store flow linkage like campaigns do\n//                    CTAFlowConfigId = req.FlowConfigId,\n//                    CTAFlowStepId = entryStepId,\n//                    ButtonBundleJson = buttonBundleJson\n//                });\n\n//                await _context.SaveChangesAsync(ct);\n\n//                await _billingIngest.IngestFromSendResponseAsync(\n//                    businessId: businessId,\n//                    messageLogId: logId,\n//                    provider: provider,\n//                    rawResponseJson: result.RawResponse ?? \"{}\"\n//                );\n\n//                _logger.LogInformation(\"[CustomAPI:{ReqId}] Done. success={Success} msgId={MessageId} flow={Flow} step={Step}\",\n//                    reqId, result.Success, result.MessageId, req.FlowConfigId, entryStepId);\n\n//                return result.Success\n//                    ? ResponseResult.SuccessInfo(\"üöÄ Template sent.\",\n//                        new\n//                        {\n//                            messageId = result.MessageId,\n//                            to = toNormalized,\n//                            templateId = req.TemplateId,\n//                            flowConfigId = req.FlowConfigId,\n//                            flowEntryStepId = entryStepId\n//                        })\n//                    : ResponseResult.ErrorInfo(\"‚ùå Send failed.\", result.ErrorMessage);\n//            }\n//            catch (Exception ex)\n//            {\n//                _logger.LogError(ex, \"‚ùå Exception in CustomApiService.SendTemplateAsync\");\n//                return ResponseResult.ErrorInfo(\"üö® Server error while sending template.\", ex.ToString());\n//            }\n//        }\n\n//        // ===== helpers =====\n\n//        private Guid GetBusinessIdOrThrow()\n//        {\n//            var user = _http.HttpContext?.User;\n//            if (user == null) throw new InvalidOperationException(\"Missing HttpContext/User.\");\n\n//            var bid = user.FindFirstValue(\"BusinessId\") ?? user.FindFirstValue(\"bid\") ?? user.FindFirstValue(\"business_id\");\n//            if (string.IsNullOrWhiteSpace(bid)) throw new InvalidOperationException(\"BusinessId claim is missing.\");\n//            return Guid.Parse(bid);\n//        }\n\n//        private static string NormalizePhone(string raw) => raw.StartsWith(\"+\") ? raw[1..] : raw;\n\n//        private static string Mask(string phone)\n//            => phone.Length <= 6 ? phone : $\"{new string('*', phone.Length - 4)}{phone[^4..]}\";\n\n//        private static bool IsHttpsMp4Url(string? url, out string? err)\n//        {\n//            err = null;\n//            if (string.IsNullOrWhiteSpace(url)) { err = \"VideoUrl is required when sending a VIDEO header.\"; return false; }\n//            if (!Uri.TryCreate(url, UriKind.Absolute, out var u)) { err = \"VideoUrl must be an absolute URL.\"; return false; }\n//            if (u.Scheme != Uri.UriSchemeHttps) { err = \"VideoUrl must be HTTPS.\"; return false; }\n//            if (!u.AbsolutePath.EndsWith(\".mp4\", StringComparison.OrdinalIgnoreCase)) { err = \"VideoUrl must point to an .mp4 file.\"; return false; }\n//            return true;\n//        }\n\n//        private static (List<object>? components, string? whyFail) BuildComponents(\n//            bool addVideoHeader,\n//            Dictionary<string, string>? variables,\n//            string? videoUrl)\n//        {\n//            try\n//            {\n//                var components = new List<object>();\n\n//                // Header (optional video)\n//                if (addVideoHeader)\n//                {\n//                    components.Add(new\n//                    {\n//                        type = \"header\",\n//                        parameters = new object[]\n//                        {\n//                            new { type = \"video\", video = new { link = videoUrl } }\n//                        }\n//                    });\n//                }\n\n//                // Body params ({{1}}, {{2}}, ...)\n//                if (variables is { Count: > 0 })\n//                {\n//                    var bodyParams = variables\n//                        .Select(kv => (Index: int.TryParse(kv.Key, out var n) ? n : int.MaxValue, Text: kv.Value ?? string.Empty))\n//                        .OrderBy(x => x.Index)\n//                        .Select(x => new { type = \"text\", text = x.Text })\n//                        .ToArray();\n\n//                    if (bodyParams.Length > 0)\n//                        components.Add(new { type = \"body\", parameters = bodyParams });\n//                }\n\n//                return (components, null);\n//            }\n//            catch (Exception ex)\n//            {\n//                return (null, ex.Message);\n//            }\n//        }\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomeApi/Services/ICtaJourneyPublisher.cs",
      "sha256": "179ba5f2372125cfe3c2aed455b5c8efa5b8f6de13ef2478d2e7e6df7890cd8e",
      "language": "csharp",
      "size": 443,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.CustomeApi.Services\n{\n    public interface ICtaJourneyPublisher\n    {\n        /// <summary>\n        /// Posts a CTAJourney event for the given business to all active endpoints in CustomerWebhookConfigs.\n        /// </summary>\n        Task PublishAsync(Guid businessId, Models.CtaJourneyEventDto dto, CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomeApi/Services/ICustomApiService.cs",
      "sha256": "76cd53ece80c088bec742c33974d8a8be781cd297d3d68e474150b19707e1f1e",
      "language": "csharp",
      "size": 377,
      "content": "using System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CustomeApi.DTOs;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.CustomeApi.Services\n{\n    public interface ICustomApiService\n    {\n        Task<ResponseResult> SendTemplateAsync(DirectTemplateSendRequest req, CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomFields/Controllers/CustomFieldsController.cs",
      "sha256": "ecf01929abd50cfb7140cfea5df6189af25ebc85d7cef8081b4cdbb33023abb5",
      "language": "csharp",
      "size": 6451,
      "content": "using System;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.AccessControl.PermissionAttributes;\nusing xbytechat.api.Features.AccessControl.Seeder;\nusing xbytechat.api.Features.CustomFields.Dtos;\nusing xbytechat.api.Features.CustomFields.Services;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.CustomFields.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize]\n    public sealed class CustomFieldsController : ControllerBase\n    {\n        private readonly ICustomFieldsService _service;\n\n        public CustomFieldsController(ICustomFieldsService service)\n        {\n            _service = service;\n        }\n\n        private Guid GetBusinessIdOrReject(out IActionResult? errorResult)\n        {\n            errorResult = null;\n\n            var businessId = HttpContext.User.GetBusinessId();\n            if (businessId == Guid.Empty)\n            {\n                errorResult = Unauthorized(ResponseResult.ErrorInfo(\"Missing BusinessId in user claims.\"));\n                return Guid.Empty;\n            }\n\n            return businessId;\n        }\n\n        // --------------------------------------------------------------------\n        // Definitions (READ = allow any authenticated user in the business)\n        // --------------------------------------------------------------------\n\n        /// <summary>\n        /// READ schema for the given entityType (e.g. CONTACT).\n        /// ‚úÖ MVP: Allow any authenticated user (business-scoped). This matches the current CRM module behavior.\n        /// Later you can add a dedicated permission like: customfields.view\n        /// </summary>\n        [HttpGet(\"definitions\")]\n        public async Task<IActionResult> GetDefinitions(\n            [FromQuery] string entityType = \"CONTACT\",\n            [FromQuery] bool includeInactive = false)\n        {\n            var bizId = GetBusinessIdOrReject(out var err);\n            if (err != null) return err;\n\n            var rows = await _service.GetDefinitionsAsync(bizId, entityType, includeInactive);\n            return Ok(ResponseResult.SuccessInfo(\"‚úÖ Custom field definitions fetched.\", rows));\n        }\n\n        /// <summary>\n        /// Managing schema is an \"admin-ish\" action.\n        /// Reusing TagsEdit for now as the closest existing CRM admin permission.\n        /// (Later: introduce customfields.manage / customfields.edit)\n        /// </summary>\n        [HttpPost(\"definitions\")]\n        \n        public async Task<IActionResult> CreateDefinition([FromBody] CreateCustomFieldDefinitionDto dto)\n        {\n            var bizId = GetBusinessIdOrReject(out var err);\n            if (err != null) return err;\n\n            var created = await _service.CreateDefinitionAsync(bizId, dto);\n            return Ok(ResponseResult.SuccessInfo(\"‚úÖ Custom field definition created.\", created));\n        }\n\n        [HttpPut(\"definitions/{fieldId:guid}\")]\n        \n        public async Task<IActionResult> UpdateDefinition([FromRoute] Guid fieldId, [FromBody] UpdateCustomFieldDefinitionDto dto)\n        {\n            var bizId = GetBusinessIdOrReject(out var err);\n            if (err != null) return err;\n\n            var updated = await _service.UpdateDefinitionAsync(bizId, fieldId, dto);\n            return Ok(ResponseResult.SuccessInfo(\"‚úÖ Custom field definition updated.\", updated));\n        }\n\n        [HttpDelete(\"definitions/{fieldId:guid}\")]\n       \n        public async Task<IActionResult> DeactivateDefinition([FromRoute] Guid fieldId)\n        {\n            var bizId = GetBusinessIdOrReject(out var err);\n            if (err != null) return err;\n\n            var ok = await _service.DeactivateDefinitionAsync(bizId, fieldId);\n            return Ok(ResponseResult.SuccessInfo(ok ? \"‚úÖ Field deactivated.\" : \"‚ÑπÔ∏è Field not found.\", ok));\n        }\n\n        // --------------------------------------------------------------------\n        // Values (READ = allow any authenticated user in the business)\n        // --------------------------------------------------------------------\n\n        /// <summary>\n        /// ‚úÖ MVP: Allow reading values for any authenticated user (business-scoped).\n        /// Later you can gate with a dedicated permission like: customfields.values.view\n        /// </summary>\n        [HttpGet(\"values\")]\n        public async Task<IActionResult> GetValues([FromQuery] string entityType, [FromQuery] Guid entityId)\n        {\n            var bizId = GetBusinessIdOrReject(out var err);\n            if (err != null) return err;\n\n            if (entityId == Guid.Empty)\n                return BadRequest(ResponseResult.ErrorInfo(\"EntityId is required.\"));\n\n            var rows = await _service.GetValuesAsync(bizId, entityType, entityId);\n            return Ok(ResponseResult.SuccessInfo(\"‚úÖ Custom field values fetched.\", rows));\n        }\n\n        /// <summary>\n        /// Upserting values changes CRM data. Keep it strict for MVP.\n        /// Reusing TagsEdit for now as \"CRM admin/edit\" gate.\n        /// </summary>\n        [HttpPut(\"values\")]\n      \n        public async Task<IActionResult> UpsertValues([FromBody] UpsertCustomFieldValuesDto dto)\n        {\n            var bizId = GetBusinessIdOrReject(out var err);\n            if (err != null) return err;\n\n            await _service.UpsertValuesAsync(bizId, dto);\n            return Ok(ResponseResult.SuccessInfo(\"‚úÖ Custom field values saved.\", true));\n        }\n\n        /// <summary>\n        /// Convenience endpoint for UI: fetch active definitions + current values.\n        /// ‚úÖ MVP: Allow any authenticated user (business-scoped) so the page can load.\n        /// </summary>\n        [HttpGet(\"schema-with-values\")]\n        public async Task<IActionResult> GetSchemaWithValues([FromQuery] string entityType, [FromQuery] Guid entityId)\n        {\n            var bizId = GetBusinessIdOrReject(out var err);\n            if (err != null) return err;\n\n            if (entityId == Guid.Empty)\n                return BadRequest(ResponseResult.ErrorInfo(\"EntityId is required.\"));\n\n            var data = await _service.GetSchemaWithValuesAsync(bizId, entityType, entityId);\n\n            return Ok(ResponseResult.SuccessInfo(\"‚úÖ Schema + values fetched.\", new\n            {\n                definitions = data.Definitions,\n                values = data.Values\n            }));\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomFields/Dtos/CreateCustomFieldDefinitionDto.cs",
      "sha256": "5c8d8fbec4a4956c22be7fbd07d8f9db34147173a9fdaa5df90ac021ab2be2ba",
      "language": "csharp",
      "size": 1119,
      "content": "using System.Text.Json;\n\nnamespace xbytechat.api.Features.CustomFields.Dtos\n{\n    /// <summary>\n    /// Request DTO to create a custom field definition.\n    /// </summary>\n    public sealed class CreateCustomFieldDefinitionDto\n    {\n        public string EntityType { get; set; } = \"Contact\";\n\n        /// <summary>\n        /// Stable internal key (snake_case recommended).\n        /// </summary>\n        public string Key { get; set; } = string.Empty;\n\n        /// <summary>\n        /// UI label.\n        /// </summary>\n        public string Label { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Data type as string:\n        /// \"Text\", \"Number\", \"Date\", \"Boolean\", \"SingleSelect\", \"MultiSelect\"\n        /// </summary>\n        public string DataType { get; set; } = \"Text\";\n\n        /// <summary>\n        /// For select types: options and any future metadata.\n        /// Example: {\"options\":[\"Retail\",\"Wholesale\"]}\n        /// </summary>\n        public JsonElement? Options { get; set; }\n\n        public bool IsRequired { get; set; } = false;\n\n        public int SortOrder { get; set; } = 0;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomFields/Dtos/CustomFieldDefinitionDto.cs",
      "sha256": "900fcaef78d5af086eeb456dce5c60463f20c8ae8623ba97d7426459f9b9111d",
      "language": "csharp",
      "size": 1322,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CustomFields.Dtos\n{\n    /// <summary>\n    /// Response DTO for a Custom Field Definition (schema).\n    /// </summary>\n    public sealed class CustomFieldDefinitionDto\n    {\n        public Guid Id { get; set; }\n\n        public string EntityType { get; set; } = \"Contact\";\n\n        /// <summary>\n        /// Stable internal key (snake_case recommended).\n        /// Example: gst_number\n        /// </summary>\n        public string Key { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Human label shown in UI.\n        /// Example: \"GST Number\"\n        /// </summary>\n        public string Label { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Data type as string to avoid enum-serialization surprises across clients.\n        /// Example: \"Text\", \"Number\", \"Date\", \"Boolean\", \"SingleSelect\", \"MultiSelect\"\n        /// </summary>\n        public string DataType { get; set; } = \"Text\";\n\n        /// <summary>\n        /// Options metadata stored as JSON (for select types).\n        /// Example: {\"options\":[\"A\",\"B\",\"C\"]}\n        /// </summary>\n        public string? OptionsJson { get; set; }\n\n        public bool IsRequired { get; set; }\n\n        public bool IsActive { get; set; } = true;\n\n        public int SortOrder { get; set; } = 0;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomFields/Dtos/CustomFieldValueDto.cs",
      "sha256": "bdec3fe529d4fa6e940e5e065fcd5c69913cde775c085ec0a13d70ce39009cf0",
      "language": "csharp",
      "size": 496,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CustomFields.Dtos\n{\n    /// <summary>\n    /// Represents a stored value for a field for a specific entity record.\n    /// Returned to the UI as raw JSON (ValueJson).\n    /// </summary>\n    public sealed class CustomFieldValueDto\n    {\n        public Guid FieldId { get; set; }\n\n        /// <summary>\n        /// Stored jsonb payload (we store as {\"value\": ...}).\n        /// </summary>\n        public string ValueJson { get; set; } = \"{}\";\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomFields/Dtos/UpdateCustomFieldDefinitionDto.cs",
      "sha256": "c9ce1b7b1191fb5ff90d5864a744ede5b399aa8e956a107abf8777de98f15694",
      "language": "csharp",
      "size": 793,
      "content": "using System.Text.Json;\n\nnamespace xbytechat.api.Features.CustomFields.Dtos\n{\n    /// <summary>\n    /// Request DTO to update a custom field definition.\n    /// We keep it flexible; service decides what fields are allowed to change.\n    /// </summary>\n    public sealed class UpdateCustomFieldDefinitionDto\n    {\n\n        public string? Label { get; set; }\n        /// <summary>\n        /// Optional: allow changing datatype later if you want,\n        /// but by default we typically keep datatype immutable.\n        /// </summary>\n        public string? DataType { get; set; }\n\n        public JsonElement? Options { get; set; }\n\n        public bool IsRequired { get; set; } = false;\n\n        public bool IsActive { get; set; } = true;\n\n        public int SortOrder { get; set; } = 0;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomFields/Dtos/UpsertCustomFieldValuesDto.cs",
      "sha256": "244c2783ce9d142c608569b620b83fe2d8470941dc4f76f116d5145398fefe4d",
      "language": "csharp",
      "size": 1019,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Text.Json;\n\nnamespace xbytechat.api.Features.CustomFields.Dtos\n{\n    /// <summary>\n    /// Bulk upsert values for one record (e.g., one Contact).\n    /// </summary>\n    public sealed class UpsertCustomFieldValuesDto\n    {\n        public string EntityType { get; set; } = \"CONTACT\";\n\n        /// <summary>\n        /// Record id (e.g., ContactId).\n        /// </summary>\n        public Guid EntityId { get; set; }\n\n        /// <summary>\n        /// Values to upsert.\n        /// Service will wrap each into {\"value\": <this>} for storage.\n        /// </summary>\n        public List<UpsertCustomFieldValueItemDto> Values { get; set; } = new();\n    }\n\n    public sealed class UpsertCustomFieldValueItemDto\n    {\n        public Guid FieldId { get; set; }\n\n        /// <summary>\n        /// Typed value as JSON.\n        /// Examples: \"abc\", 123, true, \"2025-12-14T00:00:00Z\", [\"A\",\"B\"]\n        /// </summary>\n        public JsonElement? Value { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomFields/Models/CustomFieldDataType.cs",
      "sha256": "c34fd6245abd51bdeb61eb68ccc716e4dac10e038ae2caac971a7119712a1765",
      "language": "csharp",
      "size": 397,
      "content": "namespace xbytechat.api.Features.CustomFields.Models\n{\n    /// <summary>\n    /// Supported field data types for Custom Fields.\n    /// Stored as string in DB for readability and forward compatibility.\n    /// </summary>\n    public enum CustomFieldDataType\n    {\n        Text = 1,\n        Number = 2,\n        Date = 3,\n        Boolean = 4,\n        SingleSelect = 5,\n        MultiSelect = 6\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomFields/Models/CustomFieldDefinition.cs",
      "sha256": "c77155600842690a22f247b27ed7e8abc865ace70e10d1dd55d5f5f6d09fb9be",
      "language": "csharp",
      "size": 1889,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CustomFields.Models\n{\n    /// <summary>\n    /// Defines a custom field (schema) for a Business and an EntityType (e.g., Contact).\n    /// Example:\n    ///  - EntityType = \"Contact\"\n    ///  - Key = \"gst_number\"\n    ///  - Label = \"GST Number\"\n    ///  - DataType = Text\n    /// </summary>\n    public sealed class CustomFieldDefinition\n    {\n        public Guid Id { get; set; }\n\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// Target entity type. Keep it flexible as string so we can reuse this module later:\n        /// \"Contact\", \"Conversation\", \"MessageLog\", etc.\n        /// </summary>\n        public string EntityType { get; set; } = \"Contact\";\n\n        /// <summary>\n        /// Stable key used internally (snake_case recommended).\n        /// Example: gst_number, preferred_language\n        /// </summary>\n        public string Key { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Human-friendly label shown in UI.\n        /// Example: \"GST Number\"\n        /// </summary>\n        public string Label { get; set; } = string.Empty;\n\n        public CustomFieldDataType DataType { get; set; } = CustomFieldDataType.Text;\n\n        /// <summary>\n        /// For select types: store options, UI metadata, validation rules etc.\n        /// Stored as jsonb.\n        /// Example: {\"options\":[\"A\",\"B\",\"C\"]}\n        /// </summary>\n        public string? OptionsJson { get; set; }\n\n        public bool IsRequired { get; set; } = false;\n\n        public bool IsActive { get; set; } = true;\n\n        public int SortOrder { get; set; } = 0;\n\n        public DateTime CreatedAtUtc { get; set; } = DateTime.UtcNow;\n\n        /// <summary>\n        /// Updated automatically by your UpdatedAtUtcInterceptor.\n        /// </summary>\n        public DateTime UpdatedAtUtc { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomFields/Models/CustomFieldValue.cs",
      "sha256": "b426921280a31a2ae1fa61ba8114eaa6060b51724f4c794ba261a46e00d06fa7",
      "language": "csharp",
      "size": 1590,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CustomFields.Models\n{\n    /// <summary>\n    /// Stores a field value for a specific entity record.\n    /// Example:\n    ///  - EntityType = \"Contact\"\n    ///  - EntityId = Contact.Id\n    ///  - FieldId = CustomFieldDefinition.Id\n    ///  - ValueJson = {\"value\":\"27ABCDE1234F1Z5\"} or {\"value\":true} etc.\n    /// </summary>\n    public sealed class CustomFieldValue\n    {\n        public Guid Id { get; set; }\n\n        public Guid BusinessId { get; set; }\n\n        public string EntityType { get; set; } = \"Contact\";\n\n        /// <summary>\n        /// The record id (e.g., ContactId) this value belongs to.\n        /// </summary>\n        public Guid EntityId { get; set; }\n\n        public Guid FieldId { get; set; }\n\n        /// <summary>\n        /// JSON payload holding the typed value.\n        /// For simplicity we always store jsonb. UI/service enforces shape.\n        /// Example:\n        ///  {\"value\":\"text\"}\n        ///  {\"value\":123}\n        ///  {\"value\":true}\n        ///  {\"value\":\"2025-12-14T00:00:00Z\"}\n        ///  {\"value\":[\"A\",\"B\"]}\n        /// </summary>\n        public string ValueJson { get; set; } = \"{}\";\n\n        public bool IsActive { get; set; } = true;\n\n        public DateTime CreatedAtUtc { get; set; } = DateTime.UtcNow;\n\n        /// <summary>\n        /// Updated automatically by your UpdatedAtUtcInterceptor.\n        /// </summary>\n        public DateTime UpdatedAtUtc { get; set; } = DateTime.UtcNow;\n\n        // Navigation (optional but helpful)\n        public CustomFieldDefinition? Field { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomFields/Services/CustomFieldsService.cs",
      "sha256": "a737e85a6564984ca45fab12ff85378dfe5d642e8523f851c20e21be7f75cf1e",
      "language": "csharp",
      "size": 11843,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.Json;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.CustomFields.Dtos;\nusing xbytechat.api.Features.CustomFields.Models;\n\nnamespace xbytechat.api.Features.CustomFields.Services\n{\n    public sealed class CustomFieldsService : ICustomFieldsService\n    {\n        private readonly AppDbContext _db;\n\n        // key: snake_case recommended, enforce stable internal keys\n        private static readonly Regex KeyRegex = new(\"^[a-z][a-z0-9_]{0,119}$\", RegexOptions.Compiled);\n\n        public CustomFieldsService(AppDbContext db)\n        {\n            _db = db;\n        }\n\n        public async Task<List<CustomFieldDefinitionDto>> GetDefinitionsAsync(Guid businessId, string entityType, bool includeInactive)\n        {\n            var et = NormalizeEntityType(entityType);\n\n            var q = _db.CustomFieldDefinitions\n                .AsNoTracking()\n                .Where(x => x.BusinessId == businessId && x.EntityType == et);\n\n            if (!includeInactive)\n                q = q.Where(x => x.IsActive);\n\n            var rows = await q.OrderBy(x => x.SortOrder).ThenBy(x => x.Label).ToListAsync();\n\n            return rows.Select(MapDefinition).ToList();\n        }\n\n        public async Task<CustomFieldDefinitionDto> CreateDefinitionAsync(Guid businessId, CreateCustomFieldDefinitionDto dto)\n        {\n            var et = NormalizeEntityType(dto.EntityType);\n            var key = NormalizeKey(dto.Key);\n\n            ValidateDefinitionInputs(key, dto.Label);\n\n            // DB unique index exists, but we still do a friendly pre-check for better error messages.\n            var exists = await _db.CustomFieldDefinitions\n                .AnyAsync(x => x.BusinessId == businessId && x.EntityType == et && x.Key == key);\n\n            if (exists)\n                throw new InvalidOperationException($\"Custom field key '{key}' already exists for entity '{et}'.\");\n\n            var entity = new CustomFieldDefinition\n            {\n                Id = Guid.NewGuid(),\n                BusinessId = businessId,\n                EntityType = et,\n                Key = key,\n                Label = dto.Label.Trim(),\n                DataType = ParseDataType(dto.DataType),\n                OptionsJson = NormalizeOptions(dto.Options),\n                IsRequired = dto.IsRequired,\n                IsActive = true,\n                SortOrder = dto.SortOrder\n            };\n\n            _db.CustomFieldDefinitions.Add(entity);\n            await _db.SaveChangesAsync();\n\n            return MapDefinition(entity);\n        }\n\n        public async Task<CustomFieldDefinitionDto> UpdateDefinitionAsync(Guid businessId, Guid fieldId, UpdateCustomFieldDefinitionDto dto)\n        {\n            var entity = await _db.CustomFieldDefinitions\n                .FirstOrDefaultAsync(x => x.Id == fieldId && x.BusinessId == businessId);\n\n            if (entity == null)\n                throw new KeyNotFoundException(\"Custom field definition not found.\");\n\n            // Do NOT allow changing EntityType/Key in MVP (prevents breaking existing data + joins).\n            if (!string.IsNullOrWhiteSpace(dto.Label))\n                entity.Label = dto.Label.Trim();\n\n            if (!string.IsNullOrWhiteSpace(dto.DataType))\n                entity.DataType = ParseDataType(dto.DataType);\n\n            if (dto.Options != null)\n                entity.OptionsJson = NormalizeOptions(dto.Options);\n\n            entity.IsRequired = dto.IsRequired;\n            entity.IsActive = dto.IsActive;\n            entity.SortOrder = dto.SortOrder;\n\n            await _db.SaveChangesAsync();\n            return MapDefinition(entity);\n        }\n\n        public async Task<bool> DeactivateDefinitionAsync(Guid businessId, Guid fieldId)\n        {\n            var entity = await _db.CustomFieldDefinitions\n                .FirstOrDefaultAsync(x => x.Id == fieldId && x.BusinessId == businessId);\n\n            if (entity == null) return false;\n\n            entity.IsActive = false;\n            await _db.SaveChangesAsync();\n            return true;\n        }\n\n        public async Task<List<CustomFieldValueDto>> GetValuesAsync(Guid businessId, string entityType, Guid entityId)\n        {\n            var et = NormalizeEntityType(entityType);\n\n            var rows = await _db.CustomFieldValues\n                .AsNoTracking()\n                .Where(x => x.BusinessId == businessId && x.EntityType == et && x.EntityId == entityId)\n                .ToListAsync();\n\n            return rows.Select(x => new CustomFieldValueDto\n            {\n                FieldId = x.FieldId,\n                ValueJson = x.ValueJson ?? \"{}\"\n            }).ToList();\n        }\n\n        public async Task UpsertValuesAsync(Guid businessId, UpsertCustomFieldValuesDto dto)\n        {\n            var et = NormalizeEntityType(dto.EntityType);\n\n            if (dto.EntityId == Guid.Empty)\n                throw new ArgumentException(\"EntityId is required.\");\n\n            if (dto.Values == null || dto.Values.Count == 0)\n                return;\n\n            // Load definitions once, validate field ownership + types\n            var fieldIds = dto.Values.Select(v => v.FieldId).Distinct().ToList();\n\n            var defs = await _db.CustomFieldDefinitions\n                .AsNoTracking()\n                .Where(x => x.BusinessId == businessId && x.EntityType == et && fieldIds.Contains(x.Id) && x.IsActive)\n                .ToListAsync();\n\n            if (defs.Count != fieldIds.Count)\n                throw new InvalidOperationException(\"One or more fields are invalid/inactive for this business/entity.\");\n\n            var defMap = defs.ToDictionary(x => x.Id, x => x);\n\n            // Fetch existing values for this entity+fields\n            var existing = await _db.CustomFieldValues\n                .Where(x => x.BusinessId == businessId && x.EntityType == et && x.EntityId == dto.EntityId && fieldIds.Contains(x.FieldId))\n                .ToListAsync();\n\n            var existingMap = existing.ToDictionary(x => x.FieldId, x => x);\n\n            foreach (var item in dto.Values)\n            {\n                if (item.FieldId == Guid.Empty)\n                    throw new ArgumentException(\"FieldId is required.\");\n\n                var def = defMap[item.FieldId];\n                var wrapped = WrapAndValidateValue(def, item.Value);\n\n                if (existingMap.TryGetValue(item.FieldId, out var row))\n                {\n                    row.ValueJson = wrapped;\n                }\n                else\n                {\n                    _db.CustomFieldValues.Add(new CustomFieldValue\n                    {\n                        Id = Guid.NewGuid(),\n                        BusinessId = businessId,\n                        EntityType = et,\n                        EntityId = dto.EntityId,\n                        FieldId = item.FieldId,\n                        ValueJson = wrapped\n                    });\n                }\n            }\n\n            await _db.SaveChangesAsync();\n        }\n\n        public async Task<(List<CustomFieldDefinitionDto> Definitions, List<CustomFieldValueDto> Values)> GetSchemaWithValuesAsync(\n            Guid businessId, string entityType, Guid entityId)\n        {\n            var defs = await GetDefinitionsAsync(businessId, entityType, includeInactive: false);\n            var vals = await GetValuesAsync(businessId, entityType, entityId);\n            return (defs, vals);\n        }\n\n        // ---------------- helpers ----------------\n\n        private static string NormalizeEntityType(string entityType)\n        {\n            var et = (entityType ?? \"\").Trim();\n            if (string.IsNullOrWhiteSpace(et)) et = \"CONTACT\";\n            return et.ToUpperInvariant(); // canonical storage + comparisons\n        }\n\n        private static string NormalizeKey(string key)\n        {\n            var k = (key ?? \"\").Trim().ToLowerInvariant();\n            if (!KeyRegex.IsMatch(k))\n                throw new ArgumentException(\"Key must be snake_case (a-z, 0-9, underscore), max 120 chars.\");\n            return k;\n        }\n\n        private static void ValidateDefinitionInputs(string key, string label)\n        {\n            if (string.IsNullOrWhiteSpace(label))\n                throw new ArgumentException(\"Label is required.\");\n\n            if (label.Trim().Length > 200)\n                throw new ArgumentException(\"Label too long (max 200).\");\n\n            // key already validated by regex\n        }\n\n        private static CustomFieldDataType ParseDataType(string? dataType)\n        {\n            var raw = (dataType ?? \"Text\").Trim();\n\n            if (Enum.TryParse<CustomFieldDataType>(raw, ignoreCase: true, out var dt))\n                return dt;\n\n            throw new ArgumentException($\"Invalid DataType '{raw}'.\");\n        }\n\n        private static string? NormalizeOptions(JsonElement? options)\n        {\n            if (options == null) return null;\n\n            var kind = options.Value.ValueKind;\n            if (kind is JsonValueKind.Null or JsonValueKind.Undefined)\n                return null;\n\n            // (Recommended) options should be object/array, not a primitive\n            if (kind is not (JsonValueKind.Object or JsonValueKind.Array))\n                throw new ArgumentException(\"Options must be a JSON object or array.\");\n\n            // JsonElement is already validated JSON. Store normalized JSON text.\n            return options.Value.GetRawText();\n        }\n\n        private static string WrapAndValidateValue(CustomFieldDefinition def, JsonElement? value)\n        {\n            // Required check\n            if (def.IsRequired && (value == null || value.Value.ValueKind == JsonValueKind.Null))\n                throw new ArgumentException($\"Field '{def.Label}' is required.\");\n\n            // Minimal type checks (MVP). You can extend later.\n            if (value != null && value.Value.ValueKind != JsonValueKind.Null)\n            {\n                switch (def.DataType)\n                {\n                    case CustomFieldDataType.Number:\n                        if (value.Value.ValueKind != JsonValueKind.Number)\n                            throw new ArgumentException($\"Field '{def.Label}' must be a number.\");\n                        break;\n\n                    case CustomFieldDataType.Boolean:\n                        if (value.Value.ValueKind is not (JsonValueKind.True or JsonValueKind.False))\n                            throw new ArgumentException($\"Field '{def.Label}' must be boolean.\");\n                        break;\n\n                    case CustomFieldDataType.MultiSelect:\n                        if (value.Value.ValueKind != JsonValueKind.Array)\n                            throw new ArgumentException($\"Field '{def.Label}' must be an array.\");\n                        break;\n\n                    default:\n                        // Text/Date/SingleSelect/etc -> keep permissive for MVP\n                        break;\n                }\n            }\n\n            // Wrap into {\"value\": ...}\n            var wrapped = JsonSerializer.Serialize(new Dictionary<string, object?>\n            {\n                [\"value\"] = value?.Deserialize<object?>()\n            });\n\n            return wrapped;\n        }\n\n        private static CustomFieldDefinitionDto MapDefinition(CustomFieldDefinition x)\n        {\n            return new CustomFieldDefinitionDto\n            {\n                Id = x.Id,\n                EntityType = x.EntityType,\n                Key = x.Key,\n                Label = x.Label,\n                DataType = x.DataType.ToString(),\n                OptionsJson = x.OptionsJson,\n                IsRequired = x.IsRequired,\n                IsActive = x.IsActive,\n                SortOrder = x.SortOrder\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomFields/Services/ICustomFieldsService.cs",
      "sha256": "ef65bd10b54038c7ddd79b8a0ffe8acb8d0dbf49ebac02f3f6270f6341771c22",
      "language": "csharp",
      "size": 1190,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CustomFields.Dtos;\n\nnamespace xbytechat.api.Features.CustomFields.Services\n{\n    public interface ICustomFieldsService\n    {\n        Task<List<CustomFieldDefinitionDto>> GetDefinitionsAsync(Guid businessId, string entityType, bool includeInactive);\n        Task<CustomFieldDefinitionDto> CreateDefinitionAsync(Guid businessId, CreateCustomFieldDefinitionDto dto);\n        Task<CustomFieldDefinitionDto> UpdateDefinitionAsync(Guid businessId, Guid fieldId, UpdateCustomFieldDefinitionDto dto);\n        Task<bool> DeactivateDefinitionAsync(Guid businessId, Guid fieldId);\n\n        Task<List<CustomFieldValueDto>> GetValuesAsync(Guid businessId, string entityType, Guid entityId);\n        Task UpsertValuesAsync(Guid businessId, UpsertCustomFieldValuesDto dto);\n\n        /// <summary>\n        /// Convenience endpoint for UI: returns schema + current values for a record.\n        /// </summary>\n        Task<(List<CustomFieldDefinitionDto> Definitions, List<CustomFieldValueDto> Values)> GetSchemaWithValuesAsync(\n            Guid businessId, string entityType, Guid entityId);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Controllers/BusinessPermissionOverridesController.cs",
      "sha256": "35228864f3a058afa42ee724d48b3665982a89b904a064c2d4471dd985d6aa2d",
      "language": "csharp",
      "size": 1898,
      "content": "using System;\nusing System.Security.Claims;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.Entitlements.DTOs;\nusing xbytechat.api.Features.Entitlements.Services;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.Entitlements.Controllers\n{\n    [ApiController]\n    [Route(\"api/admin/businesses/{businessId:guid}/permission-overrides\")]\n    [Authorize(Roles = \"admin,partner,reseller\")]\n    public sealed class BusinessPermissionOverridesController : ControllerBase\n    {\n        private readonly IBusinessPermissionOverrideService _service;\n\n        public BusinessPermissionOverridesController(IBusinessPermissionOverrideService service)\n        {\n            _service = service;\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> Get(Guid businessId)\n        {\n            var rows = await _service.GetAsync(businessId);\n            return Ok(ResponseResult.SuccessInfo(\"‚úÖ Overrides fetched.\", rows));\n        }\n\n        [HttpPost]\n        public async Task<IActionResult> Upsert(Guid businessId, [FromBody] UpsertBusinessPermissionOverrideDto dto)\n        {\n            var actorUserId = GetUserId();\n            var res = await _service.UpsertAsync(businessId, actorUserId, dto);\n            return Ok(res);\n        }\n\n        [HttpDelete(\"{permissionCode}\")]\n        public async Task<IActionResult> Revoke(Guid businessId, string permissionCode)\n        {\n            var actorUserId = GetUserId();\n            var res = await _service.RevokeByPermissionCodeAsync(businessId, actorUserId, permissionCode);\n            return Ok(res);\n        }\n\n        private Guid GetUserId()\n        {\n            var raw = User.FindFirstValue(\"id\") ?? User.FindFirstValue(ClaimTypes.NameIdentifier);\n            return Guid.TryParse(raw, out var id) ? id : Guid.Empty;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Controllers/EntitlementsController.cs",
      "sha256": "0c435fe50cb96bd08c30f57eb23775a506bd85d7555798508742e38ecc668977",
      "language": "csharp",
      "size": 3151,
      "content": "#nullable enable\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.Entitlements.DTOs;\nusing xbytechat.api.Features.Entitlements.Services;\nusing xbytechat.api.Helpers; // ‚úÖ Use shared helpers for claims\n\nnamespace xbytechat.api.Features.Entitlements.Controllers\n{\n    [ApiController]\n    [Route(\"api/entitlements\")]\n    [Authorize]\n    public sealed class EntitlementsController : ControllerBase\n    {\n        private readonly IQuotaService _quota;\n\n        // Roles are stored lower-case in JWT (JwtTokenService),\n        // so we treat \"admin\" and \"superadmin\" as global admins.\n        private const string AdminRoleAdmin = \"admin\";\n        private const string AdminRoleSuperAdmin = \"superadmin\";\n\n        public EntitlementsController(IQuotaService quota)\n        {\n            _quota = quota;\n        }\n\n        // Helpers\n        private Guid? TryGetCallerBusinessId()\n        {\n            // Centralized logic: reads \"businessId\" claim.\n            var id = UserContextHelper.GetBusinessId(User);\n            return id == Guid.Empty ? (Guid?)null : id;\n        }\n\n        private bool IsAdmin()\n        {\n            return User.IsInRole(AdminRoleAdmin) || User.IsInRole(AdminRoleSuperAdmin);\n        }\n\n        private bool IsAuthorizedFor(Guid targetBusinessId)\n        {\n            if (IsAdmin()) return true;\n\n            var callerBiz = TryGetCallerBusinessId();\n            return callerBiz.HasValue && callerBiz.Value == targetBusinessId;\n        }\n\n        // GET /api/entitlements/{businessId}\n        [HttpGet(\"{businessId:guid}\")]\n        public async Task<ActionResult<EntitlementsSnapshotDto>> GetSnapshot(\n            Guid businessId,\n            CancellationToken ct)\n        {\n            if (!IsAuthorizedFor(businessId))\n                return Forbid();\n\n            var dto = await _quota.GetSnapshotAsync(businessId, ct);\n            return Ok(dto);\n        }\n\n        // POST /api/entitlements/{businessId}/check\n        [HttpPost(\"{businessId:guid}/check\")]\n        public async Task<ActionResult<EntitlementResultDto>> Check(\n            Guid businessId,\n            [FromBody] EntitlementCheckDto? req,\n            CancellationToken ct)\n        {\n            if (!IsAuthorizedFor(businessId))\n                return Forbid();\n\n            if (req is null)\n                return BadRequest(\"Request body is required.\");\n\n            if (string.IsNullOrWhiteSpace(req.QuotaKey))\n                return BadRequest(\"QuotaKey required.\");\n\n            var amount = Math.Max(1, req.Amount);\n\n            var result = req.ConsumeOnSuccess\n                ? await _quota.CheckAndConsumeAsync(businessId, req.QuotaKey, amount, ct)\n                : await _quota.CheckAsync(businessId, req.QuotaKey, amount, ct);\n\n            if (!result.Allowed)\n                // 429 payload shape is already what your axios interceptor expects:\n                // { allowed:false, quotaKey, limit, remaining, message }\n                return StatusCode(429, result);\n\n            return Ok(result);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Controllers/PlanQuotasAdminController.cs",
      "sha256": "615f8f0b670d3e8aef239a57b9a5125959a2a63e18f417e08a8b52d2b99da7c3",
      "language": "csharp",
      "size": 5876,
      "content": "// üìÑ Features/Entitlements/Controllers/PlanQuotasAdminController.cs\n#nullable enable\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Entitlements.DTOs;\nusing xbytechat.api.Features.Entitlements.Models;\n\nnamespace xbytechat.api.Features.Entitlements.Controllers\n{\n    /// <summary>\n    /// Admin endpoints to manage default quotas per plan.\n    /// These are the rows in PlanQuotas table.\n    /// </summary>\n    [ApiController]\n    [Route(\"api/admin/plans/{planId:guid}/quotas\")]\n    [Authorize(Roles = \"superadmin,partneradmin,admin\")]\n    public sealed class PlanQuotasAdminController : ControllerBase\n    {\n        private readonly AppDbContext _db;\n\n        public PlanQuotasAdminController(AppDbContext db)\n        {\n            _db = db;\n        }\n\n        // GET /admin/plans/{planId}/quotas\n        [HttpGet]\n        public async Task<ActionResult<List<PlanQuotaDto>>> GetForPlan(\n            Guid planId,\n            CancellationToken ct)\n        {\n            // Validate plan exists (defensive)\n            var planExists = await _db.Plans\n                .AsNoTracking()\n                .AnyAsync(p => p.Id == planId, ct);\n\n            if (!planExists)\n                return NotFound(new { message = \"Plan not found\" });\n\n            var quotas = await _db.PlanQuotas\n                .AsNoTracking()\n                .Where(q => q.PlanId == planId)\n                .OrderBy(q => q.QuotaKey)\n                .Select(q => new PlanQuotaDto\n                {\n                    Id = q.Id,\n                    PlanId = q.PlanId,\n                    QuotaKey = q.QuotaKey,\n                    Limit = q.Limit,\n                    Period = q.Period,\n                    DenialMessage = q.DenialMessage\n                })\n                .ToListAsync(ct);\n\n            return Ok(quotas);\n        }\n\n        // PUT /admin/plans/{planId}/quotas\n        //\n        // Simple \"upsert by QuotaKey\" semantics:\n        // - Existing PlanQuota with same PlanId + QuotaKey is updated\n        // - New QuotaKey rows are inserted\n        // - Quotas not present in payload are kept (no destructive delete here)\n        [HttpPut]\n        public async Task<IActionResult> UpsertForPlan(\n            Guid planId,\n            [FromBody] List<PlanQuotaDto> payload,\n            CancellationToken ct)\n        {\n            if (payload is null)\n                return BadRequest(new { message = \"Payload is required\" });\n\n            // Normalize keys to upper-case for comparisons (used only in-memory)\n            static string Normalize(string key) =>\n                (key ?? string.Empty).Trim().ToUpperInvariant();\n\n            // Ensure plan exists\n            var planExists = await _db.Plans\n                .AsNoTracking()\n                .AnyAsync(p => p.Id == planId, ct);\n\n            if (!planExists)\n                return NotFound(new { message = \"Plan not found\" });\n\n            var incoming = payload\n                .Where(p => !string.IsNullOrWhiteSpace(p.QuotaKey))\n                .Select(p => new\n                {\n                    Raw = p,\n                    NormalizedKey = Normalize(p.QuotaKey!)\n                })\n                .ToList();\n\n            if (!incoming.Any())\n                return BadRequest(new { message = \"At least one quota with a QuotaKey is required.\" });\n\n            var keys = incoming\n                .Select(i => i.NormalizedKey)\n                .Distinct()\n                .ToList();\n\n            // ‚úÖ IMPORTANT: bring data into memory first, then call Normalize\n            var existingAllForPlan = await _db.PlanQuotas\n                .Where(q => q.PlanId == planId)\n                .ToListAsync(ct);\n\n            // optional: only keep rows whose normalized key is in payload keys\n            var existing = existingAllForPlan\n                .Where(q => keys.Contains(Normalize(q.QuotaKey)))\n                .ToList();\n            // üëâ NEW: delete quotas that are no longer present in the payload\n            var toDelete = existingAllForPlan\n                .Where(q => !keys.Contains(Normalize(q.QuotaKey)))\n                .ToList();\n\n            if (toDelete.Count > 0)\n            {\n                _db.PlanQuotas.RemoveRange(toDelete);\n            }\n\n            foreach (var item in incoming)\n            {\n                var dto = item.Raw;\n                var normalizedKey = item.NormalizedKey;\n\n                var entity = existing\n                    .FirstOrDefault(q => Normalize(q.QuotaKey) == normalizedKey);\n\n                if (entity is null)\n                {\n                    // Insert new row\n                    entity = new PlanQuota\n                    {\n                        Id = Guid.NewGuid(),\n                        PlanId = planId,\n                        QuotaKey = normalizedKey,\n                        Limit = dto.Limit,\n                        Period = dto.Period,\n                        DenialMessage = dto.DenialMessage,\n                        CreatedAt = DateTime.UtcNow,\n                        UpdatedAt = DateTime.UtcNow\n                    };\n\n                    _db.PlanQuotas.Add(entity);\n                    existing.Add(entity); // keep in local list too\n                }\n                else\n                {\n                    // Update existing row\n                    entity.QuotaKey = normalizedKey;\n                    entity.Limit = dto.Limit;\n                    entity.Period = dto.Period;\n                    entity.DenialMessage = dto.DenialMessage;\n                    entity.UpdatedAt = DateTime.UtcNow;\n                }\n            }\n\n            await _db.SaveChangesAsync(ct);\n            return NoContent();\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/DTOs/BusinessPermissionOverrideDto.cs",
      "sha256": "4d6d1c3548668dc2d58ec10bdf14d99a0040aa00f17e5b9c221c804ef481dd6e",
      "language": "csharp",
      "size": 561,
      "content": "using System;\n\nnamespace xbytechat.api.Features.Entitlements.DTOs\n{\n    public sealed class BusinessPermissionOverrideDto\n    {\n        public Guid Id { get; set; }\n        public Guid BusinessId { get; set; }\n        public string PermissionCode { get; set; } = \"\";\n        public bool IsGranted { get; set; }\n        public bool IsRevoked { get; set; }\n        public string? Reason { get; set; }\n        public DateTime? ExpiresAtUtc { get; set; }\n        public DateTime CreatedAtUtc { get; set; }\n        public DateTime UpdatedAtUtc { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/DTOs/EntitlementCheckDto.cs",
      "sha256": "e3c6863b705bec9193d677f8cf0d408345f812e955b06ffd375f8ef38d9fcb4f",
      "language": "csharp",
      "size": 1422,
      "content": "using System.Collections.Generic;\n\nnamespace xbytechat.api.Features.Entitlements.DTOs\n{\n    public sealed class EntitlementCheckDto\n    {\n        public string QuotaKey { get; set; } = default!;\n        public long Amount { get; set; } = 1;\n        public bool ConsumeOnSuccess { get; set; } = true;\n    }\n\n    public sealed class EntitlementResultDto\n    {\n        public bool Allowed { get; set; }\n        public string QuotaKey { get; set; } = default!;\n        public long? Limit { get; set; }           // null if unlimited\n        public long? Remaining { get; set; }       // null if unlimited\n        public string? Message { get; set; }\n    }\n\n    public sealed class EntitlementsSnapshotDto\n    {\n        public IEnumerable<string> GrantedPermissions { get; set; } = new List<string>();\n        public IEnumerable<QuotaSnapshotItemDto> Quotas { get; set; } = new List<QuotaSnapshotItemDto>();\n    }\n\n    public sealed class QuotaSnapshotItemDto\n    {\n        public string QuotaKey { get; set; } = default!;\n        public string Period { get; set; } = default!; // \"Daily\"/\"Monthly\"/\"Lifetime\"\n        public long? Limit { get; set; }               // null => unlimited\n        public long Consumed { get; set; }\n        public long? Remaining { get; set; }           // null => unlimited\n        public string? DenialMessage { get; set; }\n        public string WindowStartUtc { get; set; } = default!;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/DTOs/PlanQuotaDto.cs",
      "sha256": "eb3560e2218f3b7d2750e2a68fdf6a3f140f99a35665bf31e9d34671ad1611e3",
      "language": "csharp",
      "size": 738,
      "content": "// üìÑ Features/Entitlements/DTOs/PlanQuotaDto.cs\nusing System;\nusing xbytechat.api.Features.Entitlements.Models;\n\nnamespace xbytechat.api.Features.Entitlements.DTOs\n{\n    /// <summary>\n    /// Admin-facing DTO for default quotas configured per plan.\n    /// </summary>\n    public sealed class PlanQuotaDto\n    {\n        public Guid Id { get; set; }\n\n        public Guid PlanId { get; set; }\n\n        // Canonical key, e.g. \"MESSAGES_PER_MONTH\"\n        public string QuotaKey { get; set; } = string.Empty;\n\n        // -1 => unlimited\n        public long Limit { get; set; }\n\n        public QuotaPeriod Period { get; set; }\n\n        // Optional UX text used when quota is denied\n        public string? DenialMessage { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/DTOs/UpsertBusinessPermissionOverrideDto.cs",
      "sha256": "47e05889e89c82df2a1179abc49c58d3bbbdf5bc41a8ea8b211c4ff7fd41045e",
      "language": "csharp",
      "size": 410,
      "content": "using System;\n\nnamespace xbytechat.api.Features.Entitlements.DTOs\n{\n    public sealed class UpsertBusinessPermissionOverrideDto\n    {\n        public string PermissionCode { get; set; } = \"\";\n        public bool IsGranted { get; set; }           // true = grant, false = deny\n        public string? Reason { get; set; }\n        public DateTime? ExpiresAtUtc { get; set; }   // optional temporary unlock\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Models/BusinessPermissionOverride.cs",
      "sha256": "907872c4ee9b0aa63e85ed3d353d11cee3d8ee71af448f037371e95381d071d4",
      "language": "csharp",
      "size": 2004,
      "content": "using System;\nusing xbytechat.api.Features.AccessControl.Models;\nusing xbytechat.api.Features.BusinessModule.Models;\nusing xbytechat.api.Models.BusinessModel;\n\nnamespace xbytechat.api.Features.Entitlements.Models\n{\n    /// <summary>\n    /// Business-level permission override.\n    /// Used ONLY by internal admins (SuperAdmin/Partner/Reseller) to grant/deny permissions\n    /// beyond plan defaults (VIP, pilots, temporary unlocks).\n    ///\n    /// NOTE:\n    /// - This overrides PLAN-level availability for a business.\n    /// - It still should NOT bypass ROLE limitations when computing \"effective permissions\"\n    ///   for a staff user (we will enforce that in the entitlement calculation step).\n    /// </summary>\n    public sealed class BusinessPermissionOverride\n    {\n        public Guid Id { get; set; } = Guid.NewGuid();\n\n        public Guid BusinessId { get; set; }\n        public Business? Business { get; set; }\n\n        public Guid PermissionId { get; set; }\n        public Permission? Permission { get; set; }\n\n        /// <summary>\n        /// true = grant, false = deny.\n        /// </summary>\n        public bool IsGranted { get; set; }\n\n        /// <summary>\n        /// Soft revoke / disable the override.\n        /// </summary>\n        public bool IsRevoked { get; set; }\n\n        /// <summary>\n        /// Optional reason for auditability (VIP deal, pilot, migration, support).\n        /// </summary>\n        public string? Reason { get; set; }\n\n        /// <summary>\n        /// Optional expiry for temporary unlocks.\n        /// If set and expired, override should be ignored by entitlement computation.\n        /// </summary>\n        public DateTime? ExpiresAtUtc { get; set; }\n\n        /// <summary>\n        /// Who applied this override (admin user id).\n        /// </summary>\n        public Guid? CreatedByUserId { get; set; }\n\n        public DateTime CreatedAtUtc { get; set; } = DateTime.UtcNow;\n        public DateTime UpdatedAtUtc { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Models/BusinessQuotaOverride.cs",
      "sha256": "b1f87eedb2763fc2bb19f50e1a992e2d4adb2e86477ab1f04f0b3bd6f9a17fb6",
      "language": "csharp",
      "size": 848,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace xbytechat.api.Features.Entitlements.Models\n{\n    [Table(\"BusinessQuotaOverrides\")]\n    public sealed class BusinessQuotaOverride\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        [Required]\n        public Guid BusinessId { get; set; }\n\n        [Required, MaxLength(128)]\n        public string QuotaKey { get; set; } = default!; // same key as PlanQuota\n\n        public long? Limit { get; set; }     // null => fallback to plan\n        public bool? IsUnlimited { get; set; } // true => unlimited regardless of plan\n\n        public DateTime? ExpiresAt { get; set; } // null => permanent\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n        public DateTime? UpdatedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Models/BusinessUsageCounter.cs",
      "sha256": "85f37a61b7bf3227782bc452a7088746e129334cf37722d55a788faac363a1fc",
      "language": "csharp",
      "size": 928,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\nusing xbytechat.api.Features.Entitlements.Models;\n\nnamespace xbytechat.api.Features.Entitlements.Models\n{\n    [Table(\"BusinessUsageCounters\")]\n    public sealed class BusinessUsageCounter\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        [Required]\n        public Guid BusinessId { get; set; }\n\n        [Required, MaxLength(128)]\n        public string QuotaKey { get; set; } = default!;\n\n        public QuotaPeriod Period { get; set; }\n\n        // To support resets, store the window start for this counter.\n        public DateTime WindowStartUtc { get; set; }\n\n        // Current consumed units within the window.\n        public long Consumed { get; set; }\n\n        public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Models/PlanQuota.cs",
      "sha256": "215c4b1b07bd49b5499c1f3f1435739fd47ce44cc493aca1925d91e20c441573",
      "language": "csharp",
      "size": 989,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\nusing xbytechat.api.Features.Entitlements.Models;\n\nnamespace xbytechat.api.Features.Entitlements.Models\n{\n    [Table(\"PlanQuotas\")]\n    public sealed class PlanQuota\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        [Required]\n        public Guid PlanId { get; set; } // FK to AccessControl Plan\n\n        // Case-insensitive programmatic key, e.g., \"MessagesPerMonth\"\n        [Required, MaxLength(128)]\n        public string QuotaKey { get; set; } = default!;\n\n        public long Limit { get; set; }            // -1 => unlimited\n        public QuotaPeriod Period { get; set; }    // Daily/Monthly/Lifetime\n\n        // Optional UX copy shown to user on denial\n        [MaxLength(256)]\n        public string? DenialMessage { get; set; }\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n        public DateTime? UpdatedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Models/QuotaPeriod.cs",
      "sha256": "375d8f9e16fc912410137ae6208999b6580602bb4635bd5180e67f40ca8a1da7",
      "language": "csharp",
      "size": 189,
      "content": "namespace xbytechat.api.Features.Entitlements.Models\n{\n    public enum QuotaPeriod\n    {\n        Lifetime = 0,  // never resets automatically\n        Daily = 1,\n        Monthly = 2\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/QuotaKeys.cs",
      "sha256": "14149e987392ec3d22e757e52540d860518860a40a594846459035ec0428eec6",
      "language": "csharp",
      "size": 591,
      "content": "// üìÑ Features/Entitlements/QuotaKeys.cs\nnamespace xbytechat.api.Features.Entitlements\n{\n\n    public static class QuotaKeys\n    {\n        // How many messages a business can send in a given period (usually Monthly)\n        public const string MessagesPerMonth = \"MESSAGES_PER_MONTH\";\n\n        public const string MessagesPerDay = \"MESSAGES_PER_DAY\";\n        // How many campaigns can be sent per day\n        public const string CampaignsPerDay = \"CAMPAIGNS_PER_DAY\";\n\n        // How many templates can exist in total\n        public const string TemplatesTotal = \"TEMPLATES_TOTAL\";\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Seed/EntitlementsSeeder.cs",
      "sha256": "39a6c25c6d3cda63542eea996b67df2e21973a2afb10a93da008b33613f626d5",
      "language": "csharp",
      "size": 1273,
      "content": "using System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Entitlements.Models;\nusing Microsoft.EntityFrameworkCore;\n\nnamespace xbytechat.api.Features.Entitlements.Seed\n{\n    public static class EntitlementsSeeder\n    {\n        public static async Task SeedAsync(AppDbContext db, Guid planId)\n        {\n            var defaults = new[]\n            {\n                new PlanQuota { Id = Guid.NewGuid(), PlanId = planId, QuotaKey = \"MESSAGES_PER_MONTH\", Limit = 10000, Period = QuotaPeriod.Monthly, DenialMessage = \"Monthly message limit reached.\" },\n                new PlanQuota { Id = Guid.NewGuid(), PlanId = planId, QuotaKey = \"CAMPAIGNS_PER_DAY\",   Limit = 10,    Period = QuotaPeriod.Daily,   DenialMessage = \"Daily campaign limit reached.\" },\n                new PlanQuota { Id = Guid.NewGuid(), PlanId = planId, QuotaKey = \"TEMPLATES_TOTAL\",     Limit = -1,    Period = QuotaPeriod.Lifetime } // unlimited\n            };\n\n            foreach (var q in defaults)\n            {\n                var exists = await db.PlanQuotas.AnyAsync(p => p.PlanId == planId && p.QuotaKey.ToUpper() == q.QuotaKey.ToUpper());\n                if (!exists) db.PlanQuotas.Add(q);\n            }\n            await db.SaveChangesAsync();\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Services/BusinessPermissionOverrideService.cs",
      "sha256": "f1476ef9f4df036296db1c58cc8dd4c56abf0bd53d73d89d4539f24a4a506984",
      "language": "csharp",
      "size": 4988,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.Entitlements.DTOs;\nusing xbytechat.api.Features.Entitlements.Models;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.Entitlements.Services\n{\n    public sealed class BusinessPermissionOverrideService : IBusinessPermissionOverrideService\n    {\n        private readonly AppDbContext _db;\n        private readonly ILogger<BusinessPermissionOverrideService> _logger;\n\n        public BusinessPermissionOverrideService(AppDbContext db, ILogger<BusinessPermissionOverrideService> logger)\n        {\n            _db = db;\n            _logger = logger;\n        }\n\n        public async Task<List<BusinessPermissionOverrideDto>> GetAsync(Guid businessId)\n        {\n            var now = DateTime.UtcNow;\n\n            return await _db.BusinessPermissionOverrides\n                .AsNoTracking()\n                .Where(x => x.BusinessId == businessId && !x.IsRevoked)\n                .OrderByDescending(x => x.UpdatedAtUtc)\n                .Select(x => new BusinessPermissionOverrideDto\n                {\n                    Id = x.Id,\n                    BusinessId = x.BusinessId,\n                    PermissionCode = x.Permission!.Code,\n                    IsGranted = x.IsGranted,\n                    IsRevoked = x.IsRevoked,\n                    Reason = x.Reason,\n                    ExpiresAtUtc = x.ExpiresAtUtc,\n                    CreatedAtUtc = x.CreatedAtUtc,\n                    UpdatedAtUtc = x.UpdatedAtUtc\n                })\n                .ToListAsync();\n        }\n\n        public async Task<ResponseResult> UpsertAsync(Guid businessId, Guid actorUserId, UpsertBusinessPermissionOverrideDto dto)\n        {\n            var code = (dto.PermissionCode ?? \"\").Trim();\n            if (string.IsNullOrWhiteSpace(code))\n                return ResponseResult.ErrorInfo(\"‚ùå PermissionCode is required.\");\n\n            var perm = await _db.Permissions.FirstOrDefaultAsync(p => p.IsActive && p.Code == code.ToUpper());\n            if (perm == null)\n                return ResponseResult.ErrorInfo(\"‚ùå Invalid permission code.\");\n\n            var row = await _db.BusinessPermissionOverrides\n                .FirstOrDefaultAsync(x => x.BusinessId == businessId && x.PermissionId == perm.Id);\n\n            if (row == null)\n            {\n                row = new BusinessPermissionOverride\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    PermissionId = perm.Id,\n                    IsGranted = dto.IsGranted,\n                    IsRevoked = false,\n                    Reason = dto.Reason?.Trim(),\n                    ExpiresAtUtc = dto.ExpiresAtUtc,\n                    CreatedByUserId = actorUserId,\n                    CreatedAtUtc = DateTime.UtcNow,\n                    UpdatedAtUtc = DateTime.UtcNow\n                };\n                _db.BusinessPermissionOverrides.Add(row);\n            }\n            else\n            {\n                row.IsGranted = dto.IsGranted;\n                row.IsRevoked = false;\n                row.Reason = dto.Reason?.Trim();\n                row.ExpiresAtUtc = dto.ExpiresAtUtc;\n                row.UpdatedAtUtc = DateTime.UtcNow;\n            }\n\n            await _db.SaveChangesAsync();\n\n            _logger.LogInformation(\"‚úÖ Business permission override upserted. BusinessId={BusinessId}, Permission={Permission}, Granted={Granted}, ActorUserId={ActorUserId}\",\n                businessId, perm.Code, dto.IsGranted, actorUserId);\n\n            return ResponseResult.SuccessInfo(\"‚úÖ Override saved.\");\n        }\n\n        public async Task<ResponseResult> RevokeByPermissionCodeAsync(Guid businessId, Guid actorUserId, string permissionCode)\n        {\n            var code = (permissionCode ?? \"\").Trim();\n            if (string.IsNullOrWhiteSpace(code))\n                return ResponseResult.ErrorInfo(\"‚ùå PermissionCode is required.\");\n\n            var perm = await _db.Permissions.FirstOrDefaultAsync(p => p.IsActive && p.Code == code.ToUpper());\n            if (perm == null)\n                return ResponseResult.ErrorInfo(\"‚ùå Invalid permission code.\");\n\n            var row = await _db.BusinessPermissionOverrides\n                .FirstOrDefaultAsync(x => x.BusinessId == businessId && x.PermissionId == perm.Id && !x.IsRevoked);\n\n            if (row == null)\n                return ResponseResult.ErrorInfo(\"‚ùå Override not found.\");\n\n            row.IsRevoked = true;\n            row.UpdatedAtUtc = DateTime.UtcNow;\n\n            await _db.SaveChangesAsync();\n\n            _logger.LogInformation(\"‚úÖ Business permission override revoked. BusinessId={BusinessId}, Permission={Permission}, ActorUserId={ActorUserId}\",\n                businessId, perm.Code, actorUserId);\n\n            return ResponseResult.SuccessInfo(\"‚úÖ Override revoked.\");\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Services/IBusinessPermissionOverrideService.cs",
      "sha256": "39241c7ba297699b2f42ead4ecbf93f50ac5e3c1de7a5301519a5e43b9753641",
      "language": "csharp",
      "size": 594,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Entitlements.DTOs;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.Entitlements.Services\n{\n    public interface IBusinessPermissionOverrideService\n    {\n        Task<List<BusinessPermissionOverrideDto>> GetAsync(Guid businessId);\n        Task<ResponseResult> UpsertAsync(Guid businessId, Guid actorUserId, UpsertBusinessPermissionOverrideDto dto);\n        Task<ResponseResult> RevokeByPermissionCodeAsync(Guid businessId, Guid actorUserId, string permissionCode);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Services/IQuotaService.cs",
      "sha256": "55c9229cb163efbc7ef1621a7f2fa061a1299f8b85046402a2e3708327f41648",
      "language": "csharp",
      "size": 784,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Entitlements.DTOs;\n\nnamespace xbytechat.api.Features.Entitlements.Services\n{\n    public interface IQuotaService\n    {\n        Task<EntitlementResultDto> CheckAsync(Guid businessId, string quotaKey, long amount, CancellationToken ct);\n        Task<EntitlementResultDto> CheckAndConsumeAsync(Guid businessId, string quotaKey, long amount, CancellationToken ct);\n\n        Task<EntitlementsSnapshotDto> GetSnapshotAsync(Guid businessId, CancellationToken ct);\n\n        // Utility to ensure counters are on the correct window (creates or rolls window if needed)\n        Task EnsureWindowAsync(Guid businessId, string quotaKey, CancellationToken ct);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Services/QuotaService.cs",
      "sha256": "40ae3242c46c1445b58726fcc9f0e2c46511b0ca1a783eb400f57767329879aa",
      "language": "csharp",
      "size": 15037,
      "content": "using System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Entitlements.DTOs;\nusing xbytechat.api.Features.Entitlements.Models;\nusing xbytechat.api.Features.Entitlements.Services;\nusing xbytechat.api.Features.AccessControl.Models; // your Plan/PlanPermission namespace as applicable\n\nnamespace xbytechat.api.Features.Entitlements.Services\n{\n    public sealed class QuotaService : IQuotaService\n    {\n        private readonly AppDbContext _db;\n\n        public QuotaService(AppDbContext db)\n        {\n            _db = db;\n        }\n\n        // Normalize keys to uppercase to keep lookups stable on non-CI collations\n        private static string NK(string key) => key.Trim().ToUpperInvariant();\n\n        private static DateTime CurrentWindowStartUtc(QuotaPeriod p, DateTime nowUtc)\n        {\n            return p switch\n            {\n                QuotaPeriod.Daily => new DateTime(nowUtc.Year, nowUtc.Month, nowUtc.Day, 0, 0, 0, DateTimeKind.Utc),\n                QuotaPeriod.Monthly => new DateTime(nowUtc.Year, nowUtc.Month, 1, 0, 0, 0, DateTimeKind.Utc),\n                _ => DateTime.UnixEpoch\n            };\n        }\n\n        private async Task<(QuotaPeriod Period, long? Limit, string? Denial)> ResolveEffectiveLimitAsync(Guid businessId, string quotaKey, CancellationToken ct)\n        {\n            quotaKey = NK(quotaKey);\n\n            // resolve business planId\n            var business = await _db.Businesses\n                .AsNoTracking()\n                .Where(b => b.Id == businessId)\n                .Select(b => new { b.Id, b.PlanId })\n                .FirstOrDefaultAsync(ct);\n\n            if (business is null)\n                return (QuotaPeriod.Lifetime, 0, \"Business not found.\");\n\n            // override first\n            var ovr = await _db.BusinessQuotaOverrides\n                .AsNoTracking()\n                .Where(o => o.BusinessId == businessId && o.QuotaKey.ToUpper() == quotaKey)\n                .FirstOrDefaultAsync(ct);\n\n            if (ovr is not null && (ovr.ExpiresAt == null || ovr.ExpiresAt > DateTime.UtcNow))\n            {\n                if (ovr.IsUnlimited == true)\n                    return (QuotaPeriod.Lifetime, null, null); // unlimited\n\n                if (ovr.Limit.HasValue)\n                {\n                    // Need period: fall back to plan period (must exist)\n                    var pq = await _db.PlanQuotas.AsNoTracking()\n                        .Where(p => p.PlanId == business.PlanId && p.QuotaKey.ToUpper() == quotaKey)\n                        .Select(p => new { p.Period, p.DenialMessage })\n                        .FirstOrDefaultAsync(ct);\n\n                    if (pq is null)\n                        return (QuotaPeriod.Lifetime, ovr.Limit!.Value, null); // custom limit without period -> treat as lifetime\n\n                    return (pq.Period, ovr.Limit!.Value, pq.DenialMessage);\n                }\n                // if override exists but no limit/isUnlimited set, fall back to plan\n            }\n\n            // plan default\n            var planQuota = await _db.PlanQuotas.AsNoTracking()\n                .Where(p => p.PlanId == business.PlanId && p.QuotaKey.ToUpper() == quotaKey)\n                .FirstOrDefaultAsync(ct);\n\n            if (planQuota is null)\n                return (QuotaPeriod.Lifetime, 0, \"Quota not defined for plan.\"); // deny by default\n\n            if (planQuota.Limit < 0)\n                return (planQuota.Period, null, planQuota.DenialMessage); // unlimited\n\n            return (planQuota.Period, planQuota.Limit, planQuota.DenialMessage);\n        }\n\n        private async Task<BusinessUsageCounter> GetOrCreateCounterAsync(Guid businessId, string quotaKey, QuotaPeriod period, CancellationToken ct)\n        {\n            quotaKey = NK(quotaKey);\n            var now = DateTime.UtcNow;\n            var winStart = CurrentWindowStartUtc(period, now);\n\n            var counter = await _db.BusinessUsageCounters.FirstOrDefaultAsync(\n                c => c.BusinessId == businessId && c.QuotaKey.ToUpper() == quotaKey &&\n                     c.Period == period && c.WindowStartUtc == winStart, ct);\n\n            if (counter is not null) return counter;\n\n            counter = new BusinessUsageCounter\n            {\n                Id = Guid.NewGuid(),\n                BusinessId = businessId,\n                QuotaKey = quotaKey,\n                Period = period,\n                WindowStartUtc = winStart,\n                Consumed = 0,\n                CreatedAt = now,\n                UpdatedAt = now\n            };\n            _db.BusinessUsageCounters.Add(counter);\n\n            try\n            {\n                await _db.SaveChangesAsync(ct);\n                return counter;\n            }\n            catch (DbUpdateException)\n            {\n                // Another thread created it; fetch the existing row\n                return await _db.BusinessUsageCounters.FirstAsync(\n                    c => c.BusinessId == businessId && c.QuotaKey.ToUpper() == quotaKey &&\n                         c.Period == period && c.WindowStartUtc == winStart, ct);\n            }\n        }\n\n        public async Task EnsureWindowAsync(Guid businessId, string quotaKey, CancellationToken ct)\n        {\n            var (period, _, _) = await ResolveEffectiveLimitAsync(businessId, quotaKey, ct);\n            await GetOrCreateCounterAsync(businessId, quotaKey, period, ct);\n        }\n\n        public async Task<EntitlementResultDto> CheckAsync(Guid businessId, string quotaKey, long amount, CancellationToken ct)\n        {\n            quotaKey = NK(quotaKey);\n            var (period, limit, denial) = await ResolveEffectiveLimitAsync(businessId, quotaKey, ct);\n\n            if (limit is null) // unlimited\n            {\n                return new EntitlementResultDto\n                {\n                    Allowed = true,\n                    QuotaKey = quotaKey,\n                    Limit = null,\n                    Remaining = null\n                };\n            }\n\n            var counter = await GetOrCreateCounterAsync(businessId, quotaKey, period, ct);\n\n            var remaining = limit.Value - counter.Consumed;\n            var allowed = remaining >= amount;\n\n            return new EntitlementResultDto\n            {\n                Allowed = allowed,\n                QuotaKey = quotaKey,\n                Limit = limit.Value,\n                Remaining = Math.Max(0, remaining),\n                Message = allowed ? null : (denial ?? \"Quota limit reached.\")\n            };\n        }\n\n        public async Task<EntitlementResultDto> CheckAndConsumeAsync(Guid businessId, string quotaKey, long amount, CancellationToken ct)\n        {\n            quotaKey = NK(quotaKey);\n            var (period, limit, denial) = await ResolveEffectiveLimitAsync(businessId, quotaKey, ct);\n\n            if (limit is null) // unlimited\n            {\n                // No increment needed; still return success\n                return new EntitlementResultDto { Allowed = true, QuotaKey = quotaKey, Limit = null, Remaining = null };\n            }\n\n            var now = DateTime.UtcNow;\n            var winStart = CurrentWindowStartUtc(period, now);\n\n            // Atomic consume in a single SQL statement\n            // UPDATE ... SET Consumed = Consumed + @amount WHERE ... AND Consumed + @amount <= @limit\n            var updated = await _db.BusinessUsageCounters\n                .Where(c =>\n                    c.BusinessId == businessId &&\n                    c.QuotaKey.ToUpper() == quotaKey &&\n                    c.Period == period &&\n                    c.WindowStartUtc == winStart &&\n                    c.Consumed + amount <= limit.Value)\n                .ExecuteUpdateAsync(up =>\n                    up.SetProperty(c => c.Consumed, c => c.Consumed + amount)\n                      .SetProperty(c => c.UpdatedAt, _ => now), ct);\n\n            if (updated == 0)\n            {\n                // Ensure the row exists; if missing, create and retry once\n                var existed = await _db.BusinessUsageCounters.AnyAsync(c =>\n                    c.BusinessId == businessId &&\n                    c.QuotaKey.ToUpper() == quotaKey &&\n                    c.Period == period &&\n                    c.WindowStartUtc == winStart, ct);\n\n                if (!existed)\n                {\n                    var counter = new BusinessUsageCounter\n                    {\n                        Id = Guid.NewGuid(),\n                        BusinessId = businessId,\n                        QuotaKey = quotaKey,\n                        Period = period,\n                        WindowStartUtc = winStart,\n                        Consumed = 0,\n                        CreatedAt = now,\n                        UpdatedAt = now\n                    };\n                    _db.BusinessUsageCounters.Add(counter);\n                    await _db.SaveChangesAsync(ct);\n\n                    // retry atomic consume\n                    updated = await _db.BusinessUsageCounters\n                        .Where(c =>\n                            c.BusinessId == businessId &&\n                            c.QuotaKey.ToUpper() == quotaKey &&\n                            c.Period == period &&\n                            c.WindowStartUtc == winStart &&\n                            c.Consumed + amount <= limit.Value)\n                        .ExecuteUpdateAsync(up =>\n                            up.SetProperty(c => c.Consumed, c => c.Consumed + amount)\n                              .SetProperty(c => c.UpdatedAt, _ => now), ct);\n                }\n            }\n\n            if (updated == 0)\n            {\n                // Denied\n                var current = await _db.BusinessUsageCounters.AsNoTracking()\n                    .Where(c =>\n                        c.BusinessId == businessId &&\n                        c.QuotaKey.ToUpper() == quotaKey &&\n                        c.Period == period &&\n                        c.WindowStartUtc == winStart)\n                    .Select(c => c.Consumed)\n                    .FirstOrDefaultAsync(ct);\n\n                var remaining = Math.Max(0, limit.Value - current);\n\n                return new EntitlementResultDto\n                {\n                    Allowed = false,\n                    QuotaKey = quotaKey,\n                    Limit = limit.Value,\n                    Remaining = remaining,\n                    Message = denial ?? \"Quota limit reached.\"\n                };\n            }\n\n            // Success path‚Äîfetch updated consumed to compute remaining\n            var consumed = await _db.BusinessUsageCounters.AsNoTracking()\n                .Where(c =>\n                    c.BusinessId == businessId &&\n                    c.QuotaKey.ToUpper() == quotaKey &&\n                    c.Period == period &&\n                    c.WindowStartUtc == winStart)\n                .Select(c => c.Consumed)\n                .FirstAsync(ct);\n\n            return new EntitlementResultDto\n            {\n                Allowed = true,\n                QuotaKey = quotaKey,\n                Limit = limit.Value,\n                Remaining = Math.Max(0, limit.Value - consumed)\n            };\n        }\n\n        public async Task<EntitlementsSnapshotDto> GetSnapshotAsync(Guid businessId, CancellationToken ct)\n        {\n            // Resolve plan once\n            var planId = await _db.Businesses.AsNoTracking()\n                .Where(b => b.Id == businessId)\n                .Select(b => b.PlanId)\n                .FirstAsync(ct);\n\n            var now = DateTime.UtcNow;\n\n            // ‚úÖ Permission codes for this plan (base)\n            var planPerms = await _db.PlanPermissions\n                .AsNoTracking()\n                .Where(pp => pp.PlanId == planId && pp.IsActive && pp.Permission.IsActive)\n                .Select(pp => pp.Permission.Code)\n                .ToListAsync(ct);\n\n            // ‚úÖ Make it mutable + deduped\n            var grantedSet = new HashSet<string>(planPerms, StringComparer.OrdinalIgnoreCase);\n\n            // ‚úÖ Apply BUSINESS permission overrides (grant adds, deny removes)\n            // Keeps /entitlements snapshot aligned with JWT minting logic in AuthService\n            var permOverrides = await _db.BusinessPermissionOverrides\n                .AsNoTracking()\n                .Where(o =>\n                    o.BusinessId == businessId &&\n                    !o.IsRevoked &&\n                    (o.ExpiresAtUtc == null || o.ExpiresAtUtc > now) &&\n                    o.Permission.IsActive)\n                .Select(o => new\n                {\n                    Code = o.Permission.Code,\n                    o.IsGranted\n                })\n                .ToListAsync(ct);\n\n            foreach (var o in permOverrides)\n            {\n                if (string.IsNullOrWhiteSpace(o.Code)) continue;\n\n                if (o.IsGranted)\n                    grantedSet.Add(o.Code);\n                else\n                    grantedSet.Remove(o.Code);\n            }\n\n            // Quotas ‚Äì sequential to avoid DbContext concurrency issues\n            var planQuotas = await _db.PlanQuotas.AsNoTracking()\n                .Where(pq => pq.PlanId == planId)\n                .ToListAsync(ct);\n\n            var overrides = await _db.BusinessQuotaOverrides.AsNoTracking()\n                .Where(o => o.BusinessId == businessId &&\n                            (o.ExpiresAt == null || o.ExpiresAt > now))\n                .ToListAsync(ct);\n\n            var items = new List<QuotaSnapshotItemDto>();\n\n            foreach (var pq in planQuotas)\n            {\n                var key = NK(pq.QuotaKey);\n\n                long? limit = overrides.FirstOrDefault(o => NK(o.QuotaKey) == key) is { } o\n                    ? (o.IsUnlimited == true ? null : o.Limit ?? (pq.Limit < 0 ? (long?)null : pq.Limit))\n                    : (pq.Limit < 0 ? (long?)null : pq.Limit);\n\n                var winStart = CurrentWindowStartUtc(pq.Period, now);\n\n                var consumed = await _db.BusinessUsageCounters.AsNoTracking()\n                    .Where(c => c.BusinessId == businessId &&\n                                c.QuotaKey.ToUpper() == key &&\n                                c.Period == pq.Period &&\n                                c.WindowStartUtc == winStart)\n                    .Select(c => c.Consumed)\n                    .FirstOrDefaultAsync(ct);\n\n                items.Add(new QuotaSnapshotItemDto\n                {\n                    QuotaKey = key,\n                    Period = pq.Period.ToString(),\n                    Limit = limit,\n                    Consumed = consumed,\n                    Remaining = limit is null ? null : Math.Max(0, limit.Value - consumed),\n                    DenialMessage = pq.DenialMessage,\n                    WindowStartUtc = winStart.ToString(\"u\")\n                });\n            }\n\n            return new EntitlementsSnapshotDto\n            {\n                GrantedPermissions = grantedSet.OrderBy(x => x).ToList(),\n                Quotas = items\n            };\n        }\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Abstractions/IEsuStatusService.cs",
      "sha256": "825a494d506b60064b1f3811f94cece207f3feb402079cf5371171bb0752d168",
      "language": "csharp",
      "size": 420,
      "content": "#nullable enable\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.ESU.Facebook.DTOs;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Abstractions\n{\n    public interface IEsuStatusService\n    {\n        Task<EsuStatusDto> GetStatusAsync(Guid businessId, CancellationToken ct = default);\n        Task DeauthorizeAsync(Guid businessId, CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Abstractions/IEsuTokenStore.cs",
      "sha256": "19575329bfc016c7842b626d8c6403ee75cb77797bf8caad98b983aa2eed6af2",
      "language": "csharp",
      "size": 517,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.ESU.Facebook.Models;\n\npublic interface IEsuTokenStore\n{\n    Task<EsuToken?> GetAsync(Guid businessId, string provider, CancellationToken ct);\n    Task UpsertAsync(Guid businessId, string provider, string token, DateTime? expiresAtUtc, CancellationToken ct);\n    Task RevokeAsync(Guid businessId, string provider, CancellationToken ct);\n\n    Task DeleteAsync(Guid biz, string provider, CancellationToken ct = default);\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Abstractions/IFacebookGraphClient.cs",
      "sha256": "448400005f2e87088712cdae60bb312c7a1474b18d8702fb89188c8bbf6cee4a",
      "language": "csharp",
      "size": 421,
      "content": "#nullable enable\nusing System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Abstractions\n{\n    public interface IFacebookGraphClient\n    {\n        Task<T> GetAsync<T>(\n            Guid businessId,\n            string path,\n            IDictionary<string, string?>? query = null,\n            CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Abstractions/IFacebookOauthClient.cs",
      "sha256": "aa56a723ee19e25ace745f273354e63ff103c42ebeb81e8d32fd05ad55db8301",
      "language": "csharp",
      "size": 737,
      "content": "#nullable enable\nusing System.Threading;\nusing System.Threading.Tasks;\nusing FbContracts = xbytechat.api.Features.ESU.Facebook.Contracts;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Abstractions\n{\n    /// <summary>Handles the OAuth \"code ‚Üí access_token\" exchanges with Facebook Graph API.</summary>\n    public interface IFacebookOauthClient\n    {\n        Task<FbContracts.FacebookTokenResponse> ExchangeCodeAsync(string code, CancellationToken ct = default);\n\n        /// <summary>Swap short-lived token for a ~60-day long-lived token.</summary>\n        Task<FbContracts.FacebookTokenResponse> ExchangeForLongLivedAsync(\n            FbContracts.FacebookTokenResponse shortToken,\n            CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Abstractions/IFacebookTokenService.cs",
      "sha256": "1f2bd9d86694df46bd6f415d4246e249ebca0ad878762d4ec30a27f251e4d270",
      "language": "csharp",
      "size": 1029,
      "content": "#nullable enable\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.ESU.Facebook.Contracts;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Abstractions\n{\n    /// <summary>Retrieves a Facebook access token for a business with expiry checks and caching.</summary>\n    public interface IFacebookTokenService\n    {\n        /// <summary>\n        /// Returns a stored token if it exists and is not near expiry. Returns null if missing/expired.\n        /// </summary>\n        Task<FacebookStoredToken?> TryGetValidAsync(Guid businessId, CancellationToken ct = default);\n\n        /// <summary>\n        /// Throws if missing/expired. Use when a valid token is required for an operation.\n        /// </summary>\n        Task<FacebookStoredToken> GetRequiredAsync(Guid businessId, CancellationToken ct = default);\n\n        Task<string?> GetAccessTokenAsync(Guid businessId, CancellationToken ct = default);\n        Task InvalidateAsync(Guid businessId, CancellationToken ct = default);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Clients/FacebookGraphClient.cs",
      "sha256": "c96cd6ce910b95deff6df835e53329da4603f69b2230d7e5f149a92aa2451ca9",
      "language": "csharp",
      "size": 3678,
      "content": "#nullable enable\nusing System;\nusing System.Collections.Generic;\nusing System.Net.Http;\nusing System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.WebUtilities;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing xbytechat.api.Features.ESU.Facebook.Abstractions;\nusing xbytechat.api.Features.ESU.Facebook.Contracts;\nusing xbytechat.api.Features.ESU.Facebook.Options;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Clients\n{\n    internal sealed class FacebookGraphClient : IFacebookGraphClient\n    {\n        private static readonly JsonSerializerOptions JsonOpts = new(JsonSerializerDefaults.Web)\n        { PropertyNameCaseInsensitive = true, WriteIndented = false };\n\n        private readonly HttpClient _http;\n        private readonly ILogger<FacebookGraphClient> _log;\n        private readonly FacebookOauthOptions _opt;\n        private readonly IFacebookTokenService _tokens;\n\n        public FacebookGraphClient(\n            HttpClient http,\n            IOptions<FacebookOauthOptions> opt,\n            IFacebookTokenService tokens,\n            ILogger<FacebookGraphClient> log)\n        {\n            _http = http;\n            _opt = opt.Value;\n            _tokens = tokens;\n            _log = log;\n        }\n\n        public async Task<T> GetAsync<T>(\n            Guid businessId,\n            string path,\n            IDictionary<string, string?>? query = null,\n            CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty) throw new ArgumentException(\"businessId is required\", nameof(businessId));\n            if (string.IsNullOrWhiteSpace(path)) throw new ArgumentException(\"path is required\", nameof(path));\n\n            // 1) Get (valid) token\n            var token = await _tokens.GetRequiredAsync(businessId, ct).ConfigureAwait(false);\n\n            // 2) Build URL\n            var baseUrl = _opt.GraphBaseUrl.TrimEnd('/');\n            var ver = _opt.GraphApiVersion.Trim('/');\n            var url = $\"{baseUrl}/{ver}/{path.TrimStart('/')}\";\n\n            var finalUrl = query is null ? url : QueryHelpers.AddQueryString(url, query);\n\n            using var req = new HttpRequestMessage(HttpMethod.Get, finalUrl);\n            req.Headers.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue(\"Bearer\", token.AccessToken);\n\n            using var res = await _http.SendAsync(req, HttpCompletionOption.ResponseHeadersRead, ct).ConfigureAwait(false);\n            var raw = await res.Content.ReadAsStringAsync(ct).ConfigureAwait(false);\n\n            if (!res.IsSuccessStatusCode)\n            {\n                FacebookErrorResponse? err = null;\n                try { err = JsonSerializer.Deserialize<FacebookErrorResponse>(raw, JsonOpts); } catch { /* ignore */ }\n\n                var msg = err?.Error?.Message ?? $\"Graph GET {path} failed with HTTP {(int)res.StatusCode}\";\n                _log.LogWarning(\"Graph error: {Msg}. Raw: {Raw}\", msg, Truncate(raw, 1000));\n\n                throw new FacebookGraphException(\n                    msg, err?.Error?.Type, err?.Error?.Code, err?.Error?.SubCode, err?.Error?.TraceId);\n            }\n\n            try\n            {\n                return JsonSerializer.Deserialize<T>(raw, JsonOpts)\n                       ?? throw new InvalidOperationException(\"Graph response was empty.\");\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"Failed to parse Graph response for {Path}. Raw: {Raw}\", path, Truncate(raw, 1200));\n                throw;\n            }\n        }\n\n        private static string Truncate(string s, int max) => s.Length <= max ? s : s[..max];\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Clients/FacebookOauthClient.cs",
      "sha256": "d1b8fc306fc457f35cb0045bda912fd55b330abf64ba8de608dd26551ac3292a",
      "language": "csharp",
      "size": 7536,
      "content": "#nullable enable\nusing System;\nusing System.Net.Http;\nusing System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing FbContracts = xbytechat.api.Features.ESU.Facebook.Contracts;\nusing xbytechat.api.Features.ESU.Facebook.Abstractions;\nusing xbytechat.api.Features.ESU.Facebook.Options;\nusing xbytechat.api.Features.ESU.Facebook.Contracts;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Clients\n{\n    internal sealed class FacebookOauthClient : IFacebookOauthClient\n    {\n        private static readonly JsonSerializerOptions JsonOpts = new(JsonSerializerDefaults.Web)\n        { PropertyNameCaseInsensitive = true, WriteIndented = false };\n\n        private readonly HttpClient _http;\n        private readonly ILogger<FacebookOauthClient> _log;\n        private readonly FacebookOauthOptions _opt;\n\n        public FacebookOauthClient(HttpClient http, IOptions<FacebookOauthOptions> opt, ILogger<FacebookOauthClient> log)\n        {\n            _http = http ?? throw new ArgumentNullException(nameof(http));\n            _log = log ?? throw new ArgumentNullException(nameof(log));\n            _opt = opt?.Value ?? throw new ArgumentNullException(nameof(opt));\n        }\n\n        public async Task<FbContracts.FacebookTokenResponse> ExchangeCodeAsync(string code, CancellationToken ct = default)\n        {\n            if (string.IsNullOrWhiteSpace(code))\n                throw new ArgumentException(\"Authorization code must be provided.\", nameof(code));\n\n            var baseUri = _opt.GraphBaseUrl.TrimEnd('/');\n            var version = _opt.GraphApiVersion.Trim('/');\n            var path = $\"{baseUri}/{version}/oauth/access_token\";\n\n            var uri = new UriBuilder(path)\n            {\n                Query =\n                    $\"client_id={Uri.EscapeDataString(_opt.AppId)}\" +\n                    $\"&redirect_uri={Uri.EscapeDataString(_opt.RedirectUri)}\" +\n                    $\"&client_secret={Uri.EscapeDataString(_opt.AppSecret)}\" +\n                    $\"&code={Uri.EscapeDataString(code)}\"\n            }.Uri;\n\n            _log.LogInformation(\"Exchanging Facebook OAuth code for token via {Uri}\", uri.GetLeftPart(UriPartial.Path));\n\n            using var req = new HttpRequestMessage(HttpMethod.Get, uri);\n            using var res = await _http.SendAsync(req, HttpCompletionOption.ResponseHeadersRead, ct).ConfigureAwait(false);\n            var raw = await res.Content.ReadAsStringAsync(ct).ConfigureAwait(false);\n\n            if (!res.IsSuccessStatusCode)\n            {\n                FbContracts.FacebookErrorResponse? fbErr = null;\n                try { fbErr = JsonSerializer.Deserialize<FbContracts.FacebookErrorResponse>(raw, JsonOpts); } catch { }\n\n                var message = fbErr?.Error?.Message ?? $\"Facebook token exchange failed with HTTP {(int)res.StatusCode}\";\n                _log.LogWarning(\"Facebook OAuth error: {Message}. Raw: {Raw}\", message, Truncate(raw, 1000));\n                throw new InvalidOperationException(\n                    $\"Facebook OAuth error: {message} (type={fbErr?.Error?.Type}, code={fbErr?.Error?.Code}, subcode={fbErr?.Error?.SubCode})\");\n            }\n\n            FbContracts.FacebookTokenResponse? token;\n            try { token = JsonSerializer.Deserialize<FbContracts.FacebookTokenResponse>(raw, JsonOpts); }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"Failed to parse Facebook token response. Raw: {Raw}\", Truncate(raw, 1000));\n                throw;\n            }\n\n            if (token is null || string.IsNullOrWhiteSpace(token.AccessToken))\n            {\n                _log.LogError(\"Facebook token response missing access_token. Raw: {Raw}\", Truncate(raw, 1000));\n                throw new InvalidOperationException(\"Facebook token response missing access_token.\");\n            }\n\n            // attach raw JSON for auditing\n            token = new FbContracts.FacebookTokenResponse\n            {\n                AccessToken = token.AccessToken,\n                TokenType = token.TokenType,\n                ExpiresInSeconds = token.ExpiresInSeconds,\n                RawJson = raw\n            };\n\n            _log.LogInformation(\"Facebook OAuth token exchange succeeded. ExpiresIn(s)={Expires}\", token.ExpiresInSeconds);\n            return token;\n        }\n        public async Task<FbContracts.FacebookTokenResponse> ExchangeForLongLivedAsync(\n      FbContracts.FacebookTokenResponse shortToken,\n      CancellationToken ct = default)\n        {\n            if (shortToken is null || string.IsNullOrWhiteSpace(shortToken.AccessToken))\n                throw new ArgumentException(\"Short-lived token is required.\", nameof(shortToken));\n\n            var baseUri = _opt.GraphBaseUrl.TrimEnd('/');\n            var version = _opt.GraphApiVersion.Trim('/'); // e.g., v20.0\n            var path = $\"{baseUri}/{version}/oauth/access_token\";\n\n            var uri = new UriBuilder(path)\n            {\n                Query =\n                    \"grant_type=fb_exchange_token\" +\n                    $\"&client_id={Uri.EscapeDataString(_opt.AppId)}\" +\n                    $\"&client_secret={Uri.EscapeDataString(_opt.AppSecret)}\" +\n                    $\"&fb_exchange_token={Uri.EscapeDataString(shortToken.AccessToken)}\"\n            }.Uri;\n\n            _log.LogInformation(\"Exchanging short-lived token for long-lived via {Uri}\", uri.GetLeftPart(UriPartial.Path));\n\n            using var req = new HttpRequestMessage(HttpMethod.Get, uri);\n            using var res = await _http.SendAsync(req, HttpCompletionOption.ResponseHeadersRead, ct).ConfigureAwait(false);\n            var raw = await res.Content.ReadAsStringAsync(ct).ConfigureAwait(false);\n\n            if (!res.IsSuccessStatusCode)\n            {\n                FbContracts.FacebookErrorResponse? fbErr = null;\n                try { fbErr = JsonSerializer.Deserialize<FbContracts.FacebookErrorResponse>(raw, JsonOpts); } catch { }\n\n                var message = fbErr?.Error?.Message ?? $\"Facebook long-lived exchange failed with HTTP {(int)res.StatusCode}\";\n                _log.LogWarning(\"Facebook OAuth long-lived error: {Message}. Raw: {Raw}\", message, Truncate(raw, 1000));\n                throw new InvalidOperationException(\n                    $\"Facebook OAuth error: {message} (type={fbErr?.Error?.Type}, code={fbErr?.Error?.Code}, subcode={fbErr?.Error?.SubCode})\");\n            }\n\n            FbContracts.FacebookTokenResponse? token;\n            try { token = JsonSerializer.Deserialize<FbContracts.FacebookTokenResponse>(raw, JsonOpts); }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"Failed to parse long-lived token response. Raw: {Raw}\", Truncate(raw, 1000));\n                throw;\n            }\n\n            if (token is null || string.IsNullOrWhiteSpace(token.AccessToken))\n            {\n                _log.LogError(\"Long-lived token response missing access_token. Raw: {Raw}\", Truncate(raw, 1000));\n                throw new InvalidOperationException(\"Invalid long-lived token response.\");\n            }\n\n            return new FbContracts.FacebookTokenResponse\n            {\n                AccessToken = token.AccessToken,\n                TokenType = token.TokenType,\n                ExpiresInSeconds = token.ExpiresInSeconds, // usually ~5,184,000 (60 days)\n                RawJson = raw\n            };\n        }\n\n\n        private static string Truncate(string input, int max) => input.Length <= max ? input : input[..max];\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Clients/IWabaSubscriptionClient.cs",
      "sha256": "80dc2ee9eec97b6012e5c11639cfe6a22593a514dd264a04a8b654a7fc18ddef",
      "language": "csharp",
      "size": 364,
      "content": "using System.Threading;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Clients\n{\n    public interface IWabaSubscriptionClient\n    {\n        Task SubscribeAsync(string wabaId, string accessToken, CancellationToken ct = default);\n        Task UnsubscribeAsync(string wabaId, string accessToken, CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Clients/WabaSubscriptionClient.cs",
      "sha256": "82b27b0686eb6c219a05a6be7c40c9ea493dd0a76bf2b9427a2ca5fc3dd0eabb",
      "language": "csharp",
      "size": 3613,
      "content": "using System;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing xbytechat.api.Features.ESU.Facebook.Options;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Clients\n{\n    internal sealed class WabaSubscriptionClient : IWabaSubscriptionClient\n    {\n        private readonly IHttpClientFactory _httpFactory;\n        private readonly FacebookOptions _fb;\n        private readonly ILogger<WabaSubscriptionClient> _log;\n\n        public WabaSubscriptionClient(\n            IHttpClientFactory httpFactory,\n            IOptions<FacebookOptions> fb,\n            ILogger<WabaSubscriptionClient> log)\n        {\n            _httpFactory = httpFactory;\n            _fb = fb.Value;\n            _log = log;\n        }\n\n        public async Task SubscribeAsync(string wabaId, string accessToken, CancellationToken ct = default)\n        {\n            if (string.IsNullOrWhiteSpace(wabaId)) throw new ArgumentException(\"wabaId is required\", nameof(wabaId));\n            if (string.IsNullOrWhiteSpace(accessToken)) throw new ArgumentException(\"accessToken is required\", nameof(accessToken));\n\n            var baseUrl = string.IsNullOrWhiteSpace(_fb.GraphBaseUrl) ? \"https://graph.facebook.com\" : _fb.GraphBaseUrl!;\n            var version = string.IsNullOrWhiteSpace(_fb.GraphApiVersion) ? \"v22.0\" : _fb.GraphApiVersion!;\n            var url = $\"{baseUrl.TrimEnd('/')}/{version}/{wabaId}/subscribed_apps\";\n\n            using var req = new HttpRequestMessage(HttpMethod.Post, url);\n            req.Headers.Authorization = new AuthenticationHeaderValue(\"Bearer\", accessToken);\n\n            var http = _httpFactory.CreateClient();\n            var res = await http.SendAsync(req, ct);\n\n            var body = await res.Content.ReadAsStringAsync(ct);\n            if (!res.IsSuccessStatusCode)\n            {\n                _log.LogWarning(\"‚ö†Ô∏è WABA subscribe failed. wabaId={WabaId}, status={Status}, body={Body}\", wabaId, (int)res.StatusCode, body);\n                res.EnsureSuccessStatusCode();\n            }\n\n            _log.LogInformation(\"‚úÖ WABA subscribed. wabaId={WabaId}\", wabaId);\n        }\n\n        public async Task UnsubscribeAsync(string wabaId, string accessToken, CancellationToken ct = default)\n        {\n            if (string.IsNullOrWhiteSpace(wabaId)) throw new ArgumentException(\"wabaId is required\", nameof(wabaId));\n            if (string.IsNullOrWhiteSpace(accessToken)) throw new ArgumentException(\"accessToken is required\", nameof(accessToken));\n\n            var baseUrl = string.IsNullOrWhiteSpace(_fb.GraphBaseUrl) ? \"https://graph.facebook.com\" : _fb.GraphBaseUrl!;\n            var version = string.IsNullOrWhiteSpace(_fb.GraphApiVersion) ? \"v22.0\" : _fb.GraphApiVersion!;\n            var url = $\"{baseUrl.TrimEnd('/')}/{version}/{wabaId}/subscribed_apps\";\n\n            using var req = new HttpRequestMessage(HttpMethod.Delete, url);\n            req.Headers.Authorization = new AuthenticationHeaderValue(\"Bearer\", accessToken);\n\n            var http = _httpFactory.CreateClient();\n            var res = await http.SendAsync(req, ct);\n\n            var body = await res.Content.ReadAsStringAsync(ct);\n            if (!res.IsSuccessStatusCode)\n            {\n                _log.LogWarning(\"‚ö†Ô∏è WABA unsubscribe failed. wabaId={WabaId}, status={Status}, body={Body}\", wabaId, (int)res.StatusCode, body);\n                res.EnsureSuccessStatusCode();\n            }\n\n            _log.LogInformation(\"‚úÖ WABA unsubscribed. wabaId={WabaId}\", wabaId);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Contracts/FacebookErrorResponse.cs",
      "sha256": "f926a14540f2cfeb9204abd7da5046f80824812f167638f1a935bd3c1fa249bd",
      "language": "csharp",
      "size": 715,
      "content": "#nullable enable\nusing System.Text.Json.Serialization;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Contracts\n{\n    public sealed class FacebookErrorResponse\n    {\n        [JsonPropertyName(\"error\")]\n        public FacebookError? Error { get; init; }\n\n        public sealed class FacebookError\n        {\n            [JsonPropertyName(\"message\")] public string? Message { get; init; }\n            [JsonPropertyName(\"type\")] public string? Type { get; init; }\n            [JsonPropertyName(\"code\")] public int? Code { get; init; }\n            [JsonPropertyName(\"error_subcode\")] public int? SubCode { get; init; }\n            [JsonPropertyName(\"fbtrace_id\")] public string? TraceId { get; init; }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Contracts/FacebookGraphException.cs",
      "sha256": "7f619349143ee1664ce94386c6fba760d79178fc8375d46b6c42b53c1642f95d",
      "language": "csharp",
      "size": 582,
      "content": "#nullable enable\nusing System;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Contracts\n{\n    public sealed class FacebookGraphException : Exception\n    {\n        public string? Type { get; }\n        public int? Code { get; }\n        public int? SubCode { get; }\n        public string? TraceId { get; }\n\n        public FacebookGraphException(string message, string? type, int? code, int? subCode, string? traceId)\n            : base(message)\n        {\n            Type = type;\n            Code = code;\n            SubCode = subCode;\n            TraceId = traceId;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Contracts/FacebookStoredToken.cs",
      "sha256": "031120808108409a860a5faca499217c7d28d4547972f394e95403f36e6f41d6",
      "language": "csharp",
      "size": 906,
      "content": "#nullable enable\nusing System;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Contracts\n{\n    public sealed class FacebookStoredToken\n    {\n        public string AccessToken { get; init; } = string.Empty;\n        public DateTime? ExpiresAtUtc { get; init; }      // null = unknown\n        public string? RawJson { get; init; }             // audit/debug snapshot\n\n        /// <summary>Consider token invalid if it expires within this window (default 5 minutes).</summary>\n        public bool WillExpireSoon(TimeSpan? skew = null)\n        {\n            if (ExpiresAtUtc is null) return false; // unknown -> assume fine, caller may decide stricter behavior\n            var s = skew ?? TimeSpan.FromMinutes(5);\n            return DateTime.UtcNow.Add(s) >= ExpiresAtUtc.Value;\n        }\n\n        public bool IsExpired()\n            => ExpiresAtUtc is not null && DateTime.UtcNow >= ExpiresAtUtc.Value;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Contracts/FacebookTokenResponse.cs",
      "sha256": "59dd8f7c04fcffa382ee1f0c0b0e9f8cbef52cb1c8b8331d41e7026504e78c02",
      "language": "csharp",
      "size": 634,
      "content": "#nullable enable\nusing System.Text.Json.Serialization;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Contracts\n{\n    public sealed class FacebookTokenResponse\n    {\n        [JsonPropertyName(\"access_token\")]\n        public string AccessToken { get; init; } = string.Empty;\n\n        [JsonPropertyName(\"token_type\")]\n        public string TokenType { get; init; } = \"bearer\";\n\n        [JsonPropertyName(\"expires_in\")]\n        public int ExpiresInSeconds { get; init; }\n\n        /// <summary>Raw JSON payload as returned by Facebook for auditing/debugging.</summary>\n        public string RawJson { get; init; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Controllers/FacebookEsuController.cs",
      "sha256": "8cc228b58a542b7f9b01307e5e5d192386eda26da5cb3349d13202816829f216",
      "language": "csharp",
      "size": 11309,
      "content": "#nullable enable\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.AspNetCore.RateLimiting;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.ESU.Facebook.Abstractions;\nusing xbytechat.api.Features.ESU.Facebook.DTOs;\nusing xbytechat.api.Features.ESU.Facebook.Services;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Controllers\n{\n    [ApiController]\n    [Route(\"api/esu/facebook\")]\n    [Authorize] // all endpoints below require authenticated workspace\n    public sealed class FacebookEsuController : ControllerBase\n    {\n        private readonly IFacebookEsuService _service;\n        private readonly IEsuStatusService _status;\n        private readonly ILogger<FacebookEsuController> _log;\n        private readonly string _uiBase;\n\n        public FacebookEsuController(\n            IFacebookEsuService service,\n            IEsuStatusService status,\n            ILogger<FacebookEsuController> log,\n            IConfiguration cfg)\n        {\n            _service = service;\n            _status = status;\n            _log = log;\n            _uiBase = (cfg[\"Ui:PublicBaseUrl\"] ?? cfg[\"App:PublicBaseUrl\"] ?? \"http://localhost:3000/\").TrimEnd('/');\n        }\n\n        private static string SanitizeReturnUrlOrDefault(string? returnUrl, string fallback)\n        {\n            if (string.IsNullOrWhiteSpace(returnUrl))\n                return fallback;\n\n            returnUrl = returnUrl.Trim();\n\n            if (!returnUrl.StartsWith(\"/\", StringComparison.Ordinal) ||\n                returnUrl.StartsWith(\"//\", StringComparison.Ordinal) ||\n                returnUrl.Contains(\"\\\\\", StringComparison.Ordinal))\n            {\n                return fallback;\n            }\n\n            return returnUrl;\n        }\n\n        private static string? TryExtractReturnUrlFromState(string state)\n        {\n            // state format: {bizId:N}|{unixTs}|{randomHex}|{returnUrl}\n            // keep backward compatible: if parsing fails, return null.\n            var parts = state.Split('|', 4, StringSplitOptions.None);\n            if (parts.Length < 4) return null;\n\n            var returnUrl = parts[3];\n            return string.IsNullOrWhiteSpace(returnUrl) ? null : returnUrl;\n        }\n\n        private static string AppendParams(string path, string paramPairs)\n        {\n            if (string.IsNullOrWhiteSpace(paramPairs)) return path;\n\n            var cleaned = paramPairs.Trim();\n            cleaned = cleaned.TrimStart('?', '&');\n            if (cleaned.Length == 0) return path;\n\n            var sep = path.Contains(\"?\", StringComparison.Ordinal) ? \"&\" : \"?\";\n            return $\"{path}{sep}{cleaned}\";\n        }\n\n        [HttpGet(\"health\")]\n        [AllowAnonymous]\n        public IActionResult Health()\n            => Ok(new { module = \"ESU\", provider = \"FACEBOOK\", status = \"OK\" });\n\n        // -------- START / RESTART ESU --------\n\n        [HttpPost(\"start\")]\n        [DisableRateLimiting] // ESU handshake must not be throttled\n        public async Task<IActionResult> Start(\n            [FromBody] FacebookEsuStartRequestDto? dto,\n            CancellationToken ct)\n        {\n            try\n            {\n                var businessId = User.GetBusinessId();\n                if (businessId == Guid.Empty)\n                    return Unauthorized(new { ok = false, message = \"Business context missing in token.\" });\n\n                var res = await _service.StartAsync(businessId, dto?.ReturnUrlAfterSuccess, ct);\n\n                _log.LogInformation(\n                    \"ESU start issued for business={BusinessId}, state={State}, expires={Expires}\",\n                    businessId, res.State, res.ExpiresAtUtc);\n\n                return Ok(new\n                {\n                    ok = true,\n                    data = new\n                    {\n                        authUrl = res.LaunchUrl,\n                        state = res.State,\n                        expiresAtUtc = res.ExpiresAtUtc\n                    }\n                });\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"ESU start failed.\");\n                return StatusCode(500, new { ok = false, message = \"Failed to start Meta Embedded Signup.\" });\n            }\n        }\n\n        // -------- OAUTH CALLBACK (PUBLIC) --------\n\n        //[HttpGet(\"callback\")]\n        //[AllowAnonymous]\n        //[DisableRateLimiting]\n        //public async Task<IActionResult> Callback(\n        //    [FromQuery] string? code,\n        //    [FromQuery] string? state,\n        //    CancellationToken ct)\n        //{\n        //    Response.Headers[\"Cache-Control\"] = \"no-store, no-cache, must-revalidate, max-age=0\";\n        //    Response.Headers[\"Pragma\"] = \"no-cache\";\n\n        //    string Target(string q) => $\"{_uiBase}/app/welcomepage{q}\";\n\n        //    if (string.IsNullOrWhiteSpace(code) || string.IsNullOrWhiteSpace(state))\n        //    {\n        //        _log.LogWarning(\"ESU callback missing parameters. codeNull={CodeNull} stateNull={StateNull}\",\n        //            string.IsNullOrWhiteSpace(code), string.IsNullOrWhiteSpace(state));\n        //        return Redirect(Target(\"?error=missing_code_or_state\"));\n        //    }\n\n        //    try\n        //    {\n        //        await _service.HandleCallbackAsync(code!, state!, ct);\n        //        _log.LogInformation(\"ESU callback success for state={State}\", state);\n        //        //return Redirect(Target(\"?connected=1\"));\n        //        return Redirect(Target(\"?esuStatus=success\"));\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        _log.LogError(ex, \"ESU callback failed for state={State}\", state);\n        //        // return Redirect(Target(\"?error=oauth_exchange_failed\"));\n        //        return Redirect(Target(\"?esuStatus=failed&error=oauth_exchange_failed\"));\n        //    }\n        //}\n        [HttpGet(\"callback\")]\n        [AllowAnonymous]\n        [DisableRateLimiting]\n        public async Task<IActionResult> Callback(\n    [FromQuery] string? code,\n    [FromQuery] string? state,\n    CancellationToken ct)\n        {\n            Response.Headers[\"Cache-Control\"] = \"no-store, no-cache, must-revalidate, max-age=0\";\n            Response.Headers[\"Pragma\"] = \"no-cache\";\n\n            var returnUrlFromState = !string.IsNullOrWhiteSpace(state)\n                ? TryExtractReturnUrlFromState(state)\n                : null;\n\n            var returnPath = SanitizeReturnUrlOrDefault(returnUrlFromState, \"/app/welcomepage\");\n\n            string Target(string paramPairs)\n                => $\"{_uiBase}{AppendParams(returnPath, paramPairs)}\";\n\n            if (string.IsNullOrWhiteSpace(code) || string.IsNullOrWhiteSpace(state))\n            {\n                _log.LogWarning(\n                    \"ESU callback missing parameters. codeNull={CodeNull} stateNull={StateNull}\",\n                    string.IsNullOrWhiteSpace(code),\n                    string.IsNullOrWhiteSpace(state));\n\n                return Redirect(Target(\"esuStatus=failed&error=missing_code_or_state\"));\n            }\n\n            try\n            {\n                await _service.HandleCallbackAsync(code!, state!, ct);\n                _log.LogInformation(\"ESU callback success for state={State}\", state);\n\n                return Redirect(Target(\"esuStatus=success\"));\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"ESU callback failed for state={State}\", state);\n                return Redirect(Target(\"esuStatus=failed&error=oauth_exchange_failed\"));\n            }\n        }\n        // -- Set two factor verification ---\n\n    //    [HttpPost(\"register-number\")]\n    //    public async Task<IActionResult> RegisterPhoneNumber(\n    //[FromBody] RegisterPhoneNumberDto dto,\n    //CancellationToken ct)\n    //    {\n    //        var businessId = User.GetBusinessId();\n    //        if (businessId == Guid.Empty)\n    //            return Unauthorized();\n\n    //        await _service.RegisterPhoneNumberAsync(\n    //            businessId,\n    //            dto.Pin,\n    //            ct);\n\n    //        return Ok(new { ok = true });\n    //    }\n        [HttpPost(\"register-number\")]\n        public async Task<IActionResult> RegisterPhoneNumber([FromBody] RegisterPhoneNumberDto dto, CancellationToken ct)\n        {\n            var businessId = User.GetBusinessId();\n            if (businessId == Guid.Empty) return Unauthorized();\n\n            await _service.RegisterPhoneNumberAsync(businessId, dto.Pin, ct);\n            return Ok(new { ok = true });\n        }\n\n        public sealed class RegisterPhoneNumberDto\n        {\n            public string Pin { get; set; } = default!; // 6 digits\n        }\n\n        // -------- DISCONNECT (FULL DEAUTHORIZE) --------\n\n        [HttpDelete(\"disconnect\")]\n        public async Task<IActionResult> Disconnect(CancellationToken ct)\n        {\n            try\n            {\n                var businessId = User.GetBusinessId();\n                if (businessId == Guid.Empty)\n                    return Unauthorized(new { ok = false, message = \"Business context missing in token.\" });\n\n                await _service.DisconnectAsync(businessId, ct);\n                return Ok(new { ok = true });\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"ESU disconnect failed.\");\n                return StatusCode(500, new\n                {\n                    ok = false,\n                    message = \"Failed to disconnect WhatsApp for this workspace.\"\n                });\n            }\n        }\n\n        // -------- STATUS --------\n\n        [HttpGet(\"status\")]\n        public async Task<IActionResult> GetStatus(CancellationToken ct)\n        {\n            var businessId = User.GetBusinessId();\n            if (businessId == Guid.Empty)\n                return Unauthorized(new { ok = false, message = \"Business context missing in token.\" });\n\n            var dto = await _status.GetStatusAsync(businessId, ct);\n\n            // FE already supports both plain DTO and { ok, data }\n            return Ok(new { ok = true, data = dto });\n        }\n\n        // inside FacebookEsuController\n\n        [HttpDelete(\"hard-delete-full-account\")]\n        public async Task<IActionResult> DeleteAccountAndData(CancellationToken ct)\n        {\n            try\n            {\n                var businessId = User.GetBusinessId();\n                if (businessId == Guid.Empty)\n                    return Unauthorized(new { ok = false, message = \"Business context missing in token.\" });\n\n                await _service.FullDeleteAsync(businessId, ct);\n\n                return Ok(new\n                {\n                    ok = true,\n                    message = \"WhatsApp Business API connection and related onboarding data have been deleted for this workspace.\"\n                });\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"ESU account/data delete failed.\");\n                return StatusCode(500, new\n                {\n                    ok = false,\n                    message = \"Failed to delete WhatsApp onboarding data for this workspace.\"\n                });\n            }\n        }\n\n    }\n}\n\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Controllers/FacebookEsuDebugController.cs",
      "sha256": "278b72c0ade6b0335b5f61adde7aeaaad008423cf574b477aa161d365adacad2",
      "language": "csharp",
      "size": 5179,
      "content": "#nullable enable\nusing System;\nusing System.Collections.Generic; // <-- needed for the /me call\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.ESU.Facebook.Abstractions;\nusing xbytechat.api.Features.ESU.Facebook.DTOs;\nusing xbytechat.api.Infrastructure;\nusing xbytechat.api.Shared; // AppDbContext\n\nnamespace xbytechat.api.Features.ESU.Facebook.Controllers\n{\n    [ApiController]\n    [Route(\"api/esu/facebook/debug\")]\n   // [Authorize(Roles = \"SuperAdmin\")] // ‚ö†Ô∏è TEMPORARY for verification; lock down/remove after testing\n    public sealed class FacebookEsuDebugController : ControllerBase\n    {\n        private readonly IFacebookTokenService _tokenService;\n        private readonly AppDbContext _db;\n        private readonly ILogger<FacebookEsuDebugController> _log;\n        private readonly IFacebookGraphClient _graph;\n        private readonly IEsuStatusService _status;\n        public FacebookEsuDebugController(\n            IFacebookTokenService tokenService,\n            AppDbContext db,\n            ILogger<FacebookEsuDebugController> log,\n            IFacebookGraphClient graph,\n            IEsuStatusService status)\n        {\n            _tokenService = tokenService;\n            _db = db;\n            _log = log;\n            _graph = graph;\n            _status = status;\n        }\n\n        // GET /api/esu/facebook/debug/token?businessId=...\n        [HttpGet(\"token\")]\n        public async Task<IActionResult> GetToken([FromQuery] Guid businessId, CancellationToken ct)\n        {\n            if (businessId == Guid.Empty) return BadRequest(\"businessId is required.\");\n\n            var t = await _tokenService.TryGetValidAsync(businessId, ct);\n            if (t is null)\n            {\n                return Ok(new\n                {\n                    ok = false,\n                    message = \"No valid token found (missing or expired). Re-run ESU.\"\n                });\n            }\n\n            return Ok(new\n            {\n                ok = true,\n                tokenPreview = Mask(t.AccessToken),\n                expiresAtUtc = t.ExpiresAtUtc,\n                willExpireSoon = t.WillExpireSoon(),  // default 5m skew\n                rawJsonLength = t.RawJson?.Length ?? 0\n            });\n        }\n\n        [HttpGet(\"status\")]\n        [Authorize]\n        public async Task<ActionResult<EsuStatusDto>> GetStatus(CancellationToken ct)\n        {\n            // Uses the \"businessId\" claim from JWT (lowercase)\n            var businessId = User.GetBusinessId();\n\n            var dto = await _status.GetStatusAsync(businessId, ct);\n\n            // Keep it simple; frontend already normalizes shape\n            return Ok(dto);\n        }\n\n\n        [HttpPost(\"deauthorize\")]\n        public async Task<IActionResult> Deauthorize([FromQuery] Guid businessId, CancellationToken ct)\n        {\n            if (businessId == Guid.Empty) return BadRequest(\"businessId is required.\");\n            await _status.DeauthorizeAsync(businessId, ct);\n            return Ok(new { ok = true });\n        }\n\n\n        // GET /api/esu/facebook/debug/flags?businessId=...\n        [HttpGet(\"flags\")]\n        public async Task<IActionResult> ListFlags([FromQuery] Guid businessId, CancellationToken ct)\n        {\n            if (businessId == Guid.Empty) return BadRequest(\"businessId is required.\");\n\n            // Your IntegrationFlags model is the single-row, column-style model\n            var row = await _db.IntegrationFlags\n                .AsNoTracking()\n                .SingleOrDefaultAsync(x => x.BusinessId == businessId, ct);\n\n            if (row is null)\n            {\n                return Ok(new { ok = true, count = 0, items = Array.Empty<object>() });\n            }\n\n            // Box each element as object so the array can be typed object[]\n            var items = new object[]\n            {\n                new { key = \"FACEBOOK_ESU_COMPLETED\",value = row.FacebookEsuCompleted ? \"true\" : \"false\" }\n    \n            };\n\n            return Ok(new { ok = true, count = items.Length, items });\n        }\n\n        private static string Mask(string? s)\n        {\n            if (string.IsNullOrEmpty(s)) return \"\";\n            if (s.Length <= 10) return new string('*', s.Length);\n            return $\"{s.Substring(0, 6)}‚Ä¶{s.Substring(s.Length - 4)}\";\n        }\n\n        private static string? Preview(string? s, int max)\n        {\n            if (string.IsNullOrEmpty(s)) return null;\n            return s.Length <= max ? s : s.Substring(0, max) + \"‚Ä¶\";\n        }\n\n        // GET /api/esu/facebook/debug/me?businessId=...\n        [HttpGet(\"me\")]\n        public async Task<IActionResult> GetMe([FromQuery] Guid businessId, CancellationToken ct)\n        {\n            if (businessId == Guid.Empty) return BadRequest(\"businessId is required.\");\n\n            var me = await _graph.GetAsync<dynamic>(businessId, \"me\", new Dictionary<string, string?>\n            {\n                [\"fields\"] = \"id,name\"\n            }, ct);\n\n            return Ok(me);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Controllers/FacebookWebhookController.cs",
      "sha256": "37c83b8128f59e8e6aeb523db8f7e1d1070e5e13c91fff4e0554f64150b95b16",
      "language": "csharp",
      "size": 1636,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Options;\nusing xbytechat.api.Features.ESU.Facebook.Options;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Controllers\n{\n    [ApiController]\n    [Route(\"api/esu/facebook/webhook\")]\n    public sealed class FacebookWebhookController : ControllerBase\n    {\n        private readonly string _verifyToken;\n\n        public FacebookWebhookController(IOptions<FacebookOptions> opts)\n        {\n            _verifyToken = opts.Value.VerifyToken ?? string.Empty;\n        }\n\n        // GET verify: echo hub.challenge if token matches\n        [HttpGet]\n        public IActionResult Verify([FromQuery(Name = \"hub.mode\")] string? mode,\n                                    [FromQuery(Name = \"hub.verify_token\")] string? token,\n                                    [FromQuery(Name = \"hub.challenge\")] string? challenge)\n        {\n            if (string.Equals(mode, \"subscribe\", StringComparison.OrdinalIgnoreCase) &&\n                !string.IsNullOrWhiteSpace(token) &&\n                token == _verifyToken &&\n                !string.IsNullOrWhiteSpace(challenge))\n            {\n                return Content(challenge!, \"text/plain\");\n            }\n            return Forbid();\n        }\n\n        // POST stub: logs or routes ESU-related events (optional for App Review)\n        [HttpPost]\n        public async Task<IActionResult> Receive()\n        {\n            using var reader = new StreamReader(Request.Body);\n            var body = await reader.ReadToEndAsync();\n            // TODO: route event to your logger/queue if needed\n            return Ok(new { ok = true });\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Controllers/MetaComplianceController.cs",
      "sha256": "179bb937008d85aeeb49895c0daad03b0e73b79b136c13d93cd3a1e9c5487183",
      "language": "csharp",
      "size": 4673,
      "content": "#nullable enable\nusing System;\nusing System.Security.Cryptography;\nusing System.Text;\nusing System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing xbytechat.api.Features.ESU.Facebook.Abstractions;\nusing xbytechat.api.Features.ESU.Facebook.Options;\nusing xbytechat.api.Features.ESU.Facebook.Services;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Controllers\n{\n    [ApiController]\n    [Route(\"meta\")]\n    public sealed class MetaComplianceController : ControllerBase\n    {\n        private readonly IFacebookEsuService _esuService;\n        private readonly IOptions<FacebookOauthOptions> _fbOpts;\n        private readonly ILogger<MetaComplianceController> _log;\n\n        public MetaComplianceController(\n            IFacebookEsuService esuService,\n            IOptions<FacebookOauthOptions> fbOpts,\n            ILogger<MetaComplianceController> log)\n        {\n            _esuService = esuService;\n            _fbOpts = fbOpts;\n            _log = log;\n        }\n\n        // Configure this URL in Meta's \"Data Deletion\" settings.\n        // Meta sends `signed_request` (base64url.header.payload, HMAC-SHA256 with AppSecret).\n        [HttpPost(\"data-deletion\")]\n        public async Task<IActionResult> HandleDataDeletion([FromForm] string signed_request, CancellationToken ct)\n        {\n            if (string.IsNullOrWhiteSpace(signed_request))\n                return BadRequest(new { status = \"error\", message = \"missing signed_request\" });\n\n            var (ok, payloadJson) = TryValidateSignedRequest(signed_request);\n            if (!ok)\n                return BadRequest(new { status = \"error\", message = \"invalid signed_request\" });\n\n            // Payload typically contains user_id or similar identifiers.\n            // You must map that to your BusinessId based on how you tied ESU sessions to businesses.\n            // For now we assume you store mapping elsewhere and resolve it here.\n            var businessId = ResolveBusinessIdFromPayload(payloadJson);\n            if (businessId == Guid.Empty)\n            {\n                _log.LogInformation(\"Meta data-deletion: no matching business for payload={Payload}\", payloadJson);\n                return Ok(new { status = \"ignored\" });\n            }\n\n            _log.LogInformation(\"Meta data-deletion: biz={BusinessId}\", businessId);\n\n            // Canonical cleanup: same as manual disconnect\n            await _esuService.DisconnectAsync(businessId, ct);\n\n            // Optional: enqueue deeper anonymization/purge if your policy requires.\n            return Ok(new\n            {\n                status = \"success\",\n                reference_id = businessId\n            });\n        }\n\n        private (bool ok, string payloadJson) TryValidateSignedRequest(string signedRequest)\n        {\n            var parts = signedRequest.Split('.', 2);\n            if (parts.Length != 2) return (false, \"\");\n\n            var providedSig = Base64UrlDecode(parts[0]);\n            var payloadBytes = Base64UrlDecode(parts[1]);\n\n            var appSecret = _fbOpts.Value.AppSecret;\n            if (string.IsNullOrWhiteSpace(appSecret))\n                return (false, \"\");\n\n            using var hmac = new HMACSHA256(Encoding.UTF8.GetBytes(appSecret));\n            var expectedSig = hmac.ComputeHash(Encoding.UTF8.GetBytes(parts[1]));\n\n            // Constant-time compare\n            if (!CryptographicOperations.FixedTimeEquals(providedSig, expectedSig))\n                return (false, \"\");\n\n            var payloadJson = Encoding.UTF8.GetString(payloadBytes);\n            return (true, payloadJson);\n        }\n\n        private static byte[] Base64UrlDecode(string input)\n        {\n            input = input.Replace('-', '+').Replace('_', '/');\n            switch (input.Length % 4)\n            {\n                case 2: input += \"==\"; break;\n                case 3: input += \"=\"; break;\n            }\n            return Convert.FromBase64String(input);\n        }\n\n        // TODO: implement this mapping based on your stored ESU context.\n        private Guid ResolveBusinessIdFromPayload(string payloadJson)\n        {\n            using var doc = JsonDocument.Parse(payloadJson);\n            var root = doc.RootElement;\n\n            // Example: if you store mapping from Meta user_id/page_id/WABA to BusinessId.\n            // This is intentionally left for your existing infra.\n            // Return Guid.Empty when no mapping found.\n\n            // var userId = root.GetProperty(\"user_id\").GetString();\n            // lookup Biz by userId...\n\n            return Guid.Empty;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/DTOs/EsuStatusDto.cs",
      "sha256": "500f10342a1b0e3da1a6a434d98299fcb52760d56f35b1743982de9ac7635ec6",
      "language": "csharp",
      "size": 669,
      "content": "#nullable enable\nusing System;\n\nnamespace xbytechat.api.Features.ESU.Facebook.DTOs\n{\n    public sealed class EsuStatusDto\n    {\n        public bool Connected { get; init; }             // true = ESU-complete + valid token\n        public bool HasEsuFlag { get; init; }            // IntegrationFlags row + FacebookEsuCompleted\n        public bool HasValidToken { get; init; }         // from TryGetValidAsync\n        public DateTime? TokenExpiresAtUtc { get; init; }\n        public bool WillExpireSoon { get; init; }\n        public bool HardDeleted { get; init; }\n\n        public DateTime UpdatedAtUtc { get; init; }\n        public string? Debug { get; init; }\n    }\n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/DTOs/FacebookEsuDtos.cs",
      "sha256": "de4844f0acab828a681671d348d4dd9d6be053b2b699fb06b83ac96b9b2c6462",
      "language": "csharp",
      "size": 872,
      "content": "using System;\n\nnamespace xbytechat.api.Features.ESU.Facebook.DTOs\n{\n    // Request from FE to start ESU. BusinessId now comes from header X-Business-Id.\n    public sealed class FacebookEsuStartRequestDto\n    {\n        public string? ReturnUrlAfterSuccess { get; set; }   // optional FE page to navigate to after success\n    }\n\n    // Service-layer response; controller will wrap this into the envelope.\n    public sealed class FacebookEsuStartResponseDto\n    {\n        public string LaunchUrl { get; set; } = string.Empty;\n        public string State { get; set; } = string.Empty;    // returned for debugging/telemetry if needed\n        public DateTime ExpiresAtUtc { get; set; }           // when the state will expire on server\n    }\n\n    public sealed class FacebookEsuCallbackResponseDto\n    {\n        public string RedirectTo { get; set; } = \"/esu/success\";\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Models/EsuToken.cs",
      "sha256": "0cf53a8e94d8023a166f4b195f7d061d6cb4427fc9bba788de58c8aba2ae5aef",
      "language": "csharp",
      "size": 849,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Models\n{\n    [Table(\"EsuTokens\")]\n    public sealed class EsuToken\n    {\n        [Key] public Guid Id { get; set; } = Guid.NewGuid();\n        [Required] public Guid BusinessId { get; set; }\n\n        [Required, MaxLength(50)]\n        public string Provider { get; set; } = \"META_CLOUD\"; // UPPERCASE canonical\n\n        [Required, MaxLength(4096)]\n        public string AccessToken { get; set; } = null!;\n\n        public DateTime? ExpiresAtUtc { get; set; }\n        [MaxLength(512)] public string? Scope { get; set; }\n        public bool IsRevoked { get; set; }\n\n        public DateTime CreatedAtUtc { get; set; } = DateTime.UtcNow;\n        public DateTime? UpdatedAtUtc { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Models/IntegrationFlags.cs",
      "sha256": "cf6cb21691fbbdd8355439ead561d4c93ab07f8caa3f8d434a2f80b86ba71fe2",
      "language": "csharp",
      "size": 1068,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Models\n{\n    /// <summary>\n    /// One row per Business capturing lightweight ‚Äúconnected‚Äù flags\n    /// and optional token metadata for ESU-style integrations.\n    /// </summary>\n    [Table(\"IntegrationFlags\")]\n    public sealed class IntegrationFlags\n    {   \n        [Key]\n        public Guid BusinessId { get; set; }\n\n        // --- Facebook ESU ---\n        public bool FacebookEsuCompleted { get; set; }\n\n        // Optional: store a short-lived user token value/expiry if you plan follow-up Graph calls.\n        // Keep nullable; app can run just with the completion flag.\n        //[MaxLength(2048)]\n        //public string? FacebookAccessToken { get; set; }\n\n        //public DateTime? FacebookTokenExpiresAtUtc { get; set; }\n\n        // housekeeping\n        public DateTime CreatedAtUtc { get; set; } = DateTime.UtcNow;\n        public DateTime UpdatedAtUtc { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Options/FacebookOauthOptions.cs",
      "sha256": "add7b7d980d29b73a36f0a74b24314435d9a01fc1c840cdec28c57b3afc5ff11",
      "language": "csharp",
      "size": 461,
      "content": "#nullable enable\n\nnamespace xbytechat.api.Features.ESU.Facebook.Options\n{\n    public sealed class FacebookOauthOptions\n    {\n        public string AppId { get; set; } = string.Empty;\n        public string AppSecret { get; set; } = string.Empty;\n        public string RedirectUri { get; set; } = string.Empty;\n        public string GraphBaseUrl { get; set; } = \"https://graph.facebook.com\";\n        public string GraphApiVersion { get; set; } = \"v22.0\";\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Options/FacebookOptions.cs",
      "sha256": "b89d5e57d74ac7192083b906ada684a584f86663a53303bfa970df7221033891",
      "language": "csharp",
      "size": 599,
      "content": "namespace xbytechat.api.Features.ESU.Facebook.Options\n{\n    public sealed class FacebookOptions\n    {\n        public string AppId { get; set; } = string.Empty;\n        public string AppSecret { get; set; } = string.Empty;\n        public string RedirectUri { get; set; } = string.Empty;\n\n        // add these if not present\n        public string? Scopes { get; set; }\n        public string? GraphBaseUrl { get; set; }\n        public string? GraphApiVersion { get; set; }\n        public int StateTtlMinutes { get; set; } = 20;\n\n        // NEW:\n        public string? VerifyToken { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Services/EsuStatusService.cs",
      "sha256": "a3923bbab4c09515748083cb6e3a29ea349fe1852ae993432a61150d6571b0c9",
      "language": "csharp",
      "size": 5012,
      "content": "#nullable enable\nusing System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.ESU.Facebook.Abstractions;\nusing xbytechat.api.Features.ESU.Facebook.DTOs;\nusing xbytechat.api.Infrastructure;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Services\n{\n    public sealed class EsuStatusService : IEsuStatusService\n    {\n        private const string Provider = \"META_CLOUD\";\n\n        private readonly AppDbContext _db;\n        private readonly IFacebookTokenService _tokenService;\n        private readonly IEsuTokenStore _tokens;\n        private readonly ILogger<EsuStatusService> _log;\n\n        public EsuStatusService(\n            AppDbContext db,\n            IFacebookTokenService tokenService,\n            IEsuTokenStore tokens,\n            ILogger<EsuStatusService> log)\n        {\n            _db = db;\n            _tokenService = tokenService;\n            _tokens = tokens;\n            _log = log;\n        }\n\n        public async Task<EsuStatusDto> GetStatusAsync(Guid businessId, CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty)\n                throw new ArgumentException(\"businessId is required.\", nameof(businessId));\n\n            var now = DateTime.UtcNow;\n\n            // 1) Read IntegrationFlags row (UX flag)\n            var row = await _db.IntegrationFlags\n                .AsNoTracking()\n                .SingleOrDefaultAsync(x => x.BusinessId == businessId, ct);\n\n            var hasEsuFlag = row?.FacebookEsuCompleted ?? false;\n\n            // 2) Pull latest token row (even if expiring/expired) to show expiry in UI\n            //    (TryGetValidAsync hides expiring tokens by design)\n            var latestToken = await _db.EsuTokens\n                .AsNoTracking()\n                .Where(x => x.BusinessId == businessId && x.Provider == Provider)\n                .OrderByDescending(x => x.UpdatedAtUtc ?? x.CreatedAtUtc)\n                .FirstOrDefaultAsync(ct);\n\n            DateTime? expiresAt = latestToken?.ExpiresAtUtc;\n\n            // 3) Determine \"valid token\" using canonical service logic\n            bool hasValidToken = false;\n            try\n            {\n                var valid = await _tokenService.TryGetValidAsync(businessId, ct);\n                hasValidToken = valid is not null;\n\n                // Prefer valid token expiry if token row doesn't have it for some reason\n                expiresAt ??= valid?.ExpiresAtUtc;\n            }\n            catch (Exception ex)\n            {\n                _log.LogDebug(ex, \"Status check token probe failed for {Biz}\", businessId);\n            }\n\n            // 4) HardDeleted detection (your intended terminal state)\n            var hasAnyToken = await _db.EsuTokens\n                .AsNoTracking()\n                .AnyAsync(x => x.BusinessId == businessId && x.Provider == Provider, ct);\n\n            var hasAnySetting = await _db.WhatsAppSettings\n                .AsNoTracking()\n                .AnyAsync(x => x.BusinessId == businessId && x.Provider == Provider, ct);\n\n            var hasAnyPhone = await _db.WhatsAppPhoneNumbers\n                .AsNoTracking()\n                .AnyAsync(x => x.BusinessId == businessId && x.Provider == Provider, ct);\n\n            // ‚úÖ Terminal state: no flags row + no tokens/settings/phones\n            var hardDeleted = (row is null) && !hasAnyToken && !hasAnySetting && !hasAnyPhone;\n\n            // 5) Expiring soon (UI signal)\n            var willExpireSoon =\n                expiresAt.HasValue &&\n                expiresAt.Value > now &&\n                expiresAt.Value <= now.AddMinutes(10);\n\n            var updatedAt = row?.UpdatedAtUtc ?? now;\n\n            return new EsuStatusDto\n            {\n                Connected = hasEsuFlag && hasValidToken,\n                HasEsuFlag = hasEsuFlag,\n                HasValidToken = hasValidToken,\n                TokenExpiresAtUtc = expiresAt,\n                WillExpireSoon = willExpireSoon,\n                HardDeleted = hardDeleted,\n                UpdatedAtUtc = updatedAt,\n                Debug = row is null ? \"no-row\" : null\n            };\n        }\n\n        public async Task DeauthorizeAsync(Guid businessId, CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty)\n                throw new ArgumentException(\"businessId is required.\", nameof(businessId));\n\n            // 1) Clear UX flag\n            var row = await _db.IntegrationFlags\n                .SingleOrDefaultAsync(x => x.BusinessId == businessId, ct);\n\n            if (row is not null)\n            {\n                row.FacebookEsuCompleted = false;\n                row.UpdatedAtUtc = DateTime.UtcNow;\n                await _db.SaveChangesAsync(ct);\n            }\n\n            // 2) Revoke token (EsuTokens) + 3) drop from cache\n            await _tokens.RevokeAsync(businessId, Provider, ct);\n            await _tokenService.InvalidateAsync(businessId, ct);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Services/EsuTokenStore.cs",
      "sha256": "a241632aaf4b68f5cf874f010a82bb73d3fe65d14c695d8fba2c29b06bb0cac5",
      "language": "csharp",
      "size": 2256,
      "content": "using Microsoft.EntityFrameworkCore;\nusing xbytechat.api;\nusing xbytechat.api.Features.ESU.Facebook.Models;\nusing xbytechat.api.Infrastructure;\n\npublic sealed class EsuTokenStore : IEsuTokenStore\n{\n    private readonly AppDbContext _db;\n    public EsuTokenStore(AppDbContext db) => _db = db;\n\n    public Task<EsuToken?> GetAsync(Guid biz, string provider, CancellationToken ct)\n        => _db.Set<EsuToken>().AsNoTracking()\n              .FirstOrDefaultAsync(x => x.BusinessId == biz && x.Provider == provider, ct);\n\n    public async Task UpsertAsync(Guid biz, string provider, string token, DateTime? exp, CancellationToken ct)\n    {\n        provider = provider.ToUpperInvariant();\n\n        var row = await _db.Set<EsuToken>()\n            .FirstOrDefaultAsync(x => x.BusinessId == biz && x.Provider == provider, ct);\n\n        if (row is null)\n        {\n            _db.Add(new EsuToken\n            {\n                BusinessId = biz,\n                Provider = provider,\n                AccessToken = token,\n                ExpiresAtUtc = exp,\n                IsRevoked = string.IsNullOrWhiteSpace(token) // treat empty as revoked\n            });\n        }\n        else\n        {\n            row.AccessToken = token;\n            row.ExpiresAtUtc = exp;\n            row.IsRevoked = string.IsNullOrWhiteSpace(token) ? true : false;\n            row.UpdatedAtUtc = DateTime.UtcNow;\n        }\n\n        await _db.SaveChangesAsync(ct);\n    }\n\n\n    public async Task RevokeAsync(Guid biz, string provider, CancellationToken ct)\n    {\n        var row = await _db.Set<EsuToken>().FirstOrDefaultAsync(x => x.BusinessId == biz && x.Provider == provider, ct);\n        if (row is null) return;\n        row.IsRevoked = true; row.UpdatedAtUtc = DateTime.UtcNow;\n        await _db.SaveChangesAsync(ct);\n    }\n\n    // FILE: Features/ESU/Facebook/Services/EsuTokenStore.cs\n\n    public async Task DeleteAsync(Guid biz, string provider, CancellationToken ct = default)\n    {\n        var set = _db.Set<EsuToken>();\n\n        var rows = await set\n            .Where(x => x.BusinessId == biz && x.Provider == provider)\n            .ToListAsync(ct);\n\n        if (rows.Count == 0)\n            return;\n\n        set.RemoveRange(rows);\n        await _db.SaveChangesAsync(ct);\n    }\n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Services/FacebookEsuService.cs",
      "sha256": "95c016707367965c261435e3c929f556ae1e676d755f88ec85b18a600baf2ab3",
      "language": "csharp",
      "size": 40455,
      "content": "using System;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Net.Http.Json;\nusing System.Security.Cryptography;\nusing System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.WebUtilities;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing xbytechat.api.Features.ESU.Facebook.Abstractions;\nusing xbytechat.api.Features.ESU.Facebook.Contracts;\nusing xbytechat.api.Features.ESU.Facebook.DTOs;\nusing xbytechat.api.Features.ESU.Facebook.Options;\nusing xbytechat.api.Features.ESU.Facebook.Clients;\nusing xbytechat.api.Features.ESU.Shared;\nusing xbytechat.api.Features.WhatsAppSettings.Services;\nusing xbytechat.api.WhatsAppSettings.DTOs;\nusing xbytechat_api.WhatsAppSettings.DTOs;\nusing xbytechat_api.WhatsAppSettings.Services;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Services\n{\n    internal sealed class FacebookEsuService : IFacebookEsuService\n    {\n        private const string Provider = \"META_CLOUD\";\n\n        private readonly IOptions<EsuOptions> _options;\n        private readonly IOptions<FacebookOauthOptions> _oauthOpts;\n        private readonly IEsuStateStore _stateStore;\n        private readonly IEsuFlagStore _flagStore;\n        private readonly IFacebookOauthClient _oauth;\n        private readonly IEsuTokenStore _tokens;\n        private readonly IFacebookTokenService _fbTokens;\n        private readonly IWhatsAppSettingsService _waSettings;\n        private readonly IWhatsAppPhoneNumberService _waPhones;\n        private readonly ILogger<FacebookEsuService> _log;\n        private readonly IEsuStatusService _esuStatus;\n        private readonly IWabaSubscriptionClient _wabaSubscription;\n\n        public FacebookEsuService(\n            IOptions<EsuOptions> options,\n            IEsuStateStore stateStore,\n            IEsuFlagStore flagStore,\n            IFacebookOauthClient oauth,\n            IEsuTokenStore tokens,\n            IFacebookTokenService fbTokens,\n            IWhatsAppSettingsService waSettings,\n            IWhatsAppPhoneNumberService waPhones,\n            IOptions<FacebookOauthOptions> oauthOpts,\n            ILogger<FacebookEsuService> log,\n            IEsuStatusService esuStatus,\n            IWabaSubscriptionClient wabaSubscription)\n        {\n            _options = options;\n            _stateStore = stateStore;\n            _flagStore = flagStore;\n            _oauth = oauth;\n            _tokens = tokens;\n            _fbTokens = fbTokens;\n            _waSettings = waSettings;\n            _waPhones = waPhones;\n            _oauthOpts = oauthOpts;\n            _log = log;\n            _esuStatus = esuStatus;\n            _wabaSubscription = wabaSubscription;\n        }\n\n        // =======================\n        // ESU START\n        // =======================\n        public async Task<FacebookEsuStartResponseDto> StartAsync(\n            Guid businessId,\n            string? returnUrl,\n            CancellationToken ct = default)\n        {\n            var cfg = _options.Value.Facebook;\n\n            if (string.IsNullOrWhiteSpace(cfg.AppId))\n                throw new InvalidOperationException(\"ESU.Facebook.AppId is not configured.\");\n            if (string.IsNullOrWhiteSpace(cfg.RedirectUri))\n                throw new InvalidOperationException(\"ESU.Facebook.RedirectUri is not configured.\");\n            if (string.IsNullOrWhiteSpace(cfg.ConfigId))\n                throw new InvalidOperationException(\"ESU.Facebook.ConfigId is not configured.\");\n\n            var state = CreateStateToken(businessId, returnUrl);\n            var ttl = TimeSpan.FromMinutes(Math.Max(1, cfg.StateTtlMinutes));\n\n            await _stateStore.StoreAsync(state, businessId, ttl);\n\n            var dialogVersion = _oauthOpts.Value.GraphApiVersion?.Trim('/') ?? \"v20.0\";\n            var dialogBase = $\"https://www.facebook.com/{dialogVersion}/dialog/oauth\";\n\n            var query = new System.Collections.Generic.Dictionary<string, string?>\n            {\n                [\"client_id\"] = cfg.AppId,\n                [\"redirect_uri\"] = cfg.RedirectUri,\n                [\"state\"] = state,\n                [\"response_type\"] = \"code\",\n                [\"config_id\"] = cfg.ConfigId,\n\n                // ‚úÖ IMPORTANT: Explicit scope improves reliability + App Review clarity\n                [\"scope\"] = !string.IsNullOrWhiteSpace(cfg.Scopes)\n                    ? cfg.Scopes.Trim()\n                    : null\n            };\n\n            var launchUrl = QueryHelpers.AddQueryString(dialogBase, query);\n\n            _log.LogInformation(\n                \"ESU Start: biz={BusinessId}, statePrefix={StatePrefix}, url={Url}\",\n                businessId,\n                state.Length > 16 ? state[..16] : state,\n                launchUrl);\n\n            return new FacebookEsuStartResponseDto\n            {\n                LaunchUrl = launchUrl,\n                State = state,\n                ExpiresAtUtc = DateTime.UtcNow.Add(ttl)\n            };\n        }\n\n        // =======================\n        // ESU CALLBACK\n        // =======================\n        public async Task<FacebookEsuCallbackResponseDto> HandleCallbackAsync(\n            string code,\n            string state,\n            CancellationToken ct = default)\n        {\n            if (string.IsNullOrWhiteSpace(code))\n                throw new InvalidOperationException(\"OAuth failed: missing 'code'.\");\n            if (string.IsNullOrWhiteSpace(state))\n                throw new InvalidOperationException(\"OAuth failed: missing 'state'.\");\n\n            var (found, businessId) = await _stateStore.TryConsumeAsync(state);\n            if (!found || businessId == Guid.Empty)\n                throw new InvalidOperationException(\"Invalid or expired state.\");\n\n            _log.LogInformation(\n                \"ESU Callback: biz={BusinessId}, statePrefix={StatePrefix}\",\n                businessId,\n                state.Length > 16 ? state[..16] : state);\n\n            // 1) Exchange short-lived ‚Üí long-lived token\n            var token = await _oauth.ExchangeCodeAsync(code, ct);\n            if (string.IsNullOrWhiteSpace(token?.AccessToken))\n                throw new InvalidOperationException(\"OAuth exchange did not return an access token.\");\n\n            token = await _oauth.ExchangeForLongLivedAsync(token, ct);\n\n            var accessToken = token.AccessToken;\n            DateTime? expiresAtUtc = (token.ExpiresInSeconds > 0)\n                ? DateTime.UtcNow.AddSeconds(token.ExpiresInSeconds)\n                : (DateTime?)null;\n\n            _log.LogInformation(\n                \"ESU Callback: received long-lived token for biz={BusinessId}, expiresAt={ExpiresAt}\",\n                businessId,\n                expiresAtUtc?.ToString(\"O\") ?? \"<none>\");\n\n            await _tokens.UpsertAsync(\n                businessId,\n                Provider,\n                accessToken,\n                expiresAtUtc,\n                ct);\n\n            await _fbTokens.InvalidateAsync(businessId, ct);\n\n            var graphBase = _oauthOpts.Value.GraphBaseUrl?.TrimEnd('/') ?? \"https://graph.facebook.com\";\n            var graphVer = _oauthOpts.Value.GraphApiVersion?.Trim('/') ?? \"v20.0\";\n            var apiBase = $\"{graphBase}/{graphVer}\";\n\n            // 2) WABA DISCOVERY\n            string? wabaId = null;\n\n            try\n            {\n                var oauthCfg = _oauthOpts.Value;\n\n                if (!string.IsNullOrWhiteSpace(oauthCfg.AppId) &&\n                    !string.IsNullOrWhiteSpace(oauthCfg.AppSecret))\n                {\n                    var viaDebug = await TryGetWabaFromDebugTokenAsync(\n                        graphBase,\n                        accessToken,\n                        oauthCfg.AppId,\n                        oauthCfg.AppSecret,\n                        ct);\n\n                    if (!string.IsNullOrWhiteSpace(viaDebug))\n                    {\n                        wabaId = viaDebug;\n                        _log.LogInformation(\n                            \"ESU Callback: WABA discovered via debug_token: {WabaId} (biz={BusinessId})\",\n                            wabaId,\n                            businessId);\n                    }\n                }\n                else\n                {\n                    _log.LogWarning(\n                        \"ESU Callback: AppId/AppSecret missing in FacebookOauthOptions; skipping debug_token WABA discovery (biz={BusinessId})\",\n                        businessId);\n                }\n\n                if (string.IsNullOrWhiteSpace(wabaId))\n                {\n                    wabaId = await TryGetWabaFromMeAccountsAsync(apiBase, accessToken, ct);\n                }\n\n                if (string.IsNullOrWhiteSpace(wabaId))\n                {\n                    wabaId = await TryGetWabaFromBusinessesAsync(apiBase, accessToken, ct);\n                }\n\n                if (string.IsNullOrWhiteSpace(wabaId))\n                {\n                    _log.LogWarning(\n                        \"ESU Callback: No WABA discovered for biz={BusinessId}. Token scopes or ESU config may be incomplete.\",\n                        businessId);\n                }\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"ESU Callback: Error during WABA discovery for biz={BusinessId}\", businessId);\n            }\n\n            // 3) SAVE GLOBAL SETTINGS\n            try\n            {\n                var dto = new SaveWhatsAppSettingDto\n                {\n                    BusinessId = businessId,\n                    Provider = Provider,\n                    ApiUrl = apiBase,\n                    ApiKey = accessToken,\n                    WabaId = string.IsNullOrWhiteSpace(wabaId) ? null : wabaId,\n                    SenderDisplayName = null,\n                    WebhookSecret = null,\n                    WebhookVerifyToken = null,\n                    WebhookCallbackUrl = null,\n                    IsActive = true\n                };\n\n                await _waSettings.SaveOrUpdateSettingAsync(dto);\n\n                _log.LogInformation(\n                    \"ESU Callback: WhatsApp settings saved for biz={BusinessId}, provider={Provider}, hasWaba={HasWaba}\",\n                    businessId,\n                    Provider,\n                    !string.IsNullOrWhiteSpace(wabaId));\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"ESU Callback: Failed to save WhatsApp settings for biz={BusinessId}\", businessId);\n            }\n\n            // ‚úÖ IMPORTANT: Load setting ONCE for steps 4 + subscription\n            WhatsAppSettingsDto? setting = null;\n            try\n            {\n                setting = await _waSettings.GetSettingsByBusinessIdAsync(businessId);\n            }\n            catch (Exception ex)\n            {\n                _log.LogWarning(ex, \"ESU Callback: Failed to reload WhatsApp settings for biz={BusinessId}\", businessId);\n            }\n\n            // 4) SYNC PHONE NUMBERS (best-effort, but logged)\n            try\n            {\n                if (setting is not null &&\n                    setting.Provider?.Equals(Provider, StringComparison.OrdinalIgnoreCase) == true &&\n                    !string.IsNullOrWhiteSpace(setting.WabaId) &&\n                    !string.IsNullOrWhiteSpace(setting.ApiKey))\n                {\n                    // ‚úÖ FIX: box tuple into object so \"?.ToString()\" compiles\n                    object syncResult = await _waPhones.SyncFromProviderAsync(businessId, setting, Provider, ct);\n\n                    if (TryExtractCounts(syncResult, out var added, out var updated, out var total))\n                    {\n                        _log.LogInformation(\n                            \"ESU Callback: Phone sync complete for biz={BusinessId}. Added={Added}, Updated={Updated}, Total={Total}\",\n                            businessId, added, updated, total);\n                    }\n                    else\n                    {\n                        _log.LogInformation(\n                            \"ESU Callback: Phone sync complete for biz={BusinessId}. Result={Result}\",\n                            businessId,\n                            syncResult?.ToString() ?? \"<null>\");\n                    }\n                }\n                else\n                {\n                    _log.LogWarning(\n                        \"ESU Callback: Skipping phone sync for biz={BusinessId} (provider={Provider}, WabaId={WabaId}, HasApiKey={HasKey})\",\n                        businessId,\n                        setting?.Provider,\n                        setting?.WabaId ?? \"<none>\",\n                        !string.IsNullOrWhiteSpace(setting?.ApiKey));\n                }\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"ESU Callback: Error during phone sync for biz={BusinessId}\", businessId);\n            }\n\n            // 4b) Subscribe WABA to app events\n            if (setting is not null && !string.IsNullOrWhiteSpace(setting.WabaId))\n            {\n                try\n                {\n                    await SubscribeWabaAsync(setting.WabaId!, accessToken, ct);\n\n                    _log.LogInformation(\n                        \"ESU Callback: WABA subscribed successfully. biz={BusinessId}, wabaId={WabaId}\",\n                        businessId, setting.WabaId);\n                }\n                catch (Exception ex)\n                {\n                    _log.LogWarning(ex,\n                        \"ESU Callback: WABA subscribe failed (non-blocking). businessId={BusinessId}, wabaId={WabaId}\",\n                        businessId, setting.WabaId);\n                }\n            }\n\n            // 5) FLAG AS COMPLETED\n            try\n            {\n                var payloadJson = JsonSerializer.Serialize(new\n                {\n                    completed = true,\n                    provider = Provider,\n                    expires_at_utc = expiresAtUtc\n                });\n\n                await _flagStore.UpsertAsync(\n                    businessId,\n                    key: \"facebook.esu\",\n                    value: \"completed\",\n                    jsonPayload: payloadJson,\n                    ct: ct);\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"ESU Callback: Failed to write ESU completion flag for biz={BusinessId}\", businessId);\n            }\n\n            // 6) AUTO-REGISTER (HYBRID FLOW: Try \"123456\", fallback to UI if mismatch)\n            // CHECK STATUS FIRST: If any number is already CONNECTED, skip registration.\n            var phones = await _waPhones.ListAsync(businessId, Provider, ct);\n            bool alreadyConnected = phones.Any(p => p.Status?.ToUpper() == \"CONNECTED\");\n\n            string finalStatus = \"success\";\n            if (!alreadyConnected) \n            {\n                try \n                {\n                   await RegisterPhoneNumberAsync(businessId, \"123456\", ct);\n                   _log.LogInformation(\"ESU Callback: Auto-registration with default PIN success for biz={BusinessId}\", businessId);\n                }\n                catch (Exception ex) \n                {\n                   // If it's a conflict or specific error, we need the user to enter their old PIN\n                   // 409 Conflict is typical for \"PIN mismatch\" or \"Already registered with different PIN\"\n                   _log.LogWarning(\"ESU Callback: Auto-registration failed (biz={BusinessId}). User must enter PIN manually. Error: {Error}\", businessId, ex.Message);\n                   finalStatus = \"needs_pin\";\n                }\n            }\n            else \n            {\n                _log.LogInformation(\"ESU Callback: Phone(s) already CONNECTED for biz={BusinessId}. Skipping auto-registration.\", businessId);\n            }\n\n            // 7) FINAL REDIRECT\n            var rawReturnUrl = TryGetReturnUrlFromState(state);\n            var redirectBase = SanitizeReturnUrlOrDefault(rawReturnUrl, \"/app/esu-processing\");\n\n            var redirect = redirectBase.Contains(\"?\")\n                ? $\"{redirectBase}&esuStatus={finalStatus}\"\n                : $\"{redirectBase}?esuStatus={finalStatus}\";\n\n            return new FacebookEsuCallbackResponseDto { RedirectTo = redirect };\n        }\n\n        // =======================\n        // DISCONNECT\n        // =======================\n        public async Task DisconnectAsync(Guid businessId, CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty)\n                throw new ArgumentException(\"BusinessId is required.\", nameof(businessId));\n\n            _log.LogInformation(\"ESU Disconnect: biz={BusinessId}\", businessId);\n\n            bool hadEsuOrToken = false;\n\n            object? statusObj = null;\n            try\n            {\n                statusObj = await _esuStatus.GetStatusAsync(businessId, ct);\n                if (statusObj is not null)\n                {\n                    hadEsuOrToken = ReadBool(statusObj, \"Connected\")\n                                    || ReadBool(statusObj, \"HasEsuFlag\")\n                                    || ReadBool(statusObj, \"HasValidToken\");\n                }\n            }\n            catch (Exception ex)\n            {\n                _log.LogWarning(ex, \"ESU Disconnect: failed to read status for biz={BusinessId}; continuing.\", businessId);\n            }\n\n            if (statusObj is not null && (ReadBool(statusObj, \"HardDeleted\") || ReadBool(statusObj, \"IsHardDeleted\")))\n            {\n                _log.LogInformation(\"ESU Disconnect: biz={BusinessId} is hard-deleted; skipping disconnect to avoid re-creating data.\", businessId);\n                return;\n            }\n\n            if (!hadEsuOrToken)\n            {\n                _log.LogInformation(\n                    \"ESU Disconnect: nothing to disconnect for biz={BusinessId} (no ESU flags/tokens/settings).\",\n                    businessId);\n                return;\n            }\n\n            // 1) Remote revoke (best-effort)\n            try\n            {\n                var t = await _tokens.GetAsync(businessId, Provider, ct);\n                if (t is not null && !string.IsNullOrWhiteSpace(t.AccessToken) && !t.IsRevoked)\n                {\n                    var graphBase = _oauthOpts.Value.GraphBaseUrl?.TrimEnd('/') ?? \"https://graph.facebook.com\";\n                    var graphVer = _oauthOpts.Value.GraphApiVersion?.Trim('/') ?? \"v20.0\";\n                    var apiBase = $\"{graphBase}/{graphVer}\";\n\n                    // 1a) Unsubscribe WABA from app (CRITICAL for clean re-signup)\n                    try \n                    {\n                        var setting = await _waSettings.GetSettingsByBusinessIdAsync(businessId);\n                        if (setting is not null && !string.IsNullOrWhiteSpace(setting.WabaId))\n                        {\n                            _log.LogInformation(\"ESU Disconnect: attempting Meta WABA unsubscribe for biz={BusinessId}, waba={WabaId}\", \n                                businessId, setting.WabaId);\n                            \n                            await _wabaSubscription.UnsubscribeAsync(setting.WabaId, t.AccessToken, ct);\n                        }\n                    }\n                    catch (Exception ex)\n                    {\n                        _log.LogWarning(ex, \"ESU Disconnect: Meta WABA unsubscribe failed (non-blocking) for biz={BusinessId}\", businessId);\n                    }\n\n                    // 1b) Revoke permissions\n                    using var http = new HttpClient();\n                    http.DefaultRequestHeaders.Authorization =\n                        new AuthenticationHeaderValue(\"Bearer\", t.AccessToken);\n\n                    var resp = await http.DeleteAsync($\"{apiBase}/me/permissions\", ct);\n                    if (!resp.IsSuccessStatusCode)\n                    {\n                        _log.LogWarning(\n                            \"ESU Disconnect: remote revoke returned {Status} for biz={BusinessId}\",\n                            resp.StatusCode, businessId);\n                    }\n                }\n            }\n            catch (Exception ex)\n            {\n                _log.LogWarning(ex, \"ESU Disconnect: error during remote revoke for biz={BusinessId}\", businessId);\n            }\n\n            // 2) Canonical local deauthorize\n            try\n            {\n                await _esuStatus.DeauthorizeAsync(businessId, ct);\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"ESU Disconnect: error during local deauthorize for biz={BusinessId}\", businessId);\n            }\n\n            // 3) Deactivate WhatsApp settings\n            try\n            {\n                var existing = await _waSettings.GetSettingsByBusinessIdAsync(businessId);\n                if (existing is not null)\n                {\n                    await _waSettings.SaveOrUpdateSettingAsync(new SaveWhatsAppSettingDto\n                    {\n                        BusinessId = businessId,\n                        Provider = Provider,\n                        ApiUrl = null,\n                        ApiKey = null,\n                        WabaId = null,\n                        SenderDisplayName = null,\n                        WebhookSecret = null,\n                        WebhookVerifyToken = null,\n                        WebhookCallbackUrl = null,\n                        IsActive = false\n                    });\n                }\n                else\n                {\n                    _log.LogInformation(\n                        \"ESU Disconnect: WhatsApp settings already absent for biz={BusinessId}; skipping deactivation to avoid recreating rows.\",\n                        businessId);\n                }\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"ESU Disconnect: error deactivating WhatsApp settings for biz={BusinessId}\", businessId);\n            }\n\n            // 4) UX flag\n            try\n            {\n                await _flagStore.UpsertAsync(\n                    businessId,\n                    key: \"facebook.esu\",\n                    value: \"disconnected\",\n                    jsonPayload: \"{\\\"completed\\\":false}\",\n                    ct: ct);\n            }\n            catch (Exception ex)\n            {\n                _log.LogWarning(ex, \"ESU Disconnect: failed to update ESU 'disconnected' flag for biz={BusinessId}\", businessId);\n            }\n        }\n\n        // =======================\n        // FULL DELETE (hard delete)\n        // =======================\n        public async Task FullDeleteAsync(Guid businessId, CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty)\n                throw new ArgumentException(\"BusinessId is required.\", nameof(businessId));\n\n            _log.LogInformation(\"ESU FullDelete: start for biz={BusinessId}\", businessId);\n\n            try\n            {\n                await DisconnectAsync(businessId, ct);\n            }\n            catch (Exception ex)\n            {\n                _log.LogWarning(ex,\n                    \"ESU FullDelete: DisconnectAsync failed or partial for biz={BusinessId}. Continuing with local cleanup.\",\n                    businessId);\n            }\n\n            try\n            {\n                await _tokens.DeleteAsync(businessId, Provider, ct);\n                _log.LogInformation(\"ESU FullDelete: EsuTokens deleted for biz={BusinessId}\", businessId);\n            }\n            catch (Exception ex)\n            {\n                _log.LogWarning(ex, \"ESU FullDelete: failed to delete EsuTokens for biz={BusinessId}\", businessId);\n            }\n\n            try\n            {\n                var deleted = await _waSettings.DeleteSettingsAsync(businessId, ct);\n                _log.LogInformation(\"ESU FullDelete: WhatsApp settings+phones delete={Deleted} for biz={BusinessId}\", deleted, businessId);\n            }\n            catch (Exception ex)\n            {\n                _log.LogWarning(ex, \"ESU FullDelete: failed to delete WhatsApp settings for biz={BusinessId}\", businessId);\n            }\n\n            try\n            {\n                await _flagStore.DeleteAsync(businessId, ct);\n                _log.LogInformation(\"ESU FullDelete: IntegrationFlags row deleted for biz={BusinessId}\", businessId);\n            }\n            catch (Exception ex)\n            {\n                _log.LogWarning(ex, \"ESU FullDelete: failed to delete IntegrationFlags for biz={BusinessId}\", businessId);\n            }\n\n            try\n            {\n                await _fbTokens.InvalidateAsync(businessId, ct);\n            }\n            catch (Exception ex)\n            {\n                _log.LogDebug(ex, \"ESU FullDelete: token cache invalidate failed for biz={BusinessId}\", businessId);\n            }\n\n            _log.LogInformation(\"ESU FullDelete: completed for biz={BusinessId}\", businessId);\n        }\n\n        // =======================\n        // REGISTER NUMBER\n        // =======================\n        public async Task RegisterPhoneNumberAsync(Guid businessId, string pin, CancellationToken ct)\n        {\n            if (businessId == Guid.Empty)\n                throw new ArgumentException(\"BusinessId is required.\", nameof(businessId));\n\n            pin = (pin ?? string.Empty).Trim();\n\n            if (pin.Length != 6 || !IsAllDigits(pin))\n                throw new InvalidOperationException(\"PIN must be exactly 6 digits.\");\n\n            var setting = await _waSettings.GetSettingsByBusinessIdAsync(businessId);\n            if (setting is null)\n                throw new InvalidOperationException(\"WhatsApp settings not found for this business. Please connect ESU first.\");\n\n            if (!string.Equals(setting.Provider, Provider, StringComparison.OrdinalIgnoreCase))\n                throw new InvalidOperationException($\"Invalid provider. Expected '{Provider}' but got '{setting.Provider}'.\");\n\n            if (string.IsNullOrWhiteSpace(setting.ApiUrl) || string.IsNullOrWhiteSpace(setting.ApiKey))\n                throw new InvalidOperationException(\"WhatsApp settings are missing ApiUrl/ApiKey. Please reconnect ESU.\");\n\n            var phones = await _waPhones.ListAsync(businessId, Provider, ct);\n            if (phones is null || phones.Count == 0)\n                throw new InvalidOperationException(\"No phone numbers found. Please complete ESU and phone sync first.\");\n\n            var phone = phones[0];\n            var phoneNumberId = GetPhoneNumberId(phone);\n\n            if (string.IsNullOrWhiteSpace(phoneNumberId))\n                throw new InvalidOperationException(\"PhoneNumberId is missing in stored phone record. Sync did not capture it.\");\n\n            var url = $\"{setting.ApiUrl.TrimEnd('/')}/{phoneNumberId}/register\";\n\n            var payload = new\n            {\n                messaging_product = \"whatsapp\",\n                pin = pin\n            };\n\n            _log.LogInformation(\n                \"ESU RegisterNumber: registering phone_number_id={PhoneNumberId} for biz={BusinessId}\",\n                phoneNumberId,\n                businessId);\n\n            using var http = new HttpClient();\n            http.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(\"Bearer\", setting.ApiKey);\n\n            using var req = new HttpRequestMessage(HttpMethod.Post, url)\n            {\n                Content = JsonContent.Create(payload)\n            };\n\n            using var res = await http.SendAsync(req, ct);\n            var body = await res.Content.ReadAsStringAsync(ct);\n\n            if (!res.IsSuccessStatusCode)\n            {\n                _log.LogWarning(\n                    \"ESU RegisterNumber failed: biz={BusinessId}, phone_number_id={PhoneNumberId}, status={Status}, body={Body}\",\n                    businessId,\n                    phoneNumberId,\n                    (int)res.StatusCode,\n                    Truncate(body));\n\n                throw new InvalidOperationException($\"Failed to register phone number. Meta returned {(int)res.StatusCode}.\");\n            }\n\n            _log.LogInformation(\n                \"ESU RegisterNumber success: biz={BusinessId}, phone_number_id={PhoneNumberId}, body={Body}\",\n                businessId,\n                phoneNumberId,\n                Truncate(body));\n\n            // Best-effort: resync after register\n            try\n            {\n                // ‚úÖ FIX: box tuple into object so \"?.ToString()\" compiles\n                object syncResult = await _waPhones.SyncFromProviderAsync(businessId, setting, Provider, ct);\n\n                if (TryExtractCounts(syncResult, out var added, out var updated, out var total))\n                {\n                    _log.LogInformation(\n                        \"ESU RegisterNumber: phone sync after register complete for biz={BusinessId}. Added={Added}, Updated={Updated}, Total={Total}\",\n                        businessId, added, updated, total);\n                }\n                else\n                {\n                    _log.LogInformation(\n                        \"ESU RegisterNumber: phone sync after register complete for biz={BusinessId}. Result={Result}\",\n                        businessId,\n                        syncResult?.ToString() ?? \"<null>\");\n                }\n            }\n            catch (Exception ex)\n            {\n                _log.LogWarning(ex,\n                    \"ESU RegisterNumber: sync-after-register failed for biz={BusinessId} (non-blocking).\",\n                    businessId);\n            }\n        }\n\n        // =======================\n        // HELPERS\n        // =======================\n        private static string CreateStateToken(Guid businessId, string? returnUrl)\n        {\n            Span<byte> random = stackalloc byte[16];\n            RandomNumberGenerator.Fill(random);\n            var payload =\n                $\"{businessId:N}|{DateTimeOffset.UtcNow.ToUnixTimeSeconds()}|{Convert.ToHexString(random)}|{(returnUrl ?? \"\")}\";\n            var bytes = System.Text.Encoding.UTF8.GetBytes(payload);\n            return WebEncoders.Base64UrlEncode(bytes);\n        }\n\n        private static string? TryGetReturnUrlFromState(string state)\n        {\n            try\n            {\n                var bytes = WebEncoders.Base64UrlDecode(state);\n                var payload = System.Text.Encoding.UTF8.GetString(bytes);\n                var parts = payload.Split('|', 4, StringSplitOptions.None);\n                if (parts.Length == 4)\n                {\n                    var url = parts[3];\n                    return string.IsNullOrWhiteSpace(url) ? null : url;\n                }\n            }\n            catch { }\n            return null;\n        }\n\n        private async Task SubscribeWabaAsync(string wabaId, string accessToken, CancellationToken ct)\n        {\n            var graphBase = _oauthOpts.Value.GraphBaseUrl?.TrimEnd('/') ?? \"https://graph.facebook.com\";\n            var graphVer = _oauthOpts.Value.GraphApiVersion?.Trim('/') ?? \"v20.0\";\n            var url = $\"{graphBase}/{graphVer}/{wabaId}/subscribed_apps\";\n\n            using var http = new HttpClient();\n            http.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(\"Bearer\", accessToken);\n\n            using var res = await http.PostAsync(url, content: null, ct);\n\n            if (!res.IsSuccessStatusCode)\n            {\n                var body = await res.Content.ReadAsStringAsync(ct);\n                throw new InvalidOperationException($\"WABA subscribe failed ({(int)res.StatusCode}). Body: {Truncate(body)}\");\n            }\n        }\n\n        private async Task<string?> TryGetWabaFromDebugTokenAsync(\n            string graphBase,\n            string inputToken,\n            string appId,\n            string appSecret,\n            CancellationToken ct)\n        {\n            try\n            {\n                var appToken = $\"{appId}|{appSecret}\";\n                var url = $\"{graphBase.TrimEnd('/')}/debug_token\" +\n                          $\"?input_token={Uri.EscapeDataString(inputToken)}\" +\n                          $\"&access_token={Uri.EscapeDataString(appToken)}\";\n\n                using var http = new HttpClient();\n                var json = await http.GetStringAsync(url, ct);\n\n                _log.LogDebug(\"ESU debug_token raw={Body}\", Truncate(json));\n\n                using var doc = JsonDocument.Parse(json);\n                var root = doc.RootElement;\n                if (!root.TryGetProperty(\"data\", out var data)) return null;\n\n                if (data.TryGetProperty(\"granular_scopes\", out var scopes) &&\n                    scopes.ValueKind == JsonValueKind.Array)\n                {\n                    foreach (var s in scopes.EnumerateArray())\n                    {\n                        var scope = s.TryGetProperty(\"scope\", out var se) ? se.GetString() : null;\n                        if (string.IsNullOrWhiteSpace(scope)) continue;\n\n                        if (scope.StartsWith(\"whatsapp_business_\", StringComparison.OrdinalIgnoreCase))\n                        {\n                            if (s.TryGetProperty(\"target_ids\", out var targets) &&\n                                targets.ValueKind == JsonValueKind.Array)\n                            {\n                                foreach (var t in targets.EnumerateArray())\n                                {\n                                    var id = t.GetString();\n                                    if (!string.IsNullOrWhiteSpace(id))\n                                        return id;\n                                }\n                            }\n                        }\n                    }\n                }\n\n                return null;\n            }\n            catch (Exception ex)\n            {\n                _log.LogWarning(ex, \"ESU debug_token WABA discovery failed.\");\n                return null;\n            }\n        }\n\n        private async Task<string?> TryGetWabaFromMeAccountsAsync(\n            string apiBase,\n            string accessToken,\n            CancellationToken ct)\n        {\n            var url = $\"{apiBase}/me/whatsapp_business_accounts?fields=id,name\";\n            using var http = new HttpClient();\n            http.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(\"Bearer\", accessToken);\n\n            var res = await http.GetAsync(url, ct);\n            var body = await res.Content.ReadAsStringAsync(ct);\n\n            _log.LogDebug(\"ESU me/whatsapp_business_accounts: {Status} {Body}\",\n                (int)res.StatusCode,\n                Truncate(body));\n\n            if (!res.IsSuccessStatusCode) return null;\n\n            using var doc = JsonDocument.Parse(body);\n            if (!doc.RootElement.TryGetProperty(\"data\", out var arr) || arr.ValueKind != JsonValueKind.Array)\n                return null;\n\n            foreach (var it in arr.EnumerateArray())\n            {\n                if (it.TryGetProperty(\"id\", out var idp))\n                {\n                    var id = idp.GetString();\n                    if (!string.IsNullOrWhiteSpace(id))\n                        return id;\n                }\n            }\n\n            return null;\n        }\n\n        private async Task<string?> TryGetWabaFromBusinessesAsync(\n            string apiBase,\n            string accessToken,\n            CancellationToken ct)\n        {\n            var url =\n                $\"{apiBase}/me/businesses?fields=owned_whatsapp_business_accounts{{id}},client_whatsapp_business_accounts{{id}}\";\n\n            using var http = new HttpClient();\n            http.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(\"Bearer\", accessToken);\n\n            var res = await http.GetAsync(url, ct);\n            var body = await res.Content.ReadAsStringAsync(ct);\n\n            _log.LogDebug(\"ESU me/businesses: {Status} {Body}\",\n                (int)res.StatusCode,\n                Truncate(body));\n\n            if (!res.IsSuccessStatusCode) return null;\n\n            using var doc = JsonDocument.Parse(body);\n            var root = doc.RootElement;\n\n            if (!root.TryGetProperty(\"data\", out var arr) || arr.ValueKind != JsonValueKind.Array)\n                return null;\n\n            foreach (var biz in arr.EnumerateArray())\n            {\n                if (TryPickWabaId(biz, \"owned_whatsapp_business_accounts\", out var ow) &&\n                    !string.IsNullOrWhiteSpace(ow))\n                    return ow;\n\n                if (TryPickWabaId(biz, \"client_whatsapp_business_accounts\", out var cl) &&\n                    !string.IsNullOrWhiteSpace(cl))\n                    return cl;\n            }\n\n            return null;\n        }\n\n        private static string Truncate(string? s, int max = 600)\n        {\n            if (string.IsNullOrWhiteSpace(s)) return string.Empty;\n            s = s.Replace(\"\\r\", \" \").Replace(\"\\n\", \" \");\n            return s.Length <= max ? s : s[..max] + \"...\";\n        }\n\n        private static bool TryPickWabaId(JsonElement biz, string prop, out string? wabaId)\n        {\n            wabaId = null;\n            if (!biz.TryGetProperty(prop, out var block)) return false;\n            if (!block.TryGetProperty(\"data\", out var arr) || arr.ValueKind != JsonValueKind.Array) return false;\n\n            foreach (var it in arr.EnumerateArray())\n            {\n                if (it.TryGetProperty(\"id\", out var idp))\n                {\n                    wabaId = idp.GetString();\n                    if (!string.IsNullOrWhiteSpace(wabaId))\n                        return true;\n                }\n            }\n\n            return false;\n        }\n\n        private static string SanitizeReturnUrlOrDefault(string? returnUrl, string fallback)\n        {\n            if (string.IsNullOrWhiteSpace(returnUrl))\n                return fallback;\n\n            returnUrl = returnUrl.Trim();\n\n            if (!returnUrl.StartsWith(\"/\", StringComparison.Ordinal) ||\n                returnUrl.StartsWith(\"//\", StringComparison.Ordinal) ||\n                returnUrl.Contains(\"\\\\\", StringComparison.Ordinal))\n            {\n                return fallback;\n            }\n\n            return returnUrl;\n        }\n\n        private static bool IsAllDigits(string value)\n        {\n            foreach (var c in value)\n            {\n                if (c < '0' || c > '9') return false;\n            }\n            return true;\n        }\n\n        private static string? GetPhoneNumberId(object phone)\n        {\n            var type = phone.GetType();\n\n            var prop =\n                type.GetProperty(\"ProviderPhoneNumberId\")\n                ?? type.GetProperty(\"PhoneNumberId\")\n                ?? type.GetProperty(\"MetaPhoneNumberId\")\n                ?? type.GetProperty(\"ProviderId\");\n\n            return prop?.GetValue(phone)?.ToString();\n        }\n\n        private static bool TryExtractCounts(object? result, out int added, out int updated, out int total)\n        {\n            added = updated = total = 0;\n            if (result is null) return false;\n\n            var t = result.GetType();\n\n            var pAdded = t.GetProperty(\"Added\");\n            var pUpdated = t.GetProperty(\"Updated\");\n            var pTotal = t.GetProperty(\"Total\");\n\n            if (pAdded is not null && pUpdated is not null && pTotal is not null)\n            {\n                try\n                {\n                    added = Convert.ToInt32(pAdded.GetValue(result));\n                    updated = Convert.ToInt32(pUpdated.GetValue(result));\n                    total = Convert.ToInt32(pTotal.GetValue(result));\n                    return true;\n                }\n                catch { }\n            }\n\n            var f1 = t.GetField(\"Item1\");\n            var f2 = t.GetField(\"Item2\");\n            var f3 = t.GetField(\"Item3\");\n\n            if (f1 is not null && f2 is not null && f3 is not null)\n            {\n                try\n                {\n                    added = Convert.ToInt32(f1.GetValue(result));\n                    updated = Convert.ToInt32(f2.GetValue(result));\n                    total = Convert.ToInt32(f3.GetValue(result));\n                    return true;\n                }\n                catch { }\n            }\n\n            return false;\n        }\n\n        private static bool ReadBool(object obj, string propName)\n        {\n            try\n            {\n                var p = obj.GetType().GetProperty(propName);\n                if (p is null) return false;\n                var val = p.GetValue(obj);\n                return val is bool b && b;\n            }\n            catch\n            {\n                return false;\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Services/FacebookTokenService.cs",
      "sha256": "5b18d40ad124b1d99c057272bfcbb9b6290b68e45fddc41db8b9ae2e80ac9871",
      "language": "csharp",
      "size": 4146,
      "content": "using System;\nusing System.Collections.Concurrent;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Caching.Memory;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.ESU.Facebook.Abstractions;\nusing xbytechat.api.Features.ESU.Facebook.Contracts;\nusing xbytechat.api.Infrastructure;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Services\n{\n    /// <summary>\n    /// Centralized reader for Facebook tokens stored in EsuTokens.\n    /// Includes in-memory caching and per-key locking to avoid stampedes.\n    /// </summary>\n    public sealed class FacebookTokenService : IFacebookTokenService\n    {\n        private const string Provider = \"META_CLOUD\";\n\n        private readonly AppDbContext _db;\n        private readonly IMemoryCache _cache;\n        private readonly ILogger<FacebookTokenService> _log;\n\n        private static readonly ConcurrentDictionary<string, SemaphoreSlim> _locks = new();\n\n        public FacebookTokenService(AppDbContext db, IMemoryCache cache, ILogger<FacebookTokenService> log)\n        {\n            _db = db;\n            _cache = cache;\n            _log = log;\n        }\n\n        private static string CacheKey(Guid biz) => $\"esu:fbtoken:{biz:N}\";\n        private static SemaphoreSlim GetLock(string key) => _locks.GetOrAdd(key, _ => new SemaphoreSlim(1, 1));\n\n        // --- existing methods (TryGetValidAsync, GetRequiredAsync, InvalidateAsync) stay as-is ---\n\n        public async Task<FacebookStoredToken?> TryGetValidAsync(Guid businessId, CancellationToken ct = default)\n        {\n            var key = CacheKey(businessId);\n\n            if (_cache.TryGetValue<FacebookStoredToken?>(key, out var cached) &&\n                cached is not null && !cached.IsExpired() && !cached.WillExpireSoon())\n                return cached;\n\n            var gate = GetLock(key);\n            await gate.WaitAsync(ct).ConfigureAwait(false);\n            try\n            {\n                if (_cache.TryGetValue<FacebookStoredToken?>(key, out cached) &&\n                    cached is not null && !cached.IsExpired() && !cached.WillExpireSoon())\n                    return cached;\n\n                var row = await _db.EsuTokens\n                    .AsNoTracking()\n                    .SingleOrDefaultAsync(x => x.BusinessId == businessId && x.Provider == Provider && !x.IsRevoked, ct)\n                    .ConfigureAwait(false);\n\n                if (row is null || string.IsNullOrWhiteSpace(row.AccessToken)) return null;\n\n                var token = new FacebookStoredToken { AccessToken = row.AccessToken!, ExpiresAtUtc = row.ExpiresAtUtc };\n                if (token.IsExpired() || token.WillExpireSoon()) return null;\n\n                var ttl = token.ExpiresAtUtc.HasValue\n                    ? TimeSpan.FromMinutes(Math.Min(5, Math.Max(1, (token.ExpiresAtUtc.Value - DateTime.UtcNow).TotalMinutes - 1)))\n                    : TimeSpan.FromMinutes(5);\n\n                _cache.Set(key, token, new MemoryCacheEntryOptions { AbsoluteExpirationRelativeToNow = ttl, Size = 1 });\n                return token;\n            }\n            finally { gate.Release(); }\n        }\n\n        public async Task<FacebookStoredToken> GetRequiredAsync(Guid businessId, CancellationToken ct = default)\n        {\n            var token = await TryGetValidAsync(businessId, ct).ConfigureAwait(false);\n            if (token is null) throw new InvalidOperationException(\"Facebook token missing or expired. Please reconnect ESU.\");\n            return token;\n        }\n\n        // ‚úÖ NEW: implement the interface member that the compiler is asking for\n        public async Task<string?> GetAccessTokenAsync(Guid businessId, CancellationToken ct = default)\n        {\n            var token = await TryGetValidAsync(businessId, ct).ConfigureAwait(false);\n            return token?.AccessToken;\n        }\n\n        // keep invalidate async so callers can await it consistently\n        public Task InvalidateAsync(Guid businessId, CancellationToken ct = default)\n        {\n            _cache.Remove(CacheKey(businessId));\n            return Task.CompletedTask;\n        }\n    }\n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Services/IFacebookEsuService.cs",
      "sha256": "807ca414bfe70422d6d131a2c3dffc2ddae4e46830600cf97c7082203efc653d",
      "language": "csharp",
      "size": 728,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.ESU.Facebook.DTOs;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Services\n{\n    public interface IFacebookEsuService\n    {\n        Task<FacebookEsuStartResponseDto> StartAsync(Guid businessId, string? returnUrl, CancellationToken ct = default);\n        Task<FacebookEsuCallbackResponseDto> HandleCallbackAsync(string code, string state, CancellationToken ct = default);\n        Task DisconnectAsync(Guid businessId, CancellationToken ct = default);\n        Task FullDeleteAsync(Guid businessId, CancellationToken ct = default);\n\n        Task RegisterPhoneNumberAsync(Guid businessId, string pin, CancellationToken ct);\n\n\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Shared/EsuFlagCacheOptions.cs",
      "sha256": "2837ccf8cd261897691aa7e4d329811449724b84e176977ed3393062c0394605",
      "language": "csharp",
      "size": 536,
      "content": "#nullable enable\nnamespace xbytechat.api.Features.ESU.Shared\n{\n    /// <summary>Cache knobs for ESU flag reads.</summary>\n    public sealed class EsuFlagCacheOptions\n    {\n        /// <summary>Default TTL for positive cache hits (seconds). Keep short; flags change rarely but we want quick propagation.</summary>\n        public int TtlSeconds { get; set; } = 30;\n\n        /// <summary>TTL for negative lookups (misses). Prevents hammering DB when a flag is absent.</summary>\n        public int MissTtlSeconds { get; set; } = 5;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Shared/EsuFlagStore.cs",
      "sha256": "7dfa5cdbfaf4138039fc02aad6f584c3715c9ddd4cc0c5ac6b9c6d3d593b0bf7",
      "language": "csharp",
      "size": 5072,
      "content": "#nullable enable\nusing System;\nusing System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Caching.Memory;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing xbytechat.api.Features.ESU.Facebook.Models; // IntegrationFlags (plural)\nusing xbytechat.api.Infrastructure;               // AppDbContext\n\nnamespace xbytechat.api.Features.ESU.Shared\n{\n\n    public sealed class EsuFlagStore : IEsuFlagStore\n    {\n        private readonly AppDbContext _db;\n        private readonly ILogger<EsuFlagStore> _log;\n        private readonly IMemoryCache _cache;\n        private readonly EsuFlagCacheOptions _cacheOpts;\n\n        public EsuFlagStore(\n            AppDbContext db,\n            ILogger<EsuFlagStore> log,\n            IMemoryCache cache,\n            IOptions<EsuFlagCacheOptions> cacheOpts)\n        {\n            _db = db;\n            _log = log;\n            _cache = cache;\n            _cacheOpts = cacheOpts.Value;\n        }\n\n        // ---- cache helpers ---------------------------------------------------\n        private static string CacheKey(Guid businessId) => $\"esu:intflags:{businessId:N}\";\n        private void Invalidate(Guid businessId) => _cache.Remove(CacheKey(businessId));\n\n        private async Task<IntegrationFlags?> GetRowAsync(Guid businessId, CancellationToken ct)\n        {\n            if (_cache.TryGetValue<IntegrationFlags?>(CacheKey(businessId), out var cached))\n                return cached;\n\n            var row = await _db.IntegrationFlags\n                .AsNoTracking()\n                .SingleOrDefaultAsync(x => x.BusinessId == businessId, ct)\n                .ConfigureAwait(false);\n\n            var ttl = row is null\n                ? TimeSpan.FromSeconds(_cacheOpts.MissTtlSeconds)\n                : TimeSpan.FromSeconds(_cacheOpts.TtlSeconds);\n\n            _cache.Set(CacheKey(businessId), row, ttl);\n            return row;\n        }\n\n        // ---- legacy-shaped APIs (kept for back-compat) ----------------------\n\n        public async Task<IntegrationFlags?> GetAsync(Guid businessId, string key, CancellationToken ct = default)\n            => await GetRowAsync(businessId, ct).ConfigureAwait(false);\n\n        public async Task<string?> GetValueAsync(Guid businessId, string key, CancellationToken ct = default)\n        {\n            var row = await GetRowAsync(businessId, ct).ConfigureAwait(false);\n            if (row is null) return null;\n\n            if (string.Equals(key, \"FACEBOOK_ESU_COMPLETED\", StringComparison.OrdinalIgnoreCase))\n                return row.FacebookEsuCompleted ? \"true\" : \"false\";\n\n            return null; // unknown legacy key in the explicit-column model\n        }\n\n\n        public async Task UpsertAsync(\n      Guid businessId,\n      string key,\n      string value,\n      string? jsonPayload = null,   // kept for API compatibility; ignored for flags\n      CancellationToken ct = default)\n        {\n            // Load/create the per-business row\n            var row = await _db.IntegrationFlags\n                .AsTracking()\n                .FirstOrDefaultAsync(x => x.BusinessId == businessId, ct);\n\n            if (row == null)\n            {\n                row = new IntegrationFlags\n                {\n                    BusinessId = businessId,\n                    CreatedAtUtc = DateTime.UtcNow\n                };\n                _db.IntegrationFlags.Add(row);\n            }\n\n            // üö´ No secret handling here. Tokens live in EsuTokens only.\n\n            // Mark ESU completed when we get the canonical key/value\n            // (do not flip it back to false if someone passes another value later)\n            if (string.Equals(key, \"facebook.esu\", StringComparison.OrdinalIgnoreCase) &&\n                string.Equals(value, \"completed\", StringComparison.OrdinalIgnoreCase))\n            {\n                row.FacebookEsuCompleted = true;\n            }\n\n            // Touch timestamp; interceptors may also update this\n            row.UpdatedAtUtc = DateTime.UtcNow;\n\n            await _db.SaveChangesAsync(ct).ConfigureAwait(false);\n\n            // Clear any in-process caches (IMemoryCache Remove is sync)\n            Invalidate(businessId);\n        }\n\n       \n\n        public async Task<bool> IsFacebookEsuCompletedAsync(Guid businessId, CancellationToken ct = default)\n        {\n            var row = await GetRowAsync(businessId, ct).ConfigureAwait(false);\n            return row?.FacebookEsuCompleted == true;\n        }\n\n        // FILE: Features/ESU/Facebook/Services/EsuFlagStore.cs\n\n        public async Task DeleteAsync(Guid businessId, CancellationToken ct = default)\n        {\n            var row = await _db.IntegrationFlags\n                .SingleOrDefaultAsync(x => x.BusinessId == businessId, ct)\n                .ConfigureAwait(false);\n\n            if (row is null)\n                return;\n\n            _db.IntegrationFlags.Remove(row);\n            await _db.SaveChangesAsync(ct).ConfigureAwait(false);\n\n            Invalidate(businessId);\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Shared/EsuOptions.cs",
      "sha256": "daad5788b2778e66de306a92ae3bfcbe0e9f88e2db36e65cf429b713d960678d",
      "language": "csharp",
      "size": 546,
      "content": "namespace xbytechat.api.Features.ESU.Shared\n{\n    public sealed class EsuOptions\n    {\n        public FacebookEsuOptions Facebook { get; set; } = new();\n    }\n\n    public sealed class FacebookEsuOptions\n    {\n        public string AppId { get; set; } = string.Empty;\n        public string RedirectUri { get; set; } = string.Empty;\n        public string Scopes { get; set; } = \"whatsapp_business_management,whatsapp_business_messaging\";\n        public int StateTtlMinutes { get; set; } = 20;\n\n        public string? ConfigId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Shared/IEsuFlagStore.cs",
      "sha256": "99df740f3203b19df93ebb5b4c4263b361e58edd8184a2c7b248798330f617b9",
      "language": "csharp",
      "size": 498,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.ESU.Shared\n{\n    public interface IEsuFlagStore\n    {\n     \n\n        Task<bool> IsFacebookEsuCompletedAsync(\n            Guid businessId,\n            CancellationToken ct = default);\n\n        Task UpsertAsync(Guid businessId, string key, string value, string? jsonPayload = null, CancellationToken ct = default);\n        Task DeleteAsync(Guid businessId, CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Shared/IEsuStateStore.cs",
      "sha256": "6bfa023f2023e81813d00ec67d788ee6a8ebd543a62de6b52eac954afbfc082b",
      "language": "csharp",
      "size": 286,
      "content": "using System;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.ESU.Shared\n{\n    public interface IEsuStateStore\n    {\n        Task StoreAsync(string state, Guid businessId, TimeSpan ttl);\n        Task<(bool Found, Guid BusinessId)> TryConsumeAsync(string state);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Shared/Infrastructure/UpdatedAtUtcInterceptor.cs",
      "sha256": "bdaaa5ba5896c90fa6e316bd63ac4d7fe00a6b0d2897f430fc0e250d91ebe2c3",
      "language": "csharp",
      "size": 1737,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Microsoft.EntityFrameworkCore.Diagnostics;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.ESU.Facebook.Models; // IntegrationFlags\n\nnamespace xbytechat.api.Features.ESU.Shared.Infrastructure\n{\n    public sealed class UpdatedAtUtcInterceptor : SaveChangesInterceptor\n    {\n        private static readonly Type[] _trackedTypes = new[]\n        {\n            typeof(IntegrationFlags),\n            // add other entities if you want auto-bump later\n        };\n\n        private static bool ShouldTrack(object entity)\n            => _trackedTypes.Contains(entity.GetType());\n\n        public override InterceptionResult<int> SavingChanges(\n            DbContextEventData eventData, InterceptionResult<int> result)\n        {\n            Touch(eventData.Context);\n            return base.SavingChanges(eventData, result);\n        }\n\n        public override ValueTask<InterceptionResult<int>> SavingChangesAsync(\n            DbContextEventData eventData, InterceptionResult<int> result, CancellationToken cancellationToken = default)\n        {\n            Touch(eventData.Context);\n            return base.SavingChangesAsync(eventData, result, cancellationToken);\n        }\n\n        private static void Touch(DbContext? ctx)\n        {\n            if (ctx == null) return;\n\n            var now = DateTime.UtcNow;\n\n            foreach (var entry in ctx.ChangeTracker.Entries())\n            {\n                if (entry.State == EntityState.Modified && ShouldTrack(entry.Entity))\n                {\n                    var prop = entry.Property(\"UpdatedAtUtc\");\n                    if (prop != null) prop.CurrentValue = now;\n                }\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Shared/MemoryEsuStateStore.cs",
      "sha256": "dde73ec812d607f3d5d5443041bfb0f703210131f014abae66678c931667f677",
      "language": "csharp",
      "size": 885,
      "content": "using System;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Caching.Memory;\n\nnamespace xbytechat.api.Features.ESU.Shared\n{\n    internal sealed class MemoryEsuStateStore : IEsuStateStore\n    {\n        private readonly IMemoryCache _cache;\n        public MemoryEsuStateStore(IMemoryCache cache) => _cache = cache;\n\n        public Task StoreAsync(string state, Guid businessId, TimeSpan ttl)\n        {\n            _cache.Set(state, businessId, ttl);\n            return Task.CompletedTask;\n        }\n\n        public Task<(bool Found, Guid BusinessId)> TryConsumeAsync(string state)\n        {\n            if (_cache.TryGetValue<Guid>(state, out var businessId))\n            {\n                _cache.Remove(state); // one-time use\n                return Task.FromResult((true, businessId));\n            }\n            return Task.FromResult((false, Guid.Empty));\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Shared/UiOptions.cs",
      "sha256": "e3c5bde4a1db7df8037e8ab7daf415886c4cd94c606ddc3a26fa58f4af6b0edb",
      "language": "csharp",
      "size": 162,
      "content": "#nullable enable\nnamespace xbytechat.api.Features.ESU.Shared\n{\n    public sealed class UiOptions\n    {\n        public string? PublicBaseUrl { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/FlowAnalytics/Controllers/FlowAnalyticsController.cs",
      "sha256": "18a260235767524c70c33a6a49f8929060e94415ee98ff743590d207242020e3",
      "language": "csharp",
      "size": 2196,
      "content": "using Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.FlowAnalytics.Services;\n\nnamespace xbytechat.api.Features.FlowAnalytics.Controllers\n{\n    [ApiController]\n    [Route(\"api/flow-analytics\")]\n    public class FlowAnalyticsController : ControllerBase\n    {\n        private readonly IFlowAnalyticsService _analyticsService;\n\n        public FlowAnalyticsController(IFlowAnalyticsService analyticsService)\n        {\n            _analyticsService = analyticsService;\n        }\n\n        // ‚úÖ GET /api/flow-analytics/summary\n        [HttpGet(\"summary\")]\n        [Authorize]\n        public async Task<IActionResult> GetSummary()\n        {\n            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n\n            if (!Guid.TryParse(businessIdClaim, out var businessId))\n                return BadRequest(\"‚ùå Invalid business ID\");\n\n            var result = await _analyticsService.GetAnalyticsSummaryAsync(businessId);\n            return Ok(result);\n        }\n\n        // ‚úÖ GET /api/flow-analytics/most-triggered-steps\n        [HttpGet(\"most-triggered-steps\")]\n        [Authorize]\n        public async Task<IActionResult> GetMostTriggeredSteps()\n        {\n            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n\n            if (!Guid.TryParse(businessIdClaim, out var businessId))\n                return BadRequest(\"‚ùå Invalid business ID\");\n\n            var data = await _analyticsService.GetMostTriggeredStepsAsync(businessId);\n            return Ok(data);\n        }\n\n        // ‚úÖ GET /api/flow-analytics/step-journey-breakdown?startDate=...&endDate=...\n        [HttpGet(\"step-journey-breakdown\")]\n        [Authorize]\n        public async Task<IActionResult> GetStepJourneyBreakdown([FromQuery] DateTime? startDate, [FromQuery] DateTime? endDate)\n        {\n            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n\n            if (!Guid.TryParse(businessIdClaim, out var businessId))\n                return BadRequest(\"‚ùå Invalid business ID\");\n\n            var data = await _analyticsService.GetStepJourneyBreakdownAsync(businessId, startDate, endDate);\n            return Ok(data);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/FlowAnalytics/DTOs/FlowAnalyticsStepJourneyDto.cs",
      "sha256": "25c17b6d295eb4faf667e982e2878b32a18af8a759791962286f17eec9163f6f",
      "language": "csharp",
      "size": 889,
      "content": "namespace xbytechat.api.Features.FlowAnalytics.DTOs\n{\n    public class FlowAnalyticsStepJourneyDto\n    {\n        public Guid StepId { get; set; }\n\n        public string TemplateName { get; set; } = string.Empty;\n\n        public int TotalReached { get; set; }\n\n        public int ClickedNext { get; set; }\n\n        public Guid? NextStepId { get; set; }\n\n        // ‚úÖ Auto-calculated: number of users who dropped off at this step\n        public int DropOff => TotalReached - ClickedNext;\n\n        // ‚úÖ Auto-calculated: percentage of users who clicked \"next\"\n        public double ConversionRate =>\n            TotalReached == 0 ? 0 : Math.Round((double)ClickedNext / TotalReached * 100, 2);\n\n        // ‚úÖ Optional: percentage of users who dropped off\n        public double DropOffRate =>\n            TotalReached == 0 ? 0 : Math.Round((double)DropOff / TotalReached * 100, 2);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/FlowAnalytics/DTOs/FlowAnalyticsSummaryDto.cs",
      "sha256": "5298f0c920ce53f68b8113de057d804750e1a3afd39d3a24e965ae120275118a",
      "language": "csharp",
      "size": 369,
      "content": "namespace xbytechat.api.Features.FlowAnalytics.DTOs\n{\n    public class FlowAnalyticsSummaryDto\n    {\n        public int TotalExecutions { get; set; }\n        public int UniqueContacts { get; set; }\n        public string TopStepTriggered { get; set; } = \"N/A\";\n        public int TopStepCount { get; set; }\n        public DateTime? LastExecutedAt { get; set; }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/FlowAnalytics/DTOs/FlowStepAnalyticsDto.cs",
      "sha256": "538b4b71cb5a0a82ee36ec0147c0014d4f6570b635eb2ce711cb7e8de3119a09",
      "language": "csharp",
      "size": 478,
      "content": "namespace xbytechat.api.Features.FlowAnalytics.DTOs\n{\n    public class FlowStepAnalyticsDto\n    {\n        public Guid StepId { get; set; }\n        public string TemplateName { get; set; } = string.Empty;\n        public int TotalReached { get; set; }\n        public int ClickedNext { get; set; }\n        public int DropOff => TotalReached - ClickedNext;\n        public Guid? NextStepId { get; set; }\n        public DateTime ExecutedAtUtc { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/FlowAnalytics/DTOs/MostTriggeredStepDto.cs",
      "sha256": "18dc2f8497fae7508358e8556503db073d057061d1892fed2882208fa6653588",
      "language": "csharp",
      "size": 310,
      "content": "namespace xbytechat.api.Features.FlowAnalytics.DTOs\n{\n    public class MostTriggeredStepDto\n    {\n        public Guid StepId { get; set; }\n        public string StepName { get; set; } = string.Empty;\n        public int TriggerCount { get; set; }\n        public DateTime? LastTriggeredAt { get; set; }\n    }\n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/FlowAnalytics/Services/FlowAnalyticsService.cs",
      "sha256": "b832767451b9f0161f931082a45a698407bf4cfaa6c5077edef8a2f6d30385cb",
      "language": "csharp",
      "size": 5128,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\nusing xbytechat.api.Features.FlowAnalytics.DTOs;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.FlowAnalytics.Services\n{\n    public class FlowAnalyticsService : IFlowAnalyticsService\n    {\n        private readonly AppDbContext _context;\n\n        public FlowAnalyticsService(AppDbContext context)\n        {\n            _context = context;\n        }\n\n        // ‚úÖ Summary cards (executions, unique contacts, top step)\n        public async Task<FlowAnalyticsSummaryDto> GetAnalyticsSummaryAsync(Guid businessId)\n        {\n            try\n            {\n                Log.Information(\"üìä Generating Flow Analytics Summary for BusinessId: {BusinessId}\", businessId);\n\n                var recentExecutions = await _context.FlowExecutionLogs\n                    .Where(e => e.BusinessId == businessId)\n                    .ToListAsync();\n\n                var totalExecutions = recentExecutions.Count;\n                var uniqueContacts = recentExecutions.Select(e => e.ContactPhone).Distinct().Count();\n                var mostTriggeredStep = recentExecutions\n                    .GroupBy(e => e.StepName)\n                    .OrderByDescending(g => g.Count())\n                    .Select(g => new { Step = g.Key, Count = g.Count() })\n                    .FirstOrDefault();\n\n                return new FlowAnalyticsSummaryDto\n                {\n                    TotalExecutions = totalExecutions,\n                    UniqueContacts = uniqueContacts,\n                    TopStepTriggered = mostTriggeredStep?.Step ?? \"N/A\",\n                    TopStepCount = mostTriggeredStep?.Count ?? 0,\n                    LastExecutedAt = recentExecutions\n                        .OrderByDescending(e => e.ExecutedAt)\n                        .FirstOrDefault()?.ExecutedAt\n                };\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed to generate flow analytics summary\");\n                return new FlowAnalyticsSummaryDto();\n            }\n        }\n\n        // ‚úÖ Top triggered steps leaderboard\n        public async Task<List<MostTriggeredStepDto>> GetMostTriggeredStepsAsync(Guid businessId)\n        {\n            return await _context.FlowExecutionLogs\n                .Where(e => e.BusinessId == businessId)\n                .GroupBy(e => new { e.StepId, e.StepName })\n                .Select(g => new MostTriggeredStepDto\n                {\n                    StepId = g.Key.StepId,\n                    StepName = g.Key.StepName,\n                    TriggerCount = g.Count(),\n                    LastTriggeredAt = g.Max(e => e.ExecutedAt)\n                })\n                .OrderByDescending(x => x.TriggerCount)\n                .Take(5)\n                .ToListAsync();\n        }\n\n        // ‚úÖ Step-by-step journey breakdown (with date filter)\n        public async Task<List<FlowAnalyticsStepJourneyDto>> GetStepJourneyBreakdownAsync(Guid businessId, DateTime? startDate, DateTime? endDate)\n        {\n            var query = _context.FlowExecutionLogs\n                .Where(e => e.BusinessId == businessId);\n\n            if (startDate.HasValue)\n                query = query.Where(e => e.ExecutedAt >= startDate.Value.Date);\n\n            if (endDate.HasValue)\n                query = query.Where(e => e.ExecutedAt <= endDate.Value.Date.AddDays(1).AddTicks(-1));\n\n            var logs = await query.ToListAsync();\n\n            // Group by StepId\n            var grouped = logs\n                .GroupBy(e => new { e.StepId, e.TemplateName, e.TriggeredByButton, e.FlowId })\n                .Select(g => new\n                {\n                    StepId = g.Key.StepId,\n                    TemplateName = g.Key.TemplateName,\n                    TotalReached = g.Count(),\n                    ClickedNext = logs.Count(x =>\n                        x.TriggeredByButton != null &&\n                        x.FlowId == g.Key.FlowId &&\n                        x.StepId != g.Key.StepId &&\n                        x.TriggeredByButton == g.Key.TriggeredByButton\n                    ),\n                    FlowId = g.Key.FlowId,\n                    TriggeredByButton = g.Key.TriggeredByButton\n                })\n                .ToList();\n\n            // Build final breakdown\n            var breakdown = grouped.Select(g => new FlowAnalyticsStepJourneyDto\n            {\n                StepId = g.StepId,\n                TemplateName = g.TemplateName,\n                TotalReached = g.TotalReached,\n                ClickedNext = g.ClickedNext,\n              //  DropOff = g.TotalReached - g.ClickedNext,\n                NextStepId = _context.FlowButtonLinks\n                    .Where(bl =>\n                        bl.CTAFlowStepId == g.StepId &&\n                        bl.ButtonText == g.TriggeredByButton)\n                    .Select(bl => bl.NextStepId)\n                    .FirstOrDefault()\n            }).ToList();\n\n            return breakdown;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/FlowAnalytics/Services/IFlowAnalyticsService.cs",
      "sha256": "65a623c78188e9581eee608e1e5e53404f8431fb317139d50a4caadd86b074ae",
      "language": "csharp",
      "size": 512,
      "content": "using System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.FlowAnalytics.DTOs;\n\nnamespace xbytechat.api.Features.FlowAnalytics.Services\n{\n    public interface IFlowAnalyticsService\n    {\n        Task<FlowAnalyticsSummaryDto> GetAnalyticsSummaryAsync(Guid businessId);\n        Task<List<MostTriggeredStepDto>> GetMostTriggeredStepsAsync(Guid businessId);\n        Task<List<FlowAnalyticsStepJourneyDto>> GetStepJourneyBreakdownAsync(Guid businessId, DateTime? startDate, DateTime? endDate);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Controllers/InboxController.cs",
      "sha256": "3d0e927289537b66319358696495d025ff3f9a5f6c17877f661a19cd1dec1f3e",
      "language": "csharp",
      "size": 9876,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Inbox.DTOs;\nusing xbytechat.api.Features.Inbox.Services;\nusing xbytechat.api.Helpers;\nusing Microsoft.AspNetCore.Authorization;\nusing xbytechat.api.Shared;\nusing Microsoft.AspNetCore.SignalR;\nusing xbytechat.api.Features.Inbox.Hubs;\n\nnamespace xbytechat.api.Features.Inbox.Controllers\n{\n    [ApiController]\n    [Route(\"api/inbox\")]\n    public class InboxController : ControllerBase\n    {\n        private readonly IInboxService _inboxService;\n        private readonly IHubContext<InboxHub> _hubContext; // ‚úÖ for SignalR push\n        private readonly IUnreadCountService _unreadCountService;\n\n        public InboxController(\n            IInboxService inboxService,\n            IHubContext<InboxHub> hubContext,\n            IUnreadCountService unreadCountService)\n        {\n            _inboxService = inboxService;\n            _hubContext = hubContext;\n            _unreadCountService = unreadCountService;\n        }\n\n        /// <summary>\n        /// Send a new message from UI or system.\n        /// </summary>\n        [HttpPost(\"send\")]\n        public async Task<IActionResult> SendMessage([FromBody] InboxMessageDto dto)\n        {\n            if (dto == null || string.IsNullOrWhiteSpace(dto.MessageBody))\n                return BadRequest(\"Message content is required.\");\n\n            var result = await _inboxService.SaveOutgoingMessageAsync(dto);\n            return Ok(result);\n        }\n\n        /// <summary>\n        /// Receive a message from external source (e.g., WhatsApp webhook).\n        /// </summary>\n        [HttpPost(\"receive\")]\n        public async Task<IActionResult> ReceiveMessage([FromBody] InboxMessageDto dto)\n        {\n            if (dto == null || string.IsNullOrWhiteSpace(dto.MessageBody))\n                return BadRequest(\"Incoming message content is required.\");\n\n            // ‚úÖ Ensure IDs are present\n            if (dto.BusinessId == Guid.Empty || dto.ContactId == Guid.Empty)\n                return BadRequest(\"BusinessId and ContactId are required.\");\n\n            // 1) Persist the inbound message\n            var result = await _inboxService.SaveIncomingMessageAsync(dto);\n\n            // 2) Push the real-time message to everyone in this business\n            var groupName = $\"business_{dto.BusinessId}\";\n            await _hubContext.Clients.Group(groupName).SendAsync(\"ReceiveInboxMessage\", new\n            {\n                contactId = dto.ContactId,\n                messageContent = dto.MessageBody,  // ‚úÖ aligned with frontend\n                from = dto.RecipientPhone,\n                status = \"Delivered\",\n                sentAt = DateTime.UtcNow,\n                isIncoming = true\n            });\n\n            // 3) Tell clients to refresh their own unread snapshot (per-user)\n            //    We cannot compute per-user unread here (no userId in webhook context),\n            //    so we emit a refresh signal that clients handle by calling GET /inbox/unread-counts.\n            await _hubContext.Clients.Group(groupName)\n                .SendAsync(\"UnreadCountChanged\", new { refresh = true });\n\n            return Ok(result);\n        }\n\n        /// <summary>\n        /// Fetch message history between agent and customer using business token + contactId.\n        /// </summary>\n        [HttpGet(\"messages\")]\n        public async Task<IActionResult> GetMessagesByContact([FromQuery] Guid contactId)\n        {\n            if (contactId == Guid.Empty)\n                return BadRequest(\"ContactId is required.\");\n\n            var businessId = User.GetBusinessId();\n            var messages = await _inboxService.GetMessagesByContactAsync(businessId, contactId);\n            return Ok(messages);\n        }\n\n        [HttpGet(\"conversation\")]\n        public async Task<IActionResult> GetConversation(\n            [FromQuery] Guid businessId,\n            [FromQuery] string userPhone,\n            [FromQuery] string contactPhone)\n        {\n            if (businessId == Guid.Empty || string.IsNullOrWhiteSpace(userPhone) || string.IsNullOrWhiteSpace(contactPhone))\n                return BadRequest(\"Invalid input.\");\n\n            var messages = await _inboxService.GetConversationAsync(businessId, userPhone, contactPhone);\n            return Ok(messages);\n        }\n\n        [HttpPost(\"mark-read\")]\n        public async Task<IActionResult> MarkMessagesAsRead([FromQuery] Guid contactId)\n        {\n            if (contactId == Guid.Empty)\n                return BadRequest(\"ContactId is required.\");\n\n            var businessId = User.GetBusinessId();\n            await _inboxService.MarkMessagesAsReadAsync(businessId, contactId);\n            return Ok();\n        }\n\n        [HttpGet(\"unread-counts\")]\n        public async Task<IActionResult> GetUnreadCounts()\n        {\n            var businessId = User.GetBusinessId();\n            var userId = User.GetUserId();\n\n            if (businessId == null || userId == null)\n                return Unauthorized();\n\n            var counts = await _unreadCountService.GetUnreadCountsAsync(businessId, userId);\n            return Ok(counts);\n        }\n    }\n}\n\n//using Microsoft.AspNetCore.Mvc;\n//using System;\n//using System.Threading.Tasks;\n//using xbytechat.api.Features.Inbox.DTOs;\n//using xbytechat.api.Features.Inbox.Services;\n//using xbytechat.api.Helpers;\n//using Microsoft.AspNetCore.Authorization;\n//using xbytechat.api.Shared;\n//using Microsoft.AspNetCore.SignalR;\n//using xbytechat.api.Features.Inbox.Hubs;\n//namespace xbytechat.api.Features.Inbox.Controllers\n//{\n//    [ApiController]\n//    [Route(\"api/inbox\")]\n//    public class InboxController : ControllerBase\n//    {\n//        private readonly IInboxService _inboxService;\n//        private readonly IHubContext<InboxHub> _hubContext; // ‚úÖ for SignalR push\n//        private readonly IUnreadCountService _unreadCountService;\n//        public InboxController(IInboxService inboxService, IHubContext<InboxHub> hubContext, IUnreadCountService unreadCountService)\n//        {\n//            _inboxService = inboxService;\n//            _hubContext = hubContext;\n//            _unreadCountService = unreadCountService;   \n//        }\n\n//        /// <summary>\n//        /// Send a new message from UI or system.\n//        /// </summary>\n//        [HttpPost(\"send\")]\n//        public async Task<IActionResult> SendMessage([FromBody] InboxMessageDto dto)\n//        {\n//            if (dto == null || string.IsNullOrWhiteSpace(dto.MessageBody))\n//                return BadRequest(\"Message content is required.\");\n\n//            var result = await _inboxService.SaveOutgoingMessageAsync(dto);\n//            return Ok(result);\n//        }\n\n//        /// <summary>\n//        /// Receive a message from external source (e.g., WhatsApp webhook).\n//        /// </summary>\n//        [HttpPost(\"receive\")]\n//        public async Task<IActionResult> ReceiveMessage([FromBody] InboxMessageDto dto)\n//        {\n//            if (dto == null || string.IsNullOrWhiteSpace(dto.MessageBody))\n//                return BadRequest(\"Incoming message content is required.\");\n\n//            var result = await _inboxService.SaveIncomingMessageAsync(dto);\n\n//            // ‚úÖ Also broadcast in real-time to clients in this business group\n//            var groupName = $\"business_{dto.BusinessId}\";\n//            await _hubContext.Clients.Group(groupName).SendAsync(\"ReceiveInboxMessage\", new\n//            {\n//                contactId = dto.ContactId,\n//                messageContent = dto.MessageBody,  // ‚úÖ aligned with frontend\n//                from = dto.RecipientPhone,\n//                status = \"Delivered\",\n//                sentAt = DateTime.UtcNow,\n//                isIncoming = true\n//            });\n\n//            return Ok(result);\n//        }\n\n//        /// <summary>\n//        /// Fetch message history between agent and customer using business token + contactId.\n//        /// </summary>\n//        [HttpGet(\"messages\")]\n//        public async Task<IActionResult> GetMessagesByContact([FromQuery] Guid contactId)\n//        {\n//            if (contactId == Guid.Empty)\n//                return BadRequest(\"ContactId is required.\");\n\n//            var businessId = User.GetBusinessId();\n//            var messages = await _inboxService.GetMessagesByContactAsync(businessId, contactId);\n//            return Ok(messages);\n//        }\n\n//        [HttpGet(\"conversation\")]\n//        public async Task<IActionResult> GetConversation(\n//            [FromQuery] Guid businessId,\n//            [FromQuery] string userPhone,\n//            [FromQuery] string contactPhone)\n//        {\n//            if (businessId == Guid.Empty || string.IsNullOrWhiteSpace(userPhone) || string.IsNullOrWhiteSpace(contactPhone))\n//                return BadRequest(\"Invalid input.\");\n\n//            var messages = await _inboxService.GetConversationAsync(businessId, userPhone, contactPhone);\n//            return Ok(messages);\n//        }\n\n//        [HttpPost(\"mark-read\")]\n//        public async Task<IActionResult> MarkMessagesAsRead([FromQuery] Guid contactId)\n//        {\n//            if (contactId == Guid.Empty)\n//                return BadRequest(\"ContactId is required.\");\n\n//            var businessId = User.GetBusinessId();\n//            await _inboxService.MarkMessagesAsReadAsync(businessId, contactId);\n//            return Ok();\n//        }\n\n\n//        [HttpGet(\"unread-counts\")]\n//        public async Task<IActionResult> GetUnreadCounts()\n//        {\n//            var businessId = User.GetBusinessId();\n//            var userId = User.GetUserId();\n\n//            if (businessId == null || userId == null)\n//                return Unauthorized();\n\n//            var counts = await _unreadCountService.GetUnreadCountsAsync(\n//                businessId, userId);\n\n//            return Ok(counts);\n//        }\n//    }\n//}\n\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Controllers/QuickRepliesController.cs",
      "sha256": "5033e3cdc140676bd4e47f6ea2fbf18d4cdcfd15e2d7b88c646fd6709a0bdc0d",
      "language": "csharp",
      "size": 7869,
      "content": "using Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Serilog;\nusing xbytechat.api.Features.Inbox.DTOs;\nusing xbytechat.api.Features.Inbox.Services;\nusing xbytechat.api.Helpers; // for User.GetBusinessId(), GetUserId()\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.Inbox.Controllers\n{\n    [Authorize]\n    [ApiController]\n    [Route(\"api/quick-replies\")]\n    public class QuickRepliesController : ControllerBase\n    {\n        private readonly IQuickReplyService _service;\n\n        public QuickRepliesController(IQuickReplyService service) => _service = service;\n\n        [HttpGet]\n        public async Task<IActionResult> GetAll([FromQuery] string? q = null,\n            [FromQuery] string scope = \"all\")\n        {\n            var businessId = User.GetBusinessId();\n            var userId = User.GetUserId();\n\n            // Guid is a value type, so null-checks are useless.\n            // Treat Guid.Empty as \"no id in claims\".\n            if (businessId == Guid.Empty || userId == Guid.Empty)\n                return Unauthorized();\n\n            bool includeBusiness = scope is \"all\" or \"business\";\n            bool includePersonal = scope is \"all\" or \"personal\";\n\n            var list = await _service.GetAllAsync(businessId, userId, q, includeBusiness, includePersonal);\n            return Ok(list);\n        }\n\n        [HttpPost]\n        public async Task<IActionResult> Create([FromBody] QuickReplyCreateDto dto)\n        {\n            var businessId = User.GetBusinessId();\n            var userId = User.GetUserId();\n\n            if (businessId == Guid.Empty || userId == Guid.Empty)\n                return Unauthorized();\n\n            var actor = User.Identity?.Name\n                        ?? (userId != Guid.Empty ? userId.ToString() : \"system\");\n\n            Log.Information(\"Create QuickReply requested by {@Actor}\", actor);\n            var result = await _service.CreateAsync(businessId, userId, actor, dto);\n            return Ok(result);\n        }\n\n        [HttpPut(\"{id:guid}\")]\n        public async Task<IActionResult> Update([FromRoute] Guid id, [FromBody] QuickReplyUpdateDto dto)\n        {\n            var businessId = User.GetBusinessId();\n            var userId = User.GetUserId();\n\n            if (businessId == Guid.Empty || userId == Guid.Empty)\n                return Unauthorized();\n\n            var actor = User.Identity?.Name\n                        ?? (userId != Guid.Empty ? userId.ToString() : \"system\");\n\n            Log.Information(\"Update QuickReply {@QuickReplyId} by {@Actor}\", id, actor);\n            var result = await _service.UpdateAsync(businessId, userId, actor, id, dto);\n            return Ok(result);\n        }\n\n        [HttpPatch(\"{id:guid}/toggle\")]\n        public async Task<IActionResult> Toggle([FromRoute] Guid id, [FromQuery] bool active = true)\n        {\n            var businessId = User.GetBusinessId();\n            var userId = User.GetUserId();\n\n            if (businessId == Guid.Empty || userId == Guid.Empty)\n                return Unauthorized();\n\n            var actor = User.Identity?.Name\n                        ?? (userId != Guid.Empty ? userId.ToString() : \"system\");\n\n            Log.Information(\"Toggle QuickReply {@QuickReplyId} -> {Active} by {@Actor}\", id, active, actor);\n            var result = await _service.ToggleActiveAsync(businessId, userId, actor, id, active);\n            return Ok(result);\n        }\n\n        [HttpDelete(\"{id:guid}\")]\n        public async Task<IActionResult> Delete([FromRoute] Guid id)\n        {\n            var businessId = User.GetBusinessId();\n            var userId = User.GetUserId();\n\n            if (businessId == Guid.Empty || userId == Guid.Empty)\n                return Unauthorized();\n\n            var actor = User.Identity?.Name\n                        ?? (userId != Guid.Empty ? userId.ToString() : \"system\");\n\n            Log.Information(\"Delete QuickReply {@QuickReplyId} by {@Actor}\", id, actor);\n            var result = await _service.DeleteAsync(businessId, userId, actor, id);\n            return Ok(result);\n        }\n    }\n}\n\n\n//using Microsoft.AspNetCore.Authorization;\n//using Microsoft.AspNetCore.Mvc;\n//using Serilog;\n//using xbytechat.api.Features.Inbox.DTOs;\n//using xbytechat.api.Features.Inbox.Services;\n//using xbytechat.api.Helpers; // for User.GetBusinessId(), GetUserId()\n//using xbytechat.api.Shared;\n\n//namespace xbytechat.api.Features.Inbox.Controllers\n//{\n//    [Authorize]\n//    [ApiController]\n//    [Route(\"api/quick-replies\")]\n//    public class QuickRepliesController : ControllerBase\n//    {\n//        private readonly IQuickReplyService _service;\n\n//        public QuickRepliesController(IQuickReplyService service) => _service = service;\n\n//        [HttpGet]\n//        public async Task<IActionResult> GetAll([FromQuery] string? q = null,\n//            [FromQuery] string scope = \"all\")\n//        {\n//            var businessId = User.GetBusinessId();\n//            var userId = User.GetUserId();\n\n//            if (businessId == null || userId == null) return Unauthorized();\n\n//            bool includeBusiness = scope is \"all\" or \"business\";\n//            bool includePersonal = scope is \"all\" or \"personal\";\n\n//            var list = await _service.GetAllAsync(businessId, userId, q, includeBusiness, includePersonal);\n//            return Ok(list);\n//        }\n\n//        [HttpPost]\n//        public async Task<IActionResult> Create([FromBody] QuickReplyCreateDto dto)\n//        {\n//            var businessId = User.GetBusinessId();\n//            var userId = User.GetUserId();\n//            var actor = User.Identity?.Name ?? userId.ToString() ?? \"system\";\n\n//            if (businessId == null || userId == null) return Unauthorized();\n\n//            Log.Information(\"Create QuickReply requested by {@Actor}\", actor);\n//            var result = await _service.CreateAsync(businessId, userId, actor, dto);\n//            return Ok(result);\n//        }\n\n//        [HttpPut(\"{id:guid}\")]\n//        public async Task<IActionResult> Update([FromRoute] Guid id, [FromBody] QuickReplyUpdateDto dto)\n//        {\n//            var businessId = User.GetBusinessId();\n//            var userId = User.GetUserId();\n//            var actor = User.Identity?.Name ?? userId.ToString() ?? \"system\";\n\n//            if (businessId == null || userId == null) return Unauthorized();\n\n//            Log.Information(\"Update QuickReply {@QuickReplyId} by {@Actor}\", id, actor);\n//            var result = await _service.UpdateAsync(businessId, userId, actor, id, dto);\n//            return Ok(result);\n//        }\n\n//        [HttpPatch(\"{id:guid}/toggle\")]\n//        public async Task<IActionResult> Toggle([FromRoute] Guid id, [FromQuery] bool active = true)\n//        {\n//            var businessId = User.GetBusinessId();\n//            var userId = User.GetUserId();\n//            var actor = User.Identity?.Name ?? userId.ToString() ?? \"system\";\n\n//            if (businessId == null || userId == null) return Unauthorized();\n\n//            Log.Information(\"Toggle QuickReply {@QuickReplyId} -> {Active} by {@Actor}\", id, active, actor);\n//            var result = await _service.ToggleActiveAsync(businessId, userId, actor, id, active);\n//            return Ok(result);\n//        }\n\n//        [HttpDelete(\"{id:guid}\")]\n//        public async Task<IActionResult> Delete([FromRoute] Guid id)\n//        {\n//            var businessId = User.GetBusinessId();\n//            var userId = User.GetUserId();\n//            var actor = User.Identity?.Name ?? userId.ToString() ?? \"system\";\n\n//            if (businessId == null || userId == null) return Unauthorized();\n\n//            Log.Information(\"Delete QuickReply {@QuickReplyId} by {@Actor}\", id, actor);\n//            var result = await _service.DeleteAsync(businessId, userId, actor, id);\n//            return Ok(result);\n//        }\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/DTOs/InboxMessageDto.cs",
      "sha256": "bbe5d988e9fd84c5d20f75ed4a389cc2a814c5c84434c9f4a297b84aba02ab7c",
      "language": "csharp",
      "size": 1832,
      "content": "// üìÑ File: Features/Inbox/DTOs/InboxMessageDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.Inbox.DTOs\n{\n    public class InboxMessageDto\n    {\n        public Guid BusinessId { get; set; }\n        public string RecipientPhone { get; set; }\n        public string MessageBody { get; set; }\n        public Guid? ContactId { get; set; }\n        public Guid? CTAFlowStepId { get; set; }\n        public Guid? CTAFlowConfigId { get; set; }\n        public Guid? CampaignId { get; set; }\n        public string? CampaignName { get; set; }       // üÜï To show in chat bubble\n        public string? RenderedBody { get; set; }\n\n        public bool IsIncoming { get; set; }            // üÜï Needed for bubble side\n        public string Status { get; set; }              // üÜï For message ticks\n        public DateTime SentAt { get; set; }            // üÜï For timestamp\n\n        // ‚úÖ NEW: Provider/WAMID idempotency key (Meta \"messages[0].id\")\n        public string? ProviderMessageId { get; set; }\n\n        // ‚úÖ NEW: WhatsApp native media (for inbound/outbound attachments)\n        // Stored as media_id (not public URL) to avoid hosting files ourselves.\n        public string? MediaId { get; set; }            // WhatsApp Cloud API media_id\n        public string? MediaType { get; set; }          // \"image\" | \"document\" | \"video\" | \"audio\" | \"location\"\n        public string? FileName { get; set; }           // original filename (if available)\n        public string? MimeType { get; set; }           // e.g. \"image/jpeg\", \"application/pdf\"\n\n        // ?? WhatsApp location message fields (no MediaId)\n        public double? LocationLatitude { get; set; }\n        public double? LocationLongitude { get; set; }\n        public string? LocationName { get; set; }\n        public string? LocationAddress { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/DTOs/QuickReplyDtos.cs",
      "sha256": "90ec17a9a8c369db09ac8c28b8296c766c31ea78badd34e53397522a8bc08e00",
      "language": "csharp",
      "size": 1460,
      "content": "using System.ComponentModel.DataAnnotations;\nusing xbytechat.api.Features.Inbox.Models;\n\nnamespace xbytechat.api.Features.Inbox.DTOs\n{\n    public sealed class QuickReplyDto\n    {\n        public Guid Id { get; set; }\n        public Guid BusinessId { get; set; }\n        public Guid? OwnerUserId { get; set; }\n        public QuickReplyScope Scope { get; set; }\n        public string Title { get; set; } = string.Empty;\n        public string Body { get; set; } = string.Empty;\n        public string? TagsCsv { get; set; }\n        public string? Language { get; set; }\n        public bool IsActive { get; set; }\n        public DateTime UpdatedAt { get; set; }\n    }\n\n    public sealed class QuickReplyCreateDto\n    {\n        [Required, MaxLength(120)] public string Title { get; set; } = string.Empty;\n        [Required] public string Body { get; set; } = string.Empty;\n        [MaxLength(240)] public string? TagsCsv { get; set; }\n        [MaxLength(8)] public string? Language { get; set; }\n        public QuickReplyScope Scope { get; set; } = QuickReplyScope.Personal;\n    }\n\n    public sealed class QuickReplyUpdateDto\n    {\n        [Required, MaxLength(120)] public string Title { get; set; } = string.Empty;\n        [Required] public string Body { get; set; } = string.Empty;\n        [MaxLength(240)] public string? TagsCsv { get; set; }\n        [MaxLength(8)] public string? Language { get; set; }\n        public bool IsActive { get; set; } = true;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/DTOs/SendInboxMessageDto.cs",
      "sha256": "1ad0e0e61748e9f9e1fab32e1fe533c57a6c8d586694e55aa5b531359804de90",
      "language": "csharp",
      "size": 462,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.Inbox.DTOs\n{\n    /// <summary>\n    /// DTO sent from frontend when a user sends a new message.\n    /// </summary>\n    public class SendInboxMessageDto\n    {\n        [Required]\n        public Guid ContactId { get; set; }\n\n        [Required]\n        public string MessageBody { get; set; }\n\n        public string? MediaUrl { get; set; } // Optional image or file\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/DTOs/SendMessageInputDto.cs",
      "sha256": "3c76bd2b5ce839064134b72aa2114c14c73a98109c680671f5e7c463867f221a",
      "language": "csharp",
      "size": 249,
      "content": "namespace xbytechat.api.Features.Inbox.DTOs\n{\n    public class SendMessageInputDto\n    {\n        public Guid ContactId { get; set; } // üîÅ REMOVE the \"?\" (nullable) unless needed\n        public string Message { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/DTOs/TextOnlyMessageSendDto.cs",
      "sha256": "2d322145a5e6410decb150b108c7d74a656201d9be027b99b02d1c261b4ed4fc",
      "language": "csharp",
      "size": 247,
      "content": "namespace xbytechat.api.Features.Inbox.DTOs\n{\n    public class TextOnlyMessageSendDto\n    {\n        public Guid BusinessId { get; set; }\n\n        public string RecipientNumber { get; set; }\n\n        public string TextContent { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Hubs/InboxHub.cs",
      "sha256": "dc50a81d23d6ff48b0dc5d21dc8631e25679ea931e3a2a1865b1746ebe9b80d4",
      "language": "csharp",
      "size": 9092,
      "content": "using Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.SignalR;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.Features.Inbox.Services;\nusing xbytechat.api.Models;\nusing xbytechat.api.Features.Inbox.Models;\nusing xbytechat.api.Shared;\nusing xbytechat.api.Features.Inbox.DTOs;\n\nnamespace xbytechat.api.Features.Inbox.Hubs\n{\n    [Authorize]\n    public sealed class InboxHub : Hub\n    {\n        private readonly AppDbContext _db;\n        private readonly IMessageEngineService _messageService;\n        private readonly IUnreadCountService _unreadCountService;\n        private readonly ILogger<InboxHub> _logger;\n\n        public InboxHub(\n            AppDbContext db,\n            IMessageEngineService messageService,\n            IUnreadCountService unreadCountService,\n            ILogger<InboxHub> logger)\n        {\n            _db = db;\n            _messageService = messageService;\n            _unreadCountService = unreadCountService;\n            _logger = logger;\n        }\n\n        public override async Task OnConnectedAsync()\n        {\n            //var businessId = Context.User.GetBusinessId();\n            var businessId = Context.User.ResolveBusinessId(Context.GetHttpContext()!);\n            if (businessId == Guid.Empty)\n            {\n                _logger.LogWarning(\"InboxHub connect: missing BusinessId claim. Conn={ConnId}\", Context.ConnectionId);\n                await base.OnConnectedAsync();\n                return;\n            }\n\n            var groupName = GetBusinessGroupName(businessId);\n\n            await Groups.AddToGroupAsync(Context.ConnectionId, groupName);\n            _logger.LogInformation(\"InboxHub connected. Group={Group} Conn={ConnId} UserIdentifier={UserId}\",\n                groupName, Context.ConnectionId, Context.UserIdentifier);\n\n            await base.OnConnectedAsync();\n        }\n\n        public override async Task OnDisconnectedAsync(Exception? exception)\n        {\n           // var businessId = Context.User.GetBusinessId();\n            var businessId = Context.User.ResolveBusinessId(Context.GetHttpContext()!);\n            if (businessId != Guid.Empty)\n            {\n                var groupName = GetBusinessGroupName(businessId);\n                try { await Groups.RemoveFromGroupAsync(Context.ConnectionId, groupName); } catch { /* ignore */ }\n\n                _logger.LogInformation(\"InboxHub disconnected. Group={Group} Conn={ConnId}\", groupName, Context.ConnectionId);\n            }\n\n            await base.OnDisconnectedAsync(exception);\n        }\n\n        // ‚úÖ Frontend should invoke: connection.invoke(\"SendMessageToContact\", { contactId, message })\n        public async Task SendMessageToContact(SendMessageInputDto dto)\n        {\n            if (dto == null)\n                return;\n\n            if (dto.ContactId == Guid.Empty || string.IsNullOrWhiteSpace(dto.Message))\n            {\n                _logger.LogWarning(\"SendMessageToContact invalid payload. ContactId={ContactId}\", dto.ContactId);\n                return;\n            }\n\n           // var businessId = Context.User.GetBusinessId();\n            var businessId = Context.User.ResolveBusinessId(Context.GetHttpContext()!);\n            var userId = Context.User.GetUserId();\n\n            if (businessId == Guid.Empty || userId == Guid.Empty)\n            {\n                _logger.LogWarning(\"SendMessageToContact missing BusinessId/UserId. Conn={ConnId}\", Context.ConnectionId);\n                return;\n            }\n\n            try\n            {\n                // ‚úÖ Lookup recipient phone number from Contacts\n                var contact = await _db.Contacts\n                    .Where(c => c.BusinessId == businessId && c.Id == dto.ContactId)\n                    .FirstOrDefaultAsync();\n\n                if (contact == null || string.IsNullOrWhiteSpace(contact.PhoneNumber))\n                {\n                    _logger.LogWarning(\"SendMessageToContact contact not found or missing phone. BusinessId={BusinessId} ContactId={ContactId}\",\n                        businessId, dto.ContactId);\n\n                    await Clients.Caller.SendAsync(\"ReceiveInboxMessage\", new\n                    {\n                        contactId = dto.ContactId,\n                        messageContent = dto.Message,\n                        from = userId,\n                        status = \"Failed\",\n                        error = \"Invalid contact\"\n                    });\n\n                    return;\n                }\n\n                var sendDto = new TextMessageSendDto\n                {\n                    BusinessId = businessId,\n                    ContactId = dto.ContactId,\n                    RecipientNumber = contact.PhoneNumber,\n                    TextContent = dto.Message\n                };\n\n                var result = await _messageService.SendTextDirectAsync(sendDto);\n\n                var inboxMessage = new\n                {\n                    contactId = dto.ContactId,\n                    messageContent = dto.Message,\n                    from = userId,\n                    status = result.Success ? \"Sent\" : \"Failed\",\n                    sentAt = DateTime.UtcNow,\n                    logId = result.LogId,\n                    senderId = userId,\n                    isIncoming = false\n                };\n\n                // Caller always gets it\n                await Clients.Caller.SendAsync(\"ReceiveInboxMessage\", inboxMessage);\n\n                // Others in the same business get it\n                var groupName = GetBusinessGroupName(businessId);\n                await Clients.GroupExcept(groupName, Context.ConnectionId)\n                    .SendAsync(\"ReceiveInboxMessage\", inboxMessage);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"SendMessageToContact failed. BusinessId={BusinessId} ContactId={ContactId}\",\n                    businessId, dto.ContactId);\n\n                await Clients.Caller.SendAsync(\"ReceiveInboxMessage\", new\n                {\n                    contactId = dto.ContactId,\n                    messageContent = dto.Message,\n                    from = userId,\n                    status = \"Failed\",\n                    error = \"Server error\"\n                });\n            }\n        }\n\n      \n        public async Task MarkAsRead(Guid contactId)\n        {\n            if (contactId == Guid.Empty)\n                return;\n\n            var userId = Context.User.GetUserId();\n           // var businessId = Context.User.GetBusinessId();\n            var businessId = Context.User.ResolveBusinessId(Context.GetHttpContext()!);\n            if (userId == Guid.Empty || businessId == Guid.Empty)\n                return;\n\n            try\n            {\n                var now = DateTime.UtcNow;\n\n                // ‚úÖ Upsert ContactRead\n                var readEntry = await _db.ContactReads\n                    .FirstOrDefaultAsync(r => r.BusinessId == businessId && r.ContactId == contactId && r.UserId == userId);\n\n                if (readEntry == null)\n                {\n                    _db.ContactReads.Add(new ContactRead\n                    {\n                        Id = Guid.NewGuid(),\n                        BusinessId = businessId,\n                        ContactId = contactId,\n                        UserId = userId,\n                        LastReadAt = now\n                    });\n                }\n                else\n                {\n                    readEntry.LastReadAt = now;\n                }\n\n                await _db.SaveChangesAsync();\n\n                // ‚úÖ CRITICAL FIX:\n                // UnreadCountService returns ONLY contacts with unread > 0.\n                // If this contact becomes 0, it will be missing from the dictionary,\n                // so the frontend would never clear the old badge.\n                // Force-send an explicit \"0\" for this contact to the caller.\n                await Clients.Caller.SendAsync(\"UnreadCountChanged\", new\n                {\n                    contactId = contactId,\n                    unreadCount = 0\n                });\n\n                // ‚úÖ Caller also gets their full unread map (for other chats)\n                var unreadCounts = await _unreadCountService.GetUnreadCountsAsync(businessId, userId);\n                await Clients.Caller.SendAsync(\"UnreadCountChanged\", unreadCounts);\n\n                // ‚úÖ Others get \"refresh your own\" signal\n                var groupName = GetBusinessGroupName(businessId);\n                await Clients.GroupExcept(groupName, Context.ConnectionId)\n                    .SendAsync(\"UnreadCountChanged\", new { refresh = true });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex,\n                    \"MarkAsRead failed. BusinessId={BusinessId} UserId={UserId} ContactId={ContactId}\",\n                    businessId, userId, contactId);\n            }\n        }\n\n        private static string GetBusinessGroupName(Guid businessId) => $\"business_{businessId}\";\n    }\n}\n\n\n\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Models/ChatSessionState.cs",
      "sha256": "fa6184f30e1715455ee5b84ae75264c5cc2d46ed4f1721014141ed9036dfda64",
      "language": "csharp",
      "size": 500,
      "content": "namespace xbytechat.api.Features.Inbox.Models\n{\n    public class ChatSessionState\n    {\n        public Guid Id { get; set; } = Guid.NewGuid();\n        public Guid BusinessId { get; set; }\n        public Guid ContactId { get; set; }\n\n        public string Mode { get; set; } = \"automation\"; // values: \"automation\" | \"agent\"\n        public DateTime LastUpdatedAt { get; set; } = DateTime.UtcNow;\n\n        // Optional: track who switched the mode\n        public string? UpdatedBy { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Models/ContactRead.cs",
      "sha256": "aa4dd9980bc6485cf1c4981bf7dfff84f32dcfbacc6c9dbc3be4ba0429c065c6",
      "language": "csharp",
      "size": 474,
      "content": "using System;\n\nnamespace xbytechat.api.Features.Inbox.Models\n{\n    public class ContactRead\n    {\n        public Guid Id { get; set; }\n\n        // üîó FK to Contact\n        public Guid ContactId { get; set; }\n\n        // üîó FK to User (Agent)\n        public Guid UserId { get; set; }\n\n        // üìÖ Last time this agent opened this contact's chat\n        public DateTime LastReadAt { get; set; } = DateTime.UtcNow;\n\n        public Guid BusinessId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Models/QuickReply.cs",
      "sha256": "8b5cba0c3d3af40a8abf6fd445648c0671b6fb294489fcae8c2d8b438291e285",
      "language": "csharp",
      "size": 1180,
      "content": "using System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace xbytechat.api.Features.Inbox.Models\n{\n    public enum QuickReplyScope { Personal = 0, Business = 2 }\n\n    [Table(\"QuickReplies\")]\n    public class QuickReply\n    {\n        [Key] public Guid Id { get; set; }\n        [Required] public Guid BusinessId { get; set; }\n        public Guid? OwnerUserId { get; set; }                // null for Business scope\n\n        [Required, MaxLength(120)] public string Title { get; set; } = string.Empty;\n        [Required] public string Body { get; set; } = string.Empty;\n\n        [MaxLength(240)] public string? TagsCsv { get; set; }\n        [MaxLength(8)] public string? Language { get; set; }   // e.g. \"en\", \"hi\"\n\n        public QuickReplyScope Scope { get; set; } = QuickReplyScope.Personal;\n        public bool IsActive { get; set; } = true;\n        public bool IsDeleted { get; set; } = false;\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n        public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;\n        public string? CreatedBy { get; set; }\n        public string? UpdatedBy { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Repositories/IInboxRepository.cs",
      "sha256": "dc286300119f9a71db85e3f3bae523d75fbf4b7887ccbeacb7aa08166b152045",
      "language": "csharp",
      "size": 1070,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Inbox.Repositories\n{\n    public interface IInboxRepository\n    {\n        Task<List<MessageLog>> GetConversationAsync(Guid businessId, string userPhone, string contactPhone, int limit = 50);\n        Task<MessageLog?> GetLastMessageAsync(Guid businessId, string userPhone, string contactPhone);\n\n        Task AddMessageAsync(MessageLog message);\n        Task SaveChangesAsync();\n\n        Task<List<MessageLog>> GetMessagesByContactIdAsync(Guid businessId, Guid contactId);\n\n        Task<Dictionary<Guid, int>> GetUnreadMessageCountsAsync(Guid businessId);\n        Task MarkMessagesAsReadAsync(Guid businessId, Guid contactId);\n\n        Task<Dictionary<Guid, int>> GetUnreadCountsForUserAsync(Guid businessId, Guid userId);\n\n        // ‚úÖ Step 3: Soft idempotency helper\n        // Used to prevent duplicate inbound inserts when webhook retries arrive.\n        Task<MessageLog?> FindByProviderMessageIdAsync(Guid businessId, string providerMessageId);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Repositories/InboxRepository.cs",
      "sha256": "b9fbbc9cfee67371f563d25176d036696839f4ce37465c843bfb4d13ee4bb90d",
      "language": "csharp",
      "size": 5051,
      "content": "using Microsoft.EntityFrameworkCore;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Inbox.Repositories\n{\n    public class InboxRepository : IInboxRepository\n    {\n        private readonly AppDbContext _context;\n\n        public InboxRepository(AppDbContext context)\n        {\n            _context = context;\n        }\n\n        public async Task<List<MessageLog>> GetConversationAsync(Guid businessId, string userPhone, string contactPhone, int limit = 50)\n        {\n            return await _context.MessageLogs\n                .Where(m => m.BusinessId == businessId &&\n                            ((m.RecipientNumber == contactPhone && m.IsIncoming == false) ||\n                             (m.RecipientNumber == userPhone && m.IsIncoming == true)))\n                .OrderByDescending(m => m.CreatedAt)\n                .Take(limit)\n                .ToListAsync();\n        }\n\n        public async Task<MessageLog?> GetLastMessageAsync(Guid businessId, string userPhone, string contactPhone)\n        {\n            return await _context.MessageLogs\n                .Where(m => m.BusinessId == businessId &&\n                            ((m.RecipientNumber == contactPhone && m.IsIncoming == false) ||\n                             (m.RecipientNumber == userPhone && m.IsIncoming == true)))\n                .OrderByDescending(m => m.CreatedAt)\n                .FirstOrDefaultAsync();\n        }\n\n        public async Task AddMessageAsync(MessageLog message)\n        {\n            await _context.MessageLogs.AddAsync(message);\n        }\n\n        public async Task SaveChangesAsync()\n        {\n            await _context.SaveChangesAsync();\n        }\n\n        public async Task<List<MessageLog>> GetMessagesByContactIdAsync(Guid businessId, Guid contactId)\n        {\n            return await _context.MessageLogs\n                .Include(m => m.SourceCampaign)\n                .Where(m => m.BusinessId == businessId && m.ContactId == contactId)\n                .OrderBy(m => m.CreatedAt)\n                .ToListAsync();\n        }\n\n        public async Task<Dictionary<Guid, int>> GetUnreadMessageCountsAsync(Guid businessId)\n        {\n            return await _context.MessageLogs\n                .Where(m => m.BusinessId == businessId &&\n                            m.IsIncoming &&\n                            m.Status != \"Read\" &&\n                            m.ContactId != null)\n                .GroupBy(m => m.ContactId!.Value)\n                .Select(g => new { ContactId = g.Key, Count = g.Count() })\n                .ToDictionaryAsync(x => x.ContactId, x => x.Count);\n        }\n\n        public async Task MarkMessagesAsReadAsync(Guid businessId, Guid contactId)\n        {\n            var unreadMessages = await _context.MessageLogs\n                .Where(m => m.BusinessId == businessId &&\n                            m.ContactId == contactId &&\n                            m.IsIncoming &&\n                            m.Status != \"Read\")\n                .ToListAsync();\n\n            foreach (var msg in unreadMessages)\n                msg.Status = \"Read\";\n\n            await _context.SaveChangesAsync();\n        }\n\n        public async Task<Dictionary<Guid, int>> GetUnreadCountsForUserAsync(Guid businessId, Guid userId)\n        {\n            var contactReads = await _context.ContactReads\n                .Where(r => r.UserId == userId)\n                .ToDictionaryAsync(r => r.ContactId, r => r.LastReadAt);\n\n            var allMessages = await _context.MessageLogs\n                .Where(m => m.BusinessId == businessId && m.IsIncoming && m.ContactId != null)\n                .ToListAsync();\n\n            var unreadCounts = allMessages\n                .GroupBy(m => m.ContactId!.Value)\n                .ToDictionary(\n                    g => g.Key,\n                    g => g.Count(m =>\n                        !contactReads.ContainsKey(g.Key) ||\n                        (m.SentAt ?? m.CreatedAt) > contactReads[g.Key])\n                );\n\n            return unreadCounts;\n        }\n\n        // ‚úÖ Step 4: Soft idempotency lookup (BusinessId + ProviderMessageId/WAMID)\n        // Used by InboxService to avoid inserting duplicate inbound rows when Meta retries webhooks.\n        public async Task<MessageLog?> FindByProviderMessageIdAsync(Guid businessId, string providerMessageId)\n        {\n            if (businessId == Guid.Empty) return null;\n            if (string.IsNullOrWhiteSpace(providerMessageId)) return null;\n\n            var wamid = providerMessageId.Trim();\n\n            // IMPORTANT:\n            // - Use ProviderMessageId only for webhook idempotency.\n            // - Do NOT match against MessageId here (prevents cross-path collisions).\n            return await _context.MessageLogs\n                .AsNoTracking()\n                .FirstOrDefaultAsync(m =>\n                    m.BusinessId == businessId &&\n                    m.ProviderMessageId != null &&\n                    m.ProviderMessageId == wamid\n                );\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Services/AgentAssignmentService.cs",
      "sha256": "de9062b213ba63cb8695f407ede5c9e8d52a589e0dc1c7a4c5c79fd243389e4e",
      "language": "csharp",
      "size": 1104,
      "content": "using System;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Logging;\n\nnamespace xbytechat.api.Features.Inbox.Services\n{\n    public class AgentAssignmentService : IAgentAssignmentService\n    {\n        private readonly ILogger<AgentAssignmentService> _logger;\n\n        public AgentAssignmentService(ILogger<AgentAssignmentService> logger)\n        {\n            _logger = logger;\n        }\n\n        public Task<bool> IsAgentAvailableAsync(Guid businessId)\n        {\n            // üîß TODO: Replace with real logic based on your agent pool\n            _logger.LogInformation(\"Checking if agent is available for business {BusinessId}\", businessId);\n            return Task.FromResult(true); // Assume always available for MVP\n        }\n\n        public Task AssignAgentToContactAsync(Guid businessId, Guid contactId)\n        {\n            // üîß TODO: Save agent-contact assignment to DB or notify a human agent\n            _logger.LogInformation(\"Assigning agent to contact {ContactId} for business {BusinessId}\", contactId, businessId);\n            return Task.CompletedTask;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Services/ChatSessionStateService.cs",
      "sha256": "5c6672bd07d87501ca9d46e38085cbec03455bae6cc943c8b8df505a7c73808e",
      "language": "csharp",
      "size": 2964,
      "content": "using Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.AutoReplyBuilder.Models;\nusing xbytechat.api.Features.Inbox.Models;\n\nnamespace xbytechat.api.Features.Inbox.Services\n{\n    public class ChatSessionStateService : IChatSessionStateService\n    {\n        private readonly AppDbContext _db;\n\n        public ChatSessionStateService(AppDbContext db)\n        {\n            _db = db;\n        }\n\n        // ‚úÖ Returns current chat mode: \"agent\" or \"auto\"\n        public async Task<string> GetChatModeAsync(Guid businessId, Guid contactId)\n        {\n            var session = await _db.ChatSessionStates\n                .FirstOrDefaultAsync(s => s.BusinessId == businessId && s.ContactId == contactId);\n\n            return session?.Mode ?? \"auto\"; // Default to auto\n        }\n\n        // ‚úÖ Switches to agent mode\n        public async Task SwitchToAgentModeAsync(Guid businessId, Guid contactId)\n        {\n            await UpsertChatModeAsync(businessId, contactId, \"agent\");\n        }\n\n        // ‚úÖ Switches to automation mode\n        public async Task SwitchToAutomationModeAsync(Guid businessId, Guid contactId)\n        {\n            await UpsertChatModeAsync(businessId, contactId, \"auto\");\n        }\n\n        // ‚úÖ Shared logic to insert or update session state\n        private async Task UpsertChatModeAsync(Guid businessId, Guid contactId, string mode)\n        {\n            var existing = await _db.ChatSessionStates\n                .FirstOrDefaultAsync(s => s.BusinessId == businessId && s.ContactId == contactId);\n\n            if (existing != null)\n            {\n                existing.Mode = mode;\n                existing.LastUpdatedAt = DateTime.UtcNow;\n            }\n            else\n            {\n                _db.ChatSessionStates.Add(new ChatSessionState\n                {\n                    BusinessId = businessId,\n                    ContactId = contactId,\n                    Mode = mode,\n                    LastUpdatedAt = DateTime.UtcNow\n                });\n            }\n\n            await _db.SaveChangesAsync();\n        }\n\n        public async Task SetChatModeAsync(Guid businessId, Guid contactId, string mode)\n        {\n            var state = await _db.ChatSessionStates\n                .FirstOrDefaultAsync(x => x.BusinessId == businessId && x.ContactId == contactId);\n\n            if (state == null)\n            {\n                // Insert new if not exists\n                state = new ChatSessionState\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    ContactId = contactId,\n                    Mode = mode,\n                    LastUpdatedAt = DateTime.UtcNow\n                };\n                _db.ChatSessionStates.Add(state);\n            }\n            else\n            {\n                state.Mode = mode;\n                state.LastUpdatedAt = DateTime.UtcNow;\n            }\n\n            await _db.SaveChangesAsync();\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Services/IAgentAssignmentService.cs",
      "sha256": "1eae6f670d61efc4cd6f430a93cf7188c26a6d521ae49cd50ab926aa5bc027ee",
      "language": "csharp",
      "size": 286,
      "content": "using System;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Inbox.Services\n{\n    public interface IAgentAssignmentService\n    {\n        Task<bool> IsAgentAvailableAsync(Guid businessId);\n        Task AssignAgentToContactAsync(Guid businessId, Guid contactId);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Services/IChatSessionStateService.cs",
      "sha256": "3ade6df9341ebca2e5a478331e57315273317bc803a529a4e068cccc323f1693",
      "language": "csharp",
      "size": 404,
      "content": "namespace xbytechat.api.Features.Inbox.Services\n{\n    public interface IChatSessionStateService\n    {\n        Task<string> GetChatModeAsync(Guid businessId, Guid contactId);\n        Task SwitchToAgentModeAsync(Guid businessId, Guid contactId);\n        Task SwitchToAutomationModeAsync(Guid businessId, Guid contactId);\n        Task SetChatModeAsync(Guid businessId, Guid contactId, string mode);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Services/IInboxService.cs",
      "sha256": "58b2b14fb055263d0f08348900a55c5cbd62c16609e1b4ba082beb34a84efc49",
      "language": "csharp",
      "size": 885,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Inbox.DTOs;\nusing xbytechat.api.Features.MessageManagement.DTOs;\n\nnamespace xbytechat.api.Features.Inbox.Services\n{\n    public interface IInboxService\n    {\n        Task<List<MessageLog>> GetConversationAsync(Guid businessId, string userPhone, string contactPhone, int limit = 50);\n        Task<MessageLog> SaveIncomingMessageAsync(InboxMessageDto dto);\n        Task<MessageLog> SaveOutgoingMessageAsync(InboxMessageDto dto);\n        Task<List<MessageLogDto>> GetMessagesByContactAsync(Guid businessId, Guid contactId);\n        Task<Dictionary<Guid, int>> GetUnreadMessageCountsAsync(Guid businessId);\n        Task MarkMessagesAsReadAsync(Guid businessId, Guid contactId);\n\n        Task<Dictionary<Guid, int>> GetUnreadCountsForUserAsync(Guid businessId, Guid userId);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Services/InboxService.cs",
      "sha256": "8f45defa7b8f6ffc93027a8d5cd7092e26d98b0a80c0956f5c457c043e52cea1",
      "language": "csharp",
      "size": 6707,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Inbox.DTOs;\nusing xbytechat.api.Features.Inbox.Repositories;\nusing xbytechat.api.Features.MessageManagement.DTOs;\n\nnamespace xbytechat.api.Features.Inbox.Services\n{\n    public class InboxService : IInboxService\n    {\n        private readonly IInboxRepository _repository;\n\n        public InboxService(IInboxRepository repository)\n        {\n            _repository = repository;\n        }\n\n        public async Task<List<MessageLog>> GetConversationAsync(Guid businessId, string userPhone, string contactPhone, int limit = 50)\n        {\n            return await _repository.GetConversationAsync(businessId, userPhone, contactPhone, limit);\n        }\n\n        public async Task<MessageLog> SaveIncomingMessageAsync(InboxMessageDto dto)\n        {\n            // ‚úÖ Soft idempotency on (BusinessId + ProviderMessageId) if available.\n            // Normalize ProviderMessageId to avoid \"space\" duplicates.\n            var providerMessageId = string.IsNullOrWhiteSpace(dto.ProviderMessageId)\n                ? null\n                : dto.ProviderMessageId.Trim();\n\n            if (!string.IsNullOrWhiteSpace(providerMessageId))\n            {\n                var existing = await _repository.FindByProviderMessageIdAsync(dto.BusinessId, providerMessageId);\n                if (existing != null)\n                    return existing;\n            }\n\n            // ‚úÖ SentAt: caller should pass provider timestamp when available; otherwise fall back to server time.\n            var sentAtUtc = dto.SentAt == default ? DateTime.UtcNow : dto.SentAt;\n\n            var message = new MessageLog\n            {\n                Id = Guid.NewGuid(),\n                BusinessId = dto.BusinessId,\n\n                RecipientNumber = dto.RecipientPhone,\n                MessageContent = dto.MessageBody,\n\n                MediaId = dto.MediaId,\n                MediaType = dto.MediaType,\n                FileName = dto.FileName,\n                MimeType = dto.MimeType,\n                LocationLatitude = dto.LocationLatitude,\n                LocationLongitude = dto.LocationLongitude,\n                LocationName = dto.LocationName,\n                LocationAddress = dto.LocationAddress,\n\n                IsIncoming = true,\n\n                // ‚úÖ Keep status consistent for UI (incoming should never be updated by delivery webhooks now)\n                Status = string.IsNullOrWhiteSpace(dto.Status) ? \"Received\" : dto.Status.Trim(),\n                SentAt = sentAtUtc,\n\n                // ‚úÖ CreatedAt = insert time (server truth)\n                CreatedAt = DateTime.UtcNow,\n\n                ProviderMessageId = providerMessageId,\n\n                ContactId = dto.ContactId,\n                CTAFlowStepId = dto.CTAFlowStepId,\n                CTAFlowConfigId = dto.CTAFlowConfigId,\n                CampaignId = dto.CampaignId,\n                RenderedBody = dto.RenderedBody\n            };\n\n            await _repository.AddMessageAsync(message);\n            await _repository.SaveChangesAsync();\n\n            return message;\n        }\n\n        public async Task<MessageLog> SaveOutgoingMessageAsync(InboxMessageDto dto)\n        {\n            // Outgoing WAMID may be unknown at creation time.\n            // If present (e.g., send returns WAMID and we call this after), add idempotency to avoid duplicates.\n            var providerMessageId = string.IsNullOrWhiteSpace(dto.ProviderMessageId)\n                ? null\n                : dto.ProviderMessageId.Trim();\n\n            if (!string.IsNullOrWhiteSpace(providerMessageId))\n            {\n                var existing = await _repository.FindByProviderMessageIdAsync(dto.BusinessId, providerMessageId);\n                if (existing != null)\n                    return existing;\n            }\n\n            var sentAtUtc = dto.SentAt == default ? DateTime.UtcNow : dto.SentAt;\n\n            var message = new MessageLog\n            {\n                Id = Guid.NewGuid(),\n                BusinessId = dto.BusinessId,\n\n                RecipientNumber = dto.RecipientPhone,\n                MessageContent = dto.MessageBody,\n\n                MediaId = dto.MediaId,\n                MediaType = dto.MediaType,\n                FileName = dto.FileName,\n                MimeType = dto.MimeType,\n                LocationLatitude = dto.LocationLatitude,\n                LocationLongitude = dto.LocationLongitude,\n                LocationName = dto.LocationName,\n                LocationAddress = dto.LocationAddress,\n\n                IsIncoming = false,\n\n                // ‚úÖ Default outgoing status\n                Status = string.IsNullOrWhiteSpace(dto.Status) ? \"Queued\" : dto.Status.Trim(),\n                SentAt = sentAtUtc,\n\n                CreatedAt = DateTime.UtcNow,\n\n                ProviderMessageId = providerMessageId,\n\n                ContactId = dto.ContactId,\n                CTAFlowStepId = dto.CTAFlowStepId,\n                CTAFlowConfigId = dto.CTAFlowConfigId,\n                CampaignId = dto.CampaignId,\n                RenderedBody = dto.RenderedBody\n            };\n\n            await _repository.AddMessageAsync(message);\n            await _repository.SaveChangesAsync();\n\n            return message;\n        }\n\n        public async Task<List<MessageLogDto>> GetMessagesByContactAsync(Guid businessId, Guid contactId)\n        {\n            var messages = await _repository.GetMessagesByContactIdAsync(businessId, contactId);\n\n            return messages.Select(m => new MessageLogDto\n            {\n                Id = m.Id,\n                ContactId = m.ContactId,\n                RecipientNumber = m.RecipientNumber,\n                MessageContent = m.MessageContent,\n                CreatedAt = m.CreatedAt,\n                IsIncoming = m.IsIncoming,\n                RenderedBody = m.RenderedBody,\n                CampaignId = m.CampaignId,\n                CampaignName = m.SourceCampaign?.Name,\n                CTAFlowConfigId = m.CTAFlowConfigId,\n                CTAFlowStepId = m.CTAFlowStepId\n            }).ToList();\n        }\n\n        public async Task<Dictionary<Guid, int>> GetUnreadMessageCountsAsync(Guid businessId)\n        {\n            return await _repository.GetUnreadMessageCountsAsync(businessId);\n        }\n\n        public async Task MarkMessagesAsReadAsync(Guid businessId, Guid contactId)\n        {\n            await _repository.MarkMessagesAsReadAsync(businessId, contactId);\n        }\n\n        public async Task<Dictionary<Guid, int>> GetUnreadCountsForUserAsync(Guid businessId, Guid userId)\n        {\n            return await _repository.GetUnreadCountsForUserAsync(businessId, userId);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Services/IQuickReplyService.cs",
      "sha256": "531cc91cab752357d88cfa2483ab059e7a9ffdcfe4507a3105595cc17e33c1c0",
      "language": "csharp",
      "size": 816,
      "content": "using xbytechat.api.Features.Inbox.DTOs;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.Inbox.Services\n{\n    public interface IQuickReplyService\n    {\n        Task<List<QuickReplyDto>> GetAllAsync(Guid businessId, Guid userId,\n            string? search = null, bool includeBusiness = true, bool includePersonal = true);\n\n        Task<ResponseResult> CreateAsync(Guid businessId, Guid userId, string actor, QuickReplyCreateDto dto);\n        Task<ResponseResult> UpdateAsync(Guid businessId, Guid userId, string actor, Guid id, QuickReplyUpdateDto dto);\n        Task<ResponseResult> ToggleActiveAsync(Guid businessId, Guid userId, string actor, Guid id, bool isActive);\n        Task<ResponseResult> DeleteAsync(Guid businessId, Guid userId, string actor, Guid id);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Services/IUnreadCountService.cs",
      "sha256": "a7e51e22be544e5387038cd46027d2a58f968fbe1db1a3d792cde75ac9bfd4de",
      "language": "csharp",
      "size": 272,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Inbox.Services\n{\n    public interface IUnreadCountService\n    {\n        Task<Dictionary<Guid, int>> GetUnreadCountsAsync(Guid businessId, Guid userId);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Services/QuickReplyService.cs",
      "sha256": "594274585168680028dd399dbf8b94c4efa5438224541ec8ee1140c4a2482253",
      "language": "csharp",
      "size": 8104,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing xbytechat.api.Features.Inbox.DTOs;\nusing xbytechat.api.Features.Inbox.Models;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.Inbox.Services\n{\n    public class QuickReplyService : IQuickReplyService\n    {\n        private readonly AppDbContext _db;\n\n        public QuickReplyService(AppDbContext db) => _db = db;\n\n        public async Task<List<QuickReplyDto>> GetAllAsync(Guid businessId, Guid userId,\n            string? search = null, bool includeBusiness = true, bool includePersonal = true)\n        {\n            var q = _db.Set<QuickReply>()\n                .AsNoTracking()\n                .Where(qr => qr.BusinessId == businessId && !qr.IsDeleted && qr.IsActive);\n\n            if (!includeBusiness) q = q.Where(x => x.Scope == QuickReplyScope.Personal);\n            if (!includePersonal) q = q.Where(x => x.Scope == QuickReplyScope.Business);\n            if (includePersonal && includeBusiness == false)\n                q = q.Where(x => x.OwnerUserId == userId || x.Scope == QuickReplyScope.Business);\n            else if (includePersonal)\n                q = q.Where(x => x.Scope == QuickReplyScope.Business || x.OwnerUserId == userId);\n\n            if (!string.IsNullOrWhiteSpace(search))\n            {\n                var s = search.Trim().ToLower();\n                q = q.Where(x =>\n                    x.Title.ToLower().Contains(s) ||\n                    x.Body.ToLower().Contains(s) ||\n                    (x.TagsCsv != null && x.TagsCsv.ToLower().Contains(s)));\n            }\n\n            return await q\n                .OrderByDescending(x => x.Scope)\n                .ThenBy(x => x.Title)\n                .Select(x => new QuickReplyDto\n                {\n                    Id = x.Id,\n                    BusinessId = x.BusinessId,\n                    OwnerUserId = x.OwnerUserId,\n                    Scope = x.Scope,\n                    Title = x.Title,\n                    Body = x.Body,\n                    TagsCsv = x.TagsCsv,\n                    Language = x.Language,\n                    IsActive = x.IsActive,\n                    UpdatedAt = x.UpdatedAt\n                }).ToListAsync();\n        }\n\n        public async Task<ResponseResult> CreateAsync(Guid businessId, Guid userId, string actor, QuickReplyCreateDto dto)\n        {\n            try\n            {\n                var entity = new QuickReply\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    OwnerUserId = dto.Scope == QuickReplyScope.Personal ? userId : null,\n                    Scope = dto.Scope,\n                    Title = dto.Title.Trim(),\n                    Body = dto.Body,\n                    TagsCsv = dto.TagsCsv,\n                    Language = dto.Language,\n                    IsActive = true,\n                    CreatedAt = DateTime.UtcNow,\n                    UpdatedAt = DateTime.UtcNow,\n                    CreatedBy = actor,\n                    UpdatedBy = actor\n                };\n\n                _db.Add(entity);\n                await _db.SaveChangesAsync();\n\n                Log.Information(\"QuickReply created {@QuickReplyId} for business {@BusinessId} by {@Actor}\",\n                    entity.Id, businessId, actor);\n\n                return ResponseResult.SuccessInfo(\"‚úÖ Quick reply created.\");\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"Error creating quick reply for business {BusinessId}\", businessId);\n                return ResponseResult.ErrorInfo(\"‚ùå Failed to create quick reply.\", ex.ToString()); // pattern like Campaign. :contentReference[oaicite:3]{index=3}\n            }\n        }\n\n        public async Task<ResponseResult> UpdateAsync(Guid businessId, Guid userId, string actor, Guid id, QuickReplyUpdateDto dto)\n        {\n            try\n            {\n                var entity = await _db.Set<QuickReply>()\n                    .FirstOrDefaultAsync(x => x.Id == id && x.BusinessId == businessId && !x.IsDeleted);\n\n                if (entity == null)\n                    return ResponseResult.ErrorInfo(\"‚ùå Quick reply not found.\");\n\n                // Only owner can edit personal; business-scope allowed for now\n                if (entity.Scope == QuickReplyScope.Personal && entity.OwnerUserId != userId)\n                    return ResponseResult.ErrorInfo(\"‚õî You cannot edit another user's personal quick reply.\");\n\n                entity.Title = dto.Title.Trim();\n                entity.Body = dto.Body;\n                entity.TagsCsv = dto.TagsCsv;\n                entity.Language = dto.Language;\n                entity.IsActive = dto.IsActive;\n                entity.UpdatedAt = DateTime.UtcNow;\n                entity.UpdatedBy = actor;\n\n                await _db.SaveChangesAsync();\n\n                Log.Information(\"QuickReply updated {@QuickReplyId} for business {@BusinessId} by {@Actor}\",\n                    id, businessId, actor);\n\n                return ResponseResult.SuccessInfo(\"‚úÖ Quick reply updated.\");\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"Error updating quick reply {@QuickReplyId} for business {BusinessId}\", id, businessId);\n                return ResponseResult.ErrorInfo(\"‚ùå Failed to update quick reply.\", ex.ToString()); // campaign-style. :contentReference[oaicite:4]{index=4}\n            }\n        }\n\n        public async Task<ResponseResult> ToggleActiveAsync(Guid businessId, Guid userId, string actor, Guid id, bool isActive)\n        {\n            try\n            {\n                var entity = await _db.Set<QuickReply>()\n                    .FirstOrDefaultAsync(x => x.Id == id && x.BusinessId == businessId && !x.IsDeleted);\n\n                if (entity == null)\n                    return ResponseResult.ErrorInfo(\"‚ùå Quick reply not found.\");\n\n                if (entity.Scope == QuickReplyScope.Personal && entity.OwnerUserId != userId)\n                    return ResponseResult.ErrorInfo(\"‚õî You cannot modify another user's personal quick reply.\");\n\n                entity.IsActive = isActive;\n                entity.UpdatedAt = DateTime.UtcNow;\n                entity.UpdatedBy = actor;\n                await _db.SaveChangesAsync();\n\n                Log.Information(\"QuickReply toggled {@QuickReplyId} -> {IsActive} by {@Actor}\",\n                    id, isActive, actor);\n\n                return ResponseResult.SuccessInfo(isActive ? \"‚úÖ Enabled.\" : \"‚úÖ Disabled.\");\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"Error toggling quick reply {@QuickReplyId}\", id);\n                return ResponseResult.ErrorInfo(\"‚ùå Failed to toggle quick reply.\", ex.ToString());\n            }\n        }\n\n        public async Task<ResponseResult> DeleteAsync(Guid businessId, Guid userId, string actor, Guid id)\n        {\n            try\n            {\n                var entity = await _db.Set<QuickReply>()\n                    .FirstOrDefaultAsync(x => x.Id == id && x.BusinessId == businessId && !x.IsDeleted);\n\n                if (entity == null)\n                    return ResponseResult.ErrorInfo(\"‚ùå Quick reply not found.\");\n\n                if (entity.Scope == QuickReplyScope.Personal && entity.OwnerUserId != userId)\n                    return ResponseResult.ErrorInfo(\"‚õî You cannot delete another user's personal quick reply.\");\n\n                entity.IsDeleted = true;\n                entity.IsActive = false;\n                entity.UpdatedAt = DateTime.UtcNow;\n                entity.UpdatedBy = actor;\n\n                await _db.SaveChangesAsync();\n\n                Log.Information(\"QuickReply soft-deleted {@QuickReplyId} by {@Actor}\", id, actor);\n                return ResponseResult.SuccessInfo(\"üóëÔ∏è Deleted.\");\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"Error deleting quick reply {@QuickReplyId}\", id);\n                return ResponseResult.ErrorInfo(\"‚ùå Failed to delete quick reply.\", ex.ToString());\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Services/UnreadCountService.cs",
      "sha256": "783deeff0e4866ddc454bb9d642e26f173a37a45b82a87ad3f75c6150fdecd74",
      "language": "csharp",
      "size": 1537,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.Inbox.Services\n{\n    public class UnreadCountService : IUnreadCountService\n    {\n        private readonly AppDbContext _db;\n\n        public UnreadCountService(AppDbContext db)\n        {\n            _db = db;\n        }\n\n        public async Task<Dictionary<Guid, int>> GetUnreadCountsAsync(Guid businessId, Guid userId)\n        {\n            if (businessId == Guid.Empty || userId == Guid.Empty)\n                return new Dictionary<Guid, int>();\n\n            var userReads = _db.ContactReads.AsNoTracking()\n                .Where(r => r.BusinessId == businessId && r.UserId == userId);\n\n            var query = _db.MessageLogs.AsNoTracking()\n                .Where(m => m.BusinessId == businessId && m.IsIncoming && m.ContactId != null)\n                .GroupJoin(\n                    userReads,\n                    m => m.ContactId,\n                    r => r.ContactId,\n                    (m, rj) => new { m, rj }\n                )\n                .SelectMany(x => x.rj.DefaultIfEmpty(), (x, r) => new { x.m, r })\n                .Where(x => x.r == null || (x.m.SentAt ?? x.m.CreatedAt) > x.r.LastReadAt)\n                .GroupBy(x => x.m.ContactId!.Value)\n                .Select(g => new { ContactId = g.Key, Count = g.Count() });\n\n            return await query.ToDictionaryAsync(x => x.ContactId, x => x.Count);\n        }\n    }\n}\n\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/SignalR/NameUserIdProvider.cs",
      "sha256": "a634119a30658c1936e6d36db5e2a6a0a715e39bb50651261139ca883a92262b",
      "language": "csharp",
      "size": 810,
      "content": "using Microsoft.AspNetCore.SignalR;\nusing System.Security.Claims;\n\nnamespace xbytechat.api.SignalR\n{\n    public sealed class NameUserIdProvider : IUserIdProvider\n    {\n        public string? GetUserId(HubConnectionContext connection)\n        {\n            var user = connection.User;\n            if (user == null) return null;\n\n            // Prefer NameIdentifier\n            var id = user.FindFirstValue(ClaimTypes.NameIdentifier);\n            if (!string.IsNullOrWhiteSpace(id)) return id;\n\n            // Fallbacks (depending on how JWT was created)\n            id = user.FindFirstValue(\"sub\");\n            if (!string.IsNullOrWhiteSpace(id)) return id;\n\n            id = user.FindFirstValue(\"userId\");\n            if (!string.IsNullOrWhiteSpace(id)) return id;\n\n            return null;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessageLogging/Services/IMessageLogSink.cs",
      "sha256": "280e1b16e5989b3a0f91f1bd6cc41fc9efce73fa0d89328db4cf1e0bd76926c4",
      "language": "csharp",
      "size": 205,
      "content": "namespace xbytechat.api.Features.MessageLogging.Services\n{\n    /// Fire-and-forget enqueue API for MessageLog rows.\n    public interface IMessageLogSink\n    {\n        void Enqueue(MessageLog row);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessageLogging/Services/MessageLogSink.cs",
      "sha256": "a6981361a8c0176c508a4e6d7a15cb7dd9d5feeac16393073ae13d0115802757",
      "language": "csharp",
      "size": 1911,
      "content": "using System.Threading.Channels;\nusing Microsoft.EntityFrameworkCore;\n\nnamespace xbytechat.api.Features.MessageLogging.Services \n{\n    /// Background batch writer for MessageLogs.\n    public sealed class MessageLogSink : BackgroundService, IMessageLogSink\n    {\n        private readonly Channel<MessageLog> _channel =\n            Channel.CreateBounded<MessageLog>(new BoundedChannelOptions(20_000)\n            {\n                SingleReader = false,\n                SingleWriter = false,\n                FullMode = BoundedChannelFullMode.DropOldest\n            });\n\n        private readonly IServiceProvider _sp;\n        private const int BatchSize = 1000;\n\n        public MessageLogSink(IServiceProvider sp) => _sp = sp;\n\n        public void Enqueue(MessageLog row) => _channel.Writer.TryWrite(row);\n\n        protected override async Task ExecuteAsync(CancellationToken ct)\n        {\n            var batch = new List<MessageLog>(BatchSize);\n\n            while (!ct.IsCancellationRequested)\n            {\n                try\n                {\n                    while (batch.Count < BatchSize && _channel.Reader.TryRead(out var x))\n                        batch.Add(x);\n\n                    if (batch.Count == 0)\n                    {\n                        var first = await _channel.Reader.ReadAsync(ct);\n                        batch.Add(first);\n                    }\n\n                    using var scope = _sp.CreateScope();\n                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n                    db.ChangeTracker.AutoDetectChangesEnabled = false;\n\n                    await db.MessageLogs.AddRangeAsync(batch, ct);\n                    await db.SaveChangesAsync(ct);\n                    batch.Clear();\n                }\n                catch (TaskCanceledException) { /* shutdown */ }\n                catch { await Task.Delay(200, ct); }\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessageLogging/Services/MessageLogSinkOptions.cs",
      "sha256": "cf616a6c8a74f14ef5d9d26196a18cc97784dc052238edf6129917208b04fc3b",
      "language": "csharp",
      "size": 344,
      "content": "namespace xbytechat.api.Features.MessageLogging.Services;\n\npublic sealed class MessageLogSinkOptions\n{\n    // rows per COPY\n    public int BatchSize { get; set; } = 1000;\n\n    // flush if idle for this long (ms)\n    public int FlushIntervalMs { get; set; } = 800;\n\n    // fallback to EF if false\n    public bool UseCopy { get; set; } = true;\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessageLogging/Services/PostgresCopyMessageLogSink.cs",
      "sha256": "ca5ff5777e78aba4785a0e62c731d7c4f4b29b8e8491e191372626e7ad92548b",
      "language": "csharp",
      "size": 12184,
      "content": "using System.Threading.Channels;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing Npgsql;\nusing NpgsqlTypes;\nusing xbytechat.api.Features.CampaignTracking.Models; // MessageLog\nusing xbytechat.api.AuthModule.Models;               // AppDbContext\n\nnamespace xbytechat.api.Features.MessageLogging.Services;\n\n/// <summary>\n/// Background sink that batches MessageLogs and writes with COPY BINARY into Postgres.\n/// Falls back to EF AddRange on error or when UseCopy=false.\n/// </summary>\npublic sealed class PostgresCopyMessageLogSink : BackgroundService, IMessageLogSink\n{\n    private readonly IServiceProvider _sp;\n    private readonly ILogger<PostgresCopyMessageLogSink> _log;\n    private readonly MessageLogSinkOptions _opt;\n    private readonly Channel<MessageLog> _ch;\n\n    public PostgresCopyMessageLogSink(\n        IServiceProvider sp,\n        ILogger<PostgresCopyMessageLogSink> log,\n        IOptions<MessageLogSinkOptions> opt)\n    {\n        _sp = sp;\n        _log = log;\n        _opt = opt?.Value ?? new MessageLogSinkOptions();\n\n        _ch = Channel.CreateBounded<MessageLog>(new BoundedChannelOptions(capacity: 50_000)\n        {\n            SingleReader = true,\n            SingleWriter = false,\n            FullMode = BoundedChannelFullMode.Wait\n        });\n\n        _log.LogInformation(\"MessageLog sink initialized (BatchSize={Batch}, FlushIntervalMs={Flush}, UseCopy={UseCopy})\",\n            _opt.BatchSize, _opt.FlushIntervalMs, _opt.UseCopy);\n    }\n\n    public void Enqueue(MessageLog row)\n    {\n        // Fast path: try non-blocking write.\n        if (!_ch.Writer.TryWrite(row))\n        {\n            // Channel is full or not ready: enqueue asynchronously without blocking the caller.\n            _ = _ch.Writer.WriteAsync(row);\n        }\n    }\n\n    protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n    {\n        var batch = new List<MessageLog>(_opt.BatchSize);\n        var flushDelay = TimeSpan.FromMilliseconds(Math.Max(100, _opt.FlushIntervalMs));\n\n        while (!stoppingToken.IsCancellationRequested)\n        {\n            try\n            {\n                // Wait for either new data or idle timeout to flush partial batches\n                var readTask = _ch.Reader.WaitToReadAsync(stoppingToken).AsTask();\n                var delayTask = Task.Delay(flushDelay, stoppingToken);\n                var winner = await Task.WhenAny(readTask, delayTask);\n\n                if (winner == readTask && await readTask)\n                {\n                    while (_ch.Reader.TryRead(out var row))\n                    {\n                        batch.Add(row);\n                        if (batch.Count >= _opt.BatchSize)\n                        {\n                            await FlushAsync(batch, stoppingToken);\n                            batch.Clear();\n                        }\n                    }\n                }\n\n                // Idle flush if timer fired and we have pending rows\n                if (winner == delayTask && batch.Count > 0)\n                {\n                    await FlushAsync(batch, stoppingToken);\n                    batch.Clear();\n                }\n            }\n            catch (OperationCanceledException) { /* shutdown */ }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"[MessageLogSink] loop error\");\n                await Task.Delay(500, stoppingToken);\n            }\n        }\n\n        // final drain\n        try\n        {\n            if (batch.Count > 0) await FlushAsync(batch, CancellationToken.None);\n        }\n        catch (Exception ex)\n        {\n            _log.LogError(ex, \"[MessageLogSink] final flush failed\");\n        }\n    }\n\n    private async Task FlushAsync(List<MessageLog> rows, CancellationToken ct)\n    {\n        if (rows.Count == 0) return;\n\n        using var scope = _sp.CreateScope();\n        var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n\n        _log.LogInformation(\n            \"[MessageLogSink] Flushing {Count} logs. FirstIds={Ids}\",\n            rows.Count,\n            string.Join(\",\", rows.Take(5).Select(x => x.Id)));\n\n        if (_opt.UseCopy && db.Database.IsNpgsql())\n        {\n            var connString = db.Database.GetDbConnection().ConnectionString;\n\n            await using var conn = new NpgsqlConnection(connString);\n            await conn.OpenAsync(ct);\n\n            // ‚úÖ Align with table: both IsChargeable and IsIncoming are present (in this order)\n            // ‚úÖ Added ContactId to COPY list (positional order matters)\n            // ‚úÖ Also keep it close to BusinessId/CampaignId for clarity\n            const string copySql = @\"\nCOPY \"\"MessageLogs\"\" (\n    \"\"Id\"\",\n    \"\"BusinessId\"\",\n    \"\"CampaignId\"\",\n    \"\"ContactId\"\",\n    \"\"RecipientNumber\"\",\n    \"\"MessageContent\"\",\n    \"\"MediaUrl\"\",\n    \"\"Status\"\",\n    \"\"MessageId\"\",\n    \"\"ErrorMessage\"\",\n    \"\"RawResponse\"\",\n    \"\"CreatedAt\"\",\n    \"\"SentAt\"\",\n    \"\"Source\"\",\n    \"\"RunId\"\",\n    \"\"Provider\"\",\n    \"\"ProviderMessageId\"\",\n    \"\"IsChargeable\"\",\n    \"\"IsIncoming\"\"\n) FROM STDIN (FORMAT BINARY);\";\n\n\n            try\n            {\n                await using var importer = await conn.BeginBinaryImportAsync(copySql, ct);\n\n                foreach (var r in rows)\n                {\n                    await importer.StartRowAsync(ct);\n\n                    //importer.Write(r.Id, NpgsqlDbType.Uuid);\n                    //importer.Write(r.BusinessId, NpgsqlDbType.Uuid);\n                    //importer.Write(r.CampaignId, NpgsqlDbType.Uuid);\n\n                    //if (string.IsNullOrWhiteSpace(r.RecipientNumber)) importer.WriteNull();\n                    //else importer.Write(r.RecipientNumber, NpgsqlDbType.Text);\n                    importer.Write(r.Id, NpgsqlDbType.Uuid);\n                    importer.Write(r.BusinessId, NpgsqlDbType.Uuid);\n\n                    // ‚úÖ CampaignId can be nullable in many systems; write safely\n                    if (r.CampaignId.HasValue) importer.Write(r.CampaignId.Value, NpgsqlDbType.Uuid);\n                    else importer.WriteNull();\n\n                    // ‚úÖ NEW: ContactId (nullable) ‚Äî must match COPY column order exactly\n                    if (r.ContactId.HasValue) importer.Write(r.ContactId.Value, NpgsqlDbType.Uuid);\n                    else importer.WriteNull();\n\n                    if (string.IsNullOrWhiteSpace(r.RecipientNumber)) importer.WriteNull();\n                    else importer.Write(r.RecipientNumber, NpgsqlDbType.Text);\n\n\n\n                    if (string.IsNullOrWhiteSpace(r.MessageContent)) importer.WriteNull();\n                    else importer.Write(r.MessageContent, NpgsqlDbType.Text);\n\n                    if (string.IsNullOrWhiteSpace(r.MediaUrl)) importer.WriteNull();\n                    else importer.Write(r.MediaUrl, NpgsqlDbType.Text);\n\n                    if (string.IsNullOrWhiteSpace(r.Status)) importer.WriteNull();\n                    else importer.Write(r.Status, NpgsqlDbType.Text);\n\n                    if (string.IsNullOrWhiteSpace(r.MessageId)) importer.WriteNull();\n                    else importer.Write(r.MessageId, NpgsqlDbType.Text);\n\n                    if (string.IsNullOrWhiteSpace(r.ErrorMessage)) importer.WriteNull();\n                    else importer.Write(r.ErrorMessage, NpgsqlDbType.Text);\n\n                    if (string.IsNullOrWhiteSpace(r.RawResponse)) importer.WriteNull();\n                    else importer.Write(r.RawResponse, NpgsqlDbType.Text);\n\n                    importer.Write(r.CreatedAt, NpgsqlDbType.TimestampTz);\n                    if (r.SentAt.HasValue) importer.Write(r.SentAt.Value, NpgsqlDbType.TimestampTz);\n                    else importer.WriteNull();\n\n                    if (string.IsNullOrWhiteSpace(r.Source)) importer.WriteNull();\n                    else importer.Write(r.Source, NpgsqlDbType.Text);\n\n                    importer.Write(r.RunId, NpgsqlDbType.Uuid);\n\n                    if (string.IsNullOrWhiteSpace(r.Provider)) importer.WriteNull();\n                    else importer.Write(r.Provider, NpgsqlDbType.Text);\n\n                    if (string.IsNullOrWhiteSpace(r.ProviderMessageId)) importer.WriteNull();\n                    else importer.Write(r.ProviderMessageId, NpgsqlDbType.Text);\n\n                    // ‚úÖ keep order in sync with COPY list\n                    importer.Write(r.IsChargeable, NpgsqlDbType.Boolean);\n                    importer.Write(r.IsIncoming, NpgsqlDbType.Boolean);\n                }\n\n                await importer.CompleteAsync(ct);\n                _log.LogDebug(\"[MessageLogSink] COPY inserted {Count} rows\", rows.Count);\n                return;\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex,\n                    \"[MessageLogSink] COPY failed, falling back to EF for {Count} rows. FirstIds={Ids}\",\n                    rows.Count,\n                    string.Join(\",\", rows.Take(5).Select(x => x.Id)));\n                // fall through to EF path\n            }\n        }\n\n        // Fallback EF insert\n        db.ChangeTracker.AutoDetectChangesEnabled = false;\n        try\n        {\n            var written = await db.BulkInsertMessageLogsAsync(rows, ct);\n            var ids = rows.Select(x => x.Id).ToList();\n\n            if (written != rows.Count)\n            {\n                _log.LogError(\n                    \"[MessageLogSink] EF insert wrote {Written}/{Count} rows. FirstIds={Ids}\",\n                    written, rows.Count, string.Join(\",\", ids.Take(5)));\n            }\n\n            // Verify all IDs are present; if not, try once more for missing rows\n            var existingIds = await db.MessageLogs\n                .AsNoTracking()\n                .Where(m => ids.Contains(m.Id))\n                .Select(m => m.Id)\n                .ToListAsync(ct);\n\n            var missing = ids.Except(existingIds).ToList();\n            if (missing.Count > 0)\n            {\n                _log.LogError(\n                    \"[MessageLogSink] EF verification missing {Missing} rows. MissingIds={Ids}\",\n                    missing.Count, string.Join(\",\", missing));\n\n                var missingRows = rows.Where(r => missing.Contains(r.Id)).ToList();\n                db.MessageLogs.AddRange(missingRows);\n                var retryWritten = await db.SaveChangesAsync(ct);\n\n                var retryExisting = await db.MessageLogs\n                    .AsNoTracking()\n                    .Where(m => ids.Contains(m.Id))\n                    .Select(m => m.Id)\n                    .ToListAsync(ct);\n\n                var stillMissing = ids.Except(retryExisting).ToList();\n                if (stillMissing.Count > 0)\n                {\n                    _log.LogError(\n                        \"[MessageLogSink] EF insert retry still missing {Missing} rows. MissingIds={Ids}\",\n                        stillMissing.Count, string.Join(\",\", stillMissing));\n                    throw new InvalidOperationException(\"MessageLogSink failed to persist MessageLogs: \" + string.Join(\",\", stillMissing));\n                }\n\n                _log.LogInformation(\n                    \"[MessageLogSink] EF retry inserted missing rows. Written={Written} RetryWritten={RetryWritten}\",\n                    written, retryWritten);\n            }\n            else\n            {\n                _log.LogInformation(\n                    \"[MessageLogSink] EF insert succeeded for {Count} rows. FirstIds={Ids}\",\n                    rows.Count, string.Join(\",\", ids.Take(5)));\n            }\n        }\n        catch (Exception ex)\n        {\n            _log.LogError(ex,\n                \"[MessageLogSink] EF insert failed for {Count} rows. FirstIds={Ids}\",\n                rows.Count,\n                string.Join(\",\", rows.Take(5).Select(x => x.Id)));\n            throw;\n        }\n    }\n\n}\n\n/// <summary>\n/// Small EF helper for fallback insert path (kept here for locality).\n/// </summary>\ninternal static class MessageLogEfFallback\n{\n    public static async Task<int> BulkInsertMessageLogsAsync(this AppDbContext db, IEnumerable<MessageLog> rows, CancellationToken ct)\n    {\n        db.MessageLogs.AddRange(rows);\n        return await db.SaveChangesAsync(ct);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessageManagement/Controllers/MessageStatusController.cs",
      "sha256": "7b3c0a7925b1f33437cf3ad3692763936a63560660f199ba962d0999bfee7963",
      "language": "csharp",
      "size": 3233,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.MessageManagement.DTOs;\nusing xbytechat.api.Features.MessageManagement.Services;\n\nnamespace xbytechat.api.Features.MessageManagement.Controllers\n{\n    [ApiController]\n    [Route(\"api/message-status\")]\n    public class MessageStatusController : ControllerBase\n    {\n        private readonly IMessageStatusService _service;\n        private readonly ILogger<MessageStatusController> _logger;\n        private readonly AppDbContext _context;\n        private readonly IConfiguration _config;\n        public MessageStatusController(\n    IMessageStatusService service,\n    ILogger<MessageStatusController> logger,\n    AppDbContext context,\n    IConfiguration config)\n        {\n            _service = service;\n            _logger = logger;\n            _context = context;\n            _config = config;\n        }\n\n        // ‚úÖ STEP 1: Webhook Verification (GET)\n        [HttpGet(\"webhook\")]\n        public IActionResult VerifyWebhook([FromQuery(Name = \"hub.mode\")] string mode,\n                                    [FromQuery(Name = \"hub.verify_token\")] string token,\n                                    [FromQuery(Name = \"hub.challenge\")] string challenge)\n        {\n            //var VERIFY_TOKEN = _config[\"WhatsApp:MetaToken\"]; // ‚úÖ pulled from config\n\n            if (mode == \"subscribe\" && token == \"xbytechat-secret-token\")\n            {\n                _logger.LogInformation(\"‚úÖ Webhook verified.\");\n                return Ok(challenge);\n            }\n\n            _logger.LogWarning(\"‚ùå Webhook verification failed.\");\n            return Forbid();\n        }\n\n\n        // ‚úÖ STEP 2: Webhook Payload (POST)\n        [HttpPost(\"webhook\")]\n        public async Task<IActionResult> ReceiveStatus([FromBody] WebhookStatusDto dto)\n        {\n            if (dto == null || dto.statuses == null || dto.statuses.Count == 0)\n            {\n                _logger.LogWarning(\"‚ö†Ô∏è Invalid webhook payload received.\");\n                return BadRequest(\"Invalid payload\");\n            }\n\n            await _service.LogWebhookStatusAsync(dto);\n            _logger.LogInformation(\"‚úÖ Webhook status processed successfully.\");\n\n            return Ok(new { success = true });\n        }\n\n        // ‚úÖ STEP 3: Frontend UI (GET Logs)\n        [HttpGet]\n        public async Task<IActionResult> GetStatusLogs([FromQuery] Guid businessId)\n        {\n            var logs = await _context.MessageStatusLogs// MessageStatusLogs\n                .Where(x => x.BusinessId == businessId)\n                .OrderByDescending(x => x.CreatedAt)\n                .Take(100)\n                .Select(x => new\n                {\n                    x.MessageId,\n                    x.RecipientNumber,\n                    x.Status,\n                    x.SentAt,\n                    x.DeliveredAt,\n                    x.ReadAt,\n                    x.ErrorMessage,\n                    x.TemplateCategory,\n                    x.MessageType\n                })\n                .ToListAsync();\n\n            return Ok(new { success = true, data = logs });\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessageManagement/DTOs/MessageLogDto.cs",
      "sha256": "c0f207826b70160db8814aaf2e5fcf92174c9b5b7d0904bf27f60163fb2ca516",
      "language": "csharp",
      "size": 643,
      "content": "using System;\n\nnamespace xbytechat.api.Features.MessageManagement.DTOs\n{\n    public class MessageLogDto\n    {\n        public Guid Id { get; set; }\n        public Guid? ContactId { get; set; }\n        public string RecipientNumber { get; set; }\n        public string MessageContent { get; set; }\n        public bool IsIncoming { get; set; }\n        public DateTime CreatedAt { get; set; }\n        public string? RenderedBody { get; set; }\n        public Guid? CampaignId { get; set; }\n        public string? CampaignName { get; set; }\n        public Guid? CTAFlowStepId { get; set; }\n        public Guid? CTAFlowConfigId { get; set; }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/MessageManagement/DTOs/WebhookStatusDto.cs",
      "sha256": "aeb1bd281f5cc025fcc6c5a2a924daf3078c9e774d3fad3860626f871caad053",
      "language": "csharp",
      "size": 1324,
      "content": "namespace xbytechat.api.Features.MessageManagement.DTOs\n{\n    public class WebhookStatusDto\n    {\n        public List<StatusObject> statuses { get; set; }\n    }\n\n    public class StatusObject\n    {\n        public string id { get; set; }                     // Message ID (WAMID)\n        public string status { get; set; }                 // sent, delivered, read, failed\n        public long timestamp { get; set; }                // UNIX timestamp\n        public string recipient_id { get; set; }           // Phone number\n        public ConversationInfo conversation { get; set; }\n        public PricingInfo pricing { get; set; }\n        public List<ErrorInfo>? errors { get; set; }\n    }\n\n    public class ConversationInfo\n    {\n        public string id { get; set; }\n        public Origin origin { get; set; }\n    }\n\n    public class Origin\n    {\n        public string type { get; set; }                   // marketing, utility, etc.\n    }\n\n    public class PricingInfo\n    {\n        public bool billable { get; set; }\n        public string pricing_model { get; set; }\n        public string category { get; set; }               // Template category\n    }\n\n    public class ErrorInfo\n    {\n        public int code { get; set; }\n        public string title { get; set; }\n        public string details { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessageManagement/Models/MessageStatusLog.cs",
      "sha256": "9cebe2bfe3d8ca39e43e1fc51c5435e8c2fc47c9d7c2ef51e03a8de164770c8f",
      "language": "csharp",
      "size": 1906,
      "content": "using System.ComponentModel.DataAnnotations.Schema;\nusing System.ComponentModel.DataAnnotations;\nusing xbytechat.api.AuthModule.Models;\nusing xbytechat.api.Features.CampaignModule.Models;\nusing xbytechat.api.Features.BusinessModule.Models;\n\n\nnamespace xbytechat.api.Features.MessageManagement.DTOs\n{\n    public class MessageStatusLog\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        // üîó Who is it for\n        public string RecipientNumber { get; set; }\n        public string? CustomerProfileName { get; set; }\n\n        // üì© WhatsApp Message Info\n       // [ForeignKey(nameof(Message))]\n        public string? MessageId { get; set; } // WAMID\n\n       // public MessageLog? Message { get; set; }\n        public string Status { get; set; }\n        public string MessageType { get; set; }\n\n        // üßæ Template Info\n        public string? TemplateName { get; set; }\n        public string? TemplateCategory { get; set; }\n\n        // üß† Analytics/Reporting\n        public string Channel { get; set; } = \"whatsapp\";\n        public bool IsSessionOpen { get; set; }\n        public long? MetaTimestamp { get; set; }\n\n        // üïí Timestamps\n        public DateTime? SentAt { get; set; }\n        public DateTime? DeliveredAt { get; set; }\n        public DateTime? ReadAt { get; set; }\n\n        // ‚ùå Error Tracking\n        public string? ErrorMessage { get; set; }\n        public int? ErrorCode { get; set; }\n\n        // üîç Raw Log (for audit/debug)\n        public string? RawPayload { get; set; }\n\n        // üîó Foreign Keys\n        public Guid? CampaignId { get; set; }\n        public Campaign? Campaign { get; set; }\n\n        public Guid? BusinessId { get; set; }\n        public Business? Business { get; set; }\n\n        public Guid? UserId { get; set; }\n        public User? User { get; set; }\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n  \n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessageManagement/Services/IMessageStatusService.cs",
      "sha256": "cca96e16b96ab978d9e4c344d9a12a8377da0c701b18ea3e5e1bb981d1d6578a",
      "language": "csharp",
      "size": 262,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.MessageManagement.DTOs;\n\nnamespace xbytechat.api.Features.MessageManagement.Services\n{\n    public interface IMessageStatusService\n    {\n        Task LogWebhookStatusAsync(WebhookStatusDto dto);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessageManagement/Services/MessageStatusService.cs",
      "sha256": "f68c41d4a80e28d1b1de9da188c8b43c756b495494588de6fd11c8275d59a544",
      "language": "csharp",
      "size": 2755,
      "content": "using System;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.MessageManagement.DTOs;\nusing xbytechat.api.Features.MessageManagement.Services;\nusing xbytechat.api.Features.CampaignModule.Models;\nusing xbytechat.api.Models.BusinessModel;\nusing xbytechat.api.AuthModule.Models;\nusing Microsoft.EntityFrameworkCore;\n\nnamespace xbytechat.api.Features.MessageManagement.Services\n{\n    public class MessageStatusService : IMessageStatusService\n    {\n        private readonly AppDbContext _context;\n        private readonly ILogger<MessageStatusService> _logger;\n\n        public MessageStatusService(AppDbContext context, ILogger<MessageStatusService> logger)\n        {\n            _context = context;\n            _logger = logger;\n        }\n\n        public async Task LogWebhookStatusAsync(WebhookStatusDto dto)\n        {\n            foreach (var status in dto.statuses)\n            {\n                var log = new MessageStatusLog\n                {\n                    Id = Guid.NewGuid(),\n                    MessageId = status.id,\n                    Status = status.status.ToLower(),\n                    RecipientNumber = status.recipient_id,\n                    MetaTimestamp = status.timestamp,\n                    TemplateCategory = status?.pricing?.category,\n                    MessageType = status?.conversation?.origin?.type ?? \"session\",\n                    Channel = \"whatsapp\",\n                    CreatedAt = DateTime.UtcNow,\n                    RawPayload = System.Text.Json.JsonSerializer.Serialize(status)\n                };\n\n                var statusTime = DateTimeOffset.FromUnixTimeSeconds(status.timestamp).UtcDateTime;\n\n                switch (status.status.ToLower())\n                {\n                    case \"sent\": log.SentAt = statusTime; break;\n                    case \"delivered\": log.DeliveredAt = statusTime; break;\n                    case \"read\": log.ReadAt = statusTime; break;\n                }\n\n                if (status.errors != null && status.errors.Count > 0)\n                {\n                    log.ErrorMessage = status.errors[0].details;\n                    log.ErrorCode = status.errors[0].code;\n                }\n\n                await _context.MessageStatusLogs.AddAsync(log);\n            }\n\n            // ‚õëÔ∏è Wrap in try-catch and log full inner exception\n            try\n            {\n                await _context.SaveChangesAsync();\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(\"‚ùå SaveChangesAsync failed: \" + ex.Message);\n                _logger.LogError(\"‚ùå Inner exception: \" + ex.InnerException?.Message);\n                throw;\n            }\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/Abstractions/IWhatsAppProvider.cs",
      "sha256": "25a1b1105d245abb3cf620574e2cca3c0da007884f8ba8a062c2cd4724b88022",
      "language": "csharp",
      "size": 1124,
      "content": "// üìÑ File: Features/MessagesEngine/Abstractions/IWhatsAppProvider.cs\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.MessagesEngine.Abstractions\n{\n   \n    public interface IWhatsAppProvider\n    {\n        Task<WaSendResult> SendTextAsync(string to, string body);\n        Task<WaSendResult> SendTemplateAsync(string to, string templateName, string languageCode, IEnumerable<object> components);\n        Task<WaSendResult> SendInteractiveAsync(object fullPayload); // prebuilt object (e.g., image + CTA)\n    }\n}\n\n\n\n//namespace xbytechat.api.Features.MessagesEngine.Abstractions\n//{\n//    public interface IWhatsAppProvider\n//    {\n//        string Provider { get; }\n\n//        Task<WaSendResult> SendTextAsync(string to, string body, CancellationToken ct = default);\n\n//        Task<WaSendResult> SendTemplateAsync(string to, string templateName, string language, object? components, CancellationToken ct = default);\n\n//        // Optional: interactive/image+CTA\n//        Task<WaSendResult> SendInteractiveAsync(object payload, CancellationToken ct = default);\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/Abstractions/WaSendResult.cs",
      "sha256": "cbdf2f4ea14dafdbfd281c92d4701d11b385c52c89785faa04d1848b6af5bd8f",
      "language": "csharp",
      "size": 320,
      "content": "using System.Net;\n\nnamespace xbytechat.api.Features.MessagesEngine.Abstractions\n{\n    public record WaSendResult(\n        bool Success,\n        string Provider,\n        string? ProviderMessageId = null,\n        HttpStatusCode? StatusCode = null,\n        string? RawResponse = null,\n        string? Error = null\n    );\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/Abstractions/WaSendTemplate.cs",
      "sha256": "ce04cfc0e5abaca6ef42cf5593159791a9ae093be9b7399eae4442252b2362bd",
      "language": "csharp",
      "size": 378,
      "content": "using System;\n\nnamespace xbytechat.api.Features.MessagesEngine.Abstractions\n{\n    public class WaSendTemplate\n    {\n        public Guid BusinessId { get; init; }\n        public string To { get; init; } = \"\";\n        public string TemplateName { get; init; } = \"\";\n        public string Language { get; init; } = \"en_US\";\n        public object? Components { get; init; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/Abstractions/WaSendText.cs",
      "sha256": "192ded7365dc037581055e12a8e00816487953e786e107447465183e8e0f83a7",
      "language": "csharp",
      "size": 260,
      "content": "using System;\n\nnamespace xbytechat.api.Features.MessagesEngine.Abstractions\n{\n    public class WaSendText\n    {\n        public Guid BusinessId { get; init; }\n        public string To { get; init; } = \"\";\n        public string Body { get; init; } = \"\";\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/Contracts/MessageEnvelope.cs",
      "sha256": "7d9a3c2180154a34b5c48dbcc92d2b9ce3affbcadaacba097bba0eae1af2925e",
      "language": "csharp",
      "size": 648,
      "content": "using System.Collections.Generic;\n\nnamespace xbytechat.api.Features.MessagesEngine.Contracts\n{\n    /// <summary>\n    /// Provider-agnostic message envelope. Maps to Meta/Pinbot under the hood.\n    /// </summary>\n    public sealed record MessageEnvelope(\n        string To,\n        string Kind,                       // \"text\" | \"template\" | \"interactive\"\n        string? TemplateName = null,\n        string LanguageCode = \"en_US\",\n        List<object>? Components = null,    // template components\n        object? Interactive = null,         // interactive payload (if any)\n        string? TextBody = null,\n        string? ImageUrl = null\n    );\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/Controllers/MessageEngineController.cs",
      "sha256": "dccc3a3007e5829ebb5161cc80da73208b3eec3a715695a0e4c467584bb87735",
      "language": "csharp",
      "size": 8267,
      "content": "\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing System.Security.Claims;\nusing System.Text.Json;\nusing xbytechat.api.DTOs.Messages;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.Features.ReportingModule.Services;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.MessagesEngine.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize]\n    public class MessageEngineController : ControllerBase\n    {\n        private readonly IMessageEngineService _messageEngineService;\n        private readonly IMessageAnalyticsService _messageAnalyticsServiceervice;\n\n\n        public MessageEngineController(IMessageEngineService messageService, IMessageAnalyticsService messageAnalyticsService)\n        {\n            _messageEngineService = messageService;\n            _messageAnalyticsServiceervice = messageAnalyticsService;\n        }\n        //[HttpPost(\"send-contentfree-text\")]\n        //public async Task<IActionResult> SendTextMessage([FromBody] TextMessageSendDto dto)\n        //{\n        //    if (!ModelState.IsValid)\n        //        return BadRequest(ResponseResult.ErrorInfo(\"‚ùå Invalid text message payload.\"));\n\n        //    try\n        //    {\n        //        var result = await _messageEngineService.SendTextDirectAsync(dto); // üëà New direct method\n\n        //        return result.Success\n        //            ? Ok(result)\n        //            : BadRequest(ResponseResult.ErrorInfo(result.Message, result.RawResponse));\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        Console.WriteLine($\"‚ùå Exception while sending text message: {ex.Message}\");\n        //        return StatusCode(500, ResponseResult.ErrorInfo(\"üö® Server error while sending text message.\", ex.ToString()));\n        //    }\n        //}\n        [HttpPost(\"send-contentfree-text\")]\n        public async Task<IActionResult> SendTextMessage([FromBody] TextMessageSendDto dto)\n        {\n            // 0) Null/body guard\n            if (dto is null)\n                return BadRequest(ResponseResult.ErrorInfo(\n                    \"‚ùå Invalid request body.\",\n                    \"Request JSON was null or malformed.\"));\n\n            // 1) Minimal required-field validation (provider is optional here)\n            var missing = new List<string>();\n            if (string.IsNullOrWhiteSpace(dto.RecipientNumber)) missing.Add(\"recipientNumber\");\n            if (string.IsNullOrWhiteSpace(dto.TextContent)) missing.Add(\"textContent\");\n\n            if (missing.Count > 0)\n            {\n                return BadRequest(ResponseResult.ErrorInfo(\n                    \"‚ùå Invalid text message payload.\",\n                    $\"Missing/empty: {string.Join(\", \", missing)}\"\n                ));\n            }\n\n            // 2) Diagnostics while debugging\n            Console.WriteLine($\"[SendTextMessage] Incoming: {JsonSerializer.Serialize(dto)}\");\n            Console.WriteLine($\"[SendTextMessage] provider(raw)='{dto.Provider}' phoneNumberId(raw)='{dto.PhoneNumberId}'\");\n\n            try\n            {\n                // 3) Delegate to service (service will resolve provider if missing)\n                var result = await _messageEngineService.SendTextDirectAsync(dto);\n\n                // 4) Return exactly what service produced\n                return result.Success ? Ok(result) : BadRequest(result);\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"‚ùå Exception while sending text message: {ex}\");\n                return StatusCode(500, ResponseResult.ErrorInfo(\n                    \"üö® Server error while sending text message.\", ex.ToString()));\n            }\n        }\n        [HttpPost(\"send-template-simple\")]\n        public async Task<IActionResult> SendTemplateMessageSimple([FromBody] SimpleTemplateMessageDto dto)\n        {\n            if (!ModelState.IsValid)\n                return BadRequest(ResponseResult.ErrorInfo(\"‚ùå Invalid template message request.\"));\n\n            try\n            {\n                var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n                if (!Guid.TryParse(businessIdClaim, out Guid businessId))\n                    return Unauthorized(ResponseResult.ErrorInfo(\"‚ùå Business ID not found in token.\"));\n\n                var result = await _messageEngineService.SendTemplateMessageSimpleAsync(businessId, dto);\n\n                return result.Success\n                    ? Ok(result)\n                    : BadRequest(ResponseResult.ErrorInfo(result.Message ?? \"‚ùå Failed to send template.\", result.RawResponse));\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"‚ùå Exception while sending template: {ex.Message}\");\n                return StatusCode(500, ResponseResult.ErrorInfo(\"üö® Server error while sending template.\", ex.ToString()));\n            }\n        }\n\n\n        [HttpPost(\"send-image-campaign/{campaignId}\")]\n        public async Task<IActionResult> SendImageCampaign(Guid campaignId)\n        {\n            try\n            {\n                var businessId = UserClaimHelper.GetBusinessId(User); // ‚úÖ from\n                                                                      // claims\n                var userName = UserClaimHelper.GetUserName(User);     // for logging (if needed)\n\n                var result = await _messageEngineService.SendImageCampaignAsync(campaignId, businessId, userName);\n\n                return result.Success\n                    ? Ok(result)\n                    : BadRequest(result);\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(\"‚ùå Error while sending image campaign: \" + ex.Message);\n                return StatusCode(500, ResponseResult.ErrorInfo(\"Server error while sending campaign.\", ex.ToString()));\n            }\n        }\n        public static class UserClaimHelper\n        {\n            public static Guid GetBusinessId(ClaimsPrincipal user)\n            {\n                var claim = user.Claims.FirstOrDefault(c => c.Type == \"businessId\");\n                return claim != null ? Guid.Parse(claim.Value) : Guid.Empty;\n            }\n\n            public static string GetUserName(ClaimsPrincipal user)\n            {\n                return user?.Identity?.Name ?? \"Unknown\";\n            }\n        }\n\n        [HttpPost(\"send-image-template\")]\n        public async Task<IActionResult> SendImageTemplateMessage([FromBody] ImageTemplateMessageDto dto)\n        {\n            Guid businessId;\n            try\n            {\n                businessId = User.GetBusinessId(); // Uses your extension method!\n            }\n            catch (UnauthorizedAccessException ex)\n            {\n                return Unauthorized(new { message = ex.Message });\n            }\n\n            var result = await _messageEngineService.SendImageTemplateMessageAsync(dto, businessId);\n\n            if (result.Success)\n                return Ok(new { message = result.Message, raw = result.RawResponse });\n\n            return BadRequest(new { message = result.Message, raw = result.RawResponse });\n        }\n\n\n        //[HttpPost(\"send-video-template\")]\n        //public async Task<IActionResult> SendVideoTemplateMessage([FromBody] VideoTemplateMessageDto dto)\n        //{\n        //    Guid businessId;\n        //    try { businessId = User.GetBusinessId(); }\n        //    catch (UnauthorizedAccessException ex) { return Unauthorized(new { message = ex.Message }); }\n\n        //    var result = await _messageEngineService.SendVideoTemplateMessageAsync(dto, businessId);\n        //    return result.Successin\n        //        ? Ok(new { message = result.Message, raw = result.RawResponse })\n        //        : BadRequest(new { message = result.Message, raw = result.RawResponse });\n        //}\n\n        [HttpGet(\"recent\")]\n        public async Task<IActionResult> GetRecentLogs([FromQuery] int limit = 20)\n        {\n            var businessId = User.GetBusinessId();\n            var logs = await _messageAnalyticsServiceervice.GetRecentLogsAsync(businessId, limit);\n            return Ok(new { success = true, data = logs });\n        }\n\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/DTOs/AutoSendTemplateMessageDto.cs",
      "sha256": "99519bdaed8df38337d3485148cfc53b4972c2616ebb386417321455ad582576",
      "language": "csharp",
      "size": 422,
      "content": "namespace xbytechat.api.Features.MessagesEngine.DTOs\n{\n    public class AutoSendTemplateMessageDto\n    {\n        public Guid BusinessId { get; set; }\n        public Guid ContactId { get; set; }\n        public string PhoneNumber { get; set; }\n        public Guid TemplateId { get; set; }\n        public string TemplateName { get; set; }\n        public Dictionary<string, string> Placeholders { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/DTOs/CtaButtonDto.cs",
      "sha256": "60ecf5aa33d787f635ef05f11c48b8f9f6a11d48b2d7322f7f2ef575b91f9657",
      "language": "csharp",
      "size": 307,
      "content": "namespace xbytechat.api.Features.MessagesEngine.DTOs\n{\n    public class CtaButtonDto\n    {\n        public string Title { get; set; } = string.Empty; // e.g., \"Buy Now\", \"View Details\"\n        public string Type { get; set; } = string.Empty;\n        public string Value { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/DTOs/DocumentTemplateDto.cs",
      "sha256": "bbda0a8069d8f5d2cd55009d1276b85f5ba6bd077a0c8c41cb055431dbed2507",
      "language": "csharp",
      "size": 161,
      "content": "namespace xbytechat.api.Features.MessagesEngine.DTOs\n{\n    public class DocumentTemplateDto\n    {\n        public string? HeaderDocumentUrl { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/DTOs/DocumentTemplateMessageDto.cs",
      "sha256": "d1661773f6bc14badc4979362169c3170319abbebf19ca7b004eecab4a377a1f",
      "language": "csharp",
      "size": 1813,
      "content": "using System;\nusing System.Collections.Generic;\nusing xbytechat.api.Features.CampaignModule.DTOs; // for CampaignButtonDto in this folder\n\nnamespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    /// <summary>\n    /// Payload for sending a template with a DOCUMENT header.\n    /// Aliases provided so code using Parameters/Buttons OR TemplateParameters/ButtonParameters compiles.\n    /// </summary>\n    public sealed class DocumentTemplateMessageDto\n    {\n        public Guid BusinessId { get; set; }\n\n        // Routing / provider\n        public string? Provider { get; set; }            // \"META\" | \"PINNACLE\"\n        public string? PhoneNumberId { get; set; }       // Meta WABA phone id (sender)\n\n        // Recipient & template identity\n        public string RecipientNumber { get; set; } = \"\"; // E.164\n        public string TemplateName { get; set; } = \"\";\n        public string LanguageCode { get; set; } = \"en_US\";\n\n        // Header\n        public string? HeaderDocumentUrl { get; set; }\n\n        // Body params (ordered {{1}}..)\n        public List<string> Parameters { get; set; } = new();\n        // Alias for older call sites\n        public List<string> TemplateParameters\n        {\n            get => Parameters;\n            set => Parameters = value ?? new List<string>();\n        }\n\n        // Buttons (we use your actual CampaignButtonDto: ButtonText, ButtonType, TargetUrl)\n        public List<CampaignButtonDto> Buttons { get; set; } = new();\n        // Alias for older call sites\n        public List<CampaignButtonDto> ButtonParameters\n        {\n            get => Buttons;\n            set => Buttons = value ?? new List<CampaignButtonDto>();\n        }\n\n        // Optional extras\n        public Guid? CTAFlowConfigId { get; set; }\n        public string? TemplateBody { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/DTOs/ImageTemplateMessageDto.cs",
      "sha256": "471132fb66303d77584686def7af22e2365d5b68d32a950f9582f245c966452c",
      "language": "csharp",
      "size": 861,
      "content": "using System.ComponentModel.DataAnnotations;\nusing xbytechat.api.Features.CampaignModule.DTOs;\n\npublic class ImageTemplateMessageDto\n{\n    public Guid BusinessId { get; set; }\n    public string RecipientNumber { get; set; }\n    public string TemplateName { get; set; }\n    public string LanguageCode { get; set; } = \"en_US\";\n    public string HeaderImageUrl { get; set; }\n    public List<string> TemplateParameters { get; set; } = new();\n    public List<CampaignButtonDto> ButtonParameters { get; set; } = new();\n\n    // ‚úÖ Add these two for flow tracking\n    public Guid? CTAFlowConfigId { get; set; }\n    public Guid? CTAFlowStepId { get; set; }\n    public string? TemplateBody { get; set; }\n\n\n   // [RegularExpression(\"^(PINNACLE|META_CLOUD)$\")]\n    public string Provider { get; set; } = string.Empty;\n    public string? PhoneNumberId { get; set; }\n   \n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/DTOs/LocationMessageSendDto.cs",
      "sha256": "6271589eca1e4c87f9ed1fd81a944fc8d525f1be24135bddc32a8d49936dae3f",
      "language": "csharp",
      "size": 709,
      "content": "using System;\n\nnamespace xbytechat.api.Features.MessagesEngine.DTOs\n{\n    public sealed class LocationMessageSendDto\n    {\n        public Guid BusinessId { get; set; }\n        public string RecipientNumber { get; set; } = string.Empty;\n\n        public Guid ContactId { get; set; }\n        public string? PhoneNumberId { get; set; }\n        public string? Provider { get; set; } // defaults to business sender; keep for parity with other DTOs\n        public string? Source { get; set; }   // \"agent\" | \"automation\" | etc.\n\n        public double Latitude { get; set; }\n        public double Longitude { get; set; }\n        public string? Name { get; set; }\n        public string? Address { get; set; }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/DTOs/MediaMessageSendDto.cs",
      "sha256": "fe0520f49f7183562324c8952f8e8392fe027ef986c6054276850c7c3665d152",
      "language": "csharp",
      "size": 1034,
      "content": "using System;\n\nnamespace xbytechat.api.Features.MessagesEngine.DTOs\n{\n    public sealed class MediaMessageSendDto\n    {\n        public Guid BusinessId { get; set; }\n\n        public string RecipientNumber { get; set; } = string.Empty;\n\n        /// <summary>\n        /// WhatsApp Cloud API media_id (returned by /{phone_number_id}/media).\n        /// </summary>\n        public string MediaId { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Optional caption.\n        /// </summary>\n        public string? Caption { get; set; }\n\n        /// <summary>\n        /// Optional filename (recommended for documents).\n        /// </summary>\n        public string? FileName { get; set; }\n\n        /// <summary>\n        /// Optional mime type for logging/display.\n        /// </summary>\n        public string? MimeType { get; set; }\n\n        public Guid ContactId { get; set; }\n\n        public string? PhoneNumberId { get; set; }\n\n        public string? Provider { get; set; }\n\n        public string? Source { get; set; }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/DTOs/MessageTypeEnum.cs",
      "sha256": "d3120f117dc16b8ab9901ba3726defab664b2a9b4a5414eff586e7e27f55062a",
      "language": "csharp",
      "size": 286,
      "content": "using System.Text.Json.Serialization;\n\nnamespace xbytechat.api.Features.MessagesEngine.DTOs\n{\n    [JsonConverter(typeof(JsonStringEnumConverter))] // Enables string parsing in JSON\n    public enum MessageTypeEnum\n    {\n        Text,\n        Image,\n        Template,\n        Cta\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/DTOs/SendMessageDto.cs",
      "sha256": "5121018135042d9cdd9a4a404307559a8024ffa4bc1b851f346690fedb544886",
      "language": "csharp",
      "size": 2059,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.ComponentModel.DataAnnotations;\nusing xbytechat.api.Features.MessagesEngine.DTOs.Validation;\n\nnamespace xbytechat.api.Features.MessagesEngine.DTOs\n{\n    [ValidateMessageDto] // ‚úÖ Custom validator will enforce conditional field rules\n    public class SendMessageDto\n    {\n        [Required]\n        public Guid BusinessId { get; set; }\n\n        [Required]\n        [Phone]\n        public string RecipientNumber { get; set; } = string.Empty;\n\n        [Required]\n        public MessageTypeEnum MessageType { get; set; }\n\n        // üìù Text Message\n        public string? TextContent { get; set; }\n\n        // üñºÔ∏è Image Message\n        public string? MediaUrl { get; set; }\n\n        // üìã Template Message\n        public string? TemplateName { get; set; }\n        public Dictionary<string, string>? TemplateParameters { get; set; }\n\n        // üõí CTA Message\n        public List<CtaButtonDto>? CtaButtons { get; set; }\n\n        // ‚úÖ Required: this was missing [Optional but needed for CTA/Template message sending]\n        public List<string>? ButtonParams { get; set; }\n\n        // üìä Optional Metadata\n        public Guid? CampaignId { get; set; }\n        public Guid? CTAFlowConfigId { get; set; }\n        public Guid? CTAFlowStepId { get; set; }\n\n        public string? SourceModule { get; set; }\n        public string? CustomerId { get; set; }\n        public string? CustomerName { get; set; }\n        public string? CustomerPhone { get; set; }\n        public string? BotId { get; set; }\n        public string? RefMessageId { get; set; }\n        public string? CTATriggeredFrom { get; set; }\n        public DateTime? ScheduledAt { get; set; }\n\n        // ‚úÖ Add these two for flow tracking\n        public string? TemplateBody { get; set; }  // üî• Used to render actual message body from placeholders\n\n      //  [RegularExpression(\"^(PINNACLE|META_CLOUD)$\")]\n        public string Provider { get; set; } = string.Empty;\n\n        public string? PhoneNumberId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/DTOs/SendTemplateMessageSimpleDto.cs",
      "sha256": "00dc74bb6a1b396bab6fcd63f93454cfd59671260c4da8b0afd8754e83e10ce8",
      "language": "csharp",
      "size": 478,
      "content": "namespace xbytechat.api.Features.MessagesEngine.DTOs\n{\n    public class SendTemplateMessageSimpleDto\n    {\n        public Guid BusinessId { get; set; }\n        public string RecipientNumber { get; set; }\n        public string TemplateName { get; set; }\n        public List<string> TemplateParameters { get; set; } = new();\n        // ‚úÖ Add these two for flow tracking\n        public Guid? CTAFlowConfigId { get; set; }\n        public Guid? CTAFlowStepId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/DTOs/SimpleTemplateMessageDto.cs",
      "sha256": "37ca1b507cce96ca8c1244374ede5314948283794dabc3d4af5bfc610916b868",
      "language": "csharp",
      "size": 1503,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.ComponentModel.DataAnnotations;\nusing xbytechat.api.Features.MessagesEngine.Enums;\n\nnamespace xbytechat.api.Features.MessagesEngine.DTOs\n{\n    public class SimpleTemplateMessageDto\n    {\n        //public Guid BusinessId { get; set; }\n\n        public string RecipientNumber { get; set; }\n\n        public string TemplateName { get; set; }\n\n        public List<string> TemplateParameters { get; set; } = new();\n        public bool HasStaticButtons { get; set; } = false;\n\n        // Optional: media header support (image/video/document)\n        // HeaderKind is canonical lowercase: none | image | video | document | text\n        public string? HeaderKind { get; set; }\n        public string? HeaderMediaUrl { get; set; }\n\n        // Optional: dynamic URL button params (index 0..2). Send only non-empty values.\n        public List<string> UrlButtonParams { get; set; } = new();\n\n       // [RegularExpression(\"^(PINNACLE|META_CLOUD)$\")]\n        public string Provider { get; set; } = string.Empty;\n        public string? PhoneNumberId { get; set; }\n        // ‚úÖ Add these two for flow tracking\n        public Guid? CTAFlowConfigId { get; set; }\n        public Guid? CTAFlowStepId { get; set; }\n        public string? TemplateBody { get; set; }  // üî• Used to render actual message body from placeholders\n\n        public string? LanguageCode { get; set; }\n        public DeliveryMode DeliveryMode { get; set; } = DeliveryMode.Queue;\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/DTOs/TemplateForUIResponseDto.cs",
      "sha256": "8598c768ad7f753c61a4a2c296a18db6285c872705ca0b16a479b5d5bdedde55",
      "language": "csharp",
      "size": 626,
      "content": "using xbytechat.api.WhatsAppSettings.DTOs;\n\npublic class TemplateForUIResponseDto\n{\n    public string Name { get; set; }\n    public string Language { get; set; }\n    public string Body { get; set; }\n\n    // ‚úÖ Correct naming for frontend\n    public int ParametersCount { get; set; }\n\n    public List<ButtonMetadataDto> ButtonParams { get; set; }\n    public bool HasImageHeader { get; set; } // üÜï Used to detect image templates\n\n    public string? HeaderKind { get; set; }          // \"text\" | \"image\" | \"video\" | \"document\" | \"none\"\n    public bool RequiresHeaderMediaUrl { get; set; } // true for image/video/document\n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/DTOs/TextMessageSendDto.cs",
      "sha256": "4246f4f4e9b465b9590f78f3b822e7eb06f7def4e1a90e27165a68077bc414e5",
      "language": "csharp",
      "size": 991,
      "content": "using System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.MessagesEngine.DTOs\n{\n    public class TextMessageSendDto\n    {\n        public Guid BusinessId { get; set; }\n\n        public string RecipientNumber { get; set; }\n\n        public string TextContent { get; set; }\n\n        // Optional: allows UI to provide a preferred contact name when saving a new contact.\n        public string? ContactName { get; set; }\n\n        public Guid ContactId { get; set; }\n\n        public string? PhoneNumberId { get; set; }\n        // ‚úÖ NEW: Optional source indicator (e.g., \"campaign\", \"auto-reply\", etc.)\n\n        //[RegularExpression(\"^(PINNACLE|META_CLOUD)$\")]\n        //[Required]\n        public string Provider { get; set; } = string.Empty;\n        public string? Source { get; set; }\n\n        // ‚úÖ NEW: Optional message ID for campaign tracing\n        public string? MessageId { get; set; }\n\n        public bool IsSaveContact { get; set; } = false; // default true\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/DTOs/VideoTemplateMessageDto.cs",
      "sha256": "57c4f2a9a6c884efb7c3ec74c8674e04482aaaa04428ab6232a7ea3db1adc043",
      "language": "csharp",
      "size": 941,
      "content": "using System;\nusing System.Collections.Generic;\nusing xbytechat.api.Features.CampaignModule.DTOs;\n\npublic class VideoTemplateMessageDto\n{\n    public Guid BusinessId { get; set; }\n    public string RecipientNumber { get; set; } = string.Empty;\n\n    public string TemplateName { get; set; } = string.Empty;\n    public string LanguageCode { get; set; } = \"en_US\";\n\n    // mirrors HeaderImageUrl\n    public string? HeaderVideoUrl { get; set; }\n\n    public List<string> TemplateParameters { get; set; } = new();\n    public List<CampaignButtonDto> ButtonParameters { get; set; } = new();\n\n    // for flow tracking parity\n    public Guid? CTAFlowConfigId { get; set; }\n    public Guid? CTAFlowStepId { get; set; }\n    public string? TemplateBody { get; set; }\n\n    // same explicit provider knobs you already use\n    public string Provider { get; set; } = string.Empty; // \"PINNACLE\" | \"META_CLOUD\"\n    public string? PhoneNumberId { get; set; }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/Enums/DeliveryMode.cs",
      "sha256": "34b987a3b5ca838182dc0aeec507b3ed1a0641adc6c0aac7167feb2336f9e80d",
      "language": "csharp",
      "size": 501,
      "content": "using System.Collections;\n\nnamespace xbytechat.api.Features.MessagesEngine.Enums\n{\n    public enum DeliveryMode\n    {\n        /// <summary>\n        /// Default behaviour: enqueue into Outbox/worker.\n        /// Use this for campaigns, bulk sends, and scheduled jobs.\n        /// </summary>\n        Queue = 0,\n\n        /// <summary>\n        /// High-priority conversational sends:\n        /// call the WhatsApp provider directly inside the request.\n        /// </summary>\n        Immediate = 1\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/Factory/IWhatsAppProviderFactory.cs",
      "sha256": "342d4ace84b80c735c364b8ff654502fff27f1bfeb70eb78d5469879ec57ce1f",
      "language": "csharp",
      "size": 578,
      "content": "using System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.MessagesEngine.Abstractions;\n\nnamespace xbytechat.api.Features.MessagesEngine.Factory\n{\n    public interface IWhatsAppProviderFactory\n    {\n        //Task<IWhatsAppProvider> CreateAsync(Guid businessId, CancellationToken ct = default);\n        Task<IWhatsAppProvider> CreateAsync(Guid businessId);\n       //Task<IWhatsAppProvider> CreateAsync(Guid businessId, string? phoneNumberId);\n        Task<IWhatsAppProvider> CreateAsync(Guid businessId, string provider, string? phoneNumberId);\n\n    }\n}\n"
    }
  ]
}
