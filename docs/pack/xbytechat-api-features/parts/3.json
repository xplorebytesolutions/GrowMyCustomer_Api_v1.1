{
  "name": "xbytechat-api/Features",
  "part": 3,
  "of": 6,
  "generatedAt": "2026-02-11 19:15:17 +00:00",
  "files": [
    {
      "path": "xbytechat-api/Features/CampaignModule/Workers/OutboundSenderWorker.cs",
      "sha256": "331cf2348d4034bdd995f63bc3a02151a27a3e4853a280a60994e8c68913ab50",
      "language": "csharp",
      "size": 32501,
      "content": "// üìÑ File: Features/CampaignModule/Workers/OutboundSenderWorker.cs\nusing System;\nusing System.Collections.Concurrent;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Text.Json;\nusing System.Text.RegularExpressions;\nusing System.Threading;\nusing System.Threading.Channels;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Logging;\nusing Npgsql;\n\nusing xbytechat.api;\nusing xbytechat.api.Features.CampaignModule.Models;\nusing xbytechat.api.Features.CampaignTracking.Logging;\nusing xbytechat.api.Features.CampaignTracking.Models;\nusing xbytechat.api.Features.MessageLogging.Services;\nusing xbytechat.api.Features.MessagesEngine.Abstractions;\nusing xbytechat.api.Features.CampaignModule.SendEngine;\nusing xbytechat_api.Features.Billing.Services;\nusing xbytechat.api.Infrastructure.Observability;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.WhatsAppSettings.Helpers;\nusing xbytechat.api.AuthModule.Models;\n\nnamespace xbytechat.api.Features.CampaignModule.Workers\n{\n    public class OutboundSenderWorker : BackgroundService\n    {\n        private readonly IServiceProvider _sp;\n        private readonly ILogger<OutboundSenderWorker> _log;\n        private readonly Channel<OutboundMessageJob> _channel;\n        private const int DEFAULT_MAX_ATTEMPTS = 3;\n\n        // Concurrency caps\n        private readonly int _globalDop = 32;   // total parallel consumers\n        private readonly int _perNumberDop = 8; // per (provider, PhoneNumberId)\n\n        private readonly TimeSpan _pollInterval = TimeSpan.FromSeconds(1);\n        private static readonly TimeSpan _flightTimeout = TimeSpan.FromMinutes(5);\n\n        private int _inChannel;\n        private readonly Random _rand = new();\n\n        // =========================[ Template Button Cache + Parsers ]=========================\n        private static readonly ConcurrentDictionary<string, IReadOnlyList<ButtonMeta>> _btnCache =\n            new(StringComparer.Ordinal);\n\n        private static readonly Regex RxButtonTypeMeta = new(@\"^\\s*url\\s*$\", RegexOptions.IgnoreCase | RegexOptions.Compiled);\n        private static readonly Regex RxButtonTypePinn = new(@\"^\\s*url\\s*$\", RegexOptions.IgnoreCase | RegexOptions.Compiled);\n\n        private static string CacheKeyForTemplate(WhatsAppTemplate tpl)\n            => $\"{tpl.BusinessId}|{tpl.Provider}|{tpl.Name}|{tpl.LanguageCode}\".ToUpperInvariant();\n\n        private static IReadOnlyList<ButtonMeta> GetTemplateButtonsCached(WhatsAppTemplate tpl)\n            => _btnCache.GetOrAdd(CacheKeyForTemplate(tpl), _ => ParseButtonsFromTemplateRow(tpl));\n\n        private static IReadOnlyList<ButtonMeta> ParseButtonsFromTemplateRow(WhatsAppTemplate tpl)\n        {\n            if (!string.IsNullOrWhiteSpace(tpl.UrlButtons))\n            {\n                try\n                {\n                    using var doc = JsonDocument.Parse(tpl.UrlButtons);\n                    if (doc.RootElement.ValueKind == JsonValueKind.Array)\n                    {\n                        var list = new List<ButtonMeta>(capacity: 3);\n                        foreach (var el in doc.RootElement.EnumerateArray())\n                        {\n                            var text = el.TryGetProperty(\"ButtonText\", out var pText) ? pText.GetString() ?? \"\" :\n                                       el.TryGetProperty(\"Text\", out var pText2) ? pText2.GetString() ?? \"\" : \"\";\n                            var type = el.TryGetProperty(\"ButtonType\", out var pType) ? pType.GetString() ?? \"\" :\n                                       el.TryGetProperty(\"Type\", out var pType2) ? pType2.GetString() ?? \"\" : \"\";\n                            var url = el.TryGetProperty(\"TargetUrl\", out var pUrl) ? pUrl.GetString() : null;\n\n                            if (!string.IsNullOrWhiteSpace(text) && !string.IsNullOrWhiteSpace(type))\n                                list.Add(new ButtonMeta(text, type, url));\n                        }\n                        return list;\n                    }\n                }\n                catch { /* fallthrough */ }\n            }\n\n            if (!string.IsNullOrWhiteSpace(tpl.RawJson))\n            {\n                try\n                {\n                    using var doc = JsonDocument.Parse(tpl.RawJson);\n\n                    JsonElement comps = default;\n                    if (doc.RootElement.TryGetProperty(\"template\", out var tplNode) &&\n                        tplNode.TryGetProperty(\"components\", out var comps1))\n                    {\n                        comps = comps1;\n                    }\n                    else if (doc.RootElement.TryGetProperty(\"components\", out var comps2))\n                    {\n                        comps = comps2;\n                    }\n\n                    if (comps.ValueKind == JsonValueKind.Array)\n                    {\n                        var list = new List<ButtonMeta>(capacity: 3);\n\n                        foreach (var c in comps.EnumerateArray())\n                        {\n                            if (!c.TryGetProperty(\"type\", out var tProp)) continue;\n                            if (!string.Equals(tProp.GetString(), \"button\", StringComparison.OrdinalIgnoreCase)) continue;\n\n                            var isUrl =\n                                (c.TryGetProperty(\"sub_type\", out var st) && RxButtonTypeMeta.IsMatch(st.GetString() ?? \"\")) ||\n                                (c.TryGetProperty(\"subType\", out var st2) && RxButtonTypePinn.IsMatch(st2.GetString() ?? \"\"));\n\n                            if (!isUrl) continue;\n\n                            string text = \"Open\";\n                            string type = \"url\";\n                            string? url = null;\n\n                            if (c.TryGetProperty(\"parameters\", out var pars) && pars.ValueKind == JsonValueKind.Array)\n                            {\n                                foreach (var p in pars.EnumerateArray())\n                                {\n                                    if (p.TryGetProperty(\"text\", out var txtProp))\n                                    {\n                                        var v = txtProp.GetString();\n                                        if (!string.IsNullOrWhiteSpace(v)) { url = v; break; }\n                                    }\n                                }\n                            }\n\n                            list.Add(new ButtonMeta(text, type, url));\n                            if (list.Count >= 3) break;\n                        }\n\n                        return list;\n                    }\n                }\n                catch { /* ignore */ }\n            }\n\n            return Array.Empty<ButtonMeta>();\n        }\n        // =====================================================================================\n\n        public OutboundSenderWorker(IServiceProvider sp, ILogger<OutboundSenderWorker> log)\n        {\n            _sp = sp;\n            _log = log;\n\n            _channel = Channel.CreateBounded<OutboundMessageJob>(new BoundedChannelOptions(5000)\n            {\n                SingleReader = false,\n                SingleWriter = false,\n                FullMode = BoundedChannelFullMode.Wait\n            });\n        }\n\n\n\n        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n        {\n            using var cts = CancellationTokenSource.CreateLinkedTokenSource(stoppingToken);\n            var ct = cts.Token;\n\n            var consumers = Enumerable.Range(0, _globalDop)\n                .Select(_ => Task.Run(() => ConsumeAsync(ct), ct))\n                .ToArray();\n\n            var producer = Task.Run(() => ProduceAsync(ct), ct);\n\n            var all = consumers.Append(producer).ToArray();\n\n            try\n            {\n                await Task.WhenAll(all);\n            }\n            catch\n            {\n                try { cts.Cancel(); } catch { /* ignore */ }\n                throw;\n            }\n        }\n\n        private async Task ProduceAsync(CancellationToken ct)\n        {\n            const int ChannelCapacity = 5000;\n\n            var idleDelay = _pollInterval;\n            var maxIdleDelay = TimeSpan.FromSeconds(1);\n            var longIdleDelay = TimeSpan.FromSeconds(30);\n            int consecutiveEmpty = 0;\n\n            const string sql = @\"\nWITH cte AS (\n    SELECT \"\"Id\"\"\n    FROM \"\"OutboundMessageJobs\"\"\n    WHERE \"\"Status\"\" = 'Pending'\n      AND (\"\"NextAttemptAt\"\" IS NULL OR \"\"NextAttemptAt\"\" <= NOW())\n    ORDER BY \"\"NextAttemptAt\"\" NULLS FIRST, \"\"CreatedAt\"\"\n    FOR UPDATE SKIP LOCKED\n    LIMIT @take\n)\nUPDATE \"\"OutboundMessageJobs\"\" j\nSET \"\"Status\"\" = 'InFlight',\n    \"\"NextAttemptAt\"\" = NOW() + make_interval(secs => @flight),\n    \"\"LastError\"\" = NULL\nWHERE j.\"\"Id\"\" IN (SELECT \"\"Id\"\" FROM cte)\nRETURNING j.*;\";\n\n            try { await Task.Delay(_rand.Next(100, 500), ct); } catch { /* ignore */ }\n\n            while (!ct.IsCancellationRequested)\n            {\n                try\n                {\n                    using var scope = _sp.CreateScope();\n                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n\n                    var approxCount = Volatile.Read(ref _inChannel);\n                    var budget = Math.Max(0, ChannelCapacity - approxCount);\n\n                    if (budget <= 0)\n                    {\n                        await Task.Delay(idleDelay, ct);\n                        idleDelay = TimeSpan.FromMilliseconds(\n                            Math.Min(maxIdleDelay.TotalMilliseconds, idleDelay.TotalMilliseconds * 1.25)\n                        );\n                        continue;\n                    }\n\n                    // idleDelay = _pollInterval; // ‚ùå BAD: This was resetting the backoff every time!\n\n                    var take = Math.Min(budget, 2000);\n                    var flightSecs = (int)Math.Ceiling(_flightTimeout.TotalSeconds);\n\n                    var takeParam = new NpgsqlParameter<int>(\"take\", take);\n                    var flightParam = new NpgsqlParameter<int>(\"flight\", flightSecs);\n\n                    var prevTimeout = db.Database.GetCommandTimeout();\n                    db.Database.SetCommandTimeout(5);\n\n                    List<OutboundMessageJob> jobs;\n                    try\n                    {\n                        jobs = await db.OutboundMessageJobs\n                            .FromSqlRaw(sql, takeParam, flightParam)\n                            .AsNoTracking()\n                            .ToListAsync(ct);\n                    }\n                    finally\n                    {\n                        db.Database.SetCommandTimeout(prevTimeout);\n                    }\n\n                    foreach (var job in jobs)\n                    {\n                        await _channel.Writer.WriteAsync(job, ct);\n                        Interlocked.Increment(ref _inChannel);\n                    }\n\n                    if (jobs.Count == 0)\n                    {\n                        consecutiveEmpty++;\n                        var jitterMs = _rand.Next(0, 200);\n                        var delay = idleDelay + TimeSpan.FromMilliseconds(jitterMs);\n\n                        if (consecutiveEmpty >= 8 && idleDelay >= maxIdleDelay)\n                            delay = longIdleDelay + TimeSpan.FromMilliseconds(jitterMs);\n\n                        await Task.Delay(delay, ct);\n\n                        if (idleDelay < maxIdleDelay)\n                        {\n                            idleDelay = TimeSpan.FromMilliseconds(\n                                Math.Min(maxIdleDelay.TotalMilliseconds, idleDelay.TotalMilliseconds * 2)\n                            );\n                        }\n                    }\n                    else\n                    {\n                        consecutiveEmpty = 0;\n                        idleDelay = _pollInterval; // ‚úÖ Correct: Reset only when we found work\n                    }\n                }\n                catch (TaskCanceledException)\n                {\n                }\n                catch (Exception ex)\n                {\n                    _log.LogError(ex, \"[Outbox] Producer loop error\");\n                    try { await Task.Delay(TimeSpan.FromSeconds(2), ct); } catch { /* ignore */ }\n                }\n            }\n        }\n\n        // ---- keyed concurrency gate (per sender) ---------------------------------------\n        private sealed class KeyedSemaphore\n        {\n            private readonly ConcurrentDictionary<string, SemaphoreSlim> _map = new();\n            public async Task<IDisposable> AcquireAsync(string key, int dop, CancellationToken ct)\n            {\n                var sem = _map.GetOrAdd(key, _ => new SemaphoreSlim(dop));\n                await sem.WaitAsync(ct);\n                return new Releaser(sem);\n            }\n            private sealed class Releaser : IDisposable\n            {\n                private readonly SemaphoreSlim _s;\n                public Releaser(SemaphoreSlim s) => _s = s;\n                public void Dispose() => _s.Release();\n            }\n        }\n        private static readonly KeyedSemaphore _perSenderGate = new();\n        // -------------------------------------------------------------------------------\n\n        // Best-effort extraction of provider message id from a Meta success body\n        private static string? TryExtractProviderMessageId(string? raw)\n        {\n            if (string.IsNullOrWhiteSpace(raw)) return null;\n            try\n            {\n                using var doc = JsonDocument.Parse(raw);\n                if (doc.RootElement.TryGetProperty(\"messages\", out var msgs) &&\n                    msgs.ValueKind == JsonValueKind.Array &&\n                    msgs.GetArrayLength() > 0 &&\n                    msgs[0].TryGetProperty(\"id\", out var idProp))\n                {\n                    return idProp.GetString();\n                }\n            }\n            catch { /* ignore */ }\n            return null;\n        }\n\n        private async Task ConsumeAsync(CancellationToken ct)\n        {\n            static async Task<(string Phone, Guid? ContactId, string? ContactName)> ResolveRecipientAsync(\n     AppDbContext db, Guid recipientId, CancellationToken ct2)\n            {\n                var row = await db.CampaignRecipients\n                    .AsNoTracking()\n                    .Where(r => r.Id == recipientId)\n                    .Select(r => new\n                    {\n                        Phone = r.Contact != null\n                            ? r.Contact.PhoneNumber\n                            : (r.AudienceMember != null ? (r.AudienceMember.PhoneE164 ?? r.AudienceMember.PhoneRaw) : null),\n\n                        ContactId = (Guid?)(r.Contact != null ? r.Contact.Id : null),\n                        ContactName = r.Contact != null ? r.Contact.Name : null\n                    })\n                    .FirstOrDefaultAsync(ct2);\n\n                return (row?.Phone ?? string.Empty, row?.ContactId, row?.ContactName);\n            }\n\n            while (await _channel.Reader.WaitToReadAsync(ct))\n            {\n                if (!_channel.Reader.TryRead(out var job))\n                    continue;\n\n                Interlocked.Decrement(ref _inChannel);\n\n                try\n                {\n                    using var scope = _sp.CreateScope();\n                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n                    var engine = scope.ServiceProvider.GetRequiredService<IMessageEngineService>();\n                    var billing = scope.ServiceProvider.GetRequiredService<IBillingIngestService>();\n                    var logger = scope.ServiceProvider.GetRequiredService<ILogger<OutboundSenderWorker>>();\n                    var logSink = scope.ServiceProvider.GetRequiredService<ICampaignLogSink>();\n                    var limiter = scope.ServiceProvider.GetRequiredService<xbytechat.api.Infrastructure.RateLimiting.IPhoneNumberRateLimiter>();\n                    var messageLogSink = scope.ServiceProvider.GetRequiredService<IMessageLogSink>();\n                    var builder = scope.ServiceProvider.GetRequiredService<ITemplatePayloadBuilder>();\n                    var validator = scope.ServiceProvider.GetRequiredService<ICampaignSendValidator>();\n\n                    var senderKey = $\"{job.Provider}|{job.PhoneNumberId}\";\n\n                    using (await _perSenderGate.AcquireAsync(senderKey, _perNumberDop, ct))\n                    {\n                        var lease = await limiter.AcquireAsync(senderKey, ct);\n                        if (!lease.IsAcquired)\n                        {\n                            await Task.Delay(50, ct);\n                            continue;\n                        }\n\n                        var (recipientPhone, contactId, contactName) = await ResolveRecipientAsync(db, job.RecipientId, ct);\n\n                        if (string.IsNullOrWhiteSpace(recipientPhone))\n                        {\n                            job.Status = \"Failed\";\n                            job.Attempt += 1;\n                            job.LastError = \"Recipient phone not found.\";\n                            var backoff1 = (int)Math.Min(60, Math.Pow(2, job.Attempt) * 2);\n                            job.NextAttemptAt = DateTime.UtcNow.AddSeconds(backoff1);\n                            db.Update(job);\n                            await db.SaveChangesAsync(ct);\n\n                            logger.LogWarning(\"[Outbox] Recipient phone not found. job={JobId} recipient={RecipientId}\", job.Id, job.RecipientId);\n                            MetricsRegistry.MessagesFailed.Add(1);\n                            continue;\n                        }\n\n                        var lang = job.LanguageCode ?? \"en_US\";\n                        var tmplRow = await db.WhatsAppTemplates\n                            .AsNoTracking()\n                            .FirstOrDefaultAsync(t =>\n                                t.BusinessId == job.BusinessId &&\n                                t.Provider == job.Provider &&\n                                t.Name == job.TemplateName &&\n                                t.LanguageCode == lang,\n                                ct);\n\n                        if (tmplRow == null)\n                        {\n                            job.Status = \"Failed\";\n                            job.Attempt += 1;\n                            job.LastError = $\"Template not found: {job.TemplateName} ({lang}) for {job.Provider}.\";\n                            var backoff = (int)Math.Min(60, Math.Pow(2, job.Attempt) * 2);\n                            job.NextAttemptAt = DateTime.UtcNow.AddSeconds(backoff);\n                            db.Update(job);\n                            await db.SaveChangesAsync(ct);\n\n                            logger.LogWarning(\"[Outbox] Template not found. job={JobId} template={Template} lang={Lang} provider={Provider}\",\n                                job.Id, job.TemplateName, lang, job.Provider);\n                            MetricsRegistry.MessagesFailed.Add(1);\n                            continue;\n                        }\n\n                        HeaderKind headerKind = tmplRow.HeaderKind?.ToLowerInvariant() switch\n                        {\n                            \"text\" => HeaderKind.Text,\n                            \"image\" => HeaderKind.Image,\n                            \"video\" => HeaderKind.Video,\n                            \"document\" => HeaderKind.Document,\n                            \"none\" or null => HeaderKind.None,\n                            _ => HeaderKind.None\n                        };\n                        if (headerKind == HeaderKind.None && !string.IsNullOrWhiteSpace(job.MediaType))\n                        {\n                            headerKind = job.MediaType.ToLowerInvariant() switch\n                            {\n                                \"text\" => HeaderKind.Text,\n                                \"image\" => HeaderKind.Image,\n                                \"video\" => HeaderKind.Video,\n                                \"document\" => HeaderKind.Document,\n                                _ => HeaderKind.None\n                            };\n                        }\n\n                        var providerEnum = ProviderUtil.Parse(job.Provider);\n                        var buttonsFromTemplate = GetTemplateButtonsCached(tmplRow);\n\n                        var plan = new SendPlan(\n                            BusinessId: job.BusinessId,\n                            Provider: providerEnum,\n                            PhoneNumberId: job.PhoneNumberId!,\n                            TemplateName: job.TemplateName!,\n                            LanguageCode: lang,\n                            HeaderKind: headerKind,\n                            HeaderUrl: job.HeaderMediaUrl,\n                            Buttons: buttonsFromTemplate\n                        );\n\n                        var recipient = new RecipientPlan(\n                            RecipientId: job.RecipientId,\n                            ToPhoneE164: recipientPhone,\n                            ParametersJson: job.ResolvedParamsJson ?? \"[]\",\n                            ButtonParamsJson: job.ResolvedButtonUrlsJson,\n                            IdempotencyKey: job.IdempotencyKey ?? $\"{job.CampaignId}:{recipientPhone}:{job.TemplateName}\"\n                        );\n\n                        var envelope = builder.Build(plan, recipient);\n\n                        var (ok, error) = validator.Validate(plan, recipient, envelope, tmplRow);\n                        if (!ok)\n                        {\n                            job.Status = \"Failed\";\n                            job.Attempt += 1;\n                            job.LastError = error ?? \"Validation failed.\";\n                            var backoff = (int)Math.Min(60, Math.Pow(2, job.Attempt) * 2);\n                            job.NextAttemptAt = DateTime.UtcNow.AddSeconds(backoff);\n                            db.Update(job);\n                            await db.SaveChangesAsync(ct);\n\n                            logger.LogWarning(\"[Outbox] Validation failed job={JobId} error={Error}\", job.Id, job.LastError);\n                            MetricsRegistry.MessagesFailed.Add(1);\n                            continue;\n                        }\n\n                        object payload = providerEnum switch\n                        {\n                            Provider.MetaCloud =>\n                                scope.ServiceProvider.GetRequiredService<MetaCloudPayloadMapper>()\n                                    .BuildPayload(plan, recipient, envelope),\n\n                            Provider.Pinnacle =>\n                                scope.ServiceProvider.GetRequiredService<PinnaclePayloadMapper>()\n                                    .BuildPayload(plan, recipient, envelope),\n\n                            _ => throw new InvalidOperationException(\"Unknown provider\")\n                        };\n\n                        var sw = Stopwatch.StartNew();\n                        var engineResult = await engine.SendPayloadAsync(job.BusinessId, job.Provider, payload, job.PhoneNumberId);\n                        sw.Stop();\n                        MetricsRegistry.SendLatencyMs.Record(sw.Elapsed.TotalMilliseconds);\n\n                        if (!engineResult.Success)\n                        {\n                            var err = engineResult.ErrorMessage ?? string.Empty;\n                            if (err.Contains(\"429\", StringComparison.Ordinal) ||\n                                err.Contains(\"Too Many Requests\", StringComparison.OrdinalIgnoreCase))\n                            {\n                                limiter.UpdateLimits(senderKey, permitsPerSecond: 5, burst: 5);\n                                MetricsRegistry.RateLimited429s.Add(1);\n                            }\n                        }\n\n                        // ‚úÖ Surface provider ID and raw body for visibility\n                        var providerMsgId = !string.IsNullOrWhiteSpace(engineResult.MessageId)\n                            ? engineResult.MessageId\n                            : TryExtractProviderMessageId(engineResult.RawResponse);\n\n                        if (engineResult.Success)\n                        {\n                            logger.LogInformation(\"Provider send OK | providerMessageId={ProviderId} job={JobId} to={To}\",\n                                providerMsgId, job.Id, recipientPhone);\n                        }\n                        else\n                        {\n                            logger.LogWarning(\"Provider send FAILED | job={JobId} to={To} error={Error} body={Body}\",\n                                job.Id, recipientPhone, engineResult.ErrorMessage, engineResult.RawResponse);\n                        }\n\n                        // Persist MessageLogs (COPY sink)\n                        var now = DateTime.UtcNow;\n                        var runId = Guid.NewGuid();\n                        var logId = Guid.NewGuid();\n\n                        logger.LogInformation(\n                            \"[OutboundSenderWorker] Enqueue MessageLog id={LogId} recipient={RecipientId} job={JobId}\",\n                            logId, job.RecipientId, job.Id);\n\n                        messageLogSink.Enqueue(new MessageLog\n                        {\n                            Id = logId,\n                            BusinessId = job.BusinessId,\n                            CampaignId = job.CampaignId,\n                            ContactId = contactId,                 // ‚úÖ ADD\n                            RecipientNumber = recipientPhone,\n                            MessageContent = job.TemplateName,\n                            MediaUrl = job.HeaderMediaUrl,\n                            Status = engineResult.Success ? \"Sent\" : \"Failed\",\n                            MessageId = providerMsgId,\n                            ErrorMessage = engineResult.ErrorMessage,\n                            RawResponse = engineResult.RawResponse,\n                            CreatedAt = now,\n                            SentAt = engineResult.Success ? now : (DateTime?)null,\n                            Source = \"campaign\",\n                            RunId = runId,\n                            Provider = job.Provider,\n                            ProviderMessageId = providerMsgId,\n                            IsIncoming = false,\n                            IsChargeable = false\n                        });\n\n                        // Batched CampaignSendLog (COPY via sink)\n                        logSink.Enqueue(new CampaignLogRecord(\n                            Id: Guid.NewGuid(),\n                            RunId: runId,\n                            MessageId: providerMsgId,\n                            CampaignId: job.CampaignId,\n                           \n                            ContactId: contactId,\n                            RecipientId: job.RecipientId,\n                            MessageBody: job.MessageBody ?? job.TemplateName,\n                            TemplateId: job.TemplateName,\n                            SendStatus: engineResult.Success ? \"Sent\" : \"Failed\",\n                            ErrorMessage: engineResult.ErrorMessage,\n                            CreatedAt: now,\n                            CreatedBy: \"system\",\n                            SentAt: engineResult.Success ? now : (DateTime?)null,\n                            DeliveredAt: null,\n                            ReadAt: null,\n                            IpAddress: null,\n                            DeviceInfo: null,\n                            MacAddress: null,\n                            SourceChannel: \"campaign\",\n                            DeviceType: null,\n                            Browser: null,\n                            Country: null,\n                            City: null,\n                            IsClicked: false,\n                            ClickedAt: null,\n                            ClickType: null,\n                            RetryCount: job.Attempt,\n                            LastRetryAt: now,\n                            LastRetryStatus: engineResult.Success ? \"Success\" : \"Failed\",\n                            AllowRetry: job.Attempt < DEFAULT_MAX_ATTEMPTS,\n                            MessageLogId: logId,\n                            BusinessId: job.BusinessId,\n                            CTAFlowConfigId: null,\n                            CTAFlowStepId: null,\n                            ButtonBundleJson: null\n                        ));\n                        logger.LogDebug(\"[Outbox] Resolved recipient. recipientId={RecipientId} phone={Phone} contactId={ContactId} name={Name}\",\n                      job.RecipientId, recipientPhone, contactId, contactName);\n\n                        // Update job (retry/backoff if needed)\n                        job.Status = engineResult.Success ? \"Sent\" : \"Failed\";\n                        job.Attempt += 1;\n                        job.LastError = engineResult.ErrorMessage;\n\n                        if (!engineResult.Success)\n                        {\n                            var backoffSecs = (int)Math.Min(60, Math.Pow(2, job.Attempt) * 2);\n                            job.NextAttemptAt = DateTime.UtcNow.AddSeconds(backoffSecs);\n                            MetricsRegistry.MessagesFailed.Add(1);\n                        }\n                        else\n                        {\n                            job.NextAttemptAt = null;\n                            MetricsRegistry.MessagesSent.Add(1);\n                        }\n\n                        db.Update(job);\n                        await db.SaveChangesAsync(ct);\n\n                        // üîç Check if all messages for this campaign are done\n                        try \n                        {\n                            var hasPending = await db.OutboundMessageJobs\n                                .AnyAsync(j => j.CampaignId == job.CampaignId \n                                            && j.Status != \"Sent\" \n                                            && j.Status != \"Failed\", ct);\n\n                            if (!hasPending)\n                            {\n                                 var cmp = await db.Campaigns.FindAsync(new object[] { job.CampaignId }, ct);\n                                 if (cmp != null && cmp.Status != \"Sent\" && cmp.Status != \"Completed\")\n                                 {\n                                     cmp.Status = \"Sent\"; \n                                     cmp.UpdatedAt = DateTime.UtcNow;\n                                     db.Update(cmp);\n                                     await db.SaveChangesAsync(ct);\n                                     logger.LogInformation(\"‚úÖ Campaign {CampaignId} marked as SENT (all jobs done).\", job.CampaignId);\n                                 }\n                            }\n                        }\n                        catch (Exception ex)\n                        {\n                            logger.LogError(ex, \"‚ö†Ô∏è Campaign status update failed for {CampaignId}\", job.CampaignId);\n                        }\n\n                        await billing.IngestFromSendResponseAsync(\n                            job.BusinessId,\n                            logId,\n                            job.Provider,\n                            engineResult.RawResponse ?? \"{}\"\n                        );\n                    }\n                }\n                catch (TaskCanceledException)\n                {\n                }\n                catch (Exception ex)\n                {\n                    try\n                    {\n                        using var scope = _sp.CreateScope();\n                        var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n                        job.Status = \"Failed\";\n                        job.Attempt += 1;\n                        job.LastError = ex.Message;\n                        var backoffSecs = (int)Math.Min(60, Math.Pow(2, job.Attempt) * 2);\n                        job.NextAttemptAt = DateTime.UtcNow.AddSeconds(backoffSecs);\n                        db.Update(job);\n                        await db.SaveChangesAsync(ct);\n                    }\n                    catch { /* swallow */ }\n\n                    MetricsRegistry.MessagesFailed.Add(1);\n                    _log.LogError(ex, \"[Outbox] Consume error job={JobId}\", job.Id);\n                }\n            }\n        }\n    }\n}\n\n\n\n\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Workers/OutboxReaperWorker.cs",
      "sha256": "62e23d9733ccd68ae2166ca2bc11a9b2024183cf0b91163984e6d7e40e7d2f15",
      "language": "csharp",
      "size": 3194,
      "content": "using Microsoft.EntityFrameworkCore;\n\nnamespace xbytechat.api.Features.CampaignModule.Workers\n{\n    public sealed class OutboxReaperWorker : BackgroundService\n    {\n        private readonly IServiceProvider _sp;\n        private readonly ILogger<OutboxReaperWorker> _log;\n\n        // How often we sweep\n        private static readonly TimeSpan SweepEvery = TimeSpan.FromSeconds(30);\n\n        // Keep in sync with your sender logic / DEFAULT_MAX_ATTEMPTS\n        private const int MAX_ATTEMPTS = 3;\n\n        public OutboxReaperWorker(IServiceProvider sp, ILogger<OutboxReaperWorker> log)\n        {\n            _sp = sp;\n            _log = log;\n        }\n\n        // OutboxReaperWorker.cs\n        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n        {\n            while (!stoppingToken.IsCancellationRequested)\n            {\n                try\n                {\n                    using var scope = _sp.CreateScope();\n                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n                    var now = DateTime.UtcNow;\n\n                    // ---- Recover stale InFlight jobs (no Random in the expression) ----\n                    var jitterSeconds = 2 + (int)((ulong)DateTime.UtcNow.Ticks % 3); // 2..4s\n                    var backoffAt = now.AddSeconds(jitterSeconds);\n\n                    var recovered = await db.OutboundMessageJobs\n                        .Where(j => j.Status == \"InFlight\" &&\n                                    j.NextAttemptAt != null &&\n                                    j.NextAttemptAt < now)\n                        .ExecuteUpdateAsync(s => s\n                            .SetProperty(j => j.Status, _ => \"Pending\")\n                            .SetProperty(j => j.NextAttemptAt, _ => backoffAt)\n                            .SetProperty(j => j.LastError, _ => \"Recovered from stale in-flight\"),\n                            stoppingToken);\n\n                    // ---- Kill over-retried jobs ----\n                    const int MAX_ATTEMPTS = 3;\n                    var killed = await db.OutboundMessageJobs\n                        .Where(j => (j.Status == \"Pending\" || j.Status == \"Failed\" || j.Status == \"InFlight\") &&\n                                    j.Attempt >= MAX_ATTEMPTS)\n                        .ExecuteUpdateAsync(s => s\n                            .SetProperty(j => j.Status, _ => \"Dead\")\n                            .SetProperty(j => j.NextAttemptAt, _ => (DateTime?)null)\n                            .SetProperty(j => j.LastError, _ => \"Max attempts exceeded\"),\n                            stoppingToken);\n\n                    if (recovered > 0 || killed > 0)\n                        _log.LogInformation(\"[OutboxReaper] recovered={Recovered} killed={Killed}\", recovered, killed);\n                }\n                catch (TaskCanceledException) { /* shutdown */ }\n                catch (Exception ex)\n                {\n                    _log.LogError(ex, \"[OutboxReaper] sweep failed\");\n                }\n\n                try { await Task.Delay(TimeSpan.FromSeconds(30), stoppingToken); }\n                catch (TaskCanceledException) { /* shutdown */ }\n            }\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Config/TrackingOptions.cs",
      "sha256": "76b42450eeb28f2d73ad6fc86ec956bc6e278f17ee17f5e517e0689e8a247483",
      "language": "csharp",
      "size": 337,
      "content": "// üìÑ Features/CampaignTracking/Config/TrackingOptions.cs\nnamespace xbytechat.api.Features.CampaignTracking.Config\n{\n    public class TrackingOptions\n    {\n        public string BaseUrl { get; set; } = \"\";\n        public string Secret { get; set; } = \"\";\n        public TimeSpan TokenTtl { get; set; } = TimeSpan.FromDays(30);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Controllers/CampaignAnalyticsController.cs",
      "sha256": "c6f14bfb29e6c2dc73c26a9437b96ce67a2c3dbb075563f486c2f346ce037296",
      "language": "csharp",
      "size": 776,
      "content": "using Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.CampaignTracking.Services;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.CampaignTracking.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize]\n    public class CampaignAnalyticsController : BusinessControllerBase\n    {\n        private readonly ICampaignAnalyticsService _campaignAnalyticsService;\n        public CampaignAnalyticsController(ICampaignAnalyticsService svc) => _campaignAnalyticsService = svc;\n\n        [HttpGet(\"top-campaigns\")]\n        public async Task<IActionResult> GetTopCampaigns([FromQuery] int count = 5)\n            => Ok(await _campaignAnalyticsService.GetTopCampaignsAsync(BusinessId, count));\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Controllers/CampaignRetryController.cs",
      "sha256": "7fb4bd32c18410353886a39bebaf5c0c6e24ea48ce01a75d6bb0c553613438f8",
      "language": "csharp",
      "size": 1241,
      "content": "using Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CampaignTracking.Services;\n\nnamespace xbytechat.api.Features.CampaignTracking.Controllers\n{\n    [ApiController]\n    [Authorize] // ‚úÖ add this\n    [Route(\"api/campaign-retry\")]\n    public class CampaignRetryController : ControllerBase\n    {\n        private readonly ICampaignTrackingRetryService _retryService;\n\n        public CampaignRetryController(ICampaignTrackingRetryService retryService)\n        {\n            _retryService = retryService;\n        }\n\n        [HttpPost(\"{logId}/retry\")]\n        public async Task<IActionResult> RetrySingle(Guid logId)\n        {\n            var success = await _retryService.RetrySingleAsync(logId);\n            if (!success) return BadRequest(new { message = \"Retry failed or not allowed for this log.\" });\n            return Ok(new { success = true, message = \"Retry completed.\" });\n        }\n\n        [HttpPost(\"campaign/{campaignId}/retry-all\")]\n        public async Task<IActionResult> RetryAllInCampaign(Guid campaignId)\n            => Ok(new { success = true, retriedCount = await _retryService.RetryFailedInCampaignAsync(campaignId) });\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Controllers/CampaignSendLogController.cs",
      "sha256": "8e86a051f236cdefd07529124bac8ed29328bce6a37d105f8d1d3657c9fbc589",
      "language": "csharp",
      "size": 5396,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CampaignTracking.DTOs;\nusing xbytechat.api.Features.CampaignTracking.Services;\n\nnamespace xbytechat.api.Features.CampaignTracking.Controllers\n{\n    [ApiController]\n    [Route(\"api/campaign-logs\")]\n    public class CampaignSendLogController : ControllerBase\n    {\n        private readonly ICampaignSendLogService _logService;\n        private readonly ICampaignTrackingRetryService _retryService;\n\n        public CampaignSendLogController(\n            ICampaignSendLogService logService,\n            ICampaignTrackingRetryService retryService)\n        {\n            _logService = logService;\n            _retryService = retryService;\n        }\n\n        [HttpGet(\"campaign/{campaignId}\")]\n        public async Task<IActionResult> GetLogsByCampaign(\n            Guid campaignId,\n            [FromQuery] string? status,\n            [FromQuery] string? search,\n            [FromQuery] int page = 1,\n            [FromQuery] int pageSize = 10)\n        {\n            var result = await _logService.GetLogsByCampaignIdAsync(campaignId, status, search, page, pageSize);\n            return Ok(result);\n        }\n\n        [HttpGet(\"campaign/{campaignId}/contact/{contactId}\")]\n        public async Task<IActionResult> GetLogsForContact(Guid campaignId, Guid contactId)\n        {\n            var logs = await _logService.GetLogsForContactAsync(campaignId, contactId);\n            return Ok(logs);\n        }\n\n        [HttpPost]\n        public async Task<IActionResult> AddSendLog([FromBody] CampaignSendLogDto dto)\n        {\n            var ipAddress = HttpContext.Connection.RemoteIpAddress?.ToString() ?? \"unknown\";\n            var userAgent = Request.Headers[\"User-Agent\"].ToString() ?? \"unknown\";\n\n            var result = await _logService.AddSendLogAsync(dto, ipAddress, userAgent);\n            if (!result)\n                return BadRequest(new { message = \"Failed to add send log\" });\n\n            return Ok(new { success = true });\n        }\n\n        [HttpPut(\"{logId}/status\")]\n        public async Task<IActionResult> UpdateDeliveryStatus(Guid logId, [FromBody] DeliveryStatusUpdateDto dto)\n        {\n            var result = await _logService.UpdateDeliveryStatusAsync(logId, dto.Status, dto.DeliveredAt, dto.ReadAt);\n            if (!result)\n                return NotFound(new { message = \"Log not found\" });\n\n            return Ok(new { success = true });\n        }\n\n        [HttpPut(\"{logId}/track-click\")]\n        public async Task<IActionResult> TrackClick(Guid logId, [FromBody] ClickTrackDto dto)\n        {\n            var result = await _logService.TrackClickAsync(logId, dto.ClickType);\n            if (!result)\n                return NotFound(new { message = \"Log not found\" });\n\n            return Ok(new { success = true });\n        }\n\n        [HttpPost(\"{logId}/retry\")]\n        public async Task<IActionResult> RetrySingle(Guid logId)\n        {\n            var result = await _retryService.RetrySingleAsync(logId);\n            if (!result)\n                return BadRequest(new { message = \"Retry failed\" });\n\n            return Ok(new { success = true });\n        }\n\n        [HttpPost(\"campaign/{campaignId}/retry-all\")]\n        public async Task<IActionResult> RetryAll(Guid campaignId)\n        {\n            var result = await _retryService.RetryFailedInCampaignAsync(campaignId);\n            return Ok(new { success = true, retried = result });\n        }\n\n        [HttpGet(\"campaign/{campaignId}/summary\")]\n        public async Task<IActionResult> GetCampaignSummary(\n            Guid campaignId,\n            [FromQuery] DateTime? fromUtc,\n            [FromQuery] DateTime? toUtc,\n            [FromQuery] int repliedWindowDays = 7,\n            [FromQuery] Guid? runId = null)\n        {\n            if (repliedWindowDays < 0) repliedWindowDays = 0;\n            if (repliedWindowDays > 90) repliedWindowDays = 90;\n\n            var summary = await _logService.GetCampaignSummaryAsync(\n                campaignId: campaignId,\n                fromUtc: fromUtc,\n                toUtc: toUtc,\n                repliedWindowDays: repliedWindowDays,\n                runId: runId);\n\n            return Ok(summary);\n        }\n\n        [HttpGet(\"campaign/{campaignId}/contacts\")]\n        public async Task<IActionResult> GetContactsByBucket(\n            Guid campaignId,\n            [FromQuery] string bucket = \"sent\",\n            [FromQuery] DateTime? fromUtc = null,\n            [FromQuery] DateTime? toUtc = null,\n            [FromQuery] int repliedWindowDays = 7,\n            [FromQuery] Guid? runId = null,\n            [FromQuery] string? search = null,\n            [FromQuery] int page = 1,\n            [FromQuery] int pageSize = 10)\n        {\n            var result = await _logService.GetContactsByStatBucketAsync(\n                campaignId,\n                bucket,\n                fromUtc,\n                toUtc,\n                repliedWindowDays,\n                runId,\n                search,\n                page,\n                pageSize);\n\n            return Ok(result);\n        }\n    }\n\n    public class DeliveryStatusUpdateDto\n    {\n        public string Status { get; set; }\n        public DateTime? DeliveredAt { get; set; }\n        public DateTime? ReadAt { get; set; }\n    }\n\n    public class ClickTrackDto\n    {\n        public string ClickType { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Controllers/CampaignTrackingController.cs",
      "sha256": "d07d10ed133e7f754d27b41d15102c751e788fe0d932751e24e784b7f108980d",
      "language": "csharp",
      "size": 12354,
      "content": "// üìÑ Features/CampaignTracking/Controllers/CampaignTrackingController.cs\nusing System.Text.Encodings.Web;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api;\nusing xbytechat.api.Features.CampaignTracking.Services;\nusing xbytechat.api.Features.CampaignTracking.Worker;\n\nnamespace xbytechat.api.Features.CampaignTracking.Controllers\n{\n    [ApiController]\n    [Route(\"r\")] // /r/{token}\n    public class CampaignTrackingController : ControllerBase\n    {\n        private static readonly HtmlEncoder HtmlEnc = HtmlEncoder.Default;\n\n        private readonly ILogger<CampaignTrackingController> _log;\n        private readonly IClickTokenService _token;\n        private readonly IClickEventQueue _queue;\n        private readonly AppDbContext _db;\n\n        public CampaignTrackingController(\n            ILogger<CampaignTrackingController> log,\n            IClickTokenService token,\n            IClickEventQueue queue,\n            AppDbContext db)\n        {\n            _log = log;\n            _token = token;\n            _queue = queue;\n            _db = db;\n        }\n\n        [HttpGet(\"{token}\")]\n        [AllowAnonymous]\n        public async Task<IActionResult> RedirectByToken([FromRoute] string token, CancellationToken ct)\n        {\n            // 1) Validate token\n            if (!_token.TryValidate(token, out var p, out var reason))\n            {\n                _log.LogWarning(\"Tracking token rejected. reason={Reason}\", reason);\n                return BadRequest(\"Invalid token.\");\n            }\n\n            // 2) Normalize + classify destination\n            if (!TryNormalizeAllowedDestination(p!.to, out var safeDest, out var scheme))\n            {\n                _log.LogWarning(\"Rejected destination for cid {Cid}: {Dest}\", p.cid, p.to);\n                return BadRequest(\"Invalid destination.\");\n            }\n\n            // 3) Capture client info\n            var ip = HttpContext.Connection.RemoteIpAddress?.ToString() ?? \"0.0.0.0\";\n            var ua = Request.Headers.UserAgent.ToString();\n            var now = DateTime.UtcNow;\n\n            // 4) Determine click type (web | call | whatsapp)\n            var clickType = ClassifyClickType(safeDest, scheme);\n\n            // 4.1) Fetch related ids from the send log (ContactId, CampaignId, RunId)\n            Guid? contactId = null;\n            Guid? campaignId = null; // keep nullable locally\n            Guid? runId = null;\n\n            try\n            {\n                var sendLog = await _db.CampaignSendLogs\n                    .AsNoTracking()\n                    .Where(x => x.Id == p.cid)\n                    .Select(x => new { x.ContactId, x.CampaignId, x.RunId })\n                    .FirstOrDefaultAsync(ct);\n\n                if (sendLog is not null)\n                {\n                    contactId = sendLog.ContactId;\n                    campaignId = sendLog.CampaignId;\n                    runId = sendLog.RunId;\n                }\n                else\n                {\n                    _log.LogWarning(\"SendLog not found for click cid={Cid}\", p.cid);\n                }\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"Failed to fetch ContactId/CampaignId/RunId for cid={Cid}\", p.cid);\n            }\n\n            // 5) Write-through (best-effort, but executed inline)\n            try\n            {\n                await _db.CampaignClickLogs.AddAsync(new CampaignClickLog\n                {\n                    Id = Guid.NewGuid(),\n                    CampaignSendLogId = p.cid,\n\n                    // NOTE:\n                    // If CampaignClickLog.CampaignId is NON-nullable in your DB/model, we must store Guid.Empty when unknown.\n                    // If you later make it nullable, change this line to: CampaignId = campaignId\n                    CampaignId = campaignId ?? Guid.Empty,\n\n                    ContactId = contactId,\n                    ButtonIndex = p.bi,\n                    ButtonTitle = p.bt,\n                    Destination = safeDest,\n                    ClickedAt = now,\n                    Ip = ip,\n                    UserAgent = ua,\n                    ClickType = clickType,\n                    RunId = runId\n                }, ct);\n\n                await _db.SaveChangesAsync(ct);\n\n                _log.LogInformation(\n                    \"CLICK WRITE-THROUGH cid={Cid} idx={Idx} type={Type} dest={Dest}\",\n                    p.cid, p.bi, clickType, safeDest);\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"Write-through insert failed. cid={Cid}\", p.cid);\n            }\n\n            // 6) Enqueue for async worker (best effort)\n            try\n            {\n                var enq = _queue.TryWrite(new ClickEvent(\n                    CampaignSendLogId: p.cid,\n                    ButtonIndex: p.bi,\n                    ButtonTitle: p.bt,\n                    Destination: safeDest,\n                    ClickedAtUtc: now,\n                    Ip: ip,\n                    UserAgent: ua,\n                    ClickType: clickType\n                ));\n\n                _log.LogInformation(\"CLICK ENQUEUE cid={Cid} idx={Idx} enqueued={Enqueued}\", p.cid, p.bi, enq);\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"Queue write threw. cid={Cid}\", p.cid);\n            }\n\n            // 7) First-click fast path (also stores ClickType) ‚Äî best effort\n            try\n            {\n                await _db.Database.ExecuteSqlRawAsync(\n                    @\"update \"\"CampaignSendLogs\"\"\n                         set \"\"IsClicked\"\" = TRUE,\n                             \"\"ClickedAt\"\" = NOW() at time zone 'utc',\n                             \"\"ClickType\"\" = {1}\n                       where \"\"Id\"\" = {0}\n                         and \"\"IsClicked\"\" = FALSE;\",\n                    parameters: new object[] { p.cid, clickType },\n                    cancellationToken: ct);\n            }\n            catch (Exception ex)\n            {\n                _log.LogDebug(ex, \"First-click update skipped.\");\n            }\n\n            // 8) Redirect handling\n            if (clickType is \"call\" or \"whatsapp\")\n            {\n                // Deep link ‚Üí return an HTML/JS shim to trigger immediately, with a safe fallback link.\n                var destHtml = HtmlEnc.Encode(safeDest);\n                var destJs = JsEscape(safeDest);\n\n                var html = $@\"<!doctype html>\n<html lang=\"\"en\"\">\n<head>\n  <meta charset=\"\"utf-8\"\">\n  <meta http-equiv=\"\"x-ua-compatible\"\" content=\"\"ie=edge\"\">\n  <meta name=\"\"viewport\"\" content=\"\"width=device-width, initial-scale=1\"\">\n  <meta http-equiv=\"\"refresh\"\" content=\"\"0;url={destHtml}\"\">\n  <title>Redirecting‚Ä¶</title>\n  <style>\n    body{{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;padding:24px;}}\n    a{{color:#2563eb;text-decoration:underline;}}\n  </style>\n  <script>\n    window.addEventListener('load', function() {{\n      try {{ window.location.replace('{destJs}'); }} catch (e) {{}}\n      setTimeout(function() {{\n        var f = document.getElementById('fallback');\n        if (f) f.style.display = 'inline';\n      }}, 1200);\n    }});\n  </script>\n</head>\n<body>\n  <p>Redirecting‚Ä¶ If you are not redirected automatically, <a id=\"\"fallback\"\" style=\"\"display:none\"\" href=\"\"{destHtml}\"\">tap here</a>.</p>\n</body>\n</html>\";\n\n                Response.Headers[\"Cache-Control\"] = \"no-store, max-age=0\";\n                Response.Headers[\"Pragma\"] = \"no-cache\";\n                Response.Headers[\"X-Content-Type-Options\"] = \"nosniff\";\n                Response.Headers[\"Referrer-Policy\"] = \"no-referrer\";\n                Response.Headers[\"X-Frame-Options\"] = \"DENY\";\n                Response.Headers[\"Permissions-Policy\"] = \"geolocation=(), microphone=(), camera=()\";\n                Response.Headers[\"Content-Security-Policy\"] =\n                    \"default-src 'none'; script-src 'unsafe-inline'; style-src 'unsafe-inline'; base-uri 'none'; frame-ancestors 'none'\";\n\n                return new ContentResult\n                {\n                    Content = html,\n                    ContentType = \"text/html; charset=utf-8\",\n                    StatusCode = 200\n                };\n            }\n\n            // Regular web links ‚Üí normal 302\n\n            Response.Headers[\"Cache-Control\"] = \"no-store, max-age=0\";\n            Response.Headers[\"Pragma\"] = \"no-cache\";\n            Response.Headers[\"X-Content-Type-Options\"] = \"nosniff\";\n            Response.Headers[\"Referrer-Policy\"] = \"no-referrer\";\n            Response.Headers[\"X-Frame-Options\"] = \"DENY\";\n            Response.Headers[\"Permissions-Policy\"] = \"geolocation=(), microphone=(), camera=()\";\n            return Redirect(safeDest);\n        }\n\n        // --- helpers ---\n\n        private static string ClassifyClickType(string normalizedDest, string scheme)\n        {\n            // scheme is pre-normalized by TryNormalizeAllowedDestination\n            if (string.Equals(scheme, \"tel\", StringComparison.OrdinalIgnoreCase)) return \"call\";\n            if (string.Equals(scheme, \"wa\", StringComparison.OrdinalIgnoreCase)) return \"whatsapp\";\n            if (string.Equals(scheme, \"whatsapp\", StringComparison.OrdinalIgnoreCase)) return \"whatsapp\";\n\n            // http/https ‚Üí still treat WhatsApp hosts as whatsapp\n            if (normalizedDest.StartsWith(\"https://wa.me/\", StringComparison.OrdinalIgnoreCase)) return \"whatsapp\";\n            if (normalizedDest.StartsWith(\"https://api.whatsapp.com/\", StringComparison.OrdinalIgnoreCase)) return \"whatsapp\";\n\n            return \"web\";\n        }\n\n        private static string JsEscape(string s) =>\n            s.Replace(\"\\\\\", \"\\\\\\\\\").Replace(\"'\", \"\\\\'\").Replace(\"\\r\", \"\").Replace(\"\\n\", \"\");\n\n        /// <summary>\n        /// Accepts: http/https/tel/wa/whatsapp, plus shorthand wa.me/... and api.whatsapp.com/...\n        /// Returns normalized absolute string and a normalized scheme hint (\"http\",\"https\",\"tel\",\"wa\",\"whatsapp\").\n        /// </summary>\n        private static bool TryNormalizeAllowedDestination(string? input, out string normalized, out string scheme)\n        {\n            normalized = string.Empty;\n            scheme = string.Empty;\n            if (string.IsNullOrWhiteSpace(input)) return false;\n\n            var cleaned = new string(input.Trim().Where(c => !char.IsControl(c)).ToArray());\n\n            // Shorthand WhatsApp hosts without scheme ‚Üí prefix https://\n            if (!cleaned.Contains(\"://\", StringComparison.Ordinal))\n            {\n                if (cleaned.StartsWith(\"wa.me/\", StringComparison.OrdinalIgnoreCase) ||\n                    cleaned.StartsWith(\"api.whatsapp.com/\", StringComparison.OrdinalIgnoreCase))\n                {\n                    var guess = \"https://\" + cleaned;\n                    if (Uri.TryCreate(guess, UriKind.Absolute, out var waAbs))\n                    {\n                        normalized = waAbs.AbsoluteUri;\n                        scheme = \"https\";\n                        return true;\n                    }\n                }\n            }\n\n            // WhatsApp custom schemes (wa:, whatsapp:)\n            if (cleaned.StartsWith(\"wa:\", StringComparison.OrdinalIgnoreCase))\n            {\n                normalized = cleaned; scheme = \"wa\"; return true;\n            }\n            if (cleaned.StartsWith(\"whatsapp:\", StringComparison.OrdinalIgnoreCase))\n            {\n                normalized = cleaned; scheme = \"whatsapp\"; return true;\n            }\n\n            // Absolute URIs\n            if (Uri.TryCreate(cleaned, UriKind.Absolute, out var uri))\n            {\n                // tel:\n                if (uri.Scheme.Equals(\"tel\", StringComparison.OrdinalIgnoreCase))\n                {\n                    normalized = uri.ToString(); scheme = \"tel\"; return true;\n                }\n\n                // http/https (including WhatsApp hosts)\n                if (uri.Scheme.Equals(Uri.UriSchemeHttp, StringComparison.OrdinalIgnoreCase) ||\n                    uri.Scheme.Equals(Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n                {\n                    normalized = uri.AbsoluteUri;\n                    scheme = uri.Scheme; // \"http\" or \"https\"\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    }\n}\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/DTOs/CampaignContactListItemDto.cs",
      "sha256": "9a3667ed9dbbde0d46cb9911f4733be56dc30128461e899e9f091a4fcbf49289",
      "language": "csharp",
      "size": 1184,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CampaignTracking.DTOs\n{\n    public class CampaignContactListItemDto\n    {\n        // ‚úÖ Needed for Phase-2 actions (retry/delete/redirect selected)\n        public Guid SendLogId { get; set; }\n\n        // ‚úÖ Useful for drill-down / audits / inbox links\n        public Guid? MessageLogId { get; set; }\n        public Guid? RecipientId { get; set; }\n\n        public Guid? ContactId { get; set; }\n        public string ContactName { get; set; } = \"N/A\";\n        public string ContactPhone { get; set; } = \"-\";\n        public string? RecipientNumber { get; set; }\n\n        public string? SendStatus { get; set; }\n        public string? ErrorMessage { get; set; }\n\n        public bool IsClicked { get; set; }\n        public string? ClickType { get; set; }\n        public DateTime? ClickedAt { get; set; }\n\n        public DateTime? SentAt { get; set; }\n        public DateTime? DeliveredAt { get; set; }\n        public DateTime? ReadAt { get; set; }\n\n        // For replied bucket\n        public DateTime? LastInboundAt { get; set; }\n\n        // ‚úÖ One ordering timestamp for UI\n        public DateTime? LastUpdatedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/DTOs/CampaignLogSummaryDto.cs",
      "sha256": "bd3cac78ed5b703d34fde2e9459dff5ed4e1bb703729c876ffaada72c4d6a99e",
      "language": "csharp",
      "size": 586,
      "content": "namespace xbytechat.api.Features.CampaignTracking.DTOs\n{\n    public class CampaignLogSummaryDto\n    {\n        public int TotalSent { get; set; }\n        public int FailedCount { get; set; }\n        public int ClickedCount { get; set; }\n        public DateTime? LastSentAt { get; set; }\n\n        public int Delivered { get; set; }\n        public int Read { get; set; }\n        public int Sent { get; set; }\n\n        public int RepliedUniqueContacts { get; set; }\n\n        // ‚úÖ NEW: so frontend can label ‚ÄúReplied (X days)‚Äù\n        public int ReplyWindowDays { get; set; }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/DTOs/CampaignSendLogDto.cs",
      "sha256": "e4401d635c37b8b9990e5b0b8137ffe065550330c45ccf4638e336b803e6c5cf",
      "language": "csharp",
      "size": 1730,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CampaignTracking.DTOs\n{\n    public class CampaignSendLogDto\n    {\n        public Guid Id { get; set; }\n\n        // üîó Relationships\n        public Guid CampaignId { get; set; }\n        public Guid? ContactId { get; set; }\n        public string ContactName { get; set; }\n        public string ContactPhone { get; set; }\n\n        public string? RecipientNumber { get; set; }\n        // üì§ Message Info\n        public Guid RecipientId { get; set; }\n        public string MessageBody { get; set; }\n        public string? TemplateId { get; set; }\n        public string? SendStatus { get; set; }\n        public string? ErrorMessage { get; set; }\n\n        // üïí Timestamps\n        public DateTime CreatedAt { get; set; }\n        public DateTime? SentAt { get; set; }\n        public DateTime? DeliveredAt { get; set; }\n        public DateTime? ReadAt { get; set; }\n\n        // üåê Metadata\n        public string? SourceChannel { get; set; }\n        public string? IpAddress { get; set; }\n        public string? DeviceInfo { get; set; }\n        public string? MacAddress { get; set; }\n\n        // ‚úÖ Enriched metadata\n        public string? DeviceType { get; set; }\n        public string? Browser { get; set; }\n        public string? Country { get; set; }\n        public string? City { get; set; }\n\n        // üìà Click Tracking\n        public bool IsClicked { get; set; }\n        public DateTime? ClickedAt { get; set; }\n        public string? ClickType { get; set; }\n\n        // üîÅ Retry Info\n        public string? RetryStatus { get; set; }     // Pending, Retried, Skipped\n        public int RetryCount { get; set; }\n        public DateTime? LastRetryAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/DTOs/CampaignStatusDashboardDto.cs",
      "sha256": "21979b3b1de98ab2567e6485c9c0e4684b848735d36743226caaca66504e9b7b",
      "language": "csharp",
      "size": 1038,
      "content": "namespace xbytechat.api.Features.CampaignTracking.DTOs\n{\n    public class CampaignStatusDashboardDto\n    {\n        public Guid CampaignId { get; set; }\n\n        // üìä Overall Stats\n        public int TotalRecipients { get; set; }\n        public int SentCount { get; set; }\n        public int DeliveredCount { get; set; }\n        public int ReadCount { get; set; }\n        public int FailedCount { get; set; }\n\n        // üïí Delivery Timing (optional but insightful)\n        public DateTime? FirstSentAt { get; set; }\n        public DateTime? LastSentAt { get; set; }\n        public DateTime? FirstReadAt { get; set; }\n        public DateTime? LastReadAt { get; set; }\n\n        // üìâ Delivery Rates\n        public double DeliveryRate => TotalRecipients == 0 ? 0 : (double)DeliveredCount / TotalRecipients * 100;\n        public double ReadRate => TotalRecipients == 0 ? 0 : (double)ReadCount / TotalRecipients * 100;\n        public double FailureRate => TotalRecipients == 0 ? 0 : (double)FailedCount / TotalRecipients * 100;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/DTOs/TopCampaignDto.cs",
      "sha256": "deebf224725de4a79f8363405623b0761fed9b776ec86cc8d6a9b05c5f79940e",
      "language": "csharp",
      "size": 295,
      "content": "namespace xbytechat.api.Features.CampaignTracking.DTOs\n{\n    public class TopCampaignDto\n    {\n        public Guid CampaignId { get; set; }\n        public string CampaignName { get; set; }\n        public double ReadRate { get; set; }\n        public double ClickThroughRate { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/EntityTypeConfigs/CampaignSendLogConfig.cs",
      "sha256": "cf880a46e9114af3187c8c4cd1f11e526a5b0c83fc9894ebc8dc39075e937247",
      "language": "csharp",
      "size": 1967,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Microsoft.EntityFrameworkCore.Metadata.Builders;\nusing xbytechat.api.Features.CampaignTracking.Models;\n\nnamespace xbytechat.api.Features.CampaignTracking.EntityTypeConfigs\n{\n    public class CampaignSendLogConfig : IEntityTypeConfiguration<CampaignSendLog>\n    {\n        public void Configure(EntityTypeBuilder<CampaignSendLog> e)\n        {\n            e.ToTable(\"CampaignSendLogs\"); // your table name\n            e.HasKey(x => x.Id);\n\n            // common lengths to keep COPY happy (adjust if you already have constraints)\n            e.Property(x => x.MessageId).HasMaxLength(128);\n            e.Property(x => x.TemplateId).HasMaxLength(128);\n            e.Property(x => x.SendStatus).HasMaxLength(32);\n            e.Property(x => x.ErrorMessage).HasMaxLength(1024);\n            e.Property(x => x.CreatedBy).HasMaxLength(128);\n            e.Property(x => x.IpAddress).HasMaxLength(64);\n            e.Property(x => x.DeviceInfo).HasMaxLength(256);\n            e.Property(x => x.MacAddress).HasMaxLength(64);\n            e.Property(x => x.SourceChannel).HasMaxLength(64);\n            e.Property(x => x.DeviceType).HasMaxLength(64);\n            e.Property(x => x.Browser).HasMaxLength(64);\n            e.Property(x => x.Country).HasMaxLength(64);\n            e.Property(x => x.City).HasMaxLength(64);\n            e.Property(x => x.ClickType).HasMaxLength(64);\n            e.Property(x => x.LastRetryStatus).HasMaxLength(32);\n\n            // CreatedAt default (UTC) if not set by code\n            e.Property(x => x.CreatedAt).HasDefaultValueSql(\"timezone('utc', now())\");\n\n            // helpful indexes\n            e.HasIndex(x => new { x.BusinessId, x.CampaignId, x.CreatedAt });\n            e.HasIndex(x => new { x.CampaignId, x.SendStatus, x.CreatedAt });\n            e.HasIndex(x => new { x.RecipientId, x.CreatedAt });\n            e.HasIndex(x => x.MessageId);\n            e.HasIndex(x => x.RunId);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Logging/CampaignLogFlushWorker.cs",
      "sha256": "b00af09909773fe5a42fec957467b0749da9ef01e66ee094928dde050277ac59",
      "language": "csharp",
      "size": 1106,
      "content": "using Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\n\nnamespace xbytechat.api.Features.CampaignTracking.Logging\n{\n    public class CampaignLogFlushWorker : BackgroundService\n    {\n        private readonly ICampaignLogSink _sink;\n        private readonly ILogger<CampaignLogFlushWorker> _log;\n        private readonly IOptionsMonitor<BatchingOptions> _opts;\n\n        public CampaignLogFlushWorker(ICampaignLogSink sink, ILogger<CampaignLogFlushWorker> log, IOptionsMonitor<BatchingOptions> opts)\n        {\n            _sink = sink; _log = log; _opts = opts;\n        }\n\n        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n        {\n            while (!stoppingToken.IsCancellationRequested)\n            {\n                try { await _sink.FlushAsync(stoppingToken); }\n                catch (Exception ex) { _log.LogError(ex, \"[CampaignLogFlushWorker] flush error\"); }\n                await Task.Delay(TimeSpan.FromMilliseconds(_opts.CurrentValue.CampaignLog.FlushEveryMs), stoppingToken);\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Logging/CampaignLogRecord.cs",
      "sha256": "777772c74a122cabcaf3c59ae1aac8fd43c7b97b6d562d5c239921ed24c47be5",
      "language": "csharp",
      "size": 1067,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CampaignTracking.Logging\n{\n    public record CampaignLogRecord(\n        Guid Id,\n        Guid? RunId,\n        string? MessageId,\n        Guid CampaignId,\n        Guid? ContactId,\n        Guid RecipientId,\n        string MessageBody,\n        string? TemplateId,\n        string? SendStatus,\n        string? ErrorMessage,\n        DateTime CreatedAt,\n        string? CreatedBy,\n        DateTime? SentAt,\n        DateTime? DeliveredAt,\n        DateTime? ReadAt,\n        string? IpAddress,\n        string? DeviceInfo,\n        string? MacAddress,\n        string? SourceChannel,\n        string? DeviceType,\n        string? Browser,\n        string? Country,\n        string? City,\n        bool IsClicked,\n        DateTime? ClickedAt,\n        string? ClickType,\n        int RetryCount,\n        DateTime? LastRetryAt,\n        string? LastRetryStatus,\n        bool AllowRetry,\n        Guid? MessageLogId,\n        Guid BusinessId,\n        Guid? CTAFlowConfigId,\n        Guid? CTAFlowStepId,\n        string? ButtonBundleJson\n    );\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Logging/CampaignLogSink.cs",
      "sha256": "1cb036d202b67bf8fdaa1e5f217c0c8c728b1ec98ec090f4bfbcfd40e46f3bc7",
      "language": "csharp",
      "size": 12526,
      "content": "using System.Collections.Concurrent;\nusing Microsoft.EntityFrameworkCore;\nusing System.Linq;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing Npgsql;\nusing NpgsqlTypes;\nusing xbytechat.api.Features.CampaignTracking.Models; // CampaignSendLog\nusing xbytechat.api.AuthModule.Models;               // AppDbContext\n\nnamespace xbytechat.api.Features.CampaignTracking.Logging\n{\n    public class CampaignLogSink : ICampaignLogSink\n    {\n        private readonly ConcurrentQueue<CampaignLogRecord> _queue = new();\n        private readonly ConcurrentDictionary<Guid, int> _attempts = new();\n        private readonly ILogger<CampaignLogSink> _log;\n        private readonly IServiceProvider _sp;\n        private readonly IOptionsMonitor<BatchingOptions> _opts;\n\n        private const int MaxAttempts = 3;\n\n        public CampaignLogSink(ILogger<CampaignLogSink> log, IServiceProvider sp, IOptionsMonitor<BatchingOptions> opts)\n        {\n            _log = log; _sp = sp; _opts = opts;\n        }\n\n        public void Enqueue(CampaignLogRecord rec) => _queue.Enqueue(rec);\n        public int PendingCount => _queue.Count;\n\n        public async Task FlushAsync(CancellationToken ct = default)\n        {\n            var max = _opts.CurrentValue.CampaignLog.MaxBatchSize;\n            var list = new List<CampaignLogRecord>(Math.Min(_queue.Count, max));\n            while (list.Count < max && _queue.TryDequeue(out var r)) list.Add(r);\n            if (list.Count == 0) return;\n\n            try\n            {\n                // Ensure all referenced MessageLogs exist before inserting send logs\n                var messageLogIds = list\n                    .Select(x => x.MessageLogId)\n                    .Where(id => id.HasValue && id.Value != Guid.Empty)\n                    .Select(id => id!.Value)\n                    .Distinct()\n                    .ToList();\n\n                _log.LogInformation(\n                    \"[CampaignLogSink] Batch size = {BatchCount}, messageLogIds = {IdCount}\",\n                    list.Count, messageLogIds.Count);\n\n                if (messageLogIds.Count > 0)\n                {\n                    using var scope = _sp.CreateScope();\n                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n                    var existingIds = await db.MessageLogs\n                        .AsNoTracking()\n                        .Where(m => messageLogIds.Contains(m.Id))\n                        .Select(m => m.Id)\n                        .ToListAsync(ct);\n\n                    var missing = messageLogIds.Except(existingIds).ToList();\n                    if (missing.Count > 0)\n                    {\n                        // Use first record Id as batch key\n                        var batchKey = list[0].Id;\n                        var attempt = _attempts.AddOrUpdate(batchKey, 1, (_, prev) => prev + 1);\n\n                        if (attempt <= MaxAttempts)\n                        {\n                            _log.LogWarning(\n                                \"[CampaignLogSink] Deferring batch (attempt {Attempt}/{Max}) ‚Äì messageLogIds={Ids} missingCount={MissingCount}\",\n                                attempt, MaxAttempts, string.Join(\",\", messageLogIds), missing.Count);\n                            foreach (var item in list) _queue.Enqueue(item);\n                            return;\n                        }\n\n                        _log.LogError(\n                            \"[CampaignLogSink] Dropping batch after {MaxAttempts} attempts ‚Äì still missing messageLogIds={Ids}\",\n                            MaxAttempts, string.Join(\",\", messageLogIds));\n                        _attempts.TryRemove(batchKey, out _);\n                        return; // drop to avoid FK violations / infinite loop\n                    }\n\n                    // All required MessageLogs exist; clear attempts for this batch key\n                    _attempts.TryRemove(list[0].Id, out _);\n                }\n\n                if (_opts.CurrentValue.CampaignLog.UseCopy)\n                    await CopyInsertAsync(list, ct);\n                else\n                    await EfInsertAsync(list, ct);\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"[CampaignLogSink] COPY failed; falling back to EF\");\n                try { await EfInsertAsync(list, ct); }\n                catch (Exception ex2)\n                {\n                    _log.LogError(ex2, \"[CampaignLogSink] EF fallback failed; requeueing {Count}\", list.Count);\n                    foreach (var rr in list) _queue.Enqueue(rr);\n                }\n            }\n        }\n\n        private static void WriteNullable<T>(NpgsqlBinaryImporter w, T? value, NpgsqlDbType type) where T : struct\n        {\n            if (value.HasValue) w.Write(value.Value, type);\n            else w.WriteNull();\n        }\n\n        private static void WriteNullableText(NpgsqlBinaryImporter w, string? value)\n        {\n            if (string.IsNullOrWhiteSpace(value)) w.WriteNull();\n            else w.Write(value, NpgsqlDbType.Text);\n        }\n\n        private static void WriteNullableVarchar(NpgsqlBinaryImporter w, string? value)\n        {\n            if (string.IsNullOrWhiteSpace(value)) w.WriteNull();\n            else w.Write(value, NpgsqlDbType.Varchar);\n        }\n\n        private static void WriteNullableUuid(NpgsqlBinaryImporter w, Guid? value)\n        {\n            if (value.HasValue && value.Value != Guid.Empty) w.Write(value.Value, NpgsqlDbType.Uuid);\n            else w.WriteNull();\n        }\n\n        private async Task CopyInsertAsync(List<CampaignLogRecord> batch, CancellationToken ct)\n        {\n            using var scope = _sp.CreateScope();\n            var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n            var connString = db.Database.GetDbConnection().ConnectionString;\n\n            await using var conn = new NpgsqlConnection(connString);\n            await conn.OpenAsync(ct);\n\n            const string sql = @\"\nCOPY \"\"CampaignSendLogs\"\" (\n    \"\"Id\"\",\n    \"\"RunId\"\",\n    \"\"MessageId\"\",\n    \"\"CampaignId\"\",\n    \"\"ContactId\"\",\n    \"\"RecipientId\"\",\n    \"\"MessageBody\"\",\n    \"\"TemplateId\"\",\n    \"\"SendStatus\"\",\n    \"\"ErrorMessage\"\",\n    \"\"CreatedAt\"\",\n    \"\"CreatedBy\"\",\n    \"\"SentAt\"\",\n    \"\"DeliveredAt\"\",\n    \"\"ReadAt\"\",\n    \"\"IpAddress\"\",\n    \"\"DeviceInfo\"\",\n    \"\"MacAddress\"\",\n    \"\"SourceChannel\"\",\n    \"\"DeviceType\"\",\n    \"\"Browser\"\",\n    \"\"Country\"\",\n    \"\"City\"\",\n    \"\"IsClicked\"\",\n    \"\"ClickedAt\"\",\n    \"\"ClickType\"\",\n    \"\"RetryCount\"\",\n    \"\"LastRetryAt\"\",\n    \"\"LastRetryStatus\"\",\n    \"\"AllowRetry\"\",\n    \"\"MessageLogId\"\",\n    \"\"BusinessId\"\",\n    \"\"CTAFlowConfigId\"\",\n    \"\"CTAFlowStepId\"\",\n    \"\"ButtonBundleJson\"\"\n) FROM STDIN (FORMAT BINARY);\";\n\n            try\n            {\n                await using var writer = await conn.BeginBinaryImportAsync(sql, ct);\n\n                foreach (var r in batch)\n                {\n                    await writer.StartRowAsync(ct);\n\n                    // Required IDs\n                    writer.Write(r.Id, NpgsqlDbType.Uuid);\n                    writer.Write(r.RunId, NpgsqlDbType.Uuid);\n\n                    // Strings / nullable fields\n                    WriteNullableVarchar(writer, r.MessageId);\n                    writer.Write(r.CampaignId, NpgsqlDbType.Uuid);\n                    WriteNullableUuid(writer, r.ContactId);\n                    WriteNullableUuid(writer, r.RecipientId);\n\n                    WriteNullableText(writer, r.MessageBody);\n                    WriteNullableVarchar(writer, r.TemplateId);\n                    WriteNullableVarchar(writer, r.SendStatus);\n                    WriteNullableVarchar(writer, r.ErrorMessage);\n\n                    // Timestamps\n                    writer.Write(r.CreatedAt, NpgsqlDbType.TimestampTz);\n                    WriteNullableVarchar(writer, r.CreatedBy);\n                    WriteNullable(writer, r.SentAt, NpgsqlDbType.TimestampTz);\n                    WriteNullable(writer, r.DeliveredAt, NpgsqlDbType.TimestampTz);\n                    WriteNullable(writer, r.ReadAt, NpgsqlDbType.TimestampTz);\n\n                    // Device / network\n                    WriteNullableVarchar(writer, r.IpAddress);\n                    WriteNullableVarchar(writer, r.DeviceInfo);\n                    WriteNullableVarchar(writer, r.MacAddress);\n                    WriteNullableVarchar(writer, r.SourceChannel);\n                    WriteNullableVarchar(writer, r.DeviceType);\n                    WriteNullableVarchar(writer, r.Browser);\n                    WriteNullableVarchar(writer, r.Country);\n                    WriteNullableVarchar(writer, r.City);\n\n                    // Click info\n                    writer.Write(r.IsClicked, NpgsqlDbType.Boolean);\n                    WriteNullable(writer, r.ClickedAt, NpgsqlDbType.TimestampTz);\n                    WriteNullableVarchar(writer, r.ClickType);\n\n                    // Retry info ‚Äî RetryCount is non-nullable int in your model\n                    writer.Write(r.RetryCount, NpgsqlDbType.Integer);\n                    WriteNullable(writer, r.LastRetryAt, NpgsqlDbType.TimestampTz);\n                    WriteNullableVarchar(writer, r.LastRetryStatus);\n                    writer.Write(r.AllowRetry, NpgsqlDbType.Boolean);\n\n                    // FK to MessageLogs may be null initially\n                    WriteNullableUuid(writer, r.MessageLogId);\n\n                    // Remaining Ids\n                    writer.Write(r.BusinessId, NpgsqlDbType.Uuid);\n                    WriteNullableUuid(writer, r.CTAFlowConfigId);\n                    WriteNullableUuid(writer, r.CTAFlowStepId);\n\n                    // Bundle (text/json)\n                    WriteNullableText(writer, r.ButtonBundleJson);\n                }\n\n                await writer.CompleteAsync(ct);\n                _log.LogDebug(\"[CampaignLogSink] COPY inserted {Count} rows\", batch.Count);\n            }\n            catch\n            {\n                throw; // let FlushAsync() handle fallback/requeue\n            }\n        }\n\n        private async Task EfInsertAsync(List<CampaignLogRecord> batch, CancellationToken ct)\n        {\n            using var scope = _sp.CreateScope();\n            var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n\n            var entities = batch.Select(r => new CampaignSendLog\n            {\n                Id = r.Id,\n                RunId = r.RunId,\n                MessageId = r.MessageId,\n                CampaignId = r.CampaignId,\n                ContactId = r.ContactId,\n                RecipientId = r.RecipientId,\n                MessageBody = r.MessageBody,\n                TemplateId = r.TemplateId,\n                SendStatus = r.SendStatus,\n                ErrorMessage = r.ErrorMessage,\n                CreatedAt = r.CreatedAt,\n                CreatedBy = r.CreatedBy,\n                SentAt = r.SentAt,\n                DeliveredAt = r.DeliveredAt,\n                ReadAt = r.ReadAt,\n                IpAddress = r.IpAddress,\n                DeviceInfo = r.DeviceInfo,\n                MacAddress = r.MacAddress,\n                SourceChannel = r.SourceChannel,\n                DeviceType = r.DeviceType,\n                Browser = r.Browser,\n                Country = r.Country,\n                City = r.City,\n                IsClicked = r.IsClicked,\n                ClickedAt = r.ClickedAt,\n                ClickType = r.ClickType,\n                RetryCount = r.RetryCount,\n                LastRetryAt = r.LastRetryAt,\n                LastRetryStatus = r.LastRetryStatus,\n                AllowRetry = r.AllowRetry,\n                MessageLogId = r.MessageLogId,\n                BusinessId = r.BusinessId,\n                CTAFlowConfigId = r.CTAFlowConfigId,\n                CTAFlowStepId = r.CTAFlowStepId,\n                ButtonBundleJson = r.ButtonBundleJson\n            }).ToList();\n\n            var prev = db.ChangeTracker.AutoDetectChangesEnabled;\n            db.ChangeTracker.AutoDetectChangesEnabled = false;\n            await db.CampaignSendLogs.AddRangeAsync(entities, ct);\n            await db.SaveChangesAsync(ct);\n            db.ChangeTracker.AutoDetectChangesEnabled = prev;\n        }\n    }\n\n    public class BatchingOptions\n    {\n        public CampaignLogOptions CampaignLog { get; set; } = new();\n        public class CampaignLogOptions\n        {\n            public int FlushEveryMs { get; set; } = 500;\n            public int MaxBatchSize { get; set; } = 500;\n            public bool UseCopy { get; set; } = true;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Logging/ICampaignLogSink.cs",
      "sha256": "2bb93f46e441543c54cae578d67d0768ae0a459d621727f54c8eb390ec2cdf38",
      "language": "csharp",
      "size": 303,
      "content": "using System.Threading;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.CampaignTracking.Logging\n{\n    public interface ICampaignLogSink\n    {\n        void Enqueue(CampaignLogRecord rec);\n        int PendingCount { get; }\n        Task FlushAsync(CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Models/CampaignClickDailyAgg.cs",
      "sha256": "f73f8e07824860d62b98ba1112933870fd6c223a3a75ca759bccf5899d9e9ffd",
      "language": "csharp",
      "size": 571,
      "content": "// üìÑ Features/CampaignTracking/Models/CampaignClickDailyAgg.cs\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace xbytechat.api.Features.CampaignTracking.Worker\n{\n    [Table(\"CampaignClickDailyAgg\")]\n    public class CampaignClickDailyAgg\n    {\n        [Key] public Guid Id { get; set; }\n        public Guid CampaignId { get; set; }\n        public DateTime Day { get; set; } // date-only (store as date in migration)\n        public int ButtonIndex { get; set; }\n        public long Clicks { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Models/CampaignClickLog.cs",
      "sha256": "c955c29fed1ef4d960a247c80426a21493ab53a3b657a4a21083d2f617d309cb",
      "language": "csharp",
      "size": 1205,
      "content": "// üìÑ Features/CampaignTracking/Models/CampaignClickLog.cs\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace xbytechat.api.Features.CampaignTracking.Worker\n{\n    [Table(\"CampaignClickLogs\")]\n    public class CampaignClickLog\n    {\n        [Key] public Guid Id { get; set; }\n\n        public Guid? RunId { get; set; }\n        // FK through CampaignSendLog to CampaignId & ContactId\n        public Guid CampaignSendLogId { get; set; }\n\n        public Guid CampaignId { get; set; }      // denormalized for fast filtering\n        public Guid? ContactId { get; set; }      // denormalized if available\n\n        public int ButtonIndex { get; set; }\n\n        [MaxLength(120)]\n        public string ButtonTitle { get; set; } = \"\";\n\n        // NEW: \"web\" | \"call\" | \"whatsapp\" (lowercase)\n        [MaxLength(16)]\n        public string ClickType { get; set; } = \"web\";\n\n        [MaxLength(2048)]\n        public string Destination { get; set; } = \"\";\n\n        [MaxLength(64)]\n        public string Ip { get; set; } = \"\";\n\n        [MaxLength(512)]\n        public string UserAgent { get; set; } = \"\";\n\n        public DateTime ClickedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Models/CampaignSendLog.cs",
      "sha256": "9dbb49fb807aab2988868a2469e54f7563ce603881667f3d6227659b312f8ba6",
      "language": "csharp",
      "size": 2955,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\nusing xbytechat.api.Features.CampaignModule.Models;\nusing xbytechat.api.Features.CRM.Models;\n\nnamespace xbytechat.api.Features.CampaignTracking.Models\n{\n    public class CampaignSendLog\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        public Guid? RunId { get; set; }\n        public string? MessageId { get; set; } // Unique WAMID from WhatsApp\n        // üîó Foreign Keys\n    \n        public Guid CampaignId { get; set; }\n        public Campaign? Campaign { get; set; }\n\n \n        public Guid? ContactId { get; set; }\n\n        [Required]\n        public Guid RecipientId { get; set; }\n\n        // üì© Message Info\n        [Required]\n        public string MessageBody { get; set; } = \"\";\n\n        public string? TemplateId { get; set; }\n        public string? SendStatus { get; set; }\n        public string? ErrorMessage { get; set; }\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n        public string? CreatedBy { get; set; }\n\n        public DateTime? SentAt { get; set; }\n        public DateTime? DeliveredAt { get; set; }\n        public DateTime? ReadAt { get; set; }\n\n        // üåê Metadata\n        public string? IpAddress { get; set; }\n        public string? DeviceInfo { get; set; }\n        public string? MacAddress { get; set; }\n        public string? SourceChannel { get; set; }\n\n        // ‚úÖ UX-Derived\n        public string? DeviceType { get; set; }\n        public string? Browser { get; set; }\n        public string? Country { get; set; }\n        public string? City { get; set; }\n\n        // üìä Click Tracking\n        public bool IsClicked { get; set; } = false;\n        public DateTime? ClickedAt { get; set; }\n        public string? ClickType { get; set; }\n\n        // üîÅ Retry Tracking (üí° New)\n        public int RetryCount { get; set; } = 0;                 // Number of retry attempts\n        public DateTime? LastRetryAt { get; set; }               // When retry last happened\n        public string? LastRetryStatus { get; set; }             // Success / Failed\n        public bool AllowRetry { get; set; } = true;             // Flag to enable/disable retry\n\n        // üëÅ Navigation\n      \n        public Contact? Contact { get; set; }\n        public CampaignRecipient? Recipient { get; set; }\n\n\n        // üîó MessageLog reference (optional)\n        public Guid? MessageLogId { get; set; }\n        public MessageLog? MessageLog { get; set; }\n        [Required]\n        public Guid BusinessId { get; set; }\n\n        // üÜï Flow context snapshot for deterministic click resolution\n        public Guid? CTAFlowConfigId { get; set; }   // which flow this send belongs to (optional)\n        public Guid? CTAFlowStepId { get; set; }     // the entry step id (optional)\n\n        [Column(TypeName = \"text\")]\n        public string? ButtonBundleJson { get; set; }\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Services/CampaignAnalyticsService.cs",
      "sha256": "ee9163439146987bfeebca642b380b914f7a0d5dae6fc4b2468b798b06840b3e",
      "language": "csharp",
      "size": 5226,
      "content": "using Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.CampaignTracking.DTOs;\nusing xbytechat.api.Features.CampaignTracking.Models;\n\nnamespace xbytechat.api.Features.CampaignTracking.Services\n{\n\n\n    public class CampaignAnalyticsService : ICampaignAnalyticsService\n    {\n        private readonly AppDbContext _context;\n\n        public CampaignAnalyticsService(AppDbContext context)\n        {\n            _context = context;\n            //_context = context;\n        }\n\n        public async Task<CampaignStatusDashboardDto?> GetCampaignStatsAsync(Guid campaignId)\n        {\n            var logs = await _context.CampaignSendLogs\n                .Where(l => l.CampaignId == campaignId)\n                .ToListAsync();\n\n            if (!logs.Any()) return null;\n\n            return new CampaignStatusDashboardDto\n            {\n                CampaignId = campaignId,\n                TotalRecipients = logs.Count,\n                SentCount = logs.Count(l => l.SendStatus == \"Sent\"),\n                DeliveredCount = logs.Count(l => l.SendStatus == \"Delivered\"),\n                ReadCount = logs.Count(l => l.SendStatus == \"Read\"),\n                FailedCount = logs.Count(l => l.SendStatus == \"Failed\"),\n                FirstSentAt = logs.Min(l => l.SentAt),\n                LastSentAt = logs.Max(l => l.SentAt),\n                FirstReadAt = logs.Min(l => l.ReadAt),\n                LastReadAt = logs.Max(l => l.ReadAt)\n            };\n        }\n\n        //public async Task<IEnumerable<TopCampaignDto>> GetTopCampaignsAsync(Guid businessId, int count = 5)\n        //{\n        //    var campaignStats = await _context.CampaignSendLogs\n        //        .Where(log => log.BusinessId == businessId)\n        //        .GroupBy(log => log.CampaignId)\n        //        .Select(group => new\n        //        {\n        //            CampaignId = group.Key,\n        //            TotalSent = group.Count(),\n        //            TotalRead = group.Count(l => l.ReadAt != null),\n        //            TotalClicked = group.Count(l => l.ClickedAt != null)\n        //        })\n        //        .Where(s => s.TotalSent > 0)\n        //        .OrderByDescending(s => (double)s.TotalClicked / s.TotalSent)\n        //        .Take(count)\n        //        .ToListAsync();\n\n        //    if (!campaignStats.Any())\n        //    {\n        //        return new List<TopCampaignDto>();\n        //    }\n\n        //    var campaignIds = campaignStats.Select(s => s.CampaignId).ToList();\n        //    var campaigns = await _context.Campaigns\n        //        .Where(c => campaignIds.Contains(c.Id))\n        //        .ToDictionaryAsync(c => c.Id, c => c.Name);\n\n        //    return campaignStats.Select(s => new TopCampaignDto\n        //    {\n        //        CampaignId = s.CampaignId,\n        //        CampaignName = campaigns.GetValueOrDefault(s.CampaignId, \"Unnamed Campaign\"),\n        //        ReadRate = s.TotalSent > 0 ? Math.Round(((double)s.TotalRead / s.TotalSent) * 100, 2) : 0,\n        //        ClickThroughRate = s.TotalSent > 0 ? Math.Round(((double)s.TotalClicked / s.TotalSent) * 100, 2) : 0\n        //    });\n        //}\n\n\n\n        public async Task<IEnumerable<TopCampaignDto>> GetTopCampaignsAsync(Guid businessId, int count = 5)\n        {\n            if (count <= 0) count = 5;\n\n            // If you suspect legacy rows with Guid.Empty, keep the extra filter; otherwise you can drop it.\n            var campaignStats = await _context.CampaignSendLogs\n                .AsNoTracking()\n                .Where(log => log.BusinessId == businessId /* && log.CampaignId != Guid.Empty */)\n                .GroupBy(log => log.CampaignId) // CampaignId is non-nullable Guid\n                .Select(group => new\n                {\n                    CampaignId = group.Key,\n                    TotalSent = group.Count(),\n                    TotalRead = group.Count(l => l.ReadAt != null),\n                    TotalClicked = group.Count(l => l.ClickedAt != null)\n                })\n                .Where(s => s.TotalSent > 0)\n                .OrderByDescending(s => (double)s.TotalClicked / s.TotalSent) // CTR first\n                .ThenByDescending(s => s.TotalSent)                           // tie-breaker: volume\n                .Take(count)\n                .ToListAsync();\n\n            if (campaignStats.Count == 0)\n                return Array.Empty<TopCampaignDto>();\n\n            var ids = campaignStats.Select(s => s.CampaignId).ToList();\n\n            var names = await _context.Campaigns\n                .AsNoTracking()\n                .Where(c => ids.Contains(c.Id))\n                .ToDictionaryAsync(c => c.Id, c => c.Name);\n\n            var result = campaignStats.Select(s => new TopCampaignDto\n            {\n                CampaignId = s.CampaignId,\n                CampaignName = names.TryGetValue(s.CampaignId, out var n) && !string.IsNullOrWhiteSpace(n)\n                                        ? n\n                                        : \"Unnamed Campaign\",\n                ReadRate = Math.Round((double)s.TotalRead / s.TotalSent * 100, 2),\n                ClickThroughRate = Math.Round((double)s.TotalClicked / s.TotalSent * 100, 2)\n            });\n\n            return result;\n        }\n\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Services/CampaignSendLogEnricher.cs",
      "sha256": "6d1155127869663e221b9c1a80e5dce49dd32c3d57d218d8157691ed3bc8edeb",
      "language": "csharp",
      "size": 872,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.CampaignTracking.Models;\nusing System;\n\nnamespace xbytechat.api.Features.CampaignTracking.Services\n{\n    public class CampaignSendLogEnricher : ICampaignSendLogEnricher\n    {\n        public async Task EnrichAsync(CampaignSendLog log, string userAgent, string ipAddress)\n        {\n            // üß† Device Detection (simplified for now)\n            log.DeviceInfo = userAgent;\n\n            // üåç IP Lookup - Mocked for now\n            if (!string.IsNullOrWhiteSpace(ipAddress))\n            {\n                log.IpAddress = ipAddress;\n                log.SourceChannel = \"API\"; // Example: mark origin\n                // Future: Use IPinfo or GeoLite2 for full location enrichment\n            }\n\n            // ‚åõ Simulate async task for compatibility\n            await Task.CompletedTask;\n        }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Services/CampaignSendLogService.cs",
      "sha256": "e7eedc36eb37b334a590d3e10a0605bf978738093bebd3cec998efa1df4c32b2",
      "language": "csharp",
      "size": 27995,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Data;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Npgsql;\nusing xbytechat.api;\nusing xbytechat.api.Features.CampaignTracking.DTOs;\nusing xbytechat.api.Features.CampaignTracking.Models;\nusing xbytechat.api.Features.CRM.Dtos;\n\nnamespace xbytechat.api.Features.CampaignTracking.Services\n{\n    public class CampaignSendLogService : ICampaignSendLogService\n    {\n        private readonly AppDbContext _context;\n        private readonly ICampaignSendLogEnricher _enricher;\n\n        public CampaignSendLogService(AppDbContext context, ICampaignSendLogEnricher enricher)\n        {\n            _context = context;\n            _enricher = enricher;\n        }\n\n        public async Task<PagedResult<CampaignSendLogDto>> GetLogsByCampaignIdAsync(\n            Guid campaignId, string? status, string? search, int page, int pageSize)\n        {\n            if (page <= 0) page = 1;\n            if (pageSize <= 0) pageSize = 10;\n\n            var q =\n                from log in _context.CampaignSendLogs.AsNoTracking()\n                where log.CampaignId == campaignId\n                join ml in _context.MessageLogs.AsNoTracking()\n                    on log.MessageLogId equals ml.Id into g\n                from ml in g.DefaultIfEmpty()\n                select new { log, ml };\n\n            if (!string.IsNullOrWhiteSpace(status))\n                q = q.Where(x => x.log.SendStatus == status);\n\n            if (!string.IsNullOrWhiteSpace(search))\n            {\n                var kw = search.Trim();\n                var kwLike = $\"%{kw}%\";\n\n                q = q.Where(x =>\n                    (x.log.Contact != null &&\n                        (EF.Functions.ILike(x.log.Contact.Name!, kwLike) ||\n                         x.log.Contact.PhoneNumber!.Contains(kw)))\n                    ||\n                    (x.ml != null && x.ml.RecipientNumber != null && x.ml.RecipientNumber.Contains(kw))\n                );\n            }\n\n            var total = await q.CountAsync();\n\n            var items = await q\n                .OrderByDescending(x => x.log.CreatedAt)\n                .Skip((page - 1) * pageSize)\n                .Take(pageSize)\n                .Select(x => new CampaignSendLogDto\n                {\n                    Id = x.log.Id,\n                    CampaignId = x.log.CampaignId,\n                    ContactId = x.log.ContactId,\n                    ContactName = x.log.Contact != null ? x.log.Contact.Name : \"N/A\",\n                    ContactPhone = x.log.Contact != null ? x.log.Contact.PhoneNumber : \"-\",\n                    RecipientNumber = x.ml != null ? x.ml.RecipientNumber : null,\n\n                    RecipientId = x.log.RecipientId,\n                    MessageBody = x.log.MessageBody,\n                    TemplateId = x.log.TemplateId,\n                    SendStatus = x.log.SendStatus,\n                    ErrorMessage = x.log.ErrorMessage,\n\n                    CreatedAt = x.log.CreatedAt,\n                    SentAt = x.log.SentAt,\n                    DeliveredAt = x.log.DeliveredAt,\n                    ReadAt = x.log.ReadAt,\n\n                    SourceChannel = x.log.SourceChannel,\n\n                    IsClicked = x.log.IsClicked,\n                    ClickedAt = x.log.ClickedAt,\n                    ClickType = x.log.ClickType,\n\n                    // ‚úÖ Retry mapping (DTO uses RetryStatus, model uses LastRetryStatus)\n                    RetryStatus = x.log.LastRetryStatus,\n                    RetryCount = x.log.RetryCount,\n                    LastRetryAt = x.log.LastRetryAt,\n\n                    IpAddress = x.log.IpAddress,\n                    DeviceInfo = x.log.DeviceInfo,\n                    MacAddress = x.log.MacAddress,\n\n                    DeviceType = x.log.DeviceType,\n                    Browser = x.log.Browser,\n                    Country = x.log.Country,\n                    City = x.log.City\n                })\n                .ToListAsync();\n\n            return new PagedResult<CampaignSendLogDto>\n            {\n                Items = items,\n                TotalCount = total,\n                Page = page,\n                PageSize = pageSize\n            };\n        }\n\n        public async Task<List<CampaignSendLogDto>> GetLogsForContactAsync(Guid campaignId, Guid contactId)\n        {\n            return await _context.CampaignSendLogs\n                .AsNoTracking()\n                .Where(log => log.CampaignId == campaignId && log.ContactId == contactId)\n                .OrderByDescending(log => log.CreatedAt)\n                .Select(log => new CampaignSendLogDto\n                {\n                    Id = log.Id,\n                    CampaignId = log.CampaignId,\n                    ContactId = log.ContactId,\n\n                    RecipientId = log.RecipientId,\n                    MessageBody = log.MessageBody,\n                    TemplateId = log.TemplateId,\n                    SendStatus = log.SendStatus,\n                    ErrorMessage = log.ErrorMessage,\n\n                    CreatedAt = log.CreatedAt,\n                    SentAt = log.SentAt,\n                    DeliveredAt = log.DeliveredAt,\n                    ReadAt = log.ReadAt,\n\n                    IpAddress = log.IpAddress,\n                    DeviceInfo = log.DeviceInfo,\n                    MacAddress = log.MacAddress,\n\n                    SourceChannel = log.SourceChannel,\n\n                    IsClicked = log.IsClicked,\n                    ClickedAt = log.ClickedAt,\n                    ClickType = log.ClickType,\n\n                    // ‚úÖ Retry mapping\n                    RetryStatus = log.LastRetryStatus,\n                    RetryCount = log.RetryCount,\n                    LastRetryAt = log.LastRetryAt\n                })\n                .ToListAsync();\n        }\n\n        // ‚úÖ IMPORTANT: DTO does not carry BusinessId.\n        // Derive BusinessId from Campaign for tenant-safe reporting.\n        public async Task<bool> AddSendLogAsync(CampaignSendLogDto dto, string ipAddress, string userAgent)\n        {\n            var businessId = await _context.Campaigns\n                .Where(c => c.Id == dto.CampaignId)\n                .Select(c => c.BusinessId)\n                .FirstOrDefaultAsync();\n\n            if (businessId == Guid.Empty)\n                return false;\n\n            var log = new CampaignSendLog\n            {\n                Id = Guid.NewGuid(),\n                BusinessId = businessId,\n\n                CampaignId = dto.CampaignId,\n                ContactId = dto.ContactId,\n\n                RecipientId = dto.RecipientId,\n                MessageBody = dto.MessageBody,\n                TemplateId = dto.TemplateId,\n\n                SendStatus = dto.SendStatus,\n                ErrorMessage = dto.ErrorMessage,\n\n                CreatedAt = DateTime.UtcNow,\n                SentAt = dto.SentAt,\n                DeliveredAt = dto.DeliveredAt,\n                ReadAt = dto.ReadAt,\n\n                SourceChannel = dto.SourceChannel,\n\n                IsClicked = dto.IsClicked,\n                ClickedAt = dto.ClickedAt,\n                ClickType = dto.ClickType,\n\n                // ‚úÖ Retry mapping\n                RetryCount = dto.RetryCount,\n                LastRetryAt = dto.LastRetryAt,\n                LastRetryStatus = dto.RetryStatus\n            };\n\n            await _enricher.EnrichAsync(log, userAgent, ipAddress);\n\n            _context.CampaignSendLogs.Add(log);\n            await _context.SaveChangesAsync();\n            return true;\n        }\n\n        public async Task<bool> UpdateDeliveryStatusAsync(Guid logId, string status, DateTime? deliveredAt, DateTime? readAt)\n        {\n            var log = await _context.CampaignSendLogs.FirstOrDefaultAsync(l => l.Id == logId);\n            if (log == null) return false;\n\n            log.SendStatus = status;\n            log.DeliveredAt = deliveredAt ?? log.DeliveredAt;\n            log.ReadAt = readAt ?? log.ReadAt;\n\n            await _context.SaveChangesAsync();\n            return true;\n        }\n\n        public async Task<bool> TrackClickAsync(Guid logId, string clickType)\n        {\n            var log = await _context.CampaignSendLogs.FirstOrDefaultAsync(l => l.Id == logId);\n            if (log == null) return false;\n\n            log.IsClicked = true;\n            log.ClickedAt = DateTime.UtcNow;\n            log.ClickType = clickType;\n\n            await _context.SaveChangesAsync();\n            return true;\n        }\n\n        public async Task<CampaignLogSummaryDto> GetCampaignSummaryAsync(\n            Guid campaignId,\n            DateTime? fromUtc,\n            DateTime? toUtc,\n            int repliedWindowDays,\n            Guid? runId)\n        {\n            if (repliedWindowDays < 0) repliedWindowDays = 0;\n            if (repliedWindowDays > 90) repliedWindowDays = 90;\n\n            var logs = _context.CampaignSendLogs\n                .AsNoTracking()\n                .Where(l => l.CampaignId == campaignId);\n\n            if (runId.HasValue)\n                logs = logs.Where(l => l.RunId == runId.Value);\n\n            if (fromUtc.HasValue)\n                logs = logs.Where(l =>\n                    (l.SentAt != null && l.SentAt >= fromUtc.Value) ||\n                    (l.SentAt == null && l.CreatedAt >= fromUtc.Value));\n\n            if (toUtc.HasValue)\n                logs = logs.Where(l =>\n                    (l.SentAt != null && l.SentAt <= toUtc.Value) ||\n                    (l.SentAt == null && l.CreatedAt <= toUtc.Value));\n\n            var baseSummary = await logs\n                .GroupBy(_ => 1)\n                .Select(g => new\n                {\n                    TotalRecipients = g.Count(),\n                    SentCount = g.Count(l => l.SendStatus != \"Failed\"),\n                    FailedCount = g.Count(l => l.SendStatus == \"Failed\"),\n                    ClickedCount = g.Count(l => l.IsClicked),\n                    DeliveredCount = g.Count(l => l.DeliveredAt != null),\n                    ReadCount = g.Count(l => l.ReadAt != null),\n                    LastSentAt = g.Max(l => l.SentAt)\n                })\n                .FirstOrDefaultAsync();\n\n            if (baseSummary == null)\n            {\n                return new CampaignLogSummaryDto\n                {\n                    ReplyWindowDays = repliedWindowDays,\n                    RepliedUniqueContacts = 0,\n                    TotalSent = 0,\n                    Sent = 0,\n                    Delivered = 0,\n                    Read = 0,\n                    FailedCount = 0,\n                    ClickedCount = 0,\n                    LastSentAt = null\n                };\n            }\n\n            // ‚úÖ Business-safe replied metric\n            var repliedUnique = await (\n                from l in logs\n                where l.ContactId != null\n                let anchor = (l.SentAt ?? l.CreatedAt)\n                join ml in _context.MessageLogs.AsNoTracking()\n                    on l.ContactId equals ml.ContactId\n                where ml.IsIncoming == true\n                      && ml.BusinessId == l.BusinessId\n                      && ml.CreatedAt >= anchor\n                      && ml.CreatedAt <= anchor.AddDays(repliedWindowDays)\n                select l.ContactId.Value\n            ).Distinct().CountAsync();\n\n            return new CampaignLogSummaryDto\n            {\n                TotalSent = baseSummary.TotalRecipients,\n                Sent = baseSummary.SentCount,\n                FailedCount = baseSummary.FailedCount,\n                ClickedCount = baseSummary.ClickedCount,\n                Delivered = baseSummary.DeliveredCount,\n                Read = baseSummary.ReadCount,\n                LastSentAt = baseSummary.LastSentAt,\n\n                RepliedUniqueContacts = repliedUnique,\n                ReplyWindowDays = repliedWindowDays\n            };\n        }\n\n        private async Task<long> ExecuteScalarLongAsync(string sql, CancellationToken ct, params NpgsqlParameter[] parameters)\n        {\n            var connString = _context.Database.GetDbConnection().ConnectionString;\n\n            await using var conn = new NpgsqlConnection(connString);\n            await conn.OpenAsync(ct);\n\n            await using var cmd = new NpgsqlCommand(sql, conn);\n            cmd.Parameters.AddRange(parameters);\n\n            var result = await cmd.ExecuteScalarAsync(ct);\n            return result == null || result == DBNull.Value ? 0 : Convert.ToInt64(result);\n        }\n\n        public async Task<PagedResult<CampaignContactListItemDto>> GetContactsByStatBucketAsync(\n            Guid campaignId,\n            string bucket,\n            DateTime? fromUtc,\n            DateTime? toUtc,\n            int repliedWindowDays,\n            Guid? runId,\n            string? search,\n            int page,\n            int pageSize)\n        {\n            if (page <= 0) page = 1;\n            if (pageSize <= 0) pageSize = 10;\n\n            bucket = (bucket ?? \"\").Trim().ToLowerInvariant();\n            if (repliedWindowDays < 0) repliedWindowDays = 0;\n            if (repliedWindowDays > 90) repliedWindowDays = 90;\n\n            var kw = string.IsNullOrWhiteSpace(search) ? null : search.Trim();\n            var kwLike = kw == null ? null : $\"%{kw}%\";\n            var offset = (page - 1) * pageSize;\n\n            string bucketWhere = bucket switch\n            {\n                \"sent\" => @\"AND l.\"\"SendStatus\"\" <> 'Failed'\",\n                \"failed\" => @\"AND l.\"\"SendStatus\"\" = 'Failed'\",\n                \"delivered\" => @\"AND l.\"\"DeliveredAt\"\" IS NOT NULL\",\n                \"read\" => @\"AND l.\"\"ReadAt\"\" IS NOT NULL\",\n                \"clicked\" => @\"AND l.\"\"IsClicked\"\" = TRUE\",\n                \"replied\" => @\"\",\n                _ => @\"\"\n            };\n\n            const string commonBaseFilters = @\"\nWHERE l.\"\"CampaignId\"\" = @campaignId\n  AND (@runId IS NULL OR l.\"\"RunId\"\" = @runId)\n  AND (\n        @fromUtc IS NULL OR\n        ((l.\"\"SentAt\"\" IS NOT NULL AND l.\"\"SentAt\"\" >= @fromUtc) OR (l.\"\"SentAt\"\" IS NULL AND l.\"\"CreatedAt\"\" >= @fromUtc))\n      )\n  AND (\n        @toUtc IS NULL OR\n        ((l.\"\"SentAt\"\" IS NOT NULL AND l.\"\"SentAt\"\" <= @toUtc) OR (l.\"\"SentAt\"\" IS NULL AND l.\"\"CreatedAt\"\" <= @toUtc))\n      )\n\";\n\n            const string searchFilter = @\"\n  AND (\n        @kw IS NULL OR\n        (c.\"\"Name\"\" IS NOT NULL AND c.\"\"Name\"\" ILIKE @kwLike) OR\n        (c.\"\"PhoneNumber\"\" IS NOT NULL AND c.\"\"PhoneNumber\"\" LIKE '%' || @kw || '%') OR\n        (ml.\"\"RecipientNumber\"\" IS NOT NULL AND ml.\"\"RecipientNumber\"\" LIKE '%' || @kw || '%')\n      )\n\";\n\n            if (bucket == \"replied\")\n            {\n                var countSql = $@\"\nWITH base AS (\n    SELECT\n        l.\"\"Id\"\"                           AS \"\"SendLogId\"\",\n        l.\"\"MessageLogId\"\"                 AS \"\"MessageLogId\"\",\n        l.\"\"RecipientId\"\"                  AS \"\"RecipientId\"\",\n        l.\"\"BusinessId\"\"                   AS \"\"BusinessId\"\",\n        l.\"\"ContactId\"\"                    AS \"\"ContactId\"\",\n        COALESCE(c.\"\"Name\"\", 'N/A')        AS \"\"ContactName\"\",\n        COALESCE(c.\"\"PhoneNumber\"\", '-')   AS \"\"ContactPhone\"\",\n        ml.\"\"RecipientNumber\"\"             AS \"\"RecipientNumber\"\",\n        l.\"\"SendStatus\"\"                   AS \"\"SendStatus\"\",\n        l.\"\"ErrorMessage\"\"                 AS \"\"ErrorMessage\"\",\n        l.\"\"IsClicked\"\"                    AS \"\"IsClicked\"\",\n        l.\"\"ClickType\"\"                    AS \"\"ClickType\"\",\n        l.\"\"ClickedAt\"\"                    AS \"\"ClickedAt\"\",\n        l.\"\"SentAt\"\"                       AS \"\"SentAt\"\",\n        l.\"\"DeliveredAt\"\"                  AS \"\"DeliveredAt\"\",\n        l.\"\"ReadAt\"\"                       AS \"\"ReadAt\"\",\n        COALESCE(l.\"\"SentAt\"\", l.\"\"CreatedAt\"\") AS \"\"Anchor\"\",\n        COALESCE(l.\"\"ReadAt\"\", l.\"\"DeliveredAt\"\", l.\"\"SentAt\"\", l.\"\"ClickedAt\"\", l.\"\"CreatedAt\"\") AS \"\"LastUpdatedAt\"\"\n    FROM \"\"CampaignSendLogs\"\" l\n    LEFT JOIN \"\"MessageLogs\"\" ml ON ml.\"\"Id\"\" = l.\"\"MessageLogId\"\"\n    LEFT JOIN \"\"Contacts\"\" c     ON c.\"\"Id\"\"  = l.\"\"ContactId\"\"\n    {commonBaseFilters}\n    AND l.\"\"ContactId\"\" IS NOT NULL\n    {searchFilter}\n),\ndedup AS (\n    SELECT DISTINCT ON (\"\"ContactId\"\")\n        *\n    FROM base\n    ORDER BY \"\"ContactId\"\", \"\"LastUpdatedAt\"\" DESC\n),\nreplied AS (\n    SELECT\n        d.*,\n        inbound.\"\"LastInboundAt\"\" AS \"\"LastInboundAt\"\"\n    FROM dedup d\n    JOIN LATERAL (\n        SELECT MAX(m.\"\"CreatedAt\"\") AS \"\"LastInboundAt\"\"\n        FROM \"\"MessageLogs\"\" m\n        WHERE m.\"\"BusinessId\"\" = d.\"\"BusinessId\"\"\n          AND m.\"\"ContactId\"\"  = d.\"\"ContactId\"\"\n          AND m.\"\"IsIncoming\"\" = TRUE\n          AND m.\"\"CreatedAt\"\" >= d.\"\"Anchor\"\"\n          AND m.\"\"CreatedAt\"\" <= d.\"\"Anchor\"\" + make_interval(days => @repliedWindowDays)\n    ) inbound ON inbound.\"\"LastInboundAt\"\" IS NOT NULL\n)\nSELECT COUNT(*)\nFROM replied;\n\";\n\n                var itemsSql = $@\"\nWITH base AS (\n    SELECT\n        l.\"\"Id\"\"                           AS \"\"SendLogId\"\",\n        l.\"\"MessageLogId\"\"                 AS \"\"MessageLogId\"\",\n        l.\"\"RecipientId\"\"                  AS \"\"RecipientId\"\",\n        l.\"\"BusinessId\"\"                   AS \"\"BusinessId\"\",\n        l.\"\"ContactId\"\"                    AS \"\"ContactId\"\",\n        COALESCE(c.\"\"Name\"\", 'N/A')        AS \"\"ContactName\"\",\n        COALESCE(c.\"\"PhoneNumber\"\", '-')   AS \"\"ContactPhone\"\",\n        ml.\"\"RecipientNumber\"\"             AS \"\"RecipientNumber\"\",\n        l.\"\"SendStatus\"\"                   AS \"\"SendStatus\"\",\n        l.\"\"ErrorMessage\"\"                 AS \"\"ErrorMessage\"\",\n        l.\"\"IsClicked\"\"                    AS \"\"IsClicked\"\",\n        l.\"\"ClickType\"\"                    AS \"\"ClickType\"\",\n        l.\"\"ClickedAt\"\"                    AS \"\"ClickedAt\"\",\n        l.\"\"SentAt\"\"                       AS \"\"SentAt\"\",\n        l.\"\"DeliveredAt\"\"                  AS \"\"DeliveredAt\"\",\n        l.\"\"ReadAt\"\"                       AS \"\"ReadAt\"\",\n        COALESCE(l.\"\"SentAt\"\", l.\"\"CreatedAt\"\") AS \"\"Anchor\"\",\n        COALESCE(l.\"\"ReadAt\"\", l.\"\"DeliveredAt\"\", l.\"\"SentAt\"\", l.\"\"ClickedAt\"\", l.\"\"CreatedAt\"\") AS \"\"LastUpdatedAt\"\"\n    FROM \"\"CampaignSendLogs\"\" l\n    LEFT JOIN \"\"MessageLogs\"\" ml ON ml.\"\"Id\"\" = l.\"\"MessageLogId\"\"\n    LEFT JOIN \"\"Contacts\"\" c     ON c.\"\"Id\"\"  = l.\"\"ContactId\"\"\n    {commonBaseFilters}\n    AND l.\"\"ContactId\"\" IS NOT NULL\n    {searchFilter}\n),\ndedup AS (\n    SELECT DISTINCT ON (\"\"ContactId\"\")\n        *\n    FROM base\n    ORDER BY \"\"ContactId\"\", \"\"LastUpdatedAt\"\" DESC\n),\nreplied AS (\n    SELECT\n        d.*,\n        inbound.\"\"LastInboundAt\"\" AS \"\"LastInboundAt\"\"\n    FROM dedup d\n    JOIN LATERAL (\n        SELECT MAX(m.\"\"CreatedAt\"\") AS \"\"LastInboundAt\"\"\n        FROM \"\"MessageLogs\"\" m\n        WHERE m.\"\"BusinessId\"\" = d.\"\"BusinessId\"\"\n          AND m.\"\"ContactId\"\"  = d.\"\"ContactId\"\"\n          AND m.\"\"IsIncoming\"\" = TRUE\n          AND m.\"\"CreatedAt\"\" >= d.\"\"Anchor\"\"\n          AND m.\"\"CreatedAt\"\" <= d.\"\"Anchor\"\" + make_interval(days => @repliedWindowDays)\n    ) inbound ON inbound.\"\"LastInboundAt\"\" IS NOT NULL\n)\nSELECT\n    \"\"SendLogId\"\"        AS \"\"SendLogId\"\",\n    \"\"MessageLogId\"\"     AS \"\"MessageLogId\"\",\n    \"\"RecipientId\"\"      AS \"\"RecipientId\"\",\n    \"\"ContactId\"\"        AS \"\"ContactId\"\",\n    \"\"ContactName\"\"      AS \"\"ContactName\"\",\n    \"\"ContactPhone\"\"     AS \"\"ContactPhone\"\",\n    \"\"RecipientNumber\"\"  AS \"\"RecipientNumber\"\",\n    \"\"SendStatus\"\"       AS \"\"SendStatus\"\",\n    \"\"ErrorMessage\"\"     AS \"\"ErrorMessage\"\",\n    \"\"IsClicked\"\"        AS \"\"IsClicked\"\",\n    \"\"ClickType\"\"        AS \"\"ClickType\"\",\n    \"\"ClickedAt\"\"        AS \"\"ClickedAt\"\",\n    \"\"SentAt\"\"           AS \"\"SentAt\"\",\n    \"\"DeliveredAt\"\"      AS \"\"DeliveredAt\"\",\n    \"\"ReadAt\"\"           AS \"\"ReadAt\"\",\n    \"\"LastInboundAt\"\"    AS \"\"LastInboundAt\"\",\n    \"\"LastUpdatedAt\"\"    AS \"\"LastUpdatedAt\"\"\nFROM replied\nORDER BY \"\"LastInboundAt\"\" DESC\nOFFSET @offset\nLIMIT @pageSize;\n\";\n\n                // ‚úÖ Use SqlQueryRaw + object[] => no ‚Äútakes 9 arguments‚Äù compile error.\n                var total = await _context.Database\n                    .SqlQueryRaw<long>(\n                        countSql,\n                        new object[]\n                        {\n                            new NpgsqlParameter(\"campaignId\", campaignId),\n                            new NpgsqlParameter(\"runId\", (object?)runId ?? DBNull.Value),\n                            new NpgsqlParameter(\"fromUtc\", (object?)fromUtc ?? DBNull.Value),\n                            new NpgsqlParameter(\"toUtc\", (object?)toUtc ?? DBNull.Value),\n                            new NpgsqlParameter(\"kw\", (object?)kw ?? DBNull.Value),\n                            new NpgsqlParameter(\"kwLike\", (object?)kwLike ?? DBNull.Value),\n                            new NpgsqlParameter(\"repliedWindowDays\", repliedWindowDays)\n                        })\n                    .SingleAsync();\n\n                var items = await _context.Database\n                    .SqlQueryRaw<CampaignContactListItemDto>(\n                        itemsSql,\n                        new object[]\n                        {\n                            new NpgsqlParameter(\"campaignId\", campaignId),\n                            new NpgsqlParameter(\"runId\", (object?)runId ?? DBNull.Value),\n                            new NpgsqlParameter(\"fromUtc\", (object?)fromUtc ?? DBNull.Value),\n                            new NpgsqlParameter(\"toUtc\", (object?)toUtc ?? DBNull.Value),\n                            new NpgsqlParameter(\"kw\", (object?)kw ?? DBNull.Value),\n                            new NpgsqlParameter(\"kwLike\", (object?)kwLike ?? DBNull.Value),\n                            new NpgsqlParameter(\"repliedWindowDays\", repliedWindowDays),\n                            new NpgsqlParameter(\"offset\", offset),\n                            new NpgsqlParameter(\"pageSize\", pageSize)\n                        })\n                    .ToListAsync();\n\n                return new PagedResult<CampaignContactListItemDto>\n                {\n                    Items = items,\n                    TotalCount = (int)total,\n                    Page = page,\n                    PageSize = pageSize\n                };\n            }\n            else\n            {\n                var countSql = $@\"\nWITH base AS (\n    SELECT\n        l.\"\"Id\"\"                           AS \"\"SendLogId\"\",\n        l.\"\"MessageLogId\"\"                 AS \"\"MessageLogId\"\",\n        l.\"\"RecipientId\"\"                  AS \"\"RecipientId\"\",\n        l.\"\"ContactId\"\"                    AS \"\"ContactId\"\",\n        COALESCE(c.\"\"Name\"\", 'N/A')        AS \"\"ContactName\"\",\n        COALESCE(c.\"\"PhoneNumber\"\", '-')   AS \"\"ContactPhone\"\",\n        ml.\"\"RecipientNumber\"\"             AS \"\"RecipientNumber\"\",\n        l.\"\"SendStatus\"\"                   AS \"\"SendStatus\"\",\n        l.\"\"ErrorMessage\"\"                 AS \"\"ErrorMessage\"\",\n        l.\"\"IsClicked\"\"                    AS \"\"IsClicked\"\",\n        l.\"\"ClickType\"\"                    AS \"\"ClickType\"\",\n        l.\"\"ClickedAt\"\"                    AS \"\"ClickedAt\"\",\n        l.\"\"SentAt\"\"                       AS \"\"SentAt\"\",\n        l.\"\"DeliveredAt\"\"                  AS \"\"DeliveredAt\"\",\n        l.\"\"ReadAt\"\"                       AS \"\"ReadAt\"\",\n        COALESCE(l.\"\"ReadAt\"\", l.\"\"DeliveredAt\"\", l.\"\"SentAt\"\", l.\"\"ClickedAt\"\", l.\"\"CreatedAt\"\") AS \"\"LastUpdatedAt\"\",\n        COALESCE(l.\"\"ContactId\"\"::text, ml.\"\"RecipientNumber\"\") AS \"\"GroupKey\"\"\n    FROM \"\"CampaignSendLogs\"\" l\n    LEFT JOIN \"\"MessageLogs\"\" ml ON ml.\"\"Id\"\" = l.\"\"MessageLogId\"\"\n    LEFT JOIN \"\"Contacts\"\" c     ON c.\"\"Id\"\"  = l.\"\"ContactId\"\"\n    {commonBaseFilters}\n    {bucketWhere}\n    {searchFilter}\n),\ndedup AS (\n    SELECT DISTINCT ON (\"\"GroupKey\"\")\n        *\n    FROM base\n    ORDER BY \"\"GroupKey\"\", \"\"LastUpdatedAt\"\" DESC\n)\nSELECT COUNT(*) FROM dedup;\n\";\n\n                var itemsSql = $@\"\nWITH base AS (\n    SELECT\n        l.\"\"Id\"\"                           AS \"\"SendLogId\"\",\n        l.\"\"MessageLogId\"\"                 AS \"\"MessageLogId\"\",\n        l.\"\"RecipientId\"\"                  AS \"\"RecipientId\"\",\n        l.\"\"ContactId\"\"                    AS \"\"ContactId\"\",\n        COALESCE(c.\"\"Name\"\", 'N/A')        AS \"\"ContactName\"\",\n        COALESCE(c.\"\"PhoneNumber\"\", '-')   AS \"\"ContactPhone\"\",\n        ml.\"\"RecipientNumber\"\"             AS \"\"RecipientNumber\"\",\n        l.\"\"SendStatus\"\"                   AS \"\"SendStatus\"\",\n        l.\"\"ErrorMessage\"\"                 AS \"\"ErrorMessage\"\",\n        l.\"\"IsClicked\"\"                    AS \"\"IsClicked\"\",\n        l.\"\"ClickType\"\"                    AS \"\"ClickType\"\",\n        l.\"\"ClickedAt\"\"                    AS \"\"ClickedAt\"\",\n        l.\"\"SentAt\"\"                       AS \"\"SentAt\"\",\n        l.\"\"DeliveredAt\"\"                  AS \"\"DeliveredAt\"\",\n        l.\"\"ReadAt\"\"                       AS \"\"ReadAt\"\",\n        COALESCE(l.\"\"ReadAt\"\", l.\"\"DeliveredAt\"\", l.\"\"SentAt\"\", l.\"\"ClickedAt\"\", l.\"\"CreatedAt\"\") AS \"\"LastUpdatedAt\"\",\n        COALESCE(l.\"\"ContactId\"\"::text, ml.\"\"RecipientNumber\"\") AS \"\"GroupKey\"\"\n    FROM \"\"CampaignSendLogs\"\" l\n    LEFT JOIN \"\"MessageLogs\"\" ml ON ml.\"\"Id\"\" = l.\"\"MessageLogId\"\"\n    LEFT JOIN \"\"Contacts\"\" c     ON c.\"\"Id\"\"  = l.\"\"ContactId\"\"\n    {commonBaseFilters}\n    {bucketWhere}\n    {searchFilter}\n),\ndedup AS (\n    SELECT DISTINCT ON (\"\"GroupKey\"\")\n        *\n    FROM base\n    ORDER BY \"\"GroupKey\"\", \"\"LastUpdatedAt\"\" DESC\n)\nSELECT\n    \"\"SendLogId\"\"        AS \"\"SendLogId\"\",\n    \"\"MessageLogId\"\"     AS \"\"MessageLogId\"\",\n    \"\"RecipientId\"\"      AS \"\"RecipientId\"\",\n    \"\"ContactId\"\"        AS \"\"ContactId\"\",\n    \"\"ContactName\"\"      AS \"\"ContactName\"\",\n    \"\"ContactPhone\"\"     AS \"\"ContactPhone\"\",\n    \"\"RecipientNumber\"\"  AS \"\"RecipientNumber\"\",\n    \"\"SendStatus\"\"       AS \"\"SendStatus\"\",\n    \"\"ErrorMessage\"\"     AS \"\"ErrorMessage\"\",\n    \"\"IsClicked\"\"        AS \"\"IsClicked\"\",\n    \"\"ClickType\"\"        AS \"\"ClickType\"\",\n    \"\"ClickedAt\"\"        AS \"\"ClickedAt\"\",\n    \"\"SentAt\"\"           AS \"\"SentAt\"\",\n    \"\"DeliveredAt\"\"      AS \"\"DeliveredAt\"\",\n    \"\"ReadAt\"\"           AS \"\"ReadAt\"\",\n    NULL::timestamptz    AS \"\"LastInboundAt\"\",\n    \"\"LastUpdatedAt\"\"    AS \"\"LastUpdatedAt\"\"\nFROM dedup\nORDER BY \"\"LastUpdatedAt\"\" DESC\nOFFSET @offset\nLIMIT @pageSize;\n\";\n\n                var total = await _context.Database\n                    .SqlQueryRaw<long>(\n                        countSql,\n                        new object[]\n                        {\n                            new NpgsqlParameter(\"campaignId\", campaignId),\n                            new NpgsqlParameter(\"runId\", (object?)runId ?? DBNull.Value),\n                            new NpgsqlParameter(\"fromUtc\", (object?)fromUtc ?? DBNull.Value),\n                            new NpgsqlParameter(\"toUtc\", (object?)toUtc ?? DBNull.Value),\n                            new NpgsqlParameter(\"kw\", (object?)kw ?? DBNull.Value),\n                            new NpgsqlParameter(\"kwLike\", (object?)kwLike ?? DBNull.Value)\n                        })\n                    .SingleAsync();\n\n                var items = await _context.Database\n                    .SqlQueryRaw<CampaignContactListItemDto>(\n                        itemsSql,\n                        new object[]\n                        {\n                            new NpgsqlParameter(\"campaignId\", campaignId),\n                            new NpgsqlParameter(\"runId\", (object?)runId ?? DBNull.Value),\n                            new NpgsqlParameter(\"fromUtc\", (object?)fromUtc ?? DBNull.Value),\n                            new NpgsqlParameter(\"toUtc\", (object?)toUtc ?? DBNull.Value),\n                            new NpgsqlParameter(\"kw\", (object?)kw ?? DBNull.Value),\n                            new NpgsqlParameter(\"kwLike\", (object?)kwLike ?? DBNull.Value),\n                            new NpgsqlParameter(\"offset\", offset),\n                            new NpgsqlParameter(\"pageSize\", pageSize)\n                        })\n                    .ToListAsync();\n\n                return new PagedResult<CampaignContactListItemDto>\n                {\n                    Items = items,\n                    TotalCount = (int)total,\n                    Page = page,\n                    PageSize = pageSize\n                };\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Services/CampaignTrackingRetryService.cs",
      "sha256": "7b60dddd6aceae08b86da9813190186180881e6fc9efd8dc1190e497b51f9af1",
      "language": "csharp",
      "size": 2935,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api;\nusing xbytechat.api.Features.CampaignTracking.Models;\n\nnamespace xbytechat.api.Features.CampaignTracking.Services\n{\n    public class CampaignTrackingRetryService : ICampaignTrackingRetryService\n    {\n        private readonly AppDbContext _context;\n\n        public CampaignTrackingRetryService(AppDbContext context)\n        {\n            _context = context;\n        }\n\n        // ‚úÖ Public method: Retry a single failed log\n        public async Task<bool> RetrySingleAsync(Guid logId)\n        {\n            return await RetrySendLogAsync(logId);\n        }\n\n        // ‚úÖ Public method: Retry all failed logs in a campaign\n        public async Task<int> RetryFailedInCampaignAsync(Guid campaignId)\n        {\n            return await RetryAllFailedInCampaignAsync(campaignId);\n        }\n\n        // üîÅ Private: Retry a specific log\n        private async Task<bool> RetrySendLogAsync(Guid logId)\n        {\n            var log = await _context.CampaignSendLogs.FirstOrDefaultAsync(x => x.Id == logId);\n\n            if (log == null || log.SendStatus != \"Failed\" || !log.AllowRetry)\n                return false;\n\n            // üîÑ Simulate re-send (replace with actual IMessageService.SendAsync later)\n            bool sent = SimulateSendMessage(log);\n\n            log.RetryCount += 1;\n            log.LastRetryAt = DateTime.UtcNow;\n            log.LastRetryStatus = sent ? \"Sent\" : \"Failed\";\n            log.SendStatus = sent ? \"Sent\" : \"Failed\";\n            log.ErrorMessage = sent ? null : \"Mock failure on retry\";\n\n            await _context.SaveChangesAsync();\n            return sent;\n        }\n\n        // üîÅ Private: Retry all failed logs in a given campaign\n        private async Task<int> RetryAllFailedInCampaignAsync(Guid campaignId)\n        {\n            var failedLogs = await _context.CampaignSendLogs\n                .Where(log => log.CampaignId == campaignId && log.SendStatus == \"Failed\" && log.AllowRetry)\n                .ToListAsync();\n\n            int successCount = 0;\n\n            foreach (var log in failedLogs)\n            {\n                bool sent = SimulateSendMessage(log);\n\n                log.RetryCount += 1;\n                log.LastRetryAt = DateTime.UtcNow;\n                log.LastRetryStatus = sent ? \"Sent\" : \"Failed\";\n                log.SendStatus = sent ? \"Sent\" : \"Failed\";\n                log.ErrorMessage = sent ? null : \"Mock failure on retry\";\n\n                if (sent) successCount++;\n            }\n\n            await _context.SaveChangesAsync();\n            return successCount;\n        }\n\n        // üîß Simulated send (replace with actual WhatsApp message logic)\n        private bool SimulateSendMessage(CampaignSendLog log)\n        {\n            return new Random().NextDouble() < 0.9; // 90% success rate\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Services/ClickTokenService.cs",
      "sha256": "b80c48d547509139d45775d1f8447eceeec7d399e27cd9a55c20dc1aecb854fb",
      "language": "csharp",
      "size": 3152,
      "content": "// üìÑ Features/CampaignTracking/Services/ClickTokenService.cs\nusing System.Security.Cryptography;\nusing System.Text;\nusing System.Text.Json;\nusing Microsoft.AspNetCore.WebUtilities;\nusing Microsoft.Extensions.Options;\nusing xbytechat.api.Features.CampaignTracking.Config;\n\nnamespace xbytechat.api.Features.CampaignTracking.Services\n{\n    public record ClickTokenPayload(\n        Guid cid,            // CampaignSendLogId\n        int bi,              // button index\n        string bt,           // button title (optional)\n        string to,           // destination absolute URL\n        long iat,            // issued at (unix seconds)\n        long exp             // expiry (unix seconds)\n    );\n\n    public interface IClickTokenService\n    {\n        string Create(ClickTokenPayload payload);\n        bool TryValidate(string token, out ClickTokenPayload? payload, out string? error);\n    }\n\n    public class ClickTokenService : IClickTokenService\n    {\n        private readonly byte[] _key;\n\n        public ClickTokenService(IOptions<TrackingOptions> opt)\n        {\n            _key = Encoding.UTF8.GetBytes(opt.Value.Secret ?? throw new ArgumentNullException(nameof(opt.Value.Secret)));\n        }\n\n        public string Create(ClickTokenPayload payload)\n        {\n            var json = JsonSerializer.Serialize(payload);\n            var data = Encoding.UTF8.GetBytes(json);\n            var body = WebEncoders.Base64UrlEncode(data);\n\n            var sig = ComputeHmac(body);\n            return $\"{body}.{sig}\";\n        }\n\n        public bool TryValidate(string token, out ClickTokenPayload? payload, out string? error)\n        {\n            payload = null;\n            error = null;\n\n            var parts = token.Split('.');\n            if (parts.Length != 2) { error = \"format\"; return false; }\n\n            var body = parts[0];\n            var sig = parts[1];\n\n            var expected = ComputeHmac(body);\n            // timing-safe compare\n            if (!CryptographicOperations.FixedTimeEquals(Encoding.UTF8.GetBytes(sig), Encoding.UTF8.GetBytes(expected)))\n            { error = \"bad-signature\"; return false; }\n\n            try\n            {\n                var bytes = WebEncoders.Base64UrlDecode(body);\n                var obj = JsonSerializer.Deserialize<ClickTokenPayload>(bytes);\n                if (obj is null) { error = \"decode\"; return false; }\n\n                var now = DateTimeOffset.UtcNow.ToUnixTimeSeconds();\n                if (now > obj.exp) { error = \"expired\"; return false; }\n\n                // minimal URL sanity check\n                if (!Uri.TryCreate(obj.to, UriKind.Absolute, out var _)) { error = \"bad-destination\"; return false; }\n\n                payload = obj;\n                return true;\n            }\n            catch (Exception ex)\n            {\n                error = \"exception:\" + ex.GetType().Name;\n                return false;\n            }\n        }\n\n        private string ComputeHmac(string body)\n        {\n            using var h = new HMACSHA256(_key);\n            var sig = h.ComputeHash(Encoding.UTF8.GetBytes(body));\n            return WebEncoders.Base64UrlEncode(sig);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Services/ICampaignAnalyticsService.cs",
      "sha256": "c4c188f0eba3b537c076a7fc42ef62094de1ced491abcaecb619097e40debb8b",
      "language": "csharp",
      "size": 437,
      "content": "using xbytechat.api.Features.CampaignTracking.DTOs;\n\nnamespace xbytechat.api.Features.CampaignTracking.Services\n{\n    public interface ICampaignAnalyticsService\n    {\n       // Task<CampaignStatusDashboardDto> GetStatusDashboardAsync(Guid businessId);\n        Task<IEnumerable<TopCampaignDto>> GetTopCampaignsAsync(Guid businessId, int count = 5);\n        Task<CampaignStatusDashboardDto?> GetCampaignStatsAsync(Guid campaignId);\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Services/ICampaignSendLogEnricher.cs",
      "sha256": "9204a2182522e06e53fe6beb21100820231943995d044f01feb200bdcaa521de",
      "language": "csharp",
      "size": 290,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.CampaignTracking.Models;\n\nnamespace xbytechat.api.Features.CampaignTracking.Services\n{\n    public interface ICampaignSendLogEnricher\n    {\n        Task EnrichAsync(CampaignSendLog log, string userAgent, string ipAddress);\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Services/ICampaignSendLogService.cs",
      "sha256": "ee8aaaf915449983c605cb494fc80598171d66653b38178c210b08e1ee4adcbb",
      "language": "csharp",
      "size": 1374,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CampaignTracking.DTOs;\nusing xbytechat.api.Features.CRM.Dtos;\n\nnamespace xbytechat.api.Features.CampaignTracking.Services\n{\n    public interface ICampaignSendLogService\n    {\n        Task<PagedResult<CampaignSendLogDto>> GetLogsByCampaignIdAsync(\n            Guid campaignId, string? status, string? search, int page, int pageSize);\n\n        Task<List<CampaignSendLogDto>> GetLogsForContactAsync(Guid campaignId, Guid contactId);\n\n        Task<bool> AddSendLogAsync(CampaignSendLogDto dto, string ipAddress, string userAgent);\n\n        Task<bool> UpdateDeliveryStatusAsync(Guid logId, string status, DateTime? deliveredAt, DateTime? readAt);\n\n        Task<bool> TrackClickAsync(Guid logId, string clickType);\n\n        Task<CampaignLogSummaryDto> GetCampaignSummaryAsync(\n            Guid campaignId,\n            DateTime? fromUtc,\n            DateTime? toUtc,\n            int repliedWindowDays,\n            Guid? runId);\n\n        Task<PagedResult<CampaignContactListItemDto>> GetContactsByStatBucketAsync(\n            Guid campaignId,\n            string bucket,\n            DateTime? fromUtc,\n            DateTime? toUtc,\n            int repliedWindowDays,\n            Guid? runId,\n            string? search,\n            int page,\n            int pageSize);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Services/ICampaignTrackingRetryService.cs",
      "sha256": "0ea3dd070b8b87ab800873972e6200421e942c4e4536a316a8623bd7108e72ec",
      "language": "csharp",
      "size": 554,
      "content": "using System;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.CampaignTracking.Services\n{\n    public interface ICampaignTrackingRetryService\n    {\n\n        // Retry a single failed message log by its ID.\n        // will be used when user clicks \"Retry Now\" on a log row.\n        Task<bool> RetrySingleAsync(Guid logId);\n\n\n        // Retry all failed messages in a campaign where retry is allowed.\n        // will support \"Retry All Failed\" button from Campaign logs.\n        Task<int> RetryFailedInCampaignAsync(Guid campaignId);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Worker/ClickEvent.cs",
      "sha256": "feba0a8efef3e111690aeca876198178018024d5c39d3415d1cb3db163a8e52e",
      "language": "csharp",
      "size": 380,
      "content": "// Features/CampaignTracking/Worker/ClickEvent.cs\nnamespace xbytechat.api.Features.CampaignTracking.Worker\n{\n    public sealed record ClickEvent(\n        Guid CampaignSendLogId,\n        int ButtonIndex,\n        string ButtonTitle,\n        string Destination,\n        DateTime ClickedAtUtc,\n        string Ip,\n        string UserAgent,\n         string ClickType\n         \n    );\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Worker/ClickLogWorker.cs",
      "sha256": "6c5f66aa812a1532420b44d66e9a0d9b72234af71077dbb32151c78d78d30a97",
      "language": "csharp",
      "size": 8009,
      "content": "using Microsoft.EntityFrameworkCore;\nusing xbytechat.api;\n\nnamespace xbytechat.api.Features.CampaignTracking.Worker\n{\n    public sealed class ClickLogWorker : BackgroundService\n    {\n        private readonly ILogger<ClickLogWorker> _log;\n        private readonly IClickEventQueue _queue;\n        private readonly IServiceScopeFactory _scopeFactory;\n\n        public ClickLogWorker(\n            ILogger<ClickLogWorker> log,\n            IClickEventQueue queue,\n            IServiceScopeFactory scopeFactory)\n        {\n            _log = log;\n            _queue = queue;\n            _scopeFactory = scopeFactory;\n        }\n\n        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n        {\n            _log.LogInformation(\"ClickLogWorker started\");\n\n            while (!stoppingToken.IsCancellationRequested)\n            {\n                List<ClickEvent> batch;\n                try\n                {\n                    batch = await _queue.ReadBatchAsync(200, TimeSpan.FromSeconds(1), stoppingToken);\n                    if (batch.Count == 0) continue;\n\n                    // quick visibility: confirm we are ingesting call/whatsapp/web events\n                    var byType = batch.GroupBy(e => e.ClickType ?? \"web\")\n                                      .Select(g => $\"{g.Key}:{g.Count()}\")\n                                      .ToArray();\n                    _log.LogInformation(\"WORKER processing {Count} events [{Kinds}]\",\n                        batch.Count, string.Join(\", \", byType));\n                }\n                catch (OperationCanceledException)\n                {\n                    break;\n                }\n                catch (Exception ex)\n                {\n                    _log.LogError(ex, \"Queue read failed; retrying\");\n                    try { await Task.Delay(500, stoppingToken); } catch { /* ignore */ }\n                    continue;\n                }\n\n                // nothing to do\n                if (batch.Count == 0) continue;\n\n                try\n                {\n                    using var scope = _scopeFactory.CreateScope();\n                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n\n                    // Prefetch CampaignId for this batch (we only need CampaignId for the aggregates)\n                    var sendIds = batch.Select(b => b.CampaignSendLogId).Distinct().ToList();\n                    if (sendIds.Count == 0) continue;\n\n                    var sendMap = await db.CampaignSendLogs\n                        .Where(s => sendIds.Contains(s.Id))\n                        .Select(s => new { s.Id, s.CampaignId })\n                        .ToDictionaryAsync(s => s.Id, s => s.CampaignId, stoppingToken);\n\n                    // Prepare aggregate groups: (CampaignId, Day, ButtonIndex) -> count\n                    var groups = batch\n                        .Select(e =>\n                        {\n                            sendMap.TryGetValue(e.CampaignSendLogId, out var campaignId);\n                            return new { CampaignId = campaignId, Day = e.ClickedAtUtc.Date, e.ButtonIndex };\n                        })\n                        .Where(x => x.CampaignId != Guid.Empty)\n                        .GroupBy(x => new { x.CampaignId, x.Day, x.ButtonIndex })\n                        .Select(g => new { g.Key.CampaignId, g.Key.Day, g.Key.ButtonIndex, Count = g.Count() })\n                        .ToList();\n\n                    if (groups.Count == 0) continue;\n\n                    foreach (var g in groups)\n                    {\n                        await db.Database.ExecuteSqlRawAsync(@\"\n                    insert into \"\"CampaignClickDailyAgg\"\" (\"\"CampaignId\"\", \"\"Day\"\", \"\"ButtonIndex\"\", \"\"Clicks\"\")\n                    values ({0}, {1}, {2}, {3})\n                    on conflict (\"\"CampaignId\"\", \"\"Day\"\", \"\"ButtonIndex\"\")\n                    do update set \"\"Clicks\"\" = \"\"CampaignClickDailyAgg\"\".\"\"Clicks\"\" + {3};\",\n                            g.CampaignId, g.Day, g.ButtonIndex, g.Count);\n                    }\n                }\n                catch (Exception ex)\n                {\n                    _log.LogError(ex, \"Aggregate update failed; skipped this batch.\");\n                }\n            }\n\n            _log.LogInformation(\"ClickLogWorker stopped\");\n        }\n    }\n}\n\n\n//using Microsoft.EntityFrameworkCore;\n//using xbytechat.api;\n\n//namespace xbytechat.api.Features.CampaignTracking.Worker\n//{\n//    public sealed class ClickLogWorker : BackgroundService\n//    {\n//        private readonly ILogger<ClickLogWorker> _log;\n//        private readonly IClickEventQueue _queue;\n//        private readonly IServiceScopeFactory _scopeFactory;\n\n//        public ClickLogWorker(\n//            ILogger<ClickLogWorker> log,\n//            IClickEventQueue queue,\n//            IServiceScopeFactory scopeFactory)\n//        {\n//            _log = log;\n//            _queue = queue;\n//            _scopeFactory = scopeFactory;\n//        }\n\n//        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n//        {\n//            _log.LogInformation(\"ClickLogWorker started\");\n\n//            while (!stoppingToken.IsCancellationRequested)\n//            {\n//                List<ClickEvent> batch;\n//                try\n//                {\n//                    batch = await _queue.ReadBatchAsync(200, TimeSpan.FromSeconds(1), stoppingToken);\n//                    if (batch.Count == 0) continue;\n//                    _log.LogInformation(\"WORKER processing {Count} events (aggregates only)\", batch.Count);\n//                }\n//                catch (OperationCanceledException) { break; }\n//                catch (Exception ex)\n//                {\n//                    _log.LogError(ex, \"Queue read failed; retrying\");\n//                    try { await Task.Delay(500, stoppingToken); } catch { }\n//                    continue;\n//                }\n\n//                try\n//                {\n//                    using var scope = _scopeFactory.CreateScope();\n//                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n\n//                    // Prefetch CampaignId for this batch\n//                    var sendIds = batch.Select(b => b.CampaignSendLogId).Distinct().ToList();\n//                    var sendMap = await db.CampaignSendLogs\n//                        .Where(s => sendIds.Contains(s.Id))\n//                        .Select(s => new { s.Id, s.CampaignId })\n//                        .ToDictionaryAsync(s => s.Id, s => s.CampaignId, stoppingToken);\n\n//                    // Build aggregate groups\n//                    var groups = batch\n//                        .Select(e =>\n//                        {\n//                            sendMap.TryGetValue(e.CampaignSendLogId, out var campaignId);\n//                            return new { CampaignId = campaignId, Day = e.ClickedAtUtc.Date, e.ButtonIndex };\n//                        })\n//                        .Where(x => x.CampaignId != Guid.Empty)\n//                        .GroupBy(x => new { x.CampaignId, x.Day, x.ButtonIndex })\n//                        .Select(g => new { g.Key.CampaignId, g.Key.Day, g.Key.ButtonIndex, Count = g.Count() })\n//                        .ToList();\n\n//                    foreach (var g in groups)\n//                    {\n//                        await db.Database.ExecuteSqlRawAsync(@\"\n//insert into \"\"CampaignClickDailyAgg\"\" (\"\"CampaignId\"\", \"\"Day\"\", \"\"ButtonIndex\"\", \"\"Clicks\"\")\n//values ({0}, {1}, {2}, {3})\n//on conflict (\"\"CampaignId\"\", \"\"Day\"\", \"\"ButtonIndex\"\")\n//do update set \"\"Clicks\"\" = \"\"CampaignClickDailyAgg\"\".\"\"Clicks\"\" + {3};\",\n//                            g.CampaignId, g.Day, g.ButtonIndex, g.Count);\n//                    }\n//                }\n//                catch (Exception ex)\n//                {\n//                    _log.LogError(ex, \"Aggregate update failed; skipped.\");\n//                }\n//            }\n\n//            _log.LogInformation(\"ClickLogWorker stopped\");\n//        }\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Worker/IClickEventQueue.cs",
      "sha256": "a0e8a3bbb51c949024de93f0d4794c3ed494cc047e0b7dafdabe4cf696dad89c",
      "language": "csharp",
      "size": 304,
      "content": "// Features/CampaignTracking/Worker/IClickEventQueue.cs\nnamespace xbytechat.api.Features.CampaignTracking.Worker\n{\n    public interface IClickEventQueue\n    {\n        bool TryWrite(ClickEvent evt);\n        Task<List<ClickEvent>> ReadBatchAsync(int maxItems, TimeSpan wait, CancellationToken ct);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Worker/InProcessClickEventQueue.cs",
      "sha256": "8344c869f22df147598c7b1db117ba72d4c518901138838f7fed724201392009",
      "language": "csharp",
      "size": 1254,
      "content": "using System.Threading.Channels;\n\nnamespace xbytechat.api.Features.CampaignTracking.Worker\n{\n    public sealed class InProcessClickEventQueue : IClickEventQueue\n    {\n        private readonly Channel<ClickEvent> _ch;\n\n        public InProcessClickEventQueue(int capacity = 20_000)\n        {\n            _ch = Channel.CreateBounded<ClickEvent>(new BoundedChannelOptions(capacity)\n            {\n                // keep newest; never block redirect\n                FullMode = BoundedChannelFullMode.DropOldest,\n                SingleReader = true,\n                SingleWriter = false\n            });\n        }\n\n        public bool TryWrite(ClickEvent evt) => _ch.Writer.TryWrite(evt);\n\n        public async Task<List<ClickEvent>> ReadBatchAsync(int maxItems, TimeSpan wait, CancellationToken ct)\n        {\n            var list = new List<ClickEvent>(maxItems);\n            using var cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\n            cts.CancelAfter(wait);\n\n            while (list.Count < maxItems && await _ch.Reader.WaitToReadAsync(cts.Token))\n            {\n                while (list.Count < maxItems && _ch.Reader.TryRead(out var item))\n                    list.Add(item);\n            }\n            return list;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Controllers/CatalogDashboardController.cs",
      "sha256": "f9186d5de3a12145a3d7a2411736c6510ca02a7b70409ebdcaaa0de5172c0370",
      "language": "csharp",
      "size": 1708,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.Catalog.DTOs;\nusing xbytechat.api.Features.Catalog.Services;\nusing System;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Catalog.Controllers\n{\n    [ApiController]\n    [Route(\"api/catalog-dashboard\")]\n    public class CatalogDashboardController : ControllerBase\n    {\n        private readonly ICatalogDashboardService _dashboardService;\n\n        public CatalogDashboardController(ICatalogDashboardService dashboardService)\n        {\n            _dashboardService = dashboardService;\n        }\n\n        [HttpGet(\"summary\")]\n        public async Task<ActionResult<CatalogDashboardSummaryDto>> GetSummary([FromQuery] Guid businessId)\n        {\n            var summary = await _dashboardService.GetDashboardSummaryAsync(businessId);\n            return Ok(summary);\n        }\n\n        [HttpGet(\"top-products\")]\n        public async Task<IActionResult> GetTopClickedProducts([FromQuery] Guid businessId, [FromQuery] int topN = 5)\n        {\n            var topProducts = await _dashboardService.GetTopClickedProductsAsync(businessId, topN);\n            return Ok(topProducts);\n        }\n        [HttpGet(\"cta-summary\")]\n        public async Task<IActionResult> GetCtaJourneySummary([FromQuery] Guid businessId)\n        {\n            var stats = await _dashboardService.GetCtaJourneyStatsAsync(businessId);\n            return Ok(stats);\n        }\n        [HttpGet(\"product-cta-breakdown\")]\n        public async Task<IActionResult> GetProductCtaBreakdown([FromQuery] Guid businessId)\n        {\n            var breakdown = await _dashboardService.GetProductCtaBreakdownAsync(businessId);\n            return Ok(breakdown);\n        }\n\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Controllers/CatalogTrackingController.cs",
      "sha256": "85581ce69ed9dbbad069ca060c3e8a2c356ec348d74d860ed2ed1905c46f9514",
      "language": "csharp",
      "size": 1696,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Catalog.DTOs;\nusing xbytechat.api.Features.Catalog.Services;\nusing xbytechat.api.Helpers;\nusing Microsoft.Extensions.Logging;\n\nnamespace xbytechat.api.Features.Catalog.Controllers\n{\n    [ApiController]\n    [Route(\"api/catalog-tracking\")]\n    public class CatalogTrackingController : ControllerBase\n    {\n        private readonly ICatalogTrackingService _trackingService;\n        private readonly ILogger<CatalogTrackingController> _logger;\n\n        public CatalogTrackingController(\n            ICatalogTrackingService trackingService,\n            ILogger<CatalogTrackingController> logger)\n        {\n            _trackingService = trackingService;\n            _logger = logger;\n        }\n\n        [HttpPost(\"log-click\")]\n        public async Task<IActionResult> LogClick([FromBody] CatalogClickLogDto dto)\n        {\n            var result = await _trackingService.LogClickAsync(dto);\n\n            if (!result.Success)\n            {\n                _logger.LogWarning(\"‚ùå Catalog click log failed: {Msg}\", result.Message);\n                return BadRequest(result);\n            }\n\n            return StatusCode(201, result);\n        }\n\n        [HttpGet(\"recent\")]\n        public async Task<IActionResult> GetRecentLogs([FromQuery] int limit = 5)\n        {\n            var result = await _trackingService.GetRecentLogsAsync(limit);\n\n            if (!result.Success)\n            {\n                _logger.LogError(\"‚ùå Failed to fetch recent logs: {Error}\", result.ErrorMessage);\n                return StatusCode(500, result);\n            }\n\n            return Ok(result);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Controllers/ProductController.cs",
      "sha256": "96a44de270bbb3d5a3b88cc161908c14045b78ca5adab88fb776640f55de1a1b",
      "language": "csharp",
      "size": 3021,
      "content": "// üìÑ File: Features/Catalog/Controllers/ProductController.cs\n\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.Catalog.DTOs;\nusing xbytechat.api.Features.Catalog.Services;\nusing xbytechat.api.Helpers;\nusing System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api.Middleware.Attributes;\n\nnamespace xbytechat.api.Features.Catalog.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class ProductController : ControllerBase\n    {\n        private readonly IProductService _productService;\n\n        public ProductController(IProductService productService)\n        {\n            _productService = productService;\n        }\n\n        // ‚úÖ GET /api/product?businessId=...\n        [HttpGet]\n        [RequirePermission(\"ViewCatalog\")]\n        public async Task<IActionResult> GetAll([FromQuery] Guid businessId)\n        {\n            if (businessId == Guid.Empty)\n                return BadRequest(ResponseResult.ErrorInfo(\"BusinessId is required.\"));\n\n            var result = await _productService.GetProductsByBusinessIdAsync(businessId);\n            return Ok(result);\n        }\n\n        // ‚úÖ POST /api/product\n        [HttpPost]\n        [RequirePermission(\"ManageCatalog\")]\n        public async Task<IActionResult> Create([FromBody] CreateProductDto dto)\n        {\n            if (!ModelState.IsValid)\n            {\n                var errors = ModelState.Values\n                    .SelectMany(v => v.Errors)\n                    .Select(e => e.ErrorMessage)\n                    .ToList();\n\n                var errorString = string.Join(\"; \", errors);\n                return BadRequest(ResponseResult.ErrorInfo(\"Invalid product data.\", errorString));\n            }\n\n            var result = await _productService.AddProductAsync(dto);\n            if (!result.Success)\n                return BadRequest(result);\n\n            return StatusCode(201, result);\n        }\n\n        // ‚úÖ DELETE /api/product/{id}?businessId=...\n        [HttpDelete(\"{id}\")]\n        [RequirePermission(\"ManageCatalog\")]\n        public async Task<IActionResult> Delete(Guid id, [FromQuery] Guid businessId)\n        {\n            if (businessId == Guid.Empty)\n                return BadRequest(ResponseResult.ErrorInfo(\"BusinessId is required.\"));\n\n            var result = await _productService.RemoveProductAsync(id, businessId);\n            if (!result.Success)\n                return BadRequest(result);\n\n            return Ok(result);\n        }\n\n        // ‚úÖ PUT /api/product/{id}\n        [HttpPut(\"{id}\")]\n        [RequirePermission(\"ManageCatalog\")]\n        public async Task<IActionResult> Update(Guid id, [FromBody] UpdateProductDto dto)\n        {\n            if (id != dto.Id)\n                return BadRequest(ResponseResult.ErrorInfo(\"ID mismatch between route and body.\"));\n\n            var result = await _productService.UpdateProductAsync(dto);\n            if (!result.Success)\n                return BadRequest(result);\n\n            return Ok(result);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/DTOs/CatalogClickLogDto.cs",
      "sha256": "901cea612e459695f97b806841df45393d04066624affedbfd85cc9d7d3899ce",
      "language": "csharp",
      "size": 979,
      "content": "namespace xbytechat.api.Features.Catalog.DTOs\n{\n    public class CatalogClickLogDto\n    {\n        public Guid BusinessId { get; set; }\n        public Guid? ContactId { get; set; }  // ‚úÖ Add this\n        public Guid? ProductId { get; set; }\n\n        public string? UserId { get; set; }\n        public string? UserName { get; set; }\n        public string? UserPhone { get; set; }\n\n        public string? BotId { get; set; }\n        public string? CategoryBrowsed { get; set; }\n        public string? ProductBrowsed { get; set; }\n        public string? CTAJourney { get; set; }\n        public Guid? MessageLogId { get; set; }      // ‚úÖ ADD THIS FIELD\n        public string? RefMessageId { get; set; }\n\n        public string TemplateId { get; set; }\n        public string ButtonText { get; set; }\n\n        // üß† Optional: Used for A/B tracking and analytics\n        public string? PlanSnapshot { get; set; }\n\n        public string? Source { get; set; } // ‚úÖ Add this\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/DTOs/CatalogDashboardSummaryDto.cs",
      "sha256": "31e171cf2d8c5bc006b770f4be2a968db3300aaad51072555faecd119e0e0e07",
      "language": "csharp",
      "size": 698,
      "content": "namespace xbytechat.api.Features.Catalog.DTOs\n{\n    public class CatalogDashboardSummaryDto\n    {\n        // Engagement Metrics\n        public int TotalMessagesSent { get; set; }\n        public int? UniqueCustomersMessaged { get; set; }\n        public int? ProductClicks { get; set; }\n\n        // Catalog Overview\n        public int? ActiveProducts { get; set; }\n        public int? ProductsSharedViaWhatsApp { get; set; }\n\n        // Lead Intelligence\n        public int? RepeatClickers { get; set; }\n        public int? NewClickersToday { get; set; }\n\n        // Timestamps\n        public DateTime? LastCatalogClickAt { get; set; }\n        public DateTime? LastMessageSentAt { get; set; }\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/Catalog/DTOs/CreateProductDto.cs",
      "sha256": "8605a9900a0537d7cec14264a91a4a4432debcdaafb06cff99b177460bd47233",
      "language": "csharp",
      "size": 472,
      "content": "// File: Features/Catalog/DTOs/CreateProductDto.cs\n\nnamespace xbytechat.api.Features.Catalog.DTOs\n{\n    public class CreateProductDto\n    {\n        public Guid BusinessId { get; set; }\n        public string Name { get; set; } = string.Empty;\n        public string Description { get; set; } = string.Empty;\n        public decimal Price { get; set; }\n        public string Currency { get; set; } = \"INR\";\n        public string ImageUrl { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/DTOs/CtaJourneyStatsDto.cs",
      "sha256": "ca4efb6e222da04add4d8f9892be95a16ae180b34e53eec32d300c471ea503bd",
      "language": "csharp",
      "size": 188,
      "content": "namespace xbytechat.api.Features.Catalog.DTOs\n{\n    public class CtaJourneyStatsDto\n    {\n        public string CTAJourney { get; set; }\n        public int ClickCount { get; set; }\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/Catalog/DTOs/ProductCtaBreakdownDto.cs",
      "sha256": "a94adfe171430503ede80ebb733fc9983f3fe1eae04b4a5a4ed6eb14d354bc10",
      "language": "csharp",
      "size": 284,
      "content": "namespace xbytechat.api.Features.Catalog.DTOs\n{\n    public class ProductCtaBreakdownDto\n    {\n        public Guid ProductId { get; set; }\n        public string ProductName { get; set; }\n        public string CTAJourney { get; set; }\n        public int ClickCount { get; set; }\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/Catalog/DTOs/ProductDto.cs",
      "sha256": "9351e6b36ce1f707bd46bb92652331f1751b150a9d062ecfd31572a0998d59b7",
      "language": "csharp",
      "size": 549,
      "content": "// File: Features/Catalog/DTOs/ProductDto.cs\n\nnamespace xbytechat.api.Features.Catalog.DTOs\n{\n    public class ProductDto\n    {\n        public Guid Id { get; set; }\n\n        public Guid BusinessId { get; set; }\n        public string Name { get; set; } = string.Empty;\n        public string Description { get; set; } = string.Empty;\n        public decimal Price { get; set; }\n        public string Currency { get; set; } = \"INR\";\n        public string ImageUrl { get; set; } = string.Empty;\n        public bool IsActive { get; set; } = true;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/DTOs/TopProductDto.cs",
      "sha256": "464918c2b2d66c5710042f7d26d7b64fc8f4fb0380f12e7c756a0d248e613684",
      "language": "csharp",
      "size": 228,
      "content": "namespace xbytechat.api.Features.Catalog.DTOs\n{\n    public class TopProductDto\n    {\n        public Guid ProductId { get; set; }\n        public string ProductName { get; set; }\n        public int ClickCount { get; set; }\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/Catalog/DTOs/UpdateProductDto.cs",
      "sha256": "3d2fa63b4ce50da54504b1efa60375305ee53bd12498eb5c359bec2f13aeb11c",
      "language": "csharp",
      "size": 511,
      "content": "// File: Features/Catalog/DTOs/UpdateProductDto.cs\n\nnamespace xbytechat.api.Features.Catalog.DTOs\n{\n    public class UpdateProductDto\n    {\n        public Guid Id { get; set; }\n        public Guid BusinessId { get; set; }\n\n        public string Name { get; set; } = string.Empty;\n        public string Description { get; set; } = string.Empty;\n        public decimal Price { get; set; }\n        public string Currency { get; set; } = \"INR\";\n        public string ImageUrl { get; set; } = string.Empty;\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Models/CatalogClickLog.cs",
      "sha256": "04b5faf86ec274241aa075f5ba6309899ae07f9c0074d1a34285b4f7c96b437d",
      "language": "csharp",
      "size": 1636,
      "content": "namespace xbytechat.api.Features.Catalog.Models\n{\n    public class CatalogClickLog\n    {\n        public Guid Id { get; set; }\n\n        // üîó Business & Product Info\n        public Guid BusinessId { get; set; }\n        public Guid? ProductId { get; set; }\n\n        // üë§ Customer Info\n        public string? UserId { get; set; }\n        public string? UserName { get; set; }\n        public string? UserPhone { get; set; }\n\n        // ü§ñ Bot / Messaging Context\n        public string? BotId { get; set; }\n\n        // üõçÔ∏è Browsing Context\n        public string? CategoryBrowsed { get; set; }\n        public string? ProductBrowsed { get; set; }\n\n        // üîò CTA Clicked\n        public string? CTAJourney { get; set; }\n        public string TemplateId { get; set; }\n        public string RefMessageId { get; set; }\n        public string ButtonText { get; set; }\n\n        // üïí Meta\n        public DateTime? ClickedAt { get; set; } = DateTime.UtcNow;\n\n        // ‚úÖ CRM / Campaign / Analytics\n        public Guid? CampaignSendLogId { get; set; }\n        public Guid? ContactId { get; set; }\n        public bool FollowUpSent { get; set; } = false;\n        public string? LastInteractionType { get; set; }\n        public Guid? MessageLogId { get; set; }\n        public string? PlanSnapshot { get; set; }\n\n        // üÜï [New Additions for CTA Campaign Tracking]\n        public Guid? CtaId { get; set; }             // Link to CTA definition\n        public Guid? CampaignId { get; set; }        // Link to campaign (if any)\n        public string Source { get; set; } = \"catalog\"; // \"catalog\", \"campaign\", \"auto-reply\"\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Models/Product.cs",
      "sha256": "428554206c02d4602a873704a1e49c995a274f4633e0f32d8c0991c4eea72a31",
      "language": "csharp",
      "size": 1062,
      "content": "// File: Features/Catalog/Models/Product.cs\n\nusing System;\n\nnamespace xbytechat.api.Features.Catalog.Models\n{\n    public class Product\n    {\n        public Guid Id { get; set; }\n\n        // üîó Foreign Key - Business/Owner\n        public Guid BusinessId { get; set; }\n\n        // üì¶ Core Product Info\n        public string Name { get; set; } = string.Empty;\n        public string Description { get; set; } = string.Empty;\n        public decimal Price { get; set; }\n        public string Currency { get; set; } = \"INR\";\n        public string ImageUrl { get; set; } = string.Empty;\n\n        // ‚úÖ Visibility & State\n        public bool IsActive { get; set; } = true;\n\n        // üìÖ Metadata\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n        public int TotalClicks { get; set; } = 0; // Total CTA clicks tracked\n        public DateTime? LastClickedAt { get; set; } // Last time a user clicked CTA for this product\n        public string? MostClickedCTA { get; set; } // Button text with highest click count (e.g., \"Buy Now\")\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Services/CatalogDashboardService.cs",
      "sha256": "3303616ebf70e99e2e646759834c707405060cc1b22ceb5f743dfa1d8af50198",
      "language": "csharp",
      "size": 6538,
      "content": "using System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Hosting.Server;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Catalog.DTOs;\nusing static System.Runtime.InteropServices.JavaScript.JSType;\n\nnamespace xbytechat.api.Features.Catalog.Services\n{\n    public class CatalogDashboardService : ICatalogDashboardService\n    {\n        private readonly AppDbContext _context;\n\n        public CatalogDashboardService(AppDbContext context)\n        {\n            _context = context;\n        }\n\n       \n        public async Task<CatalogDashboardSummaryDto> GetDashboardSummaryAsync(Guid businessId)\n        {\n            var today = DateTime.UtcNow.Date;\n\n            var totalMessagesSent = await _context.MessageLogs\n                .CountAsync(m => m.BusinessId == businessId);\n\n            var uniqueCustomersMessaged = await _context.MessageLogs\n                .Where(m => m.BusinessId == businessId)\n                .Select(m => m.RecipientNumber)\n                .Distinct()\n                .CountAsync();\n\n            var productClicks = await _context.CatalogClickLogs\n                .CountAsync(c => c.BusinessId == businessId && c.ProductId != null);\n\n            var activeProducts = await _context.Products\n                .CountAsync(p => p.BusinessId == businessId);\n\n            var productsSharedViaWhatsapp = await _context.CatalogClickLogs\n                .Where(c => c.BusinessId == businessId && c.ProductId != null)\n                .Select(c => c.ProductId)\n                .Distinct()\n                .CountAsync();\n\n            var repeatClickers = await _context.CatalogClickLogs\n                .Where(c => c.BusinessId == businessId)\n                .GroupBy(c => c.UserPhone)\n                .CountAsync(g => g.Count() > 1);\n\n            var newClickersToday = await _context.CatalogClickLogs\n                .Where(c => c.BusinessId == businessId && c.ClickedAt.Value.Date == today)\n                .Select(c => c.UserPhone)\n                .Distinct()\n                .CountAsync();\n            //        var newClickersToday = _context.CatalogClickLogs\n            //.Where(c => c.BusinessId == businessId)\n            //.ToList() // now it's LINQ to Objects\n            //        .Where(c => c.ClickedAt?.Date == today)\n            //        .Select(c => c.UserPhone)\n            //        .Distinct()\n            //.Count();\n            //        But if your data is large, the first(server-side filtering) is the better choice.\n\n            var lastCatalogClickAt = await _context.CatalogClickLogs\n    .Where(c => c.BusinessId == businessId)\n    .MaxAsync(c => (DateTime?)c.ClickedAt);\n\n            var lastMessageSentAt = await _context.MessageLogs\n                .Where(m => m.BusinessId == businessId)\n                .MaxAsync(m => (DateTime?)m.SentAt);\n\n            return new CatalogDashboardSummaryDto\n            {\n                TotalMessagesSent = totalMessagesSent,\n                UniqueCustomersMessaged = uniqueCustomersMessaged,\n                ProductClicks = productClicks,\n                ActiveProducts = activeProducts,\n                ProductsSharedViaWhatsApp = productsSharedViaWhatsapp,\n                RepeatClickers = repeatClickers,\n                NewClickersToday = newClickersToday,\n                LastCatalogClickAt = lastCatalogClickAt,\n                LastMessageSentAt = lastMessageSentAt\n            };\n        }\n\n        public async Task<List<TopProductDto>> GetTopClickedProductsAsync(Guid businessId, int topN = 5)\n        {\n            var topProducts = await _context.CatalogClickLogs\n                .Where(c => c.BusinessId == businessId && c.ProductId != null)\n                .GroupBy(c => c.ProductId)\n                .Select(g => new\n                {\n                    ProductId = g.Key,\n                    ClickCount = g.Count()\n                })\n                .OrderByDescending(x => x.ClickCount)\n                .Take(topN)\n                .ToListAsync();\n\n            // Now fetch product names to join with clicks\n            var productIds = topProducts.Select(x => x.ProductId).ToList();\n\n            var products = await _context.Products\n                .Where(p => productIds.Contains(p.Id))\n                .ToDictionaryAsync(p => p.Id, p => p.Name);\n\n            return topProducts.Select(x => new TopProductDto\n            {\n                ProductId = x.ProductId.Value,\n                ProductName = products.ContainsKey(x.ProductId.Value) ? products[x.ProductId.Value] : \"Unknown\",\n                ClickCount = x.ClickCount\n            }).ToList();\n        }\n        public async Task<List<CtaJourneyStatsDto>> GetCtaJourneyStatsAsync(Guid businessId)\n        {\n            var stats = await _context.CatalogClickLogs\n                .Where(c => c.BusinessId == businessId && !string.IsNullOrEmpty(c.CTAJourney))\n                .GroupBy(c => c.CTAJourney)\n                .Select(g => new CtaJourneyStatsDto\n                {\n                    CTAJourney = g.Key,\n                    ClickCount = g.Count()\n                })\n                .OrderByDescending(x => x.ClickCount)\n                .ToListAsync();\n\n            return stats;\n        }\n        public async Task<List<ProductCtaBreakdownDto>> GetProductCtaBreakdownAsync(Guid businessId)\n        {\n            var groupedClicks = await _context.CatalogClickLogs\n                .Where(c => c.BusinessId == businessId && c.ProductId != null && !string.IsNullOrEmpty(c.CTAJourney))\n                .GroupBy(c => new { c.ProductId, c.CTAJourney })\n                .Select(g => new\n                {\n                    ProductId = g.Key.ProductId.Value,\n                    CTAJourney = g.Key.CTAJourney,\n                    ClickCount = g.Count()\n                })\n                .ToListAsync();\n\n            // Fetch product names for all involved productIds\n            var productIds = groupedClicks.Select(g => g.ProductId).Distinct().ToList();\n\n            var productNames = await _context.Products\n                .Where(p => productIds.Contains(p.Id))\n                .ToDictionaryAsync(p => p.Id, p => p.Name);\n\n            var result = groupedClicks.Select(g => new ProductCtaBreakdownDto\n            {\n                ProductId = g.ProductId,\n                ProductName = productNames.ContainsKey(g.ProductId) ? productNames[g.ProductId] : \"Unknown\",\n                CTAJourney = g.CTAJourney,\n                ClickCount = g.ClickCount\n            }).ToList();\n\n            return result;\n        }\n\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Services/CatalogTrackingService.cs",
      "sha256": "466e53210d232226ec62ffaed236063b75a748eff0f420e423d8f482ff3a4fdf",
      "language": "csharp",
      "size": 6371,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CRM.Models;\nusing xbytechat.api.Features.Catalog.DTOs;\nusing xbytechat.api.Features.Catalog.Models;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Models;\nusing xbytechat.api.Services.Messages.Interfaces;\nusing xbytechat.api.Features.PlanManagement.Models;\nusing xbytechat.api.Features.CRM.Timelines.Services;\n\nnamespace xbytechat.api.Features.Catalog.Services\n{\n    public class CatalogTrackingService : ICatalogTrackingService\n    {\n        private readonly AppDbContext _context;\n        private readonly IMessageService _messageService;\n        private readonly ILeadTimelineService _leadTimelineService;\n\n        public CatalogTrackingService(\n            AppDbContext context,\n            IMessageService messageService,\n            ILeadTimelineService leadTimelineService)\n        {\n            _context = context;\n            _messageService = messageService;\n            _leadTimelineService = leadTimelineService;\n        }\n\n        public async Task<ResponseResult> LogClickAsync(CatalogClickLogDto dto)\n        {\n            if (dto == null || dto.BusinessId == Guid.Empty || string.IsNullOrWhiteSpace(dto.UserPhone))\n            {\n                Log.Warning(\"‚ùå Invalid catalog click log attempt: missing businessId or userPhone.\");\n                return ResponseResult.ErrorInfo(\"Required fields are missing (businessId, userPhone).\");\n            }\n\n            try\n            {\n                Guid? campaignSendLogId = null;\n                Guid? contactId = null;\n                bool followUpSent = false;\n\n                // STEP 1: Link campaign log via RefMessageId if available\n                if (!string.IsNullOrWhiteSpace(dto.RefMessageId))\n                {\n                    var sendLog = await _context.CampaignSendLogs\n                        .FirstOrDefaultAsync(x => x.MessageId == dto.RefMessageId);\n\n                    if (sendLog != null)\n                    {\n                        sendLog.IsClicked = true;\n                        sendLog.ClickedAt = DateTime.UtcNow;\n                        sendLog.ClickType = dto.CTAJourney ?? dto.ButtonText;\n                        campaignSendLogId = sendLog.Id;\n                    }\n                }\n\n                // STEP 2: Link or Create CRM Contact\n                if (!string.IsNullOrWhiteSpace(dto.UserPhone))\n                {\n                    var contact = await _context.Contacts\n                        .FirstOrDefaultAsync(c => c.PhoneNumber == dto.UserPhone && c.BusinessId == dto.BusinessId);\n\n                    if (contact == null)\n                    {\n                        contact = new Contact\n                        {\n                            Id = Guid.NewGuid(),\n                            Name = dto.UserName ?? \"Lead\",\n                            PhoneNumber = dto.UserPhone,\n                            BusinessId = dto.BusinessId,\n                            CreatedAt = DateTime.UtcNow\n                        };\n                        _context.Contacts.Add(contact);\n                        await _context.SaveChangesAsync();\n                    }\n\n                    contactId = contact.Id;\n\n                    // STEP 3: Auto follow-up if plan allows\n                    var business = await _context.Businesses\n                        .AsNoTracking()\n                        .FirstOrDefaultAsync(b => b.Id == dto.BusinessId);\n\n                    if (business?.BusinessPlanInfo?.Plan == PlanType.Advanced)\n                    {\n                        var message = $\"Hi {contact.Name ?? \"there\"}, how can I help you?\";\n                        await _messageService.SendFollowUpAsync(contact.PhoneNumber, message);\n                        followUpSent = true;\n                    }\n                }\n\n                // STEP 4: Save the click with all linked data\n                var log = new CatalogClickLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = dto.BusinessId,\n                    ProductId = dto.ProductId,\n                    UserId = dto.UserId,\n                    UserName = dto.UserName,\n                    UserPhone = dto.UserPhone,\n                    BotId = dto.BotId,\n                    CategoryBrowsed = dto.CategoryBrowsed,\n                    ProductBrowsed = dto.ProductBrowsed,\n                    CTAJourney = dto.CTAJourney,\n                    TemplateId = dto.TemplateId,\n                    ButtonText = dto.ButtonText,\n                    RefMessageId = dto.RefMessageId,\n                    ClickedAt = DateTime.UtcNow,\n                    CampaignSendLogId = campaignSendLogId,\n                    ContactId = contactId,\n                    FollowUpSent = followUpSent,\n                    LastInteractionType = \"Clicked\",\n                    PlanSnapshot = dto.PlanSnapshot\n                };\n\n                _context.CatalogClickLogs.Add(log);\n                await _context.SaveChangesAsync();\n\n                // STEP 5: Save into LeadTimeline (no await error)\n                await _leadTimelineService.AddFromCatalogClickAsync(log);\n\n                Log.Information(\"üìä Catalog click tracked: {BusinessId}, {UserPhone}, {CTA}\", dto.BusinessId, dto.UserPhone, dto.CTAJourney);\n                return ResponseResult.SuccessInfo(\"‚úÖ Click tracked successfully.\", log.Id);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed to log catalog click\");\n                return ResponseResult.ErrorInfo(\"‚ùå Error while tracking catalog click.\", ex.Message);\n            }\n        }\n\n        public async Task<ResponseResult> GetRecentLogsAsync(int limit)\n        {\n            try\n            {\n                var logs = await _context.CatalogClickLogs\n                    .OrderByDescending(x => x.ClickedAt)\n                    .Take(limit)\n                    .ToListAsync();\n\n                return ResponseResult.SuccessInfo(\"Recent logs fetched.\", logs);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed to fetch recent catalog click logs\");\n                return ResponseResult.ErrorInfo(\"Failed to fetch logs.\", ex.Message);\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Services/ICatalogDashboardService.cs",
      "sha256": "9cac16574ec18c7343c13d49a28395b9ab04bf296e8d7b910b05d1cc88378a7d",
      "language": "csharp",
      "size": 546,
      "content": "using System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Catalog.DTOs;\nnamespace xbytechat.api.Features.Catalog.Services\n{\n    public interface ICatalogDashboardService\n    {\n        Task<CatalogDashboardSummaryDto> GetDashboardSummaryAsync(Guid businessId);\n        Task<List<TopProductDto>> GetTopClickedProductsAsync(Guid businessId, int topN = 5);\n        Task<List<CtaJourneyStatsDto>> GetCtaJourneyStatsAsync(Guid businessId);\n        Task<List<ProductCtaBreakdownDto>> GetProductCtaBreakdownAsync(Guid businessId);\n\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Services/ICatalogTrackingService.cs",
      "sha256": "b9ea119f807697f7e52cbea8b7c3aa4320c2ffe23326d076d1d1f0f9a2f12310",
      "language": "csharp",
      "size": 342,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.Catalog.DTOs;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.Catalog.Services\n{\n    public interface ICatalogTrackingService\n    {\n        Task<ResponseResult> LogClickAsync(CatalogClickLogDto dto);\n        Task<ResponseResult> GetRecentLogsAsync(int limit);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Services/IProductService.cs",
      "sha256": "23245f8c5da029c4146e515732f03b3e815636c1fddfec0f38a3a26355bdc1b1",
      "language": "csharp",
      "size": 510,
      "content": "using System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Catalog.DTOs;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.Catalog.Services\n{\n    public interface IProductService\n    {\n        Task<ResponseResult> AddProductAsync(CreateProductDto dto);\n        Task<ResponseResult> RemoveProductAsync(Guid id, Guid businessId);\n        Task<ResponseResult> UpdateProductAsync(UpdateProductDto dto);\n        Task<ResponseResult> GetProductsByBusinessIdAsync(Guid businessId);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Services/ProductService.cs",
      "sha256": "b42253a9398257b4f84555e31c4423127d843bd60b73560f7730b71433d17fd0",
      "language": "csharp",
      "size": 5527,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Catalog.DTOs;\nusing xbytechat.api.Features.Catalog.Models;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.Catalog.Services\n{\n    public class ProductService : IProductService\n    {\n        private readonly AppDbContext _context;\n\n        public ProductService(AppDbContext context)\n        {\n            _context = context;\n        }\n\n        public async Task<ResponseResult> AddProductAsync(CreateProductDto dto)\n        {\n            try\n            {\n                var exists = await _context.Products\n                    .AnyAsync(p => p.BusinessId == dto.BusinessId && p.Name == dto.Name);\n\n                if (exists)\n                {\n                    Log.Warning(\"‚ùå Duplicate product add attempt: {ProductName} for BusinessId: {BusinessId}\", dto.Name, dto.BusinessId);\n                    return ResponseResult.ErrorInfo(\"Product with this name already exists.\");\n                }\n\n                var newProduct = new Product\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = dto.BusinessId,\n                    Name = dto.Name,\n                    Description = dto.Description,\n                    Price = dto.Price,\n                    Currency = dto.Currency,\n                    ImageUrl = dto.ImageUrl,\n                    IsActive = true,\n                    CreatedAt = DateTime.UtcNow\n                };\n\n                await _context.Products.AddAsync(newProduct);\n                await _context.SaveChangesAsync();\n\n                Log.Information(\"‚úÖ Product created: {ProductName} ({ProductId})\", dto.Name, newProduct.Id);\n                return ResponseResult.SuccessInfo(\"‚úÖ Product added successfully.\", newProduct.Id);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed to add product: {ProductName}\", dto.Name);\n                return ResponseResult.ErrorInfo(\"Failed to add product.\", ex.Message);\n            }\n        }\n\n        public async Task<ResponseResult> RemoveProductAsync(Guid id, Guid businessId)\n        {\n            try\n            {\n                var product = await _context.Products\n                    .FirstOrDefaultAsync(p => p.Id == id && p.BusinessId == businessId);\n\n                if (product == null)\n                {\n                    Log.Warning(\"‚ùå Attempted to delete non-existent product: {ProductId}\", id);\n                    return ResponseResult.ErrorInfo(\"Product not found.\");\n                }\n\n                _context.Products.Remove(product);\n                await _context.SaveChangesAsync();\n\n                Log.Information(\"üóëÔ∏è Product deleted: {ProductId}\", id);\n                return ResponseResult.SuccessInfo(\"üóëÔ∏è Product deleted.\");\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed to delete product: {ProductId}\", id);\n                return ResponseResult.ErrorInfo(\"Failed to delete product.\", ex.Message);\n            }\n        }\n\n        public async Task<ResponseResult> UpdateProductAsync(UpdateProductDto dto)\n        {\n            try\n            {\n                var product = await _context.Products\n                    .FirstOrDefaultAsync(p => p.Id == dto.Id && p.BusinessId == dto.BusinessId);\n\n                if (product == null)\n                {\n                    Log.Warning(\"‚ùå Attempted to update non-existent product: {ProductId}\", dto.Id);\n                    return ResponseResult.ErrorInfo(\"Product not found.\");\n                }\n\n                product.Name = dto.Name;\n                product.Description = dto.Description;\n                product.Price = dto.Price;\n                product.Currency = dto.Currency;\n                product.ImageUrl = dto.ImageUrl;\n\n                await _context.SaveChangesAsync();\n\n                Log.Information(\"‚úÖ Product updated: {ProductId}\", dto.Id);\n                return ResponseResult.SuccessInfo(\"‚úÖ Product updated.\");\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed to update product: {ProductId}\", dto.Id);\n                return ResponseResult.ErrorInfo(\"Failed to update product.\", ex.Message);\n            }\n        }\n\n        public async Task<ResponseResult> GetProductsByBusinessIdAsync(Guid businessId)\n        {\n            try\n            {\n                var products = await _context.Products\n                    .Where(p => p.BusinessId == businessId && p.IsActive)\n                    .Select(p => new ProductDto\n                    {\n                        Id = p.Id,\n                        BusinessId = p.BusinessId,\n                        Name = p.Name,\n                        Description = p.Description,\n                        Price = p.Price,\n                        Currency = p.Currency,\n                        ImageUrl = p.ImageUrl,\n                        IsActive = p.IsActive\n                    })\n                    .ToListAsync();\n\n                return ResponseResult.SuccessInfo(\"Products fetched.\", products);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed to fetch products for BusinessId: {BusinessId}\", businessId);\n                return ResponseResult.ErrorInfo(\"Failed to fetch products.\", ex.Message);\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/Controllers/ChatInboxController.cs",
      "sha256": "8bfc29e38e01fd26cfe273ace7ba08ea169d1f222800889f8b122cd771f84789",
      "language": "csharp",
      "size": 30906,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/Controllers/ChatInboxController.cs\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Security.Claims;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.ChatInbox.DTOs;\nusing xbytechat.api.Features.ChatInbox.Models;\nusing xbytechat.api.Features.ChatInbox.Services;\nusing xbytechat.api.Models;\n\nnamespace xbytechat.api.Features.ChatInbox.Controllers\n{\n    [ApiController]\n    [Route(\"api/chat-inbox\")]\n    [Authorize]\n    public sealed class ChatInboxController : ControllerBase\n    {\n        private readonly IChatInboxQueryService _queryService;\n        private readonly IChatInboxCommandService _commandService;\n        private readonly IChatInboxAssignmentService _assignmentService;\n        private readonly IChatInboxMediaUploadService _mediaUploadService;\n        private readonly IChatInboxMediaContentService _mediaContentService;\n        private readonly AppDbContext _db;\n        private readonly ILogger<ChatInboxController> _logger;\n\n        public ChatInboxController(\n            IChatInboxQueryService queryService,\n            IChatInboxCommandService commandService,\n            IChatInboxAssignmentService assignmentService,\n            IChatInboxMediaUploadService mediaUploadService,\n            IChatInboxMediaContentService mediaContentService,\n            AppDbContext db,\n            ILogger<ChatInboxController> logger)\n        {\n            _queryService = queryService ?? throw new ArgumentNullException(nameof(queryService));\n            _commandService = commandService ?? throw new ArgumentNullException(nameof(commandService));\n            _assignmentService = assignmentService ?? throw new ArgumentNullException(nameof(assignmentService));\n            _mediaUploadService = mediaUploadService ?? throw new ArgumentNullException(nameof(mediaUploadService));\n            _mediaContentService = mediaContentService ?? throw new ArgumentNullException(nameof(mediaContentService));\n            _db = db ?? throw new ArgumentNullException(nameof(db));\n            _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n        }\n\n        private const long MaxUploadBytes = 10 * 1024 * 1024; // 10MB\n        private const string InboxAssignPermissionCode = \"INBOX.CHAT.ASSIGN\";\n\n        private static readonly HashSet<string> AllowedContentTypes = new HashSet<string>(StringComparer.OrdinalIgnoreCase)\n        {\n            \"image/jpeg\",\n            \"image/png\",\n            \"image/webp\",\n            \"application/pdf\",\n            \"video/mp4\",\n            \"video/3gpp\",\n            \"audio/mpeg\",\n            \"audio/mp4\",\n            \"audio/aac\",\n            \"audio/ogg\"\n        };\n\n        [HttpPost(\"media/upload\")]\n        [Consumes(\"multipart/form-data\")]\n        [ProducesResponseType(typeof(ChatInboxMediaUploadResponseDto), 200)]\n        public async Task<ActionResult<ChatInboxMediaUploadResponseDto>> UploadMedia(\n            [FromForm] ChatInboxMediaUploadRequestDto form,\n            CancellationToken ct = default)\n        {\n            var tokenBiz = GetBusinessId();\n            if (!tokenBiz.HasValue) return Unauthorized(\"businessId missing in token.\");\n\n            var file = form?.File;\n            if (file == null) return BadRequest(\"file is required.\");\n            if (file.Length <= 0) return BadRequest(\"file is empty.\");\n            if (file.Length > MaxUploadBytes) return BadRequest($\"file is too large. Max allowed is {MaxUploadBytes / (1024 * 1024)}MB.\");\n\n            // Some browsers append parameters like \"audio/ogg; codecs=opus\"\n            var mimeRaw = (file.ContentType ?? string.Empty).Trim();\n            var mime = mimeRaw.Split(';', 2)[0].Trim();\n            if (string.IsNullOrWhiteSpace(mime) || !AllowedContentTypes.Contains(mime))\n                return BadRequest(\"Unsupported file type. Allowed: image/jpeg, image/png, image/webp, application/pdf, video/mp4, audio/mpeg, audio/mp4, audio/aac, audio/ogg.\");\n\n            var mediaType = string.Equals(mime, \"application/pdf\", StringComparison.OrdinalIgnoreCase)\n                ? \"document\"\n                : mime.StartsWith(\"video/\", StringComparison.OrdinalIgnoreCase)\n                    ? \"video\"\n                    : mime.StartsWith(\"audio/\", StringComparison.OrdinalIgnoreCase)\n                        ? \"audio\"\n                        : \"image\";\n\n            var safeName = Path.GetFileName(file.FileName ?? \"upload.bin\");\n\n            try\n            {\n                var mediaId = await _mediaUploadService.UploadToWhatsAppAsync(\n                    tokenBiz.Value,\n                    phoneNumberId: null,\n                    file,\n                    ct).ConfigureAwait(false);\n\n                return Ok(new ChatInboxMediaUploadResponseDto\n                {\n                    MediaId = mediaId,\n                    MediaType = mediaType,\n                    FileName = safeName,\n                    MimeType = mime,\n                    SizeBytes = file.Length\n                });\n            }\n            catch (InvalidOperationException ex)\n            {\n                return BadRequest(new { message = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"ChatInbox media upload failed. BusinessId={BusinessId}\", tokenBiz.Value);\n                return BadRequest(new { message = \"Media upload failed. Please try again.\" });\n            }\n        }\n\n        [HttpGet(\"media/{mediaId}/content\")]\n        public async Task<IActionResult> GetMediaContent(\n            [FromRoute] string mediaId,\n            CancellationToken ct = default)\n        {\n            var tokenBiz = GetBusinessId();\n            if (!tokenBiz.HasValue) return Unauthorized(\"businessId missing in token.\");\n\n            var tokenUserId = GetUserId();\n            if (!tokenUserId.HasValue) return Unauthorized(\"userId missing in token.\");\n\n            var mid = (mediaId ?? string.Empty).Trim();\n            if (string.IsNullOrWhiteSpace(mid)) return BadRequest(\"mediaId is required.\");\n\n            var row = await _db.MessageLogs\n                .AsNoTracking()\n                .Where(m =>\n                    m.BusinessId == tokenBiz.Value &&\n                    m.MediaId != null &&\n                    m.MediaId == mid &&\n                    m.ContactId != null)\n                .OrderByDescending(m => m.SentAt ?? m.CreatedAt)\n                .ThenByDescending(m => m.Id)\n                .Select(m => new\n                {\n                    ContactId = m.ContactId!.Value,\n                    m.FileName,\n                    m.MimeType,\n                    m.MediaType\n                })\n                .FirstOrDefaultAsync(ct)\n                .ConfigureAwait(false);\n\n            if (row == null) return NotFound(new { message = \"Media not found.\" });\n\n            try\n            {\n                await EnsureCanAccessContactAsync(tokenBiz.Value, tokenUserId.Value, row.ContactId, ct)\n                    .ConfigureAwait(false);\n            }\n            catch (UnauthorizedAccessException ex)\n            {\n                return StatusCode(StatusCodes.Status403Forbidden, new { message = ex.Message });\n            }\n\n            try\n            {\n                var (stream, contentType) = await _mediaContentService\n                    .DownloadFromWhatsAppAsync(tokenBiz.Value, mid, ct)\n                    .ConfigureAwait(false);\n\n                var finalType = !string.IsNullOrWhiteSpace(row.MimeType)\n                    ? row.MimeType!\n                    : (contentType ?? \"application/octet-stream\");\n\n                var fallbackName = string.Equals(row.MediaType, \"document\", StringComparison.OrdinalIgnoreCase)\n                    ? \"document.pdf\"\n                    : string.Equals(row.MediaType, \"video\", StringComparison.OrdinalIgnoreCase)\n                        ? \"video.mp4\"\n                        : string.Equals(row.MediaType, \"audio\", StringComparison.OrdinalIgnoreCase)\n                            ? \"audio\"\n                            : \"image\";\n\n                var safeName = Path.GetFileName(row.FileName ?? fallbackName);\n                Response.Headers[\"Cache-Control\"] = \"no-store\";\n                Response.Headers[\"Content-Disposition\"] = $\"inline; filename=\\\"{safeName}\\\"\";\n\n                return File(stream, finalType);\n            }\n            catch (InvalidOperationException ex)\n            {\n                return BadRequest(new { message = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"ChatInbox media proxy failed. BusinessId={BusinessId} MediaId={MediaId}\", tokenBiz.Value, mid);\n                return BadRequest(new { message = \"Failed to load media. Please try again.\" });\n            }\n        }\n\n        [HttpGet(\"conversations\")]\n        [ProducesResponseType(typeof(IReadOnlyList<ChatInboxConversationDto>), 200)]\n        public async Task<IActionResult> GetConversations(\n            [FromQuery] Guid businessId,\n            [FromQuery] Guid? currentUserId, // kept for backward compatibility; ignored (token wins)\n            [FromQuery] string? tab,\n            [FromQuery] string? numberId,\n            [FromQuery] string? search,\n            [FromQuery] int? limit,\n            [FromQuery] bool paged = false,\n            [FromQuery] string? cursor = null,\n            CancellationToken cancellationToken = default)\n        {\n            if (businessId == Guid.Empty) return BadRequest(\"businessId is required.\");\n\n            var tokenBiz = GetBusinessId();\n            if (!tokenBiz.HasValue) return Unauthorized(\"businessId missing in token.\");\n            if (tokenBiz.Value != businessId) return Forbid(\"businessId does not match your tenant.\");\n\n            var tokenUserId = GetUserId();\n            if (!tokenUserId.HasValue) return Unauthorized(\"userId missing in token.\");\n\n            var filter = new ChatInboxFilterDto\n            {\n                BusinessId = businessId,\n                CurrentUserId = tokenUserId.Value, // ‚úÖ token wins\n                Tab = tab,\n                NumberId = string.IsNullOrWhiteSpace(numberId) ? null : numberId,\n                SearchTerm = string.IsNullOrWhiteSpace(search) ? null : search,\n                Limit = limit.GetValueOrDefault(50),\n                Cursor = cursor\n            };\n\n            if (!paged)\n            {\n                var result = await _queryService.GetConversationsAsync(filter, cancellationToken);\n                return Ok(result);\n            }\n\n            var page = await _queryService.GetConversationsPageAsync(filter, cancellationToken);\n            return Ok(page);\n        }\n\n        [HttpGet(\"agents\")]\n        [ProducesResponseType(typeof(List<AgentDto>), 200)]\n        public async Task<IActionResult> GetAgents(\n            [FromQuery] Guid businessId,\n            CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty) return BadRequest(\"businessId is required.\");\n\n            var tokenBiz = GetBusinessId();\n            if (!tokenBiz.HasValue) return Unauthorized(\"businessId missing in token.\");\n            if (tokenBiz.Value != businessId) return Forbid(\"businessId does not match your tenant.\");\n\n            try\n            {\n                var rows = await _assignmentService.GetAgentsAsync(businessId, ct);\n                return Ok(rows);\n            }\n            catch (Exception ex)\n            {\n                return BadRequest(ex.Message);\n            }\n        }\n\n        [HttpGet(\"messages\")]\n        [ProducesResponseType(typeof(IReadOnlyList<ChatInboxMessageDto>), 200)]\n        public async Task<IActionResult> GetMessages(\n            [FromQuery] Guid businessId,\n            [FromQuery] Guid? contactId,\n            [FromQuery] string? contactPhone,\n            [FromQuery] int limit = 50,\n            [FromQuery] bool paged = false,\n            [FromQuery] string? cursor = null,\n            CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty) return BadRequest(\"businessId is required.\");\n\n            var tokenBiz = GetBusinessId();\n            if (!tokenBiz.HasValue) return Unauthorized(\"businessId missing in token.\");\n            if (tokenBiz.Value != businessId) return Forbid(\"businessId does not match your tenant.\");\n\n            var tokenUserId = GetUserId();\n            if (!tokenUserId.HasValue) return Unauthorized(\"userId missing in token.\");\n\n            var uid = tokenUserId.Value;\n\n            // ‚úÖ Prefer ContactId path\n            if (contactId.HasValue && contactId.Value != Guid.Empty)\n            {\n                if (!paged)\n                {\n                    // ‚úÖ SECURED overload (enforces AssignedOnly visibility)\n                    var messages = await _queryService.GetMessagesForConversationByContactIdAsync(\n                        businessId, contactId.Value, limit, uid, ct);\n\n                    return Ok(messages);\n                }\n\n                // ‚úÖ SECURED overload (enforces AssignedOnly visibility)\n                var page = await _queryService.GetMessagesPageForConversationByContactIdAsync(\n                    businessId, contactId.Value, limit, cursor, uid, ct);\n\n                return Ok(page);\n            }\n\n            // Fallback: by phone\n            if (string.IsNullOrWhiteSpace(contactPhone))\n                return BadRequest(\"Provide either contactId or contactPhone.\");\n\n            if (!paged)\n            {\n                // ‚úÖ SECURED overload (enforces AssignedOnly visibility)\n                var byPhone = await _queryService.GetMessagesForConversationAsync(\n                    businessId, contactPhone, limit, uid, ct);\n\n                return Ok(byPhone);\n            }\n\n            // ‚úÖ SECURED overload (enforces AssignedOnly visibility)\n            var byPhonePage = await _queryService.GetMessagesPageForConversationByPhoneAsync(\n                businessId, contactPhone, limit, cursor, uid, ct);\n\n            return Ok(byPhonePage);\n        }\n\n        [HttpPost(\"send-message\")]\n        [ProducesResponseType(typeof(ChatInboxMessageDto), 200)]\n        public async Task<ActionResult<ChatInboxMessageDto>> SendMessage(\n            [FromBody] ChatInboxSendMessageRequestDto request,\n            CancellationToken ct = default)\n        {\n            if (request == null) return BadRequest(\"Request body is required.\");\n\n            var tokenBiz = GetBusinessId();\n            if (!tokenBiz.HasValue) return Unauthorized(\"businessId missing in token.\");\n\n            // Multi-tenant safety: never trust BusinessId from client; token wins.\n            request.BusinessId = tokenBiz.Value;\n\n            var tokenUserId = GetUserId();\n            if (!tokenUserId.HasValue) return Unauthorized(\"userId missing in token.\");\n\n            // ‚úÖ Critical: server-side actor identity\n            request.ActorUserId = tokenUserId.Value;\n\n            try\n            {\n                var result = await _commandService.SendAgentMessageAsync(request, ct);\n                return Ok(result);\n            }\n            catch (UnauthorizedAccessException ex)\n            {\n                _logger.LogWarning(\n                    ex,\n                    \"Forbidden chat-inbox send-message. BusinessId={BusinessId} ActorUserId={ActorUserId} ConversationId={ConversationId} ContactId={ContactId}\",\n                    request.BusinessId,\n                    tokenUserId.Value,\n                    request.ConversationId,\n                    request.ContactId);\n                return StatusCode(StatusCodes.Status403Forbidden, new { message = ex.Message });\n            }\n            catch (ArgumentException ex)\n            {\n                return BadRequest(ex.Message);\n            }\n            catch (InvalidOperationException ex)\n            {\n                return BadRequest(ex.Message);\n            }\n        }\n\n        //[HttpPost(\"mark-read\")]\n        //[ProducesResponseType(204)]\n        //public async Task<IActionResult> MarkRead(\n        //    [FromBody] ChatInboxMarkReadRequestDto request,\n        //    CancellationToken ct = default)\n        //{\n        //    if (request == null) return BadRequest(\"Request body is required.\");\n        //    if (request.BusinessId == Guid.Empty || request.ContactId == Guid.Empty)\n        //        return BadRequest(\"BusinessId and ContactId are required.\");\n\n        //    // ‚úÖ BusinessId MUST match token (security boundary)\n        //    var tokenBiz = GetBusinessId();\n        //    if (!tokenBiz.HasValue) return Unauthorized(\"businessId missing in token.\");\n        //    if (tokenBiz.Value != request.BusinessId) return Forbid(\"businessId does not match your tenant.\");\n\n        //    // ‚úÖ UserId MUST come from token (never trust client)\n        //    var tokenUserId = GetUserId();\n        //    if (!tokenUserId.HasValue) return Unauthorized(\"userId missing in token.\");\n\n        //    // Backward compatible: if client sent UserId, we ignore it and force token user.\n        //    request.UserId = tokenUserId.Value;\n\n        //    try\n        //    {\n        //        await _commandService.MarkConversationAsReadAsync(request, ct);\n        //        return NoContent();\n        //    }\n        //    catch (UnauthorizedAccessException ex)\n        //    {\n        //        _logger.LogWarning(\n        //            ex,\n        //            \"Forbidden chat-inbox mark-read. BusinessId={BusinessId} ActorUserId={ActorUserId} ContactId={ContactId}\",\n        //            request.BusinessId,\n        //            tokenUserId.Value,\n        //            request.ContactId);\n\n        //        return StatusCode(StatusCodes.Status403Forbidden, new { message = ex.Message });\n        //    }\n        //    catch (ArgumentException ex)\n        //    {\n        //        return BadRequest(ex.Message);\n        //    }\n        //    catch (InvalidOperationException ex)\n        //    {\n        //        return BadRequest(ex.Message);\n        //    }\n        //}\n        [HttpPost(\"mark-read\")]\n        [ProducesResponseType(204)]\n        public async Task<IActionResult> MarkRead(\n    [FromBody] ChatInboxMarkReadRequestDto request,\n    CancellationToken ct = default)\n        {\n            if (request == null) return BadRequest(\"Request body is required.\");\n            if (request.BusinessId == Guid.Empty || request.ContactId == Guid.Empty)\n                return BadRequest(\"BusinessId and ContactId are required.\");\n\n            var tokenBiz = GetBusinessId();\n            if (!tokenBiz.HasValue) return Unauthorized(\"businessId missing in token.\");\n            if (tokenBiz.Value != request.BusinessId) return Forbid(\"businessId does not match your tenant.\");\n\n            var tokenUserId = GetUserId();\n            if (!tokenUserId.HasValue) return Unauthorized(\"userId missing in token.\");\n\n            await _commandService.MarkConversationAsReadAsync(\n                request.BusinessId,\n                request.ContactId,\n                tokenUserId.Value,          // ‚úÖ token wins\n                request.LastReadAtUtc,\n                ct);\n\n            return NoContent();\n        }\n\n\n\n        [HttpPost(\"assign\")]\n        [ProducesResponseType(200)]\n        public async Task<IActionResult> Assign(\n            [FromBody] AssignConversationDto request,\n            CancellationToken ct = default)\n        {\n            if (request == null) return BadRequest(\"Request body is required.\");\n\n            if (request.BusinessId == Guid.Empty ||\n                request.ContactId == Guid.Empty ||\n                request.UserId == Guid.Empty)\n            {\n                return BadRequest(\"BusinessId, ContactId and UserId are required.\");\n            }\n\n            var tokenBiz = GetBusinessId();\n            if (!tokenBiz.HasValue) return Unauthorized(\"businessId missing in token.\");\n            if (tokenBiz.Value != request.BusinessId) return Forbid(\"businessId does not match your tenant.\");\n\n            var actorUserId = GetUserId();\n            if (!actorUserId.HasValue) return Unauthorized(\"userId missing in token.\");\n\n            try\n            {\n                await _assignmentService.AssignAsync(\n                    request.BusinessId,\n                    request.ContactId,\n                    request.UserId,\n                    actorUserId.Value,\n                    ct);\n\n                var updated = await TryGetConversationAsync(\n                    request.BusinessId,\n                    request.ContactId,\n                    actorUserId.Value,\n                    ct);\n\n                return Ok(new { success = true, conversation = updated });\n            }\n            catch (UnauthorizedAccessException ex)\n            {\n                _logger.LogWarning(\n                    ex,\n                    \"Forbidden chat-inbox assign. BusinessId={BusinessId} ActorUserId={ActorUserId} ContactId={ContactId} AssigneeUserId={AssigneeUserId}\",\n                    request.BusinessId,\n                    actorUserId.Value,\n                    request.ContactId,\n                    request.UserId);\n                return StatusCode(StatusCodes.Status403Forbidden, new { message = ex.Message });\n            }\n            catch (InvalidOperationException ex)\n            {\n                return NotFound(ex.Message);\n            }\n            catch (ArgumentException ex)\n            {\n                return BadRequest(ex.Message);\n            }\n        }\n\n        [HttpPost(\"unassign\")]\n        [ProducesResponseType(200)]\n        public async Task<IActionResult> Unassign(\n            [FromBody] UnassignConversationDto request,\n            CancellationToken ct = default)\n        {\n            if (request == null) return BadRequest(\"Request body is required.\");\n\n            if (request.BusinessId == Guid.Empty || request.ContactId == Guid.Empty)\n                return BadRequest(\"BusinessId and ContactId are required.\");\n\n            var tokenBiz = GetBusinessId();\n            if (!tokenBiz.HasValue) return Unauthorized(\"businessId missing in token.\");\n            if (tokenBiz.Value != request.BusinessId) return Forbid(\"businessId does not match your tenant.\");\n\n            var actorUserId = GetUserId();\n            if (!actorUserId.HasValue) return Unauthorized(\"userId missing in token.\");\n\n            try\n            {\n                await _assignmentService.UnassignAsync(\n                    request.BusinessId,\n                    request.ContactId,\n                    actorUserId.Value,\n                    ct);\n\n                var updated = await TryGetConversationAsync(\n                    request.BusinessId,\n                    request.ContactId,\n                    actorUserId.Value,\n                    ct);\n\n                return Ok(new { success = true, conversation = updated });\n            }\n            catch (UnauthorizedAccessException ex)\n            {\n                _logger.LogWarning(\n                    ex,\n                    \"Forbidden chat-inbox unassign. BusinessId={BusinessId} ActorUserId={ActorUserId} ContactId={ContactId}\",\n                    request.BusinessId,\n                    actorUserId.Value,\n                    request.ContactId);\n                return StatusCode(StatusCodes.Status403Forbidden, new { message = ex.Message });\n            }\n            catch (InvalidOperationException ex)\n            {\n                return NotFound(ex.Message);\n            }\n            catch (ArgumentException ex)\n            {\n                return BadRequest(ex.Message);\n            }\n        }\n\n        [HttpPost(\"set-status\")]\n        [ProducesResponseType(200)]\n        public async Task<IActionResult> SetStatus(\n            [FromBody] SetConversationStatusDto request,\n            CancellationToken ct = default)\n        {\n            if (request == null) return BadRequest(\"Request body is required.\");\n\n            if (request.BusinessId == Guid.Empty || request.ContactId == Guid.Empty)\n                return BadRequest(\"BusinessId and ContactId are required.\");\n\n            var tokenBiz = GetBusinessId();\n            if (!tokenBiz.HasValue) return Unauthorized(\"businessId missing in token.\");\n            if (tokenBiz.Value != request.BusinessId) return Forbid(\"businessId does not match your tenant.\");\n\n            var actorUserId = GetUserId();\n            if (!actorUserId.HasValue) return Unauthorized(\"userId missing in token.\");\n\n            try\n            {\n                await _assignmentService.SetStatusAsync(\n                    request.BusinessId,\n                    request.ContactId,\n                    request.Status,\n                    actorUserId.Value,\n                    ct);\n\n                var updated = await TryGetConversationAsync(\n                    request.BusinessId,\n                    request.ContactId,\n                    actorUserId.Value,\n                    ct);\n\n                return Ok(new { success = true, conversation = updated });\n            }\n            catch (UnauthorizedAccessException ex)\n            {\n                _logger.LogWarning(\n                    ex,\n                    \"Forbidden chat-inbox set-status. BusinessId={BusinessId} ActorUserId={ActorUserId} ContactId={ContactId} Status={Status}\",\n                    request.BusinessId,\n                    actorUserId.Value,\n                    request.ContactId,\n                    request.Status);\n                return StatusCode(StatusCodes.Status403Forbidden, new { message = ex.Message });\n            }\n            catch (InvalidOperationException ex)\n            {\n                return NotFound(ex.Message);\n            }\n            catch (ArgumentException ex)\n            {\n                return BadRequest(ex.Message);\n            }\n        }\n\n        private Guid? GetBusinessId()\n        {\n            var raw = User.FindFirstValue(\"businessId\") ?? User.FindFirstValue(\"BusinessId\");\n            return Guid.TryParse(raw, out var id) ? id : null;\n        }\n\n        private Guid? GetUserId()\n        {\n            var raw = User.FindFirstValue(ClaimTypes.NameIdentifier) ?? User.FindFirstValue(\"id\");\n            return Guid.TryParse(raw, out var id) ? id : null;\n        }\n\n        private async Task EnsureCanAccessContactAsync(\n            Guid businessId,\n            Guid userId,\n            Guid contactId,\n            CancellationToken ct)\n        {\n            var visibility = await _db.Businesses\n                .AsNoTracking()\n                .Where(b => b.Id == businessId)\n                .Select(b => (InboxVisibilityMode?)b.InboxVisibilityMode)\n                .FirstOrDefaultAsync(ct)\n                .ConfigureAwait(false) ?? InboxVisibilityMode.SharedInInbox;\n\n            if (visibility != InboxVisibilityMode.AssignedOnly) return;\n\n            var canSeeAll = await CanSeeAllInRestrictedModeAsync(businessId, userId, ct).ConfigureAwait(false);\n            if (canSeeAll) return;\n\n            var allowed = await _db.Contacts\n                .AsNoTracking()\n                .AnyAsync(c =>\n                    c.BusinessId == businessId &&\n                    c.Id == contactId &&\n                    c.AssignedAgentId == userId, ct)\n                .ConfigureAwait(false);\n\n            if (!allowed)\n                throw new UnauthorizedAccessException(\"Restricted inbox: you are not assigned to this conversation.\");\n        }\n\n        private static bool IsPrivilegedRoleName(string? roleName)\n        {\n            var role = (roleName ?? string.Empty).Trim().ToLowerInvariant();\n            return role is \"admin\" or \"business\" or \"superadmin\" or \"partner\";\n        }\n\n        private async Task<bool> CanSeeAllInRestrictedModeAsync(Guid businessId, Guid userId, CancellationToken ct)\n        {\n            var userRow = await _db.Users\n                .AsNoTracking()\n                .Where(u => u.Id == userId && u.BusinessId == businessId && !u.IsDeleted && u.Status == \"Active\")\n                .Select(u => new\n                {\n                    u.RoleId,\n                    RoleName = u.Role != null ? u.Role.Name : null\n                })\n                .FirstOrDefaultAsync(ct)\n                .ConfigureAwait(false);\n\n            if (userRow == null) return false;\n\n            if (IsPrivilegedRoleName(userRow.RoleName))\n                return true;\n\n            return await HasPermissionAsync(userId, InboxAssignPermissionCode, ct).ConfigureAwait(false);\n        }\n\n        private async Task<bool> HasPermissionAsync(Guid userId, string permissionCode, CancellationToken ct)\n        {\n            var code = (permissionCode ?? string.Empty).Trim().ToUpperInvariant();\n            if (code.Length == 0) return false;\n\n            var permissionId = await _db.Permissions\n                .AsNoTracking()\n                .Where(p => p.Code != null && p.Code.ToUpper() == code)\n                .Select(p => (Guid?)p.Id)\n                .FirstOrDefaultAsync(ct)\n                .ConfigureAwait(false);\n\n            if (!permissionId.HasValue) return false;\n\n            var direct = await _db.UserPermissions\n                .AsNoTracking()\n                .AnyAsync(up =>\n                    up.UserId == userId &&\n                    up.PermissionId == permissionId.Value &&\n                    up.IsGranted &&\n                    !up.IsRevoked, ct)\n                .ConfigureAwait(false);\n\n            if (direct) return true;\n\n            var roleId = await _db.Users\n                .AsNoTracking()\n                .Where(u => u.Id == userId)\n                .Select(u => u.RoleId)\n                .FirstOrDefaultAsync(ct)\n                .ConfigureAwait(false);\n\n            if (!roleId.HasValue) return false;\n\n            return await _db.RolePermissions\n                .AsNoTracking()\n                .AnyAsync(rp =>\n                    rp.RoleId == roleId.Value &&\n                    rp.PermissionId == permissionId.Value &&\n                    rp.IsActive &&\n                    !rp.IsRevoked, ct)\n                .ConfigureAwait(false);\n        }\n\n        private async Task<ChatInboxConversationDto?> TryGetConversationAsync(\n            Guid businessId,\n            Guid contactId,\n            Guid currentUserId,\n            CancellationToken ct)\n        {\n            var rows = await _queryService.GetConversationsAsync(\n                    new ChatInboxFilterDto\n                    {\n                        BusinessId = businessId,\n                        CurrentUserId = currentUserId,\n                        ContactId = contactId,\n                        Limit = 1\n                    },\n                    ct)\n                .ConfigureAwait(false);\n\n            return rows.FirstOrDefault();\n        }\n    }\n}\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/AgentDto.cs",
      "sha256": "39fd6eeec1233fec19f32ed1469ce217e586a955f1ea169451717c0773ef8c0f",
      "language": "csharp",
      "size": 311,
      "content": "using System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    public sealed class AgentDto\n    {\n        public Guid Id { get; set; }\n        public string Name { get; set; } = string.Empty;\n        public string Email { get; set; } = string.Empty;\n        public string? RoleName { get; set; }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/AssignConversationDto.cs",
      "sha256": "b2ef282b759c81018f7a8c7d3cba0dbe28e69910dec66d2a49f34d5045a5484f",
      "language": "csharp",
      "size": 256,
      "content": "using System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    public sealed class AssignConversationDto\n    {\n        public Guid BusinessId { get; set; }\n        public Guid ContactId { get; set; }\n        public Guid UserId { get; set; }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ChatInboxAssignRequestDto.cs",
      "sha256": "1070b71e595443da5bb86c5ae223123d517333fd06193925c55359d7d2e869ae",
      "language": "csharp",
      "size": 1156,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/DTOs/ChatInboxAssignRequestDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    /// <summary>\n    /// Request payload for assigning a conversation (contact) to a specific user.\n    /// </summary>\n    public sealed class ChatInboxAssignRequestDto\n    {\n        /// <summary>\n        /// Tenant/business id.\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// Contact id representing the conversation.\n        /// </summary>\n        public Guid ContactId { get; set; }\n\n        /// <summary>\n        /// Agent/user who will own this conversation.\n        /// </summary>\n        public Guid UserId { get; set; }\n    }\n\n    /// <summary>\n    /// Request payload for unassigning a conversation.\n    /// </summary>\n    public sealed class ChatInboxUnassignRequestDto\n    {\n        /// <summary>\n        /// Tenant/business id.\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// Contact id representing the conversation.\n        /// </summary>\n        public Guid ContactId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ChatInboxChangeStatusRequestDto.cs",
      "sha256": "caa15f4feb193863671beebe56a0421fababa24609b3249d3e63742645710a2e",
      "language": "csharp",
      "size": 1063,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/DTOs/ChatInboxChangeStatusRequestDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    /// <summary>\n    /// Command payload for changing the status of an Inbox conversation.\n    /// Internally this maps to Contact.IsArchived / IsActive.\n    /// </summary>\n    public sealed class ChatInboxChangeStatusRequestDto\n    {\n        /// <summary>\n        /// Tenant / business id (required).\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// Contact whose conversation we want to change (required).\n        /// </summary>\n        public Guid ContactId { get; set; }\n\n        /// <summary>\n        /// Target status: \"Open\" | \"Closed\" (case-insensitive).\n        /// We also accept \"New\"/\"Pending\" but treat them as Open internally.\n        /// </summary>\n        public string? TargetStatus { get; set; }\n\n        // Compatibility alias for newer clients posting { status: \"Open\"|\"Pending\"|\"Closed\" }\n        public string? Status { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ChatInboxConversationDto.cs",
      "sha256": "83d1e01c8c7b6c57f0bfc96714d5ef38287e0d3e7858149adb32b9ed12636678",
      "language": "csharp",
      "size": 2559,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/DTOs/ChatInboxConversationDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    /// <summary>\n    /// Lightweight conversation summary for the Chat Inbox UI.\n    /// Mirrors the front-end ConversationSummary model.\n    /// </summary>\n    public sealed class ChatInboxConversationDto\n    {\n        /// <summary>\n        /// Conversation identifier for the UI.\n        /// For v1 this can be derived from (ContactId + NumberId).\n        /// In the future, if you create an InboxConversation table,\n        /// use its primary key here.\n        /// </summary>\n        public string Id { get; set; } = default!;\n\n        public Guid ContactId { get; set; }\n        public string ContactName { get; set; } = string.Empty;\n        public string ContactPhone { get; set; } = string.Empty;\n\n        public string LastMessagePreview { get; set; } = string.Empty;\n        public DateTime LastMessageAt { get; set; }\n\n        public int UnreadCount { get; set; }\n\n        /// <summary>\n        /// \"New\" | \"Open\" | \"Pending\" | \"Closed\"\n        /// </summary>\n        public string Status { get; set; } = \"Open\";\n\n        /// <summary>\n        /// WhatsApp number id (e.g. wa-num-1).\n        /// Later you may map this to WhatsAppPhoneNumber.Id.\n        /// </summary>\n        public string NumberId { get; set; } = string.Empty;\n\n        public string NumberLabel { get; set; } = string.Empty;\n\n        /// <summary>\n        /// True if within 24h messaging window (WhatsApp session).\n        /// </summary>\n        public bool Within24h { get; set; }\n\n        public string? AssignedToUserId { get; set; }\n        public string? AssignedToUserName { get; set; }\n        public bool IsAssignedToMe { get; set; }\n\n        /// <summary>\n        /// \"automation\" | \"agent\"\n        /// </summary>\n        public string Mode { get; set; } = \"automation\";\n\n        /// <summary>\n        /// \"AutoReply\" | \"Campaign\" | \"Manual\" | \"Unknown\"\n        /// </summary>\n        public string SourceType { get; set; } = \"Unknown\";\n\n        /// <summary>\n        /// Campaign name / AutoReply flow name / other source label.\n        /// </summary>\n        public string? SourceName { get; set; }\n\n        public DateTime? FirstSeenAt { get; set; }\n        public DateTime? LastInboundAt { get; set; }\n        public DateTime? LastOutboundAt { get; set; }\n        public int TotalMessages { get; set; }\n\n        public DateTime? LastAgentReplyAt { get; set; }\n        public DateTime? LastAutomationAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ChatInboxCursorPageDto.cs",
      "sha256": "5b9d3ba892a383e22762a110b1cbfd2038d445929c9ab4b03b9d0c339b840123",
      "language": "csharp",
      "size": 520,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/DTOs/ChatInboxCursorPageDto.cs\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    /// <summary>\n    /// Cursor-based page response (stable for chat inbox).\n    /// </summary>\n    public sealed class ChatInboxCursorPageDto<T>\n    {\n        public IReadOnlyList<T> Items { get; init; } = new List<T>();\n        public string? NextCursor { get; init; }\n        public bool HasMore { get; init; }\n        public int Limit { get; init; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ChatInboxFilterDto.cs",
      "sha256": "b99a5373eb144c852da882a680e3fb479d1a5b649af882f3465e9e30715968a0",
      "language": "csharp",
      "size": 1916,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/DTOs/ChatInboxFilterDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    /// <summary>\n    /// Filters used by the Chat Inbox conversation list endpoint.\n    /// This matches the UI needs: tab, number, search, \"my\" vs \"unassigned\".\n    /// </summary>\n    public sealed class ChatInboxFilterDto\n    {\n        /// <summary>\n        /// Business Id (tenant). Mandatory for multi-tenant isolation.\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        public string? Cursor { get; set; }\n        /// <summary>\n        /// Currently logged-in user id (for \"my\" filter).\n        /// Optional: if null, \"my\" filter is ignored.\n        /// </summary>\n        public Guid? CurrentUserId { get; set; }\n\n        /// <summary>\n        /// \"live\" | \"older\" | \"unassigned\" | \"my\" | \"closed\"\n        /// </summary>\n        public string? Tab { get; set; }\n\n        /// <summary>\n        /// Optional: fetch a single conversation by contact id.\n        /// </summary>\n        public Guid? ContactId { get; set; }\n\n        /// <summary>\n        /// WhatsApp number id, e.g. \"wa-num-1\". If null or \"all\", no filter.\n        /// </summary>\n        public string? NumberId { get; set; }\n\n        /// <summary>\n        /// Free text search over name, phone, and last message preview.\n        /// </summary>\n        public string? SearchTerm { get; set; }\n\n        /// <summary>\n        /// Max number of conversations to return. Hard-capped to 200.\n        /// </summary>\n        public int Limit { get; set; } = 50;\n\n        /// <summary>\n        /// If true: only conversations without AssignedToUserId.\n        /// </summary>\n        public bool OnlyUnassigned { get; set; }\n\n        /// <summary>\n        /// If true: only conversations assigned to CurrentUserId.\n        /// </summary>\n        public bool OnlyAssignedToMe { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ChatInboxMarkReadRequestDto.cs",
      "sha256": "a149e08b11d6e43c54066ace777250ca1a630fbe15ef812f7fdc73b6fa67d3d0",
      "language": "csharp",
      "size": 864,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/DTOs/ChatInboxMarkReadRequestDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    /// <summary>\n    /// Request payload for marking a conversation as \"read\"\n    /// in the Chat Inbox.\n    /// </summary>\n    public sealed class ChatInboxMarkReadRequestDto\n    {\n        /// <summary>\n        /// Tenant/business id (required for multi-tenant isolation).\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// CRM Contact id whose messages are being marked as read.\n        /// </summary>\n        public Guid ContactId { get; set; }\n\n        /// <summary>\n        /// Optional timestamp for \"last read\". If not supplied,\n        /// the server will use DateTime.UtcNow.\n        /// </summary>\n        public DateTime? LastReadAtUtc { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ChatInboxMediaUploadRequestDto.cs",
      "sha256": "6374d18d1fa2a5ae289a17972f84c6693d0631ce10d312053e64f62c425b8415",
      "language": "csharp",
      "size": 274,
      "content": "using System.ComponentModel.DataAnnotations;\nusing Microsoft.AspNetCore.Http;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    public sealed class ChatInboxMediaUploadRequestDto\n    {\n        [Required]\n        public IFormFile File { get; set; } = default!;\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ChatInboxMediaUploadResponseDto.cs",
      "sha256": "ae80a0e2830c284d7c7a52d12f86a10e59a9e6959951252d9e532b9c4a6d6bb6",
      "language": "csharp",
      "size": 489,
      "content": "namespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    public sealed class ChatInboxMediaUploadResponseDto\n    {\n        public string MediaId { get; set; } = string.Empty;\n\n        /// <summary>\n        /// \"image\" | \"document\"\n        /// </summary>\n        public string MediaType { get; set; } = string.Empty;\n\n        public string FileName { get; set; } = string.Empty;\n        public string MimeType { get; set; } = string.Empty;\n        public long SizeBytes { get; set; }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ChatInboxMessageDto.cs",
      "sha256": "f8f922c594dd6eab46fd6a23854879e9656d87965e61b0a7376d101d1e1b06e3",
      "language": "csharp",
      "size": 2484,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/DTOs/ChatInboxMessageDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    /// <summary>\n    /// Single message in a Chat Inbox conversation.\n    /// Kept intentionally simple and stable so the React UI\n    /// can bind to it without worrying about provider details.\n    /// </summary>\n    public sealed class ChatInboxMessageDto\n    {\n        public Guid Id { get; set; }\n\n        /// <summary>\n        /// \"in\"  = message came from customer to us.\n        /// \"out\" = message we sent to customer.\n        /// For now we only have reliable data for \"out\"; we keep\n        /// the string type so we can extend it later without schema changes.\n        /// </summary>\n        public string Direction { get; set; } = \"out\";\n\n        /// <summary>\n        /// Channel identifier (e.g. \"whatsapp\") ‚Äì future-proofing.\n        /// </summary>\n        public string Channel { get; set; } = \"whatsapp\";\n\n        /// <summary>\n        /// Rendered text content for the bubble.\n        /// For templates we'll store the final rendered body.\n        /// </summary>\n        public string Text { get; set; } = string.Empty;\n\n        /// <summary>\n        /// WhatsApp media_id (if this is a media message).\n        /// </summary>\n        public string? MediaId { get; set; }\n\n        /// <summary>\n        /// \"image\" | \"document\" | \"video\" | \"audio\" | \"location\"\n        /// </summary>\n        public string? MediaType { get; set; }\n\n        public string? FileName { get; set; }\n        public string? MimeType { get; set; }\n\n        // Location message fields (when MediaType == \"location\")\n        public double? LocationLatitude { get; set; }\n        public double? LocationLongitude { get; set; }\n        public string? LocationName { get; set; }\n        public string? LocationAddress { get; set; }\n\n        /// <summary>\n        /// When we created/sent the message (UTC).\n        /// If SentAt is missing, falls back to CreatedAt.\n        /// </summary>\n        public DateTime SentAtUtc { get; set; }\n\n        /// <summary>\n        /// Provider / delivery status (‚ÄúSent‚Äù, ‚ÄúDelivered‚Äù, ‚ÄúRead‚Äù, ‚ÄúFailed‚Äù, etc.),\n        /// mapped from MessageLog.Status.\n        /// </summary>\n        public string? Status { get; set; }\n\n        /// <summary>\n        /// For failed messages, a short error string from MessageLog.ErrorMessage.\n        /// </summary>\n        public string? ErrorMessage { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ChatInboxSendMessageRequestDto.cs",
      "sha256": "0a72e0104e08707d417ff580ebf77e10e625d9b19e431c9bca6d8efad72ef923",
      "language": "csharp",
      "size": 2198,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/DTOs/ChatInboxSendMessageRequestDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    /// <summary>\n    /// Request payload for sending an agent reply from the Chat Inbox.\n    /// NOTE: ActorUserId is ALWAYS set by the server from JWT claims.\n    /// The client should NOT send it (and we ignore it if they do).\n    /// </summary>\n    public sealed class ChatInboxSendMessageRequestDto\n    {\n        public Guid BusinessId { get; set; }\n\n        public string? ConversationId { get; set; }\n\n        public Guid? ContactId { get; set; }\n\n        public string To { get; set; } = string.Empty;\n\n        public string? NumberId { get; set; }\n\n        /// <summary>\n        /// Optional for media messages. Required when sending plain text.\n        /// For media, this becomes the optional caption.\n        /// </summary>\n        public string? Text { get; set; }\n\n        /// <summary>\n        /// WhatsApp Cloud API media id returned by /{phone_number_id}/media upload.\n        /// </summary>\n        public string? MediaId { get; set; }\n\n        /// <summary>\n        /// \"image\" | \"document\" | \"video\" | \"audio\"\n        /// For location messages, send coordinates and set MediaType to \"location\" (MediaId must be null).\n        /// </summary>\n        public string? MediaType { get; set; }\n\n        /// <summary>\n        /// Original filename for UI display (optional).\n        /// </summary>\n        public string? FileName { get; set; }\n\n        /// <summary>\n        /// Client-supplied mime type for display/logging (optional).\n        /// </summary>\n        public string? MimeType { get; set; }\n\n        /// <summary>\n        /// Optional: WhatsApp \"location\" message fields.\n        /// When provided, MediaId must be null.\n        /// </summary>\n        public double? LocationLatitude { get; set; }\n        public double? LocationLongitude { get; set; }\n        public string? LocationName { get; set; }\n        public string? LocationAddress { get; set; }\n\n        /// <summary>\n        /// Server-side only (claims). Controller will overwrite it.\n        /// </summary>\n        public Guid ActorUserId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ConversationSummaryDto.cs",
      "sha256": "8d4800233670cbca833d145eba5da1a64e0b2a520e5f5bfc65ea5a36c2c9ce86",
      "language": "csharp",
      "size": 2421,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    /// <summary>\n    /// Read model used by the Chat Inbox to show the left-hand conversation list.\n    /// Mirrors the shape used in ChatInbox.jsx (INITIAL_CONVERSATIONS).\n    /// </summary>\n    public class ConversationSummaryDto\n    {\n        public Guid ContactId { get; set; }\n\n        /// <summary>\n        /// Primary display name (CRM contact name).\n        /// </summary>\n        public string? Name { get; set; }\n\n        /// <summary>\n        /// WhatsApp phone number (normalized).\n        /// </summary>\n        public string PhoneNumber { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Latest WhatsApp profile.name we saw.\n        /// </summary>\n        public string? ProfileName { get; set; }\n\n        /// <summary>\n        /// Short preview of the last message in this conversation.\n        /// </summary>\n        public string? LastMessagePreview { get; set; }\n\n        /// <summary>\n        /// When the last message was seen/sent.\n        /// </summary>\n        public DateTime? LastMessageAt { get; set; }\n\n        /// <summary>\n        /// Count of unread inbound messages for this contact.\n        /// </summary>\n        public int UnreadCount { get; set; }\n\n        /// <summary>\n        /// Priority like \"Hot\", \"Warm\", \"Cold\" (CRM-driven, optional).\n        /// </summary>\n        public string? Priority { get; set; }\n\n        /// <summary>\n        /// True if this contact is treated as VIP or important.\n        /// </summary>\n        public bool IsVip { get; set; }\n\n        /// <summary>\n        /// Conversation mode: \"automation\" or \"agent\".\n        /// </summary>\n        public string Mode { get; set; } = \"automation\";\n\n        /// <summary>\n        /// Name of the assigned agent (if any).\n        /// </summary>\n        public string? AssignedAgentName { get; set; }\n\n        /// <summary>\n        /// CRM tags as chips for quick context (e.g. VIP, Lead, Follow-up).\n        /// </summary>\n        public List<string> Tags { get; set; } = new();\n\n        /// <summary>\n        /// Text like \"3 notes ‚Ä¢ 1 reminder today\".\n        /// </summary>\n        public string? LastActivitySummary { get; set; }\n\n        /// <summary>\n        /// Text like \"Next follow-up tomorrow at 11:30 AM\".\n        /// </summary>\n        public string? TaskSummary { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/PagedResultDto.cs",
      "sha256": "256698ff426847411942435cade73faa92f50fc27f5e7dbc7c0f762636295a9c",
      "language": "csharp",
      "size": 300,
      "content": "using System.Collections.Generic;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    public sealed class PagedResultDto<T>\n    {\n        public IReadOnlyList<T> Items { get; set; } = new List<T>();\n        public string? NextCursor { get; set; }\n        public bool HasMore { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/SetConversationStatusDto.cs",
      "sha256": "5686e967c1ba7e485a8d5f69b4da51b3a69d36cc023b4ad5fbd04d7cba000ec0",
      "language": "csharp",
      "size": 277,
      "content": "using System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    public sealed class SetConversationStatusDto\n    {\n        public Guid BusinessId { get; set; }\n        public Guid ContactId { get; set; }\n        public string Status { get; set; } = string.Empty;\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/UnassignConversationDto.cs",
      "sha256": "0b4e055e968dada296fa15e5e67504d866f3fa7f6eaef725a22ff4461a7a47cf",
      "language": "csharp",
      "size": 217,
      "content": "using System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    public sealed class UnassignConversationDto\n    {\n        public Guid BusinessId { get; set; }\n        public Guid ContactId { get; set; }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/Models/InboxVisibilityMode.cs",
      "sha256": "bc601a083f20bb953e8ea9e5ea77287d22bbe2fc6998ab7b0e6ace4658896154",
      "language": "csharp",
      "size": 154,
      "content": "namespace xbytechat.api.Features.ChatInbox.Models\n{\n    public enum InboxVisibilityMode\n    {\n        SharedInInbox = 0,\n        AssignedOnly = 1\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/Services/ChatInboxAssignmentService.cs",
      "sha256": "2f77b7126a586ad3ce50d7958c4b37735d813513c50850985f314c6247f46bdd",
      "language": "csharp",
      "size": 14600,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.SignalR;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.AuthModule.Models;\nusing xbytechat.api.Features.AccessControl.Models;\nusing xbytechat.api.Features.ChatInbox.DTOs;\nusing xbytechat.api.Features.CRM.Models;\nusing xbytechat.api.Features.Inbox.Hubs;\n\nnamespace xbytechat.api.Features.ChatInbox.Services\n{\n    public sealed class ChatInboxAssignmentService : IChatInboxAssignmentService\n    {\n        private const string InboxAssignPermissionCode = \"INBOX.CHAT.ASSIGN\";\n\n        private readonly AppDbContext _db;\n        private readonly ILogger<ChatInboxAssignmentService> _logger;\n        private readonly IHubContext<InboxHub> _hub;\n\n        public ChatInboxAssignmentService(\n            AppDbContext db,\n            ILogger<ChatInboxAssignmentService> logger,\n            IHubContext<InboxHub> hub)\n        {\n            _db = db ?? throw new ArgumentNullException(nameof(db));\n            _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n            _hub = hub ?? throw new ArgumentNullException(nameof(hub));\n        }\n\n        public async Task<List<AgentDto>> GetAgentsAsync(Guid businessId, CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty)\n                throw new ArgumentException(\"BusinessId is required.\", nameof(businessId));\n\n            var agents = await _db.Users\n                .AsNoTracking()\n                .Where(u => u.BusinessId == businessId && !u.IsDeleted && u.Status == \"Active\")\n                .Include(u => u.Role)\n                .OrderBy(u => u.Name)\n                .Select(u => new AgentDto\n                {\n                    Id = u.Id,\n                    Name = u.Name ?? u.Email,\n                    Email = u.Email,\n                    RoleName = u.Role != null ? u.Role.Name : null\n                })\n                .ToListAsync(ct)\n                .ConfigureAwait(false);\n\n            return agents;\n        }\n\n        public async Task AssignAsync(\n            Guid businessId,\n            Guid contactId,\n            Guid userId,\n            Guid actorUserId,\n            CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty) throw new ArgumentException(\"BusinessId is required.\", nameof(businessId));\n            if (contactId == Guid.Empty) throw new ArgumentException(\"ContactId is required.\", nameof(contactId));\n            if (userId == Guid.Empty) throw new ArgumentException(\"UserId is required.\", nameof(userId));\n            if (actorUserId == Guid.Empty) throw new ArgumentException(\"ActorUserId is required.\", nameof(actorUserId));\n\n            var actor = await LoadActiveBusinessUserAsync(businessId, actorUserId, ct).ConfigureAwait(false);\n            _ = await LoadActiveBusinessUserAsync(businessId, userId, ct).ConfigureAwait(false); // validate target exists + active\n\n            var isSelfAssign = actorUserId == userId;\n            var canAssignOthers = await CanAssignOthersAsync(actor, ct).ConfigureAwait(false);\n\n            // ? If assigning someone else, permission required\n            if (!isSelfAssign && !canAssignOthers)\n                throw new UnauthorizedAccessException(\"Not allowed to assign conversations to other agents.\");\n\n            // ? Atomic rules:\n            // - Privileged/assign-perm can assign/reassign freely.\n            // - Self-assign without privilege is allowed ONLY when currently unassigned (prevents stealing).\n            var q = _db.Contacts.Where(c => c.BusinessId == businessId && c.Id == contactId);\n\n            if (isSelfAssign && !canAssignOthers)\n                q = q.Where(c => c.AssignedAgentId == null);\n\n            var updated = await q\n                .ExecuteUpdateAsync(\n                    setters => setters.SetProperty(c => c.AssignedAgentId, userId),\n                    ct)\n                .ConfigureAwait(false);\n\n            if (updated == 0)\n            {\n                if (isSelfAssign && !canAssignOthers)\n                    throw new UnauthorizedAccessException(\"Not allowed to self-assign. This chat is already assigned to another agent.\");\n\n                throw new InvalidOperationException(\"Contact not found for assignment.\");\n            }\n\n            _logger.LogInformation(\n                \"ChatInbox assigned. BusinessId={BusinessId} ContactId={ContactId} AssignedToUserId={AssignedToUserId} ActorUserId={ActorUserId}\",\n                businessId, contactId, userId, actorUserId);\n\n            await BroadcastRefreshAsync(businessId).ConfigureAwait(false);\n        }\n\n\n\n        public async Task UnassignAsync(Guid businessId, Guid contactId, Guid actorUserId, CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty) throw new ArgumentException(\"BusinessId is required.\", nameof(businessId));\n            if (contactId == Guid.Empty) throw new ArgumentException(\"ContactId is required.\", nameof(contactId));\n            if (actorUserId == Guid.Empty) throw new ArgumentException(\"ActorUserId is required.\", nameof(actorUserId));\n\n            var actor = await LoadActiveBusinessUserAsync(businessId, actorUserId, ct).ConfigureAwait(false);\n            var canAssignOthers = await CanAssignOthersAsync(actor, ct).ConfigureAwait(false);\n\n            // ? Atomic rules:\n            // - Privileged/assign-perm can unassign freely.\n            // - Non-privileged can unassign ONLY if currently assigned to them (or already unassigned).\n            var q = _db.Contacts.Where(c => c.BusinessId == businessId && c.Id == contactId);\n\n            if (!canAssignOthers)\n                q = q.Where(c => c.AssignedAgentId == null || c.AssignedAgentId == actorUserId);\n\n            var updated = await q\n                .ExecuteUpdateAsync(setters => setters.SetProperty(c => c.AssignedAgentId, (Guid?)null), ct)\n                .ConfigureAwait(false);\n\n            if (updated == 0)\n            {\n                // ? Perfect distinction: not found vs not allowed\n                var exists = await _db.Contacts\n                    .AsNoTracking()\n                    .AnyAsync(c => c.BusinessId == businessId && c.Id == contactId, ct)\n                    .ConfigureAwait(false);\n\n                if (!exists)\n                    throw new InvalidOperationException(\"Contact not found.\");\n\n                throw new UnauthorizedAccessException(\"Not allowed to unassign conversations owned by another agent.\");\n            }\n\n            _logger.LogInformation(\n                \"ChatInbox unassigned. BusinessId={BusinessId} ContactId={ContactId} ActorUserId={ActorUserId}\",\n                businessId, contactId, actorUserId);\n\n            await BroadcastRefreshAsync(businessId).ConfigureAwait(false);\n        }\n\n\n        public async Task SetStatusAsync(\n            Guid businessId,\n            Guid contactId,\n            string status,\n            Guid actorUserId,\n            CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty) throw new ArgumentException(\"BusinessId is required.\", nameof(businessId));\n            if (contactId == Guid.Empty) throw new ArgumentException(\"ContactId is required.\", nameof(contactId));\n            if (actorUserId == Guid.Empty) throw new ArgumentException(\"ActorUserId is required.\", nameof(actorUserId));\n\n            var normalized = NormalizeStatus(status);\n            if (normalized == null)\n                throw new ArgumentException(\"Status must be one of: Open, Pending, Closed.\", nameof(status));\n\n            var actor = await LoadActiveBusinessUserAsync(businessId, actorUserId, ct).ConfigureAwait(false);\n            var contact = await LoadBusinessContactAsync(businessId, contactId, ct).ConfigureAwait(false);\n\n            var canUpdate =\n                IsPrivilegedRole(actor) ||\n                (contact.AssignedAgentId.HasValue && contact.AssignedAgentId.Value == actorUserId);\n\n            if (!canUpdate)\n                throw new UnauthorizedAccessException(\"Not allowed to update this conversation status.\");\n\n            contact.InboxStatus = normalized;\n\n            // Back-compat for older query logic\n            if (normalized == \"Closed\")\n            {\n                contact.IsArchived = true;\n                contact.IsActive = false;\n            }\n            else\n            {\n                contact.IsArchived = false;\n                contact.IsActive = true;\n            }\n\n            _logger.LogInformation(\n                \"ChatInbox status updated. BusinessId={BusinessId} ContactId={ContactId} Status={Status} ActorUserId={ActorUserId}\",\n                businessId, contactId, normalized, actorUserId);\n\n            await _db.SaveChangesAsync(ct).ConfigureAwait(false);\n            await BroadcastRefreshAsync(businessId).ConfigureAwait(false);\n        }\n\n        private static string? NormalizeStatus(string? status)\n        {\n            var raw = (status ?? string.Empty).Trim();\n            if (raw.Length == 0) return null;\n\n            var lower = raw.ToLowerInvariant();\n            return lower switch\n            {\n                \"open\" => \"Open\",\n                \"pending\" => \"Pending\",\n                \"closed\" => \"Closed\",\n                _ => null\n            };\n        }\n\n        private async Task<Contact> LoadBusinessContactAsync(Guid businessId, Guid contactId, CancellationToken ct)\n        {\n            var contact = await _db.Contacts\n                .FirstOrDefaultAsync(c => c.BusinessId == businessId && c.Id == contactId, ct)\n                .ConfigureAwait(false);\n\n            if (contact == null)\n                throw new InvalidOperationException(\"Contact not found.\");\n\n            return contact;\n        }\n\n        private async Task<User> LoadActiveBusinessUserAsync(Guid businessId, Guid userId, CancellationToken ct)\n        {\n            var user = await _db.Users\n                .Include(u => u.Role)\n                .FirstOrDefaultAsync(u => u.Id == userId && !u.IsDeleted, ct)\n                .ConfigureAwait(false);\n\n            if (user == null)\n                throw new InvalidOperationException(\"User not found.\");\n\n            if (user.BusinessId != businessId)\n                throw new UnauthorizedAccessException(\"User does not belong to this business.\");\n\n            if (!string.Equals(user.Status, \"Active\", StringComparison.OrdinalIgnoreCase))\n                throw new UnauthorizedAccessException(\"User is not active.\");\n\n            return user;\n        }\n\n        private static bool IsPrivilegedRole(User actor)\n        {\n            var role = (actor.Role?.Name ?? string.Empty).Trim().ToLowerInvariant();\n            return role is \"admin\" or \"business\" or \"superadmin\" or \"partner\";\n        }\n\n        private async Task<bool> CanAssignOthersAsync(User actor, CancellationToken ct)\n        {\n            if (IsPrivilegedRole(actor)) return true;\n            return await HasPermissionAsync(actor.Id, InboxAssignPermissionCode, ct).ConfigureAwait(false);\n        }\n\n        private async Task<bool> HasPermissionAsync(Guid userId, string permissionCode, CancellationToken ct)\n        {\n            // Permission sources checked:\n            // 1) UserPermissions (direct user overrides)\n            // 2) RolePermissions (business role mapping)\n            var rawCode = (permissionCode ?? string.Empty).Trim();\n            var code = rawCode.ToUpperInvariant();\n            if (code.Length == 0) return false;\n\n            var permissionId = await _db.Permissions\n                .AsNoTracking()\n                .Where(p => p.Code != null && p.Code.ToUpper() == code)\n                .Select(p => (Guid?)p.Id)\n                .FirstOrDefaultAsync(ct)\n                .ConfigureAwait(false);\n\n            if (!permissionId.HasValue) return false;\n\n            var direct = await _db.UserPermissions\n                .AsNoTracking()\n                .AnyAsync(\n                    up => up.UserId == userId\n                          && up.PermissionId == permissionId.Value\n                          && up.IsGranted\n                          && !up.IsRevoked,\n                    ct)\n                .ConfigureAwait(false);\n\n            if (direct)\n            {\n                _logger.LogDebug(\n                    \"Permission granted via UserPermissions override. UserId={UserId} PermissionCode={PermissionCode}\",\n                    userId,\n                    rawCode);\n                return true;\n            }\n\n            var roleId = await _db.Users\n                .AsNoTracking()\n                .Where(u => u.Id == userId)\n                .Select(u => u.RoleId)\n                .FirstOrDefaultAsync(ct)\n                .ConfigureAwait(false);\n\n            if (!roleId.HasValue)\n            {\n                _logger.LogDebug(\n                    \"Permission denied (no role). UserId={UserId} PermissionCode={PermissionCode}\",\n                    userId,\n                    rawCode);\n                return false;\n            }\n\n            var byRole = await _db.RolePermissions\n                .AsNoTracking()\n                .AnyAsync(\n                    rp => rp.RoleId == roleId.Value\n                          && rp.PermissionId == permissionId.Value\n                          && rp.IsActive\n                          && !rp.IsRevoked,\n                    ct)\n                .ConfigureAwait(false);\n\n            if (byRole)\n            {\n                _logger.LogDebug(\n                    \"Permission granted via RolePermissions mapping. UserId={UserId} RoleId={RoleId} PermissionCode={PermissionCode}\",\n                    userId,\n                    roleId.Value,\n                    rawCode);\n                return true;\n            }\n\n            _logger.LogDebug(\n                \"Permission denied (no direct or role grant). UserId={UserId} RoleId={RoleId} PermissionCode={PermissionCode}\",\n                userId,\n                roleId.Value,\n                rawCode);\n\n            return byRole;\n        }\n\n        private async Task BroadcastRefreshAsync(Guid businessId)\n        {\n            try\n            {\n                await _hub.Clients\n                    .Group($\"business_{businessId}\")\n                    .SendAsync(\"UnreadCountChanged\", new { refresh = true })\n                    .ConfigureAwait(false);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"Failed to broadcast inbox refresh. BusinessId={BusinessId}\", businessId);\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/Services/ChatInboxCommandService.cs",
      "sha256": "1903a47a21202dae04970f7ef082e3f9a12f5566d569d4aeaf661371d04a9fcb",
      "language": "csharp",
      "size": 20979,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/Services/ChatInboxCommandService.cs\nusing System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.AuthModule.Models;                 // User\nusing xbytechat.api.Features.AccessControl.Models;     // Permissions, RolePermissions, UserPermissions\nusing xbytechat.api.Features.ChatInbox.DTOs;\nusing xbytechat.api.Features.CRM.Models;               // Contact\nusing xbytechat.api.Features.Inbox.Models;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Models;                            // AppDbContext, MessageLog\n\nnamespace xbytechat.api.Features.ChatInbox.Services\n{\n    /// <summary>\n    /// SharedInInbox visibility + Assigned-only reply (enterprise).\n    ///\n    /// Rules (Shared visibility):\n    /// 1) Anyone can SEE chats (SharedInInbox) ‚Äî enforced on query layer/UI.\n    /// 2) Reply allowed ONLY when:\n    ///    - chat is assigned to actor, OR\n    ///    - actor is Business/Platform privileged, OR\n    ///    - actor has INBOX.CHAT.ASSIGN (manager-style override)\n    /// 3) Unassigned chats:\n    ///    - ‚úÖ Any ACTIVE agent can \"claim on reply\" (auto self-assign) and reply.\n    /// </summary>\n    public sealed class ChatInboxCommandService : IChatInboxCommandService\n    {\n        private const string InboxAssignPermissionCode = \"INBOX.CHAT.ASSIGN\";\n\n        private readonly AppDbContext _db;\n        private readonly IMessageEngineService _messageEngine;\n\n        public ChatInboxCommandService(AppDbContext db, IMessageEngineService messageEngine)\n        {\n            _db = db ?? throw new ArgumentNullException(nameof(db));\n            _messageEngine = messageEngine ?? throw new ArgumentNullException(nameof(messageEngine));\n        }\n\n        public async Task<ChatInboxMessageDto> SendAgentMessageAsync(\n            ChatInboxSendMessageRequestDto request,\n            CancellationToken ct = default)\n        {\n            if (request == null) throw new ArgumentNullException(nameof(request));\n\n            if (request.BusinessId == Guid.Empty)\n                throw new ArgumentException(\"BusinessId is required.\", nameof(request));\n\n            // NOTE: ActorUserId must be set server-side from token (do NOT trust UI).\n            if (request.ActorUserId == Guid.Empty)\n                throw new ArgumentException(\"ActorUserId is required (server-side).\", nameof(request));\n\n            if (string.IsNullOrWhiteSpace(request.To))\n                throw new ArgumentException(\"Target phone (To) is required.\", nameof(request));\n\n            var text = string.IsNullOrWhiteSpace(request.Text) ? null : request.Text.Trim();\n            var mediaId = string.IsNullOrWhiteSpace(request.MediaId) ? null : request.MediaId.Trim();\n            var mediaType = string.IsNullOrWhiteSpace(request.MediaType) ? null : request.MediaType.Trim().ToLowerInvariant();\n            var hasLocation = request.LocationLatitude.HasValue && request.LocationLongitude.HasValue;\n\n            var hasText = !string.IsNullOrWhiteSpace(text);\n            var hasMedia = !string.IsNullOrWhiteSpace(mediaId);\n\n            if (!hasText && !hasMedia && !hasLocation)\n                throw new ArgumentException(\"Either Text, MediaId, or Location is required.\", nameof(request));\n\n            if (hasMedia && mediaType is not (\"image\" or \"document\" or \"video\" or \"audio\"))\n                throw new ArgumentException(\"MediaType must be 'image', 'document', 'video', or 'audio'.\", nameof(request));\n\n            if (hasMedia && mediaType == \"audio\" && hasText)\n                throw new ArgumentException(\"Audio messages do not support captions. Please remove Text.\", nameof(request));\n\n            if (hasLocation && (hasMedia || hasText))\n                throw new ArgumentException(\"Location messages cannot include Text or MediaId.\", nameof(request));\n\n            if (hasLocation)\n            {\n                var lat = request.LocationLatitude!.Value;\n                var lon = request.LocationLongitude!.Value;\n                if (lat < -90 || lat > 90) throw new ArgumentException(\"LocationLatitude must be between -90 and 90.\", nameof(request));\n                if (lon < -180 || lon > 180) throw new ArgumentException(\"LocationLongitude must be between -180 and 180.\", nameof(request));\n            }\n\n            var businessId = request.BusinessId;\n            var actorUserId = request.ActorUserId;\n            var phone = request.To.Trim();\n\n            // ‚úÖ Load actor (must be active and belong to business)\n            var actor = await LoadActiveBusinessUserAsync(businessId, actorUserId, ct).ConfigureAwait(false);\n\n            // ‚úÖ Resolve & load contact (tracked)\n            var contact = await LoadTrackedContactAsync(businessId, request.ContactId, phone, ct).ConfigureAwait(false);\n\n            // ‚úÖ Closed / archived / inactive => block\n            EnsureConversationIsReplyable(contact);\n\n            // ‚úÖ Enforce reply rules (includes claim-on-reply for ANY agent)\n            await EnforceAssignedOnlyReplyAsync(actor, contact, ct).ConfigureAwait(false);\n\n            // üì® Send via MessagesEngine\n            var result =\n                hasMedia\n                    ? await SendMediaAsync(businessId, phone, contact.Id, request, mediaId!, mediaType!, text).ConfigureAwait(false)\n                    : hasLocation\n                        ? await SendLocationAsync(businessId, phone, contact.Id, request).ConfigureAwait(false)\n                        : await _messageEngine.SendTextDirectAsync(new TextMessageSendDto\n                        {\n                            BusinessId = businessId,\n                            RecipientNumber = phone,\n                            TextContent = text!,\n                            ContactId = contact.Id,\n                            PhoneNumberId = string.IsNullOrWhiteSpace(request.NumberId) ? null : request.NumberId.Trim(),\n                            Provider = null,\n                            Source = \"agent\"\n                        }).ConfigureAwait(false);\n\n            // Load log for richer bubble\n            MessageLog? log = null;\n            if (result.LogId.HasValue)\n            {\n                log = await _db.MessageLogs\n                    .AsNoTracking()\n                    .FirstOrDefaultAsync(m => m.Id == result.LogId.Value, ct)\n                    .ConfigureAwait(false);\n            }\n\n            // Update conversation meta (outbound)\n            var nowUtc = DateTime.UtcNow;\n            contact.LastOutboundAt = nowUtc;\n            await _db.SaveChangesAsync(ct).ConfigureAwait(false);\n\n            var bubbleId = log?.Id ?? Guid.NewGuid();\n            var bubbleText = log?.MessageContent ?? (text ?? string.Empty);\n\n            var ts = log?.SentAt ?? log?.CreatedAt ?? nowUtc;\n            var sentAtUtc = ts.Kind == DateTimeKind.Utc ? ts : ts.ToUniversalTime();\n\n            var status = log?.Status ?? (result.Success ? \"Sent\" : \"Failed\");\n            var err = log?.ErrorMessage ?? (result.Success ? null : result.Message);\n\n            return new ChatInboxMessageDto\n            {\n                Id = bubbleId,\n                Direction = \"out\",\n                Channel = \"whatsapp\",\n                Text = bubbleText,\n                MediaId = log?.MediaId,\n                MediaType = log?.MediaType,\n                FileName = log?.FileName,\n                MimeType = log?.MimeType,\n                LocationLatitude = log?.LocationLatitude,\n                LocationLongitude = log?.LocationLongitude,\n                LocationName = log?.LocationName,\n                LocationAddress = log?.LocationAddress,\n                SentAtUtc = sentAtUtc,\n                Status = status,\n                ErrorMessage = err\n            };\n        }\n\n        private async Task<ResponseResult> SendMediaAsync(\n            Guid businessId,\n            string to,\n            Guid contactId,\n            ChatInboxSendMessageRequestDto request,\n            string mediaId,\n            string mediaType,\n            string? caption)\n        {\n            var dto = new MediaMessageSendDto\n            {\n                BusinessId = businessId,\n                RecipientNumber = to,\n                MediaId = mediaId,\n                Caption = caption,\n                FileName = string.IsNullOrWhiteSpace(request.FileName) ? null : request.FileName.Trim(),\n                MimeType = string.IsNullOrWhiteSpace(request.MimeType) ? null : request.MimeType.Trim(),\n                ContactId = contactId,\n                PhoneNumberId = string.IsNullOrWhiteSpace(request.NumberId) ? null : request.NumberId.Trim(),\n                Provider = null,\n                Source = \"agent\"\n            };\n\n            return mediaType switch\n            {\n                \"image\" => await _messageEngine.SendImageDirectAsync(dto).ConfigureAwait(false),\n                \"document\" => await _messageEngine.SendDocumentDirectAsync(dto).ConfigureAwait(false),\n                \"video\" => await _messageEngine.SendVideoDirectAsync(dto).ConfigureAwait(false),\n                \"audio\" => await _messageEngine.SendAudioDirectAsync(dto).ConfigureAwait(false),\n                _ => throw new ArgumentException(\"Unsupported MediaType.\", nameof(mediaType))\n            };\n        }\n\n        private Task<ResponseResult> SendLocationAsync(\n            Guid businessId,\n            string to,\n            Guid contactId,\n            ChatInboxSendMessageRequestDto request)\n        {\n            var dto = new LocationMessageSendDto\n            {\n                BusinessId = businessId,\n                RecipientNumber = to,\n                ContactId = contactId,\n                PhoneNumberId = string.IsNullOrWhiteSpace(request.NumberId) ? null : request.NumberId.Trim(),\n                Provider = null,\n                Source = \"agent\",\n                Latitude = request.LocationLatitude!.Value,\n                Longitude = request.LocationLongitude!.Value,\n                Name = string.IsNullOrWhiteSpace(request.LocationName) ? null : request.LocationName.Trim(),\n                Address = string.IsNullOrWhiteSpace(request.LocationAddress) ? null : request.LocationAddress.Trim()\n            };\n\n            return _messageEngine.SendLocationDirectAsync(dto);\n        }\n\n        //public async Task MarkConversationAsReadAsync(ChatInboxMarkReadRequestDto request, CancellationToken ct = default)\n        //{\n        //    if (request == null) throw new ArgumentNullException(nameof(request));\n        //    if (request.BusinessId == Guid.Empty) throw new ArgumentException(\"BusinessId is required.\", nameof(request));\n        //    if (request.ContactId == Guid.Empty) throw new ArgumentException(\"ContactId is required.\", nameof(request));\n        //    if (request.UserId == Guid.Empty) throw new ArgumentException(\"UserId is required.\", nameof(request));\n\n        //    var businessId = request.BusinessId;\n        //    var contactId = request.ContactId;\n        //    var userId = request.UserId;\n        //    var nowUtc = DateTime.UtcNow;\n\n        //    var lastReadAt = request.LastReadAtUtc.HasValue\n        //        ? (request.LastReadAtUtc.Value.Kind == DateTimeKind.Utc\n        //            ? request.LastReadAtUtc.Value\n        //            : request.LastReadAtUtc.Value.ToUniversalTime())\n        //        : nowUtc;\n\n        //    var existing = await _db.ContactReads\n        //        .FirstOrDefaultAsync(\n        //            r => r.BusinessId == businessId && r.ContactId == contactId && r.UserId == userId,\n        //            ct)\n        //        .ConfigureAwait(false);\n\n        //    if (existing == null)\n        //    {\n        //        await _db.ContactReads.AddAsync(new ContactRead\n        //        {\n        //            Id = Guid.NewGuid(),\n        //            BusinessId = businessId,\n        //            ContactId = contactId,\n        //            UserId = userId,\n        //            LastReadAt = lastReadAt\n        //        }, ct).ConfigureAwait(false);\n        //    }\n        //    else\n        //    {\n        //        // Only move forward in time; never go backwards.\n        //        if (existing.LastReadAt < lastReadAt)\n        //        {\n        //            existing.LastReadAt = lastReadAt;\n        //            _db.ContactReads.Update(existing);\n        //        }\n        //    }\n\n        //    await _db.SaveChangesAsync(ct).ConfigureAwait(false);\n        //}\n        public async Task MarkConversationAsReadAsync(\n      Guid businessId,\n      Guid contactId,\n      Guid userId,\n      DateTime? lastReadAtUtc,\n      CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty) throw new ArgumentException(\"BusinessId is required.\", nameof(businessId));\n            if (contactId == Guid.Empty) throw new ArgumentException(\"ContactId is required.\", nameof(contactId));\n            if (userId == Guid.Empty) throw new ArgumentException(\"UserId is required.\", nameof(userId));\n\n            var nowUtc = DateTime.UtcNow;\n\n            var lastReadAt = lastReadAtUtc.HasValue\n                ? (lastReadAtUtc.Value.Kind == DateTimeKind.Utc\n                    ? lastReadAtUtc.Value\n                    : lastReadAtUtc.Value.ToUniversalTime())\n                : nowUtc;\n\n            var existing = await _db.ContactReads\n                .FirstOrDefaultAsync(\n                    r => r.BusinessId == businessId && r.ContactId == contactId && r.UserId == userId,\n                    ct)\n                .ConfigureAwait(false);\n\n            if (existing == null)\n            {\n                await _db.ContactReads.AddAsync(new ContactRead\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    ContactId = contactId,\n                    UserId = userId,\n                    LastReadAt = lastReadAt\n                }, ct).ConfigureAwait(false);\n            }\n            else\n            {\n                // Only move forward in time; never go backwards.\n                if (existing.LastReadAt < lastReadAt)\n                {\n                    existing.LastReadAt = lastReadAt;\n                }\n            }\n\n            await _db.SaveChangesAsync(ct).ConfigureAwait(false);\n        }\n\n        // -------------------------\n        // Helpers\n        // -------------------------\n\n        private static void EnsureConversationIsReplyable(Contact contact)\n        {\n            var inboxStatus = (contact.InboxStatus ?? string.Empty).Trim();\n\n            if (string.Equals(inboxStatus, \"Closed\", StringComparison.OrdinalIgnoreCase) ||\n                contact.IsArchived ||\n                !contact.IsActive)\n            {\n                throw new InvalidOperationException(\"Conversation is closed.\");\n            }\n        }\n\n        private async Task<Contact> LoadTrackedContactAsync(Guid businessId, Guid? contactId, string phone, CancellationToken ct)\n        {\n            if (contactId.HasValue && contactId.Value != Guid.Empty)\n            {\n                var byId = await _db.Contacts\n                    .FirstOrDefaultAsync(c => c.BusinessId == businessId && c.Id == contactId.Value, ct)\n                    .ConfigureAwait(false);\n\n                if (byId != null) return byId;\n            }\n\n            var byPhone = await _db.Contacts\n                .FirstOrDefaultAsync(c => c.BusinessId == businessId && c.PhoneNumber == phone, ct)\n                .ConfigureAwait(false);\n\n            if (byPhone == null)\n                throw new InvalidOperationException(\"Contact not found for this conversation.\");\n\n            return byPhone;\n        }\n\n        private async Task<User> LoadActiveBusinessUserAsync(Guid businessId, Guid userId, CancellationToken ct)\n        {\n            var user = await _db.Users\n                .Include(u => u.Role)\n                .FirstOrDefaultAsync(u => u.Id == userId && !u.IsDeleted, ct)\n                .ConfigureAwait(false);\n\n            if (user == null) throw new InvalidOperationException(\"User not found.\");\n            if (user.BusinessId != businessId) throw new UnauthorizedAccessException(\"User does not belong to this business.\");\n            if (!string.Equals(user.Status, \"Active\", StringComparison.OrdinalIgnoreCase))\n                throw new UnauthorizedAccessException(\"User is not active.\");\n\n            return user;\n        }\n\n        private async Task EnforceAssignedOnlyReplyAsync(User actor, Contact contact, CancellationToken ct)\n        {\n            // ‚úÖ If already assigned to actor -> OK\n            if (contact.AssignedAgentId.HasValue && contact.AssignedAgentId.Value == actor.Id)\n                return;\n\n            // ‚úÖ Shared visibility rule: unassigned chat -> claim-on-first-reply (ANY active agent)\n            if (!contact.AssignedAgentId.HasValue)\n            {\n                // Atomic claim to avoid race: two agents reply at same time\n                var claimed = await _db.Contacts\n                    .Where(c => c.BusinessId == contact.BusinessId\n                                && c.Id == contact.Id\n                                && c.AssignedAgentId == null)\n                    .ExecuteUpdateAsync(setters => setters.SetProperty(c => c.AssignedAgentId, actor.Id), ct)\n                    .ConfigureAwait(false);\n\n                if (claimed > 0)\n                {\n                    // Keep in-memory entity consistent\n                    contact.AssignedAgentId = actor.Id;\n                    return;\n                }\n\n                // Someone else claimed between read and write ‚Üí reload for correct enforcement\n                var fresh = await _db.Contacts\n                    .AsNoTracking()\n                    .Where(c => c.BusinessId == contact.BusinessId && c.Id == contact.Id)\n                    .Select(c => c.AssignedAgentId)\n                    .FirstOrDefaultAsync(ct)\n                    .ConfigureAwait(false);\n\n                contact.AssignedAgentId = fresh;\n                // Now fall through to \"assigned to someone else\" logic below\n            }\n\n            // ‚úÖ Assigned to someone else -> only Business owner OR INBOX.CHAT.ASSIGN can override\n            var isBusinessOwner = IsBusinessOwner(actor);\n            var canAssign = await HasPermissionAsync(actor.Id, InboxAssignPermissionCode, ct).ConfigureAwait(false);\n\n            if (isBusinessOwner || canAssign)\n                return;\n\n            throw new UnauthorizedAccessException(\"Not allowed to reply. This chat is assigned to another agent.\");\n        }\n\n        private static bool IsBusinessOwner(User actor)\n        {\n            var role = (actor.Role?.Name ?? string.Empty).Trim().ToLowerInvariant();\n            return role == \"business\";\n        }\n\n        /// <summary>\n        /// Privileged = Business owner or platform roles.\n        /// Manager is NOT privileged unless they have INBOX.CHAT.ASSIGN.\n        /// </summary>\n        private static bool IsBusinessOrPlatformPrivileged(User actor)\n        {\n            var role = (actor.Role?.Name ?? string.Empty).Trim().ToLowerInvariant();\n            return role is \"business\" or \"admin\" or \"superadmin\" or \"partner\";\n        }\n\n        private async Task<bool> HasPermissionAsync(Guid userId, string permissionCode, CancellationToken ct)\n        {\n            var code = (permissionCode ?? string.Empty).Trim().ToUpperInvariant();\n            if (code.Length == 0) return false;\n\n            var permissionId = await _db.Permissions\n                .AsNoTracking()\n                .Where(p => p.Code != null && p.Code.ToUpper() == code)\n                .Select(p => (Guid?)p.Id)\n                .FirstOrDefaultAsync(ct)\n                .ConfigureAwait(false);\n\n            if (!permissionId.HasValue) return false;\n\n            // Direct user permission\n            var direct = await _db.UserPermissions\n                .AsNoTracking()\n                .AnyAsync(up =>\n                    up.UserId == userId &&\n                    up.PermissionId == permissionId.Value &&\n                    up.IsGranted &&\n                    !up.IsRevoked, ct)\n                .ConfigureAwait(false);\n\n            if (direct) return true;\n\n            // Role permission\n            var roleId = await _db.Users\n                .AsNoTracking()\n                .Where(u => u.Id == userId)\n                .Select(u => u.RoleId)\n                .FirstOrDefaultAsync(ct)\n                .ConfigureAwait(false);\n\n            if (!roleId.HasValue) return false;\n\n            var byRole = await _db.RolePermissions\n                .AsNoTracking()\n                .AnyAsync(rp =>\n                    rp.RoleId == roleId.Value &&\n                    rp.PermissionId == permissionId.Value &&\n                    rp.IsActive &&\n                    !rp.IsRevoked, ct)\n                .ConfigureAwait(false);\n\n            return byRole;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/Services/ChatInboxMediaContentService.cs",
      "sha256": "f694d8f000e1492ad60c86a810580189eb190b2998dcecf7a390f7a5c5e4c430",
      "language": "csharp",
      "size": 9859,
      "content": "using System;\nusing System.IO;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.TemplateModule.Abstractions;\n\nnamespace xbytechat.api.Features.ChatInbox.Services\n{\n    /// <summary>\n    /// Streams WhatsApp media bytes from Meta Cloud API without persisting on our servers.\n    /// This exists to support secure agent-side previews (the browser cannot attach Bearer tokens to &lt;img src&gt;).\n    /// </summary>\n    public sealed class ChatInboxMediaContentService : IChatInboxMediaContentService\n    {\n        private const string DefaultGraphVersion = \"v22.0\";\n\n        private readonly IHttpClientFactory _httpFactory;\n        private readonly IMetaCredentialsResolver _metaCreds;\n        private readonly ILogger<ChatInboxMediaContentService> _logger;\n\n        public ChatInboxMediaContentService(\n            IHttpClientFactory httpFactory,\n            IMetaCredentialsResolver metaCreds,\n            ILogger<ChatInboxMediaContentService> logger)\n        {\n            _httpFactory = httpFactory ?? throw new ArgumentNullException(nameof(httpFactory));\n            _metaCreds = metaCreds ?? throw new ArgumentNullException(nameof(metaCreds));\n            _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n        }\n\n        public async Task<(Stream Stream, string ContentType)> DownloadFromWhatsAppAsync(\n            Guid businessId,\n            string mediaId,\n            CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty) throw new ArgumentException(\"BusinessId is required.\", nameof(businessId));\n            if (string.IsNullOrWhiteSpace(mediaId)) throw new ArgumentException(\"mediaId is required.\", nameof(mediaId));\n\n            var creds = await _metaCreds.ResolveAsync(businessId, ct).ConfigureAwait(false);\n            var graphBase = (creds.GraphBaseUrl ?? string.Empty).Trim().TrimEnd('/');\n            var graphVersion = string.IsNullOrWhiteSpace(creds.GraphVersion)\n                ? DefaultGraphVersion\n                : creds.GraphVersion!.Trim().Trim('/');\n\n            if (string.IsNullOrWhiteSpace(graphBase))\n                throw new InvalidOperationException(\"WhatsApp Graph API base URL is missing.\");\n\n            var token = (creds.AccessToken ?? string.Empty).Trim();\n            if (string.IsNullOrWhiteSpace(token))\n                throw new InvalidOperationException(\"WhatsApp access token is missing for this business.\");\n\n            // Step 1: resolve the temporary media URL from Meta (GET /{media-id})\n            var metaUrl = $\"{graphBase}/{graphVersion}/{mediaId.Trim()}\";\n\n            using var metaReq = new HttpRequestMessage(HttpMethod.Get, metaUrl);\n            metaReq.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(\"application/json\"));\n            metaReq.Headers.Authorization = new AuthenticationHeaderValue(\"Bearer\", token);\n\n            using var client = _httpFactory.CreateClient(\"wa:meta_cloud\");\n            using var metaResp = await client.SendAsync(metaReq, HttpCompletionOption.ResponseHeadersRead, ct).ConfigureAwait(false);\n            var metaBody = await metaResp.Content.ReadAsStringAsync(ct).ConfigureAwait(false);\n\n            if (!metaResp.IsSuccessStatusCode)\n            {\n                var clean = TryGetMetaErrorMessage(metaBody) ?? \"Failed to resolve WhatsApp media URL.\";\n                _logger.LogWarning(\n                    \"ChatInbox media resolve failed. BusinessId={BusinessId} MediaId={MediaId} Status={Status} MetaError={MetaError}\",\n                    businessId,\n                    mediaId,\n                    (int)metaResp.StatusCode,\n                    clean);\n                throw new InvalidOperationException(clean);\n            }\n\n            var downloadUrl = TryGetMetaMediaUrl(metaBody);\n            var mimeType = TryGetMetaMediaMimeType(metaBody) ?? \"application/octet-stream\";\n\n            if (string.IsNullOrWhiteSpace(downloadUrl))\n                throw new InvalidOperationException(\"Meta did not return a download URL for this media.\");\n\n            // Step 2: stream the media bytes from the resolved URL (Bearer token required)\n            var fileReq = new HttpRequestMessage(HttpMethod.Get, downloadUrl);\n            fileReq.Headers.Authorization = new AuthenticationHeaderValue(\"Bearer\", token);\n\n            var fileResp = await client.SendAsync(fileReq, HttpCompletionOption.ResponseHeadersRead, ct).ConfigureAwait(false);\n            if (!fileResp.IsSuccessStatusCode)\n            {\n                var body = await fileResp.Content.ReadAsStringAsync(ct).ConfigureAwait(false);\n                fileResp.Dispose();\n\n                var clean = TryGetMetaErrorMessage(body) ?? \"Failed to download WhatsApp media.\";\n                _logger.LogWarning(\n                    \"ChatInbox media download failed. BusinessId={BusinessId} MediaId={MediaId} Status={Status} MetaError={MetaError}\",\n                    businessId,\n                    mediaId,\n                    (int)fileResp.StatusCode,\n                    clean);\n                throw new InvalidOperationException(clean);\n            }\n\n            var contentType =\n                fileResp.Content.Headers.ContentType?.MediaType ??\n                mimeType ??\n                \"application/octet-stream\";\n\n            Stream stream;\n            try\n            {\n                stream = await fileResp.Content.ReadAsStreamAsync(ct).ConfigureAwait(false);\n            }\n            catch\n            {\n                fileResp.Dispose();\n                throw;\n            }\n\n            return (new ResponseDisposingStream(stream, fileResp), contentType);\n        }\n\n        private sealed class ResponseDisposingStream : Stream\n        {\n            private readonly Stream _inner;\n            private readonly HttpResponseMessage _resp;\n\n            public ResponseDisposingStream(Stream inner, HttpResponseMessage resp)\n            {\n                _inner = inner ?? throw new ArgumentNullException(nameof(inner));\n                _resp = resp ?? throw new ArgumentNullException(nameof(resp));\n            }\n\n            public override bool CanRead => _inner.CanRead;\n            public override bool CanSeek => _inner.CanSeek;\n            public override bool CanWrite => _inner.CanWrite;\n            public override long Length => _inner.Length;\n            public override long Position { get => _inner.Position; set => _inner.Position = value; }\n            public override void Flush() => _inner.Flush();\n            public override int Read(byte[] buffer, int offset, int count) => _inner.Read(buffer, offset, count);\n            public override long Seek(long offset, SeekOrigin origin) => _inner.Seek(offset, origin);\n            public override void SetLength(long value) => _inner.SetLength(value);\n            public override void Write(byte[] buffer, int offset, int count) => _inner.Write(buffer, offset, count);\n            public override Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken) =>\n                _inner.ReadAsync(buffer, offset, count, cancellationToken);\n            public override ValueTask<int> ReadAsync(Memory<byte> buffer, CancellationToken cancellationToken = default) =>\n                _inner.ReadAsync(buffer, cancellationToken);\n            public override Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken) =>\n                _inner.CopyToAsync(destination, bufferSize, cancellationToken);\n\n            protected override void Dispose(bool disposing)\n            {\n                if (disposing)\n                {\n                    try { _inner.Dispose(); } catch { /* ignore */ }\n                    try { _resp.Dispose(); } catch { /* ignore */ }\n                }\n                base.Dispose(disposing);\n            }\n\n            public override async ValueTask DisposeAsync()\n            {\n                try { await _inner.DisposeAsync().ConfigureAwait(false); } catch { /* ignore */ }\n                try { _resp.Dispose(); } catch { /* ignore */ }\n            }\n        }\n\n        private static string? TryGetMetaMediaUrl(string body)\n        {\n            try\n            {\n                using var doc = JsonDocument.Parse(body);\n                if (doc.RootElement.ValueKind != JsonValueKind.Object) return null;\n                if (doc.RootElement.TryGetProperty(\"url\", out var urlProp) && urlProp.ValueKind == JsonValueKind.String)\n                    return urlProp.GetString();\n            }\n            catch { /* ignore */ }\n\n            return null;\n        }\n\n        private static string? TryGetMetaMediaMimeType(string body)\n        {\n            try\n            {\n                using var doc = JsonDocument.Parse(body);\n                if (doc.RootElement.ValueKind != JsonValueKind.Object) return null;\n                if (doc.RootElement.TryGetProperty(\"mime_type\", out var mimeProp) && mimeProp.ValueKind == JsonValueKind.String)\n                    return mimeProp.GetString();\n            }\n            catch { /* ignore */ }\n\n            return null;\n        }\n\n        private static string? TryGetMetaErrorMessage(string body)\n        {\n            try\n            {\n                using var doc = JsonDocument.Parse(body);\n                if (doc.RootElement.ValueKind != JsonValueKind.Object) return null;\n\n                if (!doc.RootElement.TryGetProperty(\"error\", out var err) || err.ValueKind != JsonValueKind.Object)\n                    return null;\n\n                if (err.TryGetProperty(\"message\", out var msg) && msg.ValueKind == JsonValueKind.String)\n                    return msg.GetString();\n            }\n            catch { /* ignore */ }\n\n            return null;\n        }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/Services/ChatInboxMediaUploadService.cs",
      "sha256": "aa4d8e505de0f720cdc570b34f40e46376b281f3ece5beaf659d87034638ec74",
      "language": "csharp",
      "size": 6105,
      "content": "using System;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.TemplateModule.Abstractions;\n\nnamespace xbytechat.api.Features.ChatInbox.Services\n{\n    /// <summary>\n    /// Uploads Inbox attachments to WhatsApp Cloud API media storage and returns a media_id.\n    /// We intentionally do NOT store files on our server.\n    /// </summary>\n    public sealed class ChatInboxMediaUploadService : IChatInboxMediaUploadService\n    {\n        private const string DefaultGraphVersion = \"v22.0\";\n\n        private readonly IHttpClientFactory _httpFactory;\n        private readonly IMetaCredentialsResolver _metaCreds;\n        private readonly ILogger<ChatInboxMediaUploadService> _logger;\n\n        public ChatInboxMediaUploadService(\n            IHttpClientFactory httpFactory,\n            IMetaCredentialsResolver metaCreds,\n            ILogger<ChatInboxMediaUploadService> logger)\n        {\n            _httpFactory = httpFactory ?? throw new ArgumentNullException(nameof(httpFactory));\n            _metaCreds = metaCreds ?? throw new ArgumentNullException(nameof(metaCreds));\n            _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n        }\n\n        public async Task<string> UploadToWhatsAppAsync(\n            Guid businessId,\n            string? phoneNumberId,\n            IFormFile file,\n            CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty) throw new ArgumentException(\"BusinessId is required.\", nameof(businessId));\n            if (file == null) throw new ArgumentNullException(nameof(file));\n\n            var creds = await _metaCreds.ResolveAsync(businessId, ct).ConfigureAwait(false);\n            var graphBase = (creds.GraphBaseUrl ?? string.Empty).Trim().TrimEnd('/');\n            var graphVersion = string.IsNullOrWhiteSpace(creds.GraphVersion)\n                ? DefaultGraphVersion\n                : creds.GraphVersion!.Trim().Trim('/');\n\n            if (string.IsNullOrWhiteSpace(graphBase))\n                throw new InvalidOperationException(\"WhatsApp Graph API base URL is missing.\");\n\n            var pnid = string.IsNullOrWhiteSpace(phoneNumberId)\n                ? (creds.PhoneNumberId ?? string.Empty).Trim()\n                : phoneNumberId.Trim();\n\n            if (string.IsNullOrWhiteSpace(pnid))\n                throw new InvalidOperationException(\"WhatsApp phone_number_id is missing for this business.\");\n\n            var url = $\"{graphBase}/{graphVersion}/{pnid}/media\";\n\n            using var fileStream = file.OpenReadStream();\n            using var mp = new MultipartFormDataContent();\n\n            mp.Add(new StringContent(\"whatsapp\"), \"messaging_product\");\n            mp.Add(new StringContent(file.ContentType ?? \"application/octet-stream\"), \"type\");\n\n            var fileContent = new StreamContent(fileStream);\n            fileContent.Headers.ContentType = new MediaTypeHeaderValue(file.ContentType ?? \"application/octet-stream\");\n            mp.Add(fileContent, \"file\", file.FileName ?? \"upload.bin\");\n\n            using var req = new HttpRequestMessage(HttpMethod.Post, url) { Content = mp };\n            req.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(\"application/json\"));\n\n            var token = (creds.AccessToken ?? string.Empty).Trim();\n            if (string.IsNullOrWhiteSpace(token))\n                throw new InvalidOperationException(\"WhatsApp access token is missing for this business.\");\n\n            req.Headers.Authorization = new AuthenticationHeaderValue(\"Bearer\", token);\n\n            using var client = _httpFactory.CreateClient(\"wa:meta_cloud\");\n            using var resp = await client.SendAsync(req, HttpCompletionOption.ResponseHeadersRead, ct).ConfigureAwait(false);\n            var body = await resp.Content.ReadAsStringAsync(ct).ConfigureAwait(false);\n\n            if (!resp.IsSuccessStatusCode)\n            {\n                var clean = TryGetMetaErrorMessage(body) ?? \"WhatsApp media upload failed.\";\n                _logger.LogWarning(\n                    \"ChatInbox media upload failed. BusinessId={BusinessId} PhoneNumberId={PhoneNumberId} Status={Status} MetaError={MetaError}\",\n                    businessId,\n                    pnid,\n                    (int)resp.StatusCode,\n                    clean);\n                throw new InvalidOperationException(clean);\n            }\n\n            var mediaId = TryGetMediaId(body);\n            if (string.IsNullOrWhiteSpace(mediaId))\n            {\n                _logger.LogWarning(\n                    \"ChatInbox media upload succeeded but media id missing. BusinessId={BusinessId} PhoneNumberId={PhoneNumberId}\",\n                    businessId,\n                    pnid);\n                throw new InvalidOperationException(\"WhatsApp media upload succeeded but no media id was returned.\");\n            }\n\n            return mediaId;\n        }\n\n        private static string? TryGetMediaId(string body)\n        {\n            try\n            {\n                using var doc = JsonDocument.Parse(body);\n                if (doc.RootElement.ValueKind != JsonValueKind.Object) return null;\n                if (doc.RootElement.TryGetProperty(\"id\", out var idProp))\n                    return idProp.GetString();\n            }\n            catch { /* ignore */ }\n\n            return null;\n        }\n\n        private static string? TryGetMetaErrorMessage(string body)\n        {\n            try\n            {\n                using var doc = JsonDocument.Parse(body);\n                if (doc.RootElement.ValueKind != JsonValueKind.Object) return null;\n\n                if (!doc.RootElement.TryGetProperty(\"error\", out var err) || err.ValueKind != JsonValueKind.Object)\n                    return null;\n\n                if (err.TryGetProperty(\"message\", out var msg) && msg.ValueKind == JsonValueKind.String)\n                    return msg.GetString();\n            }\n            catch { /* ignore */ }\n\n            return null;\n        }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/Services/ChatInboxQueryService.cs",
      "sha256": "0b1498c852e77a9d8bb016781d9214116dcf87135c3d97d829c5b0b7a0bdb41c",
      "language": "csharp",
      "size": 31345,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/Services/ChatInboxQueryService.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.ChatInbox.DTOs;\nusing xbytechat.api.Features.ChatInbox.Models;\nusing xbytechat.api.Features.ChatInbox.Utils;\nusing xbytechat.api.Models;\n\nnamespace xbytechat.api.Features.ChatInbox.Services\n{\n    public sealed class ChatInboxQueryService : IChatInboxQueryService\n    {\n        private const string InboxAssignPermissionCode = \"INBOX.CHAT.ASSIGN\";\n\n        private readonly AppDbContext _db;\n\n        private sealed class ConversationsCursor\n        {\n            public DateTime LastMessageAtUtc { get; set; }\n            public Guid ContactId { get; set; }\n        }\n\n        private sealed class MessagesCursor\n        {\n            public DateTime InstantUtc { get; set; }\n            public Guid MessageId { get; set; }\n        }\n\n        public ChatInboxQueryService(AppDbContext db)\n        {\n            _db = db ?? throw new ArgumentNullException(nameof(db));\n        }\n\n        // ‚úÖ Backward compatible (old behavior)\n        public async Task<IReadOnlyList<ChatInboxConversationDto>> GetConversationsAsync(\n            ChatInboxFilterDto filter,\n            CancellationToken ct = default)\n        {\n            var page = await GetConversationsPageAsync(filter, ct).ConfigureAwait(false);\n            return page.Items;\n        }\n\n        // ‚úÖ New: cursor page\n        public async Task<PagedResultDto<ChatInboxConversationDto>> GetConversationsPageAsync(\n            ChatInboxFilterDto filter,\n            CancellationToken ct = default)\n        {\n            if (filter == null) throw new ArgumentNullException(nameof(filter));\n            if (filter.BusinessId == Guid.Empty)\n                throw new ArgumentException(\"BusinessId is required.\", nameof(filter));\n\n            var limit = filter.Limit <= 0 ? 50 : filter.Limit;\n            if (limit > 200) limit = 200;\n\n            var businessId = filter.BusinessId;\n            var currentUserId = filter.CurrentUserId;\n\n            var cursorObj = CursorCodec.Decode<ConversationsCursor>(filter.Cursor);\n            var within24hCutoffUtc = DateTime.UtcNow.AddHours(-24);\n\n            var convoAgg =\n                from m in _db.MessageLogs.AsNoTracking()\n                where m.BusinessId == businessId && m.ContactId != null\n                group m by m.ContactId!.Value\n                into g\n                select new\n                {\n                    ContactId = g.Key,\n                    LastMessageAt = g.Max(x => x.SentAt ?? x.CreatedAt),\n                    FirstSeenAt = g.Min(x => x.SentAt ?? x.CreatedAt),\n                    TotalMessages = g.Count(),\n                    LastInboundAt = g.Where(x => x.IsIncoming)\n                        .Max(x => (DateTime?)(x.SentAt ?? x.CreatedAt)),\n                    LastOutboundAt = g.Where(x => !x.IsIncoming)\n                        .Max(x => (DateTime?)(x.SentAt ?? x.CreatedAt))\n                };\n\n            var q =\n                from a in convoAgg\n                join c in _db.Contacts.AsNoTracking()\n                    on a.ContactId equals c.Id\n                where c.BusinessId == businessId\n                select new\n                {\n                    a.ContactId,\n                    a.LastMessageAt,\n                    a.FirstSeenAt,\n                    a.TotalMessages,\n                    a.LastInboundAt,\n                    a.LastOutboundAt,\n                    Contact = c\n                };\n\n            // ‚úÖ Visibility mode (Shared vs Restricted)\n            var visibility = await _db.Businesses\n                .AsNoTracking()\n                .Where(b => b.Id == businessId)\n                .Select(b => (InboxVisibilityMode?)b.InboxVisibilityMode)\n                .FirstOrDefaultAsync(ct)\n                .ConfigureAwait(false) ?? InboxVisibilityMode.SharedInInbox;\n\n            // ‚úÖ Restricted mode: non-privileged agents only see chats assigned to them\n            if (visibility == InboxVisibilityMode.AssignedOnly)\n            {\n                if (!currentUserId.HasValue || currentUserId.Value == Guid.Empty)\n                {\n                    return new PagedResultDto<ChatInboxConversationDto>\n                    {\n                        Items = Array.Empty<ChatInboxConversationDto>(),\n                        HasMore = false,\n                        NextCursor = null\n                    };\n                }\n\n                var canSeeAll = await CanSeeAllInRestrictedModeAsync(businessId, currentUserId.Value, ct)\n                    .ConfigureAwait(false);\n\n                if (!canSeeAll)\n                {\n                    q = q.Where(x => x.Contact.AssignedAgentId == currentUserId.Value);\n                }\n            }\n\n            if (filter.OnlyUnassigned)\n                q = q.Where(x => x.Contact.AssignedAgentId == null);\n\n            if (filter.OnlyAssignedToMe && currentUserId.HasValue)\n                q = q.Where(x => x.Contact.AssignedAgentId == currentUserId.Value);\n\n            if (filter.ContactId.HasValue && filter.ContactId.Value != Guid.Empty)\n                q = q.Where(x => x.ContactId == filter.ContactId.Value);\n\n            var tab = (filter.Tab ?? string.Empty).Trim().ToLowerInvariant();\n            if (!string.IsNullOrWhiteSpace(tab))\n            {\n                if (tab == \"closed\")\n                {\n                    q = q.Where(x => x.Contact.InboxStatus == \"Closed\" || x.Contact.IsArchived || !x.Contact.IsActive);\n                }\n                else\n                {\n                    q = q.Where(x => x.Contact.InboxStatus != \"Closed\" && !x.Contact.IsArchived && x.Contact.IsActive);\n\n                    if (tab == \"live\")\n                    {\n                        q = q.Where(x => x.LastInboundAt.HasValue && x.LastInboundAt.Value >= within24hCutoffUtc);\n                    }\n                    else if (tab is \"older\" or \"history\")\n                    {\n                        q = q.Where(x => !x.LastInboundAt.HasValue || x.LastInboundAt.Value < within24hCutoffUtc);\n                    }\n                    else if (tab == \"unassigned\")\n                    {\n                        q = q.Where(x => x.Contact.AssignedAgentId == null);\n                    }\n                    else if (tab == \"my\")\n                    {\n                        if (currentUserId.HasValue)\n                            q = q.Where(x => x.Contact.AssignedAgentId == currentUserId.Value);\n                        else\n                            q = q.Where(x => false);\n                    }\n                }\n            }\n\n            if (!string.IsNullOrWhiteSpace(filter.SearchTerm))\n            {\n                var raw = filter.SearchTerm.Trim();\n                var term = raw.ToLowerInvariant();\n\n                q = q.Where(x =>\n                    (!string.IsNullOrEmpty(x.Contact.Name) && x.Contact.Name.ToLower().Contains(term)) ||\n                    (!string.IsNullOrEmpty(x.Contact.ProfileName) && x.Contact.ProfileName.ToLower().Contains(term)) ||\n                    (!string.IsNullOrEmpty(x.Contact.PhoneNumber) && x.Contact.PhoneNumber.Contains(raw)));\n            }\n\n            if (cursorObj != null && cursorObj.ContactId != Guid.Empty)\n            {\n                var lm = DateTime.SpecifyKind(cursorObj.LastMessageAtUtc, DateTimeKind.Utc);\n                var cid = cursorObj.ContactId;\n\n                q = q.Where(x =>\n                    x.LastMessageAt < lm ||\n                    (x.LastMessageAt == lm && x.ContactId.CompareTo(cid) < 0));\n            }\n\n            q = q.OrderByDescending(x => x.LastMessageAt)\n                 .ThenByDescending(x => x.ContactId);\n\n            var rows = await q.Take(limit + 1).ToListAsync(ct).ConfigureAwait(false);\n\n            var hasMore = rows.Count > limit;\n            var pageRows = rows.Take(limit).ToList();\n\n            if (pageRows.Count == 0)\n            {\n                return new PagedResultDto<ChatInboxConversationDto>\n                {\n                    Items = Array.Empty<ChatInboxConversationDto>(),\n                    HasMore = false,\n                    NextCursor = null\n                };\n            }\n\n            var contactIds = pageRows.Select(x => x.ContactId).ToList();\n\n            var lastMessages = await _db.MessageLogs\n                .AsNoTracking()\n                .Where(m => m.BusinessId == businessId\n                            && m.ContactId != null\n                            && contactIds.Contains(m.ContactId.Value))\n                .GroupBy(m => m.ContactId!.Value)\n                .Select(g => g\n                    .OrderByDescending(m => m.SentAt ?? m.CreatedAt)\n                    .ThenByDescending(m => m.Id)\n                    .FirstOrDefault())\n                .ToListAsync(ct)\n                .ConfigureAwait(false);\n\n            var lastMessageByContactId = lastMessages\n                .Where(m => m != null && m.ContactId != null)\n                .ToDictionary(m => m!.ContactId!.Value, m => m!);\n\n            var assignedUserIds = pageRows\n                .Select(x => x.Contact.AssignedAgentId)\n                .Where(x => x.HasValue)\n                .Select(x => x!.Value)\n                .Distinct()\n                .ToList();\n\n            var assignedUsersById = new Dictionary<Guid, string>();\n            if (assignedUserIds.Count > 0)\n            {\n                var users = await _db.Users\n                    .AsNoTracking()\n                    .Where(u => assignedUserIds.Contains(u.Id))\n                    .Select(u => new { u.Id, Name = (u.Name ?? u.Email) })\n                    .ToListAsync(ct)\n                    .ConfigureAwait(false);\n\n                assignedUsersById = users.ToDictionary(x => x.Id, x => x.Name ?? \"Unknown\");\n            }\n\n            var unreadCounts = new Dictionary<Guid, int>();\n            if (currentUserId.HasValue)\n            {\n                var uid = currentUserId.Value;\n\n                var readsQuery = _db.ContactReads\n                    .AsNoTracking()\n                    .Where(r => r.BusinessId == businessId && r.UserId == uid);\n\n                var unreadRows = await _db.MessageLogs\n                    .AsNoTracking()\n                    .Where(m => m.BusinessId == businessId\n                                && m.ContactId != null\n                                && contactIds.Contains(m.ContactId.Value)\n                                && m.IsIncoming)\n                    .GroupJoin(\n                        readsQuery,\n                        m => m.ContactId!.Value,\n                        r => r.ContactId,\n                        (m, reads) => new\n                        {\n                            ContactId = m.ContactId!.Value,\n                            Instant = (m.SentAt ?? m.CreatedAt),\n                            LastReadAt = reads.Select(x => (DateTime?)x.LastReadAt).FirstOrDefault()\n                        })\n                    .Where(x => !x.LastReadAt.HasValue || x.Instant > x.LastReadAt.Value)\n                    .GroupBy(x => x.ContactId)\n                    .Select(g => new { ContactId = g.Key, Count = g.Count() })\n                    .ToListAsync(ct)\n                    .ConfigureAwait(false);\n\n                unreadCounts = unreadRows.ToDictionary(x => x.ContactId, x => x.Count);\n            }\n\n            var sessionStates = await _db.ChatSessionStates\n                .AsNoTracking()\n                .Where(s => s.BusinessId == businessId && contactIds.Contains(s.ContactId))\n                .ToListAsync(ct)\n                .ConfigureAwait(false);\n\n            var sessionByContactId = sessionStates.ToDictionary(s => s.ContactId, s => s);\n\n            var items = new List<ChatInboxConversationDto>(pageRows.Count);\n\n            foreach (var row in pageRows)\n            {\n                var contact = row.Contact;\n\n                lastMessageByContactId.TryGetValue(row.ContactId, out var lastMsg);\n\n                var preview = lastMsg?.RenderedBody ?? lastMsg?.MessageContent ?? string.Empty;\n                if (string.IsNullOrWhiteSpace(preview) && lastMsg != null && !string.IsNullOrWhiteSpace(lastMsg.MediaType))\n                {\n                    var mt = lastMsg.MediaType.Trim().ToLowerInvariant();\n                    var name = lastMsg.FileName ?? string.Empty;\n\n                    if (mt == \"image\")\n                        preview = \"Photo\";\n                    else if (mt == \"document\")\n                        preview = string.IsNullOrWhiteSpace(name) ? \"PDF\" : name;\n                    else if (mt == \"video\")\n                        preview = string.IsNullOrWhiteSpace(name) ? \"Video\" : name;\n                    else if (mt == \"audio\")\n                        preview = string.IsNullOrWhiteSpace(name) ? \"Audio\" : name;\n                    else if (mt == \"location\")\n                        preview = string.IsNullOrWhiteSpace(lastMsg.LocationName) ? \"Location\" : lastMsg.LocationName!;\n                }\n                if (preview.Length > 140) preview = preview.Substring(0, 140) + \"‚Ä¶\";\n\n                var unread = unreadCounts.TryGetValue(row.ContactId, out var uc) ? uc : 0;\n\n                var lastInboundAt = row.LastInboundAt ?? contact.LastInboundAt;\n                var lastOutboundAt = row.LastOutboundAt ?? contact.LastOutboundAt;\n\n                var within24h =\n                    lastInboundAt.HasValue && lastInboundAt.Value >= within24hCutoffUtc;\n\n                var statusRaw = (contact.InboxStatus ?? string.Empty).Trim();\n                var statusLower = statusRaw.ToLowerInvariant();\n                var status =\n                    statusLower switch\n                    {\n                        \"open\" => \"Open\",\n                        \"pending\" => \"Pending\",\n                        \"closed\" => \"Closed\",\n                        _ => (contact.IsArchived || !contact.IsActive) ? \"Closed\" : \"Open\"\n                    };\n\n                var assignedUserId = contact.AssignedAgentId;\n                var assignedUserIdString = assignedUserId?.ToString();\n\n                var isAssignedToMe =\n                    currentUserId.HasValue &&\n                    assignedUserId.HasValue &&\n                    assignedUserId.Value == currentUserId.Value;\n\n                string? assignedUserName = null;\n                if (assignedUserId.HasValue && assignedUsersById.TryGetValue(assignedUserId.Value, out var nm))\n                    assignedUserName = nm;\n\n                var mode = \"automation\";\n                if (sessionByContactId.TryGetValue(row.ContactId, out var session))\n                {\n                    mode = session.Mode?.ToString().ToLowerInvariant() ?? \"automation\";\n                }\n                else if (lastMsg != null)\n                {\n                    if (!lastMsg.IsIncoming &&\n                        string.Equals(lastMsg.Source, \"agent\", StringComparison.OrdinalIgnoreCase))\n                    {\n                        mode = \"agent\";\n                    }\n                }\n\n                items.Add(new ChatInboxConversationDto\n                {\n                    Id = row.ContactId.ToString(),\n                    ContactId = row.ContactId,\n                    ContactName = string.IsNullOrWhiteSpace(contact.Name)\n                        ? (contact.ProfileName ?? contact.PhoneNumber)\n                        : contact.Name,\n                    ContactPhone = contact.PhoneNumber,\n\n                    LastMessagePreview = preview,\n                    LastMessageAt = row.LastMessageAt,\n\n                    UnreadCount = unread,\n                    Status = status,\n\n                    NumberId = string.Empty,\n                    NumberLabel = string.Empty,\n\n                    Within24h = within24h,\n\n                    AssignedToUserId = assignedUserIdString,\n                    AssignedToUserName = assignedUserName,\n                    IsAssignedToMe = isAssignedToMe,\n\n                    Mode = mode,\n                    SourceType = \"Unknown\",\n                    SourceName = null,\n\n                    FirstSeenAt = row.FirstSeenAt,\n                    LastInboundAt = lastInboundAt,\n                    LastOutboundAt = lastOutboundAt,\n                    TotalMessages = row.TotalMessages,\n\n                    LastAgentReplyAt = null,\n                    LastAutomationAt = null\n                });\n            }\n\n            items.Sort((a, b) =>\n            {\n                var aUnread = a.UnreadCount > 0;\n                var bUnread = b.UnreadCount > 0;\n\n                if (aUnread && !bUnread) return -1;\n                if (!aUnread && bUnread) return 1;\n\n                return b.LastMessageAt.CompareTo(a.LastMessageAt);\n            });\n\n            string? nextCursor = null;\n            if (hasMore && items.Count > 0)\n            {\n                var last = pageRows.Last();\n                nextCursor = CursorCodec.Encode(new ConversationsCursor\n                {\n                    LastMessageAtUtc = DateTime.SpecifyKind(last.LastMessageAt, DateTimeKind.Utc),\n                    ContactId = last.ContactId\n                });\n            }\n\n            return new PagedResultDto<ChatInboxConversationDto>\n            {\n                Items = items,\n                HasMore = hasMore,\n                NextCursor = nextCursor\n            };\n        }\n\n        // =============================================================\n        // ‚úÖ SECURED MESSAGE METHODS (use these from controllers)\n        // =============================================================\n\n        public async Task<IReadOnlyList<ChatInboxMessageDto>> GetMessagesForConversationAsync(\n            Guid businessId,\n            string contactPhone,\n            int limit,\n            Guid currentUserId,\n            CancellationToken ct = default)\n        {\n            var page = await GetMessagesPageForConversationByPhoneAsync(businessId, contactPhone, limit, null, currentUserId, ct)\n                .ConfigureAwait(false);\n\n            return page.Items;\n        }\n\n        public async Task<IReadOnlyList<ChatInboxMessageDto>> GetMessagesForConversationByContactIdAsync(\n            Guid businessId,\n            Guid contactId,\n            int limit,\n            Guid currentUserId,\n            CancellationToken ct = default)\n        {\n            var page = await GetMessagesPageForConversationByContactIdAsync(businessId, contactId, limit, null, currentUserId, ct)\n                .ConfigureAwait(false);\n\n            return page.Items;\n        }\n\n        public Task<PagedResultDto<ChatInboxMessageDto>> GetMessagesPageForConversationByPhoneAsync(\n            Guid businessId,\n            string contactPhone,\n            int limit,\n            string? cursor,\n            Guid currentUserId,\n            CancellationToken ct = default)\n        {\n            // Resolve contactId then delegate\n            return GetMessagesPageForConversationByPhoneInternalAsync(businessId, contactPhone, limit, cursor, currentUserId, ct);\n        }\n\n        public Task<PagedResultDto<ChatInboxMessageDto>> GetMessagesPageForConversationByContactIdAsync(\n            Guid businessId,\n            Guid contactId,\n            int limit,\n            string? cursor,\n            Guid currentUserId,\n            CancellationToken ct = default)\n        {\n            return GetMessagesPageForConversationByContactIdInternalAsync(businessId, contactId, limit, cursor, currentUserId, ct);\n        }\n\n        // =============================================================\n        // ‚ö†Ô∏è LEGACY MESSAGE METHODS (keep for compatibility only)\n        // These DO NOT enforce restricted mode. Prefer secured overloads.\n        // =============================================================\n\n        public async Task<IReadOnlyList<ChatInboxMessageDto>> GetMessagesForConversationAsync(\n            Guid businessId,\n            string contactPhone,\n            int limit,\n            CancellationToken ct = default)\n        {\n            var page = await GetMessagesPageForConversationByPhoneAsync(businessId, contactPhone, limit, null, ct)\n                .ConfigureAwait(false);\n\n            return page.Items;\n        }\n\n        public async Task<IReadOnlyList<ChatInboxMessageDto>> GetMessagesForConversationByContactIdAsync(\n            Guid businessId,\n            Guid contactId,\n            int limit,\n            CancellationToken ct = default)\n        {\n            var page = await GetMessagesPageForConversationByContactIdAsync(businessId, contactId, limit, null, ct)\n                .ConfigureAwait(false);\n\n            return page.Items;\n        }\n\n        public Task<PagedResultDto<ChatInboxMessageDto>> GetMessagesPageForConversationByPhoneAsync(\n            Guid businessId,\n            string contactPhone,\n            int limit,\n            string? cursor,\n            CancellationToken ct = default)\n        {\n            // Legacy behavior: no visibility enforcement (Shared-like)\n            return GetMessagesPageForConversationByPhoneInternalAsync(businessId, contactPhone, limit, cursor, null, ct);\n        }\n\n        public Task<PagedResultDto<ChatInboxMessageDto>> GetMessagesPageForConversationByContactIdAsync(\n            Guid businessId,\n            Guid contactId,\n            int limit,\n            string? cursor,\n            CancellationToken ct = default)\n        {\n            // Legacy behavior: no visibility enforcement (Shared-like)\n            return GetMessagesPageForConversationByContactIdInternalAsync(businessId, contactId, limit, cursor, null, ct);\n        }\n\n        // =============================================================\n        // Internal implementations with optional enforcement\n        // =============================================================\n\n        private async Task<PagedResultDto<ChatInboxMessageDto>> GetMessagesPageForConversationByPhoneInternalAsync(\n            Guid businessId,\n            string contactPhone,\n            int limit,\n            string? cursor,\n            Guid? currentUserId,\n            CancellationToken ct)\n        {\n            if (businessId == Guid.Empty)\n                throw new ArgumentException(\"BusinessId must be a non-empty GUID.\", nameof(businessId));\n\n            if (string.IsNullOrWhiteSpace(contactPhone))\n                throw new ArgumentException(\"Contact phone is required.\", nameof(contactPhone));\n\n            var trimmedPhone = contactPhone.Trim();\n\n            var contactId = await _db.Contacts\n                .AsNoTracking()\n                .Where(c => c.BusinessId == businessId && c.PhoneNumber == trimmedPhone)\n                .Select(c => (Guid?)c.Id)\n                .FirstOrDefaultAsync(ct)\n                .ConfigureAwait(false);\n\n            if (!contactId.HasValue)\n            {\n                return new PagedResultDto<ChatInboxMessageDto>\n                {\n                    Items = Array.Empty<ChatInboxMessageDto>(),\n                    HasMore = false,\n                    NextCursor = null\n                };\n            }\n\n            return await GetMessagesPageForConversationByContactIdInternalAsync(\n                    businessId, contactId.Value, limit, cursor, currentUserId, ct)\n                .ConfigureAwait(false);\n        }\n\n        private async Task<PagedResultDto<ChatInboxMessageDto>> GetMessagesPageForConversationByContactIdInternalAsync(\n            Guid businessId,\n            Guid contactId,\n            int limit,\n            string? cursor,\n            Guid? currentUserId,\n            CancellationToken ct)\n        {\n            if (businessId == Guid.Empty)\n                throw new ArgumentException(\"BusinessId must be a non-empty GUID.\", nameof(businessId));\n\n            if (contactId == Guid.Empty)\n                throw new ArgumentException(\"ContactId must be a non-empty GUID.\", nameof(contactId));\n\n            if (limit <= 0) limit = 50;\n            if (limit > 200) limit = 200;\n\n            // ‚úÖ Visibility enforcement for messages in Restricted mode\n            await EnsureCanViewConversationAsync(businessId, contactId, currentUserId, ct)\n                .ConfigureAwait(false);\n\n            var cursorObj = CursorCodec.Decode<MessagesCursor>(cursor);\n\n            var q = _db.MessageLogs\n                .AsNoTracking()\n                .Where(x => x.BusinessId == businessId && x.ContactId == contactId);\n\n            if (cursorObj != null && cursorObj.MessageId != Guid.Empty)\n            {\n                var inst = DateTime.SpecifyKind(cursorObj.InstantUtc, DateTimeKind.Utc);\n                var mid = cursorObj.MessageId;\n\n                q = q.Where(x =>\n                    (x.SentAt ?? x.CreatedAt) < inst ||\n                    ((x.SentAt ?? x.CreatedAt) == inst && x.Id.CompareTo(mid) < 0));\n            }\n\n            var rows = await q\n                .OrderByDescending(x => x.SentAt ?? x.CreatedAt)\n                .ThenByDescending(x => x.Id)\n                .Take(limit + 1)\n                .ToListAsync(ct)\n                .ConfigureAwait(false);\n\n            var hasMore = rows.Count > limit;\n            var pageRows = rows.Take(limit).ToList();\n\n            var items = pageRows.Select(x =>\n            {\n                var instant = x.SentAt ?? x.CreatedAt;\n                var utcInstant = instant.Kind == DateTimeKind.Utc ? instant : instant.ToUniversalTime();\n\n                return new ChatInboxMessageDto\n                {\n                    Id = x.Id,\n                    Direction = x.IsIncoming ? \"in\" : \"out\",\n                    Channel = \"whatsapp\",\n                    Text = x.RenderedBody ?? x.MessageContent ?? string.Empty,\n                    MediaId = x.MediaId,\n                    MediaType = x.MediaType,\n                    FileName = x.FileName,\n                    MimeType = x.MimeType,\n                    LocationLatitude = x.LocationLatitude,\n                    LocationLongitude = x.LocationLongitude,\n                    LocationName = x.LocationName,\n                    LocationAddress = x.LocationAddress,\n                    SentAtUtc = utcInstant,\n                    Status = x.Status,\n                    ErrorMessage = x.ErrorMessage\n                };\n            }).ToList();\n\n            string? nextCursor = null;\n            if (hasMore && pageRows.Count > 0)\n            {\n                var last = pageRows.Last();\n                var instant = last.SentAt ?? last.CreatedAt;\n                var utcInstant = instant.Kind == DateTimeKind.Utc ? instant : instant.ToUniversalTime();\n\n                nextCursor = CursorCodec.Encode(new MessagesCursor\n                {\n                    InstantUtc = utcInstant,\n                    MessageId = last.Id\n                });\n            }\n\n            return new PagedResultDto<ChatInboxMessageDto>\n            {\n                Items = items,\n                HasMore = hasMore,\n                NextCursor = nextCursor\n            };\n        }\n\n        private async Task EnsureCanViewConversationAsync(\n            Guid businessId,\n            Guid contactId,\n            Guid? currentUserId,\n            CancellationToken ct)\n        {\n            // Shared mode => everyone in business can view.\n            var visibility = await _db.Businesses\n                .AsNoTracking()\n                .Where(b => b.Id == businessId)\n                .Select(b => (InboxVisibilityMode?)b.InboxVisibilityMode)\n                .FirstOrDefaultAsync(ct)\n                .ConfigureAwait(false) ?? InboxVisibilityMode.SharedInInbox;\n\n            if (visibility != InboxVisibilityMode.AssignedOnly)\n                return;\n\n            if (!currentUserId.HasValue || currentUserId.Value == Guid.Empty)\n                throw new UnauthorizedAccessException(\"Restricted inbox: user context required.\");\n\n            var canSeeAll = await CanSeeAllInRestrictedModeAsync(businessId, currentUserId.Value, ct)\n                .ConfigureAwait(false);\n\n            if (canSeeAll)\n                return;\n\n            // ‚úÖ Must be assigned to this user\n            var allowed = await _db.Contacts\n                .AsNoTracking()\n                .AnyAsync(c =>\n                    c.BusinessId == businessId &&\n                    c.Id == contactId &&\n                    c.AssignedAgentId == currentUserId.Value, ct)\n                .ConfigureAwait(false);\n\n            if (!allowed)\n                throw new UnauthorizedAccessException(\"Restricted inbox: you are not assigned to this conversation.\");\n        }\n\n        // ===========================\n        // Restricted-mode helpers\n        // ===========================\n\n        private static bool IsPrivilegedRoleName(string? roleName)\n        {\n            var role = (roleName ?? string.Empty).Trim().ToLowerInvariant();\n            return role is \"admin\" or \"business\" or \"superadmin\" or \"partner\";\n        }\n\n        private async Task<bool> CanSeeAllInRestrictedModeAsync(Guid businessId, Guid userId, CancellationToken ct)\n        {\n            var userRow = await _db.Users\n                .AsNoTracking()\n                .Where(u => u.Id == userId && u.BusinessId == businessId && !u.IsDeleted && u.Status == \"Active\")\n                .Select(u => new\n                {\n                    u.RoleId,\n                    RoleName = u.Role != null ? u.Role.Name : null\n                })\n                .FirstOrDefaultAsync(ct)\n                .ConfigureAwait(false);\n\n            if (userRow == null) return false;\n\n            if (IsPrivilegedRoleName(userRow.RoleName))\n                return true;\n\n            return await HasPermissionAsync(userId, InboxAssignPermissionCode, ct).ConfigureAwait(false);\n        }\n\n        private async Task<bool> HasPermissionAsync(Guid userId, string permissionCode, CancellationToken ct)\n        {\n            var code = (permissionCode ?? string.Empty).Trim().ToUpperInvariant();\n            if (code.Length == 0) return false;\n\n            var permissionId = await _db.Permissions\n                .AsNoTracking()\n                .Where(p => p.Code != null && p.Code.ToUpper() == code)\n                .Select(p => (Guid?)p.Id)\n                .FirstOrDefaultAsync(ct)\n                .ConfigureAwait(false);\n\n            if (!permissionId.HasValue) return false;\n\n            var direct = await _db.UserPermissions\n                .AsNoTracking()\n                .AnyAsync(up =>\n                    up.UserId == userId &&\n                    up.PermissionId == permissionId.Value &&\n                    up.IsGranted &&\n                    !up.IsRevoked, ct)\n                .ConfigureAwait(false);\n\n            if (direct) return true;\n\n            var roleId = await _db.Users\n                .AsNoTracking()\n                .Where(u => u.Id == userId)\n                .Select(u => u.RoleId)\n                .FirstOrDefaultAsync(ct)\n                .ConfigureAwait(false);\n\n            if (!roleId.HasValue) return false;\n\n            return await _db.RolePermissions\n                .AsNoTracking()\n                .AnyAsync(rp =>\n                    rp.RoleId == roleId.Value &&\n                    rp.PermissionId == permissionId.Value &&\n                    rp.IsActive &&\n                    !rp.IsRevoked, ct)\n                .ConfigureAwait(false);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/Services/IChatInboxAssignmentService.cs",
      "sha256": "6cd1d4ad791003816b2b886b52e41f5d4a892acb79ae0d5e6e06dd2674282c4e",
      "language": "csharp",
      "size": 721,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.ChatInbox.DTOs;\n\nnamespace xbytechat.api.Features.ChatInbox.Services\n{\n    public interface IChatInboxAssignmentService\n    {\n        Task<List<AgentDto>> GetAgentsAsync(Guid businessId, CancellationToken ct = default);\n\n        Task AssignAsync(Guid businessId, Guid contactId, Guid userId, Guid actorUserId, CancellationToken ct = default);\n        Task UnassignAsync(Guid businessId, Guid contactId, Guid actorUserId, CancellationToken ct = default);\n        Task SetStatusAsync(Guid businessId, Guid contactId, string status, Guid actorUserId, CancellationToken ct = default);\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/Services/IChatInboxCommandService.cs",
      "sha256": "fe1087d7e7140bbd2b8f4a8778c0ab0e53f70289ea02fb189749bc338476a848",
      "language": "csharp",
      "size": 2332,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/Services/IChatInboxCommandService.cs\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.ChatInbox.DTOs;\n\nnamespace xbytechat.api.Features.ChatInbox.Services\n{\n    public interface IChatInboxCommandService\n    {\n        /// <summary>\n        /// Sends an agent-authored text message to a contact from the Chat Inbox\n        /// and returns the resulting message DTO for the UI bubble.\n        /// </summary>\n        Task<ChatInboxMessageDto> SendAgentMessageAsync(\n            ChatInboxSendMessageRequestDto request,\n            CancellationToken ct = default);\n\n        /// <summary>\n        /// Updates per-user read state (ContactReads) for a conversation.\n        /// </summary>\n        //Task MarkConversationAsReadAsync(\n        //    ChatInboxMarkReadRequestDto request,\n        //    CancellationToken ct = default);\n\n        Task MarkConversationAsReadAsync(\n           Guid businessId,\n           Guid contactId,\n           Guid userId,\n           DateTime? lastReadAtUtc,\n           CancellationToken ct = default);\n    }\n}\n\n\n//using xbytechat.api.Features.ChatInbox.DTOs;\n\n//namespace xbytechat.api.Features.ChatInbox.Services\n//{\n//    public interface IChatInboxCommandService\n//    {\n//        /// <summary>\n//        /// Sends an agent-authored text message to a contact from the Chat Inbox\n//        /// and returns the resulting message DTO for the UI bubble.\n//        /// </summary>\n//        Task<ChatInboxMessageDto> SendAgentMessageAsync(\n//            ChatInboxSendMessageRequestDto request,\n//            CancellationToken ct = default);\n//        Task MarkConversationAsReadAsync(\n//            ChatInboxMarkReadRequestDto request,\n//            CancellationToken ct = default);\n\n//        Task AssignConversationAsync(\n//           ChatInboxAssignRequestDto request,\n//           CancellationToken ct = default);\n\n//        /// <summary>\n//        /// Unassigns a conversation (sets AssignedAgentId to null).\n//        /// </summary>\n//        Task UnassignConversationAsync(\n//            ChatInboxUnassignRequestDto request,\n//            CancellationToken ct = default);\n\n//        Task ChangeConversationStatusAsync(\n//           ChatInboxChangeStatusRequestDto request,\n//           CancellationToken ct = default);\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/Services/IChatInboxMediaContentService.cs",
      "sha256": "6c4f907fe73fbfe8ae410bb04d5f4d22d1e182dc2e9f6c01e110e4212b945f9e",
      "language": "csharp",
      "size": 385,
      "content": "using System;\nusing System.IO;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.ChatInbox.Services\n{\n    public interface IChatInboxMediaContentService\n    {\n        Task<(Stream Stream, string ContentType)> DownloadFromWhatsAppAsync(\n            Guid businessId,\n            string mediaId,\n            CancellationToken ct = default);\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/Services/IChatInboxMediaUploadService.cs",
      "sha256": "cefe534d5e5f40e1b10cd805528e4d3fe5a24a071cac7764d47e3bfb9adc6872",
      "language": "csharp",
      "size": 402,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Http;\n\nnamespace xbytechat.api.Features.ChatInbox.Services\n{\n    public interface IChatInboxMediaUploadService\n    {\n        Task<string> UploadToWhatsAppAsync(\n            Guid businessId,\n            string? phoneNumberId,\n            IFormFile file,\n            CancellationToken ct = default);\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/Services/IChatInboxQueryService.cs",
      "sha256": "963dc750087f4539b0bfeafa54493cc630b55987bf2cdd43a94f50885653de22",
      "language": "csharp",
      "size": 3320,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/Services/IChatInboxQueryService.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.ChatInbox.DTOs;\n\nnamespace xbytechat.api.Features.ChatInbox.Services\n{\n    public interface IChatInboxQueryService\n    {\n        // =========================\n        // Conversations\n        // =========================\n\n        // ‚úÖ Existing (non-paged)\n        Task<IReadOnlyList<ChatInboxConversationDto>> GetConversationsAsync(\n            ChatInboxFilterDto filter,\n            CancellationToken ct = default);\n\n        // ‚úÖ Cursor paging (used by controller when paged=true)\n        Task<PagedResultDto<ChatInboxConversationDto>> GetConversationsPageAsync(\n            ChatInboxFilterDto filter,\n            CancellationToken ct = default);\n\n        // =========================\n        // Messages (LEGACY)\n        // NOTE: These are backward compatible and DO NOT enforce restricted-mode visibility.\n        // Prefer the secured overloads below in controllers.\n        // =========================\n\n        Task<IReadOnlyList<ChatInboxMessageDto>> GetMessagesForConversationAsync(\n            Guid businessId,\n            string contactPhone,\n            int limit,\n            CancellationToken ct = default);\n\n        Task<IReadOnlyList<ChatInboxMessageDto>> GetMessagesForConversationByContactIdAsync(\n            Guid businessId,\n            Guid contactId,\n            int limit,\n            CancellationToken ct = default);\n\n        Task<PagedResultDto<ChatInboxMessageDto>> GetMessagesPageForConversationByContactIdAsync(\n            Guid businessId,\n            Guid contactId,\n            int limit,\n            string? cursor,\n            CancellationToken ct = default);\n\n        Task<PagedResultDto<ChatInboxMessageDto>> GetMessagesPageForConversationByPhoneAsync(\n            Guid businessId,\n            string contactPhone,\n            int limit,\n            string? cursor,\n            CancellationToken ct = default);\n\n        // =========================\n        // Messages (SECURED)\n        // ‚úÖ These enforce AssignedOnly restrictions using currentUserId from token.\n        // =========================\n\n        Task<IReadOnlyList<ChatInboxMessageDto>> GetMessagesForConversationAsync(\n            Guid businessId,\n            string contactPhone,\n            int limit,\n            Guid currentUserId,\n            CancellationToken ct = default);\n\n        Task<IReadOnlyList<ChatInboxMessageDto>> GetMessagesForConversationByContactIdAsync(\n            Guid businessId,\n            Guid contactId,\n            int limit,\n            Guid currentUserId,\n            CancellationToken ct = default);\n\n        Task<PagedResultDto<ChatInboxMessageDto>> GetMessagesPageForConversationByContactIdAsync(\n            Guid businessId,\n            Guid contactId,\n            int limit,\n            string? cursor,\n            Guid currentUserId,\n            CancellationToken ct = default);\n\n        Task<PagedResultDto<ChatInboxMessageDto>> GetMessagesPageForConversationByPhoneAsync(\n            Guid businessId,\n            string contactPhone,\n            int limit,\n            string? cursor,\n            Guid currentUserId,\n            CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/Utils/CursorCodec.cs",
      "sha256": "21089bac9edefd1e4a8b178491f66857b944410812a7b0ee113eec56c08bd2c9",
      "language": "csharp",
      "size": 1531,
      "content": "using System;\nusing System.Text;\nusing System.Text.Json;\n\nnamespace xbytechat.api.Features.ChatInbox.Utils\n{\n    internal static class CursorCodec\n    {\n        private static readonly JsonSerializerOptions JsonOpts = new(JsonSerializerDefaults.Web);\n\n        public static string Encode<T>(T obj)\n        {\n            var json = JsonSerializer.Serialize(obj, JsonOpts);\n            var bytes = Encoding.UTF8.GetBytes(json);\n            return Base64UrlEncode(bytes);\n        }\n\n        public static T? Decode<T>(string? cursor)\n        {\n            if (string.IsNullOrWhiteSpace(cursor)) return default;\n\n            try\n            {\n                var bytes = Base64UrlDecode(cursor.Trim());\n                var json = Encoding.UTF8.GetString(bytes);\n                return JsonSerializer.Deserialize<T>(json, JsonOpts);\n            }\n            catch\n            {\n                return default;\n            }\n        }\n\n        private static string Base64UrlEncode(byte[] input)\n        {\n            return Convert.ToBase64String(input)\n                .TrimEnd('=')\n                .Replace('+', '-')\n                .Replace('/', '_');\n        }\n\n        private static byte[] Base64UrlDecode(string input)\n        {\n            var padded = input.Replace('-', '+').Replace('_', '/');\n            switch (padded.Length % 4)\n            {\n                case 2: padded += \"==\"; break;\n                case 3: padded += \"=\"; break;\n            }\n            return Convert.FromBase64String(padded);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Controllers/ContactsController.cs",
      "sha256": "51c470a6310eea101c785831c7904967a477ba77ddaa65392188e685d9eeda86",
      "language": "csharp",
      "size": 17051,
      "content": "// üìÑ File: xbytechat-api/Features/CRM/Controllers/ContactsController.cs\n\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Hosting;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing xbytechat.api.Features.CRM.Models;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Shared;\nusing xbytechat.api.Features.CRM.Dtos;\nusing xbytechat.api.Features.CRM.Interfaces;\n\nnamespace xbytechat.api.Features.CRM.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize] // CRM should be authenticated\n    public class ContactsController : ControllerBase\n    {\n        private readonly IContactService _contactService;\n        private readonly IContactTagService _contactTagService;\n        private readonly AppDbContext _db;\n        private readonly IHostEnvironment _env;\n        private readonly ILogger<ContactsController> _logger;\n\n        public ContactsController(\n            IContactService contactService,\n            IContactTagService contactTagService,\n            AppDbContext db,\n            IHostEnvironment env,\n            ILogger<ContactsController> logger)\n        {\n            _contactService = contactService;\n            _contactTagService = contactTagService;\n            _db = db;\n            _env = env;\n            _logger = logger;\n        }\n\n        // POST: api/contacts/create\n        [HttpPost(\"create\")]\n        public async Task<IActionResult> AddContact([FromBody] ContactDto dto)\n        {\n            if (!ModelState.IsValid)\n                return BadRequest(ResponseResult.ErrorInfo(\"‚ùå Invalid contact payload.\"));\n\n            try\n            {\n                var businessId = HttpContext.User.GetBusinessId();\n                var result = await _contactService.AddContactAsync(businessId, dto);\n\n                return result.Success\n                    ? Ok(result)\n                    : BadRequest(result);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"üö® Unexpected error in AddContact\");\n                return StatusCode(500, ResponseResult.ErrorInfo(\"üö® Server error while creating contact.\", ex.ToString()));\n            }\n        }\n\n        // GET: api/contacts/{id}\n        [HttpGet(\"{id:guid}\")]\n        public async Task<IActionResult> GetContactById(Guid id)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var contact = await _contactService.GetContactByIdAsync(businessId, id);\n\n            if (contact == null)\n                return NotFound(ResponseResult.ErrorInfo(\"Contact not found.\"));\n\n            return Ok(ResponseResult.SuccessInfo(\"Contact loaded.\", contact));\n        }\n\n        // PUT: api/contacts/{id}\n        [HttpPut(\"{id:guid}\")]\n        public async Task<IActionResult> UpdateContact(Guid id, [FromBody] ContactDto dto)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            dto.Id = id;\n\n            var success = await _contactService.UpdateContactAsync(businessId, dto);\n            if (!success)\n                return NotFound(ResponseResult.ErrorInfo(\"Contact not found.\"));\n\n            return Ok(ResponseResult.SuccessInfo(\"Contact updated.\"));\n        }\n\n        // DELETE: api/contacts/{id}\n        [HttpDelete(\"{id:guid}\")]\n        public async Task<IActionResult> DeleteContact(Guid id)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n\n            var success = await _contactService.DeleteContactAsync(businessId, id);\n            if (!success)\n                return NotFound(ResponseResult.ErrorInfo(\"Contact not found.\"));\n\n            return Ok(ResponseResult.SuccessInfo(\"Contact deleted.\"));\n        }\n\n        // POST: api/contacts/parse-csv  (hidden from swagger as you did)\n        [ApiExplorerSettings(IgnoreApi = true)]\n        [HttpPost(\"parse-csv\")]\n        [Consumes(\"multipart/form-data\")]\n        public async Task<IActionResult> ParseCsvToContactsAsync([FromForm] IFormFile file)\n        {\n            if (file == null || file.Length == 0)\n                return BadRequest(ResponseResult.ErrorInfo(\"CSV file is required.\"));\n\n            var businessId = HttpContext.User.GetBusinessId();\n\n            try\n            {\n                using var stream = file.OpenReadStream();\n                var parseResult = await _contactService.ParseCsvToContactsAsync(businessId, stream);\n                return Ok(ResponseResult.SuccessInfo(\"CSV parsed with detailed results.\", parseResult));\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"CSV parsing failed.\");\n                return BadRequest(ResponseResult.ErrorInfo(\"CSV parsing failed: \" + ex.Message));\n            }\n        }\n\n        // PATCH: /api/contacts/{id}/favorite\n        [HttpPatch(\"{id:guid}/favorite\")]\n        public async Task<IActionResult> ToggleFavorite(Guid id)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n\n            var success = await _contactService.ToggleFavoriteAsync(businessId, id);\n            if (!success)\n                return NotFound(ResponseResult.ErrorInfo(\"Contact not found.\"));\n\n            return Ok(ResponseResult.SuccessInfo(\"Favorite toggled.\"));\n        }\n\n        // PATCH: /api/contacts/{id}/archive\n        [HttpPatch(\"{id:guid}/archive\")]\n        public async Task<IActionResult> ToggleArchive(Guid id)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n\n            var success = await _contactService.ToggleArchiveAsync(businessId, id);\n            if (!success)\n                return NotFound(ResponseResult.ErrorInfo(\"Contact not found.\"));\n\n            return Ok(ResponseResult.SuccessInfo(\"Archive toggled.\"));\n        }\n\n        // POST: api/contacts/bulk-assign-tag\n        [HttpPost(\"bulk-assign-tag\")]\n        public async Task<IActionResult> AssignTagToContacts([FromBody] AssignTagToContactsDto dto)\n        {\n            if (dto.ContactIds == null || !dto.ContactIds.Any())\n                return BadRequest(ResponseResult.ErrorInfo(\"No contact IDs provided.\"));\n\n            var businessId = HttpContext.User.GetBusinessId();\n\n            await _contactService.AssignTagToContactsAsync(businessId, dto.ContactIds, dto.TagId);\n            return Ok(ResponseResult.SuccessInfo(\"Tag assigned to selected contacts.\"));\n        }\n\n        // DELETE: api/contacts/{contactId}/tags/{tagId}\n        // Used by Inbox ‚Äúremove tag‚Äù on one contact.\n        [HttpDelete(\"{contactId:guid}/tags/{tagId:guid}\")]\n        public async Task<IActionResult> RemoveTagFromContact(Guid contactId, Guid tagId)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n\n            var removed = await _contactTagService.RemoveTagFromContactAsync(businessId, contactId, tagId);\n            if (!removed)\n                return NotFound(ResponseResult.ErrorInfo(\"Tag link not found for this contact.\"));\n\n            return Ok(ResponseResult.SuccessInfo(\"Tag removed from contact.\"));\n        }\n\n        // POST: api/contacts/bulk-unassign-tag\n        // Avoid axios DELETE-body edge cases\n        [HttpPost(\"bulk-unassign-tag\")]\n        public async Task<IActionResult> BulkUnassignTag([FromBody] AssignTagToContactsDto dto)\n        {\n            if (dto.ContactIds == null || !dto.ContactIds.Any())\n                return BadRequest(ResponseResult.ErrorInfo(\"No contact IDs provided.\"));\n\n            var businessId = HttpContext.User.GetBusinessId();\n\n            var removedCount = 0;\n            foreach (var contactId in dto.ContactIds)\n            {\n                var removed = await _contactTagService.RemoveTagFromContactAsync(businessId, contactId, dto.TagId);\n                if (removed) removedCount++;\n            }\n\n            return Ok(ResponseResult.SuccessInfo($\"Tag unassigned from {removedCount} contact(s).\", new { removedCount }));\n        }\n\n        // OPTIONAL: keep DELETE too (prevents 405 surprises)\n        [HttpDelete(\"bulk-unassign-tag\")]\n        public Task<IActionResult> BulkUnassignTagDelete([FromBody] AssignTagToContactsDto dto)\n            => BulkUnassignTag(dto);\n\n        // GET: api/contacts?tab=all&search=...&page=1&pageSize=25\n        [HttpGet]\n        public async Task<IActionResult> GetAllContacts(\n            [FromQuery] string? tab = \"all\",\n            [FromQuery] string? search = null,\n            [FromQuery] int page = 1,\n            [FromQuery] int pageSize = 25)\n        {\n            if (page < 1) page = 1;\n            if (pageSize < 1) pageSize = 25;\n            if (pageSize > 200) pageSize = 200; // safety cap\n\n            var businessId = HttpContext.User.GetBusinessId();\n\n            var pagedResult = await _contactService.GetPagedContactsAsync(businessId, tab, page, pageSize, search);\n            return Ok(ResponseResult.SuccessInfo(\"Contacts loaded.\", pagedResult));\n        }\n\n        // GET: api/contacts/all  (flat list, used in dropdowns)\n        [HttpGet(\"all\")]\n        public async Task<IActionResult> GetAllContactsFlat()\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var allContacts = await _contactService.GetAllContactsAsync(businessId);\n\n            // Keep wrapper consistent (helps frontend)\n            return Ok(ResponseResult.SuccessInfo(\"Contacts loaded.\", allContacts));\n        }\n\n        // POST: api/contacts/filter-by-tags  (body = list of tagIds as strings)\n        [HttpPost(\"filter-by-tags\")]\n        public async Task<IActionResult> FilterContactsByTags([FromBody] List<string> tags)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n\n            var tagGuids = (tags ?? new List<string>())\n                .Where(x => Guid.TryParse(x, out _))\n                .Select(Guid.Parse)\n                .ToList();\n\n            var contacts = await _contactService.GetContactsByTagsAsync(businessId, tagGuids);\n\n            return Ok(ResponseResult.SuccessInfo(\"Contacts filtered successfully.\", contacts));\n        }\n\n        // POST: api/contacts/bulk-import\n        [HttpPost(\"bulk-import\")]\n        [Consumes(\"multipart/form-data\")]\n        public async Task<IActionResult> BulkImportContactsAsync( IFormFile file)\n        {\n            if (file == null || file.Length == 0)\n                return BadRequest(ResponseResult.ErrorInfo(\"CSV file is required.\"));\n\n            var businessId = HttpContext.User.GetBusinessId();\n\n            try\n            {\n                using var stream = file.OpenReadStream();\n                var result = await _contactService.BulkImportAsync(businessId, stream);\n                return Ok(ResponseResult.SuccessInfo(\"Contacts imported successfully.\", result));\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Bulk import failed.\");\n                return BadRequest(ResponseResult.ErrorInfo(\"Import failed: \" + ex.Message));\n            }\n        }\n\n        // GET: api/contacts/by-tags?tagIds=...&tagIds=...\n        [HttpGet(\"by-tags\")]\n        public async Task<IActionResult> GetContactsByTagIds([FromQuery] List<Guid> tagIds)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var contacts = await _contactService.GetContactsByTagsAsync(businessId, tagIds);\n\n            return Ok(ResponseResult.SuccessInfo(\"Contacts filtered successfully.\", contacts));\n        }\n\n        // GET: api/contacts/debug/opt-status?phone=9198...\n        [ApiExplorerSettings(IgnoreApi = true)]\n        [HttpGet(\"debug/opt-status\")]\n        public async Task<IActionResult> GetOptStatusDebug([FromQuery] string phone)\n        {\n            if (string.IsNullOrWhiteSpace(phone))\n                return BadRequest(ResponseResult.ErrorInfo(\"Phone is required.\"));\n\n            var businessId = HttpContext.User.GetBusinessId();\n            var candidates = BuildPhoneLookupCandidates(phone);\n            if (candidates.Count == 0)\n                return BadRequest(ResponseResult.ErrorInfo(\"Phone format is invalid.\"));\n\n            var contact = await _db.Contacts\n                .AsNoTracking()\n                .Where(c => c.BusinessId == businessId && candidates.Contains(c.PhoneNumber))\n                .OrderByDescending(c => c.OptStatus == ContactOptStatus.OptedOut)\n                .ThenByDescending(c => c.OptStatusUpdatedAt)\n                .FirstOrDefaultAsync();\n\n            if (contact == null)\n            {\n                return NotFound(ResponseResult.ErrorInfo(\"Contact not found for provided phone.\"));\n            }\n\n            return Ok(ResponseResult.SuccessInfo(\"Opt status resolved.\", new\n            {\n                contactId = contact.Id,\n                phoneNumber = contact.PhoneNumber,\n                optStatus = contact.OptStatus.ToString(),\n                channelStatus = contact.ChannelStatus.ToString(),\n                optOutReason = contact.OptOutReason,\n                optStatusUpdatedAt = contact.OptStatusUpdatedAt,\n                channelStatusUpdatedAt = contact.ChannelStatusUpdatedAt\n            }));\n        }\n\n        // POST: api/contacts/debug/force-opt-in?phone=9198...&resetChannel=true\n        [ApiExplorerSettings(IgnoreApi = true)]\n        [HttpPost(\"debug/force-opt-in\")]\n        public async Task<IActionResult> ForceOptInDebug([FromQuery] string phone, [FromQuery] bool resetChannel = false)\n        {\n            if (_env.IsProduction())\n                return StatusCode(403, ResponseResult.ErrorInfo(\"Debug endpoint is disabled in production.\"));\n\n            if (string.IsNullOrWhiteSpace(phone))\n                return BadRequest(ResponseResult.ErrorInfo(\"Phone is required.\"));\n\n            var businessId = HttpContext.User.GetBusinessId();\n            var candidates = BuildPhoneLookupCandidates(phone);\n            if (candidates.Count == 0)\n                return BadRequest(ResponseResult.ErrorInfo(\"Phone format is invalid.\"));\n\n            var contact = await _db.Contacts\n                .Where(c => c.BusinessId == businessId && candidates.Contains(c.PhoneNumber))\n                .OrderByDescending(c => c.OptStatus == ContactOptStatus.OptedOut)\n                .ThenByDescending(c => c.OptStatusUpdatedAt)\n                .FirstOrDefaultAsync();\n\n            if (contact == null)\n                return NotFound(ResponseResult.ErrorInfo(\"Contact not found for provided phone.\"));\n\n            var nowUtc = DateTime.UtcNow;\n            contact.OptStatus = ContactOptStatus.OptedIn;\n            contact.OptStatusUpdatedAt = nowUtc;\n            contact.OptOutReason = null;\n\n            if (resetChannel)\n            {\n                contact.ChannelStatus = ContactChannelStatus.Valid;\n                contact.ChannelStatusUpdatedAt = nowUtc;\n            }\n\n            await _db.SaveChangesAsync();\n\n            _logger.LogWarning(\n                \"Debug force-opt-in applied. businessId={BusinessId} contactId={ContactId} phone={Phone} resetChannel={ResetChannel}\",\n                businessId,\n                contact.Id,\n                contact.PhoneNumber,\n                resetChannel);\n\n            return Ok(ResponseResult.SuccessInfo(\"Contact force opt-in applied.\", new\n            {\n                contactId = contact.Id,\n                phoneNumber = contact.PhoneNumber,\n                optStatus = contact.OptStatus.ToString(),\n                channelStatus = contact.ChannelStatus.ToString(),\n                optOutReason = contact.OptOutReason,\n                optStatusUpdatedAt = contact.OptStatusUpdatedAt,\n                channelStatusUpdatedAt = contact.ChannelStatusUpdatedAt,\n                resetChannel\n            }));\n        }\n\n        private static List<string> BuildPhoneLookupCandidates(string? raw)\n        {\n            var value = (raw ?? string.Empty).Trim();\n            var list = new HashSet<string>(StringComparer.Ordinal);\n\n            var normalized = PhoneNumberNormalizer.NormalizeToE164Digits(value, \"IN\");\n            var digits = new string(value.Where(char.IsDigit).ToArray());\n\n            if (!string.IsNullOrWhiteSpace(normalized))\n            {\n                list.Add(normalized);\n                list.Add(\"+\" + normalized);\n\n                if (normalized.Length == 12 && normalized.StartsWith(\"91\", StringComparison.Ordinal))\n                    list.Add(normalized.Substring(2));\n            }\n\n            if (!string.IsNullOrWhiteSpace(digits))\n            {\n                list.Add(digits);\n                list.Add(\"+\" + digits);\n\n                if (digits.Length == 10)\n                {\n                    list.Add(\"91\" + digits);\n                    list.Add(\"+91\" + digits);\n                }\n                else if (digits.Length == 12 && digits.StartsWith(\"91\", StringComparison.Ordinal))\n                {\n                    list.Add(digits.Substring(2));\n                }\n            }\n\n            if (!string.IsNullOrWhiteSpace(value))\n                list.Add(value);\n\n            return list.Where(x => !string.IsNullOrWhiteSpace(x)).ToList();\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Controllers/CrmSummaryController.cs",
      "sha256": "49a9a81d7aeacd60428584f63e0e2315622b2a2a91ea8cff69145a7c452a67e0",
      "language": "csharp",
      "size": 2829,
      "content": "// üìÑ xbytechat-api/Features/CRM/Summary/Controllers/CrmSummaryController.cs\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.CRM.Services;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.CRM.Controllers\n{\n    /// <summary>\n    /// Thin API surface for CRM summary endpoints used by Chat Inbox\n    /// and future dashboards.\n    /// </summary>\n    [ApiController]\n    [Route(\"api/crm-summary\")]\n    public sealed class CrmSummaryController : ControllerBase\n    {\n        private readonly IContactSummaryService _contactSummaryService;\n        private readonly ILogger<CrmSummaryController> _logger;\n\n        public CrmSummaryController(\n            IContactSummaryService contactSummaryService,\n            ILogger<CrmSummaryController> logger)\n        {\n            _contactSummaryService = contactSummaryService ?? throw new ArgumentNullException(nameof(contactSummaryService));\n            _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n        }\n\n        /// <summary>\n        /// Returns a compact CRM snapshot for a given contact:\n        /// Contact core fields, tags, recent notes, next reminder, recent timeline entries.\n        /// </summary>\n        [HttpGet(\"contact-summary/{contactId:guid}\")]              // ‚úÖ new route: /api/crm-summary/contact-summary/{id}\n        [HttpGet(\"/api/crm/contact-summary/{contactId:guid}\")]     // ‚úÖ backward-compatible route: /api/crm/contact-summary/{id}\n        public async Task<IActionResult> GetContactSummary(Guid contactId, CancellationToken ct)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            if (businessId == Guid.Empty)\n            {\n                return Unauthorized(ResponseResult.ErrorInfo(\"Missing BusinessId in user claims.\"));\n            }\n\n            try\n            {\n                var summary = await _contactSummaryService.GetContactSummaryAsync(businessId, contactId, ct);\n                if (summary == null)\n                {\n                    return NotFound(ResponseResult.ErrorInfo(\"Contact not found for this business.\"));\n                }\n\n                return Ok(ResponseResult.SuccessInfo(\"Contact summary loaded.\", summary));\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(\n                    ex,\n                    \"‚ùå Failed to load contact summary. Business={BusinessId}, Contact={ContactId}\",\n                    businessId,\n                    contactId);\n\n                return StatusCode(\n                    500,\n                    ResponseResult.ErrorInfo(\"An error occurred while loading contact summary.\", ex.Message));\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Controllers/NotesController.cs",
      "sha256": "cb225e42566f276e2b69c4112c1a6afb8ea4bb176fabbb5e7a628df83604a799",
      "language": "csharp",
      "size": 3574,
      "content": "// üìÑ xbytechat-api/Features/CRM/Controllers/NotesController.cs\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.CRM.Dtos;\nusing xbytechat.api.Features.CRM.Interfaces;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.CRM.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class NotesController : ControllerBase\n    {\n        private readonly INoteService _noteService;\n\n        public NotesController(INoteService noteService)\n        {\n            _noteService = noteService;\n        }\n\n        // ‚úÖ Clean, REST-y POST: /api/notes\n        [HttpPost]\n        public async Task<IActionResult> AddNote([FromBody] NoteDto dto)\n        {\n            try\n            {\n                if (dto == null)\n                {\n                    return BadRequest(ResponseResult.ErrorInfo(\"Note payload is missing.\"));\n                }\n\n                var businessId = HttpContext.User.GetBusinessId();\n                var result = await _noteService.AddNoteAsync(businessId, dto);\n                return Ok(ResponseResult.SuccessInfo(\"Note created.\", result));\n            }\n            catch (Exception ex)\n            {\n                return StatusCode(\n                    500,\n                    ResponseResult.ErrorInfo(\"Error creating note\", ex.Message)\n                );\n            }\n        }\n\n        // GET /api/notes/contact/{contactId}\n        [HttpGet(\"contact/{contactId}\")]\n        public async Task<IActionResult> GetNotesByContact(Guid contactId)\n        {\n            try\n            {\n                var businessId = HttpContext.User.GetBusinessId();\n                var result = await _noteService.GetNotesByContactAsync(businessId, contactId);\n                return Ok(ResponseResult.SuccessInfo(\"Notes loaded.\", result));\n            }\n            catch (Exception ex)\n            {\n                return StatusCode(\n                    500,\n                    ResponseResult.ErrorInfo(\"Error fetching notes\", ex.Message)\n                );\n            }\n        }\n\n        // GET /api/notes/{id}\n        [HttpGet(\"{id}\")]\n        public async Task<IActionResult> GetNoteById(Guid id)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var result = await _noteService.GetNoteByIdAsync(businessId, id);\n\n            if (result == null)\n            {\n                return NotFound(ResponseResult.ErrorInfo(\"Note not found.\"));\n            }\n\n            return Ok(ResponseResult.SuccessInfo(\"Note loaded.\", result));\n        }\n\n        // PUT /api/notes/{id}\n        [HttpPut(\"{id}\")]\n        public async Task<IActionResult> UpdateNote(Guid id, [FromBody] NoteDto dto)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var success = await _noteService.UpdateNoteAsync(businessId, id, dto);\n\n            if (!success)\n            {\n                return NotFound(ResponseResult.ErrorInfo(\"Note not found.\"));\n            }\n\n            return Ok(ResponseResult.SuccessInfo(\"Note updated.\"));\n        }\n\n        // DELETE /api/notes/{id}\n        [HttpDelete(\"{id}\")]\n        public async Task<IActionResult> DeleteNote(Guid id)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var success = await _noteService.DeleteNoteAsync(businessId, id);\n\n            if (!success)\n            {\n                return NotFound(ResponseResult.ErrorInfo(\"Note not found.\"));\n            }\n\n            return Ok(ResponseResult.SuccessInfo(\"Note deleted.\"));\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Controllers/RemindersController.cs",
      "sha256": "94768043e5877270f9ca797c084d60b10d081df7b7973bed29466c4b07018405",
      "language": "csharp",
      "size": 3241,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.CRM.Models;\nusing xbytechat.api.Features.CRM.Dtos;\nusing xbytechat.api.Features.CRM.Interfaces;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.CRM.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class RemindersController : ControllerBase\n    {\n        private readonly IReminderService _reminderService;\n\n        public RemindersController(IReminderService reminderService)\n        {\n            _reminderService = reminderService;\n        }\n\n        [HttpPost]\n        public async Task<IActionResult> AddReminder(ReminderDto dto)\n        {\n            try\n            {\n                var businessId = HttpContext.User.GetBusinessId();\n                if (dto == null)\n                    return BadRequest(ResponseResult.ErrorInfo(\"Reminder data is missing.\"));\n\n                var result = await _reminderService.AddReminderAsync(businessId, dto);\n                return Ok(ResponseResult.SuccessInfo(\"Reminder created.\", result));\n            }\n            catch (Exception ex)\n            {\n                return StatusCode(500, ResponseResult.ErrorInfo(\"An error occurred while adding the reminder.\", ex.Message));\n            }\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> GetAllReminders()\n        {\n            try\n            {\n                var businessId = HttpContext.User.GetBusinessId();\n                var reminders = await _reminderService.GetAllRemindersAsync(businessId);\n                return Ok(ResponseResult.SuccessInfo(\"Reminders loaded.\", reminders));\n            }\n            catch (Exception ex)\n            {\n                return StatusCode(500, ResponseResult.ErrorInfo(\"An error occurred while fetching reminders.\", ex.Message));\n            }\n        }\n\n        [HttpGet(\"{id}\")]\n        public async Task<IActionResult> GetReminderById(Guid id)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var reminder = await _reminderService.GetReminderByIdAsync(businessId, id);\n            if (reminder == null)\n                return NotFound(ResponseResult.ErrorInfo(\"Reminder not found.\"));\n            return Ok(ResponseResult.SuccessInfo(\"Reminder loaded.\", reminder));\n        }\n\n        [HttpPut(\"{id}\")]\n        public async Task<IActionResult> UpdateReminder(Guid id, [FromBody] ReminderDto dto)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var success = await _reminderService.UpdateReminderAsync(businessId, id, dto);\n            if (!success)\n                return NotFound(ResponseResult.ErrorInfo(\"Reminder not found.\"));\n            return Ok(ResponseResult.SuccessInfo(\"Reminder updated.\"));\n        }\n\n        [HttpDelete(\"{id}\")]\n        public async Task<IActionResult> DeleteReminder(Guid id)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var success = await _reminderService.DeleteReminderAsync(businessId, id);\n            if (!success)\n                return NotFound(ResponseResult.ErrorInfo(\"Reminder not found.\"));\n            return Ok(ResponseResult.SuccessInfo(\"Reminder deleted.\"));\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Controllers/TagsController.cs",
      "sha256": "63ac6f2a529c4a2363dc42af6e6a6c17792b7aaf572935395352ebd5a8069124",
      "language": "csharp",
      "size": 2397,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.CRM.Dtos;\nusing xbytechat.api.Features.CRM.Interfaces;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.CRM.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class TagsController : ControllerBase\n    {\n        private readonly ITagService _tagService;\n\n        public TagsController(ITagService tagService)\n        {\n            _tagService = tagService;\n        }\n\n        [HttpPost]\n        public async Task<IActionResult> AddTag([FromBody] TagDto dto)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var result = await _tagService.AddTagAsync(businessId, dto);\n            return Ok(ResponseResult.SuccessInfo(\"Tag created.\", result));\n        }\n\n        [HttpPut(\"{id}\")]\n        public async Task<IActionResult> UpdateTag(Guid id, [FromBody] TagDto dto)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var success = await _tagService.UpdateTagAsync(businessId, id, dto);\n            if (!success)\n                return NotFound(ResponseResult.ErrorInfo(\"Tag not found.\"));\n            return Ok(ResponseResult.SuccessInfo(\"Tag updated.\"));\n        }\n\n        ////[HttpGet(\"get-tags\")]\n        [HttpGet(\"get-tags\")]\n        public async Task<IActionResult> GetAllTagsLegacy()\n        {\n            // Backward compatible alias for older clients\n            var businessId = HttpContext.User.GetBusinessId();\n            var tags = await _tagService.GetAllTagsAsync(businessId);\n            return Ok(ResponseResult.SuccessInfo(\"Tags loaded.\", tags));\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> GetAllTags()\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var tags = await _tagService.GetAllTagsAsync(businessId);\n            return Ok(ResponseResult.SuccessInfo(\"Tags loaded.\", tags));\n        }\n\n        [HttpDelete(\"{id}\")]\n        public async Task<IActionResult> DeleteTag(Guid id)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var success = await _tagService.DeleteTagAsync(businessId, id);\n            if (!success)\n                return NotFound(ResponseResult.ErrorInfo(\"Tag not found.\"));\n            return Ok(ResponseResult.SuccessInfo(\"Tag deleted.\"));\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Dtos/AssignTagToContactsDto.cs",
      "sha256": "905dc04f16dd3b6ee269a89e0ea202a6af3dea76b223c9013713e74bb418bb24",
      "language": "csharp",
      "size": 198,
      "content": "namespace xbytechat.api.Features.CRM.Dtos\n{\n    public class AssignTagToContactsDto\n    {\n        public List<Guid> ContactIds { get; set; } = new();\n        public Guid TagId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Dtos/BulkImportResultDto.cs",
      "sha256": "f552fe1e5d5f1e2a8275aae3baac3882b78b0cae422c4ac8d82db52d3c78bdba",
      "language": "csharp",
      "size": 1145,
      "content": "namespace xbytechat.api.Features.CRM.Dtos\n{\n    public class BulkImportResultDto\n    {\n        public int Imported { get; set; }          // brand-new rows inserted\n        public int Restored { get; set; }          // previously IsActive=false -> restored\n        public int SkippedExisting { get; set; }   // already active -> skipped\n        public int DuplicatesInFile { get; set; }  // same phone repeated in CSV -> ignored\n        public List<CsvImportError> Errors { get; set; } = new();\n    }\n\n    // Optional: remove this if unused (CsvImportError already exists elsewhere)\n    public class CsvImportErrorMsg\n    {\n        public int RowNumber { get; set; }\n        public string ErrorMessage { get; set; }\n    }\n}\n\n\n//namespace xbytechat.api.Features.CRM.Dtos\n//{\n//    public class BulkImportResultDto\n//    {\n//        public int Imported { get; set; }\n//        public int SkippedExisting { get; set; }\n//        public List<CsvImportError> Errors { get; set; } = new();\n//    }\n\n//    public class CsvImportErrorMsg\n//    {\n//        public int RowNumber { get; set; }\n//        public string ErrorMessage { get; set; }\n//    }\n//}"
    },
    {
      "path": "xbytechat-api/Features/CRM/Dtos/ContactDto.cs",
      "sha256": "83bef17a1c7bc4901f020261fb9a4d30c7bab7acab03e82fe3182e4eb4a24de3",
      "language": "csharp",
      "size": 1365,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.CRM.Dtos\n{\n    public class ContactDto\n    {\n        public Guid? Id { get; set; } // Nullable for Create (used in PUT)\n\n        public string Name { get; set; } // Contact full name\n\n        public string PhoneNumber { get; set; } // WhatsApp-compatible number\n\n        public string? Email { get; set; } // Optional email address\n\n        public string? LeadSource { get; set; } // e.g., \"WhatsApp\", \"Facebook\", \"Landing Page\"\n\n        public DateTime? LastContactedAt { get; set; } // Last WhatsApp or CRM interaction\n\n        public DateTime? NextFollowUpAt { get; set; } // For scheduling reminders\n\n        public string? Notes { get; set; } // Internal notes for the contact\n\n        public DateTime? CreatedAt { get; set; } // Read-only timestamp\n\n        // ‚úÖ NEW: Structured Tags (replaces comma-separated strings)\n        // Example: [{ id: 1, name: \"VIP\" }, { id: 2, name: \"Follow-up\" }]\n        public List<ContactTagDto> Tags { get; set; } = new();\n\n        public bool IsFavorite { get; set; } = false;\n        public bool IsArchived { get; set; } = false;\n        public string? Group { get; set; }\n\n        public bool IsTemporary { get; set; } = false;\n        public Guid? SourceCampaignId { get; set; }\n        public DateTime? ExpiresAt { get; set; }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Dtos/ContactDtoCsvMap.cs",
      "sha256": "1e2f57eea6d6f012d91f094a8f62c352fe93ae763566730af8c530fe0fb271b7",
      "language": "csharp",
      "size": 1744,
      "content": "using CsvHelper.Configuration;\n\nnamespace xbytechat.api.Features.CRM.Dtos\n{\n    /// <summary>\n    /// CSV mapping for ContactDto import.\n    /// Keeps header matching flexible (multiple header aliases).\n    /// Header normalization is applied in CsvConfiguration (not here).\n    /// </summary>\n    public sealed class ContactDtoCsvMap : ClassMap<ContactDto>\n    {\n        public ContactDtoCsvMap()\n        {\n            // Required core columns\n            Map(m => m.Name).Name(\"name\", \"fullname\", \"contactname\", \"customername\");\n            Map(m => m.PhoneNumber).Name(\"phone\", \"phonenumber\", \"mobile\", \"mobilenumber\", \"whatsapp\", \"whatsappnumber\");\n\n            // Optional columns\n            Map(m => m.Email).Name(\"email\", \"emailid\").Optional();\n            Map(m => m.Notes).Name(\"notes\", \"note\", \"remark\", \"remarks\", \"comment\", \"comments\").Optional();\n\n            // Optional but useful for CRM analytics\n            Map(m => m.LeadSource).Name(\"leadsource\", \"lead source\", \"source\", \"lead\", \"leadorigin\").Optional();\n\n            // We are intentionally NOT importing Tags yet because Tags is a List<string>.\n            // If you want later: we can add a converter for a comma-separated \"Tags\" column.\n        }\n    }\n}\n\n\n//using CsvHelper.Configuration;\n\n//namespace xbytechat.api.Features.CRM.Dtos\n//{\n//    public class ContactDtoCsvMap : ClassMap<ContactDto>\n//    {\n//        public ContactDtoCsvMap()\n//        {\n//            Map(m => m.Name).Name(\"name\", \"Name\", \"full name\");\n//            Map(m => m.PhoneNumber).Name(\"phone\", \"Phone\", \"mobile\", \"mobile number\");\n//            Map(m => m.Email).Name(\"email\", \"Email\").Optional();\n//            Map(m => m.Notes).Name(\"notes\", \"Notes\").Optional();\n//        }\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Dtos/ContactSummaryResponseDto.cs",
      "sha256": "9e1ca2d18ba212e71090bdc4633e1e4cf955e8f8ba21663145f60c032f1031e1",
      "language": "csharp",
      "size": 1436,
      "content": "// üìÑ xbytechat-api/Features/CRM/Summary/Dtos/ContactSummaryResponseDto.cs\nusing System;\nusing System.Collections.Generic;\nusing xbytechat.api.Features.CRM.Timelines.DTOs;\n\nnamespace xbytechat.api.Features.CRM.Dtos\n{\n    /// <summary>\n    /// Compact CRM snapshot for a contact:\n    /// - Core contact fields\n    /// - Tags\n    /// - Recent notes\n    /// - Next reminder\n    /// - Recent timeline events\n    /// </summary>\n    public sealed class ContactSummaryResponseDto\n    {\n        public Guid BusinessId { get; set; }\n        public Guid ContactId { get; set; }\n\n        // Core contact profile\n        public string Name { get; set; } = string.Empty;\n        public string PhoneNumber { get; set; } = string.Empty;\n        public string? Email { get; set; }\n        public string? LeadSource { get; set; }\n\n        public bool IsFavorite { get; set; }\n        public bool IsArchived { get; set; }\n        public string? Group { get; set; }\n\n        public DateTime? LastContactedAt { get; set; }\n        public DateTime? NextFollowUpAt { get; set; }\n\n        // Structured tags (from ContactDto.ContactTags ‚Üí ContactTagDto)\n        public List<ContactTagDto> Tags { get; set; } = new();\n\n        // Mini timeline section\n        public List<NoteDto> RecentNotes { get; set; } = new();\n\n        public ReminderDto? NextReminder { get; set; }\n\n        public List<LeadTimelineDto> RecentTimeline { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Dtos/ContactTagDto.cs",
      "sha256": "69e97156f1e9453485bbaa39803b7c132d5a991e27091eb6cb648b42a148fc7a",
      "language": "csharp",
      "size": 281,
      "content": "namespace xbytechat.api.Features.CRM.Dtos\n{\n    public class ContactTagDto\n    {\n        public Guid TagId { get; set; }\n        public string TagName { get; set; } = string.Empty;\n        public string? ColorHex { get; set; }\n        public string? Category { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Dtos/CrmContactSummaryDto.cs",
      "sha256": "320c7a1b0dd1223ea9e8a517b258e7235d2c12f71a798317c71483d95d2b0d26",
      "language": "csharp",
      "size": 2012,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.CRM.DTOs\n{\n    public sealed class CrmContactSummaryDto\n    {\n        public Guid ContactId { get; set; }\n        public Guid BusinessId { get; set; }\n\n        public string Name { get; set; } = string.Empty;\n        public string PhoneNumber { get; set; } = string.Empty;\n        public string? Email { get; set; }\n        public string? LeadSource { get; set; }\n        public DateTime? CreatedAt { get; set; }\n\n        // üëá These names match ChatInbox.jsx usage\n        public List<CrmTagChipDto> Tags { get; set; } = new();\n        public List<CrmNoteSnippetDto> RecentNotes { get; set; } = new();\n        public CrmReminderSnippetDto? NextReminder { get; set; }\n        public List<CrmTimelineEventDto> RecentTimeline { get; set; } = new();\n    }\n\n    public sealed class CrmTagChipDto\n    {\n        public Guid Id { get; set; }\n        public string TagName { get; set; } = string.Empty;\n        public string? ColorHex { get; set; }\n    }\n\n    public sealed class CrmNoteSnippetDto\n    {\n        public Guid Id { get; set; }\n        public string Title { get; set; } = string.Empty;\n        public string Content { get; set; } = string.Empty;\n        public string? CreatedByName { get; set; }\n        public DateTime CreatedAt { get; set; }\n    }\n\n    public sealed class CrmReminderSnippetDto\n    {\n        public Guid Id { get; set; }\n        public string Title { get; set; } = string.Empty;\n        public string? Description { get; set; }\n        public string? Status { get; set; }\n        public DateTime DueAt { get; set; }\n        public int? Priority { get; set; }\n    }\n\n    public sealed class CrmTimelineEventDto\n    {\n        public int Id { get; set; }\n        public string Title { get; set; } = string.Empty;\n        public string? Source { get; set; }\n        public string? Category { get; set; }\n        public string? EventType { get; set; }\n        public DateTime CreatedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Dtos/CsvImportResult.cs",
      "sha256": "b960c95f03cdabf593c9264c4a26457bc30278af2e88d77efe9a54ae066dd3c7",
      "language": "csharp",
      "size": 373,
      "content": "namespace xbytechat.api.Features.CRM.Dtos\n{\n    public class CsvImportResult<T>\n    {\n        public List<T> SuccessRecords { get; set; } = new();\n        public List<CsvImportError> Errors { get; set; } = new();\n    }\n\n    public class CsvImportError\n    {\n        public int RowNumber { get; set; }\n        public string ErrorMessage { get; set; } = string.Empty;\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/CRM/Dtos/NoteDto.cs",
      "sha256": "c69bf4f1954478dea6d479494ee03486eaac09f14ac495b0cbde23f17f107568",
      "language": "csharp",
      "size": 525,
      "content": "namespace xbytechat.api.Features.CRM.Dtos\n{\n    public class NoteDto\n    {\n        public Guid Id { get; set; }\n        public Guid? ContactId { get; set; }\n        public string? Title { get; set; }\n        public string Content { get; set; }\n        public string Source { get; set; }\n        public string CreatedBy { get; set; }\n        public bool IsPinned { get; set; }\n        public bool IsInternal { get; set; }\n        public DateTime CreatedAt { get; set; }\n        public DateTime? EditedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Dtos/PagedResult.cs",
      "sha256": "fecb6fb29ec3bedc245dacd6fb2198d2f2c98335be5a5d93cd5a787d9248faa3",
      "language": "csharp",
      "size": 351,
      "content": "namespace xbytechat.api.Features.CRM.Dtos\n{\n    public class PagedResult<T>\n    {\n        public List<T> Items { get; set; } = new();\n        public int TotalCount { get; set; }\n\n        public int Page { get; set; }\n        public int PageSize { get; set; }\n        public int TotalPages => (int)Math.Ceiling(TotalCount / (double)PageSize);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Dtos/ReminderDto.cs",
      "sha256": "637c90565af9cbcfe158cca564388b9afdadb2c3cbcacad35242dfe85f9bd395",
      "language": "csharp",
      "size": 1003,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CRM.Dtos\n{\n    public class ReminderDto\n    {\n        public Guid? Id { get; set; }  // Null when creating, present when updating\n\n        public Guid? ContactId { get; set; }\n\n        public string Title { get; set; } = default!;\n\n        public string? Description { get; set; }\n\n        public DateTime DueAt { get; set; }\n\n        public string? Status { get; set; } = \"Pending\";\n\n        public string? ReminderType { get; set; }\n\n        public int? Priority { get; set; }\n\n        public bool IsRecurring { get; set; }\n\n        public string? RecurrencePattern { get; set; }\n\n        public bool SendWhatsappNotification { get; set; }\n\n        public string? LinkedCampaign { get; set; }\n\n        public bool IsActive { get; set; } = true;\n\n        public DateTime? CreatedAt { get; set; }\n\n        public DateTime? UpdatedAt { get; set; }\n\n        public DateTime? CompletedAt { get; set; }\n\n        public string? CreatedBy { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Dtos/TagDto.cs",
      "sha256": "cd0010264a2cc4567c59311afd6d637f23f2e070be2d4da68f6be0ab97e46ff4",
      "language": "csharp",
      "size": 521,
      "content": "namespace xbytechat.api.Features.CRM.Dtos\n{\n    public class TagDto\n    {\n        public Guid? Id { get; set; }\n\n        public string Name { get; set; } = default!;\n\n        public string? ColorHex { get; set; }\n\n        public string? Category { get; set; }\n\n        public string? Notes { get; set; }\n\n        public bool IsSystemTag { get; set; } = false;\n\n        public bool IsActive { get; set; } = true;\n\n        public DateTime? CreatedAt { get; set; }\n\n        public DateTime? LastUsedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Interfaces/IContactService.cs",
      "sha256": "b7ca4f37c5420dd9e44b8fd2d03c1c0fff462256304cae410fbd5a135aa261b9",
      "language": "csharp",
      "size": 1862,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CRM.Dtos;\nusing xbytechat.api.Features.CRM.Models;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.CRM.Interfaces\n{\n    /// <summary>\n    /// Defines the contract for all operations related to managing contacts.\n    /// </summary>\n    public interface IContactService\n    {\n\n        Task<ResponseResult> AddContactAsync(Guid businessId, ContactDto dto);\n        Task<ContactDto> GetContactByIdAsync(Guid businessId, Guid contactId);\n        Task<bool> UpdateContactAsync(Guid businessId, ContactDto dto);\n        Task<bool> DeleteContactAsync(Guid businessId, Guid contactId);\n        Task<CsvImportResult<ContactDto>> ParseCsvToContactsAsync(Guid businessId, Stream csvStream);\n        Task<Contact> FindOrCreateAsync(Guid businessId, string phoneNumber);\n        Task<bool> ToggleFavoriteAsync(Guid businessId, Guid contactId);\n        Task<bool> ToggleArchiveAsync(Guid businessId, Guid contactId);\n        Task<IEnumerable<ContactDto>> GetAllContactsAsync(Guid businessId, string? tab = \"all\");\n        Task AssignTagToContactsAsync(Guid businessId, List<Guid> contactIds, Guid tagId);\n        Task<PagedResult<ContactDto>> GetPagedContactsAsync(\n             Guid businessId,\n             string? tab = \"all\",\n             int page = 1,\n             int pageSize = 25,\n             string? searchTerm = null\n            );\n        // ‚úÖ Tag-based filtering support\n        Task<IEnumerable<ContactDto>> GetContactsByTagsAsync(Guid businessId, List<Guid> tags);\n\n        Task<BulkImportResultDto> BulkImportAsync(Guid businessId, Stream csvStream);\n        // üìå New method to support flow node ‚Üí tag assignment\n        Task<bool> AssignTagsAsync(Guid businessId, string phoneNumber, List<string> tags);\n\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Interfaces/IContactTagService.cs",
      "sha256": "779257e42642346dc94fd82a0d7286bc5fc37e9c884338d039f4849cf222d5e2",
      "language": "csharp",
      "size": 195,
      "content": "namespace xbytechat.api.Features.CRM.Interfaces\n{\n    public interface IContactTagService\n    {\n        Task<bool> RemoveTagFromContactAsync(Guid businessId, Guid contactId, Guid tagId);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Interfaces/INoteService.cs",
      "sha256": "3a55224ed1bd77632f1df5c60e2b9e83f76c595578c5cb47c07bd3965bda4360",
      "language": "csharp",
      "size": 705,
      "content": "using xbytechat.api.Features.CRM.Dtos;\n\nnamespace xbytechat.api.Features.CRM.Interfaces\n{\n    public interface INoteService\n    {\n        // For creating new note\n        Task<NoteDto> AddNoteAsync(Guid businessId, NoteDto dto);\n\n        // List all notes for dashboard view\n        Task<IEnumerable<NoteDto>> GetNotesByContactAsync(Guid businessId, Guid contactId);\n\n        // For loading note in edit mode\n        Task<NoteDto?> GetNoteByIdAsync(Guid businessId, Guid noteId);\n        // Handles editing\n        Task<bool> UpdateNoteAsync(Guid businessId, Guid noteId, NoteDto dto);\n        // Soft delete ‚Üí IsActive = false\n        Task<bool> DeleteNoteAsync(Guid businessId, Guid noteId);\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Interfaces/IReminderService.cs",
      "sha256": "ee0bb73d2c3d212a59012abdf1d71ab3ef240b6f785d25dde255e5c7d30f3e16",
      "language": "csharp",
      "size": 824,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CRM.Dtos;\n\nnamespace xbytechat.api.Features.CRM.Interfaces\n{\n    public interface IReminderService\n    {\n        //For creating new reminder\n        Task<ReminderDto> AddReminderAsync(Guid businessId, ReminderDto dto);\n\n        //List all reminders for dashboard view\n        Task<IEnumerable<ReminderDto>> GetAllRemindersAsync(Guid businessId);\n\n        //For loading reminder in edit mode\n        Task<ReminderDto?> GetReminderByIdAsync(Guid businessId, Guid reminderId);\n\n        //Handles editing\n        Task<bool> UpdateReminderAsync(Guid businessId, Guid reminderId, ReminderDto dto);\n        //Soft delete ‚Üí IsActive = false\n        Task<bool> DeleteReminderAsync(Guid businessId, Guid reminderId);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Interfaces/ITagService.cs",
      "sha256": "3e9fdf4fa03f5eb4006b2b264f94a12f5fc20b7b8edc17f06e5ebcbe30d5c379",
      "language": "csharp",
      "size": 733,
      "content": "// üìÑ File: xbytechat-api/Features/CRM/Interfaces/ITagService.cs\n\nusing System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CRM.Dtos;\n\nnamespace xbytechat.api.Features.CRM.Interfaces\n{\n    public interface ITagService\n    {\n        Task<TagDto> AddTagAsync(Guid businessId, TagDto dto);\n\n        Task<IEnumerable<TagDto>> GetAllTagsAsync(Guid businessId);\n\n        Task<bool> UpdateTagAsync(Guid businessId, Guid tagId, TagDto dto);\n\n        Task<bool> DeleteTagAsync(Guid businessId, Guid tagId);\n\n        // ‚úÖ Return bool so callers can know if assignment actually happened\n        Task<bool> AssignTagsAsync(Guid businessId, string phoneNumber, List<string> tagNames);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Mappers/NoteMapper.cs",
      "sha256": "3f51d3d0012825818ae828ab208605ea27dce968d81fbe8c5f213714573d1694",
      "language": "csharp",
      "size": 2363,
      "content": "using xbytechat.api.Features.CRM.Dtos;\nusing xbytechat.api.Features.CRM.Models;\n\nnamespace xbytechat.api.Features.CRM.Mappers\n{\n    public static class NoteMapper\n    {\n        public static NoteDto MapToDto(Note note)\n        {\n            return new NoteDto\n            {\n                Id = note.Id,\n                ContactId = note.ContactId,\n                Title = note.Title ?? string.Empty,\n                Content = note.Content ?? string.Empty,\n                Source = note.Source ?? string.Empty,\n                CreatedBy = note.CreatedBy ?? string.Empty,\n                IsPinned = note.IsPinned,\n                IsInternal = note.IsInternal,\n                CreatedAt = note.CreatedAt,\n                EditedAt = note.EditedAt\n            };\n        }\n\n        public static Note MapToEntity(NoteDto dto, Guid businessId)\n        {\n            var content = (dto.Content ?? string.Empty).Trim();\n            var title = NormalizeTitle(dto.Title, content);\n\n            return new Note\n            {\n                Id = Guid.NewGuid(),\n                BusinessId = businessId,\n                ContactId = dto.ContactId,\n\n                // ‚úÖ Title is optional, derived from content if missing\n                Title = title,\n\n                // ‚úÖ Content is the real payload\n                Content = content,\n\n                // ‚úÖ Defaults to keep DB safe even if frontend sends null/empty\n                Source = string.IsNullOrWhiteSpace(dto.Source) ? \"Manual\" : dto.Source.Trim(),\n                CreatedBy = string.IsNullOrWhiteSpace(dto.CreatedBy) ? \"System\" : dto.CreatedBy.Trim(),\n\n                IsPinned = dto.IsPinned,\n                IsInternal = dto.IsInternal,\n\n                CreatedAt = DateTime.SpecifyKind(DateTime.UtcNow, DateTimeKind.Utc),\n                EditedAt = null\n            };\n        }\n\n        private static string NormalizeTitle(string? title, string content)\n        {\n            var t = (title ?? string.Empty).Trim();\n            if (!string.IsNullOrWhiteSpace(t)) return t;\n\n            // derive title from content\n            var c = (content ?? string.Empty).Trim();\n            if (string.IsNullOrWhiteSpace(c)) return \"(Untitled)\"; // service already blocks empty content\n\n            const int max = 60;\n            return c.Length <= max ? c : (c.Substring(0, max) + \"‚Ä¶\");\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Mappers/ReminderMapper.cs",
      "sha256": "ca8d8fdc52f0d1f3cd2c7bc1de28d88ed5193a5407283690f942f1cb9fe0fbeb",
      "language": "csharp",
      "size": 1009,
      "content": "using xbytechat.api.Features.CRM.Dtos;\nusing xbytechat.api.Features.CRM.Models;\n\nnamespace xbytechat.api.Features.CRM.Mappers\n{\n    public static class ReminderMapper\n    {\n        public static ReminderDto MapToDto(Reminder r)\n        {\n            return new ReminderDto\n            {\n                Id = r.Id,\n                ContactId = r.ContactId,\n                Title = r.Title,\n                Description = r.Description,\n                DueAt = r.DueAt,\n                Status = r.Status,\n                ReminderType = r.ReminderType,\n                Priority = r.Priority,\n                IsRecurring = r.IsRecurring,\n                RecurrencePattern = r.RecurrencePattern,\n                SendWhatsappNotification = r.SendWhatsappNotification,\n                LinkedCampaign = r.LinkedCampaign,\n                IsActive = r.IsActive,\n                CreatedAt = r.CreatedAt,\n                UpdatedAt = r.UpdatedAt,\n                CompletedAt = r.CompletedAt\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Models/Contact.cs",
      "sha256": "c937e665a05520a22229847b576b0db8d3668b905487f3e28f1adfc1e27c3649",
      "language": "csharp",
      "size": 3559,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.ComponentModel.DataAnnotations;\nusing xbytechat.api.Features.BusinessModule.Models;\n\nnamespace xbytechat.api.Features.CRM.Models\n{\n    public enum ContactOptStatus\n    {\n        Unspecified = 0,\n        OptedIn = 1,\n        OptedOut = 2\n    }\n\n    public enum ContactChannelStatus\n    {\n        Valid = 0,\n        BlockedByUser = 1,\n        InvalidNumber = 2\n    }\n\n    public class Contact\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        [Required]\n        public Guid BusinessId { get; set; }\n        public Business Business { get; set; } = null!;\n        // üîó FK to Business\n        [Required]\n        [MaxLength(100)]\n        public string Name { get; set; } = null!;\n\n        [Required]\n        [MaxLength(20)]\n        public string PhoneNumber { get; set; } = null!;\n\n        [MaxLength(100)]\n        public string? Email { get; set; }\n\n        [MaxLength(50)]\n        public string? LeadSource { get; set; }\n\n        [MaxLength(200)]\n        public string? Tags { get; set; } // Legacy, will be deprecated after ContactTag rollout\n\n        public DateTime? LastContactedAt { get; set; }\n        public DateTime? NextFollowUpAt { get; set; }\n\n        [MaxLength(500)]\n        public string? Notes { get; set; }\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n        // üß© NEW: Link to Tags\n        public ICollection<ContactTag> ContactTags { get; set; } = new List<ContactTag>();\n        // ‚úÖ New: Navigation property for many-to-many tags\n        //public ICollection<ContactTag> TagsLink { get; set; } = new List<ContactTag>();\n\n        public DateTime? LastCTAInteraction { get; set; }\n        public string? LastCTAType { get; set; }\n        public Guid? LastClickedProductId { get; set; }\n\n        // üö¶ If true, skip automation flows (manually or programmatically paused)\n        public bool IsAutomationPaused { get; set; } = false;\n\n        // üë§ If agent assigned, automation should pause (runtime check)\n        public Guid? AssignedAgentId { get; set; }\n\n        // --- Chat Inbox fields ---\n        [MaxLength(20)]\n        public string InboxStatus { get; set; } = \"Open\"; // Open / Pending / Closed\n\n        public DateTime? LastInboundAt { get; set; }   // UTC\n        public DateTime? LastOutboundAt { get; set; }  // UTC\n\n        // Hard consent state used to gate outbound sends.\n        public ContactOptStatus OptStatus { get; set; } = ContactOptStatus.Unspecified;\n\n        // Channel delivery health state for this contact number.\n        public ContactChannelStatus ChannelStatus { get; set; } = ContactChannelStatus.Valid;\n\n        // UTC timestamp for the last change to OptStatus.\n        public DateTime? OptStatusUpdatedAt { get; set; }\n\n        // UTC timestamp for the last change to ChannelStatus.\n        public DateTime? ChannelStatusUpdatedAt { get; set; }\n\n        // Human-readable reason when contact is opted out.\n        public string? OptOutReason { get; set; }\n\n        public bool IsFavorite { get; set; } = false;\n        public bool IsArchived { get; set; } = false;\n        public string? Group { get; set; }\n        public bool IsActive { get; set; } = true;\n\n\n        //public bool IsTemporary { get; set; } = false;\n        //public Guid? SourceCampaignId { get; set; }\n        //public DateTime? ExpiresAt { get; set; }\n\n        public string? ProfileName { get; set; }            // latest WA profile.name we saw inbound\n        public DateTime? ProfileNameUpdatedAt { get; set; }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Models/ContactTag.cs",
      "sha256": "de88c1bdb0a34e2703e0bb2d9c83c80f2d4af9f2c008e11782fa4949ae0dc782",
      "language": "csharp",
      "size": 510,
      "content": "using System.ComponentModel.DataAnnotations;\nusing xbytechat.api.Features.CRM.Models;\n\npublic class ContactTag\n{\n    [Key]\n    public Guid Id { get; set; }\n\n    [Required]\n    public Guid ContactId { get; set; }\n\n    public Contact Contact { get; set; }\n\n    [Required]\n    public Guid TagId { get; set; }\n\n    public Tag Tag { get; set; }\n\n    [Required]\n    public Guid BusinessId { get; set; }\n\n    public DateTime AssignedAt { get; set; } = DateTime.UtcNow;\n\n    public string? AssignedBy { get; set; }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Models/Note.cs",
      "sha256": "00b6b2dacb3efff3e8043beb4d763a5e8196378a60d699f59f0253b718c6d65d",
      "language": "csharp",
      "size": 923,
      "content": "namespace xbytechat.api.Features.CRM.Models\n{\n    public class Note\n    {\n        public Guid Id { get; set; }\n\n        // üîó Ownership & Association\n        public Guid? BusinessId { get; set; }\n        public Guid? ContactId { get; set; }\n\n        // üìù Core Content\n        public string Title { get; set; } // Optional short title (for pinning or preview)\n        public string Content { get; set; }\n\n        // üîñ Contextual Intelligence\n        public string Source { get; set; } // e.g., \"Manual\", \"Call Log\", \"WhatsApp\", \"LeadForm\"\n        public string CreatedBy { get; set; } // Store agent/user name or userId\n\n        // üìå UX Flags\n        public bool IsPinned { get; set; } = false;\n        public bool IsInternal { get; set; } = false; // if true, only visible to team\n\n        // üïì Timestamps\n        public DateTime CreatedAt { get; set; }\n        public DateTime? EditedAt { get; set; }\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/CRM/Models/Reminder.cs",
      "sha256": "fc98f9aad251b376a21b81c2984660a17369d962f22e44a6fdc4b404508542c1",
      "language": "csharp",
      "size": 1728,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CRM.Models\n{\n    public class Reminder\n    {\n        public Guid Id { get; set; }\n\n        public Guid BusinessId { get; set; }   // For multi-tenant isolation\n\n        public Guid ContactId { get; set; }    // Which contact this reminder is for\n\n        public string Title { get; set; } = default!; // Main reminder title (e.g., \"Call back about invoice\")\n\n        public string? Description { get; set; } // Longer notes, optional (for internal detail)\n\n        public DateTime DueAt { get; set; }    // When reminder should notify\n\n        public string Status { get; set; } = \"Pending\"; // \"Pending\", \"Done\", \"Overdue\"\n\n        public string? ReminderType { get; set; } // e.g., \"Call\", \"Email\", \"Follow-up\", \"Meeting\"\n\n        public int? Priority { get; set; } // e.g., 1 (High), 2 (Medium), 3 (Low)\n\n        public bool IsRecurring { get; set; } = false; // For future ‚Üí repeat reminder\n\n        public string? RecurrencePattern { get; set; } // e.g., \"Weekly\", \"Monthly\" (optional)\n\n        public bool SendWhatsappNotification { get; set; } = false; // Future: auto-WA message trigger\n\n        public string? LinkedCampaign { get; set; } // Optional: which campaign this reminder relates to\n\n        public bool IsActive { get; set; } = true;  // Soft delete support\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n        public DateTime? UpdatedAt { get; set; }\n\n        public DateTime? CompletedAt { get; set; } // Track when it was marked Done\n\n        public string? LastCTAType { get; set; } // e.g., Confirm, Reschedule\n        public DateTime? LastClickedAt { get; set; }\n        public bool FollowUpSent { get; set; } = false;\n\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Models/Tag.cs",
      "sha256": "387b3c7cd221661c2ced818b097b3a5cc250067db94531b997e4ed61f1e43e35",
      "language": "csharp",
      "size": 1117,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.CRM.Models\n{\n    public class Tag\n    {\n        public Guid Id { get; set; }\n\n        public Guid BusinessId { get; set; }             // Multi-tenant isolation\n\n        public string Name { get; set; } = default!;     // e.g., \"VIP\", \"Follow-up\"\n\n        public string? ColorHex { get; set; }            // For UI tag styling (e.g., #FF5733)\n\n        public string? Category { get; set; }            // e.g., \"Priority\", \"Campaign\", \"Stage\"\n\n        public string? Notes { get; set; }               // Admin/internal notes about this tag\n\n        public bool IsSystemTag { get; set; } = false;   // Reserved tags like \"New\", \"Subscribed\"\n\n        public bool IsActive { get; set; } = true;       // For soft-deactivation (future bulk ops)\n\n        public DateTime CreatedAt { get; set; }          // For analytics / sorting\n\n        public DateTime? LastUsedAt { get; set; }        // Useful for CRM insights later\n\n        public ICollection<ContactTag> ContactTags { get; set; } = new List<ContactTag>(); // Linked contacts\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Services/ContactProfileService.cs",
      "sha256": "a4dbe66bed0c345a7d9bca4860023d2ad35be6a378b62ba5affb4f28ee1493b5",
      "language": "csharp",
      "size": 3367,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Features.CRM.Models;\n\nnamespace xbytechat.api.Features.CRM.Services\n{\n    public sealed class ContactProfileService : IContactProfileService\n    {\n        private readonly AppDbContext _db;\n\n        public ContactProfileService(AppDbContext db) => _db = db;\n\n        public async Task UpsertProfileNameAsync(\n            Guid businessId,\n            string phoneE164,\n            string? profileName,\n            CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty || string.IsNullOrWhiteSpace(phoneE164) || string.IsNullOrWhiteSpace(profileName))\n                return;\n\n            var phoneDigits = PhoneNumberNormalizer.NormalizeToE164Digits(phoneE164, \"IN\");\n            if (string.IsNullOrWhiteSpace(phoneDigits))\n                return;\n\n            var newName = profileName.Trim();\n            var now = DateTime.UtcNow;\n\n            // Canonical lookup: digits-only E.164 (no '+')\n            var contact = await _db.Contacts.FirstOrDefaultAsync(\n                c => c.BusinessId == businessId &&\n                     c.PhoneNumber == phoneDigits,\n                ct);\n\n            if (contact == null)\n            {\n                // Concurrency-safe create\n                try\n                {\n                    _db.Contacts.Add(new Contact\n                    {\n                        Id = Guid.NewGuid(),\n                        BusinessId = businessId,\n                        PhoneNumber = phoneDigits,          // canonical = digits-only\n                        Name = newName,                     // display fallback\n                        ProfileName = newName,              // WA profile name\n                        ProfileNameUpdatedAt = now,\n                        CreatedAt = now,\n                        LastContactedAt = now\n                    });\n                    await _db.SaveChangesAsync(ct);\n                    return;\n                }\n                catch (DbUpdateException)\n                {\n                    // Someone else created it ‚Äî refetch and continue as update\n                    contact = await _db.Contacts.FirstOrDefaultAsync(\n                        c => c.BusinessId == businessId && c.PhoneNumber == phoneDigits, ct);\n                    if (contact == null) return;\n                }\n            }\n\n            var anyChange = false;\n\n            if (!string.Equals(contact.ProfileName, newName, StringComparison.Ordinal))\n            {\n                contact.ProfileName = newName;\n                contact.ProfileNameUpdatedAt = now;\n                anyChange = true;\n            }\n\n            // Backfill Name if empty/placeholder/phone\n            if (string.IsNullOrWhiteSpace(contact.Name) ||\n                contact.Name == \"WhatsApp User\" ||\n                contact.Name == contact.PhoneNumber)\n            {\n                if (!string.Equals(contact.Name, newName, StringComparison.Ordinal))\n                {\n                    contact.Name = newName;\n                    anyChange = true;\n                }\n            }\n\n            if (anyChange)\n            {\n                contact.ProfileNameUpdatedAt = now;\n                await _db.SaveChangesAsync(ct);\n            }\n        }\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Services/ContactService.cs",
      "sha256": "b0dfcf05efc0ced296125b4695cc30a6e4bb9e6c559f4f4f3c52f933a33ed598",
      "language": "csharp",
      "size": 31340,
      "content": "// üìÑ File: xbytechat-api/Features/CRM/Services/ContactService.cs\n\nusing System.ComponentModel.DataAnnotations;\nusing System.Globalization;\nusing CsvHelper;\nusing CsvHelper.Configuration;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.CRM.Dtos;\nusing xbytechat.api.Features.CRM.Interfaces;\nusing xbytechat.api.Features.CRM.Models;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.CRM.Services\n{\n    public class ContactService : IContactService\n    {\n        private readonly AppDbContext _db;\n        private readonly ILogger<ContactService> _logger;\n\n        public ContactService(AppDbContext db, ILogger<ContactService> logger)\n        {\n            _db = db;\n            _logger = logger;\n        }\n\n        public async Task<ResponseResult> AddContactAsync(Guid businessId, ContactDto dto)\n        {\n            _logger.LogInformation(\"üì© AddContactAsync called for businessId={BusinessId}, Name={Name}\", businessId, dto.Name);\n\n            try\n            {\n                var normalizedPhone = NormalizePhone(dto.PhoneNumber);\n\n                if (string.IsNullOrWhiteSpace(normalizedPhone))\n                    return ResponseResult.ErrorInfo(\"‚ùå Phone number is invalid. Please enter a valid number.\");\n\n                var existingContact = await FindContactByPhoneAsync(businessId, normalizedPhone);\n\n                if (existingContact != null)\n                {\n                    _logger.LogWarning(\"‚ö†Ô∏è Duplicate contact attempt for phone {Phone}\", dto.PhoneNumber);\n                    return ResponseResult.ErrorInfo($\"‚ùå A contact with the phone number '{dto.PhoneNumber}' already exists.\");\n                }\n\n                var contact = new Contact\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    Name = dto.Name,\n                    PhoneNumber = normalizedPhone, // ‚úÖ canonical digits-only\n                    Email = dto.Email,\n                    LeadSource = dto.LeadSource,\n                    LastContactedAt = dto.LastContactedAt?.ToUniversalTime(),\n                    NextFollowUpAt = dto.NextFollowUpAt?.ToUniversalTime(),\n                    Notes = dto.Notes,\n                    CreatedAt = DateTime.UtcNow,\n                    IsFavorite = dto.IsFavorite,\n                    IsArchived = dto.IsArchived,\n                    Group = dto.Group\n                };\n\n                if (dto.Tags != null && dto.Tags.Any())\n                {\n                    contact.ContactTags = dto.Tags.Select(t => new ContactTag\n                    {\n                        Id = Guid.NewGuid(),\n                        ContactId = contact.Id,\n                        TagId = t.TagId,\n                        BusinessId = businessId,\n                        AssignedAt = DateTime.UtcNow,\n                        AssignedBy = \"system\"\n                    }).ToList();\n                }\n\n                _db.Contacts.Add(contact);\n                await _db.SaveChangesAsync();\n\n                _logger.LogInformation(\"‚úÖ Contact added successfully: {ContactId}\", contact.Id);\n\n                var resultDto = new ContactDto\n                {\n                    Id = contact.Id,\n                    Name = contact.Name,\n                    PhoneNumber = contact.PhoneNumber,\n                    Email = contact.Email,\n                    LeadSource = contact.LeadSource,\n                    CreatedAt = contact.CreatedAt,\n                    Tags = contact.ContactTags?.Select(ct => new ContactTagDto { TagId = ct.TagId }).ToList() ?? new List<ContactTagDto>()\n                };\n\n                return ResponseResult.SuccessInfo(\"‚úÖ Contact created successfully.\", resultDto);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"üö® Unexpected error in AddContactAsync for business {BusinessId}\", businessId);\n                return ResponseResult.ErrorInfo(\"üö® A server error occurred while creating the contact.\", ex.Message);\n            }\n        }\n\n        public async Task<ContactDto> GetContactByIdAsync(Guid businessId, Guid contactId)\n        {\n            _logger.LogInformation(\"GetContactByIdAsync: businessId={BusinessId}, contactId={ContactId}\", businessId, contactId);\n\n            var contact = await _db.Contacts\n                .Where(c => c.BusinessId == businessId && c.Id == contactId && c.IsActive)\n                .Include(c => c.ContactTags)\n                    .ThenInclude(ct => ct.Tag)\n                .FirstOrDefaultAsync();\n\n            if (contact == null)\n                return null;\n\n            return new ContactDto\n            {\n                Id = contact.Id,\n                Name = contact.Name,\n                PhoneNumber = contact.PhoneNumber,\n                Email = contact.Email,\n                LeadSource = contact.LeadSource,\n                LastContactedAt = contact.LastContactedAt,\n                NextFollowUpAt = contact.NextFollowUpAt,\n                Notes = contact.Notes,\n                CreatedAt = contact.CreatedAt,\n                Tags = contact.ContactTags?\n                    .Where(ct => ct.Tag != null)\n                    .Select(ct => new ContactTagDto\n                    {\n                        TagId = ct.TagId,\n                        TagName = ct.Tag.Name\n                    })\n                    .ToList() ?? new List<ContactTagDto>()\n            };\n        }\n\n        public async Task<bool> UpdateContactAsync(Guid businessId, ContactDto dto)\n        {\n            _logger.LogInformation(\"UpdateContactAsync: businessId={BusinessId}, contactId={ContactId}\", businessId, dto.Id);\n\n            var contact = await _db.Contacts\n                .Include(c => c.ContactTags)\n                .FirstOrDefaultAsync(c => c.BusinessId == businessId && c.Id == dto.Id);\n\n            if (contact == null)\n                return false;\n\n            contact.Name = dto.Name;\n\n            var normalizedPhone = NormalizePhone(dto.PhoneNumber);\n            if (string.IsNullOrWhiteSpace(normalizedPhone))\n                throw new ArgumentException(\"Invalid phone number. Use E.164 digits-only (country code + number).\");\n\n            var lookupCandidates = BuildPhoneLookupCandidates(normalizedPhone);\n            var phoneExists = lookupCandidates.Count > 0 && await _db.Contacts.AnyAsync(c =>\n                c.BusinessId == businessId &&\n                c.Id != dto.Id &&\n                lookupCandidates.Contains(c.PhoneNumber));\n\n            if (phoneExists)\n                throw new ArgumentException(\"A contact with this phone number already exists.\");\n\n            contact.PhoneNumber = normalizedPhone;\n            contact.Email = dto.Email;\n            contact.LeadSource = dto.LeadSource;\n            contact.LastContactedAt = dto.LastContactedAt?.ToUniversalTime();\n            contact.NextFollowUpAt = dto.NextFollowUpAt?.ToUniversalTime();\n            contact.Notes = dto.Notes;\n\n            await _db.SaveChangesAsync();\n            return true;\n        }\n\n        public async Task<bool> DeleteContactAsync(Guid businessId, Guid contactId)\n        {\n            var contact = await _db.Contacts\n                .FirstOrDefaultAsync(c => c.BusinessId == businessId && c.Id == contactId && c.IsActive);\n\n            if (contact == null)\n                return false;\n\n            contact.IsActive = false;\n            await _db.SaveChangesAsync();\n            return true;\n        }\n\n        public async Task<CsvImportResult<ContactDto>> ParseCsvToContactsAsync(Guid businessId, Stream csvStream)\n        {\n            _logger.LogInformation(\"ParseCsvToContactsAsync: businessId={BusinessId}\", businessId);\n\n            var result = new CsvImportResult<ContactDto>();\n\n            var config = new CsvConfiguration(CultureInfo.InvariantCulture)\n            {\n                HeaderValidated = null,\n                MissingFieldFound = null,\n                BadDataFound = null,\n                PrepareHeaderForMatch = args =>\n                    (args.Header ?? string.Empty)\n                        .Trim()\n                        .Replace(\" \", \"\")\n                        .Replace(\"_\", \"\")\n                        .ToLowerInvariant()\n            };\n\n            using var reader = new StreamReader(csvStream);\n            using var csv = new CsvReader(reader, config);\n\n            csv.Context.RegisterClassMap<ContactDtoCsvMap>();\n\n            int rowNumber = 1;\n\n            await csv.ReadAsync();\n            csv.ReadHeader();\n\n            while (await csv.ReadAsync())\n            {\n                rowNumber++;\n                try\n                {\n                    var record = csv.GetRecord<ContactDto>();\n\n                    // ‚úÖ Normalize phone even during parse (so user sees what will be saved)\n                    var normalized = NormalizePhone(record.PhoneNumber);\n                    if (string.IsNullOrWhiteSpace(normalized))\n                    {\n                        result.Errors.Add(new CsvImportError\n                        {\n                            RowNumber = rowNumber,\n                            ErrorMessage = \"Invalid phone number (could not normalize to E.164 digits-only).\"\n                        });\n                        continue;\n                    }\n\n                    record.PhoneNumber = normalized;\n                    record.CreatedAt = DateTime.UtcNow;\n\n                    result.SuccessRecords.Add(record);\n                }\n                catch (Exception ex)\n                {\n                    result.Errors.Add(new CsvImportError\n                    {\n                        RowNumber = rowNumber,\n                        ErrorMessage = ex.Message\n                    });\n                }\n            }\n\n            return result;\n        }\n\n        private static string NormalizePhone(string phoneNumber)\n        {\n            var raw = (phoneNumber ?? string.Empty).Trim();\n            if (string.IsNullOrWhiteSpace(raw))\n                return string.Empty;\n\n            // First pass: normal parser behavior (local + international supported).\n            var normalized = PhoneNumberNormalizer.NormalizeToE164Digits(raw, \"IN\");\n            if (!string.IsNullOrWhiteSpace(normalized))\n                return normalized;\n\n            // Second pass: webhook and provider payloads often send E.164 digits without '+'.\n            var digits = new string(raw.Where(char.IsDigit).ToArray());\n            if (string.IsNullOrWhiteSpace(digits))\n                return string.Empty;\n\n            normalized = PhoneNumberNormalizer.NormalizeToE164Digits(\"+\" + digits, \"IN\");\n            if (!string.IsNullOrWhiteSpace(normalized))\n                return normalized;\n\n            // Do not store ambiguous values; force parseable canonical format.\n            return string.Empty;\n        }\n\n        private static List<string> BuildPhoneLookupCandidates(string phoneNumber)\n        {\n            var raw = (phoneNumber ?? string.Empty).Trim();\n            var candidates = new HashSet<string>(StringComparer.Ordinal);\n            var normalized = NormalizePhone(raw);\n            var digitsOnly = new string(raw.Where(char.IsDigit).ToArray());\n\n            if (!string.IsNullOrWhiteSpace(normalized))\n            {\n                candidates.Add(normalized);\n                candidates.Add(\"+\" + normalized);\n\n                // Legacy IN rows may have been stored as 10-digit local numbers.\n                if (normalized.Length == 12 && normalized.StartsWith(\"91\", StringComparison.Ordinal))\n                    candidates.Add(normalized.Substring(2));\n            }\n\n            if (!string.IsNullOrWhiteSpace(digitsOnly))\n            {\n                candidates.Add(digitsOnly);\n                candidates.Add(\"+\" + digitsOnly);\n\n                if (digitsOnly.Length == 10)\n                {\n                    candidates.Add(\"91\" + digitsOnly);\n                    candidates.Add(\"+91\" + digitsOnly);\n                }\n                else if (digitsOnly.Length == 12 && digitsOnly.StartsWith(\"91\", StringComparison.Ordinal))\n                {\n                    candidates.Add(digitsOnly.Substring(2));\n                }\n            }\n\n            if (!string.IsNullOrWhiteSpace(raw))\n                candidates.Add(raw);\n\n            return candidates.Where(x => !string.IsNullOrWhiteSpace(x)).ToList();\n        }\n\n        private async Task<Contact?> FindContactByPhoneAsync(Guid businessId, string phoneNumber)\n        {\n            var lookupCandidates = BuildPhoneLookupCandidates(phoneNumber);\n            if (lookupCandidates.Count == 0)\n                return null;\n\n            return await _db.Contacts\n                .Where(c => c.BusinessId == businessId && lookupCandidates.Contains(c.PhoneNumber))\n                .OrderByDescending(c => c.IsActive)\n                .ThenByDescending(c => c.CreatedAt)\n                .FirstOrDefaultAsync();\n        }\n\n        public async Task<Contact> FindOrCreateAsync(Guid businessId, string phoneNumber)\n        {\n            var normalized = NormalizePhone(phoneNumber);\n            if (string.IsNullOrWhiteSpace(normalized))\n                throw new ArgumentException(\"Invalid phone number format.\", nameof(phoneNumber));\n\n            var contact = await FindContactByPhoneAsync(businessId, normalized);\n\n            if (contact != null)\n            {\n                // Opportunistically backfill legacy rows to canonical digits-only storage.\n                if (!string.Equals(contact.PhoneNumber, normalized, StringComparison.Ordinal))\n                {\n                    var canonicalAlreadyExists = await _db.Contacts.AnyAsync(c =>\n                        c.BusinessId == businessId &&\n                        c.Id != contact.Id &&\n                        c.PhoneNumber == normalized);\n\n                    if (!canonicalAlreadyExists)\n                    {\n                        contact.PhoneNumber = normalized;\n                        await _db.SaveChangesAsync();\n                    }\n                }\n\n                return contact;\n            }\n\n            var newContact = new Contact\n            {\n                Id = Guid.NewGuid(),\n                BusinessId = businessId,\n                Name = \"WhatsApp User\",\n                PhoneNumber = normalized,\n                CreatedAt = DateTime.UtcNow\n            };\n\n            _db.Contacts.Add(newContact);\n            await _db.SaveChangesAsync();\n            return newContact;\n        }\n\n        public async Task<bool> ToggleFavoriteAsync(Guid businessId, Guid contactId)\n        {\n            var contact = await _db.Contacts.FirstOrDefaultAsync(c => c.BusinessId == businessId && c.Id == contactId);\n            if (contact == null) return false;\n\n            contact.IsFavorite = !contact.IsFavorite;\n            await _db.SaveChangesAsync();\n            return true;\n        }\n\n        public async Task AssignTagToContactsAsync(Guid businessId, List<Guid> contactIds, Guid tagId)\n        {\n            var contacts = await _db.Contacts\n                .Where(c => c.BusinessId == businessId && contactIds.Contains(c.Id))\n                .Include(c => c.ContactTags)\n                .ToListAsync();\n\n            foreach (var contact in contacts)\n            {\n                bool alreadyAssigned = contact.ContactTags.Any(link => link.TagId == tagId);\n                if (!alreadyAssigned)\n                {\n                    contact.ContactTags.Add(new ContactTag\n                    {\n                        ContactId = contact.Id,\n                        TagId = tagId\n                    });\n                }\n            }\n\n            await _db.SaveChangesAsync();\n        }\n\n        public async Task<bool> ToggleArchiveAsync(Guid businessId, Guid contactId)\n        {\n            var contact = await _db.Contacts.FirstOrDefaultAsync(c => c.BusinessId == businessId && c.Id == contactId);\n            if (contact == null) return false;\n\n            contact.IsArchived = !contact.IsArchived;\n            await _db.SaveChangesAsync();\n            return true;\n        }\n\n        public async Task<IEnumerable<ContactDto>> GetAllContactsAsync(Guid businessId, string? tab = \"all\")\n        {\n            var baseQuery = _db.Contacts\n                .Where(c => c.BusinessId == businessId && c.IsActive);\n\n            if (tab == \"favourites\")\n                baseQuery = baseQuery.Where(c => c.IsFavorite);\n            else if (tab == \"archived\")\n                baseQuery = baseQuery.Where(c => c.IsArchived);\n            else if (tab == \"groups\")\n                baseQuery = baseQuery.Where(c => !string.IsNullOrEmpty(c.Group));\n\n            var contacts = await baseQuery\n                .Include(c => c.ContactTags)\n                    .ThenInclude(ct => ct.Tag)\n                .ToListAsync();\n\n            return contacts.Select(c => new ContactDto\n            {\n                Id = c.Id,\n                Name = c.Name,\n                PhoneNumber = c.PhoneNumber,\n                Email = c.Email,\n                LeadSource = c.LeadSource,\n                LastContactedAt = c.LastContactedAt,\n                NextFollowUpAt = c.NextFollowUpAt,\n                Notes = c.Notes,\n                CreatedAt = c.CreatedAt,\n                IsFavorite = c.IsFavorite,\n                IsArchived = c.IsArchived,\n                Group = c.Group,\n                Tags = c.ContactTags?\n                    .Where(ct => ct.Tag != null)\n                    .Select(ct => new ContactTagDto\n                    {\n                        TagId = ct.TagId,\n                        TagName = ct.Tag.Name,\n                        ColorHex = ct.Tag.ColorHex,\n                        Category = ct.Tag.Category\n                    })\n                    .ToList() ?? new List<ContactTagDto>()\n            });\n        }\n\n        public async Task<PagedResult<ContactDto>> GetPagedContactsAsync(Guid businessId, string? tab, int page, int pageSize, string? searchTerm)\n        {\n            if (page < 1) page = 1;\n            if (pageSize < 1) pageSize = 25;\n            if (pageSize > 100) pageSize = 100;\n\n            var baseQuery = _db.Contacts\n                .Where(c => c.BusinessId == businessId && c.IsActive);\n\n            if (string.IsNullOrWhiteSpace(tab) || tab == \"all\")\n                baseQuery = baseQuery.Where(c => !c.IsArchived);\n\n            if (tab == \"favourites\")\n                baseQuery = baseQuery.Where(c => c.IsFavorite);\n            else if (tab == \"archived\")\n                baseQuery = baseQuery.Where(c => c.IsArchived);\n            else if (tab == \"groups\")\n                baseQuery = baseQuery.Where(c => !string.IsNullOrEmpty(c.Group));\n\n            if (!string.IsNullOrWhiteSpace(searchTerm))\n            {\n                var term = searchTerm.Trim();\n                baseQuery = baseQuery.Where(c =>\n                    (c.Name != null && EF.Functions.Like(c.Name, $\"%{term}%\")) ||\n                    (c.PhoneNumber != null && EF.Functions.Like(c.PhoneNumber, $\"%{term}%\")) ||\n                    (c.Email != null && EF.Functions.Like(c.Email, $\"%{term}%\"))\n                );\n            }\n\n            var totalCount = await baseQuery.CountAsync();\n\n            var contacts = await baseQuery\n                .Include(c => c.ContactTags)\n                    .ThenInclude(ct => ct.Tag)\n                .OrderBy(c => c.Name)\n                .Skip((page - 1) * pageSize)\n                .Take(pageSize)\n                .ToListAsync();\n\n            var items = contacts.Select(c => new ContactDto\n            {\n                Id = c.Id,\n                Name = c.Name,\n                PhoneNumber = c.PhoneNumber,\n                Email = c.Email,\n                LeadSource = c.LeadSource,\n                LastContactedAt = c.LastContactedAt,\n                NextFollowUpAt = c.NextFollowUpAt,\n                Notes = c.Notes,\n                CreatedAt = c.CreatedAt,\n                IsFavorite = c.IsFavorite,\n                IsArchived = c.IsArchived,\n                Group = c.Group,\n                Tags = c.ContactTags?\n                    .Where(ct => ct.Tag != null)\n                    .Select(ct => new ContactTagDto\n                    {\n                        TagId = ct.TagId,\n                        TagName = ct.Tag.Name,\n                        ColorHex = ct.Tag.ColorHex,\n                        Category = ct.Tag.Category\n                    })\n                    .ToList() ?? new List<ContactTagDto>()\n            }).ToList();\n\n            return new PagedResult<ContactDto>\n            {\n                Items = items,\n                TotalCount = totalCount,\n                Page = page,\n                PageSize = pageSize\n            };\n        }\n\n        public async Task<IEnumerable<ContactDto>> GetContactsByTagsAsync(Guid businessId, List<Guid> tagIds)\n        {\n            var baseQuery = _db.Contacts\n                .Where(c => c.BusinessId == businessId && !c.IsArchived);\n\n            if (tagIds?.Any() == true)\n            {\n                baseQuery = baseQuery.Where(c => c.ContactTags.Any(ct => tagIds.Contains(ct.TagId)));\n            }\n\n            var contacts = await baseQuery\n                .Include(c => c.ContactTags)\n                    .ThenInclude(ct => ct.Tag)\n                .ToListAsync();\n\n            return contacts.Select(c => new ContactDto\n            {\n                Id = c.Id,\n                Name = c.Name,\n                PhoneNumber = c.PhoneNumber,\n                Tags = c.ContactTags.Select(ct => new ContactTagDto\n                {\n                    TagId = ct.Tag.Id,\n                    TagName = ct.Tag.Name,\n                    ColorHex = ct.Tag.ColorHex,\n                    Category = ct.Tag.Category\n                }).ToList()\n            });\n        }\n\n        public async Task<bool> AssignTagsAsync(Guid businessId, string phoneNumber, List<string> tags)\n        {\n            var normalizedPhone = NormalizePhone(phoneNumber);\n            if (string.IsNullOrWhiteSpace(normalizedPhone)) return false;\n            phoneNumber = normalizedPhone;\n\n            if (tags == null || tags.Count == 0)\n                return false;\n\n            var lookupCandidates = BuildPhoneLookupCandidates(normalizedPhone);\n            if (lookupCandidates.Count == 0)\n                return false;\n\n            var contact = await _db.Contacts\n                .FirstOrDefaultAsync(c =>\n                    c.BusinessId == businessId &&\n                    !c.IsArchived &&\n                    lookupCandidates.Contains(c.PhoneNumber));\n\n            if (contact == null)\n                return false;\n\n            foreach (var tagName in tags)\n            {\n                if (string.IsNullOrWhiteSpace(tagName))\n                    continue;\n\n                var cleanName = tagName.Trim();\n\n                var tag = await _db.Tags\n                    .FirstOrDefaultAsync(t => t.BusinessId == businessId && t.Name == cleanName && t.IsActive);\n\n                if (tag == null)\n                {\n                    tag = new Tag\n                    {\n                        Id = Guid.NewGuid(),\n                        BusinessId = businessId,\n                        Name = cleanName,\n                        ColorHex = \"#8c8c8c\",\n                        IsActive = true,\n                        CreatedAt = DateTime.UtcNow\n                    };\n                    _db.Tags.Add(tag);\n                }\n\n                var alreadyTagged = await _db.ContactTags.AnyAsync(ct =>\n                    ct.ContactId == contact.Id && ct.TagId == tag.Id);\n\n                if (!alreadyTagged)\n                {\n                    _db.ContactTags.Add(new ContactTag\n                    {\n                        Id = Guid.NewGuid(),\n                        ContactId = contact.Id,\n                        TagId = tag.Id\n                    });\n                }\n            }\n\n            await _db.SaveChangesAsync();\n            return true;\n        }\n\n\n\n        public async Task<BulkImportResultDto> BulkImportAsync(Guid businessId, Stream csvStream)\n        {\n            _logger.LogInformation(\"Bulk import started for businessId={BusinessId}\", businessId);\n\n            var result = new BulkImportResultDto();\n\n            var config = new CsvConfiguration(System.Globalization.CultureInfo.InvariantCulture)\n            {\n                HeaderValidated = null,\n                MissingFieldFound = null,\n                BadDataFound = null,\n                PrepareHeaderForMatch = args =>\n                    (args.Header ?? string.Empty)\n                        .Trim()\n                        .Replace(\" \", \"\")\n                        .Replace(\"_\", \"\")\n                        .ToLowerInvariant()\n            };\n\n            using var reader = new StreamReader(csvStream);\n            using var csv = new CsvReader(reader, config);\n\n            csv.Context.RegisterClassMap<ContactDtoCsvMap>();\n\n            await csv.ReadAsync();\n            csv.ReadHeader();\n\n            // Collect rows first so we can query DB only for relevant phones\n            var parsedRows = new List<(int Row, string Phone, string Name, string? Email, string? LeadSource, string? Notes)>();\n            var seenInFile = new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n\n            int row = 1;\n\n            while (await csv.ReadAsync())\n            {\n                row++;\n                try\n                {\n                    var dto = csv.GetRecord<ContactDto>();\n\n                    var name = (dto.Name ?? string.Empty).Trim();\n                    if (string.IsNullOrWhiteSpace(name))\n                    {\n                        result.Errors.Add(new CsvImportError { RowNumber = row, ErrorMessage = \"Name is required.\" });\n                        continue;\n                    }\n\n                    // Canonical normalize: digits-only E.164 (no '+')\n                    var normalizedPhone = PhoneNumberNormalizer.NormalizeToE164Digits(dto.PhoneNumber, \"IN\");\n                    if (string.IsNullOrWhiteSpace(normalizedPhone))\n                    {\n                        result.Errors.Add(new CsvImportError { RowNumber = row, ErrorMessage = $\"Invalid phone number: '{dto.PhoneNumber}'\" });\n                        continue;\n                    }\n\n                    // Dedupe within the CSV\n                    if (!seenInFile.Add(normalizedPhone))\n                    {\n                        result.DuplicatesInFile++;\n                        continue;\n                    }\n\n                    var email = string.IsNullOrWhiteSpace(dto.Email) ? null : dto.Email.Trim();\n                    if (!string.IsNullOrWhiteSpace(email) && !IsValidEmail(email))\n                    {\n                        result.Errors.Add(new CsvImportError { RowNumber = row, ErrorMessage = $\"Invalid email: '{dto.Email}'\" });\n                        continue;\n                    }\n\n                    parsedRows.Add((\n                        Row: row,\n                        Phone: normalizedPhone,\n                        Name: name,\n                        Email: email,\n                        LeadSource: string.IsNullOrWhiteSpace(dto.LeadSource) ? null : dto.LeadSource.Trim(),\n                        Notes: string.IsNullOrWhiteSpace(dto.Notes) ? null : dto.Notes.Trim()\n                    ));\n                }\n                catch (Exception ex)\n                {\n                    _logger.LogWarning(ex, \"CSV parsing error at row {Row}\", row);\n                    result.Errors.Add(new CsvImportError { RowNumber = row, ErrorMessage = $\"Parse error: {ex.Message}\" });\n                }\n            }\n\n            if (parsedRows.Count == 0)\n            {\n                _logger.LogInformation(\"Bulk import done. businessId={BusinessId}, nothing to import.\", businessId);\n                return result;\n            }\n\n            var phones = parsedRows.Select(x => x.Phone).Distinct(StringComparer.OrdinalIgnoreCase).ToList();\n\n            // Fetch *all* matching contacts (including soft-deleted) for restore logic\n            var existingContacts = await _db.Contacts\n                .Where(c => c.BusinessId == businessId && phones.Contains(c.PhoneNumber))\n                .ToListAsync();\n\n            var existingByPhone = existingContacts\n                .GroupBy(c => c.PhoneNumber, StringComparer.OrdinalIgnoreCase)\n                .ToDictionary(\n                    g => g.Key,\n                    g => g.OrderByDescending(x => x.IsActive).ThenByDescending(x => x.CreatedAt).First(),\n                    StringComparer.OrdinalIgnoreCase\n                );\n\n            var toInsert = new List<Contact>();\n\n            foreach (var r in parsedRows)\n            {\n                if (existingByPhone.TryGetValue(r.Phone, out var existing))\n                {\n                    // Policy:\n                    // - Active -> skip\n                    // - Soft-deleted (IsActive=false) -> restore\n                    // - Archived -> skip (treat as existing)\n                    if (existing.IsArchived)\n                    {\n                        result.SkippedExisting++;\n                        continue;\n                    }\n\n                    if (existing.IsActive)\n                    {\n                        result.SkippedExisting++;\n                        continue;\n                    }\n\n                    // ‚úÖ Restore soft-deleted\n                    existing.IsActive = true;\n                    existing.IsArchived = false;\n\n                    // Update fields (safe updates: only overwrite when CSV provides data)\n                    existing.Name = r.Name;\n                    if (!string.IsNullOrWhiteSpace(r.Email)) existing.Email = r.Email;\n                    if (!string.IsNullOrWhiteSpace(r.LeadSource)) existing.LeadSource = r.LeadSource;\n                    if (!string.IsNullOrWhiteSpace(r.Notes)) existing.Notes = r.Notes;\n\n                    result.Restored++;\n                    continue;\n                }\n\n                // Brand-new insert\n                toInsert.Add(new Contact\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    Name = r.Name,\n                    PhoneNumber = r.Phone,\n                    Email = r.Email,\n                    LeadSource = r.LeadSource,\n                    Notes = r.Notes,\n                    IsActive = true,\n                    IsArchived = false,\n                    CreatedAt = DateTime.UtcNow\n                });\n            }\n\n            if (toInsert.Count > 0)\n            {\n                _db.Contacts.AddRange(toInsert);\n            }\n\n            await _db.SaveChangesAsync();\n\n            result.Imported = toInsert.Count;\n\n            _logger.LogInformation(\n                \"Bulk import done. businessId={BusinessId}, imported={Imported}, restored={Restored}, skippedExisting={SkippedExisting}, dupInFile={DupInFile}, errors={Errors}\",\n                businessId, result.Imported, result.Restored, result.SkippedExisting, result.DuplicatesInFile, result.Errors.Count\n            );\n\n            return result;\n\n            static bool IsValidEmail(string email)\n            {\n                // EmailAddressAttribute is good enough for MVP validation\n                return new EmailAddressAttribute().IsValid(email);\n            }\n        }\n\n\n    }\n}\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Services/ContactSummaryService.cs",
      "sha256": "9e617711dc057302ba7f05b37bc2c6d11eb2fb1ce8370e2f1fa2ec40c48a9080",
      "language": "csharp",
      "size": 4320,
      "content": "// üìÑ xbytechat-api/Features/CRM/Summary/Services/ContactSummaryService.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CRM.Dtos;\nusing xbytechat.api.Features.CRM.Interfaces;\nusing xbytechat.api.Features.CRM.Timelines.DTOs;\nusing xbytechat.api.Features.CRM.Timelines.Mappers;\nusing xbytechat.api.Features.CRM.Timelines.Services;\n\nnamespace xbytechat.api.Features.CRM.Services\n{\n    /// <summary>\n    /// Default implementation of IContactSummaryService.\n    /// Orchestrates calls into existing CRM services and returns\n    /// a single response model tailored for UI consumption.\n    /// </summary>\n    public sealed class ContactSummaryService : IContactSummaryService\n    {\n        private readonly IContactService _contactService;\n        private readonly INoteService _noteService;\n        private readonly IReminderService _reminderService;\n        private readonly ILeadTimelineService _leadTimelineService;\n\n        public ContactSummaryService(\n            IContactService contactService,\n            INoteService noteService,\n            IReminderService reminderService,\n            ILeadTimelineService leadTimelineService)\n        {\n            _contactService = contactService ?? throw new ArgumentNullException(nameof(contactService));\n            _noteService = noteService ?? throw new ArgumentNullException(nameof(noteService));\n            _reminderService = reminderService ?? throw new ArgumentNullException(nameof(reminderService));\n            _leadTimelineService = leadTimelineService ?? throw new ArgumentNullException(nameof(leadTimelineService));\n        }\n\n        public async Task<ContactSummaryResponseDto?> GetContactSummaryAsync(\n            Guid businessId,\n            Guid contactId,\n            CancellationToken ct = default)\n        {\n            // 1) Core contact (this already returns ContactDto with tags)\n            var contact = await _contactService.GetContactByIdAsync(businessId, contactId);\n            if (contact == null)\n            {\n                return null;\n            }\n\n            // 2) Notes ‚Äì latest 3 by CreatedAt\n            var notes = await _noteService.GetNotesByContactAsync(businessId, contactId);\n            var recentNotes = notes\n                .OrderByDescending(n => n.CreatedAt)\n                .Take(3)\n                .ToList();\n\n            // 3) Next upcoming reminder for this contact (in-memory filter from service)\n            var allReminders = await _reminderService.GetAllRemindersAsync(businessId);\n            var nowUtc = DateTime.UtcNow;\n\n            var nextReminder = allReminders\n                .Where(r =>\n                    r.ContactId == contactId &&\n                    r.IsActive &&\n                    string.Equals(r.Status, \"Pending\", StringComparison.OrdinalIgnoreCase) &&\n                    r.DueAt >= nowUtc)\n                .OrderBy(r => r.DueAt)\n                .FirstOrDefault();\n\n            // 4) Recent timeline entries (latest 5 by CreatedAt)\n            var timelineEntities = await _leadTimelineService.GetTimelineByContactIdAsync(contactId);\n\n            var recentTimeline = timelineEntities\n                .OrderByDescending(e => e.CreatedAt)\n                .Take(5)\n                .Select(LeadTimelineMapper.ToDto)\n                .Where(dto => dto != null)\n                .ToList()!; // mapper may return null, we filter just in case\n\n            // 5) Assemble response\n            return new ContactSummaryResponseDto\n            {\n                BusinessId = businessId,\n                ContactId = contactId,\n\n                Name = contact.Name,\n                PhoneNumber = contact.PhoneNumber,\n                Email = contact.Email,\n                LeadSource = contact.LeadSource,\n                LastContactedAt = contact.LastContactedAt,\n                NextFollowUpAt = contact.NextFollowUpAt,\n                IsFavorite = contact.IsFavorite,\n                IsArchived = contact.IsArchived,\n                Group = contact.Group,\n\n                Tags = contact.Tags ?? new List<ContactTagDto>(),\n\n                RecentNotes = recentNotes,\n                NextReminder = nextReminder,\n                RecentTimeline = recentTimeline\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Services/ContactTagService.cs",
      "sha256": "543a9a012a00f3ba3e43254aa3af8e48059f0aa7573ed59f8d7cdf20c4bc3684",
      "language": "csharp",
      "size": 2387,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.CRM.Interfaces;\nusing xbytechat.api.Features.CRM.Timelines.DTOs;\nusing xbytechat.api.Features.CRM.Timelines.Services;\n\nnamespace xbytechat.api.Features.CRM.Services\n{\n    public class ContactTagService : IContactTagService\n    {\n        private readonly AppDbContext _db;\n        private readonly ITimelineService _timelineService;\n        private readonly ILogger<ContactTagService> _logger;\n\n        public ContactTagService(AppDbContext db, ITimelineService timelineService, ILogger<ContactTagService> logger)\n        {\n            _db = db;\n            _timelineService = timelineService;\n            _logger = logger;\n        }\n\n        public async Task<bool> RemoveTagFromContactAsync(Guid businessId, Guid contactId, Guid tagId)\n        {\n            // ‚úÖ Find the link row but confirm contact belongs to this business\n            var link = await _db.ContactTags\n                .Join(_db.Contacts,\n                    ct => ct.ContactId,\n                    c => c.Id,\n                    (ct, c) => new { ct, c })\n                .Where(x => x.c.BusinessId == businessId\n                            && x.c.IsActive\n                            && x.ct.ContactId == contactId\n                            && x.ct.TagId == tagId)\n                .Select(x => x.ct)\n                .FirstOrDefaultAsync();\n\n            if (link == null) return false;\n\n            _db.ContactTags.Remove(link);\n            await _db.SaveChangesAsync();\n\n            // ‚úÖ Timeline log (safe, do not fail delete if timeline fails)\n            try\n            {\n                await _timelineService.LogTagRemovedAsync(new CRMTimelineLogDto\n                {\n                    ContactId = contactId,\n                    BusinessId = businessId,\n                    EventType = \"TagRemoved\",\n                    Description = $\"üè∑Ô∏è Tag removed.\",\n                    ReferenceId = tagId,\n                    CreatedBy = \"system\",\n                    Timestamp = DateTime.UtcNow,\n                    Category = \"CRM\"\n                });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"Timeline log failed for TagRemoved. ContactId={ContactId}, TagId={TagId}\", contactId, tagId);\n            }\n\n            return true;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Services/IContactProfileService.cs",
      "sha256": "2238c717846876f685aeb1424a5812b4673fd589105f31cdfbe116672d1cfd61",
      "language": "csharp",
      "size": 492,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.CRM.Services\n{\n    public interface IContactProfileService\n    {\n        /// <summary>\n        /// Update contact's ProfileName if changed. Lookup by (BusinessId, E.164 phone).\n        /// No-op if contact not found or name is empty.\n        /// </summary>\n        Task UpsertProfileNameAsync(Guid businessId, string phoneE164, string? profileName, CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Services/IContactSummaryService.cs",
      "sha256": "eaee7641520cea5125234a96e58c4e6ee94f241e1a3098f43f36fe5cac76e56f",
      "language": "csharp",
      "size": 773,
      "content": "// üìÑ xbytechat-api/Features/CRM/Summary/Interfaces/IContactSummaryService.cs\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CRM.Dtos;\n\nnamespace xbytechat.api.Features.CRM.Services\n{\n    /// <summary>\n    /// Aggregates data from CRM modules (Contacts, Notes, Reminders, Timeline)\n    /// into a single contact summary for the Chat Inbox / dashboards.\n    /// </summary>\n    public interface IContactSummaryService\n    {\n        /// <summary>\n        /// Returns a compact CRM snapshot for the given contact and business.\n        /// </summary>\n        Task<ContactSummaryResponseDto?> GetContactSummaryAsync(\n            Guid businessId,\n            Guid contactId,\n            CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Services/NoteService.cs",
      "sha256": "a25f2e5436a4deff6bd3860b2e339dfed6e41678d847ce1e61fc5af3d4da75c0",
      "language": "csharp",
      "size": 5573,
      "content": "using Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.CRM.Dtos;\nusing xbytechat.api.Features.CRM.Interfaces;\nusing xbytechat.api.Features.CRM.Mappers;\nusing xbytechat.api.Features.CRM.Timelines.DTOs;\nusing xbytechat.api.Features.CRM.Timelines.Services;\n\nnamespace xbytechat.api.Features.CRM.Services\n{\n    public class NoteService : INoteService\n    {\n        private readonly AppDbContext _db;\n        private readonly ITimelineService _timelineService;\n\n        public NoteService(AppDbContext db, ITimelineService timelineService)\n        {\n            _db = db;\n            _timelineService = timelineService;\n        }\n\n        // üìù Add a new Note + Log into LeadTimeline\n        public async Task<NoteDto> AddNoteAsync(Guid businessId, NoteDto dto)\n        {\n            if (dto == null) throw new ArgumentNullException(nameof(dto));\n\n            // ‚úÖ Content is the real important field\n            dto.Content = (dto.Content ?? string.Empty).Trim();\n            if (string.IsNullOrWhiteSpace(dto.Content))\n                throw new ArgumentException(\"Note content is required.\");\n\n            // ‚úÖ Title is optional ‚Üí derive from Content if missing\n            dto.Title = NormalizeTitle(dto.Title, dto.Content);\n\n            // 1Ô∏è‚É£ Map incoming DTO to Note entity\n            var note = NoteMapper.MapToEntity(dto, businessId);\n\n            // 2Ô∏è‚É£ Save the Note into database\n            _db.Notes.Add(note);\n            await _db.SaveChangesAsync();\n\n            // 3Ô∏è‚É£ Log this Note creation into LeadTimeline (only if ContactId is present)\n            if (dto.ContactId.HasValue)\n            {\n                try\n                {\n                    await _timelineService.LogNoteAddedAsync(new CRMTimelineLogDto\n                    {\n                        ContactId = dto.ContactId.Value,\n                        BusinessId = businessId,\n                        EventType = \"NoteAdded\",\n                        Description = $\"üìù Note added: {dto.Title ?? \"(Untitled)\"}\",\n                        ReferenceId = note.Id,\n                        CreatedBy = dto.CreatedBy, // ‚ö†Ô∏è ideally override from claims in controller\n                        Timestamp = DateTime.UtcNow\n                    });\n                }\n                catch (Exception ex)\n                {\n                    // üõ° Timeline saving failure should not break note creation\n                    Console.WriteLine($\"‚ö†Ô∏è Timeline log failed for NoteId {note.Id}: {ex.Message}\");\n                }\n            }\n\n            // 4Ô∏è‚É£ Return the saved note as DTO\n            return NoteMapper.MapToDto(note);\n        }\n\n        // üìã List all Notes by Contact\n        public async Task<IEnumerable<NoteDto>> GetNotesByContactAsync(Guid businessId, Guid contactId)\n        {\n            return await _db.Notes\n                .AsNoTracking()\n                .Where(n => n.BusinessId == businessId && n.ContactId == contactId)\n                .OrderByDescending(n => n.CreatedAt)\n                .Select(n => NoteMapper.MapToDto(n))\n                .ToListAsync();\n        }\n\n        // üìã Get a single Note by Id\n        public async Task<NoteDto?> GetNoteByIdAsync(Guid businessId, Guid noteId)\n        {\n            var note = await _db.Notes\n                .AsNoTracking()\n                .FirstOrDefaultAsync(n => n.Id == noteId && n.BusinessId == businessId);\n\n            return note == null ? null : NoteMapper.MapToDto(note);\n        }\n\n        // ‚úèÔ∏è Update an existing Note\n        public async Task<bool> UpdateNoteAsync(Guid businessId, Guid noteId, NoteDto dto)\n        {\n            if (dto == null) throw new ArgumentNullException(nameof(dto));\n\n            var note = await _db.Notes.FirstOrDefaultAsync(n => n.Id == noteId && n.BusinessId == businessId);\n            if (note == null) return false;\n\n            // ‚úÖ Content is required\n            dto.Content = (dto.Content ?? string.Empty).Trim();\n            if (string.IsNullOrWhiteSpace(dto.Content))\n                throw new ArgumentException(\"Note content is required.\");\n\n            // ‚úÖ Title optional: only update if provided, else derive from Content\n            var normalizedTitle = NormalizeTitle(dto.Title, dto.Content);\n            note.Title = normalizedTitle;\n\n            note.Content = dto.Content;\n            note.IsPinned = dto.IsPinned;\n            note.IsInternal = dto.IsInternal;\n            note.EditedAt = DateTime.SpecifyKind(DateTime.UtcNow, DateTimeKind.Utc);\n\n            await _db.SaveChangesAsync();\n            return true;\n        }\n\n        // üóëÔ∏è HARD delete (actual remove) a Note\n        public async Task<bool> DeleteNoteAsync(Guid businessId, Guid noteId)\n        {\n            var note = await _db.Notes.FirstOrDefaultAsync(n => n.Id == noteId && n.BusinessId == businessId);\n            if (note == null) return false;\n\n            _db.Notes.Remove(note); // ‚úÖ Hard delete\n            await _db.SaveChangesAsync();\n            return true;\n        }\n\n        // ----------------- helpers -----------------\n\n        private static string? NormalizeTitle(string? title, string content)\n        {\n            var t = (title ?? string.Empty).Trim();\n            if (!string.IsNullOrWhiteSpace(t))\n                return t;\n\n            // derive from content\n            var c = (content ?? string.Empty).Trim();\n            if (string.IsNullOrWhiteSpace(c))\n                return null;\n\n            const int max = 60;\n            return c.Length <= max ? c : (c.Substring(0, max) + \"‚Ä¶\");\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Services/ReminderService.cs",
      "sha256": "0446270dbb8c52631513ddb887d88c0a3643e1c7f0f9c0821a0d6d74984f0df0",
      "language": "csharp",
      "size": 8345,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.CRM.Dtos;\nusing xbytechat.api.Features.CRM.Interfaces;\nusing xbytechat.api.Features.CRM.Mappers;\nusing xbytechat.api.Features.CRM.Models;\nusing xbytechat.api.Features.CRM.Timelines.DTOs;\nusing xbytechat.api.Features.CRM.Timelines.Services;\n\nnamespace xbytechat.api.Features.CRM.Services\n{\n    public class ReminderService : IReminderService\n    {\n        private readonly AppDbContext _db;\n        private readonly ITimelineService _timelineService;\n        private readonly ILogger<ReminderService> _logger;\n\n        public ReminderService(AppDbContext db, ITimelineService timelineService, ILogger<ReminderService> logger)\n        {\n            _db = db;\n            _timelineService = timelineService;\n            _logger = logger;\n        }\n\n        public async Task<ReminderDto> AddReminderAsync(Guid businessId, ReminderDto dto)\n        {\n            if (dto == null) throw new ArgumentNullException(nameof(dto));\n\n            var title = string.IsNullOrWhiteSpace(dto.Title) ? \"(No title)\" : dto.Title.Trim();\n            var status = string.IsNullOrWhiteSpace(dto.Status) ? \"Pending\" : dto.Status.Trim();\n\n            // ‚úÖ Your DB model uses Guid (not nullable), so we must choose a value\n            var contactId = dto.ContactId ?? Guid.Empty;\n\n            var reminder = new Reminder\n            {\n                Id = Guid.NewGuid(),\n                BusinessId = businessId,\n                ContactId = contactId, // ‚úÖ Guid value (Guid.Empty if none)\n                Title = title,\n                Description = dto.Description?.Trim(),\n                DueAt = EnsureUtc(dto.DueAt),\n                Status = status,\n                ReminderType = dto.ReminderType?.Trim(),\n                Priority = dto.Priority,\n                IsRecurring = dto.IsRecurring,\n                RecurrencePattern = dto.RecurrencePattern,\n                SendWhatsappNotification = dto.SendWhatsappNotification,\n                LinkedCampaign = dto.LinkedCampaign,\n                CreatedAt = DateTime.UtcNow, // ‚úÖ correct\n                UpdatedAt = null,\n                CompletedAt = IsDoneStatus(status) ? DateTime.UtcNow : null,\n                IsActive = true\n            };\n\n            _db.Reminders.Add(reminder);\n            await _db.SaveChangesAsync();\n\n            // ‚úÖ Timeline only if contactId is real\n            if (contactId != Guid.Empty)\n            {\n                try\n                {\n                    await _timelineService.LogReminderSetAsync(new CRMTimelineLogDto\n                    {\n                        ContactId = contactId,\n                        BusinessId = businessId,\n                        EventType = \"ReminderSet\",\n                        Description = $\"‚è∞ Reminder set: {reminder.Title} (Due: {reminder.DueAt:yyyy-MM-dd HH:mm} UTC)\",\n                        ReferenceId = reminder.Id,\n                        CreatedBy = dto.CreatedBy ?? \"system\",\n                        Timestamp = DateTime.UtcNow,\n                        Category = \"CRM\"\n                    });\n                }\n                catch (Exception ex)\n                {\n                    _logger.LogWarning(ex, \"Timeline log failed for ReminderId={ReminderId}\", reminder.Id);\n                }\n            }\n\n            return ReminderMapper.MapToDto(reminder);\n        }\n\n        public async Task<IEnumerable<ReminderDto>> GetAllRemindersAsync(Guid businessId)\n        {\n            return await _db.Reminders\n                .AsNoTracking()\n                .Where(r => r.BusinessId == businessId && r.IsActive)\n                .OrderBy(r => r.DueAt)\n                .Select(r => ReminderMapper.MapToDto(r))\n                .ToListAsync();\n        }\n\n        public async Task<ReminderDto?> GetReminderByIdAsync(Guid businessId, Guid reminderId)\n        {\n            var reminder = await _db.Reminders\n                .AsNoTracking()\n                .FirstOrDefaultAsync(r => r.BusinessId == businessId && r.Id == reminderId && r.IsActive);\n\n            return reminder == null ? null : ReminderMapper.MapToDto(reminder);\n        }\n\n        public async Task<bool> UpdateReminderAsync(Guid businessId, Guid reminderId, ReminderDto dto)\n        {\n            var reminder = await _db.Reminders\n                .FirstOrDefaultAsync(r => r.BusinessId == businessId && r.Id == reminderId && r.IsActive);\n\n            if (reminder == null) return false;\n\n            if (!string.IsNullOrWhiteSpace(dto.Title))\n                reminder.Title = dto.Title.Trim();\n\n            reminder.Description = dto.Description?.Trim();\n            reminder.DueAt = EnsureUtc(dto.DueAt);\n\n            if (!string.IsNullOrWhiteSpace(dto.Status))\n                reminder.Status = dto.Status.Trim();\n\n            reminder.ReminderType = dto.ReminderType?.Trim();\n            reminder.Priority = dto.Priority;\n            reminder.IsRecurring = dto.IsRecurring;\n            reminder.RecurrencePattern = dto.RecurrencePattern;\n            reminder.SendWhatsappNotification = dto.SendWhatsappNotification;\n            reminder.LinkedCampaign = dto.LinkedCampaign;\n            reminder.UpdatedAt = DateTime.UtcNow;\n\n            if (IsDoneStatus(reminder.Status))\n                reminder.CompletedAt = reminder.CompletedAt ?? DateTime.UtcNow;\n\n            await _db.SaveChangesAsync();\n\n            // (optional) timeline ‚Äúupdated‚Äù\n            if (reminder.ContactId != Guid.Empty)\n            {\n                try\n                {\n                    await _timelineService.LogReminderUpdatedAsync(new CRMTimelineLogDto\n                    {\n                        ContactId = reminder.ContactId,\n                        BusinessId = businessId,\n                        EventType = \"ReminderUpdated\",\n                        Description = $\"‚úèÔ∏è Reminder updated: {reminder.Title}\",\n                        ReferenceId = reminder.Id,\n                        CreatedBy = dto.CreatedBy ?? \"system\",\n                        Timestamp = DateTime.UtcNow,\n                        Category = \"CRM\"\n                    });\n                }\n                catch (Exception ex)\n                {\n                    _logger.LogWarning(ex, \"Timeline log failed for ReminderUpdated ReminderId={ReminderId}\", reminder.Id);\n                }\n            }\n\n            return true;\n        }\n\n        // ‚úÖ HARD DELETE\n        public async Task<bool> DeleteReminderAsync(Guid businessId, Guid reminderId)\n        {\n            var reminder = await _db.Reminders\n                .FirstOrDefaultAsync(r => r.BusinessId == businessId && r.Id == reminderId && r.IsActive);\n\n            if (reminder == null) return false;\n\n            var contactId = reminder.ContactId;\n\n            _db.Reminders.Remove(reminder);\n            await _db.SaveChangesAsync();\n\n            if (contactId != Guid.Empty)\n            {\n                try\n                {\n                    await _timelineService.LogReminderDeletedAsync(new CRMTimelineLogDto\n                    {\n                        ContactId = contactId,\n                        BusinessId = businessId,\n                        EventType = \"ReminderDeleted\",\n                        Description = $\"üóëÔ∏è Reminder deleted: {reminder.Title}\",\n                        ReferenceId = reminder.Id,\n                        CreatedBy = \"system\",\n                        Timestamp = DateTime.UtcNow,\n                        Category = \"CRM\"\n                    });\n                }\n                catch (Exception ex)\n                {\n                    _logger.LogWarning(ex, \"Timeline log failed for ReminderDeleted ReminderId={ReminderId}\", reminder.Id);\n                }\n            }\n\n            return true;\n        }\n\n        private static DateTime EnsureUtc(DateTime value)\n        {\n            if (value.Kind == DateTimeKind.Utc) return value;\n            if (value.Kind == DateTimeKind.Local) return value.ToUniversalTime();\n            return DateTime.SpecifyKind(value, DateTimeKind.Utc);\n        }\n\n        private static bool IsDoneStatus(string? status)\n        {\n            if (string.IsNullOrWhiteSpace(status)) return false;\n            var s = status.Trim().ToLowerInvariant();\n            return s == \"done\" || s == \"completed\" || s == \"complete\";\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Services/TagService.cs",
      "sha256": "2e701fc3ab31d67208bdc3b4eeea07b3935f7129faac440942e15f3b6ee0a583",
      "language": "csharp",
      "size": 11636,
      "content": "// üìÑ File: xbytechat-api/Features/CRM/Services/TagService.cs\n\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.CRM.Dtos;\nusing xbytechat.api.Features.CRM.Interfaces;\nusing xbytechat.api.Features.CRM.Models;\nusing xbytechat.api.Features.CRM.Timelines.DTOs;\nusing xbytechat.api.Features.CRM.Timelines.Services;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.CRM.Services\n{\n    public class TagService : ITagService\n    {\n        private readonly AppDbContext _db;\n        private readonly ITimelineService _timelineService;\n        private readonly ILogger<TagService> _logger;\n\n        public TagService(AppDbContext db, ITimelineService timelineService, ILogger<TagService> logger)\n        {\n            _db = db;\n            _timelineService = timelineService;\n            _logger = logger;\n        }\n\n        public async Task<TagDto> AddTagAsync(Guid businessId, TagDto dto)\n        {\n            var name = (dto.Name ?? string.Empty).Trim();\n            if (string.IsNullOrWhiteSpace(name))\n                throw new ArgumentException(\"Tag name is required.\", nameof(dto.Name));\n\n            // ‚úÖ Avoid duplicates (case-insensitive) within a business\n            // NOTE: This is app-level protection; a DB unique index is still recommended later.\n            var nameLower = name.ToLowerInvariant();\n\n            var existing = await _db.Tags\n                .Where(t => t.BusinessId == businessId && t.IsActive)\n                .FirstOrDefaultAsync(t => (t.Name ?? \"\").ToLower() == nameLower);\n\n            if (existing != null)\n            {\n                return new TagDto\n                {\n                    Id = existing.Id,\n                    Name = existing.Name,\n                    ColorHex = existing.ColorHex,\n                    Category = existing.Category,\n                    Notes = existing.Notes,\n                    IsSystemTag = existing.IsSystemTag,\n                    IsActive = existing.IsActive,\n                    CreatedAt = existing.CreatedAt,\n                    LastUsedAt = existing.LastUsedAt\n                };\n            }\n\n            var tag = new Tag\n            {\n                Id = Guid.NewGuid(),\n                BusinessId = businessId,\n                Name = name,\n                ColorHex = string.IsNullOrWhiteSpace(dto.ColorHex) ? \"#8c8c8c\" : dto.ColorHex.Trim(),\n                Category = string.IsNullOrWhiteSpace(dto.Category) ? \"General\" : dto.Category.Trim(),\n                Notes = string.IsNullOrWhiteSpace(dto.Notes) ? null : dto.Notes.Trim(),\n                IsSystemTag = dto.IsSystemTag,\n\n                // ‚úÖ IMPORTANT: do not trust dto.IsActive during create (missing bool => false)\n                IsActive = true,\n\n                CreatedAt = DateTime.UtcNow,\n                LastUsedAt = null\n            };\n\n            _db.Tags.Add(tag);\n            await _db.SaveChangesAsync();\n\n            // ‚úÖ Non-blocking timeline log\n            try\n            {\n                await _timelineService.LogTagAppliedAsync(new CRMTimelineLogDto\n                {\n                    ContactId = Guid.Empty,\n                    BusinessId = businessId,\n                    EventType = \"TagCreated\",\n                    Description = $\"üè∑Ô∏è New tag created: {tag.Name}\",\n                    ReferenceId = tag.Id,\n                    CreatedBy = \"System\",\n                    Timestamp = DateTime.UtcNow,\n                    Category = \"CRM\"\n                });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"‚ö†Ô∏è Timeline log failed for TagId {TagId}\", tag.Id);\n            }\n\n            return new TagDto\n            {\n                Id = tag.Id,\n                Name = tag.Name,\n                ColorHex = tag.ColorHex,\n                Category = tag.Category,\n                Notes = tag.Notes,\n                IsSystemTag = tag.IsSystemTag,\n                IsActive = tag.IsActive,\n                CreatedAt = tag.CreatedAt,\n                LastUsedAt = tag.LastUsedAt\n            };\n        }\n\n        public async Task<IEnumerable<TagDto>> GetAllTagsAsync(Guid businessId)\n        {\n            return await _db.Tags\n                .Where(t => t.BusinessId == businessId && t.IsActive)\n                .OrderByDescending(t => t.CreatedAt)\n                .Select(t => new TagDto\n                {\n                    Id = t.Id,\n                    Name = t.Name,\n                    ColorHex = t.ColorHex,\n                    Category = t.Category,\n                    Notes = t.Notes,\n                    IsSystemTag = t.IsSystemTag,\n                    IsActive = t.IsActive,\n                    CreatedAt = t.CreatedAt,\n                    LastUsedAt = t.LastUsedAt\n                })\n                .ToListAsync();\n        }\n\n        public async Task<bool> UpdateTagAsync(Guid businessId, Guid tagId, TagDto dto)\n        {\n            var tag = await _db.Tags.FirstOrDefaultAsync(t => t.Id == tagId && t.BusinessId == businessId);\n            if (tag == null) return false;\n\n            var name = (dto.Name ?? string.Empty).Trim();\n            if (string.IsNullOrWhiteSpace(name))\n                throw new ArgumentException(\"Tag name is required.\", nameof(dto.Name));\n\n            // ‚úÖ Prevent rename collision (case-insensitive) inside business\n            var nameLower = name.ToLowerInvariant();\n\n            var collision = await _db.Tags\n                .Where(t => t.BusinessId == businessId && t.IsActive && t.Id != tagId)\n                .AnyAsync(t => (t.Name ?? \"\").ToLower() == nameLower);\n\n            if (collision)\n                throw new InvalidOperationException($\"A tag with name '{name}' already exists.\");\n\n            tag.Name = name;\n            tag.ColorHex = string.IsNullOrWhiteSpace(dto.ColorHex) ? tag.ColorHex : dto.ColorHex.Trim();\n            tag.Category = string.IsNullOrWhiteSpace(dto.Category) ? tag.Category : dto.Category.Trim();\n            tag.Notes = string.IsNullOrWhiteSpace(dto.Notes) ? null : dto.Notes.Trim();\n            tag.IsSystemTag = dto.IsSystemTag;\n\n            // ‚úÖ Allow activate/deactivate via update\n            tag.IsActive = dto.IsActive;\n            tag.LastUsedAt = DateTime.UtcNow;\n\n            await _db.SaveChangesAsync();\n            return true;\n        }\n\n        public async Task<bool> DeleteTagAsync(Guid businessId, Guid tagId)\n        {\n            var tag = await _db.Tags.FirstOrDefaultAsync(t => t.Id == tagId && t.BusinessId == businessId);\n            if (tag == null) return false;\n\n            tag.IsActive = false; // ‚úÖ soft delete\n            await _db.SaveChangesAsync();\n            return true;\n        }\n\n        /// <summary>\n        /// Assigns tags (by name) to a contact located via phone number.\n        /// Canonical phone storage: E.164 digits-only (no '+').\n        /// </summary>\n        public async Task<bool> AssignTagsAsync(Guid businessId, string phoneNumber, List<string> tagNames)\n        {\n            // ‚úÖ Normalize phone first (digits-only)\n            var normalizedPhone = PhoneNumberNormalizer.NormalizeToE164Digits(phoneNumber, \"IN\");\n            if (string.IsNullOrWhiteSpace(normalizedPhone))\n            {\n                _logger.LogWarning(\"AssignTagsAsync: invalid phone. businessId={BusinessId}, rawPhone={Phone}\", businessId, phoneNumber);\n                return false;\n            }\n\n            if (tagNames == null || tagNames.Count == 0)\n                return false;\n\n            // ‚úÖ Clean tag list (trim + remove empties + distinct, case-insensitive)\n            var cleanedTagNames = tagNames\n                .Where(t => !string.IsNullOrWhiteSpace(t))\n                .Select(t => t.Trim())\n                .Distinct(StringComparer.OrdinalIgnoreCase)\n                .ToList();\n\n            if (cleanedTagNames.Count == 0)\n                return false;\n\n            // ‚úÖ Find contact safely (tenant + active + not archived)\n            var contact = await _db.Contacts\n                .Include(c => c.ContactTags)\n                .FirstOrDefaultAsync(c =>\n                    c.BusinessId == businessId &&\n                    c.IsActive &&\n                    !c.IsArchived &&\n                    c.PhoneNumber == normalizedPhone);\n\n            if (contact == null)\n            {\n                _logger.LogWarning(\"AssignTagsAsync: contact not found. businessId={BusinessId}, phone={Phone}\", businessId, normalizedPhone);\n                return false;\n            }\n\n            var existingTagIds = contact.ContactTags?.Select(ct => ct.TagId).ToHashSet() ?? new HashSet<Guid>();\n\n            // ‚úÖ Fetch existing tags (active). Case-insensitive mapping in-memory (safe across DB collations).\n            var existingTags = await _db.Tags\n                .Where(t => t.BusinessId == businessId && t.IsActive)\n                .ToListAsync();\n\n            var existingByName = existingTags\n                .GroupBy(t => t.Name ?? \"\", StringComparer.OrdinalIgnoreCase)\n                .ToDictionary(g => g.Key, g => g.First(), StringComparer.OrdinalIgnoreCase);\n\n            var tagsToLink = new List<Tag>();\n\n            foreach (var name in cleanedTagNames)\n            {\n                if (existingByName.TryGetValue(name, out var tag))\n                {\n                    tagsToLink.Add(tag);\n                    continue;\n                }\n\n                // Create missing tag\n                var newTag = new Tag\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    Name = name,\n                    ColorHex = \"#8c8c8c\",\n                    Category = \"General\",\n                    IsActive = true,\n                    CreatedAt = DateTime.UtcNow,\n                    LastUsedAt = DateTime.UtcNow\n                };\n\n                _db.Tags.Add(newTag);\n                tagsToLink.Add(newTag);\n                existingByName[name] = newTag;\n            }\n\n            // Save new tags before linking\n            await _db.SaveChangesAsync();\n\n            contact.ContactTags ??= new List<ContactTag>();\n\n            var anyLinked = false;\n\n            foreach (var tag in tagsToLink)\n            {\n                if (existingTagIds.Contains(tag.Id))\n                    continue;\n\n                contact.ContactTags.Add(new ContactTag\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    ContactId = contact.Id,\n                    TagId = tag.Id,\n                    AssignedAt = DateTime.UtcNow,\n                    AssignedBy = \"automation\"\n                });\n\n                anyLinked = true;\n            }\n\n            if (!anyLinked)\n                return true;\n\n            await _db.SaveChangesAsync();\n\n            // ‚úÖ Non-blocking timeline\n            try\n            {\n                await _timelineService.LogTagAppliedAsync(new CRMTimelineLogDto\n                {\n                    ContactId = contact.Id,\n                    BusinessId = businessId,\n                    EventType = \"TagsAssigned\",\n                    Description = $\"üè∑Ô∏è Tags assigned: {string.Join(\", \", cleanedTagNames)}\",\n                    ReferenceId = contact.Id,\n                    CreatedBy = \"automation\",\n                    Timestamp = DateTime.UtcNow,\n                    Category = \"CRM\"\n                });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"‚ö†Ô∏è Timeline log failed for AssignTagsAsync. contactId={ContactId}\", contact.Id);\n            }\n\n            return true;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Timelines/Controllers/LeadTimelineController.cs",
      "sha256": "acbf1f3b85665c403e9ba8358653b9dbf039c8881b112af442083b59f7c6d1ee",
      "language": "csharp",
      "size": 2035,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing Serilog;\nusing xbytechat.api.Features.CRM.Timelines.DTOs;\nusing xbytechat.api.Features.CRM.Timelines.Services;\n\nnamespace xbytechat.api.Features.CRM.Timelines.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class LeadTimelineController : ControllerBase\n    {\n        private readonly ILeadTimelineService _timelineService;\n\n        public LeadTimelineController(ILeadTimelineService timelineService)\n        {\n            _timelineService = timelineService;\n        }\n\n        [HttpPost]\n        public async Task<IActionResult> AddTimelineEntry([FromBody] LeadTimelineDto dto)\n        {\n            try\n            {\n                if (!ModelState.IsValid)\n                    return BadRequest(ModelState);\n\n                var result = await _timelineService.AddTimelineEntryAsync(dto);\n\n                Log.Information(\"‚úÖ Timeline entry created for ContactId: {ContactId}\", dto.ContactId);\n\n                return Ok(result);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed to add timeline entry for ContactId: {ContactId}\", dto.ContactId);\n                throw;\n            }\n        }\n\n        [HttpGet(\"contact/{contactId}\")]\n        public async Task<IActionResult> GetTimeline(Guid contactId)\n        {\n            try\n            {\n                var timeline = await _timelineService.GetTimelineByContactIdAsync(contactId);\n\n                Log.Information(\"üìÑ Retrieved {Count} entries for ContactId: {ContactId}\", timeline.Count, contactId);\n\n                return Ok(timeline);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed to get timeline for ContactId: {ContactId}\", contactId);\n                throw;\n            }\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> GetAll()\n        {\n            var timelines = await _timelineService.GetAllTimelinesAsync();\n            return Ok(timelines);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Timelines/DTOs/CampaignTimelineLogDto.cs",
      "sha256": "b279e39522b2d36effd77fe29c36653ca83b93c6cc9a1281d1ed6b3e596b96e3",
      "language": "csharp",
      "size": 361,
      "content": "public class CampaignTimelineLogDto\n{\n    public Guid ContactId { get; set; }\n    public Guid BusinessId { get; set; }   // ‚úÖ Needed for timeline insertion\n    public Guid CampaignId { get; set; }\n    public string CampaignName { get; set; } = string.Empty; // ‚úÖ Safe default to avoid null issues\n    public DateTime? Timestamp { get; set; } // optional\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Timelines/DTOs/CRMTimelineLogDto.cs",
      "sha256": "523614f609f53bf0e19c490cf47a69ceb3ccc7df61bba97b431fcbcf6c739bdf",
      "language": "csharp",
      "size": 695,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CRM.Timelines.DTOs\n{\n    public class CRMTimelineLogDto\n    {\n        public Guid ContactId { get; set; }\n        public Guid BusinessId { get; set; }\n        public string EventType { get; set; }  // üß© Example: \"NoteAdded\", \"ReminderSet\", \"TagApplied\"\n        public string Description { get; set; }\n        public Guid? ReferenceId { get; set; }  // üÜî Related NoteId, ReminderId, TagId (optional)\n        public string CreatedBy { get; set; }\n        public string? Category { get; set; } = \"CRM\";  // üìÇ Default category: CRM\n        public DateTime? Timestamp { get; set; }  // ‚è∞ Custom time if needed (else CreatedAt = now)\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Timelines/DTOs/LeadTimelineDto.cs",
      "sha256": "3b83f102ec5c0ddae6f265b6d33ddbd741f854e83baa0f696a1a05a7d9639104",
      "language": "csharp",
      "size": 687,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CRM.Timelines.DTOs\n{\n    public class LeadTimelineDto\n    {\n        public Guid ContactId { get; set; }\n        public string ContactName { get; set; }\n        public string ContactNumber { get; set; }\n        public string EventType { get; set; }\n        public string Description { get; set; }\n        public string? Data { get; set; }\n        public Guid? ReferenceId { get; set; }\n        public bool IsSystemGenerated { get; set; } = false;\n        public string CreatedBy { get; set; }\n        public string? Source { get; set; }\n        public string? Category { get; set; }\n        public DateTime CreatedAt { get; set; }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Timelines/Mappers/LeadTimelineMapper.cs",
      "sha256": "d3a2ed675f44c84af1ce0317d44c4407bf3fc23bf4bfdd91ebf0c52bf63a9296",
      "language": "csharp",
      "size": 1843,
      "content": "using xbytechat.api.Features.CRM.Timelines.DTOs;\nusing xbytechat.api.Features.CRM.Timelines.Models;\n\nnamespace xbytechat.api.Features.CRM.Timelines.Mappers\n{\n    public static class LeadTimelineMapper\n    {\n        public static LeadTimelineDto ToDto(Models.LeadTimeline entry)\n        {\n            if (entry == null) return null;\n\n            return new LeadTimelineDto\n            {\n                ContactId = entry.ContactId,\n                ContactName = entry.Contact?.Name,                // ‚úÖ Enriched from navigation\n                ContactNumber = entry.Contact?.PhoneNumber,       // ‚úÖ Enriched from navigation\n                EventType = entry.EventType,\n                Description = entry.Description,\n                Data = entry.Data,\n                ReferenceId = entry.ReferenceId,\n                IsSystemGenerated = entry.IsSystemGenerated,\n                CreatedBy = entry.CreatedBy,\n                Source = entry.Source,\n                Category = entry.Category,\n                // ‚úÖ CreatedAt is intentionally excluded from DTO\n            };\n        }\n\n        // Optional for create/update, include only necessary fields\n        public static Models.LeadTimeline ToModel(LeadTimelineDto dto)\n        {\n            if (dto == null) return null;\n\n            return new Models.LeadTimeline\n            {\n                ContactId = dto.ContactId,\n                EventType = dto.EventType,\n                Description = dto.Description,\n                Data = dto.Data,\n                ReferenceId = dto.ReferenceId,\n                IsSystemGenerated = dto.IsSystemGenerated,\n                CreatedBy = dto.CreatedBy,\n                Source = dto.Source,\n                Category = dto.Category,\n                CreatedAt = DateTime.UtcNow // ‚úÖ Always use UTC when creating\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Timelines/Models/LeadTimeline.cs",
      "sha256": "3f31e8a170176d76713be299c4d314a5d1aaf17514d4903adb3685d41ca42572",
      "language": "csharp",
      "size": 1206,
      "content": "using xbytechat.api.Features.BusinessModule.Models;\nusing xbytechat.api.Features.CRM.Models;\n\nnamespace xbytechat.api.Features.CRM.Timelines.Models\n{\n    public class LeadTimeline\n    {\n        public int Id { get; set; }\n        public Guid ContactId { get; set; }\n        public Guid BusinessId { get; set; }\n        public Business Business { get; set; }  // optional\n\n        public Contact Contact { get; set; } // üÜï Navigation property\n\n        public string EventType { get; set; }\n\n        public string Description { get; set; }\n        public string? Data { get; set; }\n        public Guid? ReferenceId { get; set; }           // ‚úÖ New\n        public bool IsSystemGenerated { get; set; } = false;  // ‚úÖ New\n        public string CreatedBy { get; set; }\n        public string? Source { get; set; }\n        public string? Category { get; set; }\n        public DateTime CreatedAt { get; set; }\n\n        public string? CTAType { get; set; } // e.g., \"BuyNow\", \"PriceCheck\", \"ConfirmReminder\"\n        public string? CTASourceType { get; set; } // e.g., \"catalog\", \"campaign\", \"reminder\"\n        public Guid? CTASourceId { get; set; } // ID of the source object (productId, reminderId)\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Timelines/Services/ILeadTimelineService.cs",
      "sha256": "50629497a65281bae0ab515aa0b85e6a12eba14d8da57398c82e68cff749f58e",
      "language": "csharp",
      "size": 717,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Catalog.Models;\nusing xbytechat.api.Features.CRM.Timelines.DTOs;\nusing xbytechat.api.Features.CRM.Timelines.Models;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.CRM.Timelines.Services\n{\n    public interface ILeadTimelineService\n    {\n        Task<LeadTimeline> AddTimelineEntryAsync(LeadTimelineDto dto);\n        Task<List<LeadTimeline>> GetTimelineByContactIdAsync(Guid contactId);\n        Task<List<LeadTimelineDto>> GetAllTimelinesAsync();\n        Task AddFromCatalogClickAsync(CatalogClickLog log);\n        Task<ResponseResult> LogCampaignSendAsync(CampaignTimelineLogDto dto);\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Timelines/Services/ITimelineService.cs",
      "sha256": "f7018aae9a980787a0554c485915f6e623ed09c4e18b67b1843d17fa52b09b61",
      "language": "csharp",
      "size": 563,
      "content": "using xbytechat.api.Features.CRM.Timelines.DTOs;\n\nnamespace xbytechat.api.Features.CRM.Timelines.Services\n{\n    public interface ITimelineService\n    {\n        Task<bool> LogNoteAddedAsync(CRMTimelineLogDto dto);\n        Task<bool> LogReminderSetAsync(CRMTimelineLogDto dto);\n        Task<bool> LogTagAppliedAsync(CRMTimelineLogDto dto);\n\n        // ‚úÖ NEW\n        Task<bool> LogReminderUpdatedAsync(CRMTimelineLogDto dto);\n        Task<bool> LogReminderDeletedAsync(CRMTimelineLogDto dto);\n\n        Task<bool> LogTagRemovedAsync(CRMTimelineLogDto dto);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Timelines/Services/LeadTimelineService.cs",
      "sha256": "509c3bc3cf8d36b9acac08b54bf211a5992bb367934df75327f233af36eb9333",
      "language": "csharp",
      "size": 7570,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing xbytechat.api.Features.Catalog.Models;\nusing static xbytechat.api.Features.BusinessModule.Models.Business;\nusing System.Text.Json;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Features.PlanManagement.Models;\nusing xbytechat.api.Features.CRM.Timelines.DTOs;\nusing xbytechat.api.Features.CRM.Timelines.Models;\n\n\nnamespace xbytechat.api.Features.CRM.Timelines.Services\n{\n    public class LeadTimelineService : ILeadTimelineService\n    {\n        private readonly AppDbContext _context;\n\n\n        public LeadTimelineService(AppDbContext context)\n        {\n            _context = context;\n\n        }\n\n        public async Task<LeadTimeline> AddTimelineEntryAsync(LeadTimelineDto dto)\n        {\n            try\n            {\n                var entry = new LeadTimeline\n                {\n                    ContactId = dto.ContactId,\n                    EventType = dto.EventType,\n                    Description = dto.Description,\n                    Data = dto.Data,\n                    ReferenceId = dto.ReferenceId,\n                    IsSystemGenerated = dto.IsSystemGenerated,\n                    CreatedBy = dto.CreatedBy,\n                    Source = dto.Source,\n                    Category = dto.Category,\n                    CreatedAt = DateTime.UtcNow\n                };\n\n                _context.LeadTimelines.Add(entry);\n                await _context.SaveChangesAsync();\n\n                Log.Information(\"‚úÖ Timeline entry added for ContactId: {ContactId}\", dto.ContactId);\n\n                return entry;\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Error adding timeline entry for ContactId: {ContactId}\", dto.ContactId);\n                throw; // Let global middleware handle this\n            }\n        }\n\n        public async Task<List<LeadTimeline>> GetTimelineByContactIdAsync(Guid contactId)\n        {\n            try\n            {\n                var results = await _context.LeadTimelines\n                    .Where(x => x.ContactId == contactId)\n                    .OrderByDescending(x => x.CreatedAt)\n                    .ToListAsync();\n\n                Log.Information(\"üìÑ Fetched {Count} timeline entries for ContactId: {ContactId}\", results.Count, contactId);\n\n                return results;\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed to fetch timeline for ContactId: {ContactId}\", contactId);\n                throw;\n            }\n        }\n\n        public async Task<List<LeadTimelineDto>> GetAllTimelinesAsync()\n        {\n            try\n            {\n                var entries = await _context.LeadTimelines\n                    .Include(t => t.Contact) // for Contact Name/Phone\n                    .OrderByDescending(e => e.CreatedAt)\n                    .ToListAsync();\n\n                var dtoList = entries.Select(entry => new LeadTimelineDto\n                {\n                    ContactId = entry.ContactId,\n                    EventType = entry.EventType,\n                    Description = entry.Description,\n                    Data = entry.Data,\n                    ReferenceId = entry.ReferenceId,\n                    CreatedAt = entry.CreatedAt,\n                    CreatedBy = entry.CreatedBy,\n                    Source = entry.Source,\n                    Category = entry.Category,\n                    IsSystemGenerated = entry.IsSystemGenerated,\n                    ContactName = entry.Contact?.Name,\n                    ContactNumber = entry.Contact?.PhoneNumber\n                }).ToList();\n\n                Log.Information(\"üìÑ Loaded {Count} total timeline entries\", dtoList.Count);\n                return dtoList;\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed to fetch all timeline entries\");\n                throw;\n            }\n        }\n        public async Task AddFromCatalogClickAsync(CatalogClickLog log)\n        {\n            if (log == null)\n            {\n                Log.Warning(\"CatalogClickLog is null. Skipping timeline creation.\");\n                return;\n            }\n\n            try\n            {\n                var business = await _context.Businesses\n                    .AsNoTracking()\n                    .FirstOrDefaultAsync(b => b.Id == log.BusinessId);\n\n                if (business == null)\n                {\n                    Log.Warning(\"Business not found for ID: {BusinessId}. Skipping timeline creation.\", log.BusinessId);\n                    return;\n                }\n\n                // if (business.Plan == PlanType.Advanced)\n                if (business?.BusinessPlanInfo?.Plan == PlanType.Advanced)\n                {\n                    Log.Information(\"Timeline skipped for Basic Plan - BusinessId: {BusinessId}\", business.Id);\n                    return;\n                }\n\n\n                var description = $\"{log.ProductBrowsed} | {log.CTAJourney}\";\n\n                var timelineEntry = new LeadTimeline\n                {\n                    BusinessId = log.BusinessId,\n                    ContactId = log.ContactId ?? Guid.Empty,\n                    EventType = \"CatalogCTA\",\n                    Description = description,\n                    Data = JsonSerializer.Serialize(log),\n                    ReferenceId = null,\n                    CreatedBy = \"system\",\n                    IsSystemGenerated = true,\n                    Source = \"Catalog\",\n                    Category = log.CategoryBrowsed,\n                    CreatedAt = DateTime.UtcNow\n                };\n\n                _context.LeadTimelines.Add(timelineEntry);\n                await _context.SaveChangesAsync();\n\n                Log.Information(\"üìà Timeline entry created from CatalogClick for UserId: {UserId}\", log.UserId);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Error creating timeline entry from CatalogClick for UserId: {UserId}\", log.UserId);\n                // Safe swallow\n            }\n        }\n\n        public async Task<ResponseResult> LogCampaignSendAsync(CampaignTimelineLogDto dto)\n        {\n            try\n            {\n                var timeline = new LeadTimeline\n                {\n                    ContactId = dto.ContactId,\n                    BusinessId = dto.BusinessId,\n                    EventType = \"CampaignSend\",\n                    Description = $\"Campaign '{dto.CampaignName}' was sent.\", // ‚úÖ Timeline me readable text\n                    ReferenceId = dto.CampaignId, // ‚úÖ Linking to campaign record\n                    IsSystemGenerated = false,    // ‚úÖ Default (campaign sending is manual action)\n                    CreatedBy = \"system\",         // ‚úÖ Or actual user email if needed later\n                    Source = \"CampaignModule\",    // ‚úÖ Source field for clarity\n                    Category = \"Messaging\",       // ‚úÖ Logical grouping\n                    CreatedAt = dto.Timestamp ?? DateTime.UtcNow // ‚úÖ Use given Timestamp or fallback to now\n                };\n\n                _context.LeadTimelines.Add(timeline);\n                await _context.SaveChangesAsync();\n\n                return ResponseResult.SuccessInfo(\"‚úÖ Campaign send event logged into timeline.\");\n            }\n            catch (Exception ex)\n            {\n                return ResponseResult.ErrorInfo(\"‚ùå Failed to log campaign send event: \" + ex.Message);\n            }\n        }\n\n\n    }\n\n\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Timelines/Services/TimelineService.cs",
      "sha256": "5f40e44e792c09c3d4559a8a17a1f533efddc038381124a08cbbbd0a0e002ba6",
      "language": "csharp",
      "size": 3044,
      "content": "using xbytechat.api.Features.CRM.Timelines.DTOs;\nusing xbytechat.api.Features.CRM.Timelines.Models;\n\nnamespace xbytechat.api.Features.CRM.Timelines.Services\n{\n    public class TimelineService : ITimelineService\n    {\n        private readonly AppDbContext _context;\n\n        public TimelineService(AppDbContext context)\n        {\n            _context = context;\n        }\n\n        public async Task<bool> LogNoteAddedAsync(CRMTimelineLogDto dto)\n            => await InsertAsync(dto, \"NoteAdded\", dto.Description);\n\n        public async Task<bool> LogReminderSetAsync(CRMTimelineLogDto dto)\n            => await InsertAsync(dto, \"ReminderSet\", dto.Description);\n\n        public async Task<bool> LogTagAppliedAsync(CRMTimelineLogDto dto)\n            => await InsertAsync(dto, \"TagApplied\", dto.Description);\n\n        // ‚úÖ NEW\n        public async Task<bool> LogReminderUpdatedAsync(CRMTimelineLogDto dto)\n            => await InsertAsync(dto, \"ReminderUpdated\", dto.Description);\n\n        // ‚úÖ NEW\n        public async Task<bool> LogReminderDeletedAsync(CRMTimelineLogDto dto)\n            => await InsertAsync(dto, \"ReminderDeleted\", dto.Description);\n\n        private async Task<bool> InsertAsync(CRMTimelineLogDto dto, string eventType, string description)\n        {\n            try\n            {\n                var timeline = new LeadTimeline\n                {\n                    ContactId = dto.ContactId,\n                    BusinessId = dto.BusinessId,\n                    EventType = eventType,\n                    Description = description,\n                    ReferenceId = dto.ReferenceId,\n                    CreatedBy = dto.CreatedBy,\n                    Source = \"CRM\",\n                    Category = dto.Category ?? \"CRM\",\n                    CreatedAt = dto.Timestamp ?? DateTime.UtcNow,\n                    IsSystemGenerated = false\n                };\n\n                _context.LeadTimelines.Add(timeline);\n                await _context.SaveChangesAsync();\n                return true;\n            }\n            catch\n            {\n                return false;\n            }\n        }\n\n        public async Task<bool> LogTagRemovedAsync(CRMTimelineLogDto dto)\n        {\n            try\n            {\n                var timeline = new LeadTimeline\n                {\n                    ContactId = dto.ContactId,\n                    BusinessId = dto.BusinessId,\n                    EventType = \"TagRemoved\",\n                    Description = dto.Description,\n                    ReferenceId = dto.ReferenceId,\n                    CreatedBy = dto.CreatedBy,\n                    Source = \"CRM\",\n                    Category = dto.Category ?? \"CRM\",\n                    CreatedAt = dto.Timestamp ?? DateTime.UtcNow,\n                    IsSystemGenerated = false\n                };\n\n                _context.LeadTimelines.Add(timeline);\n                await _context.SaveChangesAsync();\n                return true;\n            }\n            catch\n            {\n                return false;\n            }\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CrmAnalytics/Controllers/CrmAnalyticsController.cs",
      "sha256": "9148ea0201bfa24665b2fc92339cec7f58019baa66443aba80189bc1a4c9c833",
      "language": "csharp",
      "size": 1948,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CrmAnalytics.Services;\nusing xbytechat.api.Shared;\nusing System.Security.Claims;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.CrmAnalytics.Controllers\n{\n    /// <summary>\n    /// Handles CRM analytics summary and trends.\n    /// </summary>\n    [ApiController]\n    [Route(\"api/crm\")]\n    public class CrmAnalyticsController : ControllerBase\n    {\n        private readonly ICrmAnalyticsService _crmAnalyticsService;\n\n        public CrmAnalyticsController(ICrmAnalyticsService crmAnalyticsService)\n        {\n            _crmAnalyticsService = crmAnalyticsService;\n        }\n\n        /// <summary>\n        /// Returns dashboard summary stats for the CRM.\n        /// </summary>\n        [HttpGet(\"summary\")]\n        public async Task<IActionResult> GetSummary()\n        {\n            var businessId = GetBusinessIdFromContext();\n            var result = await _crmAnalyticsService.GetSummaryAsync(businessId);\n            return Ok(ResponseResult.SuccessInfo(\"üìä CRM analytics loaded successfully.\", result));\n        }\n\n        /// <summary>\n        /// Returns contacts-added-over-time trend for graph.\n        /// </summary>\n        [HttpGet(\"trends/contacts\")]\n        public async Task<IActionResult> GetContactTrends()\n        {\n            var businessId = GetBusinessIdFromContext();\n            var result = await _crmAnalyticsService.GetContactTrendsAsync(businessId);\n            return Ok(ResponseResult.SuccessInfo(\"üìà Contact trends loaded successfully.\", result));\n        }\n\n        /// <summary>\n        /// Extracts the businessId (Guid) from current user claims.\n        /// </summary>\n        private Guid GetBusinessIdFromContext()\n        {\n            return Guid.TryParse(HttpContext.User.FindFirst(\"BusinessId\")?.Value, out var id)\n                ? id\n                : Guid.Empty;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CrmAnalytics/DTOs/ContactTrendsDto.cs",
      "sha256": "132d9271e14f9c3f2a65c9241917f67bc8129c91c7050c86a67df545c68419bc",
      "language": "csharp",
      "size": 362,
      "content": "namespace xbytechat.api.Features.CrmAnalytics.DTOs\n{\n    /// <summary>\n    /// Represents the number of contacts added on a specific date.\n    /// Used for trend charting on the CRM dashboard.\n    /// </summary>\n    public class ContactTrendsDto\n    {\n        public string Date { get; set; } // Format: yyyy-MM-dd\n        public int Count { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CrmAnalytics/DTOs/CrmAnalyticsSummaryDto.cs",
      "sha256": "73027ff6ddc0b680b03714267bbf642053cdc28f2d97c16b593a3321186ab9d9",
      "language": "csharp",
      "size": 619,
      "content": "namespace xbytechat.api.Features.CrmAnalytics.DTOs\n{\n    public class CrmAnalyticsSummaryDto\n    {\n        public int TotalContacts { get; set; }\n        public int TaggedContacts { get; set; }\n        public int ActiveReminders { get; set; }\n        public int CompletedReminders { get; set; }\n        public int TotalNotes { get; set; }\n        public int LeadsWithTimeline { get; set; }\n        public int NewContactsToday { get; set; }\n        public int NotesAddedToday { get; set; }\n        public DateTime? LastContactAddedAt { get; set; }\n        public DateTime? LastReminderCompletedAt { get; set; }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CrmAnalytics/Services/CrmAnalyticsService.cs",
      "sha256": "8fae1f725576dc5f6402559df557282ba8991f65bb324b614a65b4e9225167c5",
      "language": "csharp",
      "size": 4014,
      "content": "using System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.CrmAnalytics.DTOs;\nusing xbytechat.api.Features.CrmAnalytics.Services;\n\nnamespace xbytechat.api.Features.CrmAnalytics.Services\n{\n    /// <summary>\n    /// Provides implementation for CRM analytics calculations.\n    /// Gathers contact, tag, note, and reminder metrics for the dashboard.\n    /// </summary>\n    public class CrmAnalyticsService : ICrmAnalyticsService\n    {\n        private readonly AppDbContext _context;\n\n        public CrmAnalyticsService(AppDbContext context)\n        {\n            _context = context;\n        }\n\n        /// <summary>\n        /// Generates a summarized snapshot of CRM data for the given business.\n        /// </summary>\n        /// <param name=\"businessId\">The unique ID of the business</param>\n        /// <returns>CrmAnalyticsSummaryDto containing insights</returns>\n        public async Task<CrmAnalyticsSummaryDto> GetSummaryAsync(Guid businessId)\n        {\n            var today = DateTime.UtcNow.Date;\n\n            var totalContacts = await _context.Contacts\n                .CountAsync(c => c.BusinessId == businessId);\n\n            var taggedContacts = await _context.Contacts\n                .Where(c => c.BusinessId == businessId && c.Tags.Any())\n                .CountAsync();\n\n            var activeReminders = await _context.Reminders\n                .CountAsync(r => r.BusinessId == businessId && r.Status == \"Pending\");\n\n            var completedReminders = await _context.Reminders\n                .CountAsync(r => r.BusinessId == businessId && r.Status == \"Completed\");\n\n            var totalNotes = await _context.Notes\n                .CountAsync(n => n.BusinessId == businessId);\n\n            var leadsWithTimeline = await _context.LeadTimelines\n                .Where(t => t.BusinessId == businessId)\n                .Select(t => t.ContactId)\n                .Distinct()\n                .CountAsync();\n\n            var newContactsToday = await _context.Contacts\n                .CountAsync(c => c.BusinessId == businessId && c.CreatedAt.Date == today);\n\n            var notesAddedToday = await _context.Notes\n                .CountAsync(n => n.BusinessId == businessId && n.CreatedAt.Date == today);\n\n            var lastContactAddedAt = await _context.Contacts\n                .Where(c => c.BusinessId == businessId)\n                .OrderByDescending(c => c.CreatedAt)\n                .Select(c => (DateTime?)c.CreatedAt)\n                .FirstOrDefaultAsync();\n\n            var lastReminderCompletedAt = await _context.Reminders\n                .Where(r => r.BusinessId == businessId && r.Status == \"Completed\")\n                .OrderByDescending(r => r.CompletedAt)\n                .Select(r => (DateTime?)r.CompletedAt)\n                .FirstOrDefaultAsync();\n\n            return new CrmAnalyticsSummaryDto\n            {\n                TotalContacts = totalContacts,\n                TaggedContacts = taggedContacts,\n                ActiveReminders = activeReminders,\n                CompletedReminders = completedReminders,\n                TotalNotes = totalNotes,\n                LeadsWithTimeline = leadsWithTimeline,\n                NewContactsToday = newContactsToday,\n                NotesAddedToday = notesAddedToday,\n                LastContactAddedAt = lastContactAddedAt,\n                LastReminderCompletedAt = lastReminderCompletedAt\n            };\n        }\n        public async Task<List<ContactTrendsDto>> GetContactTrendsAsync(Guid businessId)\n        {\n            var trends = await _context.Contacts\n                .Where(c => c.BusinessId == businessId)\n                .GroupBy(c => c.CreatedAt.Date)\n                .OrderBy(g => g.Key)\n                .Select(g => new ContactTrendsDto\n                {\n                    Date = g.Key.ToString(\"yyyy-MM-dd\"),\n                    Count = g.Count()\n                })\n                .ToListAsync();\n\n            return trends;\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CrmAnalytics/Services/ICrmAnalyticsService.cs",
      "sha256": "24d70810ed26415792ab48592900090d8d1b7682d926e46f4bdc4595b24c5659",
      "language": "csharp",
      "size": 895,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.CrmAnalytics.DTOs;\n\nnamespace xbytechat.api.Features.CrmAnalytics.Services\n{\n    /// <summary>\n    /// Defines the contract for CRM Analytics services.\n    /// Handles lead-level analytics, summary metrics, and dashboard insights.\n    /// </summary>\n    public interface ICrmAnalyticsService\n    {\n        /// <summary>\n        /// Returns a summarized view of CRM statistics for a specific business.\n        /// This is used to power the CRM analytics dashboard.\n        /// </summary>\n        /// <param name=\"businessId\">The unique identifier of the business (tenant).</param>\n        /// <returns>A summary DTO containing contact, tag, note, and reminder insights.</returns>\n        Task<CrmAnalyticsSummaryDto> GetSummaryAsync(Guid businessId);\n        Task<List<ContactTrendsDto>> GetContactTrendsAsync(Guid businessId);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CsvModule/CsvBatchValidationController.cs",
      "sha256": "daf00037fbe7c0f74272fe6dd650de7918d6f2f9a1bf91e40b01039a0e04f9cc",
      "language": "csharp",
      "size": 7225,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.Json;\nusing System.Text.RegularExpressions;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api;\nusing xbytechat.api.Shared;\nusing xbytechat_api.WhatsAppSettings.Services; // User.GetBusinessId()\n\nnamespace xbytechat.api.Features.CsvModule.Controllers\n{\n    [ApiController]\n    [Route(\"api/csv/batch/{batchId:guid}/validate\")]\n    [Authorize]\n    public sealed class CsvBatchValidationController : ControllerBase\n    {\n        private readonly AppDbContext _db;\n        public CsvBatchValidationController(AppDbContext db) => _db = db;\n\n        public sealed class ValidateRequest\n        {\n            public string? PhoneHeader { get; set; }              // e.g. \"phone\"\n            public List<string>? RequiredHeaders { get; set; }    // e.g. [\"parameter1\",\"headerpara1\",\"buttonpara1\"]\n            public bool NormalizePhone { get; set; } = true;\n            public bool CheckDuplicates { get; set; } = true;\n            public int? Limit { get; set; }                       // optional sample cap\n        }\n\n        public sealed class ValidateResponse\n        {\n            public bool Success { get; set; } = true;\n            public List<string> Problems { get; set; } = new();\n            public object Stats { get; set; } = new { rows = 0, missingPhone = 0, invalidPhones = 0, duplicatePhones = 0 };\n            public List<string> Headers { get; set; } = new();    // discovered headers in the batch\n        }\n\n        [HttpPost]\n        public async Task<IActionResult> Validate(Guid batchId, [FromBody] ValidateRequest req, CancellationToken ct = default)\n        {\n            var businessId = User.GetBusinessId();\n            if (businessId == Guid.Empty) return Unauthorized();\n\n            // Load CSV rows for this batch (owned by business)\n            var rowsQ = _db.CsvRows\n                .AsNoTracking()\n                .Where(r => r.BusinessId == businessId && r.BatchId == batchId)\n                .OrderBy(r => r.RowIndex);\n\n            var total = await rowsQ.CountAsync(ct);\n            if (total == 0)\n                return Ok(new ValidateResponse\n                {\n                    Problems = new List<string> { \"CSV batch is empty.\" },\n                    Stats = new { rows = 0, missingPhone = 0, invalidPhones = 0, duplicatePhones = 0 },\n                    Headers = new List<string>()\n                });\n\n            var rows = req.Limit.HasValue && req.Limit.Value > 0\n                ? await rowsQ.Take(req.Limit.Value).ToListAsync(ct)\n                : await rowsQ.ToListAsync(ct);\n\n            // Discover header set by union of row keys (case-insensitive compare)\n            var headerSet = new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n            foreach (var r in rows)\n                foreach (var k in KeysOfJson(r.DataJson))\n                    headerSet.Add(k);\n\n            var headers = headerSet.OrderBy(x => x, StringComparer.OrdinalIgnoreCase).ToList();\n\n            var problems = new List<string>();\n\n            // Validate phone header presence\n            var phoneHeader = (req.PhoneHeader ?? \"\").Trim();\n            if (string.IsNullOrWhiteSpace(phoneHeader))\n            {\n                // Try helpful guesses\n                var guesses = new[] { \"phone\", \"mobile\", \"whatsapp\", \"number\", \"phonee164\", \"msisdn\", \"whatsapp_number\" };\n                var guess = guesses.FirstOrDefault(h => headerSet.Contains(h));\n                if (!string.IsNullOrEmpty(guess))\n                    phoneHeader = guess;\n            }\n\n            if (string.IsNullOrWhiteSpace(phoneHeader))\n            {\n                problems.Add(\"Phone column not specified and could not be guessed.\");\n            }\n            else if (!headerSet.Contains(phoneHeader))\n            {\n                problems.Add($\"Phone column ‚Äú{phoneHeader}‚Äù not found in CSV.\");\n            }\n\n            // Validate requiredHeaders presence (parameterN/headerparaN/buttonparaN)\n            var required = req.RequiredHeaders ?? new List<string>();\n            foreach (var h in required)\n            {\n                if (!headerSet.Contains(h))\n                    problems.Add($\"Required column ‚Äú{h}‚Äù is missing.\");\n            }\n\n            // Row-level checks\n            int missingPhone = 0, invalidPhones = 0, duplicatePhones = 0;\n            var seen = new HashSet<string>(StringComparer.Ordinal);\n\n            foreach (var r in rows)\n            {\n                var dict = JsonToDict(r.DataJson);\n\n                // phone\n                string? rawPhone = null;\n                if (!string.IsNullOrWhiteSpace(phoneHeader))\n                    dict.TryGetValue(phoneHeader, out rawPhone);\n\n                var normPhone = NormalizePhoneMaybe(rawPhone, req.NormalizePhone);\n                if (string.IsNullOrWhiteSpace(normPhone))\n                {\n                    missingPhone++;\n                    continue;\n                }\n\n                // naive validity check\n                if (!Regex.IsMatch(normPhone, @\"^\\d{10,15}$\"))\n                {\n                    invalidPhones++;\n                }\n\n                if (req.CheckDuplicates && !seen.Add(normPhone))\n                {\n                    duplicatePhones++;\n                }\n            }\n\n            var resp = new ValidateResponse\n            {\n                Problems = problems,\n                Stats = new { rows = total, missingPhone, invalidPhones, duplicatePhones },\n                Headers = headers\n            };\n\n            return Ok(resp);\n        }\n\n        // ---------- helpers ----------\n        private static IEnumerable<string> KeysOfJson(string? json)\n        {\n            if (string.IsNullOrWhiteSpace(json)) yield break;\n            using var doc = JsonDocument.Parse(json);\n            if (doc.RootElement.ValueKind != JsonValueKind.Object) yield break;\n            foreach (var p in doc.RootElement.EnumerateObject())\n                yield return p.Name;\n        }\n\n        private static Dictionary<string, string> JsonToDict(string? json)\n        {\n            var dict = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n            if (string.IsNullOrWhiteSpace(json)) return dict;\n            using var doc = JsonDocument.Parse(json);\n            if (doc.RootElement.ValueKind != JsonValueKind.Object) return dict;\n            foreach (var p in doc.RootElement.EnumerateObject())\n                dict[p.Name] = p.Value.ValueKind == JsonValueKind.Null ? \"\" : p.Value.ToString();\n            return dict;\n        }\n\n        private static string? NormalizePhoneMaybe(string? raw, bool normalize)\n        {\n            if (string.IsNullOrWhiteSpace(raw)) return null;\n            var trimmed = raw.Trim();\n            if (!normalize) return trimmed;\n\n            // simple E.164-ish cleanup\n            var digits = Regex.Replace(trimmed, \"[^0-9]\", \"\");\n            digits = digits.TrimStart('0');\n            if (digits.Length == 10) digits = \"91\" + digits; // heuristic India\n            return digits;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Controllers/CTAFlowController.cs",
      "sha256": "941d3a884c221e0a18355505ebd681462d87259abca4e801e091070410f16d21",
      "language": "csharp",
      "size": 9864,
      "content": "using Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Serilog;\nusing xbytechat.api.Features.CTAFlowBuilder.DTOs;\nusing xbytechat.api.Features.CTAFlowBuilder.Services;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Controllers\n{\n    [Authorize]\n    [ApiController]\n    [Route(\"api/cta-flow\")]\n    public class CTAFlowController : ControllerBase\n    {\n        private readonly ICTAFlowService _flowService;\n\n        public CTAFlowController(ICTAFlowService flowService)\n        {\n            _flowService = flowService;\n        }\n\n        // CREATE (draft-only)\n        [HttpPost(\"save-visual\")]\n        public async Task<IActionResult> SaveVisualFlow([FromBody] SaveVisualFlowDto dto)\n        {\n            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n            var createdBy = User.FindFirst(\"name\")?.Value ?? \"system\";\n            if (!Guid.TryParse(businessIdClaim, out var businessId))\n                return BadRequest(new { message = \"‚ùå Invalid business ID\" });\n\n            Log.Information(\"üì¶ Saving CTA Flow: {FlowName} by {User}\", dto.FlowName, createdBy);\n\n            var result = await _flowService.SaveVisualFlowAsync(dto, businessId, createdBy);\n            if (!result.Success)\n            {\n                var m = (result.ErrorMessage ?? \"\").Trim();\n\n                // map common validation/conflict by message text (no result.Code available)\n                if (m.Contains(\"already exists\", StringComparison.OrdinalIgnoreCase))\n                    return Conflict(new { message = \"‚ùå Duplicate flow name\", error = m });\n\n                if (m.Contains(\"required\", StringComparison.OrdinalIgnoreCase) ||\n                    m.Contains(\"empty flow\", StringComparison.OrdinalIgnoreCase) ||\n                    m.Contains(\"invalid\", StringComparison.OrdinalIgnoreCase))\n                    return BadRequest(new { message = \"‚ùå Failed to save flow\", error = m });\n\n                return StatusCode(StatusCodes.Status500InternalServerError,\n                    new { message = \"‚ùå Failed to save flow\", error = string.IsNullOrWhiteSpace(m) ? \"Unknown error\" : m });\n            }\n\n            Guid? flowId = null;\n            if (result.Data is not null)\n            {\n                try { dynamic d = result.Data; flowId = (Guid?)d.flowId; } catch { }\n            }\n\n            return Ok(new { message = \"‚úÖ Flow saved successfully\", flowId });\n        }\n\n        // UPDATE (save as draft by id)\n        [HttpPut(\"{id:guid}\")]\n        public async Task<IActionResult> Update(Guid id, [FromBody] SaveVisualFlowDto dto)\n        {\n            var biz = User.FindFirst(\"businessId\")?.Value;\n            var user = User.FindFirst(\"name\")?.Value ?? \"system\";\n            if (!Guid.TryParse(biz, out var businessId))\n                return BadRequest(new { message = \"‚ùå Invalid business.\" });\n\n            var result = await _flowService.UpdateVisualFlowAsync(id, dto, businessId, user);\n\n            return result.Status switch\n            {\n                \"notFound\" => NotFound(new { message = result.Message ?? \"‚ùå Flow not found.\" }),\n                \"requiresFork\" => Conflict(new { message = result.Message ?? \"‚ùå Edit requires fork.\", campaigns = result.Campaigns }),\n                \"error\" => BadRequest(new { message = result.Message ?? \"‚ùå Failed to update flow.\" }),\n                _ => Ok(new { message = result.Message ?? \"‚úÖ Flow updated (draft).\", needsRepublish = result.NeedsRepublish })\n            };\n        }\n\n        // FORK (create a new draft copy)\n        [HttpPost(\"{id:guid}/fork\")]\n        public async Task<IActionResult> Fork(Guid id)\n        {\n            var biz = User.FindFirst(\"businessId\")?.Value;\n            var user = User.FindFirst(\"name\")?.Value ?? \"system\";\n            if (!Guid.TryParse(biz, out var businessId))\n                return BadRequest(new { message = \"‚ùå Invalid business.\" });\n\n            var forkId = await _flowService.ForkFlowAsync(id, businessId, user);\n            if (forkId == Guid.Empty) return NotFound(new { message = \"‚ùå Flow not found.\" });\n\n            return Ok(new { flowId = forkId });\n        }\n\n        // PUBLISH (by id)\n        [HttpPost(\"{id:guid}/publish\")]\n        public async Task<IActionResult> Publish(Guid id)\n        {\n            var biz = User.FindFirst(\"businessId\")?.Value;\n            var user = User.FindFirst(\"name\")?.Value ?? \"system\";\n            if (!Guid.TryParse(biz, out var businessId))\n                return BadRequest(new { message = \"‚ùå Invalid business.\" });\n\n            var result = await _flowService.PublishFlowAsync(id, businessId, user);\n\n            if (result.Success)\n                return Ok(new { message = result.Message ?? \"‚úÖ Flow published.\" });\n\n            var msg = (result.ErrorMessage ?? result.Message ?? \"‚ùå Failed to publish.\").Trim();\n\n            if (result.Code == 404)\n                return NotFound(new { message = msg });\n\n            // Validation failures return 400 with details in payload (issue list)\n            if (result.Code == 400)\n                return BadRequest(new { message = msg, issues = result.Payload });\n\n            return BadRequest(new { message = msg });\n        }\n\n        // DELETE (only if not attached)\n        [HttpDelete(\"{id:guid}\")]\n        public async Task<IActionResult> Delete(Guid id)\n        {\n            var biz = User.FindFirst(\"businessId\")?.Value;\n            if (!Guid.TryParse(biz, out var businessId))\n                return BadRequest(new { message = \"‚ùå Invalid business.\" });\n\n            var deletedBy = User.FindFirst(\"name\")?.Value\n                          ?? User.FindFirst(\"email\")?.Value\n                          ?? User.FindFirst(\"sub\")?.Value\n                          ?? \"system\";\n\n            var result = await _flowService.DeleteFlowAsync(id, businessId, deletedBy);\n\n            if (!result.Success)\n            {\n                var msg = (result.ErrorMessage ?? result.Message ?? string.Empty).Trim();\n\n                // If message says it's attached, return 409 and include campaigns for the modal\n                if (msg.Contains(\"attached\", StringComparison.OrdinalIgnoreCase) ||\n                    msg.Contains(\"Cannot delete\", StringComparison.OrdinalIgnoreCase))\n                {\n                    var campaigns = await _flowService.GetAttachedCampaignsAsync(id, businessId);\n                    return Conflict(new { message = msg, campaigns });\n                }\n\n                if (msg.Contains(\"not found\", StringComparison.OrdinalIgnoreCase))\n                    return NotFound(new { message = msg });\n\n                return BadRequest(new { message = string.IsNullOrWhiteSpace(msg) ? \"Delete failed.\" : msg });\n            }\n\n            return Ok(new { message = result.Message ?? \"‚úÖ Flow deleted.\" });\n        }\n\n        // LISTS\n        [HttpGet(\"all-published\")]\n        public async Task<IActionResult> GetPublishedFlows()\n        {\n            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n            if (!Guid.TryParse(businessIdClaim, out var businessId))\n                return BadRequest(new { message = \"‚ùå Invalid business ID\" });\n\n            var flows = await _flowService.GetAllPublishedFlowsAsync(businessId);\n            return Ok(flows);\n        }\n\n        [HttpGet(\"all-draft\")]\n        public async Task<IActionResult> GetAllDraftFlows()\n        {\n            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n            if (!Guid.TryParse(businessIdClaim, out var businessId))\n                return BadRequest(new { message = \"‚ùå Invalid business ID\" });\n\n            var flows = await _flowService.GetAllDraftFlowsAsync(businessId);\n            return Ok(flows);\n        }\n\n        // DETAIL\n        [HttpGet(\"by-id/{id:guid}\")]\n        public async Task<IActionResult> GetById(Guid id)\n        {\n            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n            if (!Guid.TryParse(businessIdClaim, out var businessId))\n                return BadRequest(new { message = \"‚ùå Invalid business ID\" });\n\n            var dto = await _flowService.GetVisualFlowByIdAsync(id, businessId);\n            if (dto is null) return NotFound(new { message = \"‚ùå Flow not found.\" });\n\n            return Ok(dto);\n        }\n\n        [HttpGet(\"visual/{id:guid}\")]\n        public async Task<IActionResult> GetVisualFlow(Guid id)\n        {\n            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n            if (!Guid.TryParse(businessIdClaim, out var businessId))\n                return BadRequest(new { message = \"‚ùå Invalid business ID\" });\n\n            var result = await _flowService.GetVisualFlowAsync(id, businessId);\n            if (!result.Success)\n            {\n                var m = (result.ErrorMessage ?? string.Empty).Trim();\n                if (m.Contains(\"not found\", StringComparison.OrdinalIgnoreCase))\n                    return NotFound(new { message = \"‚ùå Failed to load flow\", error = m });\n\n                return StatusCode(StatusCodes.Status500InternalServerError,\n                    new { message = \"‚ùå Failed to load flow\", error = string.IsNullOrWhiteSpace(m) ? \"Unknown error\" : m });\n            }\n\n            return Ok(result.Data);\n        }\n\n        // USAGE (for delete guard)\n        [HttpGet(\"{id:guid}/usage\")]\n        public async Task<IActionResult> GetUsage(Guid id)\n        {\n            var biz = User.FindFirst(\"businessId\")?.Value;\n            if (!Guid.TryParse(biz, out var businessId))\n                return BadRequest(new { message = \"Invalid business.\" });\n\n            var campaigns = await _flowService.GetAttachedCampaignsAsync(id, businessId);\n            return Ok(new\n            {\n                canDelete = campaigns.Count == 0,\n                count = campaigns.Count,\n                campaigns\n            });\n        }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Controllers/FlowRedirectController.cs",
      "sha256": "8d5442a0a0fdb92dc7d69837cd74af882b22c6cf35ce999a7b87bfde5b27e7ca",
      "language": "csharp",
      "size": 2686,
      "content": "// üìÑ Features/CTAFlowBuilder/Controllers/FlowRedirectController.cs\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Infrastructure.Flows;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\nusing xbytechat.api.Features.CTAFlowBuilder.Services;\nusing Microsoft.AspNetCore.Authorization;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Controllers\n{\n    [ApiController]\n    [Route(\"r/flow\")]\n    public class FlowRedirectController : ControllerBase\n    {\n        private readonly IFlowClickTokenService _tokens;\n        private readonly ICTAFlowService _flows;           // service to read flow steps/links\n        private readonly IFlowRuntimeService _runtime;     // service to execute next step\n\n        public FlowRedirectController(\n            IFlowClickTokenService tokens,\n            ICTAFlowService flows,\n            IFlowRuntimeService runtime)\n        {\n            _tokens = tokens;\n            _flows = flows;\n            _runtime = runtime;\n        }\n\n        [HttpGet(\"{token}\")]\n        [AllowAnonymous] // secure by token, tenant checks inside\n        public async Task<IActionResult> RedirectByToken(string token)\n        {\n            FlowClickPayload p;\n            try\n            {\n                p = _tokens.Validate(token);\n            }\n            catch (Exception ex)\n            {\n                return BadRequest($\"Invalid or expired token: {ex.Message}\");\n            }\n\n            // üîí Tenant isolation: make sure the business in the token matches the current request context\n            // (if you have multi-tenant enforcement middleware, call it here)\n\n            // 1) Resolve the button link\n            var link = await _flows.GetLinkAsync(p.fid, p.sid, p.bi);\n            if (link is null)\n                return NotFound(\"Link not found for this flow step\");\n\n            var requestId = Guid.NewGuid(); // for idempotency\n            var exec = await _runtime.ExecuteNextAsync(new NextStepContext\n            {\n                BusinessId = p.biz,\n                FlowId = p.fid,\n                Version = p.ver,\n                SourceStepId = p.sid,\n                TargetStepId = link.NextStepId, // may be null ‚Üí terminal\n                ButtonIndex = p.bi,\n                MessageLogId = p.mlid,\n                ContactPhone = p.cp,\n                RequestId = requestId,\n\n                // üÜï Pass the clicked button for runtime decision\n                ClickedButton = link\n            });\n\n\n            // 3) Redirect the user\n            // If button was a URL, use that; else go to a generic \"thank you\" page\n            var dest = exec.RedirectUrl ?? \"/thank-you\";\n            return Redirect(dest);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/AttachedCampaignDto.cs",
      "sha256": "0d3666aab91197bf746299620d01d22712744acbbcb28b0a787a8e399eaf123f",
      "language": "csharp",
      "size": 341,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public sealed record AttachedCampaignDto(\n        Guid Id,\n        string Name,\n        string Status,\n        DateTime? ScheduledAt,\n        DateTime CreatedAt,\n        string? CreatedBy,\n        DateTime? FirstSentAt   // earliest non-null SentAt from CampaignSendLogs\n    );\n\n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/CreateFlowDto.cs",
      "sha256": "c23400a06816a2adc8886fa8d20dd77f12b8b93f993b5a772d81cb12d6612a1f",
      "language": "csharp",
      "size": 897,
      "content": "// üìÑ File: xbytechat.api/Features/CTAFlowBuilder/DTOs/CreateFlowDto.cs\nnamespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class CreateFlowDto\n    {\n        public string FlowName { get; set; } = string.Empty;\n        public List<FlowStepDto> Steps { get; set; } = new();\n        public bool IsPublished { get; set; } = false; // ‚úÖ NEW: Draft vs Published\n    }\n\n    public class FlowStepDto\n    {\n        public string TriggerButtonText { get; set; } = string.Empty;\n        public string TriggerButtonType { get; set; } = string.Empty;\n        public string TemplateToSend { get; set; } = string.Empty;\n        public int StepOrder { get; set; }\n        public List<ButtonLinkDto> ButtonLinks { get; set; } = new();\n    }\n\n    public class ButtonLinkDto\n    {\n        public string ButtonText { get; set; } = string.Empty;\n        public Guid NextStepId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/CTAButtonClickDto.cs",
      "sha256": "da355d853887193eb1d2b3e3fafcf076e6df764f0220cbf10f5c050d42b91df6",
      "language": "csharp",
      "size": 432,
      "content": "using System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class CTAButtonClickDto\n    {\n        [Required]\n        public string ButtonText { get; set; } = string.Empty;\n\n        [Required]\n        public string ButtonType { get; set; } = \"cta\"; // e.g., \"quick_reply\", \"url\", etc.\n\n        [Required]\n        public string RecipientNumber { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/CTAFlowExecutionRequest.cs",
      "sha256": "43fc0e1c1674d188b1a5385539f1314176ff81449d4547ea6665df9909a223bb",
      "language": "csharp",
      "size": 297,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class CTAFlowExecutionRequest\n    {\n        public string ButtonText { get; set; } = string.Empty;\n        public string ButtonType { get; set; } = \"cta\";\n        public string RecipientNumber { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/CtaFlowRunResult.cs",
      "sha256": "2a042b3a78e66a762ca685c50cc13508c063fd3076e291597275bbc64620e6a1",
      "language": "csharp",
      "size": 433,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public sealed class CtaFlowRunResult\n    {\n        /// <summary>\n        /// True if the CTA flow was started/executed successfully.\n        /// </summary>\n        public bool Success { get; set; }\n\n        /// <summary>\n        /// Optional human-readable error message when Success = false.\n        /// </summary>\n        public string? ErrorMessage { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/FlowEdgeDto.cs",
      "sha256": "27e76e22a8aba502d5727d9959bec58ea011d2a1f0d4388a141bfa8108043eea",
      "language": "csharp",
      "size": 272,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class FlowEdgeDto\n    {\n        public string FromNodeId { get; set; } = string.Empty;\n        public string ToNodeId { get; set; } = string.Empty;\n        public string? SourceHandle { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/FlowNodeDto.cs",
      "sha256": "8f6c4dce253e5e1d8afba5c757038643eb14fc9e168c85cb2c9f5314d5b10834",
      "language": "csharp",
      "size": 1832,
      "content": "    namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class FlowNodeDto\n    {\n        public string Id { get; set; } = string.Empty;\n\n        public string TemplateName { get; set; } = string.Empty;\n        public string? TemplateType { get; set; } // ‚úÖ e.g., \"image_template\", \"text_template\"\n\n        // For templates with a media header (image/video/document), this URL is required at runtime.\n        public string? HeaderMediaUrl { get; set; }\n\n        // Optional static values for BODY placeholders ({{1}},{{2}},...). Stored as a list where index 0 => {{1}}.\n        public List<string> BodyParams { get; set; } = new();\n\n        // Optional static values for dynamic URL button params. Index 0 => button index \"0\" (position 1).\n        // Only used when the template has URL buttons with ParameterValue like \"https://.../{{1}}\".\n        public List<string> UrlButtonParams { get; set; } = new();\n\n        public string MessageBody { get; set; } = string.Empty;\n        public string? TriggerButtonText { get; set; }\n        public string? TriggerButtonType { get; set; }\n        public float PositionX { get; set; }\n        public float PositionY { get; set; }\n\n        public string? RequiredTag { get; set; }         \n        public string? RequiredSource { get; set; }      \n        public List<LinkButtonDto> Buttons { get; set; } = new();\n        public bool UseProfileName { get; set; }\n        public int? ProfileNameSlot { get; set; }\n        //(for flow trigger mapping)\n        // ‚úÖ NEW: ReactFlow expects this structure\n        public PositionDto Position => new PositionDto\n        {\n            x = PositionX,\n            y = PositionY\n        };\n        public class PositionDto\n        {\n            public float x { get; set; }\n            public float y { get; set; }\n        }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/FlowUpdateResult.cs",
      "sha256": "54f722166617e3353652e949aa4a89c87878d4a1d30d2e208a1fb816668d0dde",
      "language": "csharp",
      "size": 443,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public sealed class FlowUpdateResult\n    {\n        // ok | requiresFork | notFound | error\n        public string Status { get; set; } = \"ok\";\n        public string? Message { get; set; }\n        public bool NeedsRepublish { get; set; } // true when we flipped published->draft to allow editing\n        public object? Campaigns { get; set; }   // list for UI when requiresFork\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/LinkButtonDto.cs",
      "sha256": "e02e2c927a96e1e02c0537fb205fd7595289bdfaa9de15c0d7a55de64a90fbc5",
      "language": "csharp",
      "size": 522,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class LinkButtonDto\n    {\n        public string Text { get; set; } = string.Empty;\n        public int Index { get; set; } = -1;\n        public string? Type { get; set; } // üî• e.g., \"URL\", \"QUICK_REPLY\"\n        public string? SubType { get; set; } // üî• e.g., \"STATIC\", \"DYNAMIC\"\n        public string? Value { get; set; } // üî• the parameter or url or payload\n\n        public string? TargetNodeId { get; set; } // üîÑ used for flow linking\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/SaveVisualFlowDto.cs",
      "sha256": "7de59d222a97efeaf9dc23dea2ef351d852087539cec12e7c946b02e11f1bd21",
      "language": "csharp",
      "size": 403,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class SaveVisualFlowDto\n    {\n        public string FlowName { get; set; } = string.Empty;\n        public bool IsPublished { get; set; }\n\n        public List<FlowNodeDto> Nodes { get; set; } = new();\n        public List<FlowEdgeDto> Edges { get; set; } = new();\n        public Guid? CampaignId { get; set; } // ‚úÖ Add this line\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/VisualFlowLoadDto.cs",
      "sha256": "10bfe378ffd4c8fb74a0746f2abafec88897072e7a974d680396bde281aaf4af",
      "language": "csharp",
      "size": 289,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class VisualFlowLoadDto\n    {\n        public string FlowName { get; set; } = string.Empty;\n        public List<FlowNodeDto> Nodes { get; set; } = new();\n        public List<FlowEdgeDto> Edges { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/VisualFlowSummaryDto.cs",
      "sha256": "70dcedd3219a474a4b38927e0f0fd4ff3e21ba16632d409f146a9d0d60d685a5",
      "language": "csharp",
      "size": 300,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class VisualFlowSummaryDto\n    {\n        public Guid Id { get; set; }\n        public string FlowName { get; set; } = string.Empty;\n        public bool IsPublished { get; set; }\n        public DateTime CreatedAt { get; set; }\n    }\n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Models/CTAFlowClickLog.cs",
      "sha256": "ecbd408e613e8ef88e2bb39fdf60bc188163e209d8242317203dfb2bff8cebb8",
      "language": "csharp",
      "size": 104,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.Models\n{\n    public class CTAFlowClickLog\n    {\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Models/CTAFlowConfig.cs",
      "sha256": "a36019c3ace9f06dcc785152a4ea8e2acc280b169f9e831a28fd6efd2f9d2551",
      "language": "csharp",
      "size": 3404,
      "content": "// üìÑ File: xbytechat.api/Features/CTAFlowBuilder/Models/CTAFlowConfig.cs\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\nusing System.Text.Json.Serialization;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Models\n{\n    /// <summary>\n    /// Represents a complete flow configuration for a business, such as \"Interested Journey\".\n    /// </summary>\n    public class CTAFlowConfig\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        [Required]\n        public Guid BusinessId { get; set; }\n\n        [Required]\n        [MaxLength(100)]\n        public string FlowName { get; set; } = string.Empty;\n\n        public bool IsActive { get; set; } = true;\n\n        public bool IsPublished { get; set; } = false; // ‚úÖ NEW: Support draft/published\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n        public string? CreatedBy { get; set; }\n        public DateTime? UpdatedAt { get; set; }  // ‚úÖ Add this line\n\n        // üîÅ Navigation to steps\n        public ICollection<CTAFlowStep> Steps { get; set; } = new List<CTAFlowStep>();\n    }\n}\n\n// üìÑ File: xbytechat.api/Features/CTAFlowBuilder/Models/CTAFlowConfig.cs\n//using System.ComponentModel.DataAnnotations;\n//using System.Text.Json.Serialization;\n//using Microsoft.EntityFrameworkCore;\n\n//namespace xbytechat.api.Features.CTAFlowBuilder.Models\n//{\n//    /// <summary>\n//    /// Represents a complete flow configuration for a business, such as \"Interested Journey\".\n//    /// </summary>\n//    [Index(nameof(BusinessId), nameof(IsActive), nameof(FlowName), Name = \"ix_ctaflowconfigs_biz_active_name\")]\n//    [Index(nameof(BusinessId), nameof(IsPublished), Name = \"ix_ctaflowconfigs_biz_published\")]\n//    public class CTAFlowConfig\n//    {\n//        [Key]\n//        public Guid Id { get; set; }\n\n//        [Required]\n//        public Guid BusinessId { get; set; }\n\n//        [Required, MaxLength(100)]\n//        public string FlowName { get; set; } = string.Empty;\n\n//        /// <summary>\n//        /// Soft ‚Äúenabled/disabled‚Äù flag for listing/selection. We still hard-delete unused flows on request.\n//        /// </summary>\n//        public bool IsActive { get; set; } = true;\n\n//        /// <summary>\n//        /// Draft vs published for the builder.\n//        /// </summary>\n//        public bool IsPublished { get; set; } = false;\n\n//        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n//        public string? CreatedBy { get; set; }\n\n//        /// <summary>\n//        /// Last modification timestamp (updated in service on edits).\n//        /// </summary>\n//        public DateTime? UpdatedAt { get; set; }\n\n//        /// <summary>\n//        /// Optimistic concurrency token to avoid race conditions (e.g., editing while someone tries to delete).\n//        /// </summary>\n//        [Timestamp]\n//        public byte[]? RowVersion { get; set; }\n\n//        // üîÅ Navigation to steps\n//        // Cascade delete is configured in OnModelCreating:\n//        // modelBuilder.Entity<CTAFlowConfig>()\n//        //   .HasMany(f => f.Steps).WithOne(s => s.Flow)\n//        //   .HasForeignKey(s => s.FlowId)\n//        //   .OnDelete(DeleteBehavior.Cascade);\n//        [JsonIgnore] // prevent huge payloads if you serialize configs somewhere else\n//        public ICollection<CTAFlowStep> Steps { get; set; } = new List<CTAFlowStep>();\n//    }\n//}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Models/CTAFlowStep.cs",
      "sha256": "442a9f56bbf8fefda20cd184a79763eb9f0472ececa17136e35242cbeeef08b9",
      "language": "csharp",
      "size": 2700,
      "content": "// üìÑ File: Features/CTAFlowBuilder/Models/CTAFlowStep.cs\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Models\n{\n    /// <summary>\n    /// Represents a single step in a CTA flow, triggered by a button.\n    /// </summary>\n    public class CTAFlowStep\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        [Required]\n        public Guid CTAFlowConfigId { get; set; }\n\n        [ForeignKey(nameof(CTAFlowConfigId))]\n        public CTAFlowConfig Flow { get; set; } = null!;\n\n        public string TriggerButtonText { get; set; } = string.Empty;\n\n        public string TriggerButtonType { get; set; } = \"cta\"; // e.g., \"quick_reply\"\n\n        public string TemplateToSend { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Optional media URL used when the selected WhatsApp template has a media header (image/video/document).\n        /// Stored per-step so click-triggered CTA sends can resolve media without relying on campaign context.\n        /// </summary>\n        public string? HeaderMediaUrl { get; set; }\n\n        /// <summary>\n        /// JSON array of body parameter values (1-based placeholders) for WhatsApp templates, e.g. [\"Alice\",\"123\"] for {{1}},{{2}}.\n        /// Stored per-step because click-triggered CTA sends don't have campaign-time personalization context.\n        /// </summary>\n        public string? BodyParamsJson { get; set; }\n\n        /// <summary>\n        /// JSON array of URL-button parameter values (max 3). Index 0 => button index \"0\" (position 1), etc.\n        /// Used only for templates with dynamic URL buttons (ParameterValue contains \"{{n}}\").\n        /// Stored per-step so CTA runtime can satisfy Meta's required button parameters on click-triggered sends.\n        /// </summary>\n        public string? UrlButtonParamsJson { get; set; }\n\n        public int StepOrder { get; set; }\n\n        public string? RequiredTag { get; set; }        // e.g., \"interested\"\n        public string? RequiredSource { get; set; }     // e.g., \"ads\", \"qr\", \"manual\"\n\n        // üîÄ Multiple buttons linking to different steps\n        public List<FlowButtonLink> ButtonLinks { get; set; } = new();\n\n        public float? PositionX { get; set; }\n        public float? PositionY { get; set; }\n        public string? TemplateType { get; set; }\n\n        // ‚úÖ Use WhatsApp Profile Name in this step's template?\n        public bool UseProfileName { get; set; } = false;\n\n        // ‚úÖ 1-based placeholder index in the template body (e.g., {{1}})\n        public int? ProfileNameSlot { get; set; } = 1;\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Models/FlowButtonLink.cs",
      "sha256": "6b265bc48b8286ca84e5937f9f8f6fe99b8b6580ca59a43aedda8290fc685aaa",
      "language": "csharp",
      "size": 807,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.Models\n{\n    public class FlowButtonLink\n    {\n        public Guid Id { get; set; } = Guid.NewGuid();\n        public string ButtonText { get; set; } = string.Empty;\n        public Guid? NextStepId { get; set; }\n        // ‚úÖ NEW FIELDS FOR FUTURE AUTOMATION\n        public string ButtonType { get; set; } = \"QUICK_REPLY\";    // e.g., URL, QUICK_REPLY, FLOW\n        public string ButtonSubType { get; set; } = \"\";            // Optional: e.g., \"Catalog\", \"PricingCTA\"\n        public string ButtonValue { get; set; } = \"\";              // e.g., URL or deep link\n\n        // Optional FK back to Step if needed\n        public Guid CTAFlowStepId { get; set; }\n        public CTAFlowStep? Step { get; set; }\n\n        public short ButtonIndex { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Models/FlowExecutionContext.cs",
      "sha256": "3b09934afbf7d4d7844c890fde23a96a3ba4d932fa506268da131b78ac6b5385",
      "language": "csharp",
      "size": 4023,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Models\n{\n    /// <summary>\n    /// Canonical context/payload for logging a single flow step execution.\n    /// This wraps all the information we want to write into FlowExecutionLogs.\n    /// </summary>\n    public sealed class FlowExecutionContext\n    {\n        /// <summary>\n        /// Tenant / business that owns this flow execution.\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// Optional contact this journey is associated with.\n        /// </summary>\n        public Guid? ContactId { get; set; }   // üëà ADD THIS\n\n        /// <summary>\n        /// Which engine started this journey (Campaign, AutoReply, etc.).\n        /// </summary>\n        public FlowExecutionOrigin Origin { get; set; } = FlowExecutionOrigin.Unknown;\n\n        /// <summary>\n        /// Logical flow definition. For CTA flows this is CTAFlowConfig.Id.\n        /// </summary>\n        public Guid? FlowId { get; set; }\n\n        /// <summary>\n        /// Step being executed.\n        /// </summary>\n        public Guid StepId { get; set; }\n\n        /// <summary>\n        /// Optional friendly name for the step.\n        /// </summary>\n        public string? StepName { get; set; }\n\n        /// <summary>\n        /// Optional correlation id for one \"run\" of a journey.\n        /// Multiple steps in the same journey can share RunId.\n        /// </summary>\n        public Guid? RunId { get; set; }\n\n        /// <summary>\n        /// Optional higher-level campaign this journey belongs to.\n        /// </summary>\n        public Guid? CampaignId { get; set; }\n\n        /// <summary>\n        /// Optional AutoReplyFlow id when journey started from keyword matching.\n        /// </summary>\n        public Guid? AutoReplyFlowId { get; set; }\n\n        /// <summary>\n        /// Optional specific send log (CampaignSendLog) if this was tied to a blast.\n        /// </summary>\n        public Guid? CampaignSendLogId { get; set; }\n\n        /// <summary>\n        /// Optional tracking log id (CTA click tracking, etc.).\n        /// </summary>\n        public Guid? TrackingLogId { get; set; }\n\n        /// <summary>\n        /// Optional link to underlying MessageLog row.\n        /// </summary>\n        public Guid? MessageLogId { get; set; }\n\n        /// <summary>\n        /// Phone number in E.164 form that this step is interacting with.\n        /// </summary>\n        public string? ContactPhone { get; set; }\n\n        /// <summary>\n        /// Human-readable label of the button that triggered the step, if any.\n        /// </summary>\n        public string? TriggeredByButton { get; set; }\n\n        /// <summary>\n        /// Index of the clicked button (0..2) where applicable.\n        /// </summary>\n        public short? ButtonIndex { get; set; }\n\n        /// <summary>\n        /// Template name that was used in this step (if any).\n        /// </summary>\n        public string? TemplateName { get; set; }\n\n        /// <summary>\n        /// Template type / category (e.g. \"image_template\", \"text_template\").\n        /// </summary>\n        public string? TemplateType { get; set; }\n\n        /// <summary>\n        /// Per-request correlation id (can come from message engine, HTTP request, etc.).\n        /// </summary>\n        public Guid? RequestId { get; set; }\n\n        /// <summary>\n        /// Whether the step action completed successfully.\n        /// </summary>\n        public bool Success { get; set; }\n\n        /// <summary>\n        /// Error message when the step failed.\n        /// </summary>\n        public string? ErrorMessage { get; set; }\n\n        /// <summary>\n        /// Raw provider response or internal payload for debugging.\n        /// </summary>\n        public string? RawResponse { get; set; }\n\n        /// <summary>\n        /// When the step was executed (UTC).\n        /// If null, the logger will default to DateTime.UtcNow.\n        /// </summary>\n        public DateTime? ExecutedAtUtc { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Models/FlowExecutionLog.cs",
      "sha256": "d859aa17be20179548d281edae56a6d0fb7b5321f5bd49144ada2ba82ad8e5a4",
      "language": "csharp",
      "size": 1635,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Models\n{\n    /// <summary>\n    /// Logs when a visual flow step is executed (useful for analytics, debugging, audit).\n    /// </summary>\n    public class FlowExecutionLog\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        public Guid? RunId { get; set; }\n        [Required]\n        public Guid BusinessId { get; set; }\n\n        [Required]\n        public Guid StepId { get; set; }\n        public string StepName { get; set; } = string.Empty;\n\n        public Guid? FlowId { get; set; }\n\n        public FlowExecutionOrigin Origin { get; set; } = FlowExecutionOrigin.Unknown; //new\n\n        public Guid? CampaignId { get; set; } // new \n        public Guid? AutoReplyFlowId { get; set; } // new\n\n        public Guid? CampaignSendLogId { get; set; }\n\n\n        public Guid? TrackingLogId { get; set; }\n\n        public string? ContactPhone { get; set; }\n\n        public string? TriggeredByButton { get; set; }\n\n        public string? TemplateName { get; set; }\n\n        public string? TemplateType { get; set; }\n\n        public bool Success { get; set; }\n\n        public string? ErrorMessage { get; set; }\n\n        public string? RawResponse { get; set; }\n\n        public DateTime ExecutedAt { get; set; } = DateTime.UtcNow;\n\n        public Guid? MessageLogId { get; set; }              // tie to originating message\n        public short? ButtonIndex { get; set; }              // which button was clicked (0..2)\n        public Guid? RequestId { get; set; }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Models/FlowExecutionOrigin.cs",
      "sha256": "34b36adc1c0b157360c81e219a5fc265c18612efb937a62fcbea1405a41280a7",
      "language": "csharp",
      "size": 1131,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Models\n{\n    /// <summary>\n    /// Describes where a flow execution was started from.\n    /// This is the key for analytics segmentation.\n    /// </summary>\n    public enum FlowExecutionOrigin\n    {\n        /// <summary>\n        /// Default / legacy rows before origin tracking was introduced.\n        /// </summary>\n        Unknown = 0,\n\n        /// <summary>\n        /// Flow started as part of a Campaign CTA (button click, deep link, etc.).\n        /// </summary>\n        Campaign = 1,\n\n        /// <summary>\n        /// Flow started from AutoReply word matching (keyword ‚Üí flow).\n        /// </summary>\n        AutoReply = 2,\n\n        /// <summary>\n        /// Flow started from a future ‚ÄúJourneyBot‚Äù or similar orchestration engine.\n        /// </summary>\n        JourneyBot = 3,\n\n        /// <summary>\n        /// Flow started manually from Inbox or agent tools.\n        /// </summary>\n        Inbox = 4,\n\n        /// <summary>\n        /// System-driven or other internal triggers (backfill, test, etc.).\n        /// </summary>\n        System = 5\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Services/CtaFlowRuntimeService.cs",
      "sha256": "380d5227b25215b5baaf9496aa9410b6dbec2b75c883bf875ec25f707dd0b5d6",
      "language": "csharp",
      "size": 19163,
      "content": "// üìÑ xbytechat-api/Features/CTAFlowBuilder/Services/CtaFlowRuntimeService.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api; // üëà Keep this if AppDbContext is in the root namespace\n// If AppDbContext lives under xbytechat.api.Data, then use:\n// using xbytechat.api.Data;\n\nusing xbytechat.api.Features.CTAFlowBuilder.DTOs;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.MessagesEngine.Enums;\nusing xbytechat.api.Features.MessagesEngine.Services;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Services\n{\n    /// <summary>\n    /// Minimal CTA flow runtime engine (v1).\n    ///\n    /// Responsibilities:\n    /// - Load CTAFlowConfig + steps from DB.\n    /// - Execute the first step (template send) using IMessageEngineService.\n    /// - Log the execution into FlowExecutionLogs via IFlowExecutionLogger.\n    ///\n    /// It uses FlowExecutionOrigin + AutoReplyFlowId / CampaignId so analytics\n    /// can later separate:\n    ///   - \"CTA flow started by AutoReply\"\n    ///   - \"CTA flow started by Campaign button\"\n    ///   - other origins (JourneyBot, Inbox, System).\n    /// </summary>\n    public sealed class CtaFlowRuntimeService : ICtaFlowRuntimeService\n    {\n        private readonly AppDbContext _db;\n        private readonly IMessageEngineService _messageEngine;\n        private readonly IFlowExecutionLogger _flowLogger;\n        private readonly ILogger<CtaFlowRuntimeService> _logger;\n\n        public CtaFlowRuntimeService(\n            AppDbContext db,\n            IMessageEngineService messageEngine,\n            IFlowExecutionLogger flowLogger,\n            ILogger<CtaFlowRuntimeService> logger)\n        {\n            _db = db ?? throw new ArgumentNullException(nameof(db));\n            _messageEngine = messageEngine ?? throw new ArgumentNullException(nameof(messageEngine));\n            _flowLogger = flowLogger ?? throw new ArgumentNullException(nameof(flowLogger));\n            _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n        }\n\n        public async Task<CtaFlowRunResult> StartFlowAsync(\n            Guid businessId,\n            Guid contactId,\n            string contactPhone,\n            Guid configId,\n            FlowExecutionOrigin origin,\n            Guid? autoReplyFlowId,\n            CancellationToken cancellationToken = default)\n        {\n            if (businessId == Guid.Empty)\n                throw new ArgumentException(\"businessId is required\", nameof(businessId));\n            if (configId == Guid.Empty)\n                throw new ArgumentException(\"configId is required\", nameof(configId));\n            if (string.IsNullOrWhiteSpace(contactPhone))\n                throw new ArgumentException(\"contactPhone is required\", nameof(contactPhone));\n\n            _logger.LogInformation(\n                \"üöÄ [CTAFlowRuntime] StartFlowAsync Biz={BusinessId}, Contact={ContactId}, Phone={Phone}, Config={ConfigId}, Origin={Origin}, AutoReplyFlowId={AutoReplyFlowId}\",\n                businessId,\n                contactId,\n                contactPhone,\n                configId,\n                origin,\n                autoReplyFlowId);\n\n            // 1Ô∏è‚É£ Load the CTA flow (must be active + published) with its steps\n            var flow = await _db.CTAFlowConfigs\n                .AsNoTracking()\n                .Include(f => f.Steps)\n                .FirstOrDefaultAsync(\n                    f => f.Id == configId\n                         && f.BusinessId == businessId\n                         && f.IsActive\n                         && f.IsPublished,\n                    cancellationToken);\n\n            if (flow == null)\n            {\n                var message =\n                    $\"CTA flow {configId} for business {businessId} not found, inactive, or not published.\";\n\n                _logger.LogWarning(\"[CTAFlowRuntime] {Message}\", message);\n\n                // Log a failed \"meta-step\" so analytics can see the failure\n                var failCtx = new FlowExecutionContext\n                {\n                    BusinessId = businessId,\n                    FlowId = configId,\n                    AutoReplyFlowId = autoReplyFlowId,\n                    Origin = origin,\n\n                    // NEW: log which contact we tried to start for\n                    ContactId = contactId,\n                    ContactPhone = contactPhone,\n\n                    StepId = configId,          // no specific step; use flow id as placeholder\n                    StepName = \"FLOW_NOT_FOUND\",\n\n                    // No template here\n                    TemplateName = null,\n                    TemplateType = null,\n\n                    Success = false,\n                    ErrorMessage = message,\n                    ExecutedAtUtc = DateTime.UtcNow\n                };\n\n                await _flowLogger.LogStepAsync(failCtx, cancellationToken);\n\n                return new CtaFlowRunResult\n                {\n                    Success = false,\n                    ErrorMessage = message\n                };\n            }\n\n            // 2Ô∏è‚É£ Pick the first step (v1 = simple linear flow)\n            var firstStep = flow.Steps\n                .OrderBy(s => s.StepOrder)\n                .FirstOrDefault();\n\n            if (firstStep == null)\n            {\n                var message =\n                    $\"CTA flow {flow.Id} ('{flow.FlowName}') has no steps configured.\";\n\n                _logger.LogWarning(\"[CTAFlowRuntime] {Message}\", message);\n\n                var failCtx = new FlowExecutionContext\n                {\n                    BusinessId = businessId,\n                    FlowId = flow.Id,\n                    AutoReplyFlowId = autoReplyFlowId,\n                    Origin = origin,\n\n                    // NEW: log contact context even on failure\n                    ContactId = contactId,\n                    ContactPhone = contactPhone,\n\n                    StepId = flow.Id,\n                    StepName = \"NO_STEPS\",\n\n                    TemplateName = null,\n                    TemplateType = null,\n\n                    Success = false,\n                    ErrorMessage = message,\n                    ExecutedAtUtc = DateTime.UtcNow\n                };\n\n                await _flowLogger.LogStepAsync(failCtx, cancellationToken);\n\n                return new CtaFlowRunResult\n                {\n                    Success = false,\n                    ErrorMessage = message\n                };\n            }\n\n            _logger.LogInformation(\n                \"[CTAFlowRuntime] Executing first step {StepId} ({Template}) of flow {FlowId} ('{FlowName}')\",\n                firstStep.Id,\n                firstStep.TemplateToSend,\n                flow.Id,\n                flow.FlowName);\n\n            // 3Ô∏è‚É£ Build SimpleTemplateMessageDto with CTA tracking fields\n            var templateDto = new SimpleTemplateMessageDto\n            {\n                RecipientNumber = contactPhone,\n                TemplateName = firstStep.TemplateToSend,\n\n                // v1: no dynamic params here ‚Äì flows can be extended later\n                TemplateParameters = new List<string>(),\n\n                // v1: let MessageEngine choose routing / provider\n                HasStaticButtons = false,\n                Provider = string.Empty,\n                PhoneNumberId = null,\n\n                // üîó Link back to CTA flow config + step\n                CTAFlowConfigId = flow.Id,\n                CTAFlowStepId = firstStep.Id,\n\n                // Optional fields ‚Äì keep null for now\n                TemplateBody = null,\n                LanguageCode = null\n            };\n\n            // 4Ô∏è‚É£ Send the message via MessageEngine (conversational ‚Üí Immediate)\n            var sendResult = await _messageEngine\n                .SendTemplateMessageSimpleAsync(\n                    businessId,\n                    templateDto,\n                    DeliveryMode.Immediate);\n\n            // 5Ô∏è‚É£ Log the step into FlowExecutionLogs\n            var logCtx = new FlowExecutionContext\n            {\n                BusinessId = businessId,\n                FlowId = flow.Id,\n                AutoReplyFlowId = autoReplyFlowId,\n                Origin = origin,\n\n                // Contact context\n                ContactId = contactId,\n                ContactPhone = contactPhone,\n\n                // Step context\n                StepId = firstStep.Id,\n                StepName = firstStep.TemplateToSend,\n\n                // Template metadata for analytics\n                TemplateName = firstStep.TemplateToSend,\n                TemplateType = firstStep.TemplateType ?? \"CTA_FLOW_TEMPLATE\",\n\n                // Result\n                Success = sendResult.Success,\n                ErrorMessage = sendResult.Success ? null : sendResult.Message,\n                ExecutedAtUtc = DateTime.UtcNow\n\n                // MessageLogId, CatalogClickLogId, CampaignId, etc.\n                // can be wired later once message engine returns those ids.\n            };\n\n            await _flowLogger.LogStepAsync(logCtx, cancellationToken);\n\n            return new CtaFlowRunResult\n            {\n                Success = sendResult.Success,\n                ErrorMessage = sendResult.Success ? null : sendResult.Message\n            };\n        }\n    }\n}\n\n\n//// üìÑ xbytechat-api/Features/CTAFlowBuilder/Services/CtaFlowRuntimeService.cs\n//using System;\n//using System.Collections.Generic;\n//using System.Linq;\n//using System.Threading;\n//using System.Threading.Tasks;\n//using Microsoft.EntityFrameworkCore;\n//using Microsoft.Extensions.Logging;\n//using xbytechat.api; // üëà Keep this if AppDbContext is in the root namespace\n//// If AppDbContext lives under xbytechat.api.Data, then use:\n//// using xbytechat.api.Data;\n\n//using xbytechat.api.Features.CTAFlowBuilder.DTOs;\n//using xbytechat.api.Features.CTAFlowBuilder.Models;\n//using xbytechat.api.Features.MessagesEngine.DTOs;\n//using xbytechat.api.Features.MessagesEngine.Services;\n\n//namespace xbytechat.api.Features.CTAFlowBuilder.Services\n//{\n//    /// <summary>\n//    /// Minimal CTA flow runtime engine (v1).\n//    ///\n//    /// Responsibilities:\n//    /// - Load CTAFlowConfig + steps from DB.\n//    /// - Execute the first step (template send) using IMessageEngineService.\n//    /// - Log the execution into FlowExecutionLogs via IFlowExecutionLogger.\n//    ///\n//    /// It uses FlowExecutionOrigin + AutoReplyFlowId / CampaignId so analytics\n//    /// can later separate:\n//    ///   - \"CTA flow started by AutoReply\"\n//    ///   - \"CTA flow started by Campaign button\"\n//    ///   - other origins (JourneyBot, Inbox, System).\n//    /// </summary>\n//    public sealed class CtaFlowRuntimeService : ICtaFlowRuntimeService\n//    {\n//        private readonly AppDbContext _db;\n//        private readonly IMessageEngineService _messageEngine;\n//        private readonly IFlowExecutionLogger _flowLogger;\n//        private readonly ILogger<CtaFlowRuntimeService> _logger;\n\n//        public CtaFlowRuntimeService(\n//            AppDbContext db,\n//            IMessageEngineService messageEngine,\n//            IFlowExecutionLogger flowLogger,\n//            ILogger<CtaFlowRuntimeService> logger)\n//        {\n//            _db = db ?? throw new ArgumentNullException(nameof(db));\n//            _messageEngine = messageEngine ?? throw new ArgumentNullException(nameof(messageEngine));\n//            _flowLogger = flowLogger ?? throw new ArgumentNullException(nameof(flowLogger));\n//            _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n//        }\n\n//        public async Task<CtaFlowRunResult> StartFlowAsync(\n//            Guid businessId,\n//            Guid contactId,\n//            string contactPhone,\n//            Guid configId,\n//            FlowExecutionOrigin origin,\n//            Guid? autoReplyFlowId,\n//            CancellationToken cancellationToken = default)\n//        {\n//            if (businessId == Guid.Empty)\n//                throw new ArgumentException(\"businessId is required\", nameof(businessId));\n//            if (configId == Guid.Empty)\n//                throw new ArgumentException(\"configId is required\", nameof(configId));\n//            if (string.IsNullOrWhiteSpace(contactPhone))\n//                throw new ArgumentException(\"contactPhone is required\", nameof(contactPhone));\n\n//            _logger.LogInformation(\n//                \"üöÄ [CTAFlowRuntime] StartFlowAsync Biz={BusinessId}, Contact={ContactId}, Phone={Phone}, Config={ConfigId}, Origin={Origin}, AutoReplyFlowId={AutoReplyFlowId}\",\n//                businessId,\n//                contactId,\n//                contactPhone,\n//                configId,\n//                origin,\n//                autoReplyFlowId);\n\n//            // 1Ô∏è‚É£ Load the CTA flow (must be active + published) with its steps\n//            var flow = await _db.CTAFlowConfigs\n//                .AsNoTracking()\n//                .Include(f => f.Steps)\n//                .FirstOrDefaultAsync(\n//                    f => f.Id == configId\n//                         && f.BusinessId == businessId\n//                         && f.IsActive\n//                         && f.IsPublished,\n//                    cancellationToken);\n\n//            if (flow == null)\n//            {\n//                var message =\n//                    $\"CTA flow {configId} for business {businessId} not found, inactive, or not published.\";\n\n//                _logger.LogWarning(\"[CTAFlowRuntime] {Message}\", message);\n\n//                // Log a failed \"meta-step\" so analytics can see the failure\n//                var failCtx = new FlowExecutionContext\n//                {\n//                    BusinessId = businessId,\n//                    FlowId = configId,\n//                    AutoReplyFlowId = autoReplyFlowId,\n//                    Origin = origin,\n\n//                    // NEW: log which contact we tried to start for\n//                    ContactId = contactId,\n//                    ContactPhone = contactPhone,\n\n//                    StepId = configId,          // no specific step; use flow id as placeholder\n//                    StepName = \"FLOW_NOT_FOUND\",\n\n//                    // No template here\n//                    TemplateName = null,\n//                    TemplateType = null,\n\n//                    Success = false,\n//                    ErrorMessage = message,\n//                    ExecutedAtUtc = DateTime.UtcNow\n//                };\n\n//                await _flowLogger.LogStepAsync(failCtx, cancellationToken);\n\n//                return new CtaFlowRunResult\n//                {\n//                    Success = false,\n//                    ErrorMessage = message\n//                };\n//            }\n\n//            // 2Ô∏è‚É£ Pick the first step (v1 = simple linear flow)\n//            var firstStep = flow.Steps\n//                .OrderBy(s => s.StepOrder)\n//                .FirstOrDefault();\n\n//            if (firstStep == null)\n//            {\n//                var message =\n//                    $\"CTA flow {flow.Id} ('{flow.FlowName}') has no steps configured.\";\n\n//                _logger.LogWarning(\"[CTAFlowRuntime] {Message}\", message);\n\n//                var failCtx = new FlowExecutionContext\n//                {\n//                    BusinessId = businessId,\n//                    FlowId = flow.Id,\n//                    AutoReplyFlowId = autoReplyFlowId,\n//                    Origin = origin,\n\n//                    // NEW: log contact context even on failure\n//                    ContactId = contactId,\n//                    ContactPhone = contactPhone,\n\n//                    StepId = flow.Id,\n//                    StepName = \"NO_STEPS\",\n\n//                    TemplateName = null,\n//                    TemplateType = null,\n\n//                    Success = false,\n//                    ErrorMessage = message,\n//                    ExecutedAtUtc = DateTime.UtcNow\n//                };\n\n//                await _flowLogger.LogStepAsync(failCtx, cancellationToken);\n\n//                return new CtaFlowRunResult\n//                {\n//                    Success = false,\n//                    ErrorMessage = message\n//                };\n//            }\n\n//            _logger.LogInformation(\n//                \"[CTAFlowRuntime] Executing first step {StepId} ({Template}) of flow {FlowId} ('{FlowName}')\",\n//                firstStep.Id,\n//                firstStep.TemplateToSend,\n//                flow.Id,\n//                flow.FlowName);\n\n//            // 3Ô∏è‚É£ Build SimpleTemplateMessageDto with CTA tracking fields\n//            var templateDto = new SimpleTemplateMessageDto\n//            {\n//                RecipientNumber = contactPhone,\n//                TemplateName = firstStep.TemplateToSend,\n\n//                // v1: no dynamic params here ‚Äì flows can be extended later\n//                TemplateParameters = new List<string>(),\n\n//                // v1: let MessageEngine choose routing / provider\n//                HasStaticButtons = false,\n//                Provider = string.Empty,\n//                PhoneNumberId = null,\n\n//                // üîó Link back to CTA flow config + step\n//                CTAFlowConfigId = flow.Id,\n//                CTAFlowStepId = firstStep.Id,\n\n//                // Optional fields ‚Äì keep null for now\n//                TemplateBody = null,\n//                LanguageCode = null\n//            };\n\n//            // 4Ô∏è‚É£ Send the message via MessageEngine\n//            var sendResult = await _messageEngine\n//                .SendTemplateMessageSimpleAsync(businessId, templateDto);\n\n//            // 5Ô∏è‚É£ Log the step into FlowExecutionLogs\n//            var logCtx = new FlowExecutionContext\n//            {\n//                BusinessId = businessId,\n//                FlowId = flow.Id,\n//                AutoReplyFlowId = autoReplyFlowId,\n//                Origin = origin,\n\n//                // Contact context\n//                ContactId = contactId,\n//                ContactPhone = contactPhone,\n\n//                // Step context\n//                StepId = firstStep.Id,\n//                StepName = firstStep.TemplateToSend,\n\n//                // Template metadata for analytics\n//                TemplateName = firstStep.TemplateToSend,\n//                TemplateType = firstStep.TemplateType ?? \"CTA_FLOW_TEMPLATE\",\n\n//                // Result\n//                Success = sendResult.Success,\n//                ErrorMessage = sendResult.Success ? null : sendResult.Message,\n//                ExecutedAtUtc = DateTime.UtcNow\n\n//                // MessageLogId, CatalogClickLogId, CampaignId, etc.\n//                // can be wired later once message engine returns those ids.\n//            };\n\n//            await _flowLogger.LogStepAsync(logCtx, cancellationToken);\n\n//            return new CtaFlowRunResult\n//            {\n//                Success = sendResult.Success,\n//                ErrorMessage = sendResult.Success ? null : sendResult.Message\n//            };\n//        }\n//    }\n//}\n\n\n"
    }
  ]
}
