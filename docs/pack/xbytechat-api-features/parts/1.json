{
  "name": "xbytechat-api/Features",
  "part": 1,
  "of": 6,
  "generatedAt": "2026-02-11 19:15:17 +00:00",
  "files": [
    {
      "path": "xbytechat-api/Features/AccessControl/BusinessRolePermissions/Controllers/BusinessRolePermissionsController.cs",
      "sha256": "7acb74fa2c5be573a4c15e5416ade17859d09fe4251d30b4f1c714a1799058cd",
      "language": "csharp",
      "size": 2624,
      "content": "using System;\nusing System.Security.Claims;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.AccessControl.BusinessRolePermissions.DTOs;\nusing xbytechat.api.Features.AccessControl.BusinessRolePermissions.Services;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.AccessControl.BusinessRolePermissions.Controllers\n{\n    [ApiController]\n    [Route(\"api/accesscontrol/business-roles/{roleId:guid}/permissions\")]\n    [Authorize]\n    //[Authorize(Policy = Policies.AdminOrOwner)]\n    public sealed class BusinessRolePermissionsController : ControllerBase\n    {\n        private readonly IBusinessRolePermissionsService _service;\n\n        public BusinessRolePermissionsController(IBusinessRolePermissionsService service)\n        {\n            _service = service;\n        }\n\n        private Guid GetBusinessId()\n        {\n            var raw =\n                User.FindFirstValue(\"BusinessId\") ??\n                User.FindFirstValue(\"businessId\") ??\n                User.FindFirstValue(\"bid\");\n\n            if (Guid.TryParse(raw, out var id)) return id;\n\n            throw new UnauthorizedAccessException(\"BusinessId claim missing.\");\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> Get([FromRoute] Guid roleId)\n        {\n            var businessId = GetBusinessId();\n\n            try\n            {\n                var res = await _service.GetAsync(businessId, roleId);\n                return Ok(ResponseResult.SuccessInfo(\"âœ… Role permissions fetched.\", res));\n            }\n            catch (KeyNotFoundException)\n            {\n                return NotFound(ResponseResult.ErrorInfo(\"Role not found.\"));\n            }\n            catch (InvalidOperationException ex)\n            {\n                return Conflict(ResponseResult.ErrorInfo(ex.Message));\n            }\n        }\n\n        [HttpPut]\n        public async Task<IActionResult> Replace([FromRoute] Guid roleId, [FromBody] UpdateBusinessRolePermissionsDto dto)\n        {\n            var businessId = GetBusinessId();\n\n            try\n            {\n                var res = await _service.ReplaceAsync(businessId, roleId, dto);\n                return Ok(ResponseResult.SuccessInfo(\"âœ… Role permissions updated.\", res));\n            }\n            catch (KeyNotFoundException)\n            {\n                return NotFound(ResponseResult.ErrorInfo(\"Role not found.\"));\n            }\n            catch (InvalidOperationException ex)\n            {\n                return Conflict(ResponseResult.ErrorInfo(ex.Message));\n            }\n        }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/BusinessRolePermissions/DTOs/BusinessRolePermissionsDto.cs",
      "sha256": "154b92d362a82f5fe4fce5f6cea860b984076ea48ff02054e3322ef1576b2bbb",
      "language": "csharp",
      "size": 300,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.AccessControl.BusinessRolePermissions.DTOs\n{\n    public sealed class BusinessRolePermissionsDto\n    {\n        public Guid RoleId { get; set; }\n        public List<string> PermissionCodes { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/BusinessRolePermissions/DTOs/UpdateBusinessRolePermissionsDto.cs",
      "sha256": "e4c99a793bd37931757c2cdf76ecf546b58eb99dbe1a6aa0da22761829ad9838",
      "language": "csharp",
      "size": 315,
      "content": "using System.Collections.Generic;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.AccessControl.BusinessRolePermissions.DTOs\n{\n    public sealed class UpdateBusinessRolePermissionsDto\n    {\n        [Required]\n        public List<string> PermissionCodes { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/BusinessRolePermissions/Services/BusinessRolePermissionsService.cs",
      "sha256": "cb7da8667cf3509042541fafda8d111e78d6473c6509f46307c337fd2890024d",
      "language": "csharp",
      "size": 4260,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.AccessControl.BusinessRolePermissions.DTOs;\n\nnamespace xbytechat.api.Features.AccessControl.BusinessRolePermissions.Services\n{\n    public sealed class BusinessRolePermissionsService : IBusinessRolePermissionsService\n    {\n        private readonly AppDbContext _db;\n\n        public BusinessRolePermissionsService(AppDbContext db)\n        {\n            _db = db;\n        }\n\n        public async Task<BusinessRolePermissionsDto> GetAsync(Guid businessId, Guid roleId)\n        {\n            // Ensure role belongs to this business and is not a system role\n            var role = await _db.Roles.AsNoTracking()\n                .Where(r => r.Id == roleId && r.BusinessId == businessId)\n                .Select(r => new { r.Id, r.BusinessId })\n                .FirstOrDefaultAsync();\n\n            if (role == null)\n                throw new KeyNotFoundException(\"Role not found.\");\n\n            if (role.BusinessId == null)\n                throw new InvalidOperationException(\"System role permissions cannot be managed here.\");\n\n            var codes = await _db.RolePermissions.AsNoTracking()\n                .Where(rp => rp.RoleId == roleId)\n                .Join(_db.Permissions.AsNoTracking(),\n                      rp => rp.PermissionId,\n                      p => p.Id,\n                      (rp, p) => p.Code)\n                .Distinct()\n                .OrderBy(x => x)\n                .ToListAsync();\n\n            return new BusinessRolePermissionsDto\n            {\n                RoleId = roleId,\n                PermissionCodes = codes\n            };\n        }\n\n        public async Task<BusinessRolePermissionsDto> ReplaceAsync(Guid businessId, Guid roleId, UpdateBusinessRolePermissionsDto dto)\n        {\n            var role = await _db.Roles\n                .Where(r => r.Id == roleId && r.BusinessId == businessId)\n                .FirstOrDefaultAsync();\n\n            if (role == null)\n                throw new KeyNotFoundException(\"Role not found.\");\n\n            if (role.BusinessId == null)\n                throw new InvalidOperationException(\"System role permissions cannot be managed here.\");\n\n            // Normalize codes (trim + distinct + uppercase optional)\n            var requestedCodes = (dto.PermissionCodes ?? new List<string>())\n                .Select(x => (x ?? \"\").Trim())\n                .Where(x => !string.IsNullOrWhiteSpace(x))\n                .Distinct(StringComparer.OrdinalIgnoreCase)\n                .ToList();\n\n            // Validate permission codes exist\n            var perms = await _db.Permissions.AsNoTracking()\n                .Where(p => requestedCodes.Contains(p.Code))\n                .Select(p => new { p.Id, p.Code })\n                .ToListAsync();\n\n            var foundCodes = perms.Select(p => p.Code).ToHashSet(StringComparer.OrdinalIgnoreCase);\n            var missing = requestedCodes.Where(c => !foundCodes.Contains(c)).ToList();\n            if (missing.Count > 0)\n                throw new InvalidOperationException($\"Unknown permission codes: {string.Join(\", \", missing)}\");\n\n            // Replace mappings in one transaction\n            await using var tx = await _db.Database.BeginTransactionAsync();\n\n            var old = await _db.RolePermissions\n                .Where(rp => rp.RoleId == roleId)\n                .ToListAsync();\n\n            if (old.Count > 0)\n                _db.RolePermissions.RemoveRange(old);\n\n            if (perms.Count > 0)\n            {\n                var newRows = perms.Select(p => new Models.RolePermission\n                {\n                    Id = Guid.NewGuid(),\n                    RoleId = roleId,\n                    PermissionId = p.Id,\n                    AssignedAt = DateTime.UtcNow\n                }).ToList();\n\n                await _db.RolePermissions.AddRangeAsync(newRows);\n            }\n\n            await _db.SaveChangesAsync();\n            await tx.CommitAsync();\n\n            return new BusinessRolePermissionsDto\n            {\n                RoleId = roleId,\n                PermissionCodes = perms.Select(p => p.Code).OrderBy(x => x).ToList()\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/BusinessRolePermissions/Services/IBusinessRolePermissionsService.cs",
      "sha256": "78f9809b6d3b958490dbf89094e2d16d43d1e31ad315d271ebfd847ec4cf2479",
      "language": "csharp",
      "size": 471,
      "content": "using System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.AccessControl.BusinessRolePermissions.DTOs;\n\nnamespace xbytechat.api.Features.AccessControl.BusinessRolePermissions.Services\n{\n    public interface IBusinessRolePermissionsService\n    {\n        Task<BusinessRolePermissionsDto> GetAsync(Guid businessId, Guid roleId);\n        Task<BusinessRolePermissionsDto> ReplaceAsync(Guid businessId, Guid roleId, UpdateBusinessRolePermissionsDto dto);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/BusinessRoles/Controllers/BusinessRolesController.cs",
      "sha256": "449be1b4eefc0b2c89e0fc079845987f1fff9186bfcde58edcfa10546061b994",
      "language": "csharp",
      "size": 3927,
      "content": "using System;\nusing System.Security.Claims;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.AccessControl.BusinessRoles.DTOs;\nusing xbytechat.api.Features.AccessControl.BusinessRoles.Services;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.AccessControl.BusinessRoles.Controllers\n{\n\n    [ApiController]\n    [Route(\"api/accesscontrol/business-roles\")]\n    [Authorize]\n    //[Authorize(Policy = Policies.AdminOrOwner)]\n    public sealed class BusinessRolesController : ControllerBase\n    {\n        private readonly IBusinessRoleService _service;\n\n        public BusinessRolesController(IBusinessRoleService service)\n        {\n            _service = service;\n        }\n\n        // âœ… IMPORTANT:\n        // Replace this with your existing \"get businessId from claims\" helper if you already have one.\n        private Guid GetBusinessId()\n        {\n            var raw =\n                User.FindFirstValue(\"BusinessId\") ??\n                User.FindFirstValue(\"businessId\") ??\n                User.FindFirstValue(\"bid\");\n\n            if (Guid.TryParse(raw, out var id)) return id;\n\n            throw new UnauthorizedAccessException(\"BusinessId claim missing.\");\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> GetAll([FromQuery] bool includeInactive = false)\n        {\n            var businessId = GetBusinessId();\n            var rows = await _service.GetAllAsync(businessId, includeInactive);\n            return Ok(ResponseResult.SuccessInfo(\"âœ… Roles fetched.\", rows));\n        }\n\n        [HttpGet(\"{id:guid}\")]\n        public async Task<IActionResult> GetById([FromRoute] Guid id)\n        {\n            var businessId = GetBusinessId();\n            var row = await _service.GetByIdAsync(businessId, id);\n            if (row == null)\n                return NotFound(ResponseResult.ErrorInfo(\"Role not found.\"));\n            return Ok(ResponseResult.SuccessInfo(\"âœ… Role fetched.\", row));\n        }\n\n        [HttpPost]\n        public async Task<IActionResult> Create([FromBody] BusinessRoleCreateDto dto)\n        {\n            var businessId = GetBusinessId();\n\n            try\n            {\n                var created = await _service.CreateAsync(businessId, dto);\n                return Ok(ResponseResult.SuccessInfo(\"âœ… Role created.\", created));\n            }\n            catch (InvalidOperationException ex)\n            {\n                return Conflict(ResponseResult.ErrorInfo(ex.Message));\n            }\n        }\n\n        [HttpPut(\"{id:guid}\")]\n        public async Task<IActionResult> Update([FromRoute] Guid id, [FromBody] BusinessRoleUpdateDto dto)\n        {\n            var businessId = GetBusinessId();\n\n            try\n            {\n                var updated = await _service.UpdateAsync(businessId, id, dto);\n                return Ok(ResponseResult.SuccessInfo(\"âœ… Role updated.\", updated));\n            }\n            catch (KeyNotFoundException)\n            {\n                return NotFound(ResponseResult.ErrorInfo(\"Role not found.\"));\n            }\n            catch (InvalidOperationException ex)\n            {\n                return Conflict(ResponseResult.ErrorInfo(ex.Message));\n            }\n        }\n\n        [HttpDelete(\"{id:guid}\")]\n        public async Task<IActionResult> Deactivate([FromRoute] Guid id)\n        {\n            var businessId = GetBusinessId();\n\n            try\n            {\n                await _service.DeactivateAsync(businessId, id);\n                return Ok(ResponseResult.SuccessInfo(\"âœ… Role deactivated.\", null));\n            }\n            catch (KeyNotFoundException)\n            {\n                return NotFound(ResponseResult.ErrorInfo(\"Role not found.\"));\n            }\n            catch (InvalidOperationException ex)\n            {\n                return Conflict(ResponseResult.ErrorInfo(ex.Message));\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/BusinessRoles/DTOs/BusinessRoleCreateDto.cs",
      "sha256": "a4473be42d9dc9546ed28cf309bfd9562a1a276e0231c67ac10d9d937147d784",
      "language": "csharp",
      "size": 339,
      "content": "using System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.AccessControl.BusinessRoles.DTOs\n{\n    public sealed class BusinessRoleCreateDto\n    {\n        [Required]\n        [MaxLength(50)]\n        public string Name { get; set; } = \"\";\n\n        [MaxLength(200)]\n        public string? Description { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/BusinessRoles/DTOs/BusinessRoleDto.cs",
      "sha256": "a7659cf36e346e9f869a01332ca13c910e6b30cdecbedbbd73604658ea3fe346",
      "language": "csharp",
      "size": 362,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AccessControl.BusinessRoles.DTOs\n{\n    public sealed class BusinessRoleDto\n    {\n        public Guid Id { get; set; }\n        public string Name { get; set; } = \"\";\n        public string? Description { get; set; }\n        public bool IsActive { get; set; }\n        public DateTime CreatedAt { get; set; }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/BusinessRoles/DTOs/BusinessRoleUpdateDto.cs",
      "sha256": "c783b3bbee6bd149cb7f00ee0a35b15e0eb886bf5fe67e0abcbccbde16008630",
      "language": "csharp",
      "size": 339,
      "content": "using System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.AccessControl.BusinessRoles.DTOs\n{\n    public sealed class BusinessRoleUpdateDto\n    {\n        [Required]\n        [MaxLength(50)]\n        public string Name { get; set; } = \"\";\n\n        [MaxLength(200)]\n        public string? Description { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/BusinessRoles/Services/BusinessRoleService.cs",
      "sha256": "40051f334cd81d618fb6d659ac0ef5d657832b3cedf1367e5b915b63fbe0b5f4",
      "language": "csharp",
      "size": 4855,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.AccessControl.BusinessRoles.DTOs;\nusing xbytechat.api.Features.AccessControl.Models;\nusing xbytechat.api.Models; // Role model lives here in most projects\n\nnamespace xbytechat.api.Features.AccessControl.BusinessRoles.Services\n{\n    public sealed class BusinessRoleService : IBusinessRoleService\n    {\n        private readonly AppDbContext _db;\n\n        public BusinessRoleService(AppDbContext db)\n        {\n            _db = db;\n        }\n\n        public async Task<List<BusinessRoleDto>> GetAllAsync(Guid businessId, bool includeInactive = false)\n        {\n            var q = _db.Roles.AsNoTracking()\n                .Where(r => r.BusinessId == businessId);\n\n            if (!includeInactive)\n                q = q.Where(r => r.IsActive);\n\n            var rows = await q\n                .OrderBy(r => r.Name)\n                .Select(r => new BusinessRoleDto\n                {\n                    Id = r.Id,\n                    Name = r.Name,\n                    Description = r.Description,\n                    IsActive = r.IsActive,\n                    CreatedAt = r.CreatedAt\n                })\n                .ToListAsync();\n\n            return rows;\n        }\n\n        public async Task<BusinessRoleDto?> GetByIdAsync(Guid businessId, Guid roleId)\n        {\n            return await _db.Roles.AsNoTracking()\n                .Where(r => r.Id == roleId && r.BusinessId == businessId)\n                .Select(r => new BusinessRoleDto\n                {\n                    Id = r.Id,\n                    Name = r.Name,\n                    Description = r.Description,\n                    IsActive = r.IsActive,\n                    CreatedAt = r.CreatedAt\n                })\n                .FirstOrDefaultAsync();\n        }\n\n        public async Task<BusinessRoleDto> CreateAsync(Guid businessId, BusinessRoleCreateDto dto)\n        {\n            var name = dto.Name.Trim();\n\n            // Industry-grade: protect system roles (BusinessId == null) from being created/edited here\n            var role = new Role\n            {\n                Id = Guid.NewGuid(),\n                BusinessId = businessId,\n                Name = name,\n                Description = dto.Description?.Trim(),\n                IsActive = true,\n                CreatedAt = DateTime.UtcNow\n            };\n\n            _db.Roles.Add(role);\n\n            try\n            {\n                await _db.SaveChangesAsync();\n            }\n            catch (DbUpdateException)\n            {\n                // Likely your unique index (BusinessId + Name where IsActive=true)\n                throw new InvalidOperationException($\"Role '{name}' already exists.\");\n            }\n\n            return new BusinessRoleDto\n            {\n                Id = role.Id,\n                Name = role.Name,\n                Description = role.Description,\n                IsActive = role.IsActive,\n                CreatedAt = role.CreatedAt\n            };\n        }\n\n        public async Task<BusinessRoleDto> UpdateAsync(Guid businessId, Guid roleId, BusinessRoleUpdateDto dto)\n        {\n            var role = await _db.Roles\n                .Where(r => r.Id == roleId && r.BusinessId == businessId)\n                .FirstOrDefaultAsync();\n\n            if (role == null)\n                throw new KeyNotFoundException(\"Role not found.\");\n\n            // Safety: never allow updating system roles from business endpoints\n            if (role.BusinessId == null)\n                throw new InvalidOperationException(\"System roles cannot be edited.\");\n\n            role.Name = dto.Name.Trim();\n            role.Description = dto.Description?.Trim();\n\n            try\n            {\n                await _db.SaveChangesAsync();\n            }\n            catch (DbUpdateException)\n            {\n                throw new InvalidOperationException($\"Role '{role.Name}' already exists.\");\n            }\n\n            return new BusinessRoleDto\n            {\n                Id = role.Id,\n                Name = role.Name,\n                Description = role.Description,\n                IsActive = role.IsActive,\n                CreatedAt = role.CreatedAt\n            };\n        }\n\n        public async Task DeactivateAsync(Guid businessId, Guid roleId)\n        {\n            var role = await _db.Roles\n                .Where(r => r.Id == roleId && r.BusinessId == businessId)\n                .FirstOrDefaultAsync();\n\n            if (role == null)\n                throw new KeyNotFoundException(\"Role not found.\");\n\n            if (role.BusinessId == null)\n                throw new InvalidOperationException(\"System roles cannot be deactivated.\");\n\n            role.IsActive = false;\n\n            await _db.SaveChangesAsync();\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/BusinessRoles/Services/IBusinessRoleService.cs",
      "sha256": "1279dc57ca820dcd4bcaff73624c9c4df323e5a88375ff7fd0926aff022917fe",
      "language": "csharp",
      "size": 688,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.AccessControl.BusinessRoles.DTOs;\n\nnamespace xbytechat.api.Features.AccessControl.BusinessRoles.Services\n{\n    public interface IBusinessRoleService\n    {\n        Task<List<BusinessRoleDto>> GetAllAsync(Guid businessId, bool includeInactive = false);\n        Task<BusinessRoleDto?> GetByIdAsync(Guid businessId, Guid roleId);\n        Task<BusinessRoleDto> CreateAsync(Guid businessId, BusinessRoleCreateDto dto);\n        Task<BusinessRoleDto> UpdateAsync(Guid businessId, Guid roleId, BusinessRoleUpdateDto dto);\n        Task DeactivateAsync(Guid businessId, Guid roleId);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Controllers/PermissionController.cs",
      "sha256": "f3ef162fea0e7bd86c0bf3b538aad49c8e9e7af7213b4b00adac8b994e3e103f",
      "language": "csharp",
      "size": 3705,
      "content": "// ðŸ“„ Features/AccessControl/Controllers/PermissionController.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.AccessControl.DTOs;\nusing xbytechat.api.Features.AccessControl.Services;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.AccessControl.Controllers\n{\n    [ApiController]\n    [Route(\"api/permission\")]\n    [Authorize]\n    public class PermissionController : ControllerBase\n    {\n        private readonly IPermissionService _permissionService;\n\n        public PermissionController(IPermissionService permissionService)\n        {\n            _permissionService = permissionService;\n        }\n\n        // --- Existing grouped endpoint (kept for compatibility) ---\n        // GET /api/permission/grouped\n        [HttpGet(\"grouped\")]\n        public async Task<IActionResult> GetGroupedPermissions(CancellationToken ct)\n        {\n            var grouped = await _permissionService.GetGroupedPermissionsAsync();\n            return Ok(ResponseResult.SuccessInfo(\"Permissions grouped by category\", grouped));\n        }\n\n        // --- New CRUD endpoints used by PermissionsPage ---\n\n        // GET /api/permission\n        [HttpGet]\n        [Authorize(Roles = \"superadmin,partneradmin,admin\")]\n        public async Task<ActionResult<IEnumerable<PermissionSummaryDto>>> GetAll(\n            CancellationToken ct)\n        {\n            var list = await _permissionService.GetAllAsync(ct);\n            return Ok(list); // React expects a plain array\n        }\n\n        // POST /api/permission\n        [HttpPost]\n        [Authorize(Roles = \"superadmin,partneradmin,admin\")]\n        public async Task<ActionResult<PermissionSummaryDto>> Create(\n            [FromBody] PermissionUpsertDto dto,\n            CancellationToken ct)\n        {\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(ModelState);\n            }\n\n            try\n            {\n                var created = await _permissionService.CreateAsync(dto, ct);\n                return Ok(created);\n            }\n            catch (InvalidOperationException ex)\n            {\n                return BadRequest(new { message = ex.Message });\n            }\n        }\n\n        // PUT /api/permission/{id}\n        [HttpPut(\"{id:guid}\")]\n        [Authorize(Roles = \"superadmin,partneradmin,admin\")]\n        public async Task<ActionResult<PermissionSummaryDto>> Update(\n            Guid id,\n            [FromBody] PermissionUpsertDto dto,\n            CancellationToken ct)\n        {\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(ModelState);\n            }\n\n            try\n            {\n                var updated = await _permissionService.UpdateAsync(id, dto, ct);\n                return Ok(updated);\n            }\n            catch (KeyNotFoundException)\n            {\n                return NotFound();\n            }\n            catch (InvalidOperationException ex)\n            {\n                return BadRequest(new { message = ex.Message });\n            }\n        }\n\n        // DELETE /api/permission/{id}  (soft delete)\n        [HttpDelete(\"{id:guid}\")]\n        [Authorize(Roles = \"superadmin,partneradmin,admin\")]\n        public async Task<IActionResult> Deactivate(\n            Guid id,\n            CancellationToken ct)\n        {\n            try\n            {\n                await _permissionService.DeactivateAsync(id, ct);\n                return NoContent();\n            }\n            catch (KeyNotFoundException)\n            {\n                return NotFound();\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Controllers/PlanController.cs",
      "sha256": "c92adfe00eb0924a8d179eca1db384ff01b69baa4a632166b2677c4a6bbb4d42",
      "language": "csharp",
      "size": 8014,
      "content": "using Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.AccessControl.DTOs;\nusing xbytechat.api.Features.AccessControl.Services;\nusing xbytechat.api.Helpers; // âœ… For ResponseResult\n\nnamespace xbytechat.api.Features.AccessControl.Controllers\n{\n    [Route(\"api/[controller]\")]\n    [ApiController]\n    [Authorize]\n    public class PlanController : ControllerBase\n    {\n        private readonly IPlanService _planService;\n        private readonly IPermissionCacheService _permissionCacheService;\n        private readonly ILogger<PlanController> _logger;\n        public PlanController(IPlanService planService, IPermissionCacheService permissionCacheService, ILogger<PlanController> logger)\n        {\n            _planService = planService;\n            _permissionCacheService = permissionCacheService;\n            _logger = logger;\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> GetPlans()\n        {\n            try\n            {\n                var plans = await _planService.GetAllPlansAsync();\n                return Ok(plans); // Return plain array\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Failed to load plans\");\n                return BadRequest(new { message = \"Failed to load plans\", error = ex.Message });\n            }\n        }\n\n        [HttpGet(\"{planId}/permissions\")]\n        public async Task<IActionResult> GetPlanPermissions(Guid planId)\n        {\n            try\n            {\n               // var permissions = await _planService.GetPermissionsForPlanAsync(planId);\n                var permissions = await _permissionCacheService.GetPlanPermissionsAsync(planId);\n\n                return Ok(permissions);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Failed to load permissions for plan {PlanId}\", planId);\n                return BadRequest(new { message = \"Failed to load permissions\", error = ex.Message });\n            }\n        }\n\n     \n        [HttpPost(\"Create\")]\n        [Authorize(Roles = \"superadmin,partneradmin,admin\")]\n        public async Task<IActionResult> CreatePlan([FromBody] CreatePlanDto dto)\n        {\n            if (string.IsNullOrWhiteSpace(dto.Code) || string.IsNullOrWhiteSpace(dto.Name))\n                return BadRequest(new { message = \"Code and Name are required\" });\n\n            try\n            {\n                var newPlanId = await _planService.CreatePlanAsync(dto);\n                return Ok(new { id = newPlanId, message = \"Plan created successfully\" });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Failed to create plan {PlanName}\", dto.Name);\n                return BadRequest(new { message = \"Failed to create plan\", error = ex.Message });\n            }\n        }\n\n        [HttpPut(\"{planId}\")]\n        [Authorize(Roles = \"superadmin,partneradmin,admin\")]\n        public async Task<IActionResult> UpdatePlan(Guid planId, [FromBody] UpdatePlanDto dto)\n        {\n            if (string.IsNullOrWhiteSpace(dto.Code) || string.IsNullOrWhiteSpace(dto.Name))\n                return BadRequest(new { message = \"Code and Name are required\" });\n\n            try\n            {\n                var updated = await _planService.UpdatePlanAsync(planId, dto);\n                if (!updated)\n                    return NotFound(new { message = \"Plan not found\" });\n\n                return Ok(new { message = \"Plan updated successfully\" });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Failed to update plan {PlanId}\", planId);\n                return BadRequest(new { message = \"Failed to update plan\", error = ex.Message });\n            }\n        }\n\n        [HttpDelete(\"{planId}\")]\n        [Authorize(Roles = \"superadmin,partneradmin,admin\")]\n        public async Task<IActionResult> DeletePlan(Guid planId)\n        {\n            try\n            {\n                var deleted = await _planService.DeletePlanAsync(planId);\n                if (!deleted)\n                    return NotFound(new { message = \"Plan not found or already inactive\" });\n                // âœ… Clear cache when plan is deleted\n                _permissionCacheService.ClearPlanPermissionsCache(planId);\n                return Ok(new { message = \"Plan deleted successfully\" });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Failed to delete plan {PlanId}\", planId);\n                return BadRequest(new { message = \"Failed to delete plan\", error = ex.Message });\n            }\n        }\n      \n        [HttpGet(\"me/permissions\")]\n        public async Task<IActionResult> GetMyPlanPermissions(CancellationToken ct)\n        {\n            var role = User.FindFirst(\"role\")?.Value ?? string.Empty;\n\n            // Admin-like roles don't need a plan\n            if (role is \"superadmin\" or \"admin\" or \"partner\" or \"reseller\")\n                return Ok(new\n                {\n                    planId = (Guid?)null,\n                    plan = (PlanDto?)null,\n                    permissions = new[] { \"*\" }\n                });\n\n            var planIdStr = User.FindFirst(\"plan_id\")?.Value;\n            if (!Guid.TryParse(planIdStr, out var planId))\n                return Ok(new\n                {\n                    planId = (Guid?)null,\n                    plan = (PlanDto?)null,\n                    permissions = Array.Empty<string>()\n                });\n\n            // permissions (cached)\n            var permissionEntities = await _permissionCacheService.GetPlanPermissionsAsync(planId);\n            var codes = permissionEntities\n                .Where(p => p.IsActive)\n                .Select(p => p.Code)\n                .Distinct()\n                .ToList();\n\n            // âœ… Fetch the plan once and return it as PlanDto\n            var planDto = await _planService.GetByIdAsync(planId, ct);\n\n            return Ok(new\n            {\n                planId,\n                plan = planDto,     // PlanDto or null\n                permissions = codes\n            });\n        }\n\n        // ðŸ“„ Features/AccessControl/Controllers/PlanController.cs\n        //[HttpPut(\"{planId:guid}/permissions\")]\n        //[Authorize(Roles = \"superadmin,partneradmin,admin\")]\n        //public async Task<IActionResult> UpdatePlanPermissions(\n        //    Guid planId,\n        //    [FromBody] UpdatePlanPermissionsRequest body,\n        //    CancellationToken ct)\n        //{\n        //    var actor = User?.Identity?.Name ?? \"system\";\n        //    await _planService.UpdatePlanPermissionsAsync(\n        //        planId,\n        //        body.PermissionIds,     // must be named PermissionIds\n        //        body.ReplaceAll,        // default true\n        //        actor,\n        //        ct);\n\n        //    return NoContent(); // 204\n        //}\n        [HttpPut(\"{planId:guid}/permissions\")]\n        [Authorize(Roles = \"superadmin,partneradmin,admin\")]\n        public async Task<IActionResult> UpdatePlanPermissions(\n    Guid planId,\n    [FromBody] UpdatePlanPermissionsRequest body,\n    CancellationToken ct)\n        {\n            var actor = User?.Identity?.Name ?? \"system\";\n\n            await _planService.UpdatePlanPermissionsAsync(\n                planId,\n                body.PermissionIds,\n                body.ReplaceAll,\n                actor,\n                ct);\n\n            // âœ… CRITICAL: clear cache so changes apply instantly\n            _permissionCacheService.ClearPlanPermissionsCache(planId);\n\n            return NoContent(); // 204\n        }\n\n        // ðŸ“„ Features/AccessControl/DTOs/UpdatePlanPermissionsRequest.cs\n        public sealed class UpdatePlanPermissionsRequest\n        {\n            public List<Guid> PermissionIds { get; set; } = new();\n            public bool ReplaceAll { get; set; } = true;\n        }\n\n\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Controllers/UserPermissionsController.cs",
      "sha256": "950672bd933736c854e3a9e88b13449a6458b03a05c906c78e9c5916d8c48787",
      "language": "csharp",
      "size": 7589,
      "content": "#nullable enable\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.AuthModule.Models;\nusing xbytechat.api.Features.AccessControl.Models;\n\nnamespace xbytechat.api.Features.AccessControl.Controllers\n{\n    /// <summary>\n    /// Manage per-user permission overrides.\n    ///\n    /// Important:\n    /// - We do NOT calculate effective permissions here.\n    ///   Plan â†’ permissions is handled by Plan/AccessControl services.\n    /// - This controller only manages rows in UserPermission (allow/deny overrides).\n    ///   The UI can merge:\n    ///     a) plan permissions  + \n    ///     b) these overrides\n    ///   to show the final state for each feature.\n    /// </summary>\n    [ApiController]\n    [Route(\"api/admin/users/{userId:guid}/permissions\")]\n    [Authorize(Roles = \"admin\")]\n    public sealed class UserPermissionsController : ControllerBase\n    {\n        private readonly AppDbContext _db;\n\n        public UserPermissionsController(AppDbContext db)\n        {\n            _db = db;\n        }\n\n        // --------- DTOs (you can later move them to Features/AccessControl/DTOs) ---------\n\n        public sealed class UserPermissionOverrideDto\n        {\n            public Guid PermissionId { get; set; }\n            public string Code { get; set; } = string.Empty;\n            public string Name { get; set; } = string.Empty;\n\n            /// <summary>\n            /// true  = explicit allow\n            /// false = explicit deny\n            /// </summary>\n            public bool IsGranted { get; set; }\n\n            /// <summary>\n            /// true  = override is logically removed (soft delete)\n            /// false = active override\n            /// </summary>\n            public bool IsRevoked { get; set; }\n\n            public DateTime AssignedAt { get; set; }\n            public string? AssignedBy { get; set; }\n        }\n\n        public sealed class UpsertUserPermissionRequest\n        {\n            public Guid PermissionId { get; set; }\n\n            /// <summary>\n            /// true  = allow\n            /// false = deny\n            /// </summary>\n            public bool IsGranted { get; set; }\n        }\n\n        // ---------------- GET: list overrides for a user ----------------\n\n        /// <summary>\n        /// Returns all active overrides for the given user.\n        /// The UI should combine this with plan permissions to show final state.\n        /// </summary>\n        [HttpGet]\n        public async Task<ActionResult<List<UserPermissionOverrideDto>>> GetOverridesForUser(\n            Guid userId,\n            CancellationToken ct)\n        {\n            // Ensure the user exists (optional but nice for admin UX)\n            var userExists = await _db.Set<User>()\n                .AnyAsync(u => u.Id == userId, ct);\n\n            if (!userExists)\n            {\n                return NotFound($\"User {userId} not found.\");\n            }\n\n            var overrides = await _db.Set<UserPermission>()\n                .AsNoTracking()\n                .Where(up => up.UserId == userId && !up.IsRevoked)\n                .Include(up => up.Permission)\n                .OrderBy(up => up.Permission.Code)\n                .Select(up => new UserPermissionOverrideDto\n                {\n                    PermissionId = up.PermissionId,\n                    Code = up.Permission.Code,\n                    Name = up.Permission.Name,\n                    IsGranted = up.IsGranted,\n                    IsRevoked = up.IsRevoked,\n                    AssignedAt = up.AssignedAt,\n                    AssignedBy = up.AssignedBy\n                })\n                .ToListAsync(ct);\n\n            return overrides;\n        }\n\n        // ---------------- POST: create/update override ----------------\n\n        /// <summary>\n        /// Create or update an override for the given user & permission.\n        /// If row exists, we update IsGranted and clear IsRevoked.\n        /// </summary>\n        [HttpPost]\n        public async Task<ActionResult<UserPermissionOverrideDto>> UpsertOverride(\n            Guid userId,\n            [FromBody] UpsertUserPermissionRequest request,\n            CancellationToken ct)\n        {\n            if (request.PermissionId == Guid.Empty)\n            {\n                return BadRequest(\"PermissionId is required.\");\n            }\n\n            var user = await _db.Set<User>()\n                .FirstOrDefaultAsync(u => u.Id == userId, ct);\n\n            if (user is null)\n            {\n                return NotFound($\"User {userId} not found.\");\n            }\n\n            var permission = await _db.Set<Permission>()\n                .FirstOrDefaultAsync(p => p.Id == request.PermissionId, ct);\n\n            if (permission is null)\n            {\n                return NotFound($\"Permission {request.PermissionId} not found.\");\n            }\n\n            var existing = await _db.Set<UserPermission>()\n                .FirstOrDefaultAsync(\n                    up => up.UserId == userId && up.PermissionId == request.PermissionId,\n                    ct);\n\n            if (existing is null)\n            {\n                existing = new UserPermission\n                {\n                    Id = Guid.NewGuid(),\n                    UserId = userId,\n                    PermissionId = request.PermissionId,\n                    IsGranted = request.IsGranted,\n                    IsRevoked = false,\n                    AssignedAt = DateTime.UtcNow,\n                    AssignedBy = User?.Identity?.Name ?? \"system\"\n                };\n\n                await _db.Set<UserPermission>().AddAsync(existing, ct);\n            }\n            else\n            {\n                existing.IsGranted = request.IsGranted;\n                existing.IsRevoked = false;\n                existing.AssignedAt = DateTime.UtcNow;\n                existing.AssignedBy = User?.Identity?.Name ?? existing.AssignedBy;\n            }\n\n            await _db.SaveChangesAsync(ct);\n\n            var dto = new UserPermissionOverrideDto\n            {\n                PermissionId = existing.PermissionId,\n                Code = permission.Code,\n                Name = permission.Name,\n                IsGranted = existing.IsGranted,\n                IsRevoked = existing.IsRevoked,\n                AssignedAt = existing.AssignedAt,\n                AssignedBy = existing.AssignedBy\n            };\n\n            return Ok(dto);\n        }\n\n        // ---------------- DELETE: soft-remove override ----------------\n\n        /// <summary>\n        /// Soft deletes an override by setting IsRevoked = true.\n        /// Effective permission will fall back to plan-level mapping.\n        /// </summary>\n        [HttpDelete(\"{permissionId:guid}\")]\n        public async Task<IActionResult> DeleteOverride(\n            Guid userId,\n            Guid permissionId,\n            CancellationToken ct)\n        {\n            var overrideRow = await _db.Set<UserPermission>()\n                .FirstOrDefaultAsync(\n                    up => up.UserId == userId && up.PermissionId == permissionId,\n                    ct);\n\n            if (overrideRow is null)\n            {\n                return NotFound();\n            }\n\n            overrideRow.IsRevoked = true;\n            // Optional: also reset grant flag â€“ your entitlement logic can ignore revoked rows anyway\n            // overrideRow.IsGranted = false;\n\n            await _db.SaveChangesAsync(ct);\n            return NoContent();\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/CreatePlanDto.cs",
      "sha256": "15d5b4b092dc0019db6a3e33fc6ea49a5bd2e02c9c4fabde02403dc9c32feb90",
      "language": "csharp",
      "size": 320,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AccessControl.DTOs\n{\n    public class CreatePlanDto\n    {\n        public string Code { get; set; } // e.g. \"FREE\", \"SMART\"\n        public string Name { get; set; }\n        public string? Description { get; set; }\n        public bool IsActive { get; set; } = true;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/GroupedPermissionDto.cs",
      "sha256": "d31e43145b8ed5908bd705af1dc96740d163615a183c30dc69b6d72097d37a76",
      "language": "csharp",
      "size": 255,
      "content": "using xbytechat.api.Features.AccessControl.Models;\n\nnamespace xbytechat.api.Features.AccessControl.DTOs\n{\n    public class GroupedPermissionDto\n    {\n        public string Group { get; set; }\n        public List<Permission> Features { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/PermissionDto.cs",
      "sha256": "46bfdeaa2a7dfa7bdaa56ed6c991868bae5fcc8ffb88cff1cc82d329e51eb92f",
      "language": "csharp",
      "size": 353,
      "content": "namespace xbytechat.api.Features.AccessControl.DTOs\n{\n    public class PermissionDto\n    {\n        public Guid Id { get; set; }\n        public string Code { get; set; }\n        public string Name { get; set; }\n        public string? Group { get; set; }\n        public string? Description { get; set; }\n        public bool IsActive { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/PermissionSummaryDto.cs",
      "sha256": "2ace6d04b01d7f967838d51fe0d7e0e0650479e1663c18f2559ca8246adf3e55",
      "language": "csharp",
      "size": 607,
      "content": "// ðŸ“„ Features/AccessControl/DTOs/PermissionSummaryDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.AccessControl.DTOs\n{\n    /// <summary>\n    /// Flat DTO used by the Permissions admin grid.\n    /// </summary>\n    public sealed class PermissionSummaryDto\n    {\n        public Guid Id { get; set; }\n\n        public string Code { get; set; } = default!;\n        public string Name { get; set; } = default!;\n\n        public string? Group { get; set; }\n        public string? Description { get; set; }\n\n        public bool IsActive { get; set; }\n        public DateTime CreatedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/PermissionUpsertDto.cs",
      "sha256": "bc57fdb6495dbd689898b10e6b6afe9a7fc02feca1e3453f8a10250f48651a02",
      "language": "csharp",
      "size": 797,
      "content": "// ðŸ“„ Features/AccessControl/DTOs/PermissionUpsertDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.AccessControl.DTOs\n{\n    /// <summary>\n    /// Payload for creating or updating a Permission.\n    /// Code is immutable once created (UI disables it for edit).\n    /// </summary>\n    public sealed class PermissionUpsertDto\n    {\n        [Required]\n        [MaxLength(200)]\n        public string Code { get; set; } = default!; // e.g. \"MESSAGING.SEND.TEXT\"\n\n        [Required]\n        [MaxLength(200)]\n        public string Name { get; set; } = default!; // friendly label\n\n        [MaxLength(200)]\n        public string? Group { get; set; } // \"Messaging\", \"Campaigns\", etc.\n\n        [MaxLength(1000)]\n        public string? Description { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/PlanDto.cs",
      "sha256": "87bcc89fbc963d131fcc246a1bde5d2d1a9198a61fac73a55b6b985644c8ee89",
      "language": "csharp",
      "size": 303,
      "content": "namespace xbytechat.api.Features.AccessControl.DTOs\n{\n    public class PlanDto\n    {\n        public Guid Id { get; set; }\n        public string Code { get; set; }\n        public string Name { get; set; }\n        public string Description { get; set; }\n        public bool IsActive { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/RoleDto.cs",
      "sha256": "890bec8d90e7068a2c8e49c4249b761506cdb9c26b2fd5a470bf14c6013954cf",
      "language": "csharp",
      "size": 479,
      "content": "namespace xbytechat.api.Features.AccessControl.DTOs;\n\n// DTO: Role details used across layers\npublic class RoleDto\n{\n    /// <summary>Unique identifier of the role.</summary>\n    public Guid Id { get; set; }\n\n   \n    public string Role { get; set; } = default!;\n\n   \n    public string Code { get; set; } = default!;\n\n   \n    public string? Description { get; set; }\n\n    \n    public bool IsActive { get; set; }\n\n       public RoleDto() { }\n\n    // Convenience constructor\n    \n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/UpdatePlanDto.cs",
      "sha256": "e4a09d8fd1c1ff0cb720be4ff2ba80df60e06fc54795e1e2a23fd06b16bf8956",
      "language": "csharp",
      "size": 273,
      "content": "namespace xbytechat.api.Features.AccessControl.DTOs\n{\n    public class UpdatePlanDto\n    {\n        public string Name { get; set; }\n        public string Code { get; set; }\n        public string Description { get; set; }\n        public bool IsActive { get; set; }\n    }\n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/UpdatePlanPermissionsRequest.cs",
      "sha256": "fb7246c045dc67de4e1841a2e77749da563069e5e02ebe856df70f4bb28e9c42",
      "language": "csharp",
      "size": 269,
      "content": "namespace xbytechat.api.Features.AccessControl.DTOs\n{\n    public class UpdatePlanPermissionsRequest\n    {\n        public List<Guid> PermissionIds { get; set; } = new();\n        public bool ReplaceAll { get; set; } = true; // optional flag your controller reads\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/UpdateRolePermissionsDto.cs",
      "sha256": "e00530db11a422793d96b8905211218a03a8e810c601034c76b75fbba37d40db",
      "language": "csharp",
      "size": 291,
      "content": "using System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.AccessControl.DTOs\n{\n    public class UpdateRolePermissionsDto\n    {\n        [Required]\n        public List<Guid> PermissionIds { get; set; } = new();\n        public bool ReplaceAll { get; set; } = true;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/UpdateUserPermissionsDto.cs",
      "sha256": "aea509c8f87c9fda5473534a5c9926fd3af7d09a1041c2832071d1aa5ba60b31",
      "language": "csharp",
      "size": 416,
      "content": "using System.Collections.Generic;\n\nnamespace xbytechat.api.Features.AccessControl.DTOs.UserPermissions\n{\n    public sealed class UpdateUserPermissionsDto\n    {\n        /// <summary>\n        /// List of Permission.Code values that should be enabled for this user.\n        /// Anything not in this list will be removed.\n        /// </summary>\n        public List<string> PermissionCodes { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/UpsertPermissionRequest.cs",
      "sha256": "f925b63f73851fa7462e56c3f9b53a56476af6cb976cbe35d813efd03db7889b",
      "language": "csharp",
      "size": 633,
      "content": "// ðŸ“ Features/AccessControl/DTOs/UpsertPermissionRequest.cs\nnamespace xbytechat.api.Features.AccessControl.DTOs\n{\n    public class UpsertPermissionRequest\n    {\n        // Code is required only on create. On update, we ignore it.\n        public string Code { get; set; } = string.Empty;\n\n        public string Name { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Logical group/module/workspace, e.g. \"Messaging\", \"Campaigns\", \"CRM\".\n        /// This maps to Permission.Group in the model.\n        /// </summary>\n        public string? Group { get; set; }\n\n        public string? Description { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/UserPermissions.cs",
      "sha256": "2f1985d1584fedd86c23fe360a05781bd5ab974fe2833c7ba1222e55c531ee6e",
      "language": "csharp",
      "size": 340,
      "content": "namespace xbytechat.api.Features.AccessControl.DTOs.UserPermissions\n{\n    public sealed class UserPermissionItemDto\n    {\n        public string PermissionCode { get; set; } = default!;\n        public string Name { get; set; } = default!;\n        public string? Description { get; set; }\n        public bool IsAssigned { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/UserPermissionSummaryDto.cs",
      "sha256": "9d6539a51791e64bf141f4f8aea394a0befa161294ac9a6e2c794fdbdde78b60",
      "language": "csharp",
      "size": 440,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.AccessControl.DTOs.UserPermissions\n{\n    public sealed class UserPermissionSummaryDto\n    {\n        public Guid UserId { get; set; }\n        public string UserEmail { get; set; } = default!;\n        public Guid BusinessId { get; set; }\n        public Guid PlanId { get; set; }\n\n        public List<UserPermissionItemDto> Items { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Models/Permission.cs",
      "sha256": "22c58f1f832014c6129b075f027045a186874bc7c20d0f312befe1d658bb0ab4",
      "language": "csharp",
      "size": 832,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.AccessControl.Models\n{\n    public class Permission\n    {\n        public Guid Id { get; set; }\n\n        public string Code { get; set; } // Unique key like \"ViewDashboard\"\n\n        public string Name { get; set; } // Friendly name like \"View Dashboard\"\n\n        public string? Group { get; set; } // Optional grouping, e.g., \"CRM\", \"Catalog\", \"Admin\"\n\n        public string? Description { get; set; }\n\n        public bool IsActive { get; set; } = true;\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n        public ICollection<RolePermission> RolePermissions { get; set; }\n\n        public ICollection<UserPermission> UserPermissions { get; set; }\n\n        public ICollection<PlanPermission> PlanPermissions { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Models/Plan.cs",
      "sha256": "9f3414b6a49c2c27b0784e659367f5f64258b19e19195a52a4248936020542be",
      "language": "csharp",
      "size": 758,
      "content": "using System;\nusing System.Collections.Generic;\nusing xbytechat.api.Features.BusinessModule.Models;\n\nnamespace xbytechat.api.Features.AccessControl.Models\n{\n    public class Plan\n    {\n        public Guid Id { get; set; }\n\n        public string Code { get; set; } // e.g. \"FREE\", \"SMART\", \"ADVANCED\"\n        public string Name { get; set; } // Friendly display name\n\n        public string? Description { get; set; }\n\n        public bool IsActive { get; set; } = true;\n\n        public bool IsInternal { get; set; } = false;\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n        public ICollection<PlanPermission> PlanPermissions { get; set; }\n        public ICollection<Business> Businesses { get; set; } = new List<Business>();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Models/PlanPermission.cs",
      "sha256": "e6e65f0ae33c19e9d2585d73812bcf99ed207d52ac6d804a3c2bf86b3152eca7",
      "language": "csharp",
      "size": 525,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AccessControl.Models\n{\n    public class PlanPermission\n    {\n        public Guid Id { get; set; }\n\n        public Guid PlanId { get; set; }\n        public Plan Plan { get; set; }\n\n        public Guid PermissionId { get; set; }\n        public Permission Permission { get; set; }\n\n        public bool IsActive { get; set; } = true;\n\n        public DateTime AssignedAt { get; set; } = DateTime.UtcNow;\n        public string? AssignedBy { get; set; } // Admin email or ID\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Models/Role.cs",
      "sha256": "9b8fb241048424da26b269048106f4771195ce236ea1c94a6e322a2d98dd99df",
      "language": "csharp",
      "size": 907,
      "content": "using System;\nusing System.Collections.Generic;\nusing xbytechat.api.AuthModule.Models;\nusing xbytechat.api.Features.BusinessModule.Models;\n\nnamespace xbytechat.api.Features.AccessControl.Models\n{\n    public class Role\n    {\n        public Guid Id { get; set; }\n\n        public string Name { get; set; } // e.g. SuperAdmin, PartnerAdmin, BusinessAdmin, Staff, etc.\n\n        public string? Description { get; set; }\n        public Guid? BusinessId { get; set; }\n\n        public Business? Business { get; set; }\n\n        public bool IsSystemDefined { get; set; } = false; // true for SuperAdmin, PartnerAdmin\n\n        public bool IsActive { get; set; } = true;\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n        public ICollection<RolePermission> RolePermissions { get; set; }\n        public ICollection<User> Users { get; set; } // ðŸ§© One-to-many relation: Role â†’ Users\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Models/RolePermission.cs",
      "sha256": "d9b31669bec3fbda1b95c89def9a6cc641e0dd21f5e38583b8dae4c0239b9a8a",
      "language": "csharp",
      "size": 619,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AccessControl.Models\n{\n    public class RolePermission\n    {\n        public Guid Id { get; set; }\n\n        public Guid RoleId { get; set; }\n        public Role Role { get; set; }\n\n        public Guid PermissionId { get; set; }\n        public Permission Permission { get; set; }\n\n        public DateTime AssignedAt { get; set; } = DateTime.UtcNow;\n        public string? AssignedBy { get; set; } // Admin user email or ID\n\n        public bool IsActive { get; set; } = true; // âœ… Add this line\n        public bool IsRevoked { get; set; } = false; // âœ… Required\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Models/UserPermission.cs",
      "sha256": "6b85321ec68fced21477222e85ac56594106c4654b5d99061c42bc1c46d876aa",
      "language": "csharp",
      "size": 677,
      "content": "using System;\nusing xbytechat.api.AuthModule.Models;\n\nnamespace xbytechat.api.Features.AccessControl.Models\n{\n    public class UserPermission\n    {\n        public Guid Id { get; set; }\n\n        public Guid UserId { get; set; }\n        public User User { get; set; }\n\n        public Guid PermissionId { get; set; }\n        public Permission Permission { get; set; }\n\n        public bool IsGranted { get; set; } = true; // âœ… true = allow, false = explicitly deny\n\n        public DateTime AssignedAt { get; set; } = DateTime.UtcNow;\n        public string? AssignedBy { get; set; } // Admin or system\n\n        public bool IsRevoked { get; set; } = false; // âœ… Required\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/PermissionAttributes/HasPermissionAttribute.cs",
      "sha256": "34dacbeb415c4d4f132196679c11cb68619fb2a180528ef22d17ef65a8df364b",
      "language": "csharp",
      "size": 2885,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing Microsoft.AspNetCore.Mvc.Filters;\nusing Microsoft.Extensions.DependencyInjection;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.AccessControl.Services;\n\nnamespace xbytechat.api.Features.AccessControl.PermissionAttributes\n{\n    /// <summary>\n    /// Enforces a permission code on API endpoints.\n    /// Priority:\n    /// 1) hasAllAccess=true => allow (admin/superadmin/partner/reseller)\n    /// 2) permissions claim contains code => allow\n    /// 3) fallback (legacy): plan_id -> plan permissions cache\n    /// </summary>\n    public class HasPermissionAttribute : Attribute, IAsyncAuthorizationFilter\n    {\n        private readonly string _permissionCode;\n\n        public HasPermissionAttribute(string permissionCode) => _permissionCode = permissionCode;\n\n        public async Task OnAuthorizationAsync(AuthorizationFilterContext context)\n        {\n            var user = context.HttpContext.User;\n\n            if (user?.Identity?.IsAuthenticated != true)\n            {\n                context.Result = new ForbidResult();\n                return;\n            }\n\n            // âœ… 1) All-access shortcut (admins)\n            var hasAllAccessClaim = user.FindFirst(\"hasAllAccess\")?.Value;\n            if (string.Equals(hasAllAccessClaim, \"true\", StringComparison.OrdinalIgnoreCase))\n                return;\n\n            // âœ… 2) Prefer the JWT permissions claim (fast, no DB hit)\n            var permsClaim = user.FindFirst(\"permissions\")?.Value;\n            if (!string.IsNullOrWhiteSpace(permsClaim))\n            {\n                var perms = new HashSet<string>(\n                    permsClaim.Split(',', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries),\n                    StringComparer.OrdinalIgnoreCase\n                );\n\n                if (perms.Contains(_permissionCode))\n                    return;\n\n                context.Result = new ForbidResult();\n                return;\n            }\n\n            // ðŸ§¯ 3) Legacy fallback: plan-only (kept for backward compatibility)\n            var planIdClaim = user.FindFirst(\"plan_id\")?.Value;\n            if (string.IsNullOrWhiteSpace(planIdClaim) || !Guid.TryParse(planIdClaim, out var planId))\n            {\n                context.Result = new ForbidResult();\n                return;\n            }\n\n            var permissionService = context.HttpContext.RequestServices\n                .GetRequiredService<IPermissionCacheService>();\n\n            var planPermissions = await permissionService.GetPlanPermissionsAsync(planId);\n\n            var hasPermission = planPermissions.Any(p =>\n                string.Equals(p.Code, _permissionCode, StringComparison.OrdinalIgnoreCase));\n\n            if (!hasPermission)\n                context.Result = new ForbidResult();\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Seeder/PermissionConstants.cs",
      "sha256": "47104d91bf08a96917121e247b83aac03fe402f24bb851d3fa4b1b9ee5375469",
      "language": "csharp",
      "size": 1126,
      "content": "namespace xbytechat.api.Features.AccessControl.Seeder\n{\n    public static class PermissionConstants\n    {\n        public static class Dashboard\n        {\n            public const string View = \"dashboard.view\";\n        }\n\n        public static class Campaigns\n        {\n            public const string View = \"campaign.view\";\n            public const string Create = \"campaign.create\";\n            public const string Delete = \"campaign.delete\";\n        }\n\n        public static class Products\n        {\n            public const string View = \"product.view\";\n            public const string Create = \"product.create\";\n            public const string Delete = \"product.delete\";\n        }\n\n        public static class CRM\n        {\n            public const string ContactsView = \"contacts.view\";\n            public const string TagsEdit = \"tags.edit\";\n        }\n\n        public static class Admin\n        {\n            public const string BusinessApprove = \"admin.business.approve\";\n            public const string ViewLogs = \"admin.logs.view\";\n        }\n\n        // ðŸ†• Add more modules and permissions here as needed\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Seeder/RolePermissionMapping.cs",
      "sha256": "47f001a1b2d6404c28e73be68faf79485c10c1c0a7dab0a5346cc06fff4f049a",
      "language": "csharp",
      "size": 1302,
      "content": "namespace xbytechat.api.Features.AccessControl.Seeder\n{\n    public static class RolePermissionMapping\n    {\n        public static readonly Dictionary<string, List<string>> RolePermissions = new()\n        {\n            [\"admin\"] = new()\n            {\n                PermissionConstants.Dashboard.View,\n                PermissionConstants.Campaigns.View,\n                PermissionConstants.Campaigns.Create,\n                PermissionConstants.Campaigns.Delete,\n                PermissionConstants.Products.View,\n                PermissionConstants.Products.Create,\n                PermissionConstants.Products.Delete,\n                PermissionConstants.CRM.ContactsView,\n                PermissionConstants.CRM.TagsEdit,\n                PermissionConstants.Admin.BusinessApprove,\n                PermissionConstants.Admin.ViewLogs\n            },\n\n            [\"business\"] = new()\n            {\n                PermissionConstants.Dashboard.View,\n                PermissionConstants.Campaigns.View,\n                PermissionConstants.CRM.ContactsView,\n                PermissionConstants.Products.View\n            },\n\n            [\"staff\"] = new()\n            {\n                PermissionConstants.Dashboard.View,\n                PermissionConstants.CRM.ContactsView\n            }\n        };\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Services/AccessControlService.cs",
      "sha256": "f17819dd1f6c0fa4be4623805f2738e2f6bad0def67f22495cef7f9bf9382d3a",
      "language": "csharp",
      "size": 7050,
      "content": "\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Security.Claims;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.AuthModule.Models;\nusing xbytechat.api.Features.AccessControl.Models;\nusing xbytechat.api.Repositories.Interfaces;\nusing System.Linq.Expressions;\n\n\nnamespace xbytechat.api.Features.AccessControl.Services\n{\n    public class AccessControlService : IAccessControlService\n    {\n        private readonly IGenericRepository<User> _userRepo;\n        private readonly IGenericRepository<RolePermission> _rolePermissionRepo;\n        private readonly IGenericRepository<UserPermission> _userPermissionRepo;\n        private readonly IGenericRepository<Permission> _permissionRepo;\n        private readonly AppDbContext _context;\n        public AccessControlService(\n            IGenericRepository<User> userRepo,\n            IGenericRepository<RolePermission> rolePermissionRepo,\n            IGenericRepository<UserPermission> userPermissionRepo,\n            IGenericRepository<Permission> permissionRepo, AppDbContext context\n        )\n        {\n            _userRepo = userRepo;\n            _rolePermissionRepo = rolePermissionRepo;\n            _userPermissionRepo = userPermissionRepo;\n            _permissionRepo = permissionRepo;\n            _context = context;\n        }\n\n        /// <summary>\n        /// âœ… Fetch all permissions (Role-based + User-specific) for a given user\n        /// </summary>\n        //public async Task<List<string>> GetPermissionsAsync(Guid userId)\n        //{\n        //    var user = await _userRepo.FindByIdAsync(userId);\n        //    if (user == null || user.RoleId == null)\n        //        return new List<string>();\n\n        //    // ðŸ” Get Role-based permissions\n        //    var rolePerms = await _rolePermissionRepo\n        //        .WhereAsync(rp => rp.RoleId == user.RoleId && !rp.IsRevoked);\n\n        //    // ðŸ” Get User-specific extra permissions\n        //    var userPerms = await _userPermissionRepo\n        //        .WhereAsync(up => up.UserId == userId && !up.IsRevoked);\n\n        //    // ðŸ§  Merge permission IDs\n        //    var permissionIds = rolePerms.Select(r => r.PermissionId)\n        //        .Union(userPerms.Select(u => u.PermissionId))\n        //        .Distinct()\n        //        .ToList();\n\n        //    // ðŸŽ¯ Get full permission names from Permission table\n        //    var allPerms = await _permissionRepo\n        //        .WhereAsync(p => permissionIds.Contains(p.Id));\n\n        //    return allPerms.Select(p => p.Code).Distinct().ToList(); // Use Code (standard)\n        //}\n\n        public async Task<IEnumerable<Permission>> GetAllPermissionsAsync()\n        {\n            return await _permissionRepo.WhereAsync(p => p.IsActive);\n        }\n\n\n        public async Task<List<string>> GetPermissionsAsync(Guid userId)\n        {\n            var user = await _userRepo.FindByIdAsync(userId);\n\n            if (user == null || user.RoleId == null)\n                return new List<string>();\n\n            // ðŸš€ Bypass: SuperAdmin always gets full access\n            if (user.Role != null && user.Role.Name.Equals(\"superadmin\", StringComparison.OrdinalIgnoreCase))\n            {\n                var allPerms = await _permissionRepo.GetAllAsync();\n                return allPerms.Select(p => p.Code).Distinct().ToList();\n            }\n\n            // ðŸ” Get Role-based permissions\n            var rolePerms = await _rolePermissionRepo\n                .WhereAsync(rp => rp.RoleId == user.RoleId && !rp.IsRevoked);\n\n            // ðŸ” Get User-specific extra permissions\n            var userPerms = await _userPermissionRepo\n                .WhereAsync(up => up.UserId == userId && !up.IsRevoked);\n\n            // ðŸ§  Merge permission IDs\n            var permissionIds = rolePerms.Select(r => r.PermissionId)\n                .Union(userPerms.Select(u => u.PermissionId))\n                .Distinct()\n                .ToList();\n\n            // ðŸŽ¯ Get full permission names from Permission table\n            var allAllowedPerms = await _permissionRepo\n                .WhereAsync(p => permissionIds.Contains(p.Id));\n\n            return allAllowedPerms.Select(p => p.Code).Distinct().ToList();\n        }\n\n        public bool HasPermission(ClaimsPrincipal user, string requiredPermission)\n        {\n            if (user == null || string.IsNullOrWhiteSpace(requiredPermission))\n                return false;\n\n            // ðŸš€ Bypass for top roles\n            var roleClaim = user.Claims.FirstOrDefault(c =>\n                c.Type == ClaimTypes.Role || c.Type.Equals(\"role\", StringComparison.OrdinalIgnoreCase)\n            )?.Value;\n\n            if (!string.IsNullOrWhiteSpace(roleClaim))\n            {\n                if (roleClaim.Equals(\"superadmin\", StringComparison.OrdinalIgnoreCase) ||\n                    roleClaim.Equals(\"admin\", StringComparison.OrdinalIgnoreCase) ||\n                    roleClaim.Equals(\"partner\", StringComparison.OrdinalIgnoreCase) ||\n                    roleClaim.Equals(\"reseller\", StringComparison.OrdinalIgnoreCase))\n                    return true;\n            }\n\n            var required = requiredPermission.Trim();\n\n            // âœ… Collect permissions from claim(s), supporting CSV and alternate claim keys\n            var set = new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n\n            void AddCsv(string? csv)\n            {\n                if (string.IsNullOrWhiteSpace(csv)) return;\n\n                foreach (var p in csv.Split(',', StringSplitOptions.RemoveEmptyEntries))\n                {\n                    var code = p.Trim();\n                    if (!string.IsNullOrWhiteSpace(code))\n                        set.Add(code);\n                }\n            }\n\n            // primary: \"permissions\" (your JWT uses this)\n            foreach (var c in user.Claims.Where(c => c.Type == \"permissions\"))\n                AddCsv(c.Value);\n\n            // fallback: \"permission\" (rare, but avoids break if someone changes token later)\n            var alt = user.Claims.FirstOrDefault(c => c.Type == \"permission\")?.Value;\n            AddCsv(alt);\n\n            return set.Contains(required);\n        }\n\n        /// <summary>\n        /// âœ… Runtime permission checker (for controller/middleware)\n        /// </summary>\n        //public bool HasPermission(ClaimsPrincipal user, string requiredPermission)\n        //{\n        //    var perms = user.Claims\n        //        .Where(c => c.Type == \"permissions\")\n        //        .Select(c => c.Value)\n        //        .ToList();\n\n        //    return perms.Contains(requiredPermission);\n        //}\n\n        public async Task<List<string>> GetPermissionsByPlanIdAsync(Guid? planId)\n        {\n            if (!planId.HasValue)\n                return new List<string>();\n\n            return await _context.PlanPermissions\n                .Where(pp => pp.PlanId == planId.Value && pp.IsActive)\n                .Select(pp => pp.Permission.Code)\n                .ToListAsync();\n        }\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Services/IAccessControlService.cs",
      "sha256": "a7175ca2ec5d8ac4aae9b09095d675ab36d2c52dd6a62b3d23c6b6990de055e2",
      "language": "csharp",
      "size": 853,
      "content": "//using System.Collections.Generic;\n//using System.Threading.Tasks;\n//using xbytechat.api.Features.AccessControl.Models;\n\n//namespace xbytechat.api.Features.AccessControl.Services\n//{\n//    public interface IAccessControlService\n//    {\n//        Task<IEnumerable<Permission>> GetAllPermissionsAsync();\n//        Task<IEnumerable<Permission>> GetPermissionsAsync(Guid userId);\n\n//    }\n//}\n\n\nusing System.Security.Claims;\nusing xbytechat.api.Features.AccessControl.Models;\n\nnamespace xbytechat.api.Features.AccessControl.Services\n{\n    public interface IAccessControlService\n    {\n        Task<List<string>> GetPermissionsAsync(Guid userId);\n        bool HasPermission(ClaimsPrincipal user, string permission);\n        Task<IEnumerable<Permission>> GetAllPermissionsAsync();\n        Task<List<string>> GetPermissionsByPlanIdAsync(Guid? planId);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Services/IPermissionService.cs.cs",
      "sha256": "9b90beeeaaf8c3d5077265251342d6ae3cf51e442106d302d2a143b7b00ae417",
      "language": "csharp",
      "size": 1071,
      "content": "// ðŸ“„ Features/AccessControl/Services/IPermissionService.cs.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.AccessControl.DTOs;\n\nnamespace xbytechat.api.Features.AccessControl.Services\n{\n    public interface IPermissionService\n    {\n        // Existing grouped view (used by older UI / internal tools)\n        Task<IEnumerable<GroupedPermissionDto>> GetGroupedPermissionsAsync();\n\n        // New flat CRUD endpoints\n        Task<IReadOnlyList<PermissionSummaryDto>> GetAllAsync(\n            CancellationToken ct = default);\n\n        Task<PermissionSummaryDto> CreateAsync(\n            PermissionUpsertDto dto,\n            CancellationToken ct = default);\n\n        Task<PermissionSummaryDto> UpdateAsync(\n            Guid id,\n            PermissionUpsertDto dto,\n            CancellationToken ct = default);\n\n        /// <summary>\n        /// Soft-delete / deactivate a permission.\n        /// </summary>\n        Task DeactivateAsync(Guid id, CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Services/IPlanService.cs",
      "sha256": "52ab5621692cbe324646331e6ac2ee6a1c4b4fe9fdfc5b75e602322a29263f19",
      "language": "csharp",
      "size": 1128,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.AccessControl.DTOs;\nusing xbytechat.api.Features.AccessControl.Models;\n\nnamespace xbytechat.api.Features.AccessControl.Services\n{\n    public interface IPlanService\n    {\n        Task<IEnumerable<PlanDto>> GetAllPlansAsync();\n        Task<IEnumerable<PermissionDto>> GetPermissionsForPlanAsync(Guid planId);\n       // Task UpdatePlanPermissionsAsync(Guid planId, List<Guid> permissionIds);\n        Task<Guid> CreatePlanAsync(CreatePlanDto dto);\n        Task<bool> DeletePlanAsync(Guid planId);\n        Task<bool> UpdatePlanAsync(Guid planId, UpdatePlanDto dto);\n\n        // New methods for permissions\n        Task<List<PermissionDto>> GetPlanPermissionsAsync(Guid planId);\n        //Task UpdatePlanPermissionsAsync(Guid planId, List<Guid> permissionIds);\n        Task UpdatePlanPermissionsAsync(\n    Guid planId,\n    IReadOnlyCollection<Guid> permissionIds,\n    bool replaceAll,\n    string? assignedBy,\n    CancellationToken ct);\n        Task<PlanDto?> GetByIdAsync(Guid planId, CancellationToken ct = default);\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Services/PermissionCacheService.cs",
      "sha256": "c268071425295dc74c3f7323b4ebcbc3f413d9eaea473b6b55ada75cc0117ea9",
      "language": "csharp",
      "size": 1696,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Caching.Memory;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.AccessControl.Models;\n\nnamespace xbytechat.api.Features.AccessControl.Services\n{\n    public interface IPermissionCacheService\n    {\n        Task<List<Permission>> GetPlanPermissionsAsync(Guid planId);\n        void ClearPlanPermissionsCache(Guid planId);\n    }\n\n    public class PermissionCacheService : IPermissionCacheService\n    {\n        private readonly AppDbContext _context;\n        private readonly IMemoryCache _cache;\n        private const string CacheKeyPrefix = \"plan_permissions_\";\n\n        public PermissionCacheService(AppDbContext context, IMemoryCache cache)\n        {\n            _context = context;\n            _cache = cache;\n        }\n\n        public async Task<List<Permission>> GetPlanPermissionsAsync(Guid planId)\n        {\n            var cacheKey = $\"{CacheKeyPrefix}{planId}\";\n\n            // Try to get from cache\n            if (_cache.TryGetValue(cacheKey, out List<Permission> cachedPermissions))\n                return cachedPermissions;\n\n            // Fetch from DB\n            var permissions = await _context.PlanPermissions\n                .Where(pp => pp.PlanId == planId && pp.IsActive)\n                .Select(pp => pp.Permission)\n                .ToListAsync();\n\n            // Store in cache\n            _cache.Set(cacheKey, permissions, TimeSpan.FromHours(1));\n\n            return permissions;\n        }\n\n        public void ClearPlanPermissionsCache(Guid planId)\n        {\n            _cache.Remove($\"{CacheKeyPrefix}{planId}\");\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Services/PermissionService.cs",
      "sha256": "ae835be421a784aa982c1f38056103da2edb440cc7794714ff48ac0c3dfaa0fa",
      "language": "csharp",
      "size": 5344,
      "content": "// ðŸ“„ Features/AccessControl/Services/PermissionService.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.AccessControl.DTOs;\nusing xbytechat.api.Features.AccessControl.Models;\n\nnamespace xbytechat.api.Features.AccessControl.Services\n{\n    public class PermissionService : IPermissionService\n    {\n        private readonly AppDbContext _context;\n\n        public PermissionService(AppDbContext context)\n        {\n            _context = context;\n        }\n\n        public async Task<IEnumerable<GroupedPermissionDto>> GetGroupedPermissionsAsync()\n        {\n            // Legacy / grouped view (kept for compatibility)\n            return await _context.Permissions\n                .Where(p => p.IsActive)\n                .GroupBy(p => p.Group ?? \"Ungrouped\")\n                .Select(g => new GroupedPermissionDto\n                {\n                    Group = g.Key,\n                    Features = g.ToList()\n                })\n                .ToListAsync();\n        }\n\n        public async Task<IReadOnlyList<PermissionSummaryDto>> GetAllAsync(\n            CancellationToken ct = default)\n        {\n            return await _context.Permissions\n                .OrderBy(p => p.Group)\n                .ThenBy(p => p.Code)\n                .Select(p => new PermissionSummaryDto\n                {\n                    Id = p.Id,\n                    Code = p.Code,\n                    Name = p.Name,\n                    Group = p.Group,\n                    Description = p.Description,\n                    IsActive = p.IsActive,\n                    CreatedAt = p.CreatedAt\n                })\n                .ToListAsync(ct);\n        }\n\n        public async Task<PermissionSummaryDto> CreateAsync(\n            PermissionUpsertDto dto,\n            CancellationToken ct = default)\n        {\n            if (dto == null) throw new ArgumentNullException(nameof(dto));\n\n            var code = dto.Code?.Trim();\n            var name = dto.Name?.Trim();\n\n            if (string.IsNullOrWhiteSpace(code) || string.IsNullOrWhiteSpace(name))\n            {\n                throw new InvalidOperationException(\"Code and Name are required.\");\n            }\n\n            var normalizedCode = code.ToUpperInvariant();\n\n            var exists = await _context.Permissions\n                .AnyAsync(p => p.Code == normalizedCode, ct);\n\n            if (exists)\n            {\n                throw new InvalidOperationException(\n                    $\"Permission code '{normalizedCode}' already exists.\");\n            }\n\n            var permission = new Permission\n            {\n                Id = Guid.NewGuid(),\n                Code = normalizedCode,\n                Name = name,\n                Group = string.IsNullOrWhiteSpace(dto.Group)\n                    ? null\n                    : dto.Group!.Trim(),\n                Description = string.IsNullOrWhiteSpace(dto.Description)\n                    ? null\n                    : dto.Description!.Trim(),\n                IsActive = true,\n                CreatedAt = DateTime.UtcNow\n            };\n\n            _context.Permissions.Add(permission);\n            await _context.SaveChangesAsync(ct);\n\n            return ToSummary(permission);\n        }\n\n        public async Task<PermissionSummaryDto> UpdateAsync(\n            Guid id,\n            PermissionUpsertDto dto,\n            CancellationToken ct = default)\n        {\n            if (dto == null) throw new ArgumentNullException(nameof(dto));\n\n            var permission = await _context.Permissions\n                .FirstOrDefaultAsync(p => p.Id == id, ct);\n\n            if (permission == null)\n                throw new KeyNotFoundException(\"Permission not found.\");\n\n            var name = dto.Name?.Trim();\n            if (string.IsNullOrWhiteSpace(name))\n                throw new InvalidOperationException(\"Name is required.\");\n\n            // Code is intentionally immutable (UI keeps it disabled).\n            permission.Name = name;\n            permission.Group = string.IsNullOrWhiteSpace(dto.Group)\n                ? null\n                : dto.Group!.Trim();\n            permission.Description = string.IsNullOrWhiteSpace(dto.Description)\n                ? null\n                : dto.Description!.Trim();\n\n            await _context.SaveChangesAsync(ct);\n\n            return ToSummary(permission);\n        }\n\n        public async Task DeactivateAsync(Guid id, CancellationToken ct = default)\n        {\n            var permission = await _context.Permissions\n                .FirstOrDefaultAsync(p => p.Id == id, ct);\n\n            if (permission == null)\n                throw new KeyNotFoundException(\"Permission not found.\");\n\n            if (!permission.IsActive)\n                return;\n\n            permission.IsActive = false;\n            await _context.SaveChangesAsync(ct);\n        }\n\n        private static PermissionSummaryDto ToSummary(Permission p)\n        {\n            return new PermissionSummaryDto\n            {\n                Id = p.Id,\n                Code = p.Code,\n                Name = p.Name,\n                Group = p.Group,\n                Description = p.Description,\n                IsActive = p.IsActive,\n                CreatedAt = p.CreatedAt\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Services/PlanService.cs",
      "sha256": "c4e23f3ca4fc67f7f1340294e9d4851943aa91acc14b4d402fe4116f1822a63c",
      "language": "csharp",
      "size": 11164,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.AccessControl.DTOs;\nusing xbytechat.api.Features.AccessControl.Models;\n\nnamespace xbytechat.api.Features.AccessControl.Services\n{\n    public class PlanService : IPlanService\n    {\n        private readonly AppDbContext _context;\n        private readonly ILogger<PlanService> _logger;\n        private readonly IPermissionCacheService _permissionCacheService;\n\n        public PlanService(AppDbContext context, ILogger<PlanService> logger, IPermissionCacheService permissionCacheService)\n        {\n            _context = context;\n            _logger = logger;\n            _permissionCacheService = permissionCacheService;\n        }\n\n\n\n        public async Task<IEnumerable<PlanDto>> GetAllPlansAsync()\n        {\n            return await _context.Plans\n                .Where(p => p.IsActive)\n                .Select(p => new PlanDto\n                {\n                    Id = p.Id,\n                    Code = p.Code,\n                    Name = p.Name,\n                    Description = p.Description,\n                    IsActive = p.IsActive\n                })\n                .ToListAsync();\n        }\n        public async Task<IEnumerable<PermissionDto>> GetPermissionsForPlanAsync(Guid planId)\n        {\n            return await _context.PlanPermissions\n                .Where(pp => pp.PlanId == planId && pp.IsActive)\n                .Select(pp => new PermissionDto\n                {\n                    Id = pp.Permission.Id,\n                    Code = pp.Permission.Code,\n                    Name = pp.Permission.Name,\n                    Group = pp.Permission.Group,\n                    Description = pp.Permission.Description,\n                    IsActive = pp.Permission.IsActive\n                })\n                .ToListAsync();\n        }\n        public async Task<PlanDto?> GetByIdAsync(Guid planId, CancellationToken ct = default)\n        {\n            return await _context.Plans\n                .AsNoTracking()\n                .Where(p => p.Id == planId)\n                .Select(p => new PlanDto\n                {\n                    Id = p.Id,\n                    Code = p.Code,\n                    Name = p.Name,\n                    Description = p.Description,\n                    IsActive = p.IsActive\n                })\n                .FirstOrDefaultAsync(ct);\n        }\n\n        //public async Task<IEnumerable<Permission>> GetPermissionsForPlanAsync(Guid planId)\n        //{\n        //    _logger.LogInformation(\"Fetching permissions for plan {PlanId}\", planId);\n        //    try\n        //    {\n        //        return await _context.PlanPermissions\n        //            .Where(pp => pp.PlanId == planId && pp.IsActive)\n        //            .Include(pp => pp.Permission)\n        //            .Select(pp => pp.Permission)\n        //            .AsNoTracking()\n        //            .ToListAsync();\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        _logger.LogError(ex, \"Error fetching permissions for plan {PlanId}\", planId);\n        //        throw;\n        //    }\n        //}\n\n        //public async Task UpdatePlanPermissionsAsync(Guid planId, List<Guid> permissionIds)\n        //{\n        //    _logger.LogInformation(\"Updating permissions for plan {PlanId}\", planId);\n        //    try\n        //    {\n        //        // Remove all existing permissions for the plan\n        //        var existing = await _context.PlanPermissions\n        //            .Where(pp => pp.PlanId == planId)\n        //            .ToListAsync();\n\n        //        _context.PlanPermissions.RemoveRange(existing);\n\n        //        // Add new permissions\n        //        var newPlanPermissions = permissionIds.Select(pid => new PlanPermission\n        //        {\n        //            Id = Guid.NewGuid(),\n        //            PlanId = planId,\n        //            PermissionId = pid,\n        //            IsActive = true,\n        //            AssignedAt = DateTime.UtcNow,\n        //            AssignedBy = \"System\"\n        //        });\n\n        //        await _context.PlanPermissions.AddRangeAsync(newPlanPermissions);\n        //        await _context.SaveChangesAsync();\n        //        _logger.LogInformation(\"Permissions updated for plan {PlanId}\", planId);\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        _logger.LogError(ex, \"Error updating permissions for plan {PlanId}\", planId);\n        //        throw;\n        //    }\n        //}\n\n        public async Task<Guid> CreatePlanAsync(CreatePlanDto dto)\n        {\n            _logger.LogInformation(\"Creating new plan: {PlanName}\", dto.Name);\n            try\n            {\n                var plan = new Plan\n                {\n                    Id = Guid.NewGuid(),\n                    Code = dto.Code,\n                    Name = dto.Name,\n                    Description = dto.Description,\n                    IsActive = dto.IsActive\n                };\n\n                _context.Plans.Add(plan);\n                await _context.SaveChangesAsync();\n\n                _logger.LogInformation(\"Plan created with ID: {PlanId}\", plan.Id);\n                return plan.Id;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error creating plan {PlanName}\", dto.Name);\n                throw;\n            }\n        }\n\n        public async Task<bool> DeletePlanAsync(Guid planId)\n        {\n            _logger.LogInformation(\"Deleting (soft) plan {PlanId}\", planId);\n            try\n            {\n                var plan = await _context.Plans.FirstOrDefaultAsync(p => p.Id == planId);\n                if (plan == null || !plan.IsActive)\n                {\n                    _logger.LogWarning(\"Plan not found or already inactive: {PlanId}\", planId);\n                    return false;\n                }\n\n                plan.IsActive = false;\n                _context.Plans.Update(plan);\n                await _context.SaveChangesAsync();\n\n                _logger.LogInformation(\"Plan {PlanId} soft deleted.\", planId);\n                return true;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error deleting plan {PlanId}\", planId);\n                throw;\n            }\n        }\n\n        public async Task<bool> UpdatePlanAsync(Guid planId, UpdatePlanDto dto)\n        {\n            _logger.LogInformation(\"Updating plan {PlanId}\", planId);\n            try\n            {\n                var plan = await _context.Plans.FirstOrDefaultAsync(p => p.Id == planId);\n                if (plan == null)\n                {\n                    _logger.LogWarning(\"Plan not found: {PlanId}\", planId);\n                    return false;\n                }\n\n                plan.Code = dto.Code;\n                plan.Name = dto.Name;\n                plan.Description = dto.Description;\n                plan.IsActive = dto.IsActive;\n\n                _context.Plans.Update(plan);\n                await _context.SaveChangesAsync();\n\n                _logger.LogInformation(\"Plan {PlanId} updated successfully.\", planId);\n                return true;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error updating plan {PlanId}\", planId);\n                throw;\n            }\n        }\n\n        public async Task UpdatePlanPermissionsAsync(\n         Guid planId,\n         IReadOnlyCollection<Guid> permissionIds,\n         bool replaceAll,\n         string? assignedBy,\n         CancellationToken ct)\n        {\n            using var trx = await _context.Database.BeginTransactionAsync(ct);\n\n            var existing = await _context.PlanPermissions\n                .Where(pp => pp.PlanId == planId)\n                .ToListAsync(ct);\n\n            var want = new HashSet<Guid>(permissionIds);\n            var byPerm = existing.ToDictionary(pp => pp.PermissionId);\n\n            // upsert requested permissions â†’ Active\n            foreach (var pid in want)\n            {\n                if (byPerm.TryGetValue(pid, out var row))\n                {\n                    if (!row.IsActive)\n                    {\n                        row.IsActive = true;\n                        row.AssignedAt = DateTime.UtcNow;\n                        row.AssignedBy = assignedBy;\n                        _context.PlanPermissions.Update(row);\n                    }\n                }\n                else\n                {\n                    _context.PlanPermissions.Add(new PlanPermission\n                    {\n                        Id = Guid.NewGuid(),\n                        PlanId = planId,\n                        PermissionId = pid,\n                        IsActive = true,\n                        AssignedAt = DateTime.UtcNow,\n                        AssignedBy = assignedBy\n                    });\n                }\n            }\n\n            // replaceAll => deactivate anything not requested\n            if (replaceAll)\n            {\n                foreach (var row in existing)\n                {\n                    if (!want.Contains(row.PermissionId) && row.IsActive)\n                    {\n                        row.IsActive = false;\n                        _context.PlanPermissions.Update(row);\n                    }\n                }\n            }\n\n            await _context.SaveChangesAsync(ct);\n            await trx.CommitAsync(ct);\n\n            // Bust the plan permission cache\n            _permissionCacheService.ClearPlanPermissionsCache(planId);\n        }\n\n\n\n        //public async Task UpdatePlanPermissionsAsync(Guid planId, List<Guid> permissionIds)\n        //{\n        //    // Remove old mappings\n        //    var existing = await _context.PlanPermissions\n        //        .Where(pp => pp.PlanId == planId)\n        //        .ToListAsync();\n        //    _context.PlanPermissions.RemoveRange(existing);\n\n        //    // Add new mappings\n        //    var newMappings = permissionIds.Select(pid => new PlanPermission\n        //    {\n        //        PlanId = planId,\n        //        PermissionId = pid,\n        //        AssignedAt = DateTime.UtcNow,\n        //        AssignedBy = \"system\" // replace with logged-in admin\n        //    });\n\n        //    await _context.PlanPermissions.AddRangeAsync(newMappings);\n        //    await _context.SaveChangesAsync();\n        //    //// Clear cache\n        //    _permissionCacheService.ClearPlanPermissionsCache(planId);\n        //}\n        public async Task<List<PermissionDto>> GetPlanPermissionsAsync(Guid planId)\n        {\n            return await _context.PlanPermissions\n                .Where(pp => pp.PlanId == planId && pp.IsActive)\n                .Select(pp => new PermissionDto\n                {\n                    Id = pp.Permission.Id,\n                    Code = pp.Permission.Code,\n                    Name = pp.Permission.Name,\n                    Group = pp.Permission.Group,\n                    Description = pp.Permission.Description\n                })\n                .ToListAsync();\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccountInsights/Controllers/AccountInsightsController.cs",
      "sha256": "64cd25ac7e7add6b1b977d821ca5a3bbd51f641bab27fe9b07eeef17c55d220e",
      "language": "csharp",
      "size": 8520,
      "content": "using System;\nusing System.Security.Claims;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.AccountInsights.DTOs;\nusing xbytechat.api.Features.AccountInsights.Models;\nusing xbytechat.api.Features.AccountInsights.Services;\nusing xbytechat.api.Features.PlanManagement.Models;\nusing System.Text.Json;\nnamespace xbytechat.api.Features.AccountInsights.Controllers\n{\n    [ApiController]\n    [Route(\"api/admin/account-insights\")]\n    [Authorize(Roles = \"admin,superadmin,partner\")]\n    public class AccountInsightsController : ControllerBase\n    {\n        private readonly IAccountInsightsService _svc;\n        private readonly AppDbContext _db;\n        public AccountInsightsController(IAccountInsightsService svc, AppDbContext db)\n        {\n            _svc = svc;\n            _db = db;\n        }\n\n        [HttpGet(\"{businessId:guid}\")]\n        public async Task<IActionResult> GetOne(Guid businessId)\n        {\n            var snapshot = await _svc.GetSnapshotAsync(businessId);\n            return Ok(snapshot);\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> GetMany([FromQuery] int page = 1, [FromQuery] int pageSize = 50, [FromQuery] Guid? partnerId = null)\n        {\n            var snapshots = await _svc.GetSnapshotsAsync(page, pageSize, partnerId);\n            return Ok(snapshots);\n        }\n        [HttpGet(\"summary\")]\n        public async Task<IActionResult> GetSummary([FromQuery] Guid? partnerId = null)\n        {\n            var summary = await _svc.GetSummaryAsync(partnerId);\n            return Ok(summary);\n        }\n\n        [HttpGet(\"trial-expiring-soon\")]\n        public async Task<IActionResult> GetTrialsExpiringSoon([FromQuery] int days = 3)\n        {\n            var items = await _svc.GetTrialsExpiringSoonAsync(days);\n            return Ok(items);\n        }\n        [HttpGet(\"by-stage\")]\n        public async Task<IActionResult> GetByStage(\n            [FromQuery] AccountLifecycleStage stage,\n            [FromQuery] Guid? partnerId = null,\n            [FromQuery] int page = 1,\n            [FromQuery] int pageSize = 100)\n        {\n            var items = await _svc.GetByLifecycleStageAsync(stage, partnerId, page, pageSize);\n            return Ok(items);\n        }\n        [HttpGet(\"segment\")]\n        public async Task<IActionResult> GetSegment(\n            [FromQuery] string key,\n            [FromQuery] Guid? partnerId = null,\n            [FromQuery] int days = 3,\n            [FromQuery] int page = 1,\n            [FromQuery] int pageSize = 200)\n        {\n            if (string.IsNullOrWhiteSpace(key))\n                return BadRequest(\"Segment key is required.\");\n\n            key = key.Trim().ToLowerInvariant();\n\n            if (page <= 0) page = 1;\n            if (pageSize <= 0 || pageSize > 500) pageSize = 200;\n\n            IReadOnlyList<AccountInsightsSnapshotDto> items;\n\n            switch (key)\n            {\n                case \"trials-near-expiry\":\n                    // Trials whose trial window ends within next {days}\n                    items = await _svc.GetTrialsExpiringSoonAsync(days);\n                    break;\n\n                case \"no-usage-post-approval\":\n                case \"wa-setup-no-usage\":\n                    // Approved, never sent a message\n                    items = await _svc.GetByLifecycleStageAsync(\n                        AccountLifecycleStage.NoUsagePostApproval,\n                        partnerId,\n                        page,\n                        pageSize);\n                    break;\n\n                case \"at-risk\":\n                    items = await _svc.GetByLifecycleStageAsync(\n                        AccountLifecycleStage.AtRisk,\n                        partnerId,\n                        page,\n                        pageSize);\n                    break;\n\n                case \"dormant\":\n                    items = await _svc.GetByLifecycleStageAsync(\n                        AccountLifecycleStage.Dormant,\n                        partnerId,\n                        page,\n                        pageSize);\n                    break;\n\n                case \"healthy-active\":\n                    items = await _svc.GetByLifecycleStageAsync(\n                        AccountLifecycleStage.Active,\n                        partnerId,\n                        page,\n                        pageSize);\n                    break;\n\n                default:\n                    return BadRequest($\"Unknown segment key '{key}'.\");\n            }\n\n            return Ok(items);\n        }\n\n        [HttpGet(\"{businessId:guid}/actions\")]\n        public async Task<IActionResult> GetRecentActions(Guid businessId, [FromQuery] int limit = 10)\n        {\n            var items = await _svc.GetRecentActionsAsync(businessId, limit);\n            // Frontend supports both array and { items }; use { items } for clarity.\n            return Ok(new { items });\n        }\n        private string GetActor()\n        {\n            // Prefer email/username, fall back to subject or role\n            var email = User?.FindFirst(ClaimTypes.Email)?.Value;\n            var name = User?.Identity?.Name;\n\n            return !string.IsNullOrWhiteSpace(email)\n                ? email\n                : !string.IsNullOrWhiteSpace(name)\n                    ? name\n                    : \"admin\";\n        }\n\n        [HttpPost(\"{businessId:guid}/mark-contacted\")]\n        public async Task<IActionResult> MarkContacted(Guid businessId)\n        {\n            // No schema flag change; purely timeline-based\n            var actor = GetActor();\n\n            await _svc.LogActionAsync(\n                businessId,\n                AccountInsightActionTypes.TagContacted,\n                \"Marked as contacted\",\n                actor);\n\n            return Ok(new\n            {\n                ok = true,\n                businessId,\n                contacted = true\n            });\n        }\n        public class ExtendTrialRequest\n        {\n            public int ExtraDays { get; set; }\n        }\n\n        [HttpPost(\"{businessId:guid}/extend-trial\")]\n        public async Task<IActionResult> ExtendTrial(\n            Guid businessId,\n            [FromBody] ExtendTrialRequest body)\n        {\n            if (body == null || body.ExtraDays <= 0 || body.ExtraDays > 365)\n                return BadRequest(\"ExtraDays must be between 1 and 365.\");\n\n            var actor = GetActor();\n\n            var biz = await _db.Businesses\n                .Include(b => b.BusinessPlanInfo)\n                .FirstOrDefaultAsync(b => b.Id == businessId);\n\n            if (biz == null)\n                return NotFound(\"Business not found.\");\n\n            var plan = biz.BusinessPlanInfo;\n            if (plan == null)\n                return BadRequest(\"Business has no plan info.\");\n\n            if (plan.Plan != PlanType.Trial)\n                return BadRequest(\"Trial extension is only allowed for Trial plan.\");\n\n            var now = DateTime.UtcNow;\n\n            // current end date resolution (aligned with BuildSnapshotAsync)\n            var trialStart = plan.CreatedAt != default\n                ? plan.CreatedAt\n                : biz.CreatedAt;\n\n            DateTime currentEnd;\n            if (plan.QuotaResetDate != default && plan.QuotaResetDate > trialStart)\n            {\n                currentEnd = plan.QuotaResetDate;\n            }\n            else\n            {\n                currentEnd = trialStart.AddDays(14); // fallback consistent with DefaultTrialDaysFallback\n            }\n\n            var oldEnd = currentEnd;\n            var newEnd = oldEnd.AddDays(body.ExtraDays);\n\n            plan.QuotaResetDate = newEnd;\n            await _db.SaveChangesAsync();\n\n            var meta = JsonSerializer.Serialize(new\n            {\n                oldEnd,\n                newEnd,\n                extraDays = body.ExtraDays\n            });\n\n            await _svc.LogActionAsync(\n                businessId,\n                AccountInsightActionTypes.ExtendTrial,\n                $\"Trial extended by {body.ExtraDays} days\",\n                actor,\n                meta);\n\n            // Return updated snapshot so frontend stays in sync without extra roundtrip\n            var snapshot = await _svc.GetSnapshotAsync(businessId);\n\n            return Ok(new\n            {\n                ok = true,\n                businessId,\n                oldEnd,\n                newEnd,\n                snapshot\n            });\n        }\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccountInsights/DTOs/AccountInsightsActionDto.cs",
      "sha256": "b77b9c0ccf810b320dbbae050e075b6dc2da7cc80c8ac9316cc2136498311905",
      "language": "csharp",
      "size": 430,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AccountInsights.DTOs\n{\n    public class AccountInsightsActionDto\n    {\n        public long Id { get; set; }\n        public Guid BusinessId { get; set; }\n\n        public string Type { get; set; }\n        public string Label { get; set; }\n        public string Actor { get; set; }\n\n        public string MetaJson { get; set; }\n\n        public DateTime CreatedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccountInsights/DTOs/AccountInsightsSnapshotDto.cs",
      "sha256": "c2da56319228b929b1fd68165baacda30d7288b931c6c9a1c97c515c9c88d17f",
      "language": "csharp",
      "size": 1738,
      "content": "using System;\nusing xbytechat.api.Features.AccountInsights.Models;\nusing xbytechat.api.Features.PlanManagement.Models; // PlanType\n\nnamespace xbytechat.api.Features.AccountInsights.DTOs\n{\n    public class AccountInsightsSnapshotDto\n    {\n        public Guid BusinessId { get; set; }\n        public string BusinessName { get; set; }\n        public string BusinessEmail { get; set; }\n\n        public bool IsDeleted { get; set; }\n        public string Status { get; set; }           // Pending / Approved / Rejected (raw)\n        public bool IsApproved { get; set; }\n\n        public Guid? CreatedByPartnerId { get; set; }\n        public DateTime CreatedAt { get; set; }\n        public DateTime? ApprovedAt { get; set; }\n\n        // Plan / quota\n        public PlanType? PlanType { get; set; }\n        public int? TotalMonthlyQuota { get; set; }\n        public int? RemainingMessages { get; set; }\n        public DateTime? QuotaResetDate { get; set; }\n\n        // WhatsApp / onboarding\n        public bool HasWhatsAppConfig { get; set; }\n        public bool HasActiveWhatsAppNumber { get; set; }\n\n        // Usage\n        public bool HasAnyMessages { get; set; }\n        public DateTime? FirstMessageAt { get; set; }\n        public DateTime? LastMessageAt { get; set; }\n        public int MessagesLast30Days { get; set; }\n\n        // Lifecycle\n        public AccountLifecycleStage LifecycleStage { get; set; }\n        public int HealthScore { get; set; }\n\n        // Trial intelligence\n        public bool IsTrial { get; set; }\n        public DateTime? TrialStartAt { get; set; }\n        public DateTime? TrialEndsAt { get; set; }\n        public bool IsTrialExpiringSoon { get; set; }\n        public bool IsTrialExpired { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccountInsights/DTOs/AccountInsightsSummaryDto.cs",
      "sha256": "ccd45ad696bb4109efbaacbef1df10cc2e041a085b7e001b951d6ed2eaee4560",
      "language": "csharp",
      "size": 1128,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.AccountInsights.DTOs\n{\n    public class AccountInsightsSummaryDto\n    {\n        public DateTime GeneratedAtUtc { get; set; }\n\n        // Core counts\n        public int TotalBusinesses { get; set; }\n        public int ActiveBusinesses { get; set; }\n        public int AtRiskBusinesses { get; set; }\n        public int DormantBusinesses { get; set; }\n        public int NoUsagePostApproval { get; set; }\n\n        public int PendingApproval { get; set; }\n        public int Rejected { get; set; }\n        public int Deleted { get; set; }\n\n        // Plan\n        public int TrialPlan { get; set; }\n        public int PaidPlan { get; set; }\n        public int UnknownPlan { get; set; }\n\n        // Trial lifecycle\n        public int TrialTotal { get; set; }\n        public int TrialExpiringSoon { get; set; }\n        public int TrialExpiredNoUpgrade { get; set; }\n\n        // Distributions\n        public Dictionary<string, int> ByLifecycleStage { get; set; } = new();\n        public Dictionary<string, int> ByPlanType { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccountInsights/Models/AccountInsightActionTypes.cs",
      "sha256": "7055e4c6a231ed5f9738be56baf19b9a6fe8cf019469c2a74616a2b04d373f09",
      "language": "csharp",
      "size": 875,
      "content": "namespace xbytechat.api.Features.AccountInsights.Models\n{\n    /// <summary>\n    /// Canonical action type codes for AccountInsightsAction.ActionType.\n    /// Keeps frontend and backend aligned and avoids random strings.\n    /// </summary>\n    public static class AccountInsightActionTypes\n    {\n        // Manual sales / CS actions\n        public const string TagContacted = \"TAG_CONTACTED\";\n\n        // Trial lifecycle (only log when an actual manual/system CHANGE happens)\n        public const string ExtendTrial = \"EXTEND_TRIAL\";\n\n        // Plan changes\n        public const string PlanUpgraded = \"PLAN_UPGRADED\";\n        public const string PlanDowngraded = \"PLAN_DOWNGRADED\";\n\n        // System nudges (emails / campaigns etc.)\n        public const string SystemNudge = \"SYSTEM_NUDGE\";\n\n        // Generic manual note\n        public const string Note = \"NOTE\";\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccountInsights/Models/AccountInsightsAction.cs",
      "sha256": "06bf45cb34c4a8d6d783ccbe9794df5a37e3972cbd2527ab66434170f5e5355b",
      "language": "csharp",
      "size": 1298,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AccountInsights.Models\n{\n    /// <summary>\n    /// Lightweight append-only log of important micro-actions taken on an account.\n    /// Used to power the Recent Activity timeline in Account Insights UI.\n    /// </summary>\n    public class AccountInsightsAction\n    {\n        public long Id { get; set; }\n\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// Machine-friendly action code, e.g. \"TAG_CONTACTED\", \"EXTEND_TRIAL\".\n        /// </summary>\n        public string ActionType { get; set; }\n\n        /// <summary>\n        /// Human-readable label shown in the UI timeline.\n        /// </summary>\n        public string Label { get; set; }\n\n        /// <summary>\n        /// Who performed the action (user email/id) or \"system\".\n        /// </summary>\n        public string Actor { get; set; }\n\n        /// <summary>\n        /// Optional JSON blob for extra context (e.g. { \"extraDays\": 7 }).\n        /// Stored as string for simplicity; can be mapped to JSONB on the DB side.\n        /// </summary>\n        public string MetaJson { get; set; }\n\n        /// <summary>\n        /// UTC timestamp when the action occurred.\n        /// </summary>\n        public DateTime CreatedAtUtc { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccountInsights/Models/AccountLifecycleStage.cs",
      "sha256": "4fcb2d0f0326c4bc85cc7e3e2836bc2c64d0956002e5807ee4cb1f3df2cef89c",
      "language": "csharp",
      "size": 695,
      "content": "namespace xbytechat.api.Features.AccountInsights.Models\n{\n    public enum AccountLifecycleStage\n    {\n        Unknown = 0,\n\n        PendingApproval = 10,      // Signed up, not yet approved\n        Rejected = 20,             // Explicitly rejected\n        InactiveDeleted = 25,      // Soft-deleted\n\n        Trial = 30,                // Trial plan, approved, some activity or in trial window\n        Active = 40,               // Approved + active usage\n        AtRisk = 50,               // Approved + low/no recent usage\n        Dormant = 60,              // Approved but idle for a long time\n\n        NoUsagePostApproval = 70   // Approved but literally never used (high churn risk)\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccountInsights/Services/AccountInsightsAlertService.cs",
      "sha256": "ee402e60508d432937e55c465d3a883d5708315bd4e297cddca077f99e7793d8",
      "language": "csharp",
      "size": 2033,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.AccountInsights.DTOs;\nusing xbytechat.api.Features.AccountInsights.Models;\nusing xbytechat.api.Features.AccountInsights.Services;\n\nnamespace xbytechat.api.Features.AccountInsights.Services\n{\n    public interface IAccountInsightsAlertService\n    {\n        Task<IReadOnlyList<AccountInsightsSnapshotDto>> GetTrialExpiringSoonAsync(int days = 3);\n        Task<IReadOnlyList<AccountInsightsSnapshotDto>> GetInactivePostApprovalAsync();\n    }\n\n    /// <summary>\n    /// Read-only helper for schedulers / workers to fetch cohorts that should be nudged.\n    /// This layer does NOT send messages itself.\n    /// </summary>\n    public class AccountInsightsAlertService : IAccountInsightsAlertService\n    {\n        private readonly IAccountInsightsService _insights;\n        private readonly ILogger<AccountInsightsAlertService> _log;\n\n        public AccountInsightsAlertService(\n            IAccountInsightsService insights,\n            ILogger<AccountInsightsAlertService> log)\n        {\n            _insights = insights;\n            _log = log;\n        }\n\n        public async Task<IReadOnlyList<AccountInsightsSnapshotDto>> GetTrialExpiringSoonAsync(int days = 3)\n        {\n            // Uses core logic; safe to call from a daily/cron job.\n            var list = await _insights.GetTrialsExpiringSoonAsync(days);\n            _log.LogInformation(\"Found {Count} trials expiring in next {Days} days\", list.Count, days);\n            return list;\n        }\n\n        public async Task<IReadOnlyList<AccountInsightsSnapshotDto>> GetInactivePostApprovalAsync()\n        {\n            // NoUsagePostApproval cohort: approved, no messages ever.\n            var list = await _insights.GetByLifecycleStageAsync(AccountLifecycleStage.NoUsagePostApproval);\n            _log.LogInformation(\"Found {Count} approved accounts with no usage post-approval\", list.Count);\n            return list;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccountInsights/Services/AccountInsightsService.cs",
      "sha256": "8d6457fc7aefe15956384777654cf665ca72fc9349990888d8ae9ba5764bdfe2",
      "language": "csharp",
      "size": 18261,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api;\nusing xbytechat.api.Features.AccountInsights.DTOs;\nusing xbytechat.api.Features.AccountInsights.Models;\nusing xbytechat.api.Features.BusinessModule.Models;\nusing xbytechat.api.Features.PlanManagement.Models; // PlanType\nusing xbytechat.api.Models.BusinessModel;          // BusinessPlanInfo\n\nnamespace xbytechat.api.Features.AccountInsights.Services\n{\n    public class AccountInsightsService : IAccountInsightsService\n    {\n        private readonly AppDbContext _db;\n        private readonly ILogger<AccountInsightsService> _log;\n\n        private const int TrialExpiringSoonDays = 3;\n        private const int DefaultTrialDaysFallback = 14;\n\n        public AccountInsightsService(AppDbContext db, ILogger<AccountInsightsService> log)\n        {\n            _db = db;\n            _log = log;\n        }\n\n        public async Task<AccountInsightsSnapshotDto> GetSnapshotAsync(Guid businessId)\n        {\n            var biz = await _db.Businesses\n                .Include(b => b.BusinessPlanInfo)\n                .FirstOrDefaultAsync(b => b.Id == businessId);\n\n            if (biz == null)\n                throw new InvalidOperationException($\"Business {businessId} not found\");\n\n            return await BuildSnapshotAsync(biz);\n        }\n\n        public async Task<IReadOnlyList<AccountInsightsSnapshotDto>> GetSnapshotsAsync(\n            int page = 1,\n            int pageSize = 50,\n            Guid? partnerId = null)\n        {\n            if (page <= 0) page = 1;\n            if (pageSize <= 0 || pageSize > 500) pageSize = 50;\n\n            var query = _db.Businesses\n                .Include(b => b.BusinessPlanInfo)\n                .AsQueryable();\n\n            if (partnerId.HasValue)\n            {\n                query = query.Where(b => b.CreatedByPartnerId == partnerId.Value);\n            }\n\n            query = query.OrderByDescending(b => b.CreatedAt);\n\n            var list = await query\n                .Skip((page - 1) * pageSize)\n                .Take(pageSize)\n                .ToListAsync();\n\n            var snapshots = new List<AccountInsightsSnapshotDto>(list.Count);\n            foreach (var biz in list)\n            {\n                snapshots.Add(await BuildSnapshotAsync(biz));\n            }\n\n            return snapshots;\n        }\n\n        // ---------- Core snapshot builder ----------\n\n        private async Task<AccountInsightsSnapshotDto> BuildSnapshotAsync(Business biz)\n        {\n            var now = DateTime.UtcNow;\n            var thirtyDaysAgo = now.AddDays(-30);\n            var ninetyDaysAgo = now.AddDays(-90);\n\n            var hasWaConfig = await _db.WhatsAppSettings\n                .AnyAsync(x => x.BusinessId == biz.Id && x.IsActive);\n\n            var hasActiveWaNumber = await _db.WhatsAppPhoneNumbers\n                .AnyAsync(x => x.BusinessId == biz.Id && x.IsActive);\n\n            var msgQuery = _db.MessageLogs.Where(m => m.BusinessId == biz.Id);\n            var hasAnyMessages = await msgQuery.AnyAsync();\n\n            DateTime? firstMessageAt = null;\n            DateTime? lastMessageAt = null;\n            var messagesLast30 = 0;\n\n            if (hasAnyMessages)\n            {\n                firstMessageAt = await msgQuery.MinAsync(m => (DateTime?)m.CreatedAt);\n                lastMessageAt = await msgQuery.MaxAsync(m => (DateTime?)m.CreatedAt);\n                messagesLast30 = await msgQuery.CountAsync(m => m.CreatedAt >= thirtyDaysAgo);\n            }\n\n            var planInfo = biz.BusinessPlanInfo;\n\n            // ---- Trial derivation ----\n            bool isTrial = false;\n            DateTime? trialStart = null;\n            DateTime? trialEnd = null;\n            bool trialExpiringSoon = false;\n            bool trialExpired = false;\n\n            if (planInfo != null &&\n                planInfo.Plan == PlanType.Trial &&\n                !biz.IsDeleted)\n            {\n                isTrial = true;\n\n                trialStart = planInfo.CreatedAt != default\n                    ? planInfo.CreatedAt\n                    : biz.CreatedAt;\n\n                if (trialStart.HasValue)\n                {\n                    if (planInfo.QuotaResetDate != default &&\n                        planInfo.QuotaResetDate > trialStart.Value)\n                    {\n                        trialEnd = planInfo.QuotaResetDate;\n                    }\n                    else\n                    {\n                        trialEnd = trialStart.Value.AddDays(DefaultTrialDaysFallback);\n                    }\n                }\n\n                if (trialEnd.HasValue)\n                {\n                    if (now <= trialEnd.Value)\n                    {\n                        var daysLeft = (trialEnd.Value - now).TotalDays;\n                        if (daysLeft >= 0 && daysLeft <= TrialExpiringSoonDays)\n                            trialExpiringSoon = true;\n                    }\n                    else\n                    {\n                        trialExpired = true;\n                    }\n                }\n            }\n\n            var stage = ComputeLifecycleStage(\n                biz,\n                hasWaConfig,\n                hasActiveWaNumber,\n                hasAnyMessages,\n                lastMessageAt,\n                messagesLast30,\n                now,\n                ninetyDaysAgo);\n\n            var health = ComputeHealthScore(\n                stage,\n                hasWaConfig,\n                hasActiveWaNumber,\n                messagesLast30,\n                lastMessageAt,\n                now);\n\n            return new AccountInsightsSnapshotDto\n            {\n                BusinessId = biz.Id,\n                BusinessName = biz.BusinessName,\n                BusinessEmail = biz.BusinessEmail,\n                IsDeleted = biz.IsDeleted,\n                Status = biz.Status.ToString(),\n                IsApproved = biz.IsApproved,\n                CreatedByPartnerId = biz.CreatedByPartnerId,\n                CreatedAt = biz.CreatedAt,\n                ApprovedAt = biz.ApprovedAt,\n\n                PlanType = planInfo?.Plan,\n                TotalMonthlyQuota = planInfo?.TotalMonthlyQuota,\n                RemainingMessages = planInfo?.RemainingMessages,\n                QuotaResetDate = planInfo?.QuotaResetDate,\n\n                HasWhatsAppConfig = hasWaConfig,\n                HasActiveWhatsAppNumber = hasActiveWaNumber,\n\n                HasAnyMessages = hasAnyMessages,\n                FirstMessageAt = firstMessageAt,\n                LastMessageAt = lastMessageAt,\n                MessagesLast30Days = messagesLast30,\n\n                LifecycleStage = stage,\n                HealthScore = health,\n\n                IsTrial = isTrial,\n                TrialStartAt = trialStart,\n                TrialEndsAt = trialEnd,\n                IsTrialExpiringSoon = trialExpiringSoon,\n                IsTrialExpired = trialExpired\n            };\n        }\n\n        private static AccountLifecycleStage ComputeLifecycleStage(\n            Business biz,\n            bool hasWaConfig,\n            bool hasActiveWaNumber,\n            bool hasAnyMessages,\n            DateTime? lastMessageAt,\n            int messagesLast30,\n            DateTime now,\n            DateTime ninetyDaysAgo)\n        {\n            if (biz.IsDeleted)\n                return AccountLifecycleStage.InactiveDeleted;\n\n            switch (biz.Status)\n            {\n                case Business.StatusType.Rejected:\n                    return AccountLifecycleStage.Rejected;\n                case Business.StatusType.Pending:\n                    return AccountLifecycleStage.PendingApproval;\n            }\n\n            if (!biz.IsApproved)\n                return AccountLifecycleStage.Unknown;\n\n            if (!hasAnyMessages)\n                return AccountLifecycleStage.NoUsagePostApproval;\n\n            if (messagesLast30 > 0)\n                return AccountLifecycleStage.Active;\n\n            if (lastMessageAt.HasValue && lastMessageAt.Value < ninetyDaysAgo)\n                return AccountLifecycleStage.Dormant;\n\n            return AccountLifecycleStage.AtRisk;\n        }\n\n        private static int ComputeHealthScore(\n            AccountLifecycleStage stage,\n            bool hasWaConfig,\n            bool hasActiveWaNumber,\n            int messagesLast30,\n            DateTime? lastMessageAt,\n            DateTime now)\n        {\n            if (stage == AccountLifecycleStage.InactiveDeleted ||\n                stage == AccountLifecycleStage.Rejected)\n                return 0;\n\n            var score = 0;\n\n            if (hasWaConfig) score += 15;\n            if (hasActiveWaNumber) score += 15;\n\n            if (messagesLast30 > 0)\n            {\n                score += 40;\n                if (messagesLast30 > 50) score += 10;\n                if (messagesLast30 > 200) score += 10;\n            }\n            else if (lastMessageAt.HasValue)\n            {\n                var days = (now - lastMessageAt.Value).TotalDays;\n                if (days <= 30) score += 30;\n                else if (days <= 90) score += 15;\n            }\n\n            switch (stage)\n            {\n                case AccountLifecycleStage.Active:\n                    score += 20;\n                    break;\n                case AccountLifecycleStage.AtRisk:\n                    score += 5;\n                    break;\n                case AccountLifecycleStage.NoUsagePostApproval:\n                    score -= 10;\n                    break;\n                case AccountLifecycleStage.Dormant:\n                    score -= 20;\n                    break;\n            }\n\n            if (score < 0) score = 0;\n            if (score > 100) score = 100;\n\n            return score;\n        }\n\n        // ---------- Summary ----------\n\n        public async Task<AccountInsightsSummaryDto> GetSummaryAsync(Guid? partnerId = null)\n        {\n            var now = DateTime.UtcNow;\n\n            var bizQuery = _db.Businesses\n                .Include(b => b.BusinessPlanInfo)\n                .AsQueryable();\n\n            if (partnerId.HasValue)\n                bizQuery = bizQuery.Where(b => b.CreatedByPartnerId == partnerId.Value);\n\n            var businesses = await bizQuery.ToListAsync();\n\n            var summary = new AccountInsightsSummaryDto\n            {\n                GeneratedAtUtc = now,\n                TotalBusinesses = businesses.Count\n            };\n\n            var stageCounts = new Dictionary<AccountLifecycleStage, int>();\n            var planCounts = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);\n\n            foreach (var biz in businesses)\n            {\n                var snapshot = await BuildSnapshotAsync(biz);\n\n                if (snapshot.IsDeleted)\n                    summary.Deleted++;\n\n                switch (snapshot.Status)\n                {\n                    case nameof(Business.StatusType.Pending):\n                        summary.PendingApproval++;\n                        break;\n                    case nameof(Business.StatusType.Rejected):\n                        summary.Rejected++;\n                        break;\n                }\n\n                if (!stageCounts.ContainsKey(snapshot.LifecycleStage))\n                    stageCounts[snapshot.LifecycleStage] = 0;\n                stageCounts[snapshot.LifecycleStage]++;\n\n                switch (snapshot.LifecycleStage)\n                {\n                    case AccountLifecycleStage.Active:\n                        summary.ActiveBusinesses++;\n                        break;\n                    case AccountLifecycleStage.AtRisk:\n                        summary.AtRiskBusinesses++;\n                        break;\n                    case AccountLifecycleStage.Dormant:\n                        summary.DormantBusinesses++;\n                        break;\n                    case AccountLifecycleStage.NoUsagePostApproval:\n                        summary.NoUsagePostApproval++;\n                        break;\n                }\n\n                if (snapshot.PlanType.HasValue)\n                {\n                    var planKey = snapshot.PlanType.Value.ToString();\n                    if (!planCounts.ContainsKey(planKey))\n                        planCounts[planKey] = 0;\n                    planCounts[planKey]++;\n\n                    if (snapshot.PlanType.Value == PlanType.Trial)\n                        summary.TrialPlan++;\n                    else\n                        summary.PaidPlan++;\n                }\n                else\n                {\n                    summary.UnknownPlan++;\n                    if (!planCounts.ContainsKey(\"Unknown\"))\n                        planCounts[\"Unknown\"] = 0;\n                    planCounts[\"Unknown\"]++;\n                }\n\n                if (snapshot.IsTrial)\n                {\n                    summary.TrialTotal++;\n\n                    if (snapshot.IsTrialExpiringSoon &&\n                        !snapshot.IsDeleted &&\n                        snapshot.LifecycleStage != AccountLifecycleStage.Rejected)\n                    {\n                        summary.TrialExpiringSoon++;\n                    }\n\n                    if (snapshot.IsTrialExpired &&\n                        !snapshot.IsDeleted &&\n                        snapshot.PlanType == PlanType.Trial)\n                    {\n                        summary.TrialExpiredNoUpgrade++;\n                    }\n                }\n            }\n\n            foreach (var kv in stageCounts)\n                summary.ByLifecycleStage[kv.Key.ToString()] = kv.Value;\n\n            foreach (var kv in planCounts)\n                summary.ByPlanType[kv.Key] = kv.Value;\n\n            return summary;\n        }\n\n        // ---------- Queries used by AlertService ----------\n\n        public async Task<IReadOnlyList<AccountInsightsSnapshotDto>> GetTrialsExpiringSoonAsync(int days = TrialExpiringSoonDays)\n        {\n            if (days <= 0) days = TrialExpiringSoonDays;\n\n            var now = DateTime.UtcNow;\n            var maxDate = now.AddDays(days);\n\n            var trials = await _db.Businesses\n                .Include(b => b.BusinessPlanInfo)\n                .Where(b =>\n                    !b.IsDeleted &&\n                    b.BusinessPlanInfo != null &&\n                    b.BusinessPlanInfo.Plan == PlanType.Trial)\n                .ToListAsync();\n\n            var list = new List<AccountInsightsSnapshotDto>();\n\n            foreach (var biz in trials)\n            {\n                var snapshot = await BuildSnapshotAsync(biz);\n\n                if (snapshot.IsTrial &&\n                    snapshot.TrialEndsAt.HasValue &&\n                    snapshot.TrialEndsAt.Value >= now &&\n                    snapshot.TrialEndsAt.Value <= maxDate &&\n                    !snapshot.IsTrialExpired)\n                {\n                    list.Add(snapshot);\n                }\n            }\n\n            return list;\n        }\n\n        public async Task<IReadOnlyList<AccountInsightsSnapshotDto>> GetByLifecycleStageAsync(\n            AccountLifecycleStage stage,\n            Guid? partnerId = null,\n            int page = 1,\n            int pageSize = 100)\n        {\n            if (page <= 0) page = 1;\n            if (pageSize <= 0 || pageSize > 500) pageSize = 100;\n\n            var query = _db.Businesses\n                .Include(b => b.BusinessPlanInfo)\n                .AsQueryable();\n\n            if (partnerId.HasValue)\n                query = query.Where(b => b.CreatedByPartnerId == partnerId.Value);\n\n            query = query.OrderByDescending(b => b.CreatedAt);\n\n            var businesses = await query\n                .Skip((page - 1) * pageSize)\n                .Take(pageSize)\n                .ToListAsync();\n\n            var result = new List<AccountInsightsSnapshotDto>();\n\n            foreach (var biz in businesses)\n            {\n                var snapshot = await BuildSnapshotAsync(biz);\n                if (snapshot.LifecycleStage == stage)\n                    result.Add(snapshot);\n            }\n\n            return result;\n        }\n\n        public async Task<IReadOnlyList<AccountInsightsActionDto>> GetRecentActionsAsync(\n        Guid businessId,\n        int limit = 10)\n        {\n            if (limit <= 0 || limit > 100)\n                limit = 10;\n\n            var actions = await _db.AccountInsightsActions\n                .Where(a => a.BusinessId == businessId)\n                .OrderByDescending(a => a.CreatedAtUtc)\n                .Take(limit)\n                .ToListAsync();\n\n            var dtos = actions\n                .Select(a => new AccountInsightsActionDto\n                {\n                    Id = a.Id,\n                    BusinessId = a.BusinessId,\n                    Type = a.ActionType,\n                    Label = a.Label,\n                    Actor = a.Actor,\n                    MetaJson = a.MetaJson,\n                    CreatedAt = a.CreatedAtUtc\n                })\n                .ToList();\n\n            return dtos;\n        }\n\n        public async Task LogActionAsync(\n    Guid businessId,\n    string actionType,\n    string label,\n    string actor,\n    string metaJson = null)\n        {\n            if (businessId == Guid.Empty)\n                throw new ArgumentException(\"BusinessId is required\", nameof(businessId));\n\n            if (string.IsNullOrWhiteSpace(actionType))\n                throw new ArgumentException(\"ActionType is required\", nameof(actionType));\n\n            if (string.IsNullOrWhiteSpace(label))\n                label = actionType;\n\n            var safeActor = string.IsNullOrWhiteSpace(actor) ? \"system\" : actor.Trim();\n\n            var entity = new AccountInsightsAction\n            {\n                BusinessId = businessId,\n                ActionType = actionType,\n                Label = label,\n                Actor = safeActor,\n                MetaJson = metaJson ?? string.Empty,\n                CreatedAtUtc = DateTime.UtcNow\n            };\n\n            _db.AccountInsightsActions.Add(entity);\n            await _db.SaveChangesAsync();\n\n            _log.LogInformation(\n                \"AccountInsightsAction logged: {BusinessId} {Type} by {Actor}\",\n                businessId,\n                actionType,\n                safeActor);\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccountInsights/Services/IAccountInsightsService.cs",
      "sha256": "a3ae86511f2774208f11cdbac7813469b4970c16ad5ff767b7f23273cc6bc1d8",
      "language": "csharp",
      "size": 1202,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.AccountInsights.DTOs;\nusing xbytechat.api.Features.AccountInsights.Models;\n\nnamespace xbytechat.api.Features.AccountInsights.Services\n{\n    public interface IAccountInsightsService\n    {\n        Task<AccountInsightsSnapshotDto> GetSnapshotAsync(Guid businessId);\n\n        Task<IReadOnlyList<AccountInsightsSnapshotDto>> GetSnapshotsAsync(\n            int page = 1,\n            int pageSize = 50,\n            Guid? partnerId = null);\n\n        Task<AccountInsightsSummaryDto> GetSummaryAsync(Guid? partnerId = null);\n\n        Task<IReadOnlyList<AccountInsightsSnapshotDto>> GetTrialsExpiringSoonAsync(int days = 3);\n\n        Task<IReadOnlyList<AccountInsightsSnapshotDto>> GetByLifecycleStageAsync(\n            AccountLifecycleStage stage,\n            Guid? partnerId = null,\n            int page = 1,\n            int pageSize = 100);\n\n        Task<IReadOnlyList<AccountInsightsActionDto>> GetRecentActionsAsync(\n       Guid businessId,\n       int limit = 10);\n\n        Task LogActionAsync(\n           Guid businessId, string actionType,string label, string actor,string metaJson = null);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Audiences/Controllers/AudienceController.cs",
      "sha256": "36755710674031902cf3133a3308170d732b23a2eb5cc6c6dcba17589b8fec7e",
      "language": "csharp",
      "size": 2865,
      "content": "using System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing xbytechat.api;\nusing xbytechat.api.Features.Audiences.DTOs;\nusing xbytechat.api.Features.Audiences.Services;\nusing xbytechat.api.Shared; // User.GetBusinessId()\n\nnamespace xbytechat.api.Features.Audiences.Controllers\n{\n    [ApiController]\n    [Route(\"api/audiences\")]\n    [Authorize]\n    public class AudienceController : ControllerBase\n    {\n        private readonly AppDbContext _db;\n        private readonly IAudienceService _svc;\n\n        public AudienceController(AppDbContext db, IAudienceService svc)\n        { _db = db; _svc = svc; }\n\n        [HttpPost]\n        public async Task<IActionResult> Create([FromBody] AudienceCreateDto dto)\n        {\n            var businessId = User.GetBusinessId();\n            var userName = User.Identity?.Name ?? \"system\";\n            if (businessId == Guid.Empty) return Unauthorized();\n\n            if (string.IsNullOrWhiteSpace(dto?.Name))\n                return BadRequest(new { success = false, message = \"Name is required\" });\n\n            var id = await _svc.CreateAsync(businessId, dto!, userName);\n            return Ok(new { success = true, id });\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> List()\n        {\n            var businessId = User.GetBusinessId();\n            if (businessId == Guid.Empty) return Unauthorized();\n\n            var items = await _svc.ListAsync(businessId);\n            return Ok(new { success = true, items });\n        }\n\n        [HttpPost(\"{audienceId:guid}/assign\")]\n        public async Task<IActionResult> Assign(Guid audienceId, [FromBody] AudienceAssignDto dto)\n        {\n            var businessId = User.GetBusinessId();\n            var userName = User.Identity?.Name ?? \"system\";\n            if (businessId == Guid.Empty) return Unauthorized();\n\n            var ok = await _svc.AssignAsync(businessId, audienceId, dto ?? new AudienceAssignDto(), userName);\n            return Ok(new { success = ok });\n        }\n\n        [HttpGet(\"{audienceId:guid}/members\")]\n        public async Task<IActionResult> Members(Guid audienceId, [FromQuery] int page = 1, [FromQuery] int pageSize = 50)\n        {\n            var businessId = User.GetBusinessId();\n            if (businessId == Guid.Empty) return Unauthorized();\n\n            var exists = await _db.Audiences.AnyAsync(a => a.Id == audienceId && a.BusinessId == businessId && !a.IsDeleted);\n            if (!exists) return NotFound(new { success = false, message = \"Audience not found\" });\n\n            var rows = await _svc.GetMembersAsync(businessId, audienceId, page, pageSize);\n            return Ok(new { success = true, items = rows, page, pageSize });\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Audiences/Controllers/AudienceImportController.cs",
      "sha256": "3b83d236a62b4def34dc67cda4f095665cdc144985151dd97565eb8de142268d",
      "language": "csharp",
      "size": 1639,
      "content": "using System;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.AspNetCore.Mvc;\nusing Serilog;\nusing xbytechat.api.Features.Audiences.Services;\nusing xbytechat.api.Shared; // User.GetBusinessId()\n\nnamespace xbytechat.api.Features.Audiences.Controllers\n{\n    [ApiController]\n    [Route(\"api/audiences/import\")]\n    [Authorize]\n    public class AudienceImportController : ControllerBase\n    {\n        private readonly IAudienceImportService _svc;\n\n        public AudienceImportController(IAudienceImportService svc)\n        {\n            _svc = svc;\n        }\n\n        //[HttpPost(\"csv\")]\n        //[RequestSizeLimit(64_000_000)] // 64 MB\n        //public async Task<IActionResult> ImportCsv([FromForm] IFormFile file)\n        //{\n        //    var businessId = User.GetBusinessId();\n        //    if (businessId == Guid.Empty) return Unauthorized();\n\n        //    if (file == null || file.Length == 0)\n        //        return BadRequest(new { success = false, message = \"CSV file is required\" });\n\n        //    try\n        //    {\n        //        await using var stream = file.OpenReadStream();\n        //        var resp = await _svc.ImportCsvAsync(businessId, stream, file.FileName, HttpContext.RequestAborted);\n\n        //        return Ok(new { success = true, data = resp });\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        Log.Error(ex, \"âŒ CSV import failed | biz={Biz}\", businessId);\n        //        return StatusCode(500, new { success = false, message = \"CSV import failed\" });\n        //    }\n        //}\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Audiences/DTOs/AudienceDtos.cs",
      "sha256": "36380702ffe3286aab70c4f45799ef8fc330b26eb9eae08190a307598ade1aa7",
      "language": "csharp",
      "size": 1198,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.Audiences.DTOs\n{\n    public class AudienceCreateDto\n    {\n        public string Name { get; set; } = \"\";\n        public string? Description { get; set; }\n    }\n\n    public class AudienceSummaryDto\n    {\n        public Guid Id { get; set; }\n        public string Name { get; set; } = \"\";\n        public string? Description { get; set; }\n        public int MemberCount { get; set; }\n        public DateTime CreatedAt { get; set; }\n    }\n\n    public class AudienceMemberDto\n    {\n        public Guid Id { get; set; }\n        public Guid? ContactId { get; set; }   // optional link to CRM contact\n        public string? Name { get; set; }\n        public string? PhoneNumber { get; set; }\n        public string? Email { get; set; }\n        public string? VariablesJson { get; set; } // if your model stores row-level vars\n        public DateTime CreatedAt { get; set; }\n    }\n\n    public class AudienceAssignDto\n    {\n        public List<Guid> ContactIds { get; set; } = new(); // optional: assign CRM contacts\n        public Guid? CsvBatchId { get; set; }               // optional: attach CSV batch to audience\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Audiences/DTOs/CsvImportDtos.cs",
      "sha256": "c93d41ac64223fad52cd0ce3cb909af0347cac1e44b642fcdc9139c013b1ba73",
      "language": "csharp",
      "size": 342,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.Audiences.DTOs\n{\n    public class CsvImportResponseDto\n    {\n        public Guid BatchId { get; set; }\n        public int RowCount { get; set; }\n        public List<string> Columns { get; set; } = new();\n        public DateTime CreatedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Audiences/Services/AudienceImportService.cs",
      "sha256": "5f990d10d95cab3f23dec45ac06e073f26e7cb72107ab594dcea39e220d95e82",
      "language": "csharp",
      "size": 4348,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing xbytechat.api;\nusing xbytechat.api.Features.Audiences.DTOs;\n\nnamespace xbytechat.api.Features.Audiences.Services\n{\n    public class AudienceImportService : IAudienceImportService\n    {\n        private readonly AppDbContext _db;\n\n        public AudienceImportService(AppDbContext db)\n        {\n            _db = db;\n        }\n\n        public async Task<CsvImportResponseDto> ImportCsvAsync(\n            Guid businessId,\n            Stream csvStream,\n            string fileName,\n            CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty)\n                throw new UnauthorizedAccessException(\"Invalid business id.\");\n\n            if (csvStream == null || !csvStream.CanRead)\n                throw new ArgumentException(\"CSV stream is not readable.\");\n\n            using var reader = new StreamReader(csvStream);\n\n            // --- header row ---\n            var headerLine = await reader.ReadLineAsync();\n            if (string.IsNullOrWhiteSpace(headerLine))\n                throw new InvalidOperationException(\"Empty CSV.\");\n\n            var headers = headerLine.Split(',')\n                                    .Select(h => (h ?? string.Empty).Trim())\n                                    .Where(h => !string.IsNullOrWhiteSpace(h))\n                                    .ToList();\n\n            if (headers.Count == 0)\n                throw new InvalidOperationException(\"No columns.\");\n\n            var batchId = Guid.NewGuid();\n            var now = DateTime.UtcNow;\n\n            // Pre-create batch // need to Reconfirm\n            _db.CsvBatches.Add(new Features.CampaignModule.Models.CsvBatch\n            {\n                Id = batchId,\n                BusinessId = businessId,\n                FileName = fileName,\n                // âœ… match your model: CsvBatch.HeadersJson\n                HeadersJson = Newtonsoft.Json.JsonConvert.SerializeObject(headers),\n                RowCount = 0,\n                CreatedAt = now\n            });\n\n            var rowsBuffer = new List<Features.CampaignModule.Models.CsvRow>(capacity: 1024);\n            var total = 0;\n\n            // naive CSV parse (comma-only, no quoting in v1)\n            while (!reader.EndOfStream)\n            {\n                var line = await reader.ReadLineAsync();\n                if (string.IsNullOrWhiteSpace(line)) continue;\n\n                var cells = line.Split(',');\n                var dict = new Dictionary<string, string?>();\n                for (int i = 0; i < headers.Count; i++)\n                {\n                    var v = (i < cells.Length ? cells[i] : null)?.Trim();\n                    dict[headers[i]] = v;\n                }\n\n                rowsBuffer.Add(new Features.CampaignModule.Models.CsvRow\n                {\n                    Id = Guid.NewGuid(),\n                    BatchId = batchId,\n                    // ðŸ” If your property is not RowJson, change this to the correct one (e.g., DataJson)\n                    RowJson = Newtonsoft.Json.JsonConvert.SerializeObject(dict),\n                    CreatedAt = DateTime.UtcNow\n                });\n\n                total++;\n\n                // chunked insert every 1k for memory safety\n                if (rowsBuffer.Count >= 1000)\n                {\n                    await _db.CsvRows.AddRangeAsync(rowsBuffer, ct);\n                    await _db.SaveChangesAsync(ct);\n                    rowsBuffer.Clear();\n                }\n            }\n\n            if (rowsBuffer.Count > 0)\n            {\n                await _db.CsvRows.AddRangeAsync(rowsBuffer, ct);\n            }\n\n            // update batch row count\n            var batchRow = await _db.CsvBatches.FirstAsync(b => b.Id == batchId, ct);\n            batchRow.RowCount = total;\n\n            await _db.SaveChangesAsync(ct);\n\n            Log.Information(\"ðŸ“¥ CSV imported | biz={Biz} batch={Batch} rows={Rows} file={File}\",\n                businessId, batchId, total, fileName);\n\n            return new CsvImportResponseDto\n            {\n                BatchId = batchId,\n                RowCount = total,\n                Columns = headers,\n                CreatedAt = now\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Audiences/Services/AudienceService.cs",
      "sha256": "fb57c4508c2c26b3104efdc7523cb47fde69b702d427bcfd45b205e481877369",
      "language": "csharp",
      "size": 9457,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing xbytechat.api;\nusing xbytechat.api.Features.Audiences.DTOs;\nusing xbytechat.api.Features.CampaignModule.Models;\nusing xbytechat.api.Features.CRM.Models;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.Audiences.Services\n{\n    public class AudienceService : IAudienceService\n    {\n        private readonly AppDbContext _db;\n\n        public AudienceService(AppDbContext db) { _db = db; }\n\n        public async Task<Guid> CreateAsync(Guid businessId, AudienceCreateDto dto, string createdBy)\n        {\n            var id = Guid.NewGuid();\n            try\n            {\n                var now = DateTime.UtcNow;\n                Guid? createdByUserId = null;\n                if (Guid.TryParse(createdBy, out var parsed)) createdByUserId = parsed;\n\n                // âœ… Normalize name (trim + lower for comparison)\n                var name = (dto?.Name?.Trim() ?? \"Untitled Audience\").Trim();\n                var nameKey = name.ToLowerInvariant();\n\n                // âœ… Enforce uniqueness at service level (active audiences only)\n                var exists = await _db.Set<Audience>()\n                    .AsNoTracking()\n                    .AnyAsync(a =>\n                        a.BusinessId == businessId &&\n                        !a.IsDeleted &&\n                        a.Name.ToLower() == nameKey);\n\n                if (exists)\n                {\n                    // Prefer returning a domain exception that your middleware maps to 409.\n                    // If you don't have that yet, throwing is still better than duplicating silently.\n                    throw new InvalidOperationException($\"Audience name '{name}' already exists.\");\n                }\n\n                var model = new Audience\n                {\n                    Id = id,\n                    BusinessId = businessId,\n                    Name = name,\n                    Description = dto?.Description,\n                    CsvBatchId = null,\n                    IsDeleted = false,\n                    CreatedByUserId = createdByUserId,\n                    CreatedAt = now,\n                    UpdatedAt = now\n                };\n\n                _db.Set<Audience>().Add(model);\n                await _db.SaveChangesAsync();\n\n                Log.Information(\"âœ… Audience created | biz={Biz} id={Id} name={Name}\", businessId, id, model.Name);\n                return id;\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"âŒ Failed creating audience | biz={Biz}\", businessId);\n                throw;\n            }\n        }\n\n        public async Task<List<AudienceSummaryDto>> ListAsync(Guid businessId)\n        {\n            var audiences = _db.Set<Audience>()\n                .AsNoTracking()\n                .Where(a => a.BusinessId == businessId && !a.IsDeleted);\n\n            var members = _db.Set<AudienceMember>();\n\n            var items = await audiences\n                .OrderByDescending(a => a.CreatedAt)\n                .Select(a => new AudienceSummaryDto\n                {\n                    Id = a.Id,\n                    Name = a.Name,\n                    Description = a.Description,\n                    MemberCount = members.Count(m => m.BusinessId == businessId && m.AudienceId == a.Id && !m.IsDeleted),\n                    CreatedAt = a.CreatedAt\n                })\n                .ToListAsync();\n\n            return items;\n        }\n\n        public async Task<bool> AssignAsync(Guid businessId, Guid audienceId, AudienceAssignDto dto, string createdBy)\n        {\n            var audience = await _db.Set<Audience>()\n                .FirstOrDefaultAsync(a => a.Id == audienceId && a.BusinessId == businessId && !a.IsDeleted);\n\n            if (audience == null) return false;\n\n            var now = DateTime.UtcNow;\n\n            // 1) Assign CRM contacts (if provided)\n            if (dto?.ContactIds != null && dto.ContactIds.Count > 0)\n            {\n                var contacts = await _db.Set<Contact>()\n                    .Where(c => c.BusinessId == businessId && dto.ContactIds.Contains(c.Id))\n                    .Select(c => new { c.Id, c.Name, c.PhoneNumber, c.Email })\n                    .ToListAsync();\n\n                // âœ… Load existing members for this audience to support:\n                // - skip duplicates\n                // - reactivate soft-deleted members\n                var existing = await _db.Set<AudienceMember>()\n                    .Where(m => m.BusinessId == businessId && m.AudienceId == audienceId)\n                    .ToListAsync();\n\n                // Map by normalized phone (canonical identity)\n                var byPhone = existing\n                    .Where(m => !string.IsNullOrWhiteSpace(m.PhoneE164))\n                    .GroupBy(m => m.PhoneE164)\n                    .ToDictionary(g => g.Key, g => g.First());\n\n                var toAdd = new List<AudienceMember>();\n\n                foreach (var c in contacts)\n                {\n                    var phoneRaw = (c.PhoneNumber ?? \"\").Trim();\n\n                    // âœ… Canonical digits-only E.164 (NO '+'), same as CRM\n                    var phoneE164 = PhoneNumberNormalizer.NormalizeToE164Digits(phoneRaw, \"IN\");\n\n                    // If phone can't normalize, skip creating identity records\n                    if (string.IsNullOrWhiteSpace(phoneE164))\n                        continue;\n\n                    if (byPhone.TryGetValue(phoneE164, out var existingMember))\n                    {\n                        // âœ… Reactivate if it was soft-deleted\n                        if (existingMember.IsDeleted)\n                        {\n                            existingMember.IsDeleted = false;\n                            existingMember.UpdatedAt = now;\n                        }\n\n                        // âœ… Refresh basic fields (optional but usually correct)\n                        existingMember.ContactId = c.Id;\n                        existingMember.Name = c.Name;\n                        existingMember.Email = string.IsNullOrWhiteSpace(c.Email) ? null : c.Email;\n                        existingMember.PhoneRaw = phoneRaw;\n\n                        continue; // no new insert\n                    }\n\n                    // âœ… Add new member\n                    var member = new AudienceMember\n                    {\n                        Id = Guid.NewGuid(),\n                        AudienceId = audienceId,\n                        BusinessId = businessId,\n                        ContactId = c.Id,\n                        Name = c.Name,\n                        Email = string.IsNullOrWhiteSpace(c.Email) ? null : c.Email,\n                        PhoneRaw = phoneRaw,\n                        PhoneE164 = phoneE164,\n                        AttributesJson = null,\n                        IsTransientContact = false,\n                        IsDeleted = false,\n                        CreatedAt = now,\n                        UpdatedAt = now\n                    };\n\n                    toAdd.Add(member);\n                    byPhone[phoneE164] = member; // prevent duplicates inside same request too\n                }\n\n                if (toAdd.Count > 0)\n                    await _db.Set<AudienceMember>().AddRangeAsync(toAdd);\n            }\n\n            // 2) Optionally link a CSV batch\n            if (dto?.CsvBatchId.HasValue == true && dto.CsvBatchId.Value != Guid.Empty)\n            {\n                var batch = await _db.Set<CsvBatch>()\n                    .FirstOrDefaultAsync(b => b.Id == dto.CsvBatchId.Value && b.BusinessId == businessId);\n\n                if (batch != null)\n                {\n                    audience.CsvBatchId = batch.Id;\n                }\n            }\n\n            audience.UpdatedAt = now;\n\n            await _db.SaveChangesAsync();\n\n            Log.Information(\"ðŸ‘¥ Audience assigned | biz={Biz} audience={AudienceId} contacts={Contacts} batch={Batch}\",\n                businessId, audienceId, dto?.ContactIds?.Count ?? 0, dto?.CsvBatchId);\n\n            return true;\n        }\n\n        public async Task<List<AudienceMemberDto>> GetMembersAsync(Guid businessId, Guid audienceId, int page = 1, int pageSize = 50)\n        {\n            page = Math.Max(1, page);\n            pageSize = Clamp(pageSize, 10, 200);\n\n            var q = _db.Set<AudienceMember>()\n                .AsNoTracking()\n                .Where(m => m.BusinessId == businessId && m.AudienceId == audienceId && !m.IsDeleted)\n                .OrderByDescending(m => m.CreatedAt);\n\n            var items = await q\n                .Skip((page - 1) * pageSize)\n                .Take(pageSize)\n                .Select(m => new AudienceMemberDto\n                {\n                    Id = m.Id,\n                    ContactId = m.ContactId,\n                    Name = m.Name,\n                    PhoneNumber = string.IsNullOrWhiteSpace(m.PhoneE164) ? m.PhoneRaw : m.PhoneE164,\n                    Email = m.Email,\n                    VariablesJson = m.AttributesJson,\n                    CreatedAt = m.CreatedAt\n                })\n                .ToListAsync();\n\n            return items;\n        }\n\n        // ---- helpers ----\n\n        private static int Clamp(int value, int min, int max)\n        {\n            if (value < min) return min;\n            if (value > max) return max;\n            return value;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Audiences/Services/CampaignVariableMapService.cs",
      "sha256": "fde5d702d281a92a4bbe0caa800ed3ab47c52fb28be71324666f3a9c7f34c3c7",
      "language": "csharp",
      "size": 6105,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing xbytechat.api;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing xbytechat.api.Features.CampaignModule.Models;\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    public interface ICampaignVariableMapService\n    {\n        Task<bool> SaveAsync(Guid businessId, CampaignVariableMapDto dto, string updatedBy);\n        Task<CampaignVariableMapDto?> GetAsync(Guid businessId, Guid campaignId);\n    }\n\n    public class CampaignVariableMapService : ICampaignVariableMapService\n    {\n        private readonly AppDbContext _db;\n\n        public CampaignVariableMapService(AppDbContext db) { _db = db; }\n\n        public async Task<bool> SaveAsync(Guid businessId, CampaignVariableMapDto dto, string updatedBy)\n        {\n            try\n            {\n                if (businessId == Guid.Empty) throw new UnauthorizedAccessException(\"Invalid business id.\");\n                if (dto == null) throw new ArgumentNullException(nameof(dto));\n                if (dto.CampaignId == Guid.Empty) throw new ArgumentException(\"CampaignId is required.\", nameof(dto));\n\n                // Ensure campaign ownership\n                var owns = await _db.Campaigns\n                    .AsNoTracking()\n                    .AnyAsync(c => c.Id == dto.CampaignId && c.BusinessId == businessId);\n                if (!owns) return false;\n\n                // Load existing rows for this campaign\n                var existing = await _db.CampaignVariableMaps\n                    .Where(m => m.BusinessId == businessId && m.CampaignId == dto.CampaignId)\n                    .ToListAsync();\n\n                // Normalize incoming:\n                // - tolerate null Items\n                // - default Component â†’ \"BODY\" if missing\n                // - trim strings\n                // - keep last occurrence per (Component, Index)\n                var incoming = (dto.Items?.AsEnumerable() ?? Enumerable.Empty<CampaignVariableMapItemDto>())\n                    .Where(i => i != null && i.Index >= 1)\n                    .Select(i => new\n                    {\n                        Component = string.IsNullOrWhiteSpace(i.Component) ? \"BODY\" : i.Component!.Trim(),\n                        i.Index,\n                        SourceType = string.IsNullOrWhiteSpace(i.SourceType) ? \"Static\" : i.SourceType!.Trim(),\n                        SourceKey = string.IsNullOrWhiteSpace(i.SourceKey) ? null : i.SourceKey!.Trim(),\n                        StaticValue = i.StaticValue,\n                        Expression = i.Expression,\n                        DefaultValue = i.DefaultValue,\n                        i.IsRequired\n                    })\n                    .GroupBy(x => new { x.Component, x.Index })\n                    .Select(g => g.Last())\n                    .ToList();\n\n                var incomingKeySet = incoming\n                    .Select(i => (i.Component, i.Index))\n                    .ToHashSet();\n\n                // Upsert each incoming row\n                foreach (var item in incoming)\n                {\n                    var row = existing.FirstOrDefault(x => x.Component == item.Component && x.Index == item.Index);\n                    if (row == null)\n                    {\n                        row = new CampaignVariableMap\n                        {\n                            Id = Guid.NewGuid(),\n                            BusinessId = businessId,\n                            CampaignId = dto.CampaignId,\n                            Component = item.Component,\n                            Index = item.Index\n                        };\n                        _db.CampaignVariableMaps.Add(row);\n                        existing.Add(row); // keep local cache in sync in case of duplicates\n                    }\n\n                    row.SourceType = item.SourceType;\n                    row.SourceKey = item.SourceKey;\n                    row.StaticValue = item.StaticValue;\n                    row.Expression = item.Expression;\n                    row.DefaultValue = item.DefaultValue;\n                    row.IsRequired = item.IsRequired;\n                }\n\n                // Remove deleted mappings (anything not present in incoming)\n                var toRemove = existing.Where(x => !incomingKeySet.Contains((x.Component, x.Index))).ToList();\n                if (toRemove.Count > 0)\n                    _db.CampaignVariableMaps.RemoveRange(toRemove);\n\n                await _db.SaveChangesAsync();\n\n                var upserted = incoming.Count;\n                var removed = toRemove.Count;\n\n                Log.Information(\"âœ… Variable map saved | biz={Biz} campaign={Campaign} upserted={Up} removed={Rm}\",\n                    businessId, dto.CampaignId, upserted, removed);\n\n                return true;\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"âŒ Failed saving campaign variable map | biz={Biz} campaign={Campaign}\", businessId, dto?.CampaignId);\n                throw;\n            }\n        }\n        public async Task<CampaignVariableMapDto?> GetAsync(Guid businessId, Guid campaignId)\n        {\n            var rows = await _db.CampaignVariableMaps\n                .AsNoTracking()\n                .Where(m => m.BusinessId == businessId && m.CampaignId == campaignId)\n                .OrderBy(m => m.Component).ThenBy(m => m.Index)\n                .ToListAsync();\n\n            var items = rows.Select(r => new CampaignVariableMapItemDto\n            {\n                Component = r.Component,\n                Index = r.Index,\n                SourceType = r.SourceType,\n                SourceKey = r.SourceKey,\n                StaticValue = r.StaticValue,\n                Expression = r.Expression,\n                DefaultValue = r.DefaultValue,\n                IsRequired = r.IsRequired\n            }).ToList();\n\n            return new CampaignVariableMapDto\n            {\n                CampaignId = campaignId,\n                Items = items\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Audiences/Services/IAudienceImportService.cs",
      "sha256": "80df51144eb035b0134e49bbdb7de6c48754a7800e72ee354b158ddf5401a202",
      "language": "csharp",
      "size": 586,
      "content": "using System;\nusing System.IO;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Audiences.DTOs;\n\nnamespace xbytechat.api.Features.Audiences.Services\n{\n    public interface IAudienceImportService\n    {\n        /// <summary>\n        /// Parses a CSV stream (first row = headers), creates a CsvBatch and CsvRows, and returns batch summary.\n        /// </summary>\n        Task<CsvImportResponseDto> ImportCsvAsync(\n            Guid businessId,\n            Stream csvStream,\n            string fileName,\n            CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Audiences/Services/IAudienceService.cs",
      "sha256": "c4f890bff1e68cdc956ca7346d41da16101fb082400f0a4d03ed8e5e5b77ce6b",
      "language": "csharp",
      "size": 538,
      "content": "using xbytechat.api.Features.Audiences.DTOs;\n\nnamespace xbytechat.api.Features.Audiences.Services\n{\n    public interface IAudienceService\n    {\n        Task<Guid> CreateAsync(Guid businessId, AudienceCreateDto dto, string createdBy);\n        Task<List<AudienceSummaryDto>> ListAsync(Guid businessId);\n        Task<bool> AssignAsync(Guid businessId, Guid audienceId, AudienceAssignDto dto, string createdBy);\n        Task<List<AudienceMemberDto>> GetMembersAsync(Guid businessId, Guid audienceId, int page = 1, int pageSize = 50);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Auditing/Controllers/FlowExecutionsController.cs",
      "sha256": "cd9482252d3b70cb771d4826a5a216a9c93b9c5074a29b9ae1dadc60743a3612",
      "language": "csharp",
      "size": 3843,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.Auditing.FlowExecutions.DTOs;\nusing xbytechat.api.Features.Auditing.FlowExecutions.Services;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\n\nnamespace xbytechat.api.Features.Auditing.FlowExecutions.Controllers\n{\n    /// <summary>\n    /// Internal / debugging API for exploring flow execution logs.\n    /// This is not meant to be exposed to end customers directly.\n    /// </summary>\n    [ApiController]\n    [Route(\"api/flow-executions\")]\n    public class FlowExecutionsController : ControllerBase\n    {\n        private readonly IFlowExecutionQueryService _queryService;\n        private readonly ILogger<FlowExecutionsController> _logger;\n\n        public FlowExecutionsController(\n            IFlowExecutionQueryService queryService,\n            ILogger<FlowExecutionsController> logger)\n        {\n            _queryService = queryService ?? throw new ArgumentNullException(nameof(queryService));\n            _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n        }\n\n        /// <summary>\n        /// Returns recent flow execution steps for a business, ordered by latest first.\n        /// \n        /// Example:\n        /// GET /api/flow-executions/recent?businessId=...&origin=AutoReply&limit=50\n        /// </summary>\n        [HttpGet(\"recent\")]\n        public async Task<ActionResult<IReadOnlyList<FlowExecutionLogDto>>> GetRecent(\n            [FromQuery] Guid businessId,\n            [FromQuery] FlowExecutionOrigin? origin,\n            [FromQuery] Guid? flowId,\n            [FromQuery] string? contactPhone,\n            [FromQuery] int limit = 50,\n            CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty)\n            {\n                return BadRequest(\"businessId is required.\");\n            }\n\n            var filter = new FlowExecutionFilter\n            {\n                Origin = origin,\n                FlowId = flowId,\n                ContactPhone = contactPhone,\n                Limit = limit\n            };\n\n            _logger.LogInformation(\n                \"[FlowExecutions] GetRecent biz={BusinessId} origin={Origin} flowId={FlowId} phone={Phone} limit={Limit}\",\n                businessId,\n                origin,\n                flowId,\n                contactPhone,\n                limit);\n\n            var results = await _queryService\n                .GetRecentExecutionsAsync(businessId, filter, ct)\n                .ConfigureAwait(false);\n\n            return Ok(results);\n        }\n\n        [HttpGet(\"run/{runId:guid}\")]\n        public async Task<ActionResult<IReadOnlyList<FlowExecutionLogDto>>> GetRunTimeline(\n           [FromRoute] Guid runId,\n           [FromQuery] Guid businessId,\n           CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty)\n            {\n                return BadRequest(\"businessId is required\");\n            }\n\n            if (runId == Guid.Empty)\n            {\n                return BadRequest(\"runId is required\");\n            }\n\n            try\n            {\n                var rows = await _queryService.GetRunTimelineAsync(\n                    businessId,\n                    runId,\n                    ct);\n\n                // Even if no rows, that's a valid 200 with empty list.\n                return Ok(rows);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex,\n                    \"[FlowExecutions] Error in GetRunTimeline for BusinessId={BusinessId}, RunId={RunId}\",\n                    businessId,\n                    runId);\n\n                return StatusCode(500, \"Failed to fetch run timeline.\");\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Auditing/FlowExecutions/DTOs/FlowExecutionFilter.cs",
      "sha256": "4b5d3d9134e83169856fccecac2a1e261d435e0aa4ddfc3fd81d79dcd9bc3519",
      "language": "csharp",
      "size": 1252,
      "content": "using System;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\n\nnamespace xbytechat.api.Features.Auditing.FlowExecutions.DTOs\n{\n    /// <summary>\n    /// Filter options when querying flow execution logs.\n    /// All fields are optional except BusinessId (which is passed separately).\n    /// </summary>\n    public class FlowExecutionFilter\n    {\n        /// <summary>\n        /// Optional: restrict to a specific origin (AutoReply, Campaign, etc.).\n        /// </summary>\n        public FlowExecutionOrigin? Origin { get; set; }\n\n        /// <summary>\n        /// Optional: restrict to a specific flow id.\n        /// This is usually the CTAFlowConfig.Id or AutoReplyFlow.Id,\n        /// depending on how FlowId is populated.\n        /// </summary>\n        public Guid? FlowId { get; set; }\n\n        /// <summary>\n        /// Optional: restrict to a specific contact phone number.\n        /// Stored exactly as in FlowExecutionLogs (usually WhatsApp \"from\" number).\n        /// </summary>\n        public string? ContactPhone { get; set; }\n\n        /// <summary>\n        /// Maximum number of rows to return.\n        /// Defaults to 50; upper capped in service for safety.\n        /// </summary>\n        public int Limit { get; set; } = 50;\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/Auditing/FlowExecutions/DTOs/FlowExecutionLogDto.cs",
      "sha256": "fe73dcb4340e01df3f5dafa5035c89bd7bca11471759f98c08afe2287908de06",
      "language": "csharp",
      "size": 3418,
      "content": "using System;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\n\nnamespace xbytechat.api.Features.Auditing.FlowExecutions.DTOs\n{\n    /// <summary>\n    /// Lightweight projection of a FlowExecutionLog row for debugging/analytics.\n    /// Matches the current FlowExecutionLog entity in CTAFlowBuilder.Models.\n    /// </summary>\n    public class FlowExecutionLogDto\n    {\n        public Guid Id { get; set; }\n\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// Correlation id for a single run of a flow (e.g. one user journey).\n        /// Nullable because older rows might not have it.\n        /// </summary>\n        public Guid? RunId { get; set; }\n\n        /// <summary>\n        /// Flow id being executed:\n        /// - For CTA flows: CTAFlowConfig.Id\n        /// - For AutoReply flows: AutoReplyFlow.Id (depending on how you log it)\n        /// Nullable because your entity uses Guid?.\n        /// </summary>\n        public Guid? FlowId { get; set; }\n\n        /// <summary>\n        /// If this execution was started by an AutoReply flow, this can carry that flow id.\n        /// </summary>\n        public Guid? AutoReplyFlowId { get; set; }\n\n        /// <summary>\n        /// If this execution was started as part of a campaign, this can carry Campaign.Id.\n        /// </summary>\n        public Guid? CampaignId { get; set; }\n\n        /// <summary>\n        /// Optional link to a specific campaign send log.\n        /// </summary>\n        public Guid? CampaignSendLogId { get; set; }\n\n        /// <summary>\n        /// Optional link to a tracking log row (e.g. button click tracking).\n        /// </summary>\n        public Guid? TrackingLogId { get; set; }\n\n        public FlowExecutionOrigin Origin { get; set; }\n\n        /// <summary>\n        /// Contact's WhatsApp phone number (as stored in FlowExecutionLog).\n        /// </summary>\n        public string? ContactPhone { get; set; }\n\n        public Guid StepId { get; set; }\n\n        public string StepName { get; set; } = string.Empty;\n\n        /// <summary>\n        /// If the step was triggered by a button click, this can store the button text.\n        /// </summary>\n        public string? TriggeredByButton { get; set; }\n\n        public string? TemplateName { get; set; }\n\n        public string? TemplateType { get; set; }\n\n        /// <summary>\n        /// True if the step was executed successfully.\n        /// </summary>\n        public bool Success { get; set; }\n\n        /// <summary>\n        /// Error message when Success == false.\n        /// </summary>\n        public string? ErrorMessage { get; set; }\n\n        /// <summary>\n        /// Raw provider response (optional).\n        /// </summary>\n        public string? RawResponse { get; set; }\n\n        /// <summary>\n        /// Optional link back to the originating MessageLog.\n        /// </summary>\n        public Guid? MessageLogId { get; set; }\n\n        /// <summary>\n        /// Which button index (0..2) was clicked, if applicable.\n        /// </summary>\n        public short? ButtonIndex { get; set; }\n\n        /// <summary>\n        /// Optional request id correlation (for cross-service tracing).\n        /// </summary>\n        public Guid? RequestId { get; set; }\n\n        /// <summary>\n        /// When this step was executed (UTC). Backed by FlowExecutionLog.ExecutedAt.\n        /// </summary>\n        public DateTime ExecutedAtUtc { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Auditing/FlowExecutions/Services/FlowExecutionQueryService.cs",
      "sha256": "934d7e5e7f2aeadcdb33937ca6db5cab3241978f0ffcdcab048e27a2c4e1ba8b",
      "language": "csharp",
      "size": 8423,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Auditing.FlowExecutions.DTOs;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\n\nnamespace xbytechat.api.Features.Auditing.FlowExecutions.Services\n{\n    /// <summary>\n    /// Default implementation of IFlowExecutionQueryService.\n    /// Performs filtered, read-only queries over FlowExecutionLogs.\n    /// </summary>\n    public sealed class FlowExecutionQueryService : IFlowExecutionQueryService\n    {\n        private readonly AppDbContext _db;\n\n        public FlowExecutionQueryService(AppDbContext db)\n        {\n            _db = db ?? throw new ArgumentNullException(nameof(db));\n        }\n\n        public async Task<IReadOnlyList<FlowExecutionLogDto>> GetRecentExecutionsAsync(\n            Guid businessId,\n            FlowExecutionFilter filter,\n            CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty)\n                throw new ArgumentException(\"BusinessId must be a non-empty GUID.\", nameof(businessId));\n\n            filter ??= new FlowExecutionFilter();\n\n            // Hard cap to avoid accidental huge result sets\n            var limit = filter.Limit <= 0 ? 50 : filter.Limit;\n            if (limit > 500)\n            {\n                limit = 500;\n            }\n\n            var query = _db.FlowExecutionLogs\n                .AsNoTracking()\n                .Where(x => x.BusinessId == businessId);\n\n            if (filter.Origin.HasValue)\n            {\n                query = query.Where(x => x.Origin == filter.Origin.Value);\n            }\n\n            if (filter.FlowId.HasValue)\n            {\n                var flowId = filter.FlowId.Value;\n                // Entity FlowId is Guid?, so we just compare directly.\n                query = query.Where(x => x.FlowId == flowId);\n            }\n\n            if (!string.IsNullOrWhiteSpace(filter.ContactPhone))\n            {\n                var phone = filter.ContactPhone.Trim();\n                query = query.Where(x => x.ContactPhone == phone);\n            }\n\n            // Order by latest execution first, using FlowExecutionLog.ExecutedAt\n            query = query\n                .OrderByDescending(x => x.ExecutedAt)\n                .ThenByDescending(x => x.Id)\n                .Take(limit);\n\n            var results = await query\n                .Select(x => new FlowExecutionLogDto\n                {\n                    Id = x.Id,\n                    BusinessId = x.BusinessId,\n                    RunId = x.RunId,\n                    FlowId = x.FlowId,\n                    AutoReplyFlowId = x.AutoReplyFlowId,\n                    CampaignId = x.CampaignId,\n                    CampaignSendLogId = x.CampaignSendLogId,\n                    TrackingLogId = x.TrackingLogId,\n                    Origin = x.Origin,\n                    ContactPhone = x.ContactPhone,\n                    StepId = x.StepId,\n                    StepName = x.StepName,\n                    TriggeredByButton = x.TriggeredByButton,\n                    TemplateName = x.TemplateName,\n                    TemplateType = x.TemplateType,\n                    Success = x.Success,\n                    ErrorMessage = x.ErrorMessage,\n                    RawResponse = x.RawResponse,\n                    MessageLogId = x.MessageLogId,\n                    ButtonIndex = x.ButtonIndex,\n                    RequestId = x.RequestId,\n                    ExecutedAtUtc = x.ExecutedAt\n                })\n                .ToListAsync(ct)\n                .ConfigureAwait(false);\n\n            return results;\n        }\n\n        //public async Task<IReadOnlyList<FlowExecutionLogDto>> GetRunTimelineAsync(\n        //    Guid businessId,\n        //    Guid runId,\n        //    CancellationToken ct = default)\n        //{\n        //    if (businessId == Guid.Empty)\n        //        throw new ArgumentException(\"BusinessId is required\", nameof(businessId));\n\n        //    if (runId == Guid.Empty)\n        //        throw new ArgumentException(\"RunId is required\", nameof(runId));\n\n        //    var query = _db.FlowExecutionLogs\n        //        .AsNoTracking()\n        //        .Where(x =>\n        //            x.BusinessId == businessId &&\n        //            x.RunId == runId);\n\n        //    // For a timeline we want oldest â†’ newest.\n        //    query = query\n        //        .OrderBy(x => x.ExecutedAt)\n        //        .ThenBy(x => x.Id);\n\n        //    return await query\n        //        .Select(x => new FlowExecutionLogDto\n        //        {\n        //            Id = x.Id,\n        //            RunId = x.RunId,\n        //            BusinessId = x.BusinessId,\n        //            FlowId = x.FlowId,\n        //            AutoReplyFlowId = x.AutoReplyFlowId,\n        //            CampaignId = x.CampaignId,\n        //            Origin = x.Origin,\n\n        //            StepId = x.StepId,\n        //            StepName = x.StepName,\n        //            ContactPhone = x.ContactPhone,\n        //            TriggeredByButton = x.TriggeredByButton,\n        //            TemplateName = x.TemplateName,\n        //            TemplateType = x.TemplateType,\n        //            Success = x.Success,\n        //            ErrorMessage = x.ErrorMessage,\n        //            RawResponse = x.RawResponse,\n        //            MessageLogId = x.MessageLogId,\n        //            ButtonIndex = x.ButtonIndex,\n        //            RequestId = x.RequestId,\n        //            ExecutedAtUtc = x.ExecutedAt\n        //        })\n        //        .ToListAsync(ct)\n        //        .ConfigureAwait(false);\n        //}\n        public async Task<IReadOnlyList<FlowExecutionLogDto>> GetRunTimelineAsync(\n            Guid businessId,\n            Guid runId,\n            CancellationToken ct = default)\n        {\n            if (runId == Guid.Empty)\n                throw new ArgumentException(\"RunId is required\", nameof(runId));\n\n            // Primary query: business-scoped (what we expect normally)\n            IQueryable<FlowExecutionLog> query = _db.FlowExecutionLogs\n                .AsNoTracking()\n                .Where(x => x.RunId == runId);\n\n            if (businessId != Guid.Empty)\n            {\n                query = query.Where(x => x.BusinessId == businessId);\n            }\n\n            var primary = await query\n                .OrderBy(x => x.ExecutedAt)\n                .ThenBy(x => x.Id)\n                .ToListAsync(ct)\n                .ConfigureAwait(false);\n\n            // If nothing found, fall back to \"by RunId only\" (no business filter).\n            // This makes the explorer robust against any mismatched BusinessId data.\n            List<FlowExecutionLog> rows;\n            if (primary.Count > 0)\n            {\n                rows = primary;\n            }\n            else\n            {\n                rows = await _db.FlowExecutionLogs\n                    .AsNoTracking()\n                    .Where(x => x.RunId == runId)\n                    .OrderBy(x => x.ExecutedAt)\n                    .ThenBy(x => x.Id)\n                    .ToListAsync(ct)\n                    .ConfigureAwait(false);\n            }\n\n            return rows\n                .Select(x => new FlowExecutionLogDto\n                {\n                    Id = x.Id,\n                    RunId = x.RunId,\n                    BusinessId = x.BusinessId,\n                    FlowId = x.FlowId,\n                    AutoReplyFlowId = x.AutoReplyFlowId,\n                    CampaignId = x.CampaignId,\n                    CampaignSendLogId = x.CampaignSendLogId,\n                    TrackingLogId = x.TrackingLogId,\n                    Origin = x.Origin,\n                    StepId = x.StepId,\n                    StepName = x.StepName,\n                    ContactPhone = x.ContactPhone,\n                    TriggeredByButton = x.TriggeredByButton,\n                    TemplateName = x.TemplateName,\n                    TemplateType = x.TemplateType,\n                    Success = x.Success,\n                    ErrorMessage = x.ErrorMessage,\n                    RawResponse = x.RawResponse,\n                    MessageLogId = x.MessageLogId,\n                    ButtonIndex = x.ButtonIndex,\n                    RequestId = x.RequestId,\n                    ExecutedAtUtc = x.ExecutedAt\n                })\n                .ToList();\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Auditing/FlowExecutions/Services/IFlowExecutionQueryService.cs",
      "sha256": "39152ea71e1d5e0622da76c594765c55a889dd175676f056cc875e966c1043f5",
      "language": "csharp",
      "size": 1167,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Auditing.FlowExecutions.DTOs;\n\nnamespace xbytechat.api.Features.Auditing.FlowExecutions.Services\n{\n    /// <summary>\n    /// Read-only query service for inspecting flow execution logs.\n    /// Used by internal tools / analytics / debug endpoints.\n    /// </summary>\n    public interface IFlowExecutionQueryService\n    {\n        /// <summary>\n        /// Returns recent flow execution steps for a given business,\n        /// ordered by ExecutedAtUtc descending.\n        /// </summary>\n        /// <param name=\"businessId\">The tenant/business id to filter by (required).</param>\n        /// <param name=\"filter\">Optional filters for origin, flow, contact, and limit.</param>\n        Task<IReadOnlyList<FlowExecutionLogDto>> GetRecentExecutionsAsync(\n            Guid businessId,\n            FlowExecutionFilter filter,\n            CancellationToken ct = default);\n\n        Task<IReadOnlyList<FlowExecutionLogDto>> GetRunTimelineAsync(\n           Guid businessId,\n           Guid runId,\n           CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AuditTrail/DTOs/CreateAuditLogDto.cs",
      "sha256": "845322cca23fe6666ea3c5947bf45d55d34363c27d5bacec30375a04b24a73ef",
      "language": "csharp",
      "size": 471,
      "content": "namespace xbytechat.api.Features.AuditTrail.DTOs;\n\npublic class CreateAuditLogDto\n{\n    public string ActionType { get; set; }\n    public string Module { get; set; }\n    public string? RecordId { get; set; }\n\n    public string? OldValues { get; set; }\n    public string? NewValues { get; set; }\n    public string? Description { get; set; }\n\n    public string? IPAddress { get; set; }\n    public string? UserAgent { get; set; }\n    public string? Location { get; set; }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AuditTrail/Models/AuditLog.cs",
      "sha256": "91e4760f6e10564db50d99acec9f1c83de5fd0b8ca2e0d3bc5874d645ac93a45",
      "language": "csharp",
      "size": 1034,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AuditTrail.Models\n{\n    public class AuditLog\n    {\n        public Guid Id { get; set; } = Guid.NewGuid();\n\n        // ðŸ“ Business Context (Multi-Tenant)\n        public Guid BusinessId { get; set; }\n\n        // ðŸ™‹ Who performed the action\n        public Guid PerformedByUserId { get; set; }\n        public string? PerformedByUserName { get; set; } // Optional for display\n        public string? RoleAtTime { get; set; } // admin / business / agent\n\n        // ðŸ” Action Details\n        public string ActionType { get; set; } = \"\"; // e.g., campaign.created, user.login\n        public string? Description { get; set; } // Free text for summary or custom note\n\n        // ðŸŒ Optional: Technical metadata\n        public string? IPAddress { get; set; }\n        public string? UserAgent { get; set; }\n        public string? Location { get; set; } // Optional for geo-capture later\n\n        // ðŸ•’ Timestamp\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AuditTrail/Services/AuditLogService.cs",
      "sha256": "6b18d820c4191681a1bf26d6672f189bce0cadcfba3c8beb9e29dbed4ad4fdd9",
      "language": "csharp",
      "size": 536,
      "content": "using xbytechat.api.Features.AuditTrail.Models;\nusing xbytechat.api.Repositories;\nusing xbytechat.api.Repositories.Interfaces;\n\nnamespace xbytechat.api.Features.AuditTrail.Services\n{\n    public class AuditLogService : IAuditLogService\n    {\n        private readonly IGenericRepository<AuditLog> _repo;\n\n        public AuditLogService(IGenericRepository<AuditLog> repo)\n        {\n            _repo = repo;\n        }\n\n        public async Task SaveLogAsync(AuditLog log)\n        {\n            await _repo.AddAsync(log);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AuditTrail/Services/IAuditLogService.cs",
      "sha256": "65d811af2c7dc349002b7b1a340a765025625f9fe31c241dccc8f3eaeab15330",
      "language": "csharp",
      "size": 197,
      "content": "using xbytechat.api.Features.AuditTrail.Models;\n\nnamespace xbytechat.api.Features.AuditTrail.Services\n{\n    public interface IAuditLogService\n    {\n        Task SaveLogAsync(AuditLog log);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Config/ChoiceConfig.cs",
      "sha256": "0d09e0bc40325856d625ab31e93694e661b6df532e5de78f2a55254783e40c1c",
      "language": "csharp",
      "size": 354,
      "content": "namespace xbytechat.api.Features.Automation.Config\n{\n    public class ChoiceConfig\n    {\n        public List<ChoiceCondition> Conditions { get; set; } = new();\n        public string FallbackNodeId { get; set; }\n    }\n\n    public class ChoiceCondition\n    {\n        public string Match { get; set; }\n        public string NextNodeId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Config/MessageConfig.cs",
      "sha256": "564fbd35e79d9ef3f8b48ed54e15d55a9d0226b7d6ea72315d81b562a7a4ecae",
      "language": "csharp",
      "size": 225,
      "content": "namespace xbytechat.api.Features.Automation.Models.Configs\n{\n    public class MessageConfig\n    {\n        public string Text { get; set; } = string.Empty;\n\n        // Future: Add support for media, buttons, templates\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Config/TagNodeConfig.cs",
      "sha256": "81144c1418ba70285c6af13bf7aee6346f8f6674416ffc9ab79614bceb3be4d0",
      "language": "csharp",
      "size": 197,
      "content": "using System.Collections.Generic;\n\nnamespace xbytechat.api.Features.Automation.Models.Configs\n{\n    public class TagNodeConfig\n    {\n        public List<string> Tags { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Config/WaitConfig.cs",
      "sha256": "d13667732f9e18370123b10c2881aa385e8d11a33bc01acaf0f7eb96f4903bd6",
      "language": "csharp",
      "size": 170,
      "content": "namespace xbytechat.api.Features.Automation.Models.Configs\n{\n    public class WaitConfig\n    {\n        public int Seconds { get; set; } = 2; // Default wait time\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Controllers/AutomationController.cs",
      "sha256": "a8918574633489f57249d757a1f1c883a0c86531cbc734c67de68ba419caa957",
      "language": "csharp",
      "size": 2153,
      "content": "using Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.Automation.DTOs;\nusing xbytechat.api.Features.Automation.Repositories;\nusing xbytechat.api.Features.Automation.Services;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Shared;\nusing xbytechat.api.Features.CRM.Interfaces;\n\nnamespace xbytechat.api.Features.Automation.Controllers\n{\n    [ApiController]\n    [Route(\"api/automation\")]\n    [Authorize]\n    public class AutomationController : ControllerBase\n    {\n        private readonly IAutomationFlowRepository _automationRepository;\n        private readonly IAutomationRunner _automationRunner;\n        private readonly IContactService _contactService;\n\n        public AutomationController(\n            IAutomationFlowRepository automationRepository,\n            IAutomationRunner automationRunner,\n            IContactService contactService)\n        {\n            _automationRepository = automationRepository;\n            _automationRunner = automationRunner;\n            _contactService = contactService;\n        }\n\n        [HttpPost(\"trigger\")]\n        public async Task<IActionResult> TriggerByKeyword([FromBody] AutomationTriggerRequest request)\n        {\n            var businessId = User.GetBusinessId();\n            var userId = User.GetUserId();\n\n            if (string.IsNullOrWhiteSpace(request.Keyword) || string.IsNullOrWhiteSpace(request.Phone))\n                return BadRequest(\"Keyword and phone are required.\");\n\n            var flow = await _automationRepository.GetFlowByKeywordAsync(businessId, request.Keyword);\n            if (flow == null || !flow.IsActive)\n                return NotFound(\"âš ï¸ No matching active automation flow found.\");\n\n            var contact = await _contactService.FindOrCreateAsync(businessId, request.Phone);\n\n            var result = await _automationRunner.RunFlowAsync(\n                flow,\n                businessId,\n                contact.Id,\n                request.Phone,\n                request.SourceChannel ?? \"manual\",\n                request.IndustryTag ?? \"manual\"\n            );\n\n            return Ok(result);\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/DTOs/AutomationEdgeDto.cs",
      "sha256": "d9093a43a35fa0c12238f7c78daec3980190c4160320cfe73c6b93ff2d41c5ce",
      "language": "csharp",
      "size": 450,
      "content": "using System;\n\nnamespace xbytechat.api.Features.Automation.DTOs\n{\n    /// <summary>\n    /// Represents a connection (edge) between two automation nodes.\n    /// </summary>\n    public class AutomationEdgeDto\n    {\n        public Guid SourceNodeId { get; set; }\n\n        public Guid TargetNodeId { get; set; }\n\n        public string? Condition { get; set; }  // Optional: for future conditional routing (e.g., \"if clicked\", \"if not responded\")\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/DTOs/AutomationTriggerRequest.cs",
      "sha256": "aeca572a0bab580b70dddd50cb6f4e1b282f17508311aaeb9beaefef34d8fa46",
      "language": "csharp",
      "size": 296,
      "content": "namespace xbytechat.api.Features.Automation.DTOs\n{\n    public class AutomationTriggerRequest\n    {\n        public string Keyword { get; set; }\n\n        public string Phone { get; set; }\n\n        public string? SourceChannel { get; set; }\n\n        public string? IndustryTag { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/DTOs/MessageNodeConfig.cs",
      "sha256": "8fdadb2bb6457b35ed85d89655b1f6d1d9bc5028a0ec212d9dd7eaa70b1a8e0d",
      "language": "csharp",
      "size": 218,
      "content": "namespace xbytechat.api.Features.Automation.DTOs\n{\n    public class MessageNodeConfig\n    {\n        public string Text { get; set; } = string.Empty;\n\n        // Optional: Later you can add buttons, media, etc.\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/DTOs/TagNodeConfig.cs",
      "sha256": "2feaf9902643a6bb0e59b019cfca34a41ada3abf9f66afffcac065c6bb545b6c",
      "language": "csharp",
      "size": 199,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.Automation.DTOs\n{\n    public class TagNodeConfig\n    {\n        public List<Guid> Tags { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/DTOs/WaitNodeConfig.cs",
      "sha256": "f520007158ae72db229b2a23f437666e64d34fcc96cdd728ad57a4320f152b75",
      "language": "csharp",
      "size": 143,
      "content": "namespace xbytechat.api.Features.Automation.DTOs\n{\n    public class WaitNodeConfig\n    {\n        public int Seconds { get; set; } = 3;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Models/AutomationFlow.cs",
      "sha256": "7dd5063615cfa824960a08fdd88d9fdf500a3c0461151b27e09fcaa7d97b45fe",
      "language": "csharp",
      "size": 803,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.Automation.Models\n{\n    /// <summary>\n    /// Represents a saved automation flow with nodes and edges.\n    /// </summary>\n    public class AutomationFlow\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        public Guid BusinessId { get; set; }\n\n        public string Name { get; set; } = string.Empty;\n\n        public string TriggerKeyword { get; set; } = string.Empty; // âœ… Better naming\n\n        public string NodesJson { get; set; } = \"[]\";\n\n        public string EdgesJson { get; set; } = \"[]\";\n\n        public bool IsActive { get; set; } = true;\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n        public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Models/AutomationFlowEdge.cs",
      "sha256": "ad1f63ff8580807f996a658e2a95652c94370929e8dd75eac9f1fdc98c398105",
      "language": "csharp",
      "size": 280,
      "content": "namespace xbytechat.api.Features.Automation.Models\n{\n    public class AutomationFlowEdge\n    {\n        public string SourceNodeId { get; set; } = string.Empty;\n        public string TargetNodeId { get; set; } = string.Empty;\n        public string? Condition { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Models/AutomationFlowNode.cs",
      "sha256": "c18876f0d4c8fdf851da8df67ddff902fee66217b804a6765a9b533f8402e76d",
      "language": "csharp",
      "size": 354,
      "content": "using System;\n\nnamespace xbytechat.api.Features.Automation.Models\n{\n    public class AutomationFlowNode\n    {\n        public string Id { get; set; } = Guid.NewGuid().ToString(\"N\");\n        public string Label { get; set; } = string.Empty;\n        public NodeTypeEnum NodeType { get; set; }\n        public string ConfigJson { get; set; } = \"{}\";\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Models/AutomationFlowRunResult.cs",
      "sha256": "61407553e4f66fbfdc8c0a51868372170e58411cd6c74e857e8e9cab13e27b6b",
      "language": "csharp",
      "size": 403,
      "content": "using System;\n\nnamespace xbytechat.api.Features.Automation.Models\n{\n    public class AutomationFlowRunResult\n    {\n        public bool NeedsAgent { get; set; } = false;\n\n        public Guid? HandoffNodeId { get; set; } = null;\n\n        public string? Notes { get; set; }  // Optional: track execution info (e.g., exit reason)\n\n        public DateTime ExecutedAt { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Models/FlowExecutionContext.cs",
      "sha256": "aef2132567e314889ae4d98f06dd96c43873ab3513b6c02cd8553346e3e7ff57",
      "language": "csharp",
      "size": 523,
      "content": "using System;\n\nnamespace xbytechat.api.Features.Automation.Models\n{\n    /// <summary>\n    /// Context required to run an automation flow.\n    /// </summary>\n    public class FlowExecutionContext\n    {\n        public AutomationFlow Flow { get; set; }\n\n        public Guid BusinessId { get; set; }\n\n        public Guid ContactId { get; set; }\n\n        public string ContactPhone { get; set; }\n\n        public string SourceChannel { get; set; } = \"manual\";\n\n        public string IndustryTag { get; set; } = \"manual\";\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Models/FlowRunResult.cs",
      "sha256": "64baa95c50dc4528fa36e8ad36a12ac82a0528c8c640797d16b58e17455d6125",
      "language": "csharp",
      "size": 345,
      "content": "using System;\n\nnamespace xbytechat.api.Features.Automation.Models\n{\n    /// <summary>\n    /// Represents the result of running an automation flow.\n    /// </summary>\n    public class FlowRunResult\n    {\n        public bool NeedsAgent { get; set; } = false;\n\n        public Guid? HandoffNodeId { get; set; } // If agent handoff requested\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Models/NodeConfigs.cs",
      "sha256": "0e8b3fb72dd676ec59568e34b569e1302a621a35a6efca4553736f89b15b21c4",
      "language": "csharp",
      "size": 167,
      "content": "namespace xbytechat.api.Features.Automation.Models.NodeConfigs\n{\n    public class MessageConfig\n    {\n        public string Text { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Models/NodeTypeEnum.cs",
      "sha256": "ac2b60c1ffd633136ef56df710b0cf7f141496e92e30cd1c4bd42f201f4d85d3",
      "language": "csharp",
      "size": 223,
      "content": "namespace xbytechat.api.Features.Automation.Models\n{\n    public enum NodeTypeEnum\n    {\n        Message,\n        Wait,\n        Tag,\n        AgentHandoff,\n        Choice,\n        Condition,\n        Loop,\n        End\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Models/TagNodeConfig.cs",
      "sha256": "9cec10f188aea021e4b186075bf0f84e18cb4071046ade7098c2658d077559f5",
      "language": "csharp",
      "size": 201,
      "content": "using System.Collections.Generic;\n\nnamespace xbytechat.api.Features.Automation.Models.NodeConfigs\n{\n    public class TagNodeConfig\n    {\n        public List<string> Tags { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Models/WaitConfig.cs",
      "sha256": "641533b56ae811de7505263f827bc5f89cc405f67645b053fd06737f1e5fa621",
      "language": "csharp",
      "size": 153,
      "content": "namespace xbytechat.api.Features.Automation.Models.NodeConfigs\n{\n    public class WaitConfig\n    {\n        public int Seconds { get; set; } = 1;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Repositories/AutomationFlowRepository.cs",
      "sha256": "0e6a38673480db7c067e41901c2725f6c93683975ffaacfdcefb67bcfe90820e",
      "language": "csharp",
      "size": 3297,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Automation.Models;\n\nnamespace xbytechat.api.Features.Automation.Repositories\n{\n    public class AutomationFlowRepository : IAutomationFlowRepository\n    {\n        private readonly AppDbContext _db;\n\n        public AutomationFlowRepository(AppDbContext db)\n        {\n            _db = db;\n        }\n\n        public async Task<AutomationFlow?> GetByIdAsync(Guid flowId, Guid businessId)\n        {\n            return await _db.AutomationFlows\n                .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId && f.IsActive);\n        }\n\n        public async Task<AutomationFlow?> GetFlowByKeywordAsync(Guid businessId, string keyword)\n        {\n            return await _db.AutomationFlows\n                .FirstOrDefaultAsync(f =>\n                    f.BusinessId == businessId &&\n                    f.TriggerKeyword.ToLower() == keyword.ToLower() &&\n                    f.IsActive);\n        }\n\n        public async Task<IEnumerable<AutomationFlow>> GetAllByBusinessAsync(Guid businessId)\n        {\n            return await _db.AutomationFlows\n                .Where(f => f.BusinessId == businessId && f.IsActive)\n                .OrderBy(f => f.Name)\n                .ToListAsync();\n        }\n\n        public async Task<AutomationFlow> CreateAsync(AutomationFlow flow)\n        {\n            flow.Id = Guid.NewGuid();\n            flow.CreatedAt = DateTime.UtcNow;\n            flow.IsActive = true;\n\n            _db.AutomationFlows.Add(flow);\n            await _db.SaveChangesAsync();\n            return flow;\n        }\n\n        public async Task<AutomationFlow> UpdateAsync(AutomationFlow flow)\n        {\n            var existing = await _db.AutomationFlows\n                .FirstOrDefaultAsync(f => f.Id == flow.Id && f.BusinessId == flow.BusinessId && f.IsActive);\n\n            if (existing == null)\n                throw new KeyNotFoundException(\"Automation flow not found.\");\n\n            existing.Name = flow.Name;\n            existing.TriggerKeyword = flow.TriggerKeyword;\n            existing.NodesJson = flow.NodesJson;\n            existing.EdgesJson = flow.EdgesJson;\n            existing.UpdatedAt = DateTime.UtcNow;\n\n            _db.AutomationFlows.Update(existing);\n            await _db.SaveChangesAsync();\n\n            return existing;\n        }\n\n        public async Task<bool> DeleteAsync(Guid flowId, Guid businessId)\n        {\n            var flow = await _db.AutomationFlows\n                .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId && f.IsActive);\n\n            if (flow == null)\n                return false;\n\n            flow.IsActive = false;\n            flow.UpdatedAt = DateTime.UtcNow;\n\n            _db.AutomationFlows.Update(flow);\n            await _db.SaveChangesAsync();\n            return true;\n        }\n        public async Task<AutomationFlow?> GetByKeywordAsync(Guid businessId, string keyword)\n        {\n            return await _db.AutomationFlows\n                .FirstOrDefaultAsync(f =>\n                f.BusinessId == businessId &&\n                EF.Functions.ILike(f.TriggerKeyword, keyword) &&\n                f.IsActive);\n        }\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Repositories/IAutomationFlowRepository.cs",
      "sha256": "3c0e87413a797f0b2cb7de16b419204f9f84555fd58a4435ca5bffc5f570b2fe",
      "language": "csharp",
      "size": 1022,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Automation.Models;\n\nnamespace xbytechat.api.Features.Automation.Repositories\n{\n    public interface IAutomationFlowRepository\n    {\n        // ðŸ” Get flow by unique FlowId + BusinessId (strict filtering)\n        Task<AutomationFlow?> GetByIdAsync(Guid flowId, Guid businessId);\n\n        // ðŸ” Get flow by keyword for auto-trigger\n        Task<AutomationFlow?> GetFlowByKeywordAsync(Guid businessId, string keyword);\n\n        // ðŸ“‹ List all flows for business\n        Task<IEnumerable<AutomationFlow>> GetAllByBusinessAsync(Guid businessId);\n\n        // âž• Create flow\n        Task<AutomationFlow> CreateAsync(AutomationFlow flow);\n\n        // âœï¸ Update flow\n        Task<AutomationFlow> UpdateAsync(AutomationFlow flow);\n\n        // âŒ Delete flow\n        Task<bool> DeleteAsync(Guid flowId, Guid businessId);\n        Task<AutomationFlow?> GetByKeywordAsync(Guid businessId, string keyword);\n\n\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Services/AutomationRunner.cs",
      "sha256": "a72d4f5b71367cbace05c222c0bedc1f4eb84d97e9096a52211881f032a2323a",
      "language": "csharp",
      "size": 12642,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.EntityFrameworkCore;\nusing Newtonsoft.Json;\nusing xbytechat.api.Features.Automation.Models;\nusing xbytechat.api.Features.Automation.Models.Configs;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.Features.Inbox.Models;\nusing xbytechat.api.Features.Automation.Config;\nusing xbytechat.api.Features.CRM.Interfaces;\n\nnamespace xbytechat.api.Features.Automation.Services\n{\n    public class AutomationRunner : IAutomationRunner\n    {\n        private readonly IMessageEngineService _messageService;\n        private readonly IContactService _contactService;\n        private readonly ILogger<AutomationRunner> _logger;\n        private readonly AppDbContext _appDbContext;\n        public AutomationRunner(\n            IMessageEngineService messageService,\n            IContactService contactService,\n            ILogger<AutomationRunner> logger, AppDbContext appDbContext)\n        {\n            _messageService = messageService;\n            _contactService = contactService;\n            _logger = logger;\n            _appDbContext = appDbContext;\n        }\n\n        public async Task<AutomationFlowRunResult> RunFlowAsync(\n            AutomationFlow flow,\n            Guid businessId,\n            Guid contactId,\n            string contactPhone,\n            string sourceChannel,\n            string industryTag)\n        {\n            var nodes = JsonConvert.DeserializeObject<List<AutomationFlowNode>>(flow.NodesJson);\n            var edges = JsonConvert.DeserializeObject<List<AutomationFlowEdge>>(flow.EdgesJson);\n\n            var result = new AutomationFlowRunResult();\n            var currentNode = nodes.FirstOrDefault(); // Start from first node\n\n            if (currentNode == null)\n            {\n                _logger.LogWarning(\"ðŸš« Flow has no start node.\");\n                result.NeedsAgent = true;\n                result.Notes = \"No start node found.\";\n                return result;\n            }\n\n            while (currentNode != null)\n            {\n                _logger.LogInformation(\"âž¡ï¸ Running node: {NodeType} | {NodeId}\", currentNode.NodeType, currentNode.Id);\n\n                switch (currentNode.NodeType)\n                {\n                    case NodeTypeEnum.Message:\n                        var msgCfg = JsonConvert.DeserializeObject<MessageConfig>(currentNode.ConfigJson);\n                        var msgDto = new TextMessageSendDto\n                        {\n                            BusinessId = businessId,\n                            ContactId = contactId,\n                            RecipientNumber = contactPhone,\n                            TextContent = msgCfg.Text,\n                            Source = \"automation\"\n                        };\n                        _logger.LogInformation(\"ðŸ“¤ Sending message: {Text}\", msgCfg.Text);\n                        await _messageService.SendAutomationReply(msgDto);\n                        break;\n\n                    case NodeTypeEnum.Wait:\n                        var waitCfg = JsonConvert.DeserializeObject<WaitConfig>(currentNode.ConfigJson);\n                        _logger.LogInformation(\"â³ Waiting {Seconds}s\", waitCfg.Seconds);\n                        await Task.Delay(waitCfg.Seconds * 1000);\n                        break;\n\n                    case NodeTypeEnum.Tag:\n                        var tagCfg = JsonConvert.DeserializeObject<TagNodeConfig>(currentNode.ConfigJson);\n                        _logger.LogInformation(\"ðŸ·ï¸ Assigning tags: {Tags}\", string.Join(\", \", tagCfg.Tags));\n                        await _contactService.AssignTagsAsync(businessId, contactPhone, tagCfg.Tags);\n                        break;\n\n                    case NodeTypeEnum.AgentHandoff:\n                        result.NeedsAgent = true;\n                        if (Guid.TryParse(currentNode.Id, out var parsedId))\n                        {\n                            result.HandoffNodeId = parsedId;\n                        }\n                        else\n                        {\n                            _logger.LogWarning(\"âš ï¸ Invalid node ID format for AgentHandoff node: {Id}\", currentNode.Id);\n                            result.HandoffNodeId = null;\n                        }\n                        result.Notes = \"Flow routed to human agent.\";\n                        return result;\n\n                    case NodeTypeEnum.End:\n                        _logger.LogInformation(\"âœ… End node reached.\");\n                        currentNode = null;\n                        continue;\n\n                    case NodeTypeEnum.Choice:\n                        _logger.LogInformation(\"ðŸ§  Reached Choice node. Saving session state to wait for user input...\");\n\n                        var session = await _appDbContext.ChatSessionStates.FirstOrDefaultAsync(s =>\n                            s.BusinessId == businessId && s.ContactId == contactId);\n\n                        if (session == null)\n                        {\n                            session = new ChatSessionState\n                            {\n                                Id = Guid.NewGuid(),\n                                BusinessId = businessId,\n                                ContactId = contactId\n                            };\n                            _appDbContext.ChatSessionStates.Add(session);\n                        }\n\n                        session.Mode = \"awaiting_choice\";\n                        session.UpdatedBy = currentNode.Id.ToString();\n                        session.LastUpdatedAt = DateTime.UtcNow;\n\n                        await _appDbContext.SaveChangesAsync();\n\n                        result.Notes = \"Choice node reached. Flow paused.\";\n                        return result;\n                }\n\n                var edge = edges.FirstOrDefault(e => e.SourceNodeId == currentNode.Id);\n                currentNode = edge == null ? null : nodes.FirstOrDefault(n => n.Id == edge.TargetNodeId);\n            }\n\n            result.Notes = \"Flow completed.\";\n            return result;\n        }\n        public async Task<AutomationFlowRunResult> ResumeFlowAsync(\n           Guid businessId,\n           Guid contactId,\n           string contactPhone,\n           string incomingMessage)\n        {\n            var session = await _appDbContext.ChatSessionStates\n                .FirstOrDefaultAsync(s => s.BusinessId == businessId && s.ContactId == contactId);\n\n            if (session == null || session.Mode != \"awaiting_choice\")\n            {\n                _logger.LogWarning(\"âŒ No active automation session found or mode not awaiting_choice.\");\n                return new AutomationFlowRunResult { NeedsAgent = true, Notes = \"No active automation session.\" };\n            }\n\n            var flow = await _appDbContext.AutomationFlows\n                .Where(f => f.BusinessId == businessId && f.IsActive)\n                .OrderByDescending(f => f.UpdatedAt)\n                .FirstOrDefaultAsync();\n\n            if (flow == null)\n            {\n                _logger.LogWarning(\"âŒ No active automation flow found for business.\");\n                return new AutomationFlowRunResult { NeedsAgent = true, Notes = \"No active flow found.\" };\n            }\n\n            var nodes = JsonConvert.DeserializeObject<List<AutomationFlowNode>>(flow.NodesJson);\n            var edges = JsonConvert.DeserializeObject<List<AutomationFlowEdge>>(flow.EdgesJson);\n\n            var choiceNode = nodes.FirstOrDefault(n => n.Id == session.UpdatedBy && n.NodeType == NodeTypeEnum.Choice);\n            if (choiceNode == null)\n            {\n                _logger.LogWarning(\"âŒ Stored session node not found or not a Choice node.\");\n                return new AutomationFlowRunResult { NeedsAgent = true, Notes = \"Invalid Choice node in session.\" };\n            }\n\n            var cfg = JsonConvert.DeserializeObject<ChoiceConfig>(choiceNode.ConfigJson);\n            if (cfg?.Conditions == null)\n            {\n                _logger.LogWarning(\"âŒ Choice config is null or empty.\");\n                return new AutomationFlowRunResult { NeedsAgent = true, Notes = \"Invalid Choice config.\" };\n            }\n\n            var match = cfg.Conditions.FirstOrDefault(c =>\n                string.Equals(c.Match.Trim(), incomingMessage.Trim(), StringComparison.OrdinalIgnoreCase));\n\n            string nextNodeId = match?.NextNodeId ?? cfg.FallbackNodeId;\n            if (match == null)\n            {\n                _logger.LogWarning(\"ðŸ” No matching condition found. Using fallback: {Fallback}\", nextNodeId);\n            }\n\n            var nextNode = nodes.FirstOrDefault(n => n.Id == nextNodeId);\n            if (nextNode == null)\n            {\n                _logger.LogWarning(\"âŒ Next node after choice not found.\");\n                return new AutomationFlowRunResult { NeedsAgent = true, Notes = \"Next node not found.\" };\n            }\n\n            // âœ… Clear session after resume\n            _appDbContext.ChatSessionStates.Remove(session);\n            await _appDbContext.SaveChangesAsync();\n\n            // âœ… Resume from the matched node using shared loop\n            return await ExecuteNodeLoopAsync(flow, nextNode, nodes, edges, businessId, contactId, contactPhone);\n        }\n\n\n        private async Task<AutomationFlowRunResult> ExecuteNodeLoopAsync(\n    AutomationFlow flow,\n    AutomationFlowNode startNode,\n    List<AutomationFlowNode> nodes,\n    List<AutomationFlowEdge> edges,\n    Guid businessId,\n    Guid contactId,\n    string contactPhone)\n        {\n            var result = new AutomationFlowRunResult();\n            var currentNode = startNode;\n\n            while (currentNode != null)\n            {\n                _logger.LogInformation(\"âž¡ï¸ Executing node: {NodeType} | {NodeId}\", currentNode.NodeType, currentNode.Id);\n\n                switch (currentNode.NodeType)\n                {\n                    case NodeTypeEnum.Message:\n                        var msgCfg = JsonConvert.DeserializeObject<MessageConfig>(currentNode.ConfigJson);\n                        var msgDto = new TextMessageSendDto\n                        {\n                            BusinessId = businessId,\n                            ContactId = contactId,\n                            RecipientNumber = contactPhone,\n                            TextContent = msgCfg.Text,\n                            Source = \"automation\"\n                        };\n                        await _messageService.SendAutomationReply(msgDto);\n                        break;\n\n                    case NodeTypeEnum.Tag:\n                        var tagCfg = JsonConvert.DeserializeObject<TagNodeConfig>(currentNode.ConfigJson);\n                        await _contactService.AssignTagsAsync(businessId, contactPhone, tagCfg.Tags);\n                        break;\n\n                    case NodeTypeEnum.Wait:\n                        var waitCfg = JsonConvert.DeserializeObject<WaitConfig>(currentNode.ConfigJson);\n                        await Task.Delay(waitCfg.Seconds * 1000);\n                        break;\n\n                    case NodeTypeEnum.End:\n                        return new AutomationFlowRunResult { Notes = \"âœ… Flow ended.\" };\n\n                    case NodeTypeEnum.AgentHandoff:\n                        return new AutomationFlowRunResult\n                        {\n                            NeedsAgent = true,\n                            Notes = \"Routed to human agent.\"\n                        };\n\n                    case NodeTypeEnum.Choice:\n                        var session = new ChatSessionState\n                        {\n                            Id = Guid.NewGuid(),\n                            BusinessId = businessId,\n                            ContactId = contactId,\n                            Mode = \"awaiting_choice\",\n                            UpdatedBy = currentNode.Id.ToString(),\n                            LastUpdatedAt = DateTime.UtcNow\n                        };\n                        _appDbContext.ChatSessionStates.Add(session);\n                        await _appDbContext.SaveChangesAsync();\n\n                        return new AutomationFlowRunResult { Notes = \"Paused at Choice node.\" };\n                }\n\n                var edge = edges.FirstOrDefault(e => e.SourceNodeId == currentNode.Id);\n                currentNode = edge == null ? null : nodes.FirstOrDefault(n => n.Id == edge.TargetNodeId);\n            }\n\n            return new AutomationFlowRunResult { Notes = \"Flow completed.\" };\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Services/AutomationService.cs",
      "sha256": "ff80f3aa6181772b1eae30360dc0e8fb364a432f380e12f8a79d03f24618bdc4",
      "language": "csharp",
      "size": 5110,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.Automation.Models;\nusing xbytechat.api.Features.Automation.Repositories;\nusing xbytechat.api.Features.CRM.Interfaces;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.Automation.Services\n{\n    public class AutomationService : IAutomationService\n    {\n        private readonly IAutomationFlowRepository _flowRepository;\n        private readonly IAutomationRunner _runner;\n        private readonly IContactService _contactService;\n        private readonly ILogger<AutomationService> _logger;\n        private readonly IHttpContextAccessor _httpContextAccessor;\n\n        public AutomationService(\n            IAutomationFlowRepository flowRepository,\n            IAutomationRunner runner,\n            IContactService contactService,\n            ILogger<AutomationService> logger,\n            IHttpContextAccessor httpContextAccessor)\n        {\n            _flowRepository = flowRepository;\n            _runner = runner;\n            _contactService = contactService;\n            _logger = logger;\n            _httpContextAccessor = httpContextAccessor;\n        }\n\n        public async Task<AutomationFlow?> GetFlowByIdAsync(Guid flowId, Guid businessId)\n        {\n            return await _flowRepository.GetByIdAsync(flowId, businessId);\n        }\n\n        public async Task<AutomationFlow?> GetFlowByKeywordAsync(Guid businessId, string keyword)\n        {\n            return await _flowRepository.GetByKeywordAsync(businessId, keyword);\n        }\n\n        public async Task<AutomationFlowRunResult> RunFlowAsync(\n            AutomationFlow flow,\n            Guid businessId,\n            Guid contactId,\n            string phone,\n            string sourceChannel,\n            string industryTag)\n        {\n            return await _runner.RunFlowAsync(flow, businessId, contactId, phone, sourceChannel, industryTag);\n        }\n\n        public async Task<IEnumerable<AutomationFlow>> GetAllFlowsAsync(Guid businessId)\n        {\n            return await _flowRepository.GetAllByBusinessAsync(businessId);\n        }\n\n        public async Task<AutomationFlow> CreateFlowAsync(Guid businessId, AutomationFlow flow)\n        {\n            flow.BusinessId = businessId;\n            return await _flowRepository.CreateAsync(flow);\n        }\n\n        public async Task<bool> DeleteFlowAsync(Guid flowId, Guid businessId)\n        {\n            return await _flowRepository.DeleteAsync(flowId, businessId);\n        }\n\n        public async Task RunByKeywordAsync(string messageText, string phoneNumber, string sourceChannel = \"whatsapp\")\n        {\n            var businessId = _httpContextAccessor.HttpContext?.User?.GetBusinessId()\n                ?? throw new UnauthorizedAccessException(\"BusinessId could not be resolved from context.\");\n\n            var flow = await _flowRepository.GetByKeywordAsync(businessId, messageText);\n            if (flow == null)\n            {\n                _logger.LogInformation(\"No matching automation flow for keyword: {Keyword}\", messageText);\n                return;\n            }\n\n            var contact = await _contactService.FindOrCreateAsync(businessId, phoneNumber);\n            await _runner.RunFlowAsync(flow, businessId, contact.Id, contact.PhoneNumber, sourceChannel, industryTag: \"default\");\n        }\n\n        public async Task<bool> TryRunFlowByKeywordAsync(\n         Guid businessId,\n         string messageText,\n         string userPhone,\n         string sourceChannel,\n         string industryTag)\n        {\n            try\n            {\n                // ðŸ” Normalize keyword\n                var normalizedKeyword = messageText.Trim().ToLower();\n\n                // âœ… Fetch flow by trigger keyword\n                var flow = await _flowRepository.GetByKeywordAsync(businessId, normalizedKeyword);\n                if (flow == null)\n                {\n                    _logger.LogInformation(\"TryRun: No matching automation flow found for keyword: '{Keyword}'\", normalizedKeyword);\n                    return false;\n                }\n\n                // ðŸ‘¤ Ensure contact exists\n                var contact = await _contactService.FindOrCreateAsync(businessId, userPhone);\n                if (contact == null)\n                {\n                    _logger.LogWarning(\"âŒ TryRun: Failed to resolve or create contact for phone: {Phone}\", userPhone);\n                    return false;\n                }\n\n                // â–¶ï¸ Run automation flow\n                _logger.LogInformation(\"ðŸš€ Running flow '{FlowName}' for keyword '{Keyword}'\", flow.Name, normalizedKeyword);\n                await _runner.RunFlowAsync(flow, businessId, contact.Id, contact.PhoneNumber, sourceChannel, industryTag);\n\n                return true;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"âŒ TryRun: Exception while executing flow for keyword '{Keyword}'\", messageText);\n                return false;\n            }\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Services/IAutomationRunner.cs",
      "sha256": "0aa081c7006bb76ff84c8cee9da21e51a021a69c4e0b6d191ffdc1356b5e4001",
      "language": "csharp",
      "size": 453,
      "content": "using System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Automation.Models;\n\nnamespace xbytechat.api.Features.Automation.Services\n{\n    public interface IAutomationRunner\n    {\n        Task<AutomationFlowRunResult> RunFlowAsync(\n             AutomationFlow flow,\n             Guid businessId,\n             Guid contactId,\n             string contactPhone,\n             string sourceChannel,\n             string industryTag\n );\n\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Services/IAutomationService.cs",
      "sha256": "fd32d83e0e970571048b14fb8805162a0b1139c917ed0bf99ad84b4a244ce609",
      "language": "csharp",
      "size": 1688,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Automation.Models;\n\nnamespace xbytechat.api.Features.Automation.Services\n{\n    public interface IAutomationService\n    {\n        // ðŸ“Œ Get flow by FlowId (for admin UI or debugging)\n        Task<AutomationFlow?> GetFlowByIdAsync(Guid flowId, Guid businessId);\n\n        // ðŸ“Œ Get flow by keyword match (used for auto-triggering)\n        Task<AutomationFlow?> GetFlowByKeywordAsync(Guid businessId, string keyword);\n\n        // ðŸ› ï¸ Execute a flow with contact and channel info\n        Task<AutomationFlowRunResult> RunFlowAsync(\n            AutomationFlow flow,\n            Guid businessId,\n            Guid contactId,\n            string phone,\n            string sourceChannel,\n            string industryTag\n        );\n\n        // ðŸ“‹ List all flows (for admin or dashboard)\n        Task<IEnumerable<AutomationFlow>> GetAllFlowsAsync(Guid businessId);\n\n        // âž• Create new flow\n        Task<AutomationFlow> CreateFlowAsync(Guid businessId, AutomationFlow flow);\n\n        // âŒ Delete existing flow\n        Task<bool> DeleteFlowAsync(Guid flowId, Guid businessId);\n\n        // âš¡ Runtime entry point â€“ called when a message arrives\n        Task RunByKeywordAsync(\n            string messageText,\n            string phoneNumber,\n            string sourceChannel = \"whatsapp\"\n        );\n\n        // âœ… Returns true if flow matched and executed\n        Task<bool> TryRunFlowByKeywordAsync(\n            Guid businessId,\n            string messageText,\n            string userPhone,\n            string sourceChannel,\n            string industryTag\n        );\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Controllers/AutoReplyFlowsController.cs",
      "sha256": "25ac7814daf6df137e5beb976fe5ba21a8d94fdb458c29a1a8531aea723c3077",
      "language": "csharp",
      "size": 12787,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.AutoReplyBuilder.DTOs;\nusing xbytechat.api.Features.AutoReplyBuilder.Services;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Controllers\n{\n    /// <summary>\n    /// Controller for AutoReply builder operations:\n    /// - CRUD for AutoReply flows used by the canvas UI\n    /// - Test-match endpoint used by the \"Test Auto-Reply Match\" panel\n    /// </summary>\n    [ApiController]\n    [Route(\"api/autoreplyflows\")]\n    [Authorize]\n    public sealed class AutoReplyFlowsController : ControllerBase\n    {\n        private readonly IAutoReplyFlowService _service;\n        private readonly IAutoReplyRuntimeService _runtime;\n        private readonly ILogger<AutoReplyFlowsController> _logger;\n\n        public AutoReplyFlowsController(\n            IAutoReplyFlowService service,\n            IAutoReplyRuntimeService runtime,\n            ILogger<AutoReplyFlowsController> logger)\n        {\n            _service = service;\n            _runtime = runtime;\n            _logger = logger;\n        }\n\n        // ---------------------------------------------------------\n        // 1) LIST FLOWS  - used when the builder page loads\n        // GET /api/autoreplyflows\n        // ---------------------------------------------------------\n        [HttpGet]\n        public async Task<ActionResult<IEnumerable<AutoReplyFlowSummaryDto>>> GetAll(\n            CancellationToken ct)\n        {\n            var bizId = ClaimsBusinessDetails.GetBusinessId(User);\n            var flows = await _service.GetFlowsForBusinessAsync(bizId, ct);\n            return Ok(flows);\n        }\n\n        // ---------------------------------------------------------\n        // 2) GET SINGLE FLOW - used when opening a specific flow\n        // GET /api/autoreplyflows/{id}\n        // ---------------------------------------------------------\n        [HttpGet(\"{id:guid}\")]\n        public async Task<ActionResult<AutoReplyFlowDto>> Get(Guid id, CancellationToken ct)\n        {\n            var bizId = ClaimsBusinessDetails.GetBusinessId(User);\n            var flow = await _service.GetFlowAsync(bizId, id, ct);\n            if (flow is null) return NotFound();\n            return Ok(flow);\n        }\n\n        // ---------------------------------------------------------\n        // 3) CREATE / UPDATE FLOW - used when you click Save in builder\n        // POST /api/autoreplyflows\n        // ---------------------------------------------------------\n        [HttpPost]\n        public async Task<ActionResult<AutoReplyFlowDto>> Save(\n            [FromBody] AutoReplyFlowDto dto,\n            CancellationToken ct)\n        {\n            if (!ModelState.IsValid)\n            {\n                _logger.LogWarning(\"AutoReplyFlow model invalid: {@ModelState}\", ModelState);\n                return ValidationProblem(ModelState);\n            }\n\n            var bizId = ClaimsBusinessDetails.GetBusinessId(User);\n            var saved = await _service.SaveFlowAsync(bizId, dto, ct);\n            return Ok(saved);\n        }\n\n        // ---------------------------------------------------------\n        // 3a) BACK-COMPAT ALIAS FOR OLDER FRONTEND\n        // POST /api/autoreplyflows/save\n        // ---------------------------------------------------------\n        [HttpPost(\"save\")]\n        public Task<ActionResult<AutoReplyFlowDto>> SaveAlias(\n            [FromBody] AutoReplyFlowDto dto,\n            CancellationToken ct)\n            => Save(dto, ct);\n\n        // ---------------------------------------------------------\n        // 4) DELETE FLOW\n        // DELETE /api/autoreplyflows/{id}\n        // ---------------------------------------------------------\n        [HttpDelete(\"{id:guid}\")]\n        public async Task<IActionResult> Delete(Guid id, CancellationToken ct)\n        {\n            var bizId = ClaimsBusinessDetails.GetBusinessId(User);\n            await _service.DeleteFlowAsync(bizId, id, ct);\n            return NoContent();\n        }\n        // ---------------------------------------------------------\n        // 4a) UPDATE FLOW STATUS (ACTIVE / INACTIVE)\n        // PATCH /api/autoreplyflows/{id}/status\n        // ---------------------------------------------------------\n        [HttpPatch(\"{id:guid}/status\")]\n        public async Task<IActionResult> UpdateStatus(\n            Guid id,\n            [FromBody] AutoReplyFlowStatusUpdateDto dto,\n            CancellationToken ct)\n        {\n            if (dto is null)\n            {\n                return BadRequest(\"Request body is required.\");\n            }\n\n            var bizId = ClaimsBusinessDetails.GetBusinessId(User);\n\n            await _service.SetActiveAsync(\n                bizId,\n                id,\n                dto.IsActive,\n                ct);\n\n            return NoContent();\n        }\n\n        // ---------------------------------------------------------\n        // 5) TEST-MATCH ENDPOINT FOR BUILDER PANEL\n        // POST /api/autoreplyflows/test-match\n        //\n        // Frontend sends: { businessId, incomingText }\n        // Response: { isMatch, flowId, flowName, matchedKeyword, startNodeType, startNodeName }\n        // ---------------------------------------------------------\n        [HttpPost(\"test-match\")]\n        public async Task<ActionResult<AutoReplyTestMatchResponseDto>> TestMatchAsync(\n            [FromBody] AutoReplyTestMatchRequestDto dto,\n            CancellationToken ct)\n        {\n            if (!ModelState.IsValid)\n            {\n                return ValidationProblem(ModelState);\n            }\n\n            _logger.LogInformation(\n                \"ðŸ” AutoReply test-match requested for Business {BusinessId} with text: {Text}\",\n                dto.BusinessId,\n                dto.IncomingText\n            );\n\n            // NOTE: Right now the runtime is mostly stubbed.\n            // This call will later contain the real keyword/flow matching logic.\n            var result = await _runtime.TestMatchAsync(dto.BusinessId, dto.IncomingText, ct);\n\n            var response = new AutoReplyTestMatchResponseDto\n            {\n                IsMatch = result.Handled,\n                FlowId = result.AutoReplyFlowId ?? result.CtaFlowConfigId,\n                FlowName = null, // will be filled when runtime returns metadata\n                MatchedKeyword = result.MatchedKeyword,\n                StartNodeType = null, // will be wired from CTAFlow metadata later\n                StartNodeName = null\n            };\n\n            return Ok(response);\n        }\n    }\n}\n\n\n//using System;\n//using System.Threading;\n//using System.Threading.Tasks;\n//using Microsoft.AspNetCore.Mvc;\n//using Microsoft.Extensions.Logging;\n//using xbytechat.api.Features.AutoReplyBuilder.DTOs;\n//using xbytechat.api.Features.AutoReplyBuilder.Services;\n\n//namespace xbytechat.api.Features.AutoReplyBuilder.Controllers\n//{\n//    /// <summary>\n//    /// Controller for AutoReply builder operations (test match, later maybe listing flows, etc.).\n//    /// </summary>\n//    [ApiController]\n//    [Route(\"api/autoreplyflows\")]\n//    public sealed class AutoReplyFlowsController : ControllerBase\n//    {\n//        private readonly IAutoReplyRuntimeService _autoReplyRuntime;\n//        private readonly ILogger<AutoReplyFlowsController> _logger;\n\n//        public AutoReplyFlowsController(\n//            IAutoReplyRuntimeService autoReplyRuntime,\n//            ILogger<AutoReplyFlowsController> logger)\n//        {\n//            _autoReplyRuntime = autoReplyRuntime;\n//            _logger = logger;\n//        }\n\n//        /// <summary>\n//        /// Test whether a given incoming text would match any AutoReply rule.\n//        /// Used by the AutoReplyBuilder \"Test Auto-Reply Match\" panel.\n//        /// </summary>\n//        [HttpPost(\"test-match\")]\n//        public async Task<ActionResult<AutoReplyTestMatchResponseDto>> TestMatchAsync(\n//            [FromBody] AutoReplyTestMatchRequestDto dto,\n//            CancellationToken ct)\n//        {\n//            if (!ModelState.IsValid)\n//            {\n//                return ValidationProblem(ModelState);\n//            }\n\n//            _logger.LogInformation(\n//                \"ðŸ” AutoReply test-match requested for Business {BusinessId} with text: {Text}\",\n//                dto.BusinessId,\n//                dto.IncomingText\n//            );\n\n//            var result = await _autoReplyRuntime.TestMatchAsync(dto.BusinessId, dto.IncomingText, ct);\n\n//            // For now, runtime always returns NotHandled, so IsMatch will be false.\n//            // Later, when we implement matching, Handled = true will mean a rule matched.\n//            var response = new AutoReplyTestMatchResponseDto\n//            {\n//                IsMatch = result.Handled,\n//                FlowId = result.AutoReplyFlowId ?? result.CtaFlowConfigId,\n//                FlowName = null, // will be populated once runtime can surface flow metadata\n//                MatchedKeyword = result.MatchedKeyword,\n//                StartNodeType = null, // to be filled when CTAFlow metadata is integrated\n//                StartNodeName = null  // same as above\n//            };\n\n//            return Ok(response);\n//        }\n//    }\n//}\n\n\n////using Microsoft.AspNetCore.Authorization;\n////using Microsoft.AspNetCore.Mvc;\n////using xbytechat.api.Features.AutoReplyBuilder.DTOs;\n////using xbytechat.api.Shared;\n////using xbytechat.api.Features.AutoReplyBuilder.Services;\n////using xbytechat.api.Features.AutoReplyBuilder.DTOs;\n\n////namespace xbytechat.api.Features.AutoReplyBuilder.Controllers\n////{\n////    [ApiController]\n////    [Route(\"api/autoreplyflows\")]\n////    [Authorize]\n////    public sealed class AutoReplyFlowsController : ControllerBase\n////    {\n////        private readonly IAutoReplyFlowService _service;\n////        private readonly IAutoReplyRuntimeService _runtime;\n////        private readonly ILogger<AutoReplyFlowsController> _logger;\n\n////        public AutoReplyFlowsController(\n////            IAutoReplyFlowService service,\n////            IAutoReplyRuntimeService runtime,\n////            ILogger<AutoReplyFlowsController> logger)\n////        {\n////            _service = service;\n////            _runtime = runtime;\n////            _logger = logger;\n////        }\n\n////        // GET /api/autoreplyflows\n////        [HttpGet]\n////        public async Task<ActionResult<IEnumerable<AutoReplyFlowSummaryDto>>> GetAll(CancellationToken ct)\n////        {\n////            var bizId = User.GetBusinessId();\n////            var flows = await _service.GetFlowsForBusinessAsync(bizId, ct);\n////            return Ok(flows);\n////        }\n\n////        // GET /api/autoreplyflows/{id}\n////        [HttpGet(\"{id:guid}\")]\n////        public async Task<ActionResult<AutoReplyFlowDto>> Get(Guid id, CancellationToken ct)\n////        {\n////            var bizId = User.GetBusinessId();\n////            var flow = await _service.GetFlowAsync(bizId, id, ct);\n////            if (flow is null) return NotFound();\n////            return Ok(flow);\n////        }\n\n////        // POST /api/autoreplyflows (create or update)\n////        [HttpPost]\n////        public async Task<ActionResult<AutoReplyFlowDto>> Save([FromBody] AutoReplyFlowDto dto, CancellationToken ct)\n////        {\n////            if (!ModelState.IsValid)\n////            {\n////                _logger.LogWarning(\"AutoReplyFlow model invalid: {@ModelState}\", ModelState);\n////                return ValidationProblem(ModelState);\n////            }\n\n////            var bizId = User.GetBusinessId();\n////            var saved = await _service.SaveFlowAsync(bizId, dto, ct);\n////            return Ok(saved);\n////        }\n\n////        // Back-compat alias for older frontend\n////        [HttpPost(\"save\")]\n////        public Task<ActionResult<AutoReplyFlowDto>> SaveAlias([FromBody] AutoReplyFlowDto dto, CancellationToken ct) => Save(dto, ct);\n\n////        // DELETE /api/autoreplyflows/{id}\n////        [HttpDelete(\"{id:guid}\")]\n////        public async Task<IActionResult> Delete(Guid id, CancellationToken ct)\n////        {\n////            var bizId = User.GetBusinessId();\n////            await _service.DeleteFlowAsync(bizId, id, ct);\n////            return NoContent();\n////        }\n\n////        // POST /api/autoreplyflows/test-match\n////        [HttpPost(\"test-match\")]\n////        public async Task<ActionResult<AutoReplyMatchResultDto>> TestMatch([FromBody] AutoReplyMatchRequestDto request, CancellationToken ct)\n////        {\n////            var result = await _runtime.FindMatchAsync(request, ct);\n////            return Ok(result);\n////        }\n////    }\n////}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Controllers/AutoReplyLogsController.cs",
      "sha256": "73bd3aafc0179cf97c57ab38413426d298cba586c91bbed26edadc7c77b691f8",
      "language": "csharp",
      "size": 1791,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.AutoReplyBuilder.DTOs;\nusing xbytechat.api.Features.AutoReplyBuilder.Services;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Controllers\n{\n    /// <summary>\n    /// Read-only endpoints for AutoReply logs, used by the builder UI.\n    /// </summary>\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize] // same auth pattern as other feature controllers\n    public class AutoReplyLogsController : ControllerBase\n    {\n        private readonly IAutoReplyLogService _logService;\n\n        public AutoReplyLogsController(IAutoReplyLogService logService)\n        {\n            _logService = logService;\n        }\n\n        /// <summary>\n        /// Returns most recent auto-reply triggers for the current business.\n        /// GET /api/autoreplylogs/recent?take=20\n        /// </summary>\n        [HttpGet(\"recent\")]\n        [ProducesResponseType(typeof(IReadOnlyList<AutoReplyLogSummaryDto>), 200)]\n        public async Task<ActionResult<IReadOnlyList<AutoReplyLogSummaryDto>>> GetRecentAsync(\n            [FromQuery] int take = 20,\n            CancellationToken cancellationToken = default)\n        {\n            // BusinessId comes from JWT claims\n            var businessId = User.GetBusinessId();\n\n            if (businessId == Guid.Empty)\n            {\n                return Unauthorized(\"Missing or invalid business id in token.\");\n            }\n\n            var items = await _logService.GetRecentAsync(\n                businessId,\n                take,\n                cancellationToken);\n\n            return Ok(items);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Controllers/AutoReplyRuntimeController.cs",
      "sha256": "a9f67fd1830276dc16b500b095809916f5e927e4468ad792e90bb991da999ceb",
      "language": "csharp",
      "size": 2328,
      "content": "using Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.AutoReplyBuilder.DTOs;\nusing xbytechat.api.Features.AutoReplyBuilder.Services;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Controllers\n{\n    [ApiController]\n    [Route(\"api/auto-reply-runtime\")]\n    [Authorize]\n    public class AutoReplyRuntimeController : ControllerBase\n    {\n        private readonly IAutoReplyRuntimeService _runtimeService;\n        private readonly ILogger<AutoReplyRuntimeController> _logger;\n\n        public AutoReplyRuntimeController(\n            IAutoReplyRuntimeService runtimeService,\n            ILogger<AutoReplyRuntimeController> logger)\n        {\n            _runtimeService = runtimeService;\n            _logger = logger;\n        }\n\n        // ðŸ” Simple button-click matcher (uses the new keyword matcher under the hood)\n        [HttpPost(\"button-click\")]\n        public async Task<ActionResult<AutoReplyMatchResultDto>> HandleButtonClick([FromBody] AutoReplyButtonClickDto dto)\n        {\n            var businessId = ClaimsBusinessDetails.GetBusinessId(User);\n\n            _logger.LogInformation(\"ðŸ”˜ Button clicked: BusinessId={BusinessId}, Phone={Phone}, Button={ButtonText}, RefMsg={RefMessageId}\",\n                businessId, dto.Phone, dto.ButtonText, dto.RefMessageId?.ToString() ?? \"null\");\n\n            var result = await _runtimeService.FindMatchAsync(\n                new AutoReplyMatchRequestDto\n                {\n                    BusinessId = businessId,\n                    IncomingText = dto.ButtonText ?? string.Empty\n                });\n\n            return Ok(result);\n        }\n\n        // ðŸ§ª Manual test (canvas-based flow trigger) - now returns a match preview only\n        [HttpPost(\"flow-by-button\")]\n        public async Task<ActionResult<AutoReplyMatchResultDto>> TriggerFlowByButton([FromBody] AutoReplyButtonClickDto dto)\n        {\n            var businessId = dto.BusinessId != Guid.Empty ? dto.BusinessId : ClaimsBusinessDetails.GetBusinessId(User);\n            var match = await _runtimeService.FindMatchAsync(new AutoReplyMatchRequestDto\n            {\n                BusinessId = businessId,\n                IncomingText = dto.ButtonText ?? string.Empty\n            });\n\n            return Ok(match);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Controllers/TemplatesController.cs",
      "sha256": "555d0e0c3deaa65e82290ddcf55e06bb4fa67bbcf43e5b9d56ea5109f7c236b8",
      "language": "csharp",
      "size": 995,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.TemplateMessages.DTOs;\n\nnamespace xbytechat.api.Features.TemplateMessages.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class TemplatesController : ControllerBase\n    {\n        private static readonly List<TemplateDto> MockTemplates = new()\n        {\n            new TemplateDto\n            {\n                Id = Guid.NewGuid(),\n                Name = \"Welcome Template\",\n                Placeholders = 2\n            },\n            new TemplateDto\n            {\n                Id = Guid.NewGuid(),\n                Name = \"Offer Reminder\",\n                Placeholders = 1\n            },\n            new TemplateDto\n            {\n                Id = Guid.NewGuid(),\n                Name = \"Follow Up\",\n                Placeholders = 3\n            }\n        };\n\n        [HttpGet]\n        public ActionResult<List<TemplateDto>> GetAll()\n        {\n            return Ok(MockTemplates);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/AutoReplyButtonClickDto.cs",
      "sha256": "c33e345f9a02ff4d627ba42ba92505f5819a034035b07bde678784a244b9d6ac",
      "language": "csharp",
      "size": 412,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n{\n    public class AutoReplyButtonClickDto\n    {\n        public Guid FlowId { get; set; }\n        public Guid BusinessId { get; set; }\n        public Guid ContactId { get; set; }\n        public string Phone { get; set; } = string.Empty;\n        public string ButtonText { get; set; } = string.Empty;\n        public Guid? RefMessageId { get; set; }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/AutoReplyFlowDefinitionDto.cs",
      "sha256": "4c8f724416a637942e075af6566e476ec364a649fe98839fc0288bcefbc2277d",
      "language": "csharp",
      "size": 3849,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n{\n    /// <summary>\n    /// Runtime shape for an AutoReply flow definition, deserialized from AutoReplyFlow.NodesJson.\n    /// This is NOT an EF entity and is never mapped to a DB table.\n    /// </summary>\n    public sealed class AutoReplyFlowDefinitionDto\n    {\n        /// <summary>\n        /// Optional â€“ if your NodesJson stores the starting node id.\n        /// If your runtime method uses this, it will be populated; otherwise it can stay null/empty.\n        /// </summary>\n        public string? StartNodeId { get; set; }\n\n        /// <summary>\n        /// All nodes that belong to this flow, in whatever order they were saved by the builder.\n        /// ExecuteFlowLinearAsync can order or chain them as it likes.\n        /// </summary>\n        public List<AutoReplyFlowNodeDto> Nodes { get; set; } = new();\n    }\n\n    /// <summary>\n    /// Runtime shape for a single node inside an AutoReply flow.\n    /// This is intentionally kept as a \"flattened\" shape that matches the\n    /// needs of ExecuteFlowLinearAsync:\n    /// - Node type (message / template / set-tag / wait)\n    /// - Content fields for that type\n    /// - Linear chaining info (Order / NextNodeId)\n    /// </summary>\n    public sealed class AutoReplyFlowNodeDto\n    {\n        /// <summary>\n        /// Unique id of the node inside this flow (often the same as the ReactFlow node id).\n        /// </summary>\n        public string Id { get; set; } = null!;\n\n        /// <summary>\n        /// Node type. Expected values (by the new runtime) include:\n        /// \"message\", \"template\", \"set-tag\", \"wait\"\n        /// </summary>\n        public string Type { get; set; } = null!;\n\n        /// <summary>\n        /// Optional friendly name / label shown in the builder UI.\n        /// Not required for runtime, but useful for logs and debugging.\n        /// </summary>\n        public string? Name { get; set; }\n\n        /// <summary>\n        /// Execution order for linear flows, if you are ordering by an explicit number.\n        /// If your runtime doesnâ€™t use this, it can safely remain 0.\n        /// </summary>\n        public int Order { get; set; }\n\n        // ----- Content for \"message\" nodes -----\n\n        /// <summary>\n        /// Plain text to send for \"message\" type nodes.\n        /// </summary>\n        public string? Text { get; set; }\n\n        // ----- Content for \"template\" nodes -----\n\n        /// <summary>\n        /// Template name for \"template\" type nodes.\n        /// </summary>\n        public string? TemplateName { get; set; }\n\n        /// <summary>\n        /// Optional template namespace / category if you store it.\n        /// </summary>\n        public string? TemplateNamespace { get; set; }\n\n        /// <summary>\n        /// Optional template language code (e.g., \"en\", \"en_US\").\n        /// </summary>\n        public string? TemplateLanguage { get; set; }\n\n        // ----- Content for \"set-tag\" nodes -----\n\n        /// <summary>\n        /// Tag key to set on the contact (e.g., \"lead_stage\").\n        /// </summary>\n        public string? TagKey { get; set; }\n\n        /// <summary>\n        /// Tag value to set on the contact (e.g., \"hot\", \"warm\", \"cold\").\n        /// </summary>\n        public string? TagValue { get; set; }\n\n        // ----- Content for \"wait\" nodes -----\n\n        /// <summary>\n        /// Delay for \"wait\" nodes, in seconds.\n        /// </summary>\n        public int? WaitSeconds { get; set; }\n\n        // ----- Basic chaining -----\n\n        /// <summary>\n        /// Next node id for simple linear flows.\n        /// If your runtime walks the flow by following NextNodeId,\n        /// this will be populated when saving from the builder.\n        /// </summary>\n        public string? NextNodeId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/AutoReplyFlowDto.cs",
      "sha256": "8e0d6126ca3f97d47b6802a4f859f24ab1ba134be25ee89b6746df52ffc34fee",
      "language": "csharp",
      "size": 3507,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n{\n    /// <summary>\n    /// Full flow DTO (including nodes) for CRUD in the builder.\n    /// </summary>\n    public sealed class AutoReplyFlowDto\n    {\n        public Guid? Id { get; set; }\n\n        public string Name { get; set; } = string.Empty;\n\n        public string? Description { get; set; }\n\n        public bool IsActive { get; set; }\n\n        /// <summary>\n        /// Comma / newline separated trigger keywords, e.g. \"hi, hello\".\n        /// </summary>\n        public string? TriggerKeyword { get; set; }\n\n        public string? IndustryTag { get; set; }\n\n        public string? UseCase { get; set; }\n\n        public bool IsDefaultTemplate { get; set; }\n\n        /// <summary>\n        /// Matching mode for this flow:\n        /// \"Exact\" | \"Word\" | \"StartsWith\" | \"Contains\".\n        /// Defaults to \"Word\" on the backend when not provided.\n        /// </summary>\n        public string MatchMode { get; set; } = \"Word\";\n\n        /// <summary>\n        /// Priority for choosing between multiple matching flows.\n        /// Higher values win. Default is 0.\n        /// </summary>\n        public int Priority { get; set; } = 0;\n\n        /// <summary>\n        /// When the flow was first created (UTC).\n        /// </summary>\n        public DateTime CreatedAt { get; set; }\n\n        /// <summary>\n        /// When the flow was last updated (UTC). Null if never updated after creation.\n        /// </summary>\n        public DateTime? UpdatedAt { get; set; }\n\n        public List<AutoReplyNodeDto> Nodes { get; set; } = new();\n    }\n}\n\n\n//using System;\n//using System.Collections.Generic;\n\n//namespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n//{\n//    /// <summary>\n//    /// Full flow DTO (including nodes) for CRUD in the builder.\n//    /// </summary>\n//    public sealed class AutoReplyFlowDto\n//    {\n//        public Guid? Id { get; set; }\n\n//        public string Name { get; set; } = string.Empty;\n\n//        public string? Description { get; set; }\n\n//        public bool IsActive { get; set; }\n\n//        public string? TriggerKeyword { get; set; }\n\n//        public string? IndustryTag { get; set; }\n\n//        public string? UseCase { get; set; }\n\n//        public bool IsDefaultTemplate { get; set; }\n\n//        /// <summary>\n//        /// When the flow was first created (UTC).\n//        /// </summary>\n//        public DateTime CreatedAt { get; set; }\n\n//        /// <summary>\n//        /// When the flow was last updated (UTC). Null if never updated after creation.\n//        /// </summary>\n//        public DateTime? UpdatedAt { get; set; }\n\n//        public List<AutoReplyNodeDto> Nodes { get; set; } = new();\n//    }\n//}\n\n\n//using System;\n//using System.Collections.Generic;\n\n//namespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n//{\n//    /// <summary>\n//    /// Full flow DTO (including nodes) for CRUD in the builder.\n//    /// </summary>\n//    public sealed class AutoReplyFlowDto\n//    {\n//        public Guid? Id { get; set; }\n//        public string Name { get; set; } = string.Empty;\n//        public string? Description { get; set; }\n//        public bool IsActive { get; set; }\n//        public string? TriggerKeyword { get; set; }\n//        public string? IndustryTag { get; set; }\n//        public string? UseCase { get; set; }\n//        public bool IsDefaultTemplate { get; set; }\n//        public List<AutoReplyNodeDto> Nodes { get; set; } = new();\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/AutoReplyFlowStatusUpdateDto.cs",
      "sha256": "ba3e8768d81a1c89519ccb2061a16b269765b8bf58fd2874adecfb0e99fe7903",
      "language": "csharp",
      "size": 459,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n{\n    /// <summary>\n    /// Simple DTO used to toggle the active status of an AutoReplyFlow\n    /// from the Flows modal (Activate / Deactivate).\n    /// </summary>\n    public sealed class AutoReplyFlowStatusUpdateDto\n    {\n        /// <summary>\n        /// True to mark the flow as active, false to deactivate it.\n        /// </summary>\n        public bool IsActive { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/AutoReplyFlowSummaryDto.cs",
      "sha256": "0e7186cfa19fdb74bd8833bdf02389698600b368428dfde4f96d1f8290035540",
      "language": "csharp",
      "size": 944,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n{\n    /// <summary>\n    /// Lightweight projection for list screens.\n    /// </summary>\n    public sealed class AutoReplyFlowSummaryDto\n    {\n        public Guid Id { get; set; }\n        public string Name { get; set; } = string.Empty;\n        public bool IsActive { get; set; }\n\n        public string? TriggerKeyword { get; set; }\n        public DateTime CreatedAt { get; set; }\n        public DateTime? UpdatedAt { get; set; }\n\n        /// <summary>\n        /// Matching mode for this flow:\n        /// \"Exact\" | \"Word\" | \"StartsWith\" | \"Contains\".\n        /// Default is \"Word\".\n        /// </summary>\n        public string MatchMode { get; set; } = \"Word\";\n\n        /// <summary>\n        /// Priority for choosing between multiple matching flows.\n        /// Higher values win. Default is 0.\n        /// </summary>\n        public int Priority { get; set; } = 0;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/AutoReplyLogDto.cs",
      "sha256": "dd13070b128bd950f4a1234e9f4d72c462a54c9add4b75cdd3146d7a05c7c4e6",
      "language": "csharp",
      "size": 1728,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n{\n    /// <summary>\n    /// DTO used to log when an AutoReply flow is triggered for a contact.\n    /// </summary>\n    public class AutoReplyLogDto\n    {\n        /// <summary>\n        /// Primary key of the log entry.\n        /// </summary>\n        public Guid Id { get; set; }\n\n        /// <summary>\n        /// Business (tenant) that owns this log entry.\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// Contact that triggered this auto-reply.\n        /// </summary>\n        public Guid ContactId { get; set; }\n\n        /// <summary>\n        /// Type of trigger. Currently always \"flow\" since the legacy rule engine is removed.\n        /// </summary>\n        public string TriggerType { get; set; } = \"flow\";\n\n        /// <summary>\n        /// The keyword that matched and caused the flow to trigger.\n        /// </summary>\n        public string TriggerKeyword { get; set; } = string.Empty;\n\n        /// <summary>\n        /// The reply content that was sent (for auditing / analytics).\n        /// </summary>\n        public string ReplyContent { get; set; } = string.Empty;\n\n        /// <summary>\n        /// UTC timestamp when the auto-reply was triggered.\n        /// </summary>\n        public DateTime TriggeredAt { get; set; }\n\n        /// <summary>\n        /// Optional human-friendly name of the flow that handled the message.\n        /// </summary>\n        public string? FlowName { get; set; }\n\n        /// <summary>\n        /// Optional reference to the outbound MessageLog row that represents the sent auto-reply.\n        /// </summary>\n        public Guid? MessageLogId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/AutoReplyLogSummaryDto.cs",
      "sha256": "2f6883f2a2298da7abbafad539c5126c4a8ec49cd73c4da82f53b7e8d0ed26b8",
      "language": "csharp",
      "size": 644,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n{\n    /// <summary>\n    /// Lightweight read model for showing recent auto-reply triggers\n    /// in the builder UI.\n    /// </summary>\n    public sealed class AutoReplyLogSummaryDto\n    {\n        public Guid Id { get; set; }\n        public string? TriggerType { get; set; }\n        public string? TriggerKeyword { get; set; }\n        public string? FlowName { get; set; }\n        public string? ReplyContent { get; set; }\n        public Guid? ContactId { get; set; }\n        public Guid? MessageLogId { get; set; }\n        public DateTime TriggeredAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/AutoReplyMatchRequestDto.cs",
      "sha256": "25f4ad69dbe593fa20f959847f215102af791cbd025936ae93b6658d4344be13",
      "language": "csharp",
      "size": 352,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n{\n    /// <summary>\n    /// Minimal request for testing runtime auto-reply flow matching.\n    /// </summary>\n    public sealed class AutoReplyMatchRequestDto\n    {\n        public Guid BusinessId { get; set; }\n        public string IncomingText { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/AutoReplyMatchResultDto.cs",
      "sha256": "6ed66ea75c1c11f1baa718db9002019e755393a93e1dae1b941a84b4c6a2fd65",
      "language": "csharp",
      "size": 598,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n{\n    /// <summary>\n    /// Result of a runtime match attempt.\n    /// </summary>\n    public sealed class AutoReplyMatchResultDto\n    {\n        public Guid? FlowId { get; set; }\n        public string? FlowName { get; set; }\n        public string? MatchedKeyword { get; set; }\n        public string? MatchType { get; set; }\n        public Guid? StartNodeId { get; set; }\n        public string? StartNodeType { get; set; }\n        public string? StartNodeConfigJson { get; set; }\n        public bool IsMatch { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/AutoReplyNodeDto.cs",
      "sha256": "82540be38bfc3ac4fea1deafff566c384f68b97f8492374619440e52133f21bd",
      "language": "csharp",
      "size": 689,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n{\n    /// <summary>\n    /// DTO for a single node inside an auto-reply flow.\n    /// Maps directly to <see cref=\"Models.AutoReplyFlowNode\"/> so builder edits round-trip cleanly.\n    /// </summary>\n    public sealed class AutoReplyNodeDto\n    {\n        public Guid? Id { get; set; }\n        public string NodeType { get; set; } = string.Empty;\n        public string? Label { get; set; }\n        public string? NodeName { get; set; }\n        public string? ConfigJson { get; set; }\n        public double PositionX { get; set; }\n        public double PositionY { get; set; }\n        public int Order { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/AutoReplyTestMatchRequestDto.cs",
      "sha256": "a8c862e0b53ae6f8dd27d5e7491b372192ed4bb196cf42e7fb15364c7a82efc6",
      "language": "csharp",
      "size": 692,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n{\n    /// <summary>\n    /// Request body for POST /api/autoreplyflows/test-match.\n    /// Sent by the AutoReplyBuilder UI when testing a sample message.\n    /// </summary>\n    public sealed class AutoReplyTestMatchRequestDto\n    {\n        /// <summary>\n        /// Business (tenant) ID â€“ taken from the logged-in user's auth context in the UI.\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// Sample incoming text typed by the user in the \"Test Auto-Reply Match\" panel.\n        /// </summary>\n        public string IncomingText { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/AutoReplyTestMatchResponseDto.cs",
      "sha256": "c52ef35fdd714cd41dcb48bd3729017170cbec767dbd748c362495b94ba9f5a3",
      "language": "csharp",
      "size": 1244,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n{\n    /// <summary>\n    /// Response shape for POST /api/autoreplyflows/test-match.\n    /// This is what the AutoReplyBuilder UI expects in testResult.\n    /// </summary>\n    public sealed class AutoReplyTestMatchResponseDto\n    {\n        /// <summary>\n        /// True if a matching AutoReply flow was found for the given text.\n        /// </summary>\n        public bool IsMatch { get; set; }\n\n        /// <summary>\n        /// The matched AutoReply flow ID, if any.\n        /// </summary>\n        public Guid? FlowId { get; set; }\n\n        /// <summary>\n        /// The matched AutoReply flow name, if available.\n        /// </summary>\n        public string? FlowName { get; set; }\n\n        /// <summary>\n        /// The keyword or rule that matched, for display/debugging.\n        /// </summary>\n        public string? MatchedKeyword { get; set; }\n\n        /// <summary>\n        /// The type of the Start node (e.g. \"message\", \"template\", etc.).\n        /// </summary>\n        public string? StartNodeType { get; set; }\n\n        /// <summary>\n        /// The name/label of the Start node.\n        /// </summary>\n        public string? StartNodeName { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/FlowExecutionContextDto.cs",
      "sha256": "46002b4a0231f0341915cd9d899d5264fb27bdaa0b829348f628f9e655a274fc",
      "language": "csharp",
      "size": 1390,
      "content": "using System;\nusing xbytechat.api.Features.AutoReplyBuilder.Flows.Models;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n{\n    /// <summary>\n    /// Runtime-only context for executing an AutoReply flow.\n    /// This is NOT an EF entity â€“ it will never create a DB table.\n    /// </summary>\n    public class FlowExecutionContextDto\n    {\n        /// <summary>\n        /// The AutoReply flow being executed (DB entity loaded from AutoReplyFlow table).\n        /// </summary>\n        public AutoReplyFlow Flow { get; set; } = null!;\n\n        /// <summary>\n        /// Business (tenant) ID for scoping.\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// Contact ID in your CRM / Contacts table.\n        /// </summary>\n        public Guid ContactId { get; set; }\n\n        /// <summary>\n        /// WhatsApp phone number (MSISDN) of the contact.\n        /// </summary>\n        public string ContactPhone { get; set; } = null!;\n\n        /// <summary>\n        /// Channel source, e.g. \"whatsapp\". Kept flexible for future multi-channel.\n        /// </summary>\n        public string SourceChannel { get; set; } = \"whatsapp\";\n\n        /// <summary>\n        /// Optional industry tag (restaurant, clinic, etc.) for analytics / specialization.\n        /// </summary>\n        public string IndustryTag { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/FlowNodeConfigs/ButtonChoiceNodeConfig.cs",
      "sha256": "a573ed18c3b3cce438f3f126b958408f9c6245ac01be98c3db1d0c4a92adbb18",
      "language": "csharp",
      "size": 577,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.DTOs.FlowNodeConfigs\n{\n    public class ButtonChoiceNodeConfig\n    {\n        public string PromptText { get; set; } = \"Please choose an option:\";\n\n        public List<ButtonOption> Options { get; set; } = new();\n    }\n\n    public class ButtonOption\n    {\n        public string Label { get; set; } = string.Empty;\n        public string Value { get; set; } = string.Empty;\n\n        // Optional metadata to control button behavior\n        public string? NextStepHint { get; set; } // Can guide user or be used for logging\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/FlowNodeConfigs/ConditionNodeConfig.cs",
      "sha256": "836736c40f25f700d3a84836ee147930568713f5f623bcdc1569b42ff5b4432e",
      "language": "csharp",
      "size": 306,
      "content": "using System.Collections.Generic;\nnamespace xbytechat.api.Features.AutoReplyBuilder.DTOs.FlowNodeConfigs\n{\n    public class ConditionNodeConfig\n    {\n    \n        public string InputKey { get; set; } = \"buttonText\";\n\n        public Dictionary<string, string> PathMap { get; set; } = new();\n       \n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/FlowNodeConfigs/DecisionNodeConfig.cs",
      "sha256": "5575668b5865a5bb2847165208e60278c44386e8f710abb968606e22bb52fe70",
      "language": "csharp",
      "size": 418,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.DTOs.FlowNodeConfigs\n{\n    public class DecisionNodeConfig\n    {\n        public string ConditionType { get; set; } = \"keyword\"; // or \"tag\", \"time\", \"plan\", etc.\n        public string Parameter { get; set; } = string.Empty;   // e.g. \"yes\", \"vip\", \"evening\"\n        public string SourceChannel { get; set; } = \"whatsapp\"; // Optional for multi-channel control\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/FlowNodeConfigs/FormInputNodeConfig.cs",
      "sha256": "34b1ef9a54bc19dbb2163a80371edaf8d5bf75420e9924e90e82762fa4831216",
      "language": "csharp",
      "size": 596,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.DTOs.FlowNodeConfigs\n{\n    public class FormInputNodeConfig\n    {\n        public string QuestionText { get; set; } = \"Please enter your response:\";\n\n        public string FieldKey { get; set; } = \"customer_name\";\n        // Used for storing user response under a label\n\n        public string? ValidationRegex { get; set; }\n        // Optional, e.g., @\"^[0-9]{10}$\" for phone numbers\n\n        public string? PlaceholderHint { get; set; }\n        // e.g., \"Full Name\", \"10-digit Phone\"\n\n        public bool IsRequired { get; set; } = true;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/FlowNodeConfigs/FormNodeConfig.cs",
      "sha256": "f839475742eb0fc23ab0c6e58e1f23a0583e4b649301ac588feb0808dd1c243d",
      "language": "csharp",
      "size": 818,
      "content": "using System.Collections.Generic;\nnamespace xbytechat.api.Features.AutoReplyBuilder.DTOs.FlowNodeConfigs\n{\n    public class FormNodeConfig\n    {\n        public string Title { get; set; } = \"Please fill out this form\";\n\n        public List<FormFieldConfig> Fields { get; set; } = new();\n\n        public bool SaveToContact { get; set; } = true; // Whether to update contact info\n\n        public string? SubmitMessage { get; set; } = \"Thanks for submitting!\";\n    }\n\n    public class FormFieldConfig\n    {\n        public string Key { get; set; } = string.Empty;      // contactName, email, phone\n        public string Label { get; set; } = string.Empty;    // \"Your Name\"\n        public string Type { get; set; } = \"text\";           // text, number, email, etc.\n        public bool Required { get; set; } = true;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/FlowNodeConfigs/ForwardToAgentNodeConfig.cs",
      "sha256": "486eab52256f3ee2bfea5f06ada3bf8fade4f055f1012e4a1291ac0e61c9f35c",
      "language": "csharp",
      "size": 268,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.DTOs.FlowNodeConfigs\n{\n    public class ForwardToAgentNodeConfig\n    {\n        public string? NoteToAgent { get; set; } // Optional instruction for agent\n        public bool MarkAsUrgent { get; set; } = false;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/FlowNodeConfigs/NodeIconMap.cs",
      "sha256": "e56ce9b9bdedf03682aaa6c56815fb85dd510ecd2ec1e4c82f53c0fa5c8f9401",
      "language": "csharp",
      "size": 591,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.DTOs.FlowNodeConfigs\n{\n    public class NodeIconMap\n    {\n        public static readonly Dictionary<string, string> IconMap = new()\n        {\n            { NodeTypeEnum.Message, \"ðŸ—¨ï¸\" },\n            { NodeTypeEnum.Template, \"ðŸ“„\" },\n            { NodeTypeEnum.Tag, \"ðŸ·ï¸\" },\n            { NodeTypeEnum.Wait, \"â±ï¸\" },\n            { NodeTypeEnum.ButtonChoice, \"ðŸ”˜\" },\n            { NodeTypeEnum.Branch, \"ðŸŒ¿\" },\n            { NodeTypeEnum.AgentHandoff, \"ðŸ‘¨â€ðŸ’¼\" },\n            { NodeTypeEnum.End, \"â›”\" }\n        };\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/FlowNodeConfigs/NodeTypeEnum.cs",
      "sha256": "d21739b3b7651f2a026a4e412de76d45fe215ae50907b0c7ee025bee0c1ed189",
      "language": "csharp",
      "size": 572,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.DTOs.FlowNodeConfigs\n{\n    public class NodeTypeEnum\n    {\n        public const string Message = \"message\";\n        public const string Template = \"template\";\n        public const string Tag = \"tag\";\n        public const string Wait = \"wait\";\n        public const string ButtonChoice = \"button_choice\";\n        public const string Branch = \"branch\";\n        public const string End = \"end\"; // Optional: Used for flow exit\n        public const string AgentHandoff = \"agent_handoff\"; // Optional: Transfer to human\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/RenameFlowDto.cs",
      "sha256": "c2ad4577f121df77190a9463e0eb6528c20054bd0901e7bc9a355aedfb53031c",
      "language": "csharp",
      "size": 146,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n{\n    public class RenameFlowDto\n    {\n        public string NewName { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/SaveFlowDto.cs",
      "sha256": "b4b9d49533bad3114236c255a28ecc08bc82a01f1141b981146f320c76cc39f4",
      "language": "csharp",
      "size": 2315,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Flows.DTOs\n{\n    public class SaveFlowDto\n    {\n        public Guid Id { get; set; }\n        public Guid BusinessId { get; set; }\n        public string Name { get; set; }\n        public string? TriggerKeyword { get; set; }\n        public List<NodeDto> Nodes { get; set; } = new();\n        public List<EdgeDto> Edges { get; set; } = new();\n        public DateTime CreatedAt { get; set; }\n\n        public string? IndustryTag { get; set; }     // e.g. \"restaurant\", \"clinic\", etc.\n        public string? UseCase { get; set; }         // e.g. \"Order Flow\", \"Appointment Flow\"\n        public bool IsDefaultTemplate { get; set; } = false; // Flag for prebuilt templates\n\n    }\n\n    public class NodeDto\n    {\n        public string Id { get; set; } = string.Empty;\n        public string Type { get; set; } = string.Empty;\n        public AutoPositionDto Position { get; set; } = new();\n        public NodeDataDto Data { get; set; } = new();\n    }\n\n    public class AutoPositionDto\n    {\n        public double X { get; set; }\n        public double Y { get; set; }\n    }\n\n    public class NodeDataDto\n    {\n        public string Label { get; set; } = string.Empty;\n        public object Config { get; set; } = new { };\n    }\n\n    public class EdgeDto\n    {\n        public string Id { get; set; } = string.Empty;\n        public string Source { get; set; } = string.Empty;\n        public string Target { get; set; } = string.Empty;\n        public string SourceNodeId { get; set; } = string.Empty;\n        public string TargetNodeId { get; set; } = string.Empty;\n        public string SourceHandle { get; set; } = string.Empty;\n        public string TargetHandle { get; set; } = string.Empty;\n    }\n}\n\n\n//using System;\n\n//namespace xbytechat.api.Features.AutoReplyBuilder.Flows.DTOs\n//{\n//    public class SaveFlowDto\n//    {\n//        public Guid Id { get; set; }\n//        public Guid BusinessId { get; set; }\n//        public string Name { get; set; } = string.Empty;\n//        public List<Dictionary<string, object>> Nodes { get; set; }\n\n//        public List<Dictionary<string, object>> Edges { get; set; }\n//        public DateTime CreatedAt { get; set; }\n//        public string? TriggerKeyword { get; set; }\n\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/TemplateDto.cs",
      "sha256": "42ae32842447bb89f8178a8bae3c490d1fe646b526c27cbe72571e23536f7116",
      "language": "csharp",
      "size": 240,
      "content": "namespace xbytechat.api.Features.TemplateMessages.DTOs\n{\n    public class TemplateDto\n    {\n        public Guid Id { get; set; }\n        public string Name { get; set; } = string.Empty;\n        public int Placeholders { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Flows/DTOs/FlowNodeConfigs/AutoReplyEdgeDto.cs",
      "sha256": "5cbac1daff177794f7ae69aabf6b323f279f0b7132dc060e462a91226849f868",
      "language": "csharp",
      "size": 264,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.Flows.DTOs.FlowNodeConfigs\n{\n    public class AutoReplyEdgeDto\n    {\n        public string Id { get; set; }\n        public string SourceNodeId { get; set; }\n        public string TargetNodeId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Flows/DTOs/FlowNodeConfigs/MessageConfig.cs",
      "sha256": "6e7673134b9b3fabb432529dd4b510007ff1d934f016b3a2d831a4503d01c2c7",
      "language": "csharp",
      "size": 201,
      "content": "// MessageConfig.cs\nnamespace xbytechat.api.Features.AutoReplyBuilder.Flows.DTOs.FlowNodeConfigs\n{\n    public class MessageConfig\n    {\n        public string Text { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Flows/DTOs/FlowNodeConfigs/RuntimeConfigs.cs",
      "sha256": "280793d810ae7ce0f016f2671b3627cd52a4029b6ea574d0fee20e0c0e11e5ae",
      "language": "csharp",
      "size": 125,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.Flows.DTOs.FlowNodeConfigs\n{\n    public class RuntimeConfigs\n    {\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Flows/DTOs/FlowNodeConfigs/TagNodeConfig.cs",
      "sha256": "d9fade9fca5845b7cb33279a01288a4dd94a90aaaed58d384a778209656b5ead",
      "language": "csharp",
      "size": 197,
      "content": "// TagConfig.cs\nnamespace xbytechat.api.Features.AutoReplyBuilder.Flows.DTOs.FlowNodeConfigs\n{\n    public class TagNodeConfig\n    {\n        public List<string> Tags { get; set; } = new();\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Flows/DTOs/FlowNodeConfigs/TemplateConfig.cs",
      "sha256": "5c7ea8f78b131705f6bccf1ced0e21a754dadf67bbd6420696995f565c07767a",
      "language": "csharp",
      "size": 682,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.Flows.DTOs.FlowNodeConfigs\n{\n    public class TemplateConfig\n    {\n        public string TemplateName { get; set; } = string.Empty;\n        public List<string> Placeholders { get; set; } = new();\n        public string? Language { get; set; } = \"en_US\";\n        public string? ImageUrl { get; set; }\n        public List<TemplateButtonDto>? MultiButtons { get; set; } = new();\n    }\n\n    public class TemplateButtonDto\n    {\n        public string ButtonText { get; set; } = string.Empty;\n        public string ButtonType { get; set; } = \"url\"; // or \"quick_reply\"\n        public string TargetUrl { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Flows/DTOs/FlowNodeConfigs/WaitConfig.cs",
      "sha256": "afe336952d0d4959422bbbc499884b286291888fcbd64dd068f26013160261c6",
      "language": "csharp",
      "size": 179,
      "content": "// WaitConfig.cs\nnamespace xbytechat.api.Features.AutoReplyBuilder.Flows.DTOs.FlowNodeConfigs\n{\n    public class WaitConfig\n    {\n        public int Seconds { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Flows/Enum/NodeTypes.cs",
      "sha256": "94b210bd5bbbbce823c3a1beb8172eddf708305bfbb8b897d1e3c7ef10097b36",
      "language": "csharp",
      "size": 538,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.Flows.Enum\n{\n    public class NodeTypes\n    {\n        public const string Start = \"start\";\n        public const string Message = \"message\";\n        public const string Template = \"template\";\n        public const string Wait = \"wait\";\n        public const string Tag = \"tag\";\n        public const string Agent = \"agent\";\n        public const string Condition = \"condition\"; // Coming soon\n        public const string Form = \"form\";           // For â€œAsk Nameâ€, â€œAsk Emailâ€\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Models/AutoReplyFlow.cs",
      "sha256": "4010a313f312dd02ea7373389accf18917c52426f75519fa7691d773cb7e60ce",
      "language": "csharp",
      "size": 3631,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Flows.Models\n{\n    public class AutoReplyFlow\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        public Guid BusinessId { get; set; }\n\n        [Required]\n        public string Name { get; set; } = string.Empty;\n\n        [Required]\n        public string NodesJson { get; set; } = string.Empty;\n\n        [Required]\n        public string EdgesJson { get; set; } = string.Empty;\n\n        // Stored in UTC; set on first create\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n        // Nullable; updated on every SaveFlowAsync\n        public DateTime? UpdatedAt { get; set; }\n\n        /// <summary>\n        /// Comma / newline separated trigger keywords, e.g. \"hi, hello\"\n        /// </summary>\n        public string? TriggerKeyword { get; set; }\n\n        public bool IsActive { get; set; } = true;\n\n        // Optional metadata for templates / catalog\n        public string? IndustryTag { get; set; }    // e.g., \"restaurant\", \"clinic\", \"education\"\n        public string? UseCase { get; set; }        // e.g., \"Order Flow\", \"Booking Flow\"\n\n        /// <summary>\n        /// Flag to indicate system-provided template (vs user-created).\n        /// </summary>\n        public bool IsDefaultTemplate { get; set; } = false;\n\n        /// <summary>\n        /// Matching mode for this flow:\n        /// \"Exact\" | \"Word\" | \"StartsWith\" | \"Contains\".\n        /// Default: \"Word\".\n        /// </summary>\n        [MaxLength(32)]\n        public string MatchMode { get; set; } = \"Word\";\n\n        /// <summary>\n        /// Priority for choosing between multiple matching flows.\n        /// Higher value wins.\n        /// Default: 0.\n        /// </summary>\n        public int Priority { get; set; } = 0;\n\n        /// <summary>\n        /// Legacy alias for TriggerKeyword; still populated for older code paths.\n        /// </summary>\n        public string? Keyword { get; set; }\n    }\n}\n\n\n\n\n//using System;\n//using System.ComponentModel.DataAnnotations;\n\n//namespace xbytechat.api.Features.AutoReplyBuilder.Flows.Models\n//{\n//    public class AutoReplyFlow\n//    {\n//        [Key]\n//        public Guid Id { get; set; }\n\n//        public Guid BusinessId { get; set; }\n\n//        [Required]\n//        public string Name { get; set; } = string.Empty;\n\n//        [Required]\n//        public string NodesJson { get; set; } = string.Empty;\n\n//        [Required]\n//        public string EdgesJson { get; set; } = string.Empty;\n\n//        // Stored in UTC; set on first create\n//        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n//        // Nullable; updated on every SaveFlowAsync\n//        public DateTime? UpdatedAt { get; set; }\n\n//        /// <summary>\n//        /// Comma / newline separated trigger keywords, e.g. \"hi, hello\"\n//        /// </summary>\n//        public string? TriggerKeyword { get; set; }\n\n//        public bool IsActive { get; set; } = true;\n\n//        // Optional metadata for templates / catalog\n//        public string? IndustryTag { get; set; }    // e.g., \"restaurant\", \"clinic\", \"education\"\n//        public string? UseCase { get; set; }        // e.g., \"Order Flow\", \"Booking Flow\"\n\n//        /// <summary>\n//        /// Flag to indicate system-provided template (vs user-created).\n//        /// </summary>\n//        public bool IsDefaultTemplate { get; set; } = false;\n\n//        /// <summary>\n//        /// Legacy alias for TriggerKeyword; still populated for older code paths.\n//        /// </summary>\n//        public string? Keyword { get; set; }\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Models/AutoReplyFlowEdge.cs",
      "sha256": "7996bdb8fa1917943e90dad9ad4225984a34b6342eb153028849b30ca63abd7f",
      "language": "csharp",
      "size": 763,
      "content": "using System.ComponentModel.DataAnnotations.Schema;\nusing System.ComponentModel.DataAnnotations;\nusing xbytechat.api.Features.AutoReplyBuilder.Flows.Models;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Models\n{\n    public class AutoReplyFlowEdge\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        [Required]\n        public Guid FlowId { get; set; }\n\n        [ForeignKey(\"FlowId\")]\n        public AutoReplyFlow Flow { get; set; }\n\n        public string SourceNodeId { get; set; } = string.Empty;\n        public string TargetNodeId { get; set; } = string.Empty;\n    \n        public string? SourceHandle { get; set; }\n        public string? TargetHandle { get; set; }\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n    }\n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Models/AutoReplyFlowNode.cs",
      "sha256": "88a50d45fe3b72f6c3bc0593104b7ee549180c842628cb3d9048c5227a025871",
      "language": "csharp",
      "size": 1013,
      "content": "using System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\nusing xbytechat.api.Features.AutoReplyBuilder.Flows.Models;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Models\n{\n    public class AutoReplyFlowNode\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        [Required]\n        public Guid FlowId { get; set; }\n\n        [ForeignKey(\"FlowId\")]\n        public AutoReplyFlow Flow { get; set; }\n\n        // ðŸ”„ Use a constrained string or enum (recommended for future)\n        [Required]\n        public string NodeType { get; set; } = string.Empty;\n\n        public string Label { get; set; } = string.Empty;\n\n        public string? NodeName { get; set; } // ðŸ†• Optional internal label for debugging\n\n        [Required]\n        public string ConfigJson { get; set; } = string.Empty;\n\n        public Position Position { get; set; } = new();\n\n        public int Order { get; set; }\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Models/AutoReplyLog.cs",
      "sha256": "6683278ee0d8c068bb3a8b08629bb11c8b223bb71c9b00f2b1567560ad515d22",
      "language": "csharp",
      "size": 908,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Models\n{\n    [Table(\"AutoReplyLogs\")]\n    public class AutoReplyLog\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        public Guid BusinessId { get; set; }\n        public Guid ContactId { get; set; }\n\n        public string TriggerKeyword { get; set; } = string.Empty; // e.g., \"hi\", \"price\"\n        public string TriggerType { get; set; } = \"flow\";    // \"flow\" or \"rule\"\n\n        public string ReplyContent { get; set; } = string.Empty;    // Plaintext summary of what was sent\n        public string? FlowName { get; set; }                       // Nullable if rule-based\n\n        public Guid? MessageLogId { get; set; }                     // Optional link to MessageLog\n        public DateTime TriggeredAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Models/FlowNode.cs",
      "sha256": "8991ad6277d58a2785f6a93fd8b8ca815af4ce80351d38f30aaf47890909471f",
      "language": "csharp",
      "size": 318,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.Models\n{\n    public class FlowNode\n    {\n        public string Id { get; set; }\n        public string Type { get; set; }\n        public Position Position { get; set; }\n        public Dictionary<string, object> Data { get; set; }  // This should capture config\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Models/FlowRunResult.cs",
      "sha256": "67982580319a635214c13b2ec05cc279d9afc21fdeb1224248a8060036e27f5c",
      "language": "csharp",
      "size": 463,
      "content": "// File: Features/AutoReplyBuilder/Models/FlowRunResult.cs\n\nusing System;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Models\n{\n    /// <summary>\n    /// Encapsulates the result of running a visual flow, including agent handoff status.\n    /// </summary>\n    public class FlowRunResult\n    {\n        public bool NeedsAgent { get; set; } = false;\n\n\n        public Guid? HandoffNodeId { get; set; }\n\n        public string? ContextJson { get; set; }\n\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Models/Position.cs",
      "sha256": "0c352c43f4dfcebdc462622ca0acdcd8c1eaafa07a91a70804793d8c76724201",
      "language": "csharp",
      "size": 176,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.Models\n{\n    public class Position\n    {\n        public double X { get; set; }\n        public double Y { get; set; }\n    }\n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Repositories/AutoReplyFlowRepository.cs",
      "sha256": "d919b1d695c3c29ccc653b806d4884197b3d52fb9eb5f86c0f32f893eb198671",
      "language": "csharp",
      "size": 4350,
      "content": "using Microsoft.EntityFrameworkCore;\nusing xbytechat.api;\nusing xbytechat.api.Features.AutoReplyBuilder.Flows.Models;\nusing xbytechat.api.Features.AutoReplyBuilder.Flows.Repositories;\nusing xbytechat.api.Features.AutoReplyBuilder.Models;\n\npublic class AutoReplyFlowRepository : IAutoReplyFlowRepository\n{\n    private readonly AppDbContext _context;\n    private readonly ILogger<AutoReplyFlowRepository> _logger;\n\n    public AutoReplyFlowRepository(AppDbContext context, ILogger<AutoReplyFlowRepository> logger)\n    {\n        _context = context;\n        _logger = logger;\n    }\n\n    public async Task<AutoReplyFlow> SaveAsync(AutoReplyFlow flow)\n    {\n        _context.AutoReplyFlows.Add(flow);\n        try\n        {\n            await _context.SaveChangesAsync();\n        }\n        catch (DbUpdateException ex)\n        {\n            _logger.LogError(ex, \"âŒ Save failed: {0}\", ex.InnerException?.Message);\n            throw;\n        }\n\n        return flow;\n    }\n\n    public async Task SaveNodesAndEdgesAsync(IEnumerable<AutoReplyFlowNode> nodes, IEnumerable<AutoReplyFlowEdge> edges)\n    {\n        _context.AutoReplyFlowNodes.AddRange(nodes);\n        _context.AutoReplyFlowEdges.AddRange(edges);\n        try\n        {\n            await _context.SaveChangesAsync();\n        }\n        catch (DbUpdateException ex)\n        {\n            _logger.LogError(ex, \"âŒ Save failed: {0}\", ex.InnerException?.Message);\n            throw;\n        }\n\n    }\n\n    public async Task<List<AutoReplyFlow>> GetAllByBusinessIdAsync(Guid businessId)\n    {\n        return await _context.AutoReplyFlows\n            .Where(f => f.BusinessId == businessId)\n            .OrderByDescending(f => f.CreatedAt)\n            .ToListAsync();\n    }\n\n    public async Task<AutoReplyFlow?> GetByIdAsync(Guid flowId, Guid businessId)\n    {\n        return await _context.AutoReplyFlows\n            .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId);\n    }\n\n    public async Task<int> GetFlowCountAsync(Guid businessId)\n    {\n        return await _context.AutoReplyFlows.CountAsync(f => f.BusinessId == businessId);\n    }\n\n    public async Task<bool> RenameFlowAsync(Guid id, string newName)\n    {\n        var flow = await _context.AutoReplyFlows.FindAsync(id);\n        if (flow == null) return false;\n\n        flow.Name = newName;\n        try\n        {\n            await _context.SaveChangesAsync();\n        }\n        catch (DbUpdateException ex)\n        {\n            _logger.LogError(ex, \"âŒ Save failed: {0}\", ex.InnerException?.Message);\n            throw;\n        }\n\n        return true;\n    }\n\n    public async Task<bool> DeleteFlowAsync(Guid id, Guid businessId)\n    {\n        var flow = await _context.AutoReplyFlows\n            .FirstOrDefaultAsync(f => f.Id == id && f.BusinessId == businessId);\n\n        if (flow == null) return false;\n\n        _context.AutoReplyFlows.Remove(flow);\n        try\n        {\n            await _context.SaveChangesAsync();\n        }\n        catch (DbUpdateException ex)\n        {\n            _logger.LogError(ex, \"âŒ Save failed: {0}\", ex.InnerException?.Message);\n            throw;\n        }\n\n        return true;\n    }\n    public async Task<List<AutoReplyFlowNode>> GetNodesByFlowIdAsync(Guid flowId)\n    {\n        return await _context.AutoReplyFlowNodes\n            .Where(n => n.FlowId == flowId)\n            .ToListAsync();\n    }\n\n    public async Task<List<AutoReplyFlowEdge>> GetEdgesByFlowIdAsync(Guid flowId)\n    {\n        return await _context.AutoReplyFlowEdges\n            .Where(e => e.FlowId == flowId)\n            .ToListAsync();\n    }\n    public async Task<AutoReplyFlow?> FindFlowByKeywordAsync(Guid businessId, string keyword)\n    {\n        return await _context.AutoReplyFlows\n            .Where(f => f.BusinessId == businessId && f.IsActive && f.TriggerKeyword == keyword)\n            .OrderByDescending(f => f.CreatedAt)\n            .FirstOrDefaultAsync();\n    }\n    public async Task<List<AutoReplyFlowNode>> GetStructuredNodesAsync(Guid flowId)\n    {\n        return await _context.AutoReplyFlowNodes\n            .Where(n => n.FlowId == flowId)\n            .ToListAsync();\n    }\n\n    public async Task<List<AutoReplyFlowEdge>> GetStructuredEdgesAsync(Guid flowId)\n    {\n        return await _context.AutoReplyFlowEdges\n            .Where(e => e.FlowId == flowId)\n            .ToListAsync();\n    }\n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Repositories/AutoReplyLogRepository.cs",
      "sha256": "4a8777aecfb95fef141063dfa3475992a3848fdd582209819e66ab552d045f71",
      "language": "csharp",
      "size": 1569,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.AutoReplyBuilder.DTOs;\nusing xbytechat.api.Models;\nusing xbytechat.api.Shared;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.AutoReplyBuilder.Models;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Repositories\n{\n    public class AutoReplyLogRepository : IAutoReplyLogRepository\n    {\n        private readonly AppDbContext _context;\n        private readonly ILogger<AutoReplyLogRepository> _logger;\n\n        public AutoReplyLogRepository(AppDbContext context, ILogger<AutoReplyLogRepository> logger)\n        {\n            _context = context;\n            _logger = logger;\n        }\n\n        public async Task SaveAsync(AutoReplyLogDto dto)\n        {\n            try\n            {\n                var log = new AutoReplyLog\n                {\n                    Id = dto.Id,\n                    BusinessId = dto.BusinessId,\n                    ContactId = dto.ContactId,\n                    TriggerKeyword = dto.TriggerKeyword,\n                    TriggerType = dto.TriggerType,\n                    ReplyContent = dto.ReplyContent,\n                    TriggeredAt = dto.TriggeredAt,\n                    FlowName = dto.FlowName,\n                    MessageLogId = dto.MessageLogId\n                };\n\n                _context.AutoReplyLogs.Add(log);\n                await _context.SaveChangesAsync();\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"âŒ Failed to save AutoReplyLog\");\n                throw;\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Repositories/IAutoReplyFlowRepository.cs",
      "sha256": "f78ae431c2892c49cc0844c2f19e5df301598c964326722b3ca52aec7e9ba61d",
      "language": "csharp",
      "size": 1161,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.AutoReplyBuilder.Flows.Models;\nusing xbytechat.api.Features.AutoReplyBuilder.Models;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Flows.Repositories\n{\n    public interface IAutoReplyFlowRepository\n    {\n        Task<AutoReplyFlow> SaveAsync(AutoReplyFlow flow);\n        Task<AutoReplyFlow?> GetByIdAsync(Guid flowId, Guid businessId);\n        Task<List<AutoReplyFlow>> GetAllByBusinessIdAsync(Guid businessId);\n        Task<int> GetFlowCountAsync(Guid businessId);\n        Task<bool> RenameFlowAsync(Guid id, string newName);\n        Task<bool> DeleteFlowAsync(Guid id, Guid businessId);\n        Task SaveNodesAndEdgesAsync(IEnumerable<AutoReplyFlowNode> nodes, IEnumerable<AutoReplyFlowEdge> edges);\n        Task<List<AutoReplyFlowNode>> GetNodesByFlowIdAsync(Guid flowId);\n        Task<List<AutoReplyFlowEdge>> GetEdgesByFlowIdAsync(Guid flowId);\n        Task<AutoReplyFlow?> FindFlowByKeywordAsync(Guid businessId, string keyword);\n        Task<List<AutoReplyFlowNode>> GetStructuredNodesAsync(Guid flowId);\n        Task<List<AutoReplyFlowEdge>> GetStructuredEdgesAsync(Guid flowId);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Repositories/IAutoReplyLogRepository.cs",
      "sha256": "49f1ecf8c4ab7bb6a0122d7d98e22eb4cb6e2b4b522c99c3963ca64d57889264",
      "language": "csharp",
      "size": 255,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.AutoReplyBuilder.DTOs;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Repositories\n{\n    public interface IAutoReplyLogRepository\n    {\n        Task SaveAsync(AutoReplyLogDto logDto);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Services/AutoReplyFlowService.cs",
      "sha256": "2145c395e2e5488a5f0e21d854bba3ab8c61fc831b8369e19789c390c8f6d5ef",
      "language": "csharp",
      "size": 9422,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api;\nusing xbytechat.api.Features.AutoReplyBuilder.DTOs;\nusing xbytechat.api.Features.AutoReplyBuilder.Flows.Models;\nusing xbytechat.api.Features.AutoReplyBuilder.Models;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Services\n{\n    /// <summary>\n    /// Minimal CRUD service for the Auto-Reply flow builder.\n    /// Keeps one flow -> many nodes persisted in PostgreSQL.\n    /// </summary>\n    public class AutoReplyFlowService : IAutoReplyFlowService\n    {\n        private readonly AppDbContext _db;\n        private readonly ILogger<AutoReplyFlowService> _log;\n\n        public AutoReplyFlowService(AppDbContext db, ILogger<AutoReplyFlowService> log)\n        {\n            _db = db;\n            _log = log;\n        }\n\n        public async Task<IReadOnlyList<AutoReplyFlowSummaryDto>> GetFlowsForBusinessAsync(Guid businessId, CancellationToken ct = default)\n        {\n            return await _db.AutoReplyFlows\n                .AsNoTracking()\n                .Where(f => f.BusinessId == businessId)\n                .OrderByDescending(f => f.CreatedAt)\n                .Select(f => new AutoReplyFlowSummaryDto\n                {\n                    Id = f.Id,\n                    Name = f.Name,\n                    IsActive = f.IsActive,\n                    TriggerKeyword = f.TriggerKeyword,\n                    CreatedAt = f.CreatedAt,\n                    UpdatedAt = f.UpdatedAt // entity does not currently track updates\n                })\n                .ToListAsync(ct);\n        }\n\n        public async Task<AutoReplyFlowDto?> GetFlowAsync(Guid businessId, Guid flowId, CancellationToken ct = default)\n        {\n            var flow = await _db.AutoReplyFlows\n                .AsNoTracking()\n                .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId, ct);\n\n            if (flow == null)\n            {\n                return null;\n            }\n\n            var nodes = await _db.AutoReplyNodes\n                .AsNoTracking()\n                .Where(n => n.FlowId == flowId)\n                .OrderBy(n => n.Order)\n                .ThenBy(n => n.CreatedAt)\n                .ToListAsync(ct);\n\n            return MapToDto(flow, nodes);\n        }\n\n        public async Task<AutoReplyFlowDto> SaveFlowAsync(\n        Guid businessId,\n        AutoReplyFlowDto dto,\n        CancellationToken ct = default)\n        {\n            if (dto == null) throw new ArgumentNullException(nameof(dto));\n            if (string.IsNullOrWhiteSpace(dto.Name))\n                throw new ArgumentException(\"Name is required\", nameof(dto));\n\n            _log.LogInformation(\n                \"[AutoReplyFlow] SaveFlowAsync biz={BusinessId} flow={FlowName}\",\n                businessId,\n                dto.Name);\n\n            var flow = dto.Id.HasValue\n                ? await _db.AutoReplyFlows.FirstOrDefaultAsync(\n                    f => f.Id == dto.Id.Value && f.BusinessId == businessId,\n                    ct)\n                : null;\n\n            var isNew = flow == null;\n            if (isNew)\n            {\n                flow = new AutoReplyFlow\n                {\n                    Id = dto.Id ?? Guid.NewGuid(),\n                    BusinessId = businessId,\n                    CreatedAt = DateTime.UtcNow,\n                };\n                _db.AutoReplyFlows.Add(flow);\n            }\n\n            // ðŸ”§ Core fields\n            flow.Name = dto.Name.Trim();\n            flow.TriggerKeyword = dto.TriggerKeyword?.Trim();\n            flow.Keyword = dto.TriggerKeyword?.Trim(); // legacy alias used elsewhere\n            flow.IsActive = dto.IsActive;\n            flow.IndustryTag = dto.IndustryTag;\n            flow.UseCase = dto.UseCase;\n            flow.IsDefaultTemplate = dto.IsDefaultTemplate;\n\n            // ðŸ•’ Always stamp \"last updated\"\n            flow.UpdatedAt = DateTime.UtcNow;\n\n            // Ensure required JSON columns never stay null (legacy storage)\n            flow.NodesJson = string.IsNullOrWhiteSpace(flow.NodesJson) ? \"[]\" : flow.NodesJson;\n            flow.EdgesJson = string.IsNullOrWhiteSpace(flow.EdgesJson) ? \"[]\" : flow.EdgesJson;\n\n            // Replace nodes wholesale for now (simple + safe for MVP)\n            var existingNodes = await _db.AutoReplyNodes\n                .Where(n => n.FlowId == flow.Id)\n                .ToListAsync(ct);\n\n            if (existingNodes.Count > 0)\n            {\n                _db.AutoReplyNodes.RemoveRange(existingNodes);\n            }\n\n            var incomingNodes = dto.Nodes ?? new List<AutoReplyNodeDto>();\n\n            var newNodes = incomingNodes.Select((n, index) => new AutoReplyFlowNode\n            {\n                Id = n.Id == null || n.Id == Guid.Empty ? Guid.NewGuid() : n.Id.Value,\n                FlowId = flow.Id,\n                NodeType = n.NodeType,\n                Label = n.Label ?? string.Empty,\n                NodeName = string.IsNullOrWhiteSpace(n.NodeName) ? n.Label : n.NodeName,\n                ConfigJson = string.IsNullOrWhiteSpace(n.ConfigJson) ? \"{}\" : n.ConfigJson,\n                Position = new Position\n                {\n                    X = n.PositionX,\n                    Y = n.PositionY\n                },\n                Order = n.Order != 0 ? n.Order : index,\n                CreatedAt = DateTime.UtcNow\n            }).ToList();\n\n            if (newNodes.Count > 0)\n            {\n                _db.AutoReplyNodes.AddRange(newNodes);\n\n                // ðŸ” Keep NodesJson in sync with the rows (only fields runtime cares about)\n                var nodesJsonPayload = newNodes\n                    .Select(n => new\n                    {\n                        Id = (Guid?)n.Id,\n                        NodeType = n.NodeType,\n                        NodeName = n.NodeName,\n                        ConfigJson = n.ConfigJson,\n                        Order = n.Order\n                    })\n                    .ToList();\n\n                flow.NodesJson = System.Text.Json.JsonSerializer.Serialize(nodesJsonPayload);\n            }\n            else\n            {\n                flow.NodesJson = \"[]\";\n            }\n\n            await _db.SaveChangesAsync(ct);\n\n            return MapToDto(flow, newNodes);\n        }\n\n\n\n        public async Task DeleteFlowAsync(Guid businessId, Guid flowId, CancellationToken ct = default)\n        {\n            var flow = await _db.AutoReplyFlows.FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId, ct);\n            if (flow == null)\n            {\n                _log.LogInformation(\"[AutoReplyFlow] Delete skipped - not found biz={BusinessId} flowId={FlowId}\", businessId, flowId);\n                return;\n            }\n\n            _db.AutoReplyFlows.Remove(flow); // nodes cascade via FK\n            await _db.SaveChangesAsync(ct);\n            _log.LogInformation(\"[AutoReplyFlow] Deleted biz={BusinessId} flowId={FlowId}\", businessId, flowId);\n        }\n        public async Task SetActiveAsync(\n    Guid businessId,\n    Guid flowId,\n    bool isActive,\n    CancellationToken ct = default)\n        {\n            var flow = await _db.AutoReplyFlows\n                .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId, ct);\n\n            if (flow == null)\n            {\n                _log.LogWarning(\n                    \"[AutoReplyFlow] SetActiveAsync: flow not found. Biz={BusinessId}, Flow={FlowId}\",\n                    businessId,\n                    flowId);\n                return;\n            }\n\n            if (flow.IsActive == isActive)\n            {\n                _log.LogDebug(\n                    \"[AutoReplyFlow] SetActiveAsync: no-op, already IsActive={IsActive}. Biz={BusinessId}, Flow={FlowId}\",\n                    isActive,\n                    businessId,\n                    flowId);\n                return;\n            }\n\n            flow.IsActive = isActive;\n            flow.UpdatedAt = DateTime.UtcNow;\n\n            await _db.SaveChangesAsync(ct);\n\n            _log.LogInformation(\n                \"[AutoReplyFlow] SetActiveAsync: updated IsActive={IsActive}. Biz={BusinessId}, Flow={FlowId}\",\n                isActive,\n                businessId,\n                flowId);\n        }\n\n        private static AutoReplyFlowDto MapToDto(\n     AutoReplyFlow flow,\n     IReadOnlyCollection<AutoReplyFlowNode> nodes)\n        {\n            return new AutoReplyFlowDto\n            {\n                Id = flow.Id,\n                Name = flow.Name,\n                IsActive = flow.IsActive,\n                TriggerKeyword = flow.TriggerKeyword ?? flow.Keyword,\n                IndustryTag = flow.IndustryTag,\n                UseCase = flow.UseCase,\n                IsDefaultTemplate = flow.IsDefaultTemplate,\n                CreatedAt = flow.CreatedAt,\n                UpdatedAt = flow.UpdatedAt,\n                Nodes = nodes.Select(n => new AutoReplyNodeDto\n                {\n                    Id = n.Id,\n                    NodeType = n.NodeType,\n                    Label = n.Label,\n                    NodeName = n.NodeName,\n                    ConfigJson = n.ConfigJson,\n                    PositionX = n.Position?.X ?? 0,\n                    PositionY = n.Position?.Y ?? 0,\n                    Order = n.Order\n                }).ToList()\n            };\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Services/AutoReplyLogService.cs",
      "sha256": "62ff3476179f2420bd95eb00c54f7ad8a33f2600eac49979f8a8e0886d429e43",
      "language": "csharp",
      "size": 4764,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api;\nusing xbytechat.api.Features.AutoReplyBuilder.DTOs;\nusing xbytechat.api.Features.AutoReplyBuilder.Models;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Services\n{\n    /// <summary>\n    /// Query-only service for reading AutoReplyLogs for analytics / UI.\n    /// </summary>\n    public sealed class AutoReplyLogService : IAutoReplyLogService\n    {\n        private readonly AppDbContext _dbContext;\n        private readonly ILogger<AutoReplyLogService> _logger;\n\n        public AutoReplyLogService(\n            AppDbContext dbContext,\n            ILogger<AutoReplyLogService> logger)\n        {\n            _dbContext = dbContext;\n            _logger = logger;\n        }\n\n        public async Task<IReadOnlyList<AutoReplyLogSummaryDto>> GetRecentAsync(\n            Guid businessId,\n            int take,\n            CancellationToken cancellationToken = default)\n        {\n            if (businessId == Guid.Empty)\n            {\n                return Array.Empty<AutoReplyLogSummaryDto>();\n            }\n\n            // Clamp \"take\" to safe range\n            if (take <= 0) take = 20;\n            if (take > 100) take = 100;\n\n            _logger.LogDebug(\n                \"Fetching {Take} recent AutoReplyLogs for BusinessId={BusinessId}\",\n                take, businessId);\n\n            var query = _dbContext.Set<AutoReplyLog>()\n                .AsNoTracking()\n                .Where(x => x.BusinessId == businessId)\n                .OrderByDescending(x => x.TriggeredAt)\n                .Take(take);\n\n            var items = await query\n                .Select(x => new AutoReplyLogSummaryDto\n                {\n                    Id = x.Id,\n                    TriggerType = x.TriggerType,\n                    TriggerKeyword = x.TriggerKeyword,\n                    FlowName = x.FlowName,\n                    ReplyContent = x.ReplyContent,\n                    ContactId = x.ContactId,\n                    MessageLogId = x.MessageLogId,\n                    TriggeredAt = x.TriggeredAt\n                })\n                .ToListAsync(cancellationToken);\n\n            return items;\n        }\n    }\n}\n\n\n//using System;\n//using System.Collections.Generic;\n//using System.Linq;\n//using System.Threading;\n//using System.Threading.Tasks;\n//using Microsoft.EntityFrameworkCore;\n//using Microsoft.Extensions.Logging;\n//using xbytechat.api;\n//using xbytechat.api.Features.AutoReplyBuilder.DTOs;\n//using xbytechat.api.Features.AutoReplyBuilder.Models;\n\n//namespace xbytechat.api.Features.AutoReplyBuilder.Services\n//{\n//    /// <summary>\n//    /// Query-only service for reading AutoReplyLogs for analytics / UI.\n//    /// </summary>\n//    public sealed class AutoReplyLogService : IAutoReplyLogService\n//    {\n//        private readonly AppDbContext _dbContext;\n//        private readonly ILogger<AutoReplyLogService> _logger;\n\n//        public AutoReplyLogService(\n//            AppDbContext dbContext,\n//            ILogger<AutoReplyLogService> logger)\n//        {\n//            _dbContext = dbContext;\n//            _logger = logger;\n//        }\n\n//        public async Task<IReadOnlyList<AutoReplyLogSummaryDto>> GetRecentAsync(\n//            Guid businessId,\n//            int take,\n//            CancellationToken cancellationToken = default)\n//        {\n//            if (businessId == Guid.Empty)\n//            {\n//                return Array.Empty<AutoReplyLogSummaryDto>();\n//            }\n\n//            // clamp \"take\" to a safe range\n//            if (take <= 0) take = 20;\n//            if (take > 100) take = 100;\n\n//            _logger.LogDebug(\n//                \"Fetching {Take} recent AutoReplyLogs for BusinessId={BusinessId}\",\n//                take, businessId);\n\n//            var query = _dbContext.Set<AutoReplyLog>()\n//                .AsNoTracking()\n//                .Where(x => x.BusinessId == businessId)\n//                .OrderByDescending(x => x.TriggeredAt)\n//                .Take(take);\n\n//            var items = await query\n//                .Select(x => new AutoReplyLogSummaryDto\n//                {\n//                    Id = x.Id,\n//                    TriggerType = x.TriggerType,\n//                    TriggerKeyword = x.TriggerKeyword,\n//                    FlowName = x.FlowName,\n//                    ReplyContent = x.ReplyContent,\n//                    ContactId = x.ContactId,\n//                    MessageLogId = x.MessageLogId,\n//                    TriggeredAt = x.TriggeredAt\n//                })\n//                .ToListAsync(cancellationToken);\n\n//            return items;\n//        }\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Services/AutoReplyRuntimeResult.cs",
      "sha256": "73f400851fbb9d03de3a8766167d5fff0a8f423760ac0a9e1f73c549d712987d",
      "language": "csharp",
      "size": 3973,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Services\n{\n    /// <summary>\n    /// Result of trying to handle an incoming message via AutoReply.\n    /// This is used by the webhook and by the test-match endpoint.\n    /// </summary>\n    public class AutoReplyRuntimeResult\n    {\n        /// <summary>\n        /// True if this incoming message was handled by AutoReply logic\n        /// (either by sending a simple reply or starting a CTA flow).\n        /// </summary>\n        public bool Handled { get; set; }\n\n        /// <summary>\n        /// True if we sent an immediate/simple reply (text/template) as part of handling.\n        /// </summary>\n        public bool SentSimpleReply { get; set; }\n\n        /// <summary>\n        /// True if, instead of only replying once, we started a CTA flow journey.\n        /// </summary>\n        public bool StartedCtaFlow { get; set; }\n\n        /// <summary>\n        /// The AutoReply flow/rule that matched (if any).\n        /// </summary>\n        public Guid? AutoReplyFlowId { get; set; }\n\n        /// <summary>\n        /// If a CTA flow was started, this is the CTAFlowConfig.Id that was kicked off.\n        /// </summary>\n        public Guid? CtaFlowConfigId { get; set; }\n\n        /// <summary>\n        /// The keyword or pattern that matched, for debugging/analytics.\n        /// </summary>\n        public string? MatchedKeyword { get; set; }\n\n        /// <summary>\n        /// Optional notes for logging / debugging (e.g. why nothing matched).\n        /// </summary>\n        public string? Notes { get; set; }\n\n        /// <summary>\n        /// (Test-mode only) Type of the first action node we plan to execute\n        /// in the matched flow (e.g. \"message\", \"wait\", \"set-tag\").\n        /// </summary>\n        public string? StartNodeType { get; set; }\n\n        /// <summary>\n        /// (Test-mode only) Display name of the first action node.\n        /// </summary>\n        public string? StartNodeName { get; set; }\n\n        // ---- Helper factories ----\n\n        public static AutoReplyRuntimeResult NotHandled(string? notes = null) =>\n            new AutoReplyRuntimeResult\n            {\n                Handled = false,\n                SentSimpleReply = false,\n                StartedCtaFlow = false,\n                Notes = notes,\n                AutoReplyFlowId = null,\n                CtaFlowConfigId = null,\n                MatchedKeyword = null,\n                StartNodeType = null,\n                StartNodeName = null\n            };\n\n        public static AutoReplyRuntimeResult SimpleReply(\n            Guid? autoReplyFlowId,\n            string? matchedKeyword = null,\n            string? notes = null,\n            string? startNodeType = null,\n            string? startNodeName = null) =>\n            new AutoReplyRuntimeResult\n            {\n                Handled = true,\n                SentSimpleReply = true,\n                StartedCtaFlow = false,\n                AutoReplyFlowId = autoReplyFlowId,\n                CtaFlowConfigId = null,\n                MatchedKeyword = matchedKeyword,\n                Notes = notes,\n                StartNodeType = startNodeType,\n                StartNodeName = startNodeName\n            };\n\n        public static AutoReplyRuntimeResult CtaFlowStarted(\n            Guid? autoReplyFlowId,\n            Guid? ctaFlowConfigId,\n            string? matchedKeyword = null,\n            string? notes = null,\n            string? startNodeType = null,\n            string? startNodeName = null) =>\n            new AutoReplyRuntimeResult\n            {\n                Handled = true,\n                SentSimpleReply = false,\n                StartedCtaFlow = true,\n                AutoReplyFlowId = autoReplyFlowId,\n                CtaFlowConfigId = ctaFlowConfigId,\n                MatchedKeyword = matchedKeyword,\n                Notes = notes,\n                StartNodeType = startNodeType,\n                StartNodeName = startNodeName\n            };\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Services/AutoReplyRuntimeService.cs",
      "sha256": "e7aaf46068445af40428a9b4b0fa24baa3435b6a4c61ae546558e81d0767cd85",
      "language": "csharp",
      "size": 70536,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api;\nusing xbytechat.api.Features.AutoReplyBuilder.DTOs;\nusing xbytechat.api.Features.AutoReplyBuilder.Flows.Models;\nusing xbytechat.api.Features.AutoReplyBuilder.Models;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.CTAFlowBuilder.Services;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\nusing System.Text.Json.Serialization;\nusing xbytechat.api.Features.MessagesEngine.Enums;\nusing xbytechat.api.AuthModule.Models;\nusing xbytechat.api.Features.CRM.Models;\nusing xbytechat.api.WhatsAppSettings.DTOs;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Services\n{\n    /// <summary>\n    /// Default implementation of the AutoReply runtime engine.\n    ///\n    /// Responsibilities:\n    /// - Match inbound text against AutoReplyFlow.TriggerKeyword (builder flows).\n    /// - Provide:\n    ///     * Test-only matching for the AutoReplyBuilder UI (no sending).\n    ///     * Runtime matching for the WhatsApp webhook (executes multi-step flows).\n    ///     * Legacy DTO-based matching for existing APIs (FindMatchAsync).\n    /// - For builder flows, can inspect NodesJson and execute \"message\" / \"template\" /\n    ///   \"tag\" / \"wait\" nodes in order (simple linear runner for now).\n    /// </summary>\n    public sealed class AutoReplyRuntimeService : IAutoReplyRuntimeService\n    {\n        private readonly AppDbContext _dbContext;\n        private readonly IMessageEngineService _messageEngine;\n        private readonly ILogger<AutoReplyRuntimeService> _logger;\n        private readonly IFlowExecutionLogger _flowExecutionLogger;\n        private readonly ICtaFlowRuntimeService _ctaFlowRuntime;\n\n        public AutoReplyRuntimeService(\n            AppDbContext dbContext,\n            IMessageEngineService messageEngine,\n            ILogger<AutoReplyRuntimeService> logger,\n            IFlowExecutionLogger flowExecutionLogger,\n            ICtaFlowRuntimeService ctaFlowRuntime)\n        {\n            _dbContext = dbContext;\n            _messageEngine = messageEngine;\n            _logger = logger;\n            _flowExecutionLogger = flowExecutionLogger;\n            _ctaFlowRuntime = ctaFlowRuntime;\n        }\n\n        // ----------------------------------------------------\n        // 1) Runtime â€“ used by the webhook\n        // ----------------------------------------------------\n\n        public async Task<AutoReplyRuntimeResult> TryHandleAsync(\n            Guid businessId,\n            Guid contactId,\n            string contactPhone,\n            string incomingText,\n            CancellationToken cancellationToken = default)\n        {\n            var text = (incomingText ?? string.Empty).Trim();\n\n            if (businessId == Guid.Empty || string.IsNullOrWhiteSpace(text))\n            {\n                return AutoReplyRuntimeResult.NotHandled(\n                    \"BusinessId was empty or incoming text was blank (runtime).\");\n            }\n\n            _logger.LogInformation(\n                \"ðŸ¤– AutoReplyRuntime invoked (runtime) for Business={BusinessId}, Contact={ContactId}, Phone={Phone}, Text={Text}\",\n                businessId,\n                contactId,\n                contactPhone,\n                text);\n\n            // Reuse the canonical matching logic (builder flows only)\n            var matchResult = await TestMatchAsync(businessId, text, cancellationToken);\n\n            // â›” Only short-circuit when we have NO builder flow id at all.\n            // If AutoReplyFlowId is present, we still try to execute the flow\n            // even if Handled == false.\n            if (!matchResult.Handled && !matchResult.AutoReplyFlowId.HasValue)\n            {\n                _logger.LogDebug(\n                    \"ðŸ‘‚ AutoReplyRuntime (runtime) found no matching visual flow for Business={BusinessId}\",\n                    businessId);\n\n                return matchResult;\n            }\n\n            _logger.LogInformation(\n                \"ðŸ¤– AutoReplyRuntime (runtime) matched flow {FlowId} with keyword '{Keyword}'. Notes: {Notes}\",\n                matchResult.AutoReplyFlowId ?? matchResult.CtaFlowConfigId,\n                matchResult.MatchedKeyword,\n                matchResult.Notes);\n\n            // New behaviour: execute the full visual builder flow as a linear sequence.\n            if (matchResult.AutoReplyFlowId.HasValue)\n            {\n                var flowId = matchResult.AutoReplyFlowId.Value;\n\n                var flow = await _dbContext.Set<AutoReplyFlow>()\n                    .AsNoTracking()\n                    .FirstOrDefaultAsync(\n                        f => f.Id == flowId && f.BusinessId == businessId,\n                        cancellationToken);\n\n                if (flow == null)\n                {\n                    _logger.LogWarning(\n                        \"AutoReplyRuntime matched flow id {FlowId} but could not reload AutoReplyFlow from DB.\",\n                        flowId);\n\n                    matchResult.SentSimpleReply = false;\n                    // Keep original Handled flag; webhook can decide what to do.\n                    return matchResult;\n                }\n\n                // Extra visibility for debugging\n                var matchMode = string.IsNullOrWhiteSpace(flow.MatchMode) ? \"Word\" : flow.MatchMode;\n                _logger.LogInformation(\n                    \"ðŸ¤– AutoReplyRuntime (runtime) executing flow {FlowId} '{FlowName}' for Business={BusinessId}, Contact={ContactId}. Mode={MatchMode}, Priority={Priority}, Keyword='{Keyword}'\",\n                    flow.Id,\n                    flow.Name,\n                    businessId,\n                    contactId,\n                    matchMode,\n                    flow.Priority,\n                    matchResult.MatchedKeyword);\n\n                var outcome = await ExecuteFlowLinearAsync(\n                    flow,\n                    businessId,\n                    contactId,\n                    contactPhone,\n                    cancellationToken);\n\n                // Mark as â€œwe respondedâ€ only if at least one step sent something.\n                matchResult.SentSimpleReply = outcome.AnySent;\n                if (outcome.AnySent)\n                {\n                    // Force Handled = true so webhook does NOT fall back\n                    // to the legacy AutomationService greeting.\n                    matchResult.Handled = true;\n                }\n\n                if (!outcome.AnySent)\n                {\n                    _logger.LogWarning(\n                        \"AutoReplyRuntime executed flow {FlowId} for Business={BusinessId} but no messages/templates were sent.\",\n                        flowId,\n                        businessId);\n\n                    return matchResult;\n                }\n\n                _logger.LogInformation(\n                    \"âœ… AutoReplyRuntime executed flow {FlowId} for Business={BusinessId}, Contact={ContactId}. Summary={Summary}\",\n                    flowId,\n                    businessId,\n                    contactId,\n                    outcome.Summary ?? \"(no summary)\");\n\n                // ðŸ“ Always log the trigger (match + executed steps)\n                await LogAutoReplyAsync(\n                    businessId,\n                    contactId,\n                    matchResult.MatchedKeyword,\n                    flow,\n                    outcome.Summary,\n                    messageLogId: null, // we can wire a real MessageLogId later\n                    ct: cancellationToken);\n\n                return matchResult;\n            }\n\n            // In future we can support direct CTA-flow start via matchResult.CtaFlowConfigId.\n            return matchResult;\n        }\n\n\n        // ----------------------------------------------------\n        // 2) Test mode â€“ used by AutoReplyBuilder \"Test Match\"\n        // ----------------------------------------------------\n        public async Task<AutoReplyRuntimeResult> TestMatchAsync(\n            Guid businessId,\n            string incomingText,\n            CancellationToken cancellationToken = default)\n        {\n            var text = (incomingText ?? string.Empty).Trim();\n\n            if (businessId == Guid.Empty || string.IsNullOrWhiteSpace(text))\n            {\n                return AutoReplyRuntimeResult.NotHandled(\n                    \"BusinessId was empty or incoming text was blank (test).\");\n            }\n\n            _logger.LogDebug(\n                \"ðŸ§ª AutoReplyRuntime test-match for Business={BusinessId}, Text={Text}\",\n                businessId,\n                text);\n\n            var normalizedText = text.ToLowerInvariant();\n            var incomingWords = SplitIntoWords(normalizedText);\n\n            // 2.1) Builder flows (new AutoReplyBuilder)\n            var flows = await _dbContext.Set<AutoReplyFlow>()\n                .AsNoTracking()\n                .Where(f =>\n                    f.BusinessId == businessId &&\n                    f.IsActive &&\n                    !string.IsNullOrWhiteSpace(f.TriggerKeyword))\n                .OrderBy(f => f.Name)\n                .ThenBy(f => f.Id)\n                .ToListAsync(cancellationToken);\n\n            var candidates = new List<FlowMatchCandidate>();\n\n            foreach (var flow in flows)\n            {\n                var triggerField = flow.TriggerKeyword ?? string.Empty;\n\n                // Support comma / newline separated triggers\n                var keywords = triggerField\n                    .Split(new[] { ',', '\\n', '\\r' }, StringSplitOptions.RemoveEmptyEntries)\n                    .Select(k => k.Trim())\n                    .Where(k => !string.IsNullOrWhiteSpace(k))\n                    .ToList();\n\n                if (keywords.Count == 0)\n                    continue;\n\n                var rawMatchMode = string.IsNullOrWhiteSpace(flow.MatchMode)\n                    ? \"Word\"\n                    : flow.MatchMode.Trim();\n\n                var matchMode = rawMatchMode.ToUpperInvariant();\n\n                foreach (var kw in keywords)\n                {\n                    var normalizedKeyword = kw.ToLowerInvariant();\n\n                    if (IsKeywordMatch(\n                            normalizedKeyword,\n                            normalizedText,\n                            matchMode,\n                            incomingWords))\n                    {\n                        candidates.Add(new FlowMatchCandidate\n                        {\n                            Flow = flow,\n                            Keyword = kw,\n                            MatchMode = matchMode,\n                            Priority = flow.Priority,\n                            KeywordLength = normalizedKeyword.Length\n                        });\n                    }\n                }\n            }\n\n            if (candidates.Count == 0)\n            {\n                // âœ… No legacy rule fallback anymore: if no flow matches, we just say \"not handled\".\n                return AutoReplyRuntimeResult.NotHandled(\n                    \"No AutoReply flow matched the incoming text.\");\n            }\n\n            // ðŸŽ¯ Big-player style selection:\n            // 1) Highest Priority\n            // 2) Longest keyword (more specific)\n            // 3) Newest flow (CreatedAt)\n            // 4) Stable by Id\n            var winner = candidates\n                .OrderByDescending(c => c.Priority)\n                .ThenByDescending(c => c.KeywordLength)\n                .ThenByDescending(c => c.Flow.CreatedAt)\n                .ThenBy(c => c.Flow.Id)\n                .First();\n\n            var matchedFlow = winner.Flow;\n            var matchedKeyword = winner.Keyword;\n\n            var startSummary = GetFirstActionNodeSummary(matchedFlow);\n\n            var note =\n                $\"Matched flow '{matchedFlow.Name}' ({matchedFlow.Id}) by trigger '{matchedKeyword}'. \" +\n                $\"Mode={winner.MatchMode}, Priority={winner.Priority}, Candidates={candidates.Count}.\";\n\n            _logger.LogInformation(\n                \"ðŸ§ª AutoReplyRuntime (test) matched winner flow {FlowId} '{FlowName}' with keyword '{Keyword}'. Mode={MatchMode}, Priority={Priority}, Candidates={CandidateCount}.\",\n                matchedFlow.Id,\n                matchedFlow.Name,\n                matchedKeyword,\n                winner.MatchMode,\n                winner.Priority,\n                candidates.Count);\n\n            // Still treat as \"simple reply\" from the point of view of the test API,\n            // even though runtime now executes multi-step flows.\n            return AutoReplyRuntimeResult.SimpleReply(\n                autoReplyFlowId: matchedFlow.Id,\n                matchedKeyword: matchedKeyword,\n                notes: note,\n                startNodeType: startSummary?.NodeType,\n                startNodeName: startSummary?.NodeName\n            );\n        }\n\n        // ----------------------------------------------------\n        // 3) Legacy DTO adapter â€“ for existing APIs\n        // ----------------------------------------------------\n        public async Task<AutoReplyMatchResultDto> FindMatchAsync(\n            AutoReplyMatchRequestDto request,\n            CancellationToken cancellationToken = default)\n        {\n            var runtimeResult = await TestMatchAsync(\n                request.BusinessId,\n                request.IncomingText,\n                cancellationToken);\n\n            if (!runtimeResult.Handled)\n            {\n                // Back-compat: previously returned IsMatch=false with everything else null.\n                return new AutoReplyMatchResultDto\n                {\n                    IsMatch = false\n                };\n            }\n\n            var dto = new AutoReplyMatchResultDto\n            {\n                IsMatch = true,\n                FlowId = runtimeResult.AutoReplyFlowId ?? runtimeResult.CtaFlowConfigId,\n                FlowName = null, // TODO: surface flow name once we propagate it from flow entity.\n                MatchedKeyword = runtimeResult.MatchedKeyword,\n                MatchType = runtimeResult.StartedCtaFlow ? \"CTA_FLOW\" : \"SIMPLE_REPLY\",\n                StartNodeId = null,\n                StartNodeType = null,\n                StartNodeConfigJson = null\n            };\n\n            return dto;\n        }\n\n        // ----------------------------------------------------\n        // 4) Multi-step flow execution (builder flows)\n        // ----------------------------------------------------\n\n        /// <summary>\n        /// Represents the outcome of executing a visual AutoReply flow.\n        /// </summary>\n        private sealed class FlowExecutionOutcome\n        {\n            /// <summary>\n            /// True if at least one message/template was sent.\n            /// </summary>\n            public bool AnySent { get; set; }\n\n            /// <summary>\n            /// Number of plain text messages sent in this run.\n            /// </summary>\n            public int SentTextMessages { get; set; }\n\n            /// <summary>\n            /// Number of template messages sent in this run.\n            /// </summary>\n            public int SentTemplates { get; set; }\n\n            /// <summary>\n            /// Extra notes about execution (e.g. errors, loop guards, tags/waits summary).\n            /// </summary>\n            public string? Notes { get; set; }\n\n            /// <summary>\n            /// Short human-readable summary for logs.\n            /// </summary>\n            public string? Summary\n            {\n                get\n                {\n                    var parts = new List<string>();\n\n                    if (SentTextMessages > 0)\n                    {\n                        parts.Add($\"Text x{SentTextMessages}\");\n                    }\n\n                    if (SentTemplates > 0)\n                    {\n                        parts.Add($\"Template x{SentTemplates}\");\n                    }\n\n                    if (!string.IsNullOrWhiteSpace(Notes))\n                    {\n                        parts.Add(Notes!);\n                    }\n\n                    return parts.Count == 0 ? null : string.Join(\" | \", parts);\n                }\n            }\n\n            public static FlowExecutionOutcome Empty { get; } = new();\n        }\n\n        /// <summary>\n        /// Execute a builder-based flow as a simple linear sequence of nodes.\n        /// For now:\n        /// - Supports: \"message\", \"template\", \"wait\", \"tag\".\n        /// - Executes in the order defined by node.Order, ignoring the visual \"start\" node.\n        /// </summary>\n        private async Task<FlowExecutionOutcome> ExecuteFlowLinearAsync(\n            AutoReplyFlow flow,\n            Guid businessId,\n            Guid contactId,\n            string contactPhone,\n            CancellationToken ct)\n        {\n            var nodes = DeserializeNodes(flow.NodesJson);\n            if (nodes == null || nodes.Count == 0)\n            {\n                _logger.LogWarning(\n                    \"AutoReply flow {FlowId} for Business={BusinessId} has no nodes; nothing to execute.\",\n                    flow.Id,\n                    businessId);\n\n                return FlowExecutionOutcome.Empty;\n            }\n\n            // For now we treat flows as linear sequences:\n            // - ignore the explicit edges graph\n            // - skip the visual \"start\" node\n            var orderedNodes = nodes\n                .Where(n => !string.Equals(n.NodeType, \"start\", StringComparison.OrdinalIgnoreCase))\n                .OrderBy(n => n.Order)\n                .ToList();\n\n            if (orderedNodes.Count == 0)\n            {\n                _logger.LogWarning(\n                    \"AutoReply flow {FlowId} for Business={BusinessId} has only a start node and no action nodes.\",\n                    flow.Id,\n                    businessId);\n\n                return FlowExecutionOutcome.Empty;\n            }\n\n            var outcome = new FlowExecutionOutcome();\n            var pieces = new List<string>();\n\n            foreach (var node in orderedNodes)\n            {\n                if (ct.IsCancellationRequested)\n                {\n                    _logger.LogInformation(\n                        \"AutoReply flow execution cancelled for FlowId={FlowId}, Business={BusinessId}, Contact={ContactId}.\",\n                        flow.Id,\n                        businessId,\n                        contactId);\n                    break;\n                }\n\n                var nodeType = node.NodeType?.Trim().ToLowerInvariant();\n                AutoReplyNodeConfig? cfg = null;\n\n                if (!string.IsNullOrWhiteSpace(node.ConfigJson))\n                {\n                    try\n                    {\n                        var options = new JsonSerializerOptions\n                        {\n                            PropertyNameCaseInsensitive = true\n                        };\n                        cfg = JsonSerializer.Deserialize<AutoReplyNodeConfig>(node.ConfigJson, options);\n                    }\n                    catch (Exception ex)\n                    {\n                        _logger.LogError(\n                            ex,\n                            \"Failed to parse ConfigJson for AutoReply node {NodeId} in flow {FlowId}. ConfigJson={ConfigJson}\",\n                            node.Id,\n                            flow.Id,\n                            node.ConfigJson);\n\n                        // Log as failed step and continue\n                        await LogFlowStepAsync(\n                            businessId,\n                            flow,\n                            node,\n                            contactPhone,\n                            messageLogId: null,\n                            success: false,\n                            errorMessage: \"ConfigJson deserialization failed\",\n                            templateName: null,\n                            templateType: null,\n                            cancellationToken: ct);\n\n                        continue;\n                    }\n                }\n\n                switch (nodeType)\n                {\n                    case \"message\":\n                        {\n                            var body = cfg?.Text ?? cfg?.Body;\n                            if (string.IsNullOrWhiteSpace(body))\n                            {\n                                _logger.LogWarning(\n                                    \"AutoReply message node {NodeId} in flow {FlowId} has empty body.\",\n                                    node.Id,\n                                    flow.Id);\n\n                                await LogFlowStepAsync(\n                                    businessId,\n                                    flow,\n                                    node,\n                                    contactPhone,\n                                    messageLogId: null,\n                                    success: false,\n                                    errorMessage: \"Empty message body\",\n                                    templateName: null,\n                                    templateType: \"AUTO_REPLY_TEXT\",\n                                    cancellationToken: ct);\n\n                                break;\n                            }\n\n                            var trimmedBody = body.Trim();\n\n                            _logger.LogInformation(\n                                \"ðŸ“„ AutoReplyRuntime sending text message node {NodeId} for flow {FlowId}.\",\n                                node.Id,\n                                flow.Id);\n\n                            // âœ… Now use DeliveryMode.Immediate (conversational reply)\n                            var sendResult = await _messageEngine.SendAutoReplyTextAsync(\n                                businessId,\n                                contactPhone,\n                                trimmedBody,\n                                DeliveryMode.Immediate,\n                                ct);\n\n                            if (!sendResult.Success)\n                            {\n                                _logger.LogWarning(\n                                    \"âŒ AutoReplyRuntime failed to send text node {NodeId} in flow {FlowId}, Business={BusinessId}, Contact={ContactId}: {Message}\",\n                                    node.Id,\n                                    flow.Id,\n                                    businessId,\n                                    contactId,\n                                    sendResult.Message);\n\n                                outcome.Notes = $\"Failed to send text node {node.Id}: {sendResult.Message}\";\n\n                                await LogFlowStepAsync(\n                                    businessId,\n                                    flow,\n                                    node,\n                                    contactPhone,\n                                    messageLogId: null, // TODO: wire real MessageLogId from sendResult if available\n                                    success: false,\n                                    errorMessage: sendResult.Message,\n                                    templateName: null,\n                                    templateType: \"AUTO_REPLY_TEXT\",\n                                    cancellationToken: ct);\n\n                                return outcome;\n                            }\n\n                            outcome.AnySent = true;\n                            outcome.SentTextMessages++;\n                            pieces.Add(trimmedBody);\n\n                            await LogFlowStepAsync(\n                                businessId,\n                                flow,\n                                node,\n                                contactPhone,\n                                messageLogId: null, // TODO: from sendResult\n                                success: true,\n                                errorMessage: null,\n                                templateName: null,\n                                templateType: \"AUTO_REPLY_TEXT\",\n                                cancellationToken: ct);\n\n                            break;\n                        }\n\n                    case \"template\":\n                        {\n                            var templateName = cfg?.TemplateName;\n                            if (string.IsNullOrWhiteSpace(templateName))\n                            {\n                                _logger.LogWarning(\n                                    \"AutoReply template node {NodeId} in flow {FlowId} has no TemplateName configured.\",\n                                    node.Id,\n                                    flow.Id);\n\n                                await LogFlowStepAsync(\n                                    businessId,\n                                    flow,\n                                    node,\n                                    contactPhone,\n                                    messageLogId: null,\n                                    success: false,\n                                    errorMessage: \"Missing TemplateName\",\n                                    templateName: null,\n                                    templateType: \"AUTO_REPLY_TEMPLATE\",\n                                    cancellationToken: ct);\n\n                                break;\n                            }\n\n                            // Lookup template meta to validate header/buttons & keep language in sync.\n                            var templateRow = await _dbContext.Set<WhatsAppTemplate>()\n                                .AsNoTracking()\n                                .Where(t => t.BusinessId == businessId && t.IsActive && t.Name == templateName)\n                                .OrderByDescending(t => t.UpdatedAt)\n                                .FirstOrDefaultAsync(ct);\n\n                            var headerKind = (templateRow?.HeaderKind ?? \"none\").Trim().ToLowerInvariant();\n                            var languageCode = string.IsNullOrWhiteSpace(templateRow?.LanguageCode)\n                                ? \"en_US\"\n                                : templateRow!.LanguageCode!.Trim();\n\n                            // Body params ({{1}}, {{2}}, ...). Keep the list length stable.\n                            var rawBodyParams = cfg?.BodyParams ?? cfg?.Placeholders ?? new List<string>();\n                            var bodyParams = (rawBodyParams ?? new List<string>())\n                                .Select(p => p ?? string.Empty)\n                                .ToList();\n\n                            var expectedBodyVars = templateRow != null\n                                ? Math.Max(templateRow.BodyVarCount, 0)\n                                : bodyParams.Count;\n\n                            if (expectedBodyVars > 0)\n                            {\n                                if (bodyParams.Count < expectedBodyVars)\n                                {\n                                    bodyParams.AddRange(Enumerable.Repeat(string.Empty, expectedBodyVars - bodyParams.Count));\n                                }\n                                else if (bodyParams.Count > expectedBodyVars)\n                                {\n                                    bodyParams = bodyParams.Take(expectedBodyVars).ToList();\n                                }\n                            }\n                            else\n                            {\n                                // Template expects no body params; avoid sending extras.\n                                bodyParams = new List<string>();\n                            }\n\n                            // Optional: auto-fill one slot from contact profile/name\n                            if (cfg?.UseProfileName == true && bodyParams.Count > 0)\n                            {\n                                var slot = cfg.ProfileNameSlot ?? 1;\n                                slot = Math.Max(1, Math.Min(slot, bodyParams.Count));\n\n                                var contact = await _dbContext.Set<Contact>()\n                                    .AsNoTracking()\n                                    .FirstOrDefaultAsync(\n                                        c => c.Id == contactId && c.BusinessId == businessId,\n                                        ct);\n\n                                var displayName = (contact?.ProfileName ?? contact?.Name ?? string.Empty).Trim();\n                                if (string.IsNullOrWhiteSpace(displayName))\n                                    displayName = \"there\";\n\n                                bodyParams[slot - 1] = displayName;\n                            }\n\n                            // Header media URL (for image/video/document templates)\n                            var headerMediaUrl = (cfg?.HeaderMediaUrl ?? string.Empty).Trim();\n                            var needsHeaderUrl =\n                                headerKind == \"image\" || headerKind == \"video\" || headerKind == \"document\";\n\n                            if (needsHeaderUrl && !IsValidHttpsUrl(headerMediaUrl))\n                            {\n                                var msg = $\"Missing/invalid HTTPS header URL for {headerKind} template '{templateName}'.\";\n                                _logger.LogWarning(\n                                    \"AutoReply template node {NodeId} in flow {FlowId} cannot send: {Message}\",\n                                    node.Id,\n                                    flow.Id,\n                                    msg);\n\n                                await LogFlowStepAsync(\n                                    businessId,\n                                    flow,\n                                    node,\n                                    contactPhone,\n                                    messageLogId: null,\n                                    success: false,\n                                    errorMessage: msg,\n                                    templateName: templateName,\n                                    templateType: \"AUTO_REPLY_TEMPLATE\",\n                                    cancellationToken: ct);\n\n                                break;\n                            }\n\n                            // Dynamic URL button params (index 0..2) - validate required ones using cached template buttons.\n                            var rawUrlParams = cfg?.UrlButtonParams ?? new List<string>();\n                            var urlParams = new List<string>(capacity: 3)\n                            {\n                                rawUrlParams.Count > 0 ? (rawUrlParams[0] ?? string.Empty) : string.Empty,\n                                rawUrlParams.Count > 1 ? (rawUrlParams[1] ?? string.Empty) : string.Empty,\n                                rawUrlParams.Count > 2 ? (rawUrlParams[2] ?? string.Empty) : string.Empty,\n                            };\n\n                            var requiredUrlIndices = GetRequiredDynamicUrlButtonIndices(templateRow?.UrlButtons);\n                            var missingUrlIndex = requiredUrlIndices.FirstOrDefault(i => string.IsNullOrWhiteSpace(urlParams[i]));\n                            if (requiredUrlIndices.Count > 0 && requiredUrlIndices.Any(i => string.IsNullOrWhiteSpace(urlParams[i])))\n                            {\n                                var msg =\n                                    $\"Missing dynamic URL button value for index {missingUrlIndex} on template '{templateName}'.\";\n\n                                _logger.LogWarning(\n                                    \"AutoReply template node {NodeId} in flow {FlowId} cannot send: {Message}\",\n                                    node.Id,\n                                    flow.Id,\n                                    msg);\n\n                                await LogFlowStepAsync(\n                                    businessId,\n                                    flow,\n                                    node,\n                                    contactPhone,\n                                    messageLogId: null,\n                                    success: false,\n                                    errorMessage: msg,\n                                    templateName: templateName,\n                                    templateType: \"AUTO_REPLY_TEMPLATE\",\n                                    cancellationToken: ct);\n\n                                break;\n                            }\n\n                            var dto = new SimpleTemplateMessageDto\n                            {\n                                RecipientNumber = contactPhone,\n                                TemplateName = templateName!,\n                                TemplateParameters = bodyParams,\n                                HasStaticButtons = false,\n                                TemplateBody = cfg?.Body ?? templateRow?.Body ?? string.Empty,\n                                LanguageCode = languageCode,\n                                HeaderKind = headerKind,\n                                HeaderMediaUrl = headerMediaUrl,\n                                UrlButtonParams = urlParams\n                            };\n\n                            _logger.LogInformation(\n                                \"ðŸ“„ AutoReplyRuntime sending template node {NodeId} (template={TemplateName}) for flow {FlowId}.\",\n                                node.Id,\n                                templateName,\n                                flow.Id);\n\n                            // âœ… Now use DeliveryMode.Immediate (conversational template)\n                            var sendResult = await _messageEngine.SendTemplateMessageSimpleAsync(\n                                businessId,\n                                dto,\n                                DeliveryMode.Immediate);\n\n                            if (!sendResult.Success)\n                            {\n                                _logger.LogWarning(\n                                    \"âŒ AutoReplyRuntime failed to send template node {NodeId} in flow {FlowId}, Business={BusinessId}, Contact={ContactId}: {Message}\",\n                                    node.Id,\n                                    flow.Id,\n                                    businessId,\n                                    contactId,\n                                    sendResult.Message);\n\n                                outcome.Notes = $\"Failed to send template node {node.Id}: {sendResult.Message}\";\n\n                                await LogFlowStepAsync(\n                                    businessId,\n                                    flow,\n                                    node,\n                                    contactPhone,\n                                    messageLogId: null,\n                                    success: false,\n                                    errorMessage: sendResult.Message,\n                                    templateName: templateName,\n                                    templateType: \"AUTO_REPLY_TEMPLATE\",\n                                    cancellationToken: ct);\n\n                                return outcome;\n                            }\n\n                            outcome.AnySent = true;\n                            outcome.SentTemplates++;\n                            pieces.Add($\"[TEMPLATE:{templateName}]\");\n\n                            await LogFlowStepAsync(\n                                businessId,\n                                flow,\n                                node,\n                                contactPhone,\n                                messageLogId: null,\n                                success: true,\n                                errorMessage: null,\n                                templateName: templateName,\n                                templateType: \"AUTO_REPLY_TEMPLATE\",\n                                cancellationToken: ct);\n\n                            break;\n                        }\n\n                    case \"tag\":\n                        {\n                            var (success, appliedTags, error) =\n                                await ApplyTagsToContactAsync(\n                                    businessId,\n                                    contactId,\n                                    contactPhone,\n                                    cfg,\n                                    node.ConfigJson,\n                                    ct);\n\n                            if (!success)\n                            {\n                                _logger.LogWarning(\n                                    \"AutoReply tag node {NodeId} in flow {FlowId} failed to apply tags. Reason: {Reason}.\",\n                                    node.Id,\n                                    flow.Id,\n                                    error ?? \"Unknown\");\n\n                                await LogFlowStepAsync(\n                                    businessId,\n                                    flow,\n                                    node,\n                                    contactPhone,\n                                    messageLogId: null,\n                                    success: false,\n                                    errorMessage: error ?? \"Failed to apply tags\",\n                                    templateName: null,\n                                    templateType: \"AUTO_REPLY_TAG\",\n                                    cancellationToken: ct);\n\n                                break;\n                            }\n\n                            _logger.LogInformation(\n                                \"ðŸ· AutoReply tag node {NodeId} in flow {FlowId} applied tags: {Tags}.\",\n                                node.Id,\n                                flow.Id,\n                                string.Join(\",\", appliedTags));\n\n                            pieces.Add($\"[TAGS:{string.Join(\",\", appliedTags)}]\");\n\n                            await LogFlowStepAsync(\n                                businessId,\n                                flow,\n                                node,\n                                contactPhone,\n                                messageLogId: null,\n                                success: true,\n                                errorMessage: null,\n                                templateName: null,\n                                templateType: \"AUTO_REPLY_TAG\",\n                                cancellationToken: ct);\n\n                            break;\n                        }\n\n                    case \"wait\":\n                        {\n                            var seconds = cfg?.Seconds\n                                           ?? cfg?.DelaySeconds\n                                           ?? cfg?.WaitSeconds\n                                           ?? 0;\n\n                            if (seconds <= 0)\n                            {\n                                _logger.LogWarning(\n                                    \"AutoReply wait node {NodeId} in flow {FlowId} has invalid or zero Seconds.\",\n                                    node.Id,\n                                    flow.Id);\n\n                                await LogFlowStepAsync(\n                                    businessId,\n                                    flow,\n                                    node,\n                                    contactPhone,\n                                    messageLogId: null,\n                                    success: false,\n                                    errorMessage: \"Invalid wait seconds\",\n                                    templateName: null,\n                                    templateType: \"AUTO_REPLY_WAIT\",\n                                    cancellationToken: ct);\n\n                                break;\n                            }\n\n                            const int MaxWaitSeconds = 15;\n                            var requestedSeconds = seconds;\n                            if (seconds > MaxWaitSeconds)\n                            {\n                                seconds = MaxWaitSeconds;\n                            }\n\n                            _logger.LogInformation(\n                                \"â± AutoReply wait node {NodeId} in flow {FlowId} performing inline wait of {Seconds}s (requested {RequestedSeconds}s).\",\n                                node.Id,\n                                flow.Id,\n                                seconds,\n                                requestedSeconds);\n\n                            try\n                            {\n                                await Task.Delay(TimeSpan.FromSeconds(seconds), ct);\n                            }\n                            catch (TaskCanceledException)\n                            {\n                                _logger.LogInformation(\n                                    \"AutoReply wait node {NodeId} in flow {FlowId} was cancelled during wait of {Seconds}s.\",\n                                    node.Id,\n                                    flow.Id,\n                                    seconds);\n                                throw;\n                            }\n\n                            pieces.Add($\"[WAIT:{seconds}s]\");\n\n                            await LogFlowStepAsync(\n                                businessId,\n                                flow,\n                                node,\n                                contactPhone,\n                                messageLogId: null,\n                                success: true,\n                                errorMessage: null,\n                                templateName: null,\n                                templateType: \"AUTO_REPLY_WAIT\",\n                                cancellationToken: ct);\n\n                            break;\n                        }\n\n                    case \"cta_flow\":\n                        {\n                            // â¬‡ï¸ use the Guid parsed from the string\n                            var ctaConfigId = cfg?.CtaFlowConfigGuid ?? Guid.Empty;\n                            if (ctaConfigId == Guid.Empty)\n                            {\n                                _logger.LogWarning(\n                                    \"AutoReply CTA_FLOW node {NodeId} in flow {FlowId} has no CtaFlowConfigId configured.\",\n                                    node.Id,\n                                    flow.Id);\n\n                                await LogFlowStepAsync(\n                                    businessId,\n                                    flow,\n                                    node,\n                                    contactPhone,\n                                    messageLogId: null,\n                                    success: false,\n                                    errorMessage: \"Missing CtaFlowConfigId\",\n                                    templateName: null,\n                                    templateType: \"AUTO_REPLY_CTA_FLOW\",\n                                    cancellationToken: ct);\n\n                                break;\n                            }\n\n                            _logger.LogInformation(\n                                \"ðŸš€ AutoReply CTA_FLOW node {NodeId} in flow {FlowId} starting CTA flow config {ConfigId} for Business={BusinessId}, Contact={ContactId}.\",\n                                node.Id,\n                                flow.Id,\n                                ctaConfigId,\n                                businessId,\n                                contactId);\n\n                            var runResult = await _ctaFlowRuntime.StartFlowAsync(\n                                businessId,\n                                contactId,\n                                contactPhone,\n                                ctaConfigId,\n                                FlowExecutionOrigin.AutoReply,\n                                flow.Id,\n                                ct);\n\n                            // ... existing success/error handling for CTA flow (unchanged) ...\n\n                            break;\n                        }\n\n                    default:\n                        {\n                            _logger.LogDebug(\n                                \"AutoReplyRuntime encountered unsupported node type '{NodeType}' in flow {FlowId}, node {NodeId}.\",\n                                node.NodeType,\n                                flow.Id,\n                                node.Id);\n                            break;\n                        }\n\n                }\n            }\n\n            if (pieces.Count > 0)\n            {\n                outcome.Notes = string.Join(\" | \", pieces);\n            }\n\n            return outcome;\n        }\n\n        // ----------------------------------------------------\n        // Helpers â€“ keyword matching\n        // ----------------------------------------------------\n        private static List<string> SplitIntoWords(string normalizedIncoming)\n        {\n            if (string.IsNullOrWhiteSpace(normalizedIncoming))\n                return new List<string>();\n\n            var parts = normalizedIncoming.Split(\n                new[]\n                {\n                    ' ', '\\t', '\\r', '\\n',\n                    '.', ',', '!', '?', ';', ':',\n                    '-', '_', '/', '\\\\',\n                    '(', ')', '[', ']', '{', '}',\n                    '\"', '\\'', 'â€™'\n                },\n                StringSplitOptions.RemoveEmptyEntries);\n\n            return parts.ToList();\n        }\n\n        private static bool IsKeywordMatch(\n            string normalizedKeyword,\n            string normalizedIncoming,\n            string matchMode,\n            IReadOnlyList<string> incomingWords)\n        {\n            if (string.IsNullOrWhiteSpace(normalizedKeyword) ||\n                string.IsNullOrWhiteSpace(normalizedIncoming))\n            {\n                return false;\n            }\n\n            var mode = string.IsNullOrWhiteSpace(matchMode)\n                ? \"WORD\"\n                : matchMode.Trim().ToUpperInvariant();\n\n            switch (mode)\n            {\n                case \"EXACT\":\n                    // Entire text must be exactly the keyword\n                    return string.Equals(\n                        normalizedIncoming,\n                        normalizedKeyword,\n                        StringComparison.Ordinal);\n\n                case \"WORD\":\n                    // For single words: token-based match (message must contain that word).\n                    // For multi-word keywords: fall back to simple substring contains.\n                    if (!normalizedKeyword.Contains(' '))\n                    {\n                        if (incomingWords == null || incomingWords.Count == 0)\n                            return false;\n\n                        foreach (var w in incomingWords)\n                        {\n                            if (string.Equals(w, normalizedKeyword, StringComparison.Ordinal))\n                                return true;\n                        }\n\n                        return false;\n                    }\n\n                    return normalizedIncoming.Contains(\n                        normalizedKeyword,\n                        StringComparison.Ordinal);\n\n                case \"STARTSWITH\":\n                    return normalizedIncoming.StartsWith(\n                        normalizedKeyword,\n                        StringComparison.Ordinal);\n\n                case \"CONTAINS\":\n                default:\n                    return normalizedIncoming.Contains(\n                        normalizedKeyword,\n                        StringComparison.Ordinal);\n            }\n        }\n\n        private static bool IsValidHttpsUrl(string? value)\n        {\n            if (string.IsNullOrWhiteSpace(value)) return false;\n            if (!Uri.TryCreate(value.Trim(), UriKind.Absolute, out var uri)) return false;\n            return string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase);\n        }\n\n        private static IReadOnlyList<int> GetRequiredDynamicUrlButtonIndices(string? urlButtonsJson)\n        {\n            if (string.IsNullOrWhiteSpace(urlButtonsJson))\n                return Array.Empty<int>();\n\n            try\n            {\n                var options = new JsonSerializerOptions\n                {\n                    PropertyNameCaseInsensitive = true\n                };\n\n                var btns = JsonSerializer.Deserialize<List<ButtonMetadataDto>>(urlButtonsJson, options)\n                           ?? new List<ButtonMetadataDto>();\n\n                return btns\n                    .Where(b =>\n                    {\n                        var type = (b.Type ?? string.Empty).Trim().ToUpperInvariant();\n                        var sub = (b.SubType ?? string.Empty).Trim().ToLowerInvariant();\n                        var isUrl = type == \"URL\" || sub == \"url\";\n                        var isDynamic = (b.ParameterValue ?? string.Empty).Contains(\"{{\", StringComparison.Ordinal);\n                        return isUrl && isDynamic;\n                    })\n                    .Select(b => b.Index)\n                    .Where(i => i >= 0 && i <= 2)\n                    .Distinct()\n                    .OrderBy(i => i)\n                    .ToList();\n            }\n            catch\n            {\n                return Array.Empty<int>();\n            }\n        }\n\n        // ----------------------------------------------------\n        // Helpers â€“ nodes / configs\n        // ----------------------------------------------------\n        private FlowNodeSummary? GetFirstActionNodeSummary(AutoReplyFlow flow)\n        {\n            var nodes = DeserializeNodes(flow.NodesJson);\n            if (nodes == null || nodes.Count == 0)\n                return null;\n\n            var firstAction = nodes\n                .Where(n => !string.Equals(n.NodeType, \"start\", StringComparison.OrdinalIgnoreCase))\n                .OrderBy(n => n.Order)\n                .FirstOrDefault();\n\n            if (firstAction == null)\n                return null;\n\n            return new FlowNodeSummary(\n                firstAction.NodeType ?? \"?\",\n                firstAction.NodeName ?? \"?\");\n        }\n\n        /// <summary>\n        /// Reads the first \"message\" node and extracts the text/body we want to send.\n        /// Kept for compatibility; not used by the new multi-step runner.\n        /// </summary>\n        private string? GetSimpleReplyText(AutoReplyFlow flow)\n        {\n            var nodes = DeserializeNodes(flow.NodesJson);\n            if (nodes == null || nodes.Count == 0)\n                return null;\n\n            var msgNode = nodes\n                .Where(n =>\n                    string.Equals(n.NodeType, \"message\", StringComparison.OrdinalIgnoreCase))\n                .OrderBy(n => n.Order)\n                .FirstOrDefault();\n\n            if (msgNode == null || string.IsNullOrWhiteSpace(msgNode.ConfigJson))\n                return null;\n\n            try\n            {\n                // âš™ï¸ IMPORTANT: make it case-insensitive so \"text\" / \"body\" also bind.\n                var options = new JsonSerializerOptions\n                {\n                    PropertyNameCaseInsensitive = true\n                };\n\n                var cfg = JsonSerializer.Deserialize<AutoReplyNodeConfig>(msgNode.ConfigJson, options);\n                var text = cfg?.Text ?? cfg?.Body;\n\n                return string.IsNullOrWhiteSpace(text)\n                    ? null\n                    : text.Trim();\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex,\n                    \"Failed to parse AutoReply message node config for flow {FlowId}. ConfigJson={ConfigJson}\",\n                    flow.Id,\n                    msgNode.ConfigJson);\n\n                return null;\n            }\n        }\n\n        private static List<AutoReplyNodeRecord>? DeserializeNodes(string? nodesJson)\n        {\n            if (string.IsNullOrWhiteSpace(nodesJson))\n                return null;\n\n            try\n            {\n                var options = new JsonSerializerOptions\n                {\n                    PropertyNameCaseInsensitive = true\n                };\n\n                return JsonSerializer.Deserialize<List<AutoReplyNodeRecord>>(nodesJson, options);\n            }\n            catch\n            {\n                // If we cannot parse nodes, treat as no nodes.\n                return null;\n            }\n        }\n\n        // ----------------------------------------------------\n        // Tag application helper (real DB write)\n        // ----------------------------------------------------\n        private async Task<(bool Success, string[] AppliedTags, string? ErrorMessage)> ApplyTagsToContactAsync(\n            Guid businessId,\n            Guid contactId,\n            string contactPhone,\n            AutoReplyNodeConfig? cfg,\n            string? rawConfigJson,\n            CancellationToken ct)\n        {\n            var rawNames = (cfg?.Tags ?? Array.Empty<string>()).ToList();\n            var rawIds = (cfg?.TagIds ?? Array.Empty<string>()).ToList();\n\n            // Back-compat: some older saved flows might have tags stored as a single string,\n            // e.g. { \"tags\": \"vip, hot\" } instead of { \"tags\": [\"vip\",\"hot\"] }.\n            if (!string.IsNullOrWhiteSpace(rawConfigJson))\n            {\n                try\n                {\n                    using var doc = JsonDocument.Parse(rawConfigJson);\n                    if (doc.RootElement.ValueKind == JsonValueKind.Object)\n                    {\n                        foreach (var prop in doc.RootElement.EnumerateObject())\n                        {\n                            var name = prop.Name ?? string.Empty;\n\n                            if (name.Equals(\"tags\", StringComparison.OrdinalIgnoreCase))\n                            {\n                                if (prop.Value.ValueKind == JsonValueKind.String)\n                                {\n                                    var s = prop.Value.GetString() ?? string.Empty;\n                                    rawNames.AddRange(\n                                        s.Split(new[] { ',', ';', '\\n', '\\r' }, StringSplitOptions.RemoveEmptyEntries)\n                                         .Select(x => x.Trim())\n                                    );\n                                }\n                                else if (prop.Value.ValueKind == JsonValueKind.Array)\n                                {\n                                    foreach (var item in prop.Value.EnumerateArray())\n                                    {\n                                        if (item.ValueKind == JsonValueKind.String)\n                                            rawNames.Add(item.GetString() ?? string.Empty);\n                                    }\n                                }\n                            }\n\n                            if (name.Equals(\"tagIds\", StringComparison.OrdinalIgnoreCase))\n                            {\n                                if (prop.Value.ValueKind == JsonValueKind.String)\n                                {\n                                    var s = prop.Value.GetString() ?? string.Empty;\n                                    rawIds.AddRange(\n                                        s.Split(new[] { ',', ';', '\\n', '\\r' }, StringSplitOptions.RemoveEmptyEntries)\n                                         .Select(x => x.Trim())\n                                    );\n                                }\n                                else if (prop.Value.ValueKind == JsonValueKind.Array)\n                                {\n                                    foreach (var item in prop.Value.EnumerateArray())\n                                    {\n                                        if (item.ValueKind == JsonValueKind.String)\n                                            rawIds.Add(item.GetString() ?? string.Empty);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                catch\n                {\n                    // ignore parse errors; configs can be arbitrary\n                }\n            }\n\n            var tagNames = rawNames\n                .Where(t => !string.IsNullOrWhiteSpace(t))\n                .Select(t => t.Trim())\n                .Where(t => t.Length > 0)\n                .Distinct(StringComparer.OrdinalIgnoreCase)\n                .ToList();\n\n            var tagIds = rawIds\n                .Where(t => !string.IsNullOrWhiteSpace(t))\n                .Select(t => t.Trim())\n                .Select(t => Guid.TryParse(t, out var g) ? g : Guid.Empty)\n                .Where(g => g != Guid.Empty)\n                .Distinct()\n                .ToList();\n\n            if (tagNames.Count == 0 && tagIds.Count == 0)\n            {\n                return (false, Array.Empty<string>(), \"No tags configured\");\n            }\n\n            Contact? contact = null;\n\n            if (contactId != Guid.Empty)\n            {\n                contact = await _dbContext.Contacts\n                    .Include(c => c.ContactTags)\n                    .FirstOrDefaultAsync(c =>\n                        c.Id == contactId &&\n                        c.BusinessId == businessId &&\n                        c.IsActive &&\n                        !c.IsArchived,\n                        ct);\n            }\n\n            // Fallback: if contact id wasn't provided or lookup failed, try phone.\n            if (contact == null && !string.IsNullOrWhiteSpace(contactPhone))\n            {\n                var phone = contactPhone.Trim();\n                contact = await _dbContext.Contacts\n                    .Include(c => c.ContactTags)\n                    .FirstOrDefaultAsync(c =>\n                        c.BusinessId == businessId &&\n                        c.IsActive &&\n                        !c.IsArchived &&\n                        c.PhoneNumber == phone,\n                        ct);\n            }\n\n            if (contact == null)\n            {\n                return (false, Array.Empty<string>(), \"Contact not found\");\n            }\n\n            var now = DateTime.UtcNow;\n            var existingTagIds = contact.ContactTags?.Select(ct => ct.TagId).ToHashSet() ?? new HashSet<Guid>();\n\n            var tagsToLink = new List<Tag>();\n\n            // 1) Resolve explicit TagIds (if builder ever stores ids)\n            if (tagIds.Count > 0)\n            {\n                var byId = await _dbContext.Tags\n                    .Where(t => t.BusinessId == businessId && t.IsActive && tagIds.Contains(t.Id))\n                    .ToListAsync(ct);\n                tagsToLink.AddRange(byId);\n            }\n\n            // 2) Resolve Tag names (create missing tags when needed)\n            if (tagNames.Count > 0)\n            {\n                var nameLowers = tagNames.Select(n => n.ToLowerInvariant()).ToList();\n\n                var existing = await _dbContext.Tags\n                    .Where(t => t.BusinessId == businessId && t.IsActive && nameLowers.Contains((t.Name ?? \"\").ToLower()))\n                    .ToListAsync(ct);\n\n                var existingByLower = existing\n                    .Where(t => !string.IsNullOrWhiteSpace(t.Name))\n                    .GroupBy(t => t.Name.Trim().ToLowerInvariant())\n                    .ToDictionary(g => g.Key, g => g.First());\n\n                foreach (var name in tagNames)\n                {\n                    var key = name.ToLowerInvariant();\n                    if (existingByLower.TryGetValue(key, out var found))\n                    {\n                        tagsToLink.Add(found);\n                        continue;\n                    }\n\n                    var created = new Tag\n                    {\n                        Id = Guid.NewGuid(),\n                        BusinessId = businessId,\n                        Name = name,\n                        ColorHex = \"#8c8c8c\",\n                        Category = \"General\",\n                        IsActive = true,\n                        CreatedAt = now,\n                        LastUsedAt = now\n                    };\n\n                    _dbContext.Tags.Add(created);\n                    tagsToLink.Add(created);\n                    existingByLower[key] = created;\n                }\n\n                await _dbContext.SaveChangesAsync(ct); // persist new tags before linking\n            }\n\n            tagsToLink = tagsToLink\n                .Where(t => t != null && t.BusinessId == businessId && t.IsActive)\n                .GroupBy(t => t.Id)\n                .Select(g => g.First())\n                .ToList();\n\n            if (tagsToLink.Count == 0)\n            {\n                return (false, Array.Empty<string>(), \"No valid tags found for business\");\n            }\n\n            contact.ContactTags ??= new List<ContactTag>();\n\n            foreach (var tag in tagsToLink)\n            {\n                tag.LastUsedAt = now;\n\n                if (existingTagIds.Contains(tag.Id))\n                    continue;\n\n                contact.ContactTags.Add(new ContactTag\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    ContactId = contact.Id,\n                    TagId = tag.Id,\n                    AssignedAt = now,\n                    AssignedBy = \"automation\"\n                });\n\n                existingTagIds.Add(tag.Id);\n            }\n\n            try\n            {\n                await _dbContext.SaveChangesAsync(ct);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(\n                    ex,\n                    \"AutoReply tag assignment failed. businessId={BusinessId}, contactId={ContactId}\",\n                    businessId,\n                    contact.Id);\n\n                return (false, Array.Empty<string>(), \"Failed to apply tags (DB error)\");\n            }\n\n            var applied = tagsToLink\n                .Select(t => t.Name)\n                .Where(n => !string.IsNullOrWhiteSpace(n))\n                .Select(n => n.Trim())\n                .Distinct(StringComparer.OrdinalIgnoreCase)\n                .ToArray();\n\n            return (true, applied, null);\n        }\n\n        // ----------------------------------------------------\n        // AutoReply logging helper\n        // ----------------------------------------------------\n        private async Task LogAutoReplyAsync(\n            Guid businessId,\n            Guid contactId,\n            string? matchedKeyword,\n            AutoReplyFlow? flow,\n            string? replyText,\n            Guid? messageLogId,\n            CancellationToken ct)\n        {\n            try\n            {\n                var log = new AutoReplyLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    ContactId = contactId,\n                    TriggerType = \"flow\",\n                    TriggerKeyword = matchedKeyword ?? string.Empty,\n                    ReplyContent = replyText ?? string.Empty,\n                    FlowName = flow?.Name,\n                    MessageLogId = messageLogId,\n                    TriggeredAt = DateTime.UtcNow\n                };\n\n                _dbContext.Set<AutoReplyLog>().Add(log);\n                await _dbContext.SaveChangesAsync(ct);\n\n                _logger.LogInformation(\n                    \"ðŸ“ AutoReplyLog inserted for BusinessId={BusinessId}, ContactId={ContactId}, FlowName={FlowName}, Keyword='{Keyword}'.\",\n                    businessId,\n                    contactId,\n                    flow?.Name,\n                    matchedKeyword);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(\n                    ex,\n                    \"âŒ Failed to insert AutoReplyLog for BusinessId={BusinessId}, ContactId={ContactId}, FlowName={FlowName}.\",\n                    businessId,\n                    contactId,\n                    flow?.Name);\n            }\n        }\n\n        /// <summary>\n        /// Helper to write a single origin-aware FlowExecutionLog row for an AutoReply step.\n        /// </summary>\n        private async Task LogFlowStepAsync(\n           Guid businessId,\n           AutoReplyFlow flow,\n           AutoReplyNodeRecord node,\n           string contactPhone,\n           Guid? messageLogId,\n           bool success,\n           string? errorMessage,\n           string? templateName,\n           string? templateType,\n           CancellationToken cancellationToken)\n        {\n            try\n            {\n                if (flow == null)\n                {\n                    _logger.LogWarning(\n                        \"Skipping FlowExecution log because AutoReplyFlow is null. BusinessId={BusinessId}, Contact={ContactPhone}\",\n                        businessId,\n                        contactPhone);\n\n                    return;\n                }\n\n                if (node == null)\n                {\n                    _logger.LogWarning(\n                        \"Skipping FlowExecution log because AutoReply node is null. BusinessId={BusinessId}, AutoReplyFlowId={FlowId}, Contact={ContactPhone}\",\n                        businessId,\n                        flow.Id,\n                        contactPhone);\n\n                    return;\n                }\n\n                // AutoReplyNodeRecord.Id is Guid?; if somehow missing, keep Guid.Empty so we can see it in logs.\n                var stepId = node.Id ?? Guid.Empty;\n\n                var ctx = new FlowExecutionContext\n                {\n                    BusinessId = businessId,\n                    Origin = FlowExecutionOrigin.AutoReply,\n\n                    // For AutoReply we DO NOT use CTA FlowId; that column is reserved for CTAFlowConfigId.\n                    FlowId = null,\n\n                    StepId = stepId,\n                    StepName = node.NodeName ?? node.NodeType ?? \"AUTO_REPLY_STEP\",\n\n                    // No per-run grouping yet; can add when you introduce FlowRunId\n                    RunId = null,\n\n                    // AutoReply-origin, not a campaign broadcast\n                    CampaignId = null,\n                    AutoReplyFlowId = flow.Id,\n                    CampaignSendLogId = null,\n                    TrackingLogId = null,\n\n                    MessageLogId = messageLogId,\n                    ContactPhone = contactPhone,\n\n                    // No buttons involved for plain AutoReply nodes (we log button stuff in CTAFlowRuntime)\n                    TriggeredByButton = null,\n                    ButtonIndex = null,\n\n                    TemplateName = templateName,\n                    TemplateType = templateType,\n\n                    RequestId = null,\n                    Success = success,\n                    ErrorMessage = errorMessage,\n                    RawResponse = null,\n\n                    ExecutedAtUtc = DateTime.UtcNow\n                };\n\n                await _flowExecutionLogger.LogStepAsync(ctx, cancellationToken);\n\n                _logger.LogInformation(\n                    \"[AutoReplyFlowLog] Logged step. Biz={BusinessId}, AutoReplyFlowId={FlowId}, StepId={StepId}, StepName={StepName}, Success={Success}, Template={TemplateName}\",\n                    businessId,\n                    flow.Id,\n                    stepId,\n                    ctx.StepName,\n                    ctx.Success,\n                    ctx.TemplateName ?? \"(none)\");\n            }\n            catch (Exception ex)\n            {\n                // Never break AutoReply runtime because logging failed.\n                _logger.LogError(\n                    ex,\n                    \"Failed to log AutoReply FlowExecution step for BusinessId={BusinessId}, AutoReplyFlowId={FlowId}, NodeId={NodeId}\",\n                    businessId,\n                    flow?.Id,\n                    node?.Id);\n            }\n        }\n\n        // ----------------------------------------------------\n        // Private types for node parsing / choosing winners\n        // ----------------------------------------------------\n\n        private sealed class AutoReplyNodeRecord\n        {\n            public Guid? Id { get; set; }\n            public string? NodeType { get; set; }\n            public string? NodeName { get; set; }\n            public string? ConfigJson { get; set; }\n            public int Order { get; set; }\n            // positionX/positionY etc exist in JSON but we don't need them here\n        }\n\n        private sealed class AutoReplyNodeConfig\n        {\n            public string? Text { get; set; }           // for \"message\" nodes\n            public string? Body { get; set; }           // sometimes templates/body may reuse this\n            public string? TemplateName { get; set; }   // for template nodes\n\n            // Template node â€“ dynamic values (CTA-like)\n            public List<string>? BodyParams { get; set; }        // {{1}}, {{2}}, ...\n            public List<string>? Placeholders { get; set; }      // legacy alias\n            public string? HeaderMediaUrl { get; set; }          // image/video/document URL\n            public List<string>? UrlButtonParams { get; set; }   // index 0..2 URL params\n            public bool? UseProfileName { get; set; }            // auto-fill one slot\n            public int? ProfileNameSlot { get; set; }            // 1-based slot index\n\n            // Tag node â€“ support both \"tags\" and \"tagIds\" shapes\n            public string[]? Tags { get; set; }\n            public string[]? TagIds { get; set; }\n\n            // Wait node â€“ support multiple property names coming from builder\n            public int? Seconds { get; set; }\n            public int? DelaySeconds { get; set; }\n            public int? WaitSeconds { get; set; }\n\n            // CTA flow node â€“ ID of the CTA flow config to start\n            public string? CtaFlowConfigId { get; set; }\n\n            [JsonIgnore]\n            public Guid? CtaFlowConfigGuid =>\n              Guid.TryParse(CtaFlowConfigId, out var g) ? g : (Guid?)null;\n        }\n\n        private sealed record FlowNodeSummary(string NodeType, string NodeName);\n\n        private sealed class FlowMatchCandidate\n        {\n            public AutoReplyFlow Flow { get; init; } = null!;\n            public string Keyword { get; init; } = string.Empty;\n            public string MatchMode { get; init; } = \"WORD\";\n            public int Priority { get; init; }\n            public int KeywordLength { get; init; }\n        }\n    }\n}\n\n\n\n\n\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Services/FlowRunner.cs",
      "sha256": "d8c0004b19eb4964915bcf51a0ecdadf6dc89cfe50220970befa0fe58a5d4307",
      "language": "csharp",
      "size": 103,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.Services\n{\n    public class FlowRunner\n    {\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Services/IAutoReplyFlowService.cs",
      "sha256": "ed0bc4cbd7017360eb700dcd3012a016a2189ba01c7a945a5056e1e5d8177c65",
      "language": "csharp",
      "size": 876,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.AutoReplyBuilder.DTOs;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Services\n{\n    public interface IAutoReplyFlowService\n    {\n        Task<IReadOnlyList<AutoReplyFlowSummaryDto>> GetFlowsForBusinessAsync(Guid businessId, CancellationToken ct = default);\n\n        Task<AutoReplyFlowDto?> GetFlowAsync(Guid businessId, Guid flowId, CancellationToken ct = default);\n\n        Task<AutoReplyFlowDto> SaveFlowAsync(Guid businessId, AutoReplyFlowDto dto, CancellationToken ct = default);\n\n        Task DeleteFlowAsync(Guid businessId, Guid flowId, CancellationToken ct = default);\n        Task SetActiveAsync(\n            Guid businessId,\n            Guid flowId,\n            bool isActive,\n            CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Services/IAutoReplyLogService.cs",
      "sha256": "f684d51cf8e980999c33b87dc4aa280b02eb818e12b7f4b8bc90368ce5458fd2",
      "language": "csharp",
      "size": 609,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.AutoReplyBuilder.DTOs;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Services\n{\n    public interface IAutoReplyLogService\n    {\n        /// <summary>\n        /// Returns the most recent auto-reply triggers for a business,\n        /// ordered by TriggeredAt desc.\n        /// </summary>\n        Task<IReadOnlyList<AutoReplyLogSummaryDto>> GetRecentAsync(\n            Guid businessId,\n            int take,\n            CancellationToken cancellationToken = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Services/IAutoReplyRuntimeService.cs",
      "sha256": "4182b20e2a5b814027abc73f1a31f3b96f2a70b8d9ccaacf33ea64b98514e014",
      "language": "csharp",
      "size": 1365,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.AutoReplyBuilder.DTOs;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Services\n{\n    public interface IAutoReplyRuntimeService\n    {\n        /// <summary>\n        /// Real runtime handler used by the webhook when an inbound WhatsApp message arrives.\n        /// </summary>\n        Task<AutoReplyRuntimeResult> TryHandleAsync(\n            Guid businessId,\n            Guid contactId,\n            string contactPhone,\n            string incomingText,\n            CancellationToken cancellationToken = default);\n\n        /// <summary>\n        /// Test-only match used by the AutoReply Builder UI (\"Test Auto-Reply Match\" panel).\n        /// MUST NOT send any real messages.\n        /// </summary>\n        Task<AutoReplyRuntimeResult> TestMatchAsync(\n            Guid businessId,\n            string incomingText,\n            CancellationToken cancellationToken = default);\n\n        /// <summary>\n        /// Legacy DTO-based matcher used by existing endpoints\n        /// (e.g. /api/auto-reply-runtime/button-click).\n        /// Thin adapter over <see cref=\"TestMatchAsync\"/>.\n        /// </summary>\n        Task<AutoReplyMatchResultDto> FindMatchAsync(\n            AutoReplyMatchRequestDto request,\n            CancellationToken cancellationToken = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Services/IFlowRunner.cs",
      "sha256": "11438f4864857ba65f652f4ed62baf47119c77fcd6933106db70602675dce48b",
      "language": "csharp",
      "size": 104,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.Services\n{\n    public class IFlowRunner\n    {\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyTemplates/Restaurant/Configs/MenuNodeConfig.cs",
      "sha256": "f20da12fb12eed3191a2998cb2e7a7dbc65b03bfcb571cf1b6a413f52d78d42a",
      "language": "csharp",
      "size": 527,
      "content": "namespace xbytechat.api.Features.AutoReplyTemplates.Restaurant.Configs\n{\n    public class MenuNodeConfig\n    {\n        public string MenuTitle { get; set; } = string.Empty;         // e.g., \"Today's Specials\"\n        public string Description { get; set; } = string.Empty;       // e.g., \"Lunch combos starting at â‚¹199\"\n        public string MenuImageUrl { get; set; } = string.Empty;      // CDN or public link\n        public string MenuDownloadUrl { get; set; } = string.Empty;   // PDF link or product catalog URL\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Billing/Controllers/WhatsAppMetaWebhookController.cs",
      "sha256": "5d6058aacf89412c04875981d4a5cb9a6231ff533ce9db9796e201479e55a252",
      "language": "csharp",
      "size": 2829,
      "content": "using System;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.Billing.Security;\nusing xbytechat_api.Features.Billing.Services;\n\nnamespace xbytechat_api.Features.Billing.Controllers\n{\n    [ApiController]\n    [Route(\"api/webhooks/whatsapp/meta\")]\n    public class WhatsAppMetaWebhookController : ControllerBase\n    {\n        private readonly ILogger<WhatsAppMetaWebhookController> _log;\n        private readonly IBillingIngestService _ingest;\n        private readonly IConfiguration _config;\n        private readonly IMetaSignatureValidator _metaSigValidator;\n        public WhatsAppMetaWebhookController(ILogger<WhatsAppMetaWebhookController> log,\n            IBillingIngestService ingest, IConfiguration config, IMetaSignatureValidator metaSigValidator)\n        {\n            _log = log;\n            _ingest = ingest;\n            _config = config;\n            _metaSigValidator = metaSigValidator;\n        }\n\n        // Meta verification handshake\n        // GET /api/webhooks/whatsapp/meta?hub.mode=subscribe&hub.challenge=...&hub.verify_token=...&businessId=...\n        [HttpGet]\n        public IActionResult Verify([FromQuery(Name = \"hub.mode\")] string mode,\n                                    [FromQuery(Name = \"hub.challenge\")] string challenge,\n                                    [FromQuery(Name = \"hub.verify_token\")] string verifyToken,\n                                    [FromQuery] Guid? businessId = null)\n        {\n            var expected = _config[\"WhatsApp:MetaVerifyToken\"]; // optional; if empty we accept\n            if (!string.IsNullOrWhiteSpace(expected) && !string.Equals(expected, verifyToken))\n            {\n                _log.LogWarning(\"Meta webhook verify failed. Provided token does not match.\");\n                return Unauthorized();\n            }\n            _log.LogInformation(\"Meta webhook verified. BusinessId={BusinessId}\", businessId);\n            return Content(challenge ?? string.Empty, \"text/plain\");\n        }\n\n        // POST /api/webhooks/whatsapp/meta?businessId=...\n        [HttpPost]\n        public async Task<IActionResult> Post([FromQuery] Guid businessId)\n        {\n            using var reader = new StreamReader(Request.Body);\n            var payload = await reader.ReadToEndAsync();\n\n            var sig = Request.Headers[\"X-Hub-Signature-256\"].ToString();\n\n            if (!_metaSigValidator.IsValid(sig, payload))\n            {\n                _log.LogWarning(\"Meta webhook: invalid signature for business {BusinessId}\", businessId);\n                return Unauthorized();\n            }\n\n            await _ingest.IngestFromWebhookAsync(businessId, \"META_CLOUD\", payload);\n\n            return Ok();\n        }\n\n\n        // If you need GET verification for Meta webhook, add it here.\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Billing/Controllers/WhatsAppPinnacleWebhookController.cs",
      "sha256": "50c4e7ef562320331826b09fa5210313b19967296a61f89daf10e2e421b8bf73",
      "language": "csharp",
      "size": 1268,
      "content": "using System;\nusing System.IO;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing xbytechat_api.Features.Billing.Services;\n\nnamespace xbytechat_api.Features.Billing.Controllers\n{\n    [ApiController]\n    [Route(\"api/webhooks/whatsapp/pinnacle\")]\n    public class WhatsAppPinnacleWebhookController : ControllerBase\n    {\n        private readonly ILogger<WhatsAppPinnacleWebhookController> _log;\n        private readonly IBillingIngestService _ingest;\n\n        public WhatsAppPinnacleWebhookController(\n            ILogger<WhatsAppPinnacleWebhookController> log,\n            IBillingIngestService ingest)\n        {\n            _log = log;\n            _ingest = ingest;\n        }\n\n        // POST /api/webhooks/whatsapp/pinnacle?businessId=...\n        [HttpPost]\n        public async Task<IActionResult> Post([FromQuery] Guid businessId)\n        {\n            using var reader = new StreamReader(Request.Body);\n            var payload = await reader.ReadToEndAsync();\n\n            _log.LogInformation(\"Pinnacle webhook payload ({Len} chars) for Biz {Biz}\", payload?.Length ?? 0, businessId);\n            await _ingest.IngestFromWebhookAsync(businessId, \"PINNACLE\", payload);\n\n            return Ok();\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Billing/DTOs/BillingSnapshotDto.cs",
      "sha256": "ccb71af46ccda4580bcf96c49ae7cab671224aa519eaaf63e561d2fa39d0eb26",
      "language": "csharp",
      "size": 534,
      "content": "using System.Collections.Generic;\n\nnamespace xbytechat_api.Features.Billing.DTOs\n{\n    public class BillingSnapshotDto\n    {\n        public int TotalMessages { get; set; }\n        public int ChargeableMessages { get; set; }\n        public int FreeMessages { get; set; }\n        public Dictionary<string, int> CountByCategory { get; set; } = new();    // marketing, utility, authentication, service, free_entry\n        public Dictionary<string, decimal> SpendByCurrency { get; set; } = new();// \"USD\" => 12.34, \"INR\" => 250.00\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Billing/Models/ProviderBillingEvent.cs",
      "sha256": "f923e2377733fecf0ad48ff39d28f1a6e1bbfe4e78f370748b864f1568285824",
      "language": "csharp",
      "size": 1179,
      "content": "using System;\n\nnamespace xbytechat_api.Features.Billing.Models\n{\n    public class ProviderBillingEvent\n    {\n        public Guid Id { get; set; } = Guid.NewGuid();\n        public Guid BusinessId { get; set; }\n\n        // Link if we can; may be null if webhook arrives before we create MessageLog\n        public Guid? MessageLogId { get; set; }\n\n        public string Provider { get; set; } = \"\";          // \"Meta_cloud\", \"Pinnacle\"\n        public string EventType { get; set; } = \"\";         // \"conversation_started\", \"message_delivered\", \"pricing_update\", etc.\n\n        public string? ProviderMessageId { get; set; }      // \"wamid...\"\n        public string? ConversationId { get; set; }\n        public string? ConversationCategory { get; set; }\n        public bool? IsChargeable { get; set; }\n        public decimal? PriceAmount { get; set; }\n        public string? PriceCurrency { get; set; }\n\n        public string PayloadJson { get; set; } = \"\";       // original provider payload for audit\n        public DateTimeOffset OccurredAt { get; set; }      // when provider says it happened\n        public DateTimeOffset CreatedAt { get; set; } = DateTimeOffset.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Billing/Security/MetaSignatureValidator.cs",
      "sha256": "2f5296dfd490f127acd70615ed255b07d30937004ef7b3f58ee8d2a6b1521863",
      "language": "csharp",
      "size": 1745,
      "content": "using System;\nusing System.Security.Cryptography;\nusing System.Text;\nusing Microsoft.Extensions.Configuration;\n\nnamespace xbytechat.api.Features.Billing.Security\n{\n    public interface IMetaSignatureValidator\n    {\n        bool IsValid(string signatureHeader, string payload);\n    }\n\n    public class MetaSignatureValidator : IMetaSignatureValidator\n    {\n        private readonly string _appSecret;\n\n        public MetaSignatureValidator(IConfiguration config)\n        {\n            _appSecret = config[\"WhatsApp:MetaAppSecret\"]\n                         ?? throw new InvalidOperationException(\"WhatsApp:MetaAppSecret is not configured\");\n        }\n\n        public bool IsValid(string signatureHeader, string payload)\n        {\n            if (string.IsNullOrWhiteSpace(signatureHeader) || string.IsNullOrEmpty(payload))\n                return false;\n\n            // header format: sha256=HEX\n            const string prefix = \"sha256=\";\n            if (!signatureHeader.StartsWith(prefix, StringComparison.OrdinalIgnoreCase))\n                return false;\n\n            var sent = signatureHeader.Substring(prefix.Length);\n\n            using var hmac = new HMACSHA256(Encoding.UTF8.GetBytes(_appSecret));\n            var hashBytes = hmac.ComputeHash(Encoding.UTF8.GetBytes(payload));\n            var expected = BitConverter.ToString(hashBytes).Replace(\"-\", \"\").ToLowerInvariant();\n\n            return CryptographicEquals(expected, sent);\n        }\n\n        private static bool CryptographicEquals(string a, string b)\n        {\n            if (a.Length != b.Length) return false;\n\n            var result = 0;\n            for (int i = 0; i < a.Length; i++)\n                result |= a[i] ^ b[i];\n\n            return result == 0;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Billing/Services/BillingIngestService.cs",
      "sha256": "c608eae99d94309f2e21fc3c2fb7843c97bb8301e0f262a34cbe263bce124153",
      "language": "csharp",
      "size": 26626,
      "content": "using System;\nusing System.Linq;\nusing System.Text.Json;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api; // AppDbContext\nusing xbytechat_api.Features.Billing.Models;\nusing Npgsql;\nusing Serilog;\n\nnamespace xbytechat_api.Features.Billing.Services\n{\n    public class BillingIngestService : IBillingIngestService\n    {\n        private readonly AppDbContext _db;\n        private readonly ILogger<BillingIngestService> _log;\n\n        public BillingIngestService(AppDbContext db, ILogger<BillingIngestService> log)\n        {\n            _db = db;\n            _log = log;\n        }\n\n        public async Task IngestFromSendResponseAsync(Guid businessId, Guid messageLogId, string provider, string rawResponseJson)\n        {\n            // Guard: only accept events for known businesses\n            var hasBiz = await _db.Businesses.AnyAsync(b => b.Id == businessId);\n            if (!hasBiz)\n            {\n                _log.LogWarning(\"Ignoring send-response for unknown business {BusinessId}\", businessId);\n                return;\n            }\n\n            try\n            {\n                using var doc = JsonDocument.Parse(rawResponseJson);\n\n                string? providerMessageId =\n                    doc.RootElement.TryGetProperty(\"messages\", out var msgs) &&\n                    msgs.ValueKind == JsonValueKind.Array &&\n                    msgs.GetArrayLength() > 0\n                        ? (msgs[0].TryGetProperty(\"id\", out var idEl) ? idEl.GetString() : null)\n                        : (doc.RootElement.TryGetProperty(\"id\", out var idEl2) ? idEl2.GetString() : null);\n\n                var logRow = await _db.MessageLogs\n                    .FirstOrDefaultAsync(x => x.Id == messageLogId && x.BusinessId == businessId);\n\n                if (logRow != null)\n                {\n                    logRow.Provider = provider;\n                    if (!string.IsNullOrWhiteSpace(providerMessageId))\n                        logRow.ProviderMessageId = providerMessageId;\n                }\n\n                var ev = new ProviderBillingEvent\n                {\n                    BusinessId = businessId,\n                    MessageLogId = messageLogId,\n                    Provider = provider,\n                    EventType = \"send_response\",\n                    ProviderMessageId = providerMessageId,\n                    PayloadJson = rawResponseJson,\n                    OccurredAt = DateTimeOffset.UtcNow\n                };\n\n                _db.ProviderBillingEvents.Add(ev);\n                await _db.SaveChangesAsync();\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"Failed to ingest send response payload for business {BusinessId}\", businessId);\n            }\n        }\n\n        public async Task IngestFromWebhookAsync(Guid businessId, string provider, string payloadJson)\n        {\n            // Guard: only accept events for known businesses\n            var hasBiz = await _db.Businesses.AnyAsync(b => b.Id == businessId);\n            if (!hasBiz)\n            {\n                _log.LogWarning(\"Ignoring {Provider} webhook for unknown business {BusinessId}\", provider, businessId);\n                return;\n            }\n\n            try\n            {\n                using var doc = JsonDocument.Parse(payloadJson);\n                var now = DateTimeOffset.UtcNow;\n\n                // For the common/strong-keyed case (ProviderMessageId), we rely on DB unique index.\n                // For weaker cases (no ProviderMessageId, only ConversationId), we still probe with ExistsAsync.\n\n                Task<bool> ExistsForConversationAsync(string eventType, string? conversationId)\n                {\n                    if (string.IsNullOrWhiteSpace(conversationId))\n                        return Task.FromResult(false);\n\n                    return _db.ProviderBillingEvents.AsNoTracking().AnyAsync(x =>\n                        x.BusinessId == businessId &&\n                        x.Provider == provider &&\n                        x.EventType == eventType &&\n                        x.ConversationId == conversationId);\n                }\n\n                if (string.Equals(provider, \"META_CLOUD\", StringComparison.OrdinalIgnoreCase))\n                {\n                    foreach (var entry in Enumerate(doc.RootElement, \"entry\"))\n                        foreach (var change in Enumerate(entry, \"changes\"))\n                        {\n                            if (!change.TryGetProperty(\"value\", out var value))\n                                continue;\n\n                            foreach (var st in Enumerate(value, \"statuses\"))\n                            {\n                                string? providerMessageId = st.TryGetProperty(\"id\", out var idEl)\n                                    ? idEl.GetString()\n                                    : null;\n\n                                string? status = null;\n                                if (st.TryGetProperty(\"status\", out var statusEl) && statusEl.ValueKind == JsonValueKind.String)\n                                    status = statusEl.GetString()?.ToLowerInvariant();\n\n                                // OccurredAt from provider if present\n                                var occurredAt = now;\n                                if (st.TryGetProperty(\"timestamp\", out var tsEl))\n                                {\n                                    if (tsEl.ValueKind == JsonValueKind.String &&\n                                        long.TryParse(tsEl.GetString(), out var tsLong))\n                                        occurredAt = DateTimeOffset.FromUnixTimeSeconds(tsLong);\n                                    else if (tsEl.ValueKind == JsonValueKind.Number &&\n                                             tsEl.TryGetInt64(out var tsNum))\n                                        occurredAt = DateTimeOffset.FromUnixTimeSeconds(tsNum);\n                                }\n\n                                // Conversation info\n                                string? conversationId = null;\n                                DateTimeOffset? convStartedAt = null;\n\n                                if (st.TryGetProperty(\"conversation\", out var convEl) &&\n                                    convEl.ValueKind == JsonValueKind.Object)\n                                {\n                                    if (convEl.TryGetProperty(\"id\", out var cidEl))\n                                        conversationId = cidEl.GetString();\n\n                                    if (convEl.TryGetProperty(\"expiration_timestamp\", out var expEl))\n                                    {\n                                        long exp = 0;\n                                        if (expEl.ValueKind == JsonValueKind.String &&\n                                            long.TryParse(expEl.GetString(), out var expStr))\n                                            exp = expStr;\n                                        else if (expEl.ValueKind == JsonValueKind.Number &&\n                                                 expEl.TryGetInt64(out var expNum))\n                                            exp = expNum;\n\n                                        if (exp > 0)\n                                        {\n                                            var expiration = DateTimeOffset.FromUnixTimeSeconds(exp);\n                                            convStartedAt = expiration.AddHours(-24);\n                                        }\n                                    }\n                                }\n\n                                // Pricing block (optional)\n                                string? category = null;\n                                bool? billable = null;\n                                decimal? amount = null;\n                                string? currency = null;\n\n                                if (st.TryGetProperty(\"pricing\", out var pEl) &&\n                                    pEl.ValueKind == JsonValueKind.Object)\n                                {\n                                    if (pEl.TryGetProperty(\"category\", out var catEl))\n                                        category = catEl.GetString()?.ToLowerInvariant();\n\n                                    if (pEl.TryGetProperty(\"billable\", out var bilEl) &&\n                                        (bilEl.ValueKind == JsonValueKind.True ||\n                                         bilEl.ValueKind == JsonValueKind.False))\n                                        billable = bilEl.GetBoolean();\n\n                                    if (pEl.TryGetProperty(\"amount\", out var amtEl) &&\n                                        amtEl.ValueKind == JsonValueKind.Number)\n                                        amount = amtEl.GetDecimal();\n\n                                    if (pEl.TryGetProperty(\"currency\", out var curEl) &&\n                                        curEl.ValueKind == JsonValueKind.String)\n                                        currency = curEl.GetString();\n                                }\n\n                                // 1) Status event (if present)\n                                if (!string.IsNullOrWhiteSpace(status))\n                                {\n                                    var ev = new ProviderBillingEvent\n                                    {\n                                        BusinessId = businessId,\n                                        Provider = provider,\n                                        EventType = status, // sent/delivered/read etc.\n                                        ProviderMessageId = providerMessageId,\n                                        ConversationId = conversationId,\n                                        ConversationCategory = category,\n                                        IsChargeable = billable,\n                                        PriceAmount = amount,\n                                        PriceCurrency = currency,\n                                        PayloadJson = payloadJson,\n                                        OccurredAt = occurredAt\n                                    };\n\n                                    if (!string.IsNullOrWhiteSpace(providerMessageId))\n                                    {\n                                        await TryAddBillingEventAsync(ev);\n                                    }\n                                    else\n                                    {\n                                        // fallback: dedupe via conversation id if no provider message id\n                                        if (!await ExistsForConversationAsync(status, conversationId))\n                                        {\n                                            _db.ProviderBillingEvents.Add(ev);\n                                        }\n                                    }\n                                }\n\n                                // 2) Pricing update (if any pricing fields)\n                                var hasAnyPricing =\n                                    !string.IsNullOrWhiteSpace(category) ||\n                                    billable.HasValue ||\n                                    amount.HasValue ||\n                                    !string.IsNullOrWhiteSpace(currency);\n\n                                if (hasAnyPricing)\n                                {\n                                    var pricingEv = new ProviderBillingEvent\n                                    {\n                                        BusinessId = businessId,\n                                        Provider = provider,\n                                        EventType = \"pricing_update\",\n                                        ProviderMessageId = providerMessageId,\n                                        ConversationId = conversationId,\n                                        ConversationCategory = category,\n                                        IsChargeable = billable,\n                                        PriceAmount = amount,\n                                        PriceCurrency = currency,\n                                        PayloadJson = payloadJson,\n                                        OccurredAt = occurredAt\n                                    };\n\n                                    if (!string.IsNullOrWhiteSpace(providerMessageId))\n                                    {\n                                        await TryAddBillingEventAsync(pricingEv);\n                                    }\n                                    else\n                                    {\n                                        if (!await ExistsForConversationAsync(\"pricing_update\", conversationId))\n                                        {\n                                            _db.ProviderBillingEvents.Add(pricingEv);\n                                        }\n                                    }\n                                }\n\n                                // Keep MessageLog in sync (best effort)\n                                var logRow = await FindMatchingMessageLog(businessId, providerMessageId, conversationId);\n                                if (logRow != null)\n                                {\n                                    logRow.Provider = provider;\n                                    if (!string.IsNullOrWhiteSpace(providerMessageId))\n                                        logRow.ProviderMessageId = providerMessageId;\n                                    if (!string.IsNullOrWhiteSpace(conversationId))\n                                        logRow.ConversationId = conversationId;\n                                    if (convStartedAt.HasValue)\n                                        logRow.ConversationStartedAt = convStartedAt;\n\n                                    if (billable.HasValue)\n                                        logRow.IsChargeable = billable.Value;\n                                    if (!string.IsNullOrWhiteSpace(category))\n                                        logRow.ConversationCategory = category;\n                                    if (amount.HasValue)\n                                        logRow.PriceAmount = amount;\n                                    if (!string.IsNullOrWhiteSpace(currency))\n                                        logRow.PriceCurrency = currency;\n                                }\n                            }\n                        }\n                }\n                else if (string.Equals(provider, \"PINNACLE\", StringComparison.OrdinalIgnoreCase))\n                {\n                    // Best-effort scan for pricing blocks\n                    foreach (var pricing in JsonPathAll(doc.RootElement, \"pricing\"))\n                    {\n                        string? category = pricing.TryGetProperty(\"category\", out var catEl)\n                            ? catEl.GetString()?.ToLowerInvariant()\n                            : null;\n\n                        bool? billable =\n                            pricing.TryGetProperty(\"billable\", out var bilEl) &&\n                            (bilEl.ValueKind == JsonValueKind.True ||\n                             bilEl.ValueKind == JsonValueKind.False)\n                                ? bilEl.GetBoolean()\n                                : (bool?)null;\n\n                        decimal? amount = null;\n                        if (pricing.TryGetProperty(\"amount\", out var amtEl) &&\n                            amtEl.ValueKind == JsonValueKind.Number)\n                            amount = amtEl.GetDecimal();\n\n                        string? currency = pricing.TryGetProperty(\"currency\", out var curEl)\n                            ? curEl.GetString()\n                            : null;\n\n                        var parent = TryGetParentObject(doc.RootElement, pricing);\n                        string? providerMessageId =\n                            TryGetString(parent, \"id\")\n                            ?? TryGetString(parent, \"message_id\")\n                            ?? TryGetString(parent, \"wamid\");\n\n                        string? conversationId =\n                            TryGetString(parent, \"conversation_id\")\n                            ?? TryGetNestedString(parent, \"conversation\", \"id\");\n\n                        string? status = TryGetString(parent, \"status\")?.ToLowerInvariant();\n\n                        // Pricing event\n                        var pricingEv = new ProviderBillingEvent\n                        {\n                            BusinessId = businessId,\n                            Provider = provider,\n                            EventType = \"pricing_update\",\n                            ProviderMessageId = providerMessageId,\n                            ConversationId = conversationId,\n                            ConversationCategory = category,\n                            IsChargeable = billable,\n                            PriceAmount = amount,\n                            PriceCurrency = currency,\n                            PayloadJson = payloadJson,\n                            OccurredAt = now\n                        };\n\n                        if (!string.IsNullOrWhiteSpace(providerMessageId))\n                        {\n                            await TryAddBillingEventAsync(pricingEv);\n                        }\n                        else\n                        {\n                            if (!await ExistsForConversationAsync(\"pricing_update\", conversationId))\n                                _db.ProviderBillingEvents.Add(pricingEv);\n                        }\n\n                        // Optional status event from same parent\n                        if (!string.IsNullOrWhiteSpace(status))\n                        {\n                            var statusEv = new ProviderBillingEvent\n                            {\n                                BusinessId = businessId,\n                                Provider = provider,\n                                EventType = status,\n                                ProviderMessageId = providerMessageId,\n                                ConversationId = conversationId,\n                                ConversationCategory = category,\n                                IsChargeable = billable,\n                                PriceAmount = amount,\n                                PriceCurrency = currency,\n                                PayloadJson = payloadJson,\n                                OccurredAt = now\n                            };\n\n                            if (!string.IsNullOrWhiteSpace(providerMessageId))\n                            {\n                                await TryAddBillingEventAsync(statusEv);\n                            }\n                            else\n                            {\n                                if (!await ExistsForConversationAsync(status, conversationId))\n                                    _db.ProviderBillingEvents.Add(statusEv);\n                            }\n                        }\n\n                        // Sync MessageLog where possible\n                        var logRow = await FindMatchingMessageLog(businessId, providerMessageId, conversationId);\n                        if (logRow != null)\n                        {\n                            logRow.Provider = provider;\n                            if (!string.IsNullOrWhiteSpace(providerMessageId))\n                                logRow.ProviderMessageId = providerMessageId;\n                            if (!string.IsNullOrWhiteSpace(conversationId))\n                                logRow.ConversationId = conversationId;\n\n                            if (billable.HasValue)\n                                logRow.IsChargeable = billable.Value;\n                            if (!string.IsNullOrWhiteSpace(category))\n                                logRow.ConversationCategory = category;\n                            if (amount.HasValue)\n                                logRow.PriceAmount = amount;\n                            if (!string.IsNullOrWhiteSpace(currency))\n                                logRow.PriceCurrency = currency;\n                        }\n                    }\n                }\n                else\n                {\n                    // Unknown provider; keep audit trail, but flagged\n                    _db.ProviderBillingEvents.Add(new ProviderBillingEvent\n                    {\n                        BusinessId = businessId,\n                        Provider = provider,\n                        EventType = \"unknown_provider_webhook\",\n                        PayloadJson = payloadJson,\n                        OccurredAt = now\n                    });\n                }\n\n                await _db.SaveChangesAsync();\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"Failed to ingest webhook payload for business {BusinessId}\", businessId);\n            }\n        }\n\n        // -------- helpers --------\n\n\n\n        private async Task<ProviderBillingEvent?> TryAddBillingEventAsync(ProviderBillingEvent ev)\n        {\n            if (string.IsNullOrWhiteSpace(ev.ProviderMessageId))\n            {\n                // No strong key; let caller handle SaveChanges once.\n                _db.ProviderBillingEvents.Add(ev);\n                return ev;\n            }\n\n            _db.ProviderBillingEvents.Add(ev);\n\n            try\n            {\n                await _db.SaveChangesAsync();\n                return ev;\n            }\n            catch (DbUpdateException ex) when (IsUniqueViolation(ex))\n            {\n                _log.LogDebug(\"Duplicate ProviderBillingEvent ignored for message {ProviderMessageId}\", ev.ProviderMessageId);\n                _db.Entry(ev).State = EntityState.Detached;\n                return null;\n            }\n        }\n\n        private static bool IsUniqueViolation(DbUpdateException ex)\n        {\n            // Postgres example\n            if (ex.InnerException is PostgresException pg &&\n                pg.SqlState == PostgresErrorCodes.UniqueViolation)\n            {\n                return true;\n            }\n\n            // For SQL Server / others, check error numbers here.\n\n            return false;\n        }\n\n        private async Task<MessageLog?> FindMatchingMessageLog(Guid businessId, string? providerMessageId, string? conversationId)\n        {\n            if (!string.IsNullOrWhiteSpace(providerMessageId))\n            {\n                var byMsgId = await _db.MessageLogs\n                    .OrderByDescending(x => x.CreatedAt)\n                    .FirstOrDefaultAsync(x =>\n                        x.BusinessId == businessId &&\n                        x.ProviderMessageId == providerMessageId);\n                if (byMsgId != null) return byMsgId;\n            }\n\n            if (!string.IsNullOrWhiteSpace(conversationId))\n            {\n                var byConv = await _db.MessageLogs\n                    .OrderByDescending(x => x.CreatedAt)\n                    .FirstOrDefaultAsync(x =>\n                        x.BusinessId == businessId &&\n                        x.ConversationId == conversationId);\n                if (byConv != null) return byConv;\n            }\n\n            return null;\n        }\n\n        private static IEnumerable<JsonElement> Enumerate(JsonElement root, string name)\n        {\n            if (root.ValueKind != JsonValueKind.Object) yield break;\n            if (!root.TryGetProperty(name, out var arr) || arr.ValueKind != JsonValueKind.Array) yield break;\n\n            foreach (var x in arr.EnumerateArray())\n                yield return x;\n        }\n\n        private static IEnumerable<JsonElement> JsonPathAll(JsonElement root, string name)\n        {\n            if (root.ValueKind == JsonValueKind.Object)\n            {\n                foreach (var p in root.EnumerateObject())\n                {\n                    if (string.Equals(p.Name, name, StringComparison.OrdinalIgnoreCase))\n                        yield return p.Value;\n\n                    foreach (var x in JsonPathAll(p.Value, name))\n                        yield return x;\n                }\n            }\n            else if (root.ValueKind == JsonValueKind.Array)\n            {\n                foreach (var item in root.EnumerateArray())\n                    foreach (var x in JsonPathAll(item, name))\n                        yield return x;\n            }\n        }\n\n        private static JsonElement? TryGetParentObject(JsonElement root, JsonElement node)\n        {\n            // Best-effort: System.Text.Json has no parent pointer; we scan recursively.\n            if (root.ValueKind == JsonValueKind.Object)\n            {\n                foreach (var p in root.EnumerateObject())\n                {\n                    if (p.Value.ValueKind == JsonValueKind.Object)\n                    {\n                        if (object.ReferenceEquals(p.Value, node)) return root;\n                        var cand = TryGetParentObject(p.Value, node);\n                        if (cand.HasValue) return cand;\n                    }\n                    else if (p.Value.ValueKind == JsonValueKind.Array)\n                    {\n                        foreach (var e in p.Value.EnumerateArray())\n                        {\n                            if (object.ReferenceEquals(e, node)) return root;\n                            var cand = TryGetParentObject(e, node);\n                            if (cand.HasValue) return cand;\n                        }\n                    }\n                }\n            }\n            else if (root.ValueKind == JsonValueKind.Array)\n            {\n                foreach (var e in root.EnumerateArray())\n                {\n                    var cand = TryGetParentObject(e, node);\n                    if (cand.HasValue) return cand;\n                }\n            }\n\n            return null;\n        }\n\n        private static string? TryGetString(JsonElement? obj, string name)\n        {\n            if (!obj.HasValue || obj.Value.ValueKind != JsonValueKind.Object)\n                return null;\n\n            return obj.Value.TryGetProperty(name, out var el) ? el.GetString() : null;\n        }\n\n        private static string? TryGetNestedString(JsonElement? obj, string name1, string name2)\n        {\n            if (!obj.HasValue || obj.Value.ValueKind != JsonValueKind.Object)\n                return null;\n\n            if (!obj.Value.TryGetProperty(name1, out var inner) || inner.ValueKind != JsonValueKind.Object)\n                return null;\n\n            return inner.TryGetProperty(name2, out var v) ? v.GetString() : null;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Billing/Services/BillingReadService.cs",
      "sha256": "0298676bbd8d96132ccbaf42ca893f76a03f769606106dfe82a6bed17982b5fc",
      "language": "csharp",
      "size": 7066,
      "content": "using System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\nusing Microsoft.EntityFrameworkCore;\n\nusing xbytechat.api;                               // AppDbContext\nusing xbytechat_api.Features.Billing.DTOs;         // BillingSnapshotDto\nusing xbytechat_api.Features.Billing.Models;       // ProviderBillingEvent (for _db.ProviderBillingEvents)\n\nnamespace xbytechat_api.Features.Billing.Services\n{\n    public class BillingReadService : IBillingReadService\n    {\n        private readonly AppDbContext _db;\n        public BillingReadService(AppDbContext db) => _db = db;\n\n        public async Task<BillingSnapshotDto> GetBusinessBillingSnapshotAsync(Guid businessId, DateOnly from, DateOnly to)\n        {\n            // Build inclusive [from..to] range in UTC\n            var fromDt = from.ToDateTime(TimeOnly.MinValue, DateTimeKind.Utc);\n            var toDt = to.ToDateTime(TimeOnly.MaxValue, DateTimeKind.Utc);\n\n            // 1) Volume: total messages in the period (unchanged behavior)\n            var totalMessages = await _db.MessageLogs.AsNoTracking()\n                .Where(x => x.BusinessId == businessId && x.CreatedAt >= fromDt && x.CreatedAt <= toDt)\n                .CountAsync();\n\n            // 2) Billing source of truth: pricing_update events in the period\n            //    (Only select small projection; we'll dedupe in-memory safely.)\n            var evRaw = await _db.ProviderBillingEvents.AsNoTracking()\n                .Where(e => e.BusinessId == businessId\n                            && e.EventType == \"pricing_update\"\n                            && e.OccurredAt >= fromDt && e.OccurredAt <= toDt)\n                .Select(e => new {\n                    e.Provider,\n                    e.ProviderMessageId,\n                    e.EventType,\n                    e.ConversationId,\n                    e.ConversationCategory,\n                    e.IsChargeable,\n                    e.PriceAmount,\n                    e.PriceCurrency\n                })\n                .ToListAsync();\n\n            // 2a) Defend against webhook replays (if DB unique index not yet deployed)\n            //     Deduplicate on Provider+ProviderMessageId+EventType to drop repeats of the same message event.\n            var evDedup = evRaw\n                .GroupBy(e => new { e.Provider, e.ProviderMessageId, e.EventType })\n                .Select(g => g.First())\n                .ToList();\n\n            // 2b) Group by conversation to compute window-level metrics\n            var convGroups = evDedup\n                .Where(e => !string.IsNullOrWhiteSpace(e.ConversationId))\n                .GroupBy(e => e.ConversationId!)\n                .ToList();\n\n            // Chargeable windows: any event in the conversation marked billable == true\n            var chargeableWindows = convGroups.Count(g => g.Any(x => x.IsChargeable == true));\n\n            // Free windows: conversations explicitly marked billable == false and NOT marked true anywhere\n            var freeWindows = convGroups.Count(g => g.Any(x => x.IsChargeable == false) && !g.Any(x => x.IsChargeable == true));\n\n            // Count by category (per conversation, pick first non-empty category; default \"unknown\")\n            var countByCategory = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);\n            foreach (var g in convGroups)\n            {\n                var category = g.Select(x => x.ConversationCategory)\n                                .FirstOrDefault(s => !string.IsNullOrWhiteSpace(s))\n                                ?.ToLowerInvariant() ?? \"unknown\";\n                countByCategory[category] = countByCategory.TryGetValue(category, out var c) ? c + 1 : 1;\n            }\n\n            // Spend by currency: for each conversation, take the latest non-null amount (if any), then sum by currency\n            var spendByCurrency = new Dictionary<string, decimal>(StringComparer.OrdinalIgnoreCase);\n            foreach (var g in convGroups)\n            {\n                // Prefer an explicit currency on any event in the conversation\n                var amountWithCurrency = g.LastOrDefault(x => x.PriceAmount.HasValue && !string.IsNullOrWhiteSpace(x.PriceCurrency));\n                if (amountWithCurrency?.IsChargeable == true) // only count billable windows\n                {\n                    var cur = amountWithCurrency.PriceCurrency!.ToUpperInvariant();\n                    var amt = amountWithCurrency.PriceAmount!.Value;\n                    spendByCurrency[cur] = spendByCurrency.TryGetValue(cur, out var sum) ? sum + amt : amt;\n                }\n            }\n\n            // Compose DTO\n            var dto = new BillingSnapshotDto\n            {\n                TotalMessages = totalMessages,\n                // These two are now \"window\"-level metrics (conversations) â€“ most accurate for billing with Meta.\n                ChargeableMessages = chargeableWindows,\n                FreeMessages = freeWindows,\n                CountByCategory = countByCategory,\n                SpendByCurrency = spendByCurrency\n            };\n\n            return dto;\n        }\n    }\n}\n\n\n//using System;\n//using System.Linq;\n//using System.Threading.Tasks;\n//using Microsoft.EntityFrameworkCore;\n//using xbytechat.api;\n//using xbytechat_api.Features.Billing.DTOs;\n\n//namespace xbytechat_api.Features.Billing.Services\n//{\n//    public class BillingReadService : IBillingReadService\n//    {\n//        private readonly AppDbContext _db;\n//        public BillingReadService(AppDbContext db) => _db = db;\n\n//        public async Task<BillingSnapshotDto> GetBusinessBillingSnapshotAsync(Guid businessId, DateOnly from, DateOnly to)\n//        {\n//            var fromDt = from.ToDateTime(TimeOnly.MinValue, DateTimeKind.Utc);\n//            var toDt = to.ToDateTime(TimeOnly.MaxValue, DateTimeKind.Utc);\n\n//            var q = _db.MessageLogs.AsNoTracking()\n//                    .Where(x => x.BusinessId == businessId && x.CreatedAt >= fromDt && x.CreatedAt <= toDt);\n\n//            var list = await q.Select(x => new {\n//                x.IsChargeable,\n//                x.ConversationCategory,\n//                x.PriceAmount,\n//                x.PriceCurrency\n//            }).ToListAsync();\n\n//            var dto = new BillingSnapshotDto\n//            {\n//                TotalMessages = list.Count,\n//                ChargeableMessages = list.Count(x => x.IsChargeable == true),\n//                FreeMessages = list.Count(x => x.IsChargeable == false)\n//            };\n\n//            dto.CountByCategory = list\n//                .GroupBy(x => string.IsNullOrWhiteSpace(x.ConversationCategory) ? \"unknown\" : x.ConversationCategory!.ToLowerInvariant())\n//                .ToDictionary(g => g.Key, g => g.Count());\n\n//            dto.SpendByCurrency = list\n//                .Where(x => x.PriceAmount.HasValue && !string.IsNullOrWhiteSpace(x.PriceCurrency))\n//                .GroupBy(x => x.PriceCurrency!)\n//                .ToDictionary(g => g.Key, g => g.Sum(v => v.PriceAmount!.Value));\n\n//            return dto;\n//        }\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/Billing/Services/IBillingIngestService.cs",
      "sha256": "8678a1ec3a5979b124caa81faa47d93d5ca21bd8c0d97bf35a8d55bb50824bdf",
      "language": "csharp",
      "size": 416,
      "content": "using System;\nusing System.Threading.Tasks;\nusing xbytechat_api.Features.Billing.DTOs;\n\nnamespace xbytechat_api.Features.Billing.Services\n{\n    public interface IBillingIngestService\n    {\n        Task IngestFromSendResponseAsync(Guid businessId, Guid messageLogId, string provider, string rawResponseJson);\n        Task IngestFromWebhookAsync(Guid businessId, string provider, string payloadJson);\n        \n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Billing/Services/IBillingReadService.cs",
      "sha256": "146ab2ebc0dea7d43cd6d050c51c28118cf4c7655b369657e198861aa6c9c3ca",
      "language": "csharp",
      "size": 306,
      "content": "using System;\nusing System.Threading.Tasks;\nusing xbytechat_api.Features.Billing.DTOs;\n\nnamespace xbytechat_api.Features.Billing.Services\n{\n    public interface IBillingReadService\n    {\n        Task<BillingSnapshotDto> GetBusinessBillingSnapshotAsync(Guid businessId, DateOnly from, DateOnly to);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/BusinessModule/Controllers/BusinessesController.cs",
      "sha256": "daa2d6b5b6ab777793c363889afd8f0df25e82da0a53c1aa991d12f4f151edce",
      "language": "csharp",
      "size": 7256,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Helpers;\nusing Serilog;\nusing System.Security.Claims;\nusing xbytechat.api.Features.BusinessModule.DTOs;\nusing xbytechat.api.Features.BusinessModule.Models;\nusing xbytechat.api.Features.BusinessModule.Services;\nusing Microsoft.AspNetCore.Authorization;\n\nnamespace xbytechat.api.Features.BusinessModule.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class BusinessesController : ControllerBase\n    {\n        private readonly IBusinessService _businessService;\n\n        public BusinessesController(IBusinessService businessService)\n        {\n            _businessService = businessService;\n        }\n\n\n\n        [HttpGet(\"pending\")]\n        [Authorize(Roles = \"admin,superadmin,partner\")] // partners see scoped; admin/superadmin see ALL\n        public async Task<IActionResult> GetPendingBusinesses([FromQuery] string? status = null)\n        {\n            try\n            {\n                // Read role/id from multiple possible claim types\n                var role = User.FindFirst(ClaimTypes.Role)?.Value\n                           ?? User.FindFirst(\"role\")?.Value\n                           ?? User.FindFirst(\"roles\")?.Value\n                           ?? \"\";\n\n                var userId = User.FindFirst(\"id\")?.Value\n                           ?? User.FindFirst(ClaimTypes.NameIdentifier)?.Value\n                           ?? User.FindFirst(\"sub\")?.Value\n                           ?? \"\";\n\n                var result = await _businessService.GetPendingBusinessesAsync(role, userId, status);\n                return Ok(ResponseResult.SuccessInfo(\"âœ… Pending businesses fetched successfully.\", result));\n            }\n            catch\n            {\n                return StatusCode(500, ResponseResult.ErrorInfo(\"âŒ Failed to fetch pending businesses. Please try again later.\"));\n            }\n        }\n\n\n        // âœ… Get business by ID (used for profile completion)\n\n        [HttpGet(\"{id}\")]\n        public async Task<IActionResult> GetBusinessById(Guid id)\n        {\n            try\n            {\n                var business = await _businessService.GetByIdAsync(id);\n                if (business == null)\n                    return NotFound(ResponseResult.ErrorInfo(\"âŒ Business not found.\"));\n\n                return Ok(business);\n            }\n            catch (Exception ex)\n            {\n                return StatusCode(500, ResponseResult.ErrorInfo(\"ðŸš¨ Failed to fetch business. \" + ex.Message));\n            }\n        }\n\n        //[HttpPut(\"assigned-to/{id}\")]\n        [HttpPut(\"{id}\")]\n        [Authorize]\n        public async Task<IActionResult> UpdateBusiness(Guid id, [FromBody] UpdateBusinessDto dto)\n        {\n            if (dto == null)\n                return BadRequest(ResponseResult.ErrorInfo(\"âŒ Invalid payload.\"));\n\n            var result = await _businessService.UpdateBusinessAsync(id, dto);\n\n            if (!result.Success)\n                return BadRequest(result);\n\n            return Ok(result);\n        }\n\n        // ðŸŸ¢ Approve a business\n        [HttpPost(\"approve/{id}\")]\n        public async Task<IActionResult> Approve(Guid id)\n        {\n            try\n            {\n                var result = await _businessService.ApproveBusinessAsync(id);\n\n                if (result.Success)\n                {\n                    // âœ… Optional Success Logging\n                    Log.Information(\"âœ… Business approved successfully. BusinessId: {BusinessId}\", id);\n                    return Ok(result);\n                }\n                else\n                {\n                    // âœ… Optional Warning Logging\n                    Log.Warning(\"âš ï¸ Business approval failed. BusinessId: {BusinessId} - Message: {Message}\", id, result.Message);\n                    return BadRequest(result);\n                }\n            }\n            catch (Exception ex)\n            {\n                // âœ… Proper Error Logging\n                Log.Error(ex, \"âŒ Exception occurred while approving business. BusinessId: {BusinessId}\", id);\n\n                return StatusCode(500, ResponseResult.ErrorInfo(\n                    \"âŒ Something went wrong while approving business. Please try again later.\"\n                ));\n            }\n        }\n\n\n        // ðŸ”´ Reject a business\n        [HttpPost(\"reject/{id}\")]\n        public async Task<IActionResult> Reject(Guid id)\n        {\n            try\n            {\n                var result = await _businessService.RejectBusinessAsync(id);\n                return result.Success ? Ok(result) : NotFound(result);\n            }\n            catch (Exception ex)\n            {\n                return StatusCode(500, ResponseResult.ErrorInfo(\"âŒ Failed to reject business. \" + ex.Message));\n            }\n        }\n\n        // ðŸŸ¡ Put a business on hold\n        [HttpPost(\"hold/{id}\")]\n        public async Task<IActionResult> Hold(Guid id)\n        {\n            try\n            {\n                var result = await _businessService.HoldBusinessAsync(id);\n                return result.Success ? Ok(result) : NotFound(result);\n            }\n            catch (Exception ex)\n            {\n                return StatusCode(500, ResponseResult.ErrorInfo(\"âŒ Failed to hold business. \" + ex.Message));\n            }\n        }\n\n        // ðŸŸ¢ Assign Plan Endpoint\n        [HttpPut(\"{id}/plan\")]\n        [Authorize(Roles = \"superadmin,admin,partner\")]\n        public async Task<IActionResult> AssignPlan(Guid id, [FromBody] AssignPlanDto dto)\n        {\n            if (dto == null || dto.PlanId == Guid.Empty)\n                return BadRequest(ResponseResult.ErrorInfo(\"âŒ Invalid plan ID.\"));\n\n            var result = await _businessService.AssignPlanAsync(id, dto.PlanId);\n            return result.Success ? Ok(result) : BadRequest(result);\n        }\n\n        // ðŸ›  Complete profile after signup\n        [HttpPost(\"profile-completion/{businessId}\")]\n        public async Task<IActionResult> CompleteProfile(Guid businessId, [FromBody] ProfileCompletionDto dto)\n        {\n            try\n            {\n                var result = await _businessService.CompleteProfileAsync(businessId, dto);\n                return result.Success ? Ok(result) : BadRequest(result);\n            }\n            catch (Exception ex)\n            {\n                return StatusCode(500, ResponseResult.ErrorInfo(\"âŒ Failed to update profile. \" + ex.Message));\n            }\n        }\n\n        [HttpGet(\"approved\")]\n        [Authorize(Roles = \"superadmin,admin,partner,reseller\")]\n        public async Task<IActionResult> GetApprovedBusinesses()\n        {\n            var result = await _businessService.GetApprovedBusinessesAsync();\n            return Ok(result);\n        }\n\n        [HttpDelete(\"{id}\")]\n        [Authorize(Roles = \"superadmin,admin\")]\n        public async Task<IActionResult> Delete(Guid id)\n        {\n            try\n            {\n                var result = await _businessService.HardDeleteBusinessAsync(id);\n                return result.Success ? Ok(result) : BadRequest(result);\n            }\n            catch (Exception ex)\n            {\n                return StatusCode(500, ResponseResult.ErrorInfo(\"âŒ Failed to delete business. \" + ex.Message));\n            }\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/BusinessModule/DTOs/ApprovedBusinessDto.cs",
      "sha256": "2865f6c70c051e3a0e928c5036af77c16484d73c0b52ee5dbaa8c467d0f370de",
      "language": "csharp",
      "size": 389,
      "content": "using System;\n\nnamespace xbytechat.api.Features.BusinessModule.DTOs\n{\n    public class ApprovedBusinessDto\n    {\n        public Guid Id { get; set; }\n        public string CompanyName { get; set; }\n        public string BusinessEmail { get; set; }\n        public Guid? PlanId { get; set; }\n        public string? PlanName { get; set; }\n        public string? LogoUrl { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/BusinessModule/DTOs/AssignPlanDto.cs",
      "sha256": "af9e563e924d864356b611c4f2da381d3f2974aed4161750db956d87810b2524",
      "language": "csharp",
      "size": 206,
      "content": "using System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.BusinessModule.DTOs\n{\n    public class AssignPlanDto\n    {\n        [Required]\n        public Guid PlanId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/BusinessModule/DTOs/PendingBusinessDto.cs",
      "sha256": "f60e58c1239780719d05d4f318d05c9c3506e5dc308daecb51fa2feb7b3286cd",
      "language": "csharp",
      "size": 575,
      "content": "namespace xbytechat.api.Features.BusinessModule.DTOs\n{\n    public class PendingBusinessDto\n    {\n        public Guid BusinessId { get; set; }\n        public string CompanyName { get; set; }\n        public string BusinessEmail { get; set; }\n        public string? RepresentativeName { get; set; }\n        public string? Phone { get; set; }\n        public string Plan { get; set; }\n        public DateTime CreatedAt { get; set; }\n        public bool? IsApproved { get; set; }\n        public string Status { get; set; }\n        public DateTime? ApprovedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/BusinessModule/DTOs/ProfileCompletionDto.cs",
      "sha256": "cbd238cd045c0ee7bfc5061311058fa84005f29244727a11ef5b7a6eedbcf64f",
      "language": "csharp",
      "size": 489,
      "content": "namespace xbytechat.api.Features.BusinessModule.DTOs\n{\n    public class ProfileCompletionDto\n    {\n        public string? BusinessName { get; set; }\n        public string? ReperesentativeName { get; set; }\n        public string? CompanyPhone { get; set; }\n        public string? Phone { get; set; }\n        public string? Website { get; set; }\n        public string? Address { get; set; }\n        public string? Industry { get; set; }\n        public string? LogoUrl { get; set; }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/BusinessModule/DTOs/SignupBusinessDto.cs",
      "sha256": "daebace2d54e91a96825decc469c8acd57822d3e74bd5271ca80792e36cbb30e",
      "language": "csharp",
      "size": 717,
      "content": "using System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.BusinessModule.DTOs\n{\n    public class SignupBusinessDto\n    {\n        [Required]\n        public string CompanyName { get; set; }\n\n        [Required]\n        [EmailAddress]\n        public string Email { get; set; }\n\n        [Required]\n        public string Password { get; set; }\n\n        public string? RepresentativeName { get; set; }\n\n        public string? Phone { get; set; }\n        public string RoleName { get; set; } = \"business\"; // Default to business role\n\n        // ðŸ†• NEW FIELD (Internal use only)\n        public Guid? CreatedByPartnerId { get; set; } // to assign the business to a specific user/agent/partner}\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/BusinessModule/DTOs/UpdateBusinessDto.cs",
      "sha256": "d220065497b49d19e2e1ee681723ac965ddecc155c3de606f397fbdcc87ac585",
      "language": "csharp",
      "size": 756,
      "content": "namespace xbytechat.api.Features.BusinessModule.DTOs\n{\n    /// <summary>\n    /// Allowed fields for business profile updates.\n    /// No lifecycle / plan / ownership fields here.\n    /// </summary>\n    public class UpdateBusinessDto\n    {\n        public string? CompanyName { get; set; }\n        public string? BusinessName { get; set; }\n        public string? BusinessEmail { get; set; }\n        public string? Phone { get; set; }\n        public string? CompanyPhone { get; set; }\n        public string? Website { get; set; }\n        public string? Address { get; set; }\n        public string? Industry { get; set; }\n        public string? LogoUrl { get; set; }\n        public string? Tags { get; set; }\n        public string? Notes { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/BusinessModule/Models/Business.cs",
      "sha256": "fa10e5438adc1fc17627162d4bff022f905891ce609b37ebbd62dc948e7e9924",
      "language": "csharp",
      "size": 3191,
      "content": "using System;\nusing System.Collections.Generic;\nusing xbytechat.api.AuthModule.Models;\nusing xbytechat.api.Features.AccessControl.Models;\nusing xbytechat.api.Features.CampaignModule.Models;\nusing xbytechat.api.Features.ChatInbox.Models;\nusing xbytechat.api.Features.MessageManagement.DTOs;\nusing xbytechat.api.Models.BusinessModel;\nusing xbytechat_api.WhatsAppSettings.Models;\n\nnamespace xbytechat.api.Features.BusinessModule.Models\n{\n    public class Business\n    {\n        public Guid Id { get; set; }\n\n        // ðŸ¢ Basic Info\n        public string? CompanyName { get; set; }\n        public string BusinessName { get; set; }\n        public string BusinessEmail { get; set; }  // Not used for login, just business contact\n        public string? RepresentativeName { get; set; }\n\n        public Guid? CreatedByPartnerId { get; set; }\n        public string? Phone { get; set; }\n        public string? CompanyPhone { get; set; }\n        public string? Website { get; set; }\n        public string? Address { get; set; }\n        public string? Industry { get; set; }\n        public string? LogoUrl { get; set; }\n\n        // ðŸ“¦ SaaS Plan & Status using Enums\n        // public enum PlanType { Basic, Smart, Advanced } -- moved to bisinessinfo\n        // public PlanType Plan { get; set; } = PlanType.Basic;  // moved to bisinessinfo\n        public enum StatusType { Pending, Approved, Rejected, Hold }\n        public StatusType Status { get; set; } = StatusType.Pending;  // Default to Pending\n\n        // ðŸ“ Metadata\n        public string? Tags { get; set; }\n        public string? Source { get; set; }\n        public string? Notes { get; set; }\n\n        // ðŸ“… Timestamps\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n        public string? CreatedBy { get; set; }\n        public bool IsApproved { get; set; } = false;\n        public string? ApprovedBy { get; set; }\n        public DateTime? ApprovedAt { get; set; }\n        public DateTime? LastLoginAt { get; set; }\n\n        // ðŸ—‘ Soft Deletion\n        public bool IsDeleted { get; set; } = false;\n        public DateTime? DeletedAt { get; set; }\n        public string? DeletedBy { get; set; }\n\n        // ðŸ‘¥ Navigation Property - List of Users (nullable if no users)\n        public List<User> Users { get; set; } = new();\n\n\n        public ICollection<MessageStatusLog> MessageStatusLogs { get; set; }\n        public ICollection<Campaign> Campaigns { get; set; } = new List<Campaign>();\n        // ðŸ”— Plan Info linked\n\n        /// This is a one-to-one relationship with BusinessPlanInfo\n        public BusinessPlanInfo? BusinessPlanInfo { get; set; }\n\n        public Guid? PlanId { get; set; } // Nullable in case no plan is assigned yet\n        public Plan? Plan { get; set; }   // Navigation property to the Plan entity\n\n       // public WhatsAppSettingEntity WhatsAppSettings { get; set; }\n        public ICollection<WhatsAppSettingEntity> WhatsAppSettings { get; set; }\n\n        public ICollection<Role> Roles { get; set; }\n\n        // ðŸ“¥ Inbox visibility policy (Shared vs Restricted)\n        public InboxVisibilityMode InboxVisibilityMode { get; set; } = InboxVisibilityMode.SharedInInbox;\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/BusinessModule/Services/BusinessService.cs",
      "sha256": "2a22f3f678e045f3f9c6ce389dc02a6e617b2fc784989532a484ac89669f49f3",
      "language": "csharp",
      "size": 30284,
      "content": "using Microsoft.AspNetCore.Identity;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing System.Security.Claims;\nusing System.Security.Cryptography;\nusing System.Text;\nusing xbytechat.api.AuthModule.Models;\nusing xbytechat.api.Features.AccessControl.Models;\nusing xbytechat.api.Features.AuditTrail.Models;\nusing xbytechat.api.Features.AuditTrail.Services;\nusing xbytechat.api.Features.BusinessModule.DTOs;\nusing xbytechat.api.Features.BusinessModule.Models;\nusing xbytechat.api.Features.PlanManagement.Models;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Models.BusinessModel;\nusing xbytechat.api.Repositories.Interfaces;\nusing xbytechat.api.Features.AccessControl.Models;\nusing xbytechat.api.Features.Entitlements.Models;\nusing xbytechat.api.Features.Entitlements;\n\nnamespace xbytechat.api.Features.BusinessModule.Services\n{\n    public class BusinessService : IBusinessService\n    {\n        private readonly IGenericRepository<Business> _businessRepo;\n        private readonly IGenericRepository<User> _userRepo;\n        private readonly IGenericRepository<Role> _roleRepo;\n        private readonly IGenericRepository<Plan> _planRepo;\n        private readonly IGenericRepository<PlanQuota> _planQuotaRepo;\n        private readonly IAuditLogService _auditLogService;\n        private readonly IHttpContextAccessor _httpContextAccessor;\n        // inside BusinessService class (class scope, not inside a method)\n        private static readonly Guid BASIC_PLAN_ID = Guid.Parse(\"5f9f5de1-a0b2-48ba-b03d-77b27345613f\");\n        private readonly IPasswordHasher<User> _passwordHasher;\n\n        private readonly AppDbContext _db;\n        public BusinessService(\n            AppDbContext db,\n            IGenericRepository<Business> businessRepo,\n            IGenericRepository<User> userRepo,\n            IGenericRepository<Role> roleRepo,\n            IGenericRepository<Plan> planRepo,\n            IGenericRepository<PlanQuota> planQuotaRepo,\n            IAuditLogService auditLogService,\n            IHttpContextAccessor httpContextAccessor, IPasswordHasher<User> passwordHasher)\n        {\n            _db = db;\n            _passwordHasher = passwordHasher;\n            _businessRepo = businessRepo;\n            _userRepo = userRepo;\n            _roleRepo = roleRepo;\n            _planRepo = planRepo;\n            _planQuotaRepo = planQuotaRepo;\n            _auditLogService = auditLogService;\n            _httpContextAccessor = httpContextAccessor;\n        }\n\n        //public async Task<ResponseResult> SignupBusinessAsync(SignupBusinessDto dto)\n        //{\n        //    var normalizedEmail = dto.Email.Trim().ToLower();\n        //    var existing = await _userRepo.FirstOrDefaultAsync(u => u.Email == normalizedEmail);\n        //    if (existing != null)\n        //        return ResponseResult.ErrorInfo(\"âŒ Email already exists\");\n\n        //    var business = new Business\n        //    {\n        //        Id = Guid.NewGuid(),\n        //        CompanyName = dto.CompanyName,\n        //        BusinessName = dto.CompanyName,\n        //        BusinessEmail = normalizedEmail,\n        //        RepresentativeName = dto.RepresentativeName,\n        //        Phone = dto.Phone,\n        //        CreatedByPartnerId = dto.CreatedByPartnerId,\n        //        Status = Business.StatusType.Pending,\n        //        // Plan = PlanType.Basic,\n        //        IsApproved = false,\n        //        CreatedAt = DateTime.UtcNow,\n        //        PlanId = BASIC_PLAN_ID   // âœ… hard-code Basic plan here\n        //    };\n        //    // STEP 2: Create Plan Info separately\n        //    var planInfo = new BusinessPlanInfo\n        //    {\n        //        BusinessId = business.Id,\n        //        Plan = PlanType.Basic,\n        //        TotalMonthlyQuota = 1000,\n        //        RemainingMessages = 1000,\n        //        QuotaResetDate = DateTime.UtcNow.AddMonths(1),\n        //        WalletBalance = 0\n        //    };\n        //    // STEP 3: Link them\n        //    business.BusinessPlanInfo = planInfo;\n        //    // STEP 4: Save both\n        //    await _businessRepo.AddAsync(business);\n        //    await _businessRepo.SaveAsync();\n\n        //    var role = await _roleRepo.FirstOrDefaultAsync(r => r.Name.ToLower() == dto.RoleName.Trim().ToLower());\n\n        //    if (role == null)\n        //        return ResponseResult.ErrorInfo(\"âŒ Invalid role specified\");\n\n        //    var user = new User\n        //    {\n        //        Id = Guid.NewGuid(),\n        //        Name = dto.CompanyName,\n        //        Email = normalizedEmail,\n        //        PasswordHash = HashPassword(dto.Password),\n        //        //PasswordHash = _passwordHasher.HashPassword(null!, dto.Password),\n        //        Role = role,\n        //        Status = \"Pending\",\n        //        BusinessId = business.Id\n        //    };\n\n        //    await _userRepo.AddAsync(user);\n        //    await _userRepo.SaveAsync();\n\n        //    await _auditLogService.SaveLogAsync(new AuditLog\n        //    {\n        //        BusinessId = business.Id,\n        //        PerformedByUserId = user.Id,\n        //        PerformedByUserName = user.Name,\n        //        RoleAtTime = \"business\",\n        //        ActionType = \"business.signup\",\n        //        Description = $\"New business signup: {business.CompanyName}\",\n        //        IPAddress = _httpContextAccessor.HttpContext?.Connection?.RemoteIpAddress?.ToString(),\n        //        UserAgent = _httpContextAccessor.HttpContext?.Request?.Headers[\"User-Agent\"].ToString()\n        //    });\n\n        //    return ResponseResult.SuccessInfo(\"âœ… Signup successful. Pending approval.\", new { BusinessId = business.Id });\n        //}\n\n        public async Task<ResponseResult> SignupBusinessAsync(SignupBusinessDto dto)\n        {\n            var normalizedEmail = dto.Email.Trim().ToLower();\n            var existing = await _userRepo.FirstOrDefaultAsync(u => u.Email == normalizedEmail);\n            if (existing != null)\n                return ResponseResult.ErrorInfo(\"âŒ Email already exists\");\n\n            var basicPlanId = Guid.Parse(\"5f9f5de1-a0b2-48ba-b03d-77b27345613f\");\n            var business = new Business\n            {\n                Id = Guid.NewGuid(),\n                CompanyName = dto.CompanyName,\n                BusinessName = dto.CompanyName,\n                BusinessEmail = normalizedEmail,\n                RepresentativeName = dto.RepresentativeName,\n                Phone = dto.Phone,\n                CreatedByPartnerId = dto.CreatedByPartnerId,\n                Status = Business.StatusType.Pending,\n                IsApproved = false,\n                CreatedAt = DateTime.UtcNow,\n\n                // âŒ IMPORTANT: no plan yet at signup\n                PlanId = basicPlanId,              // if Guid?  (or just omit setting it)\n                                            // BusinessPlanInfo = null   // will be created at plan-selection time\n            };\n\n            // Only save the business now, without plan info\n            await _businessRepo.AddAsync(business);\n            await _businessRepo.SaveAsync();\n\n            var role = await _roleRepo.FirstOrDefaultAsync(\n                r => r.Name.ToLower() == dto.RoleName.Trim().ToLower()\n            );\n\n            if (role == null)\n                return ResponseResult.ErrorInfo(\"âŒ Invalid role specified\");\n\n            var user = new User\n            {\n                Id = Guid.NewGuid(),\n                Name = dto.CompanyName,\n                Email = normalizedEmail,\n                PasswordHash = HashPassword(dto.Password),\n                Role = role,\n                Status = \"Pending\",\n                BusinessId = business.Id\n            };\n\n            await _userRepo.AddAsync(user);\n            await _userRepo.SaveAsync();\n\n            await _auditLogService.SaveLogAsync(new AuditLog\n            {\n                BusinessId = business.Id,\n                PerformedByUserId = user.Id,\n                PerformedByUserName = user.Name,\n                RoleAtTime = \"business\",\n                ActionType = \"business.signup\",\n                Description = $\"New business signup: {business.CompanyName}\",\n                IPAddress = _httpContextAccessor.HttpContext?.Connection?.RemoteIpAddress?.ToString(),\n                UserAgent = _httpContextAccessor.HttpContext?.Request?.Headers[\"User-Agent\"].ToString()\n            });\n\n            return ResponseResult.SuccessInfo(\n                \"âœ… Signup successful. Pending approval.\",\n                new { BusinessId = business.Id }\n            );\n        }\n\n\n\n        public async Task<ResponseResult> UpdateBusinessAsync(Guid businessId, UpdateBusinessDto dto)\n        {\n            if (dto == null)\n                return ResponseResult.ErrorInfo(\"âŒ Invalid business update payload.\");\n\n            var business = await _businessRepo.AsQueryable()\n                .FirstOrDefaultAsync(b => b.Id == businessId && !b.IsDeleted);\n\n            if (business == null)\n                return ResponseResult.ErrorInfo(\"âŒ Business not found.\");\n\n            // ---- Authorization: who is allowed to edit this business? ----\n\n            var httpContext = _httpContextAccessor.HttpContext;\n            var user = httpContext?.User;\n\n            if (user == null || !user.Identity?.IsAuthenticated == true)\n                return ResponseResult.ErrorInfo(\"âŒ Unauthorized. Please login again.\");\n\n            var role =\n                user.FindFirst(ClaimTypes.Role)?.Value ??\n                user.FindFirst(\"role\")?.Value ??\n                user.FindFirst(\"roles\")?.Value ??\n                string.Empty;\n\n            var userIdStr =\n                user.FindFirst(\"id\")?.Value ??\n                user.FindFirst(ClaimTypes.NameIdentifier)?.Value ??\n                user.FindFirst(\"sub\")?.Value ??\n                string.Empty;\n\n            Guid.TryParse(userIdStr, out var userId);\n\n            var roleLc = (role ?? string.Empty).ToLowerInvariant();\n            var isAdmin = roleLc == \"admin\" || roleLc == \"superadmin\";\n            var isPartner = roleLc == \"partner\";\n            var isAssignedPartner = isPartner && business.CreatedByPartnerId.HasValue &&\n                                    business.CreatedByPartnerId.Value == userId;\n\n            var isBusinessUser = false;\n            if (userId != Guid.Empty)\n            {\n                var userEntity = await _userRepo.AsQueryable()\n                    .AsNoTracking()\n                    .FirstOrDefaultAsync(u => u.Id == userId);\n\n                if (userEntity != null && userEntity.BusinessId == business.Id)\n                    isBusinessUser = true;\n            }\n\n            if (!isAdmin && !isAssignedPartner && !isBusinessUser)\n            {\n                return ResponseResult.ErrorInfo(\"â›” You are not allowed to update this business.\");\n            }\n\n            // ---- Apply only allowed fields ----\n\n            if (!string.IsNullOrWhiteSpace(dto.CompanyName))\n                business.CompanyName = dto.CompanyName.Trim();\n\n            if (!string.IsNullOrWhiteSpace(dto.BusinessName))\n                business.BusinessName = dto.BusinessName.Trim();\n\n            if (!string.IsNullOrWhiteSpace(dto.BusinessEmail))\n                business.BusinessEmail = dto.BusinessEmail.Trim().ToLowerInvariant();\n\n            if (!string.IsNullOrWhiteSpace(dto.Phone))\n                business.Phone = dto.Phone.Trim();\n\n            if (!string.IsNullOrWhiteSpace(dto.CompanyPhone))\n                business.CompanyPhone = dto.CompanyPhone.Trim();\n\n            if (!string.IsNullOrWhiteSpace(dto.Website))\n                business.Website = dto.Website.Trim();\n\n            if (!string.IsNullOrWhiteSpace(dto.Address))\n                business.Address = dto.Address.Trim();\n\n            if (!string.IsNullOrWhiteSpace(dto.Industry))\n                business.Industry = dto.Industry.Trim();\n\n            if (!string.IsNullOrWhiteSpace(dto.LogoUrl))\n                business.LogoUrl = dto.LogoUrl.Trim();\n\n            if (!string.IsNullOrWhiteSpace(dto.Tags))\n                business.Tags = dto.Tags.Trim();\n\n            if (!string.IsNullOrWhiteSpace(dto.Notes))\n                business.Notes = dto.Notes.Trim();\n\n            // âŒ DO NOT touch:\n            // - business.Status\n            // - business.IsApproved\n            // - business.PlanId\n            // - business.BusinessPlanInfo\n            // - business.CreatedByPartnerId\n            // - deletion flags\n            // These are controlled only by dedicated admin/partner flows.\n\n            try\n            {\n                _businessRepo.Update(business);\n                await _businessRepo.SaveAsync();\n                return ResponseResult.SuccessInfo(\"âœ… Business updated successfully.\");\n            }\n            catch (Exception ex)\n            {\n                return ResponseResult.ErrorInfo(\"âŒ Failed to update business: \" + ex.Message);\n            }\n        }\n\n\n        public async Task<List<PendingBusinessDto>> GetPendingBusinessesAsync(string role, string userId, string? status = null)\n        {\n            try\n            {\n                var roleLc = (role ?? \"\").ToLowerInvariant();\n\n                // base: not deleted\n                IQueryable<Business> q = _businessRepo.AsQueryable()\n                    .AsNoTracking()\n                    .Include(b => b.BusinessPlanInfo)\n                    .Where(b => !b.IsDeleted);\n\n                // Filtering by status\n                if (!string.IsNullOrEmpty(status))\n                {\n                    var statusLc = status.ToLowerInvariant();\n                    if (statusLc == \"pending\")\n                        q = q.Where(b => b.Status == Business.StatusType.Pending);\n                    else if (statusLc == \"rejected\" || statusLc == \"reject\")\n                        q = q.Where(b => b.Status == Business.StatusType.Rejected);\n                    else if (statusLc == \"hold\" || statusLc == \"on-hold\" || statusLc == \"on_hold\")\n                        q = q.Where(b => b.Status == Business.StatusType.Hold);\n                    else if (statusLc == \"approved\")\n                        q = q.Where(b => b.Status == Business.StatusType.Approved);\n                }\n                else\n                {\n                    // Default to Pending if no status filter provided\n                    q = q.Where(b => b.Status == Business.StatusType.Pending);\n                }\n\n                // scope for partner\n                if (roleLc == \"partner\")\n                {\n                    if (!Guid.TryParse(userId, out var partnerId)) return new();\n                    q = q.Where(b => b.CreatedByPartnerId == partnerId);\n                }\n                else if (roleLc != \"admin\" && roleLc != \"superadmin\")\n                {\n                    return new(); // anyone else: nothing\n                }\n\n                var items = await q.OrderByDescending(b => b.CreatedAt).ToListAsync();\n\n                // Map to your existing DTO\n                return items.Select(b => new PendingBusinessDto\n                {\n                    BusinessId = b.Id,\n                    CompanyName = b.CompanyName ?? \"\",\n                    BusinessEmail = b.BusinessEmail ?? \"\",\n                    RepresentativeName = b.RepresentativeName ?? \"\",\n                    Phone = b.Phone ?? \"\",\n                    Plan = b.BusinessPlanInfo?.Plan.ToString() ?? \"Unknown\",\n                    CreatedAt = b.CreatedAt,\n                    IsApproved = b.IsApproved,\n                    Status = b.Status.ToString(),\n                    ApprovedAt = b.ApprovedAt\n                }).ToList();\n            }\n            catch\n            {\n                return new();\n            }\n        }\n\n        public async Task<ResponseResult> ApproveBusinessAsync(Guid businessId)\n        {\n            var business = await _businessRepo\n                .AsQueryable()\n                .Include(b => b.Users)\n                .FirstOrDefaultAsync(b => b.Id == businessId);\n\n            if (business == null)\n                return ResponseResult.ErrorInfo(\"âŒ Business not found.\");\n\n            // âœ… Current Logged-in User Details\n            var httpContext = _httpContextAccessor.HttpContext;\n            var currentUserId = httpContext?.User?.FindFirst(\"id\")?.Value;\n            var currentUserRole = httpContext?.User?.Claims\n    .FirstOrDefault(c => c.Type.Contains(\"role\"))?.Value;\n            //httpContext?.User?.FindFirst(\"role\")?.Value;\n\n            // var currentUserName = httpContext?.User?.FindFirst(\"name\")?.Value ?? \"Unknown\";\n            var currentUserName = httpContext?.User?.Claims\n    .FirstOrDefault(c => c.Type.Contains(\"name\"))?.Value ?? \"Unknown\";\n            if (string.IsNullOrEmpty(currentUserId) || string.IsNullOrEmpty(currentUserRole))\n                return ResponseResult.ErrorInfo(\"âŒ Unauthorized access. Please login again.\");\n\n            var currentGuid = Guid.Parse(currentUserId);\n\n            // âœ… Authorization Logic\n            var isSuperAdmin = currentUserRole.Equals(\"admin\", StringComparison.OrdinalIgnoreCase) ||\n                               currentUserRole.Equals(\"superadmin\", StringComparison.OrdinalIgnoreCase);\n\n            var isAssignedPartner = business.CreatedByPartnerId.HasValue &&\n                                     business.CreatedByPartnerId.Value == currentGuid;\n\n            if (!isSuperAdmin && !isAssignedPartner)\n            {\n                return ResponseResult.ErrorInfo(\"â›” You are not authorized to approve this business.\");\n            }\n\n            // âœ… Approve Business\n\n            business.IsApproved = true;\n            business.Status = Business.StatusType.Approved;\n            business.ApprovedAt = DateTime.UtcNow;\n            business.ApprovedBy = currentUserName;\n            _businessRepo.Update(business);\n\n            // âœ… Update all Users to \"ProfilePending\"\n            foreach (var user in business.Users)\n            {\n                user.Status = \"Active\";\n                _userRepo.Update(user);\n            }\n\n            await _businessRepo.SaveAsync();\n            await _userRepo.SaveAsync();\n\n            // âœ… Audit Log\n            await _auditLogService.SaveLogAsync(new AuditLog\n            {\n                BusinessId = business.Id,\n                PerformedByUserId = currentGuid,\n                PerformedByUserName = currentUserName,\n                RoleAtTime = currentUserRole,\n                ActionType = \"business.approved\",\n                Description = $\"Business approved: {business.CompanyName}\",\n                IPAddress = httpContext?.Connection?.RemoteIpAddress?.ToString(),\n                UserAgent = httpContext?.Request?.Headers[\"User-Agent\"].ToString()\n            });\n\n            return ResponseResult.SuccessInfo(\"âœ… Business approved successfully.\");\n        }\n\n        public async Task<ResponseResult> RejectBusinessAsync(Guid businessId)\n        {\n            var business = await _businessRepo.FindByIdAsync(businessId);\n            if (business is null)\n                return ResponseResult.ErrorInfo(\"âŒ Business not found\");\n\n            business.Status = Business.StatusType.Rejected;\n            business.IsApproved = false;\n            // business.IsDeleted = true; // removed soft-delete to allow showing in Rejected tab\n            business.DeletedAt = null;\n\n            _businessRepo.Update(business);\n            await _businessRepo.SaveAsync();\n\n            await _auditLogService.SaveLogAsync(new AuditLog\n            {\n                BusinessId = business.Id,\n                PerformedByUserId = Guid.TryParse(_httpContextAccessor.HttpContext?.User?.FindFirst(\"id\")?.Value, out var userId) ? userId : Guid.Empty,\n                PerformedByUserName = _httpContextAccessor.HttpContext?.User?.FindFirst(\"email\")?.Value,\n                RoleAtTime = _httpContextAccessor.HttpContext?.User?.FindFirst(\"role\")?.Value,\n                ActionType = \"business.rejected\",\n                Description = $\"Business rejected: {business.CompanyName}\",\n                IPAddress = _httpContextAccessor.HttpContext?.Connection?.RemoteIpAddress?.ToString(),\n                UserAgent = _httpContextAccessor.HttpContext?.Request?.Headers[\"User-Agent\"].ToString()\n            });\n\n            return ResponseResult.SuccessInfo(\"âœ… Business rejected and marked as deleted\");\n        }\n\n        public async Task<ResponseResult> HoldBusinessAsync(Guid businessId)\n        {\n            var business = await _businessRepo.FindByIdAsync(businessId);\n            if (business is null)\n                return ResponseResult.ErrorInfo(\"âŒ Business not found\");\n\n            business.IsApproved = false;\n            business.Status = Business.StatusType.Hold;\n\n            _businessRepo.Update(business);\n            await _businessRepo.SaveAsync();\n\n            await _auditLogService.SaveLogAsync(new AuditLog\n            {\n                BusinessId = business.Id,\n                PerformedByUserId = Guid.TryParse(_httpContextAccessor.HttpContext?.User?.FindFirst(\"id\")?.Value, out var userId) ? userId : Guid.Empty,\n                PerformedByUserName = _httpContextAccessor.HttpContext?.User?.FindFirst(\"email\")?.Value,\n                RoleAtTime = _httpContextAccessor.HttpContext?.User?.FindFirst(\"role\")?.Value,\n                ActionType = \"business.hold\",\n                Description = $\"Business put on hold: {business.CompanyName}\",\n                IPAddress = _httpContextAccessor.HttpContext?.Connection?.RemoteIpAddress?.ToString(),\n                UserAgent = _httpContextAccessor.HttpContext?.Request?.Headers[\"User-Agent\"].ToString()\n            });\n\n            return ResponseResult.SuccessInfo(\"â¸ Business put on hold\");\n        }\n\n        public async Task<ResponseResult> CompleteProfileAsync(Guid businessId, ProfileCompletionDto dto)\n        {\n            var business = await _businessRepo.FindByIdAsync(businessId);\n            if (business is null)\n                return ResponseResult.ErrorInfo(\"âŒ Business not found\");\n\n            if (!string.IsNullOrEmpty(dto.BusinessName)) business.BusinessName = dto.BusinessName;\n            if (!string.IsNullOrEmpty(dto.CompanyPhone)) business.CompanyPhone = dto.CompanyPhone;\n            if (!string.IsNullOrEmpty(dto.Website)) business.Website = dto.Website;\n            if (!string.IsNullOrEmpty(dto.Address)) business.Address = dto.Address;\n            if (!string.IsNullOrEmpty(dto.Industry)) business.Industry = dto.Industry;\n            if (!string.IsNullOrEmpty(dto.LogoUrl)) business.LogoUrl = dto.LogoUrl;\n            if (!string.IsNullOrEmpty(dto.ReperesentativeName)) business.RepresentativeName = dto.ReperesentativeName;\n            if (!string.IsNullOrEmpty(dto.Phone)) business.Phone = dto.Phone;\n            _businessRepo.Update(business);\n            await _businessRepo.SaveAsync();\n            return ResponseResult.SuccessInfo(\"âœ… Profile updated successfully\");\n        }\n\n        public async Task<Business?> GetBusinessByEmailAsync(string email)\n        {\n            return await _businessRepo.FirstOrDefaultAsync(b => b.BusinessEmail.ToLower() == email.Trim().ToLower());\n        }\n\n        private string HashPassword(string password)\n        {\n            using var sha = SHA256.Create();\n            var bytes = Encoding.UTF8.GetBytes(password);\n            var hash = sha.ComputeHash(bytes);\n            return Convert.ToBase64String(hash);\n        }\n\n        public async Task<Business?> GetByIdAsync(Guid businessId)\n        {\n            return await _businessRepo.FindByIdAsync(businessId);\n        }\n\n        public async Task<List<ApprovedBusinessDto>> GetApprovedBusinessesAsync()\n        {\n            return await _businessRepo.AsQueryable()\n               .Include(b => b.Plan)\n               .Where(b => b.IsApproved && !b.IsDeleted)\n               .OrderBy(b => b.CompanyName)\n               .Select(b => new ApprovedBusinessDto\n               {\n                   Id = b.Id,\n                   CompanyName = b.CompanyName,\n                   BusinessEmail = b.BusinessEmail,\n                   PlanId = b.PlanId,\n                   PlanName = b.Plan != null ? b.Plan.Name : null,\n                   LogoUrl = b.LogoUrl\n               })\n               .ToListAsync();\n        }\n        public async Task<ResponseResult> HardDeleteBusinessAsync(Guid businessId)\n        {\n            try\n            {\n                var business = await _businessRepo.AsQueryable()\n                    .Include(b => b.Users)\n                    .Include(b => b.BusinessPlanInfo)\n                    .FirstOrDefaultAsync(b => b.Id == businessId);\n\n                if (business == null)\n                    return ResponseResult.ErrorInfo(\"âŒ Business not found\");\n\n                // Audit log before deletion\n                await _auditLogService.SaveLogAsync(new AuditLog\n                {\n                    BusinessId = business.Id,\n                    ActionType = \"business.hard_deleted\",\n                    Description = $\"Business permanently deleted: {business.CompanyName}\",\n                    IPAddress = _httpContextAccessor.HttpContext?.Connection?.RemoteIpAddress?.ToString(),\n                    UserAgent = _httpContextAccessor.HttpContext?.Request?.Headers[\"User-Agent\"].ToString()\n                });\n\n                // Remove related users first\n                if (business.Users != null && business.Users.Any())\n                {\n                    foreach (var user in business.Users.ToList())\n                    {\n                        _userRepo.Delete(user);\n                    }\n                    await _userRepo.SaveAsync();\n                }\n\n                if (business.BusinessPlanInfo != null)\n                {\n                    _db.BusinessPlanInfos.Remove(business.BusinessPlanInfo);\n                }\n\n                _businessRepo.Delete(business);\n                await _businessRepo.SaveAsync();\n\n                return ResponseResult.SuccessInfo(\"ðŸ—‘ï¸ Business permanently deleted\");\n            }\n            catch (Exception ex)\n            {\n                return ResponseResult.ErrorInfo(\"âŒ Failed to delete business: \" + ex.Message);\n            }\n        }\n\n        public async Task<ResponseResult> AssignPlanAsync(Guid businessId, Guid planId)\n        {\n            var business = await _businessRepo.AsQueryable()\n                .Include(b => b.BusinessPlanInfo)\n                .FirstOrDefaultAsync(b => b.Id == businessId);\n\n            if (business is null)\n                return ResponseResult.ErrorInfo(\"âŒ Business not found\");\n\n            // 1. Fetch Real Plan\n            var plan = await _planRepo.FindByIdAsync(planId);\n            if (plan == null)\n            {\n                return ResponseResult.ErrorInfo(\"âŒ Plan not found.\");\n            }\n\n            // 2. Fetch Quotas for this Plan\n            // Assuming we look for \"MESSAGES_PER_MONTH\"\n            var quotas = await _planQuotaRepo.AsQueryable()\n                .Where(q => q.PlanId == planId)\n                .ToListAsync();\n\n            var messageQuota = quotas\n                .FirstOrDefault(q => q.QuotaKey == QuotaKeys.MessagesPerMonth);\n\n            int monthlyLimit = messageQuota != null ? (int)messageQuota.Limit : 1000; // Default fallback if not defined\n\n            // 3. Map Plan Code to Enum (Best Effort)\n            // If Plan.Code is \"SMART\", map to PlanType.Smart\n            // This is brittle if Enum and DB drift, but necessary if BusinessPlanInfo relies on Enum.\n            PlanType planTypeEnum = PlanType.Basic;\n            if (Enum.TryParse<PlanType>(plan.Code, true, out var parsed))\n            {\n                planTypeEnum = parsed;\n            }\n            else\n            {\n                // Fallback logic by name? Or default to Basic/Smart if unknown\n                planTypeEnum = PlanType.Smart; \n            }\n\n            // Update linking\n            business.PlanId = planId;\n\n            // Handle BusinessPlanInfo\n            if (business.BusinessPlanInfo == null)\n            {\n                var newPlanInfo = new BusinessPlanInfo\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = business.Id,\n                    Plan = planTypeEnum, \n                    TotalMonthlyQuota = monthlyLimit, \n                    RemainingMessages = monthlyLimit,\n                    QuotaResetDate = DateTime.UtcNow.AddMonths(1),\n                    WalletBalance = 0\n                };\n                \n                // Explicitly add the new child entity\n                _db.Entry(newPlanInfo).State = EntityState.Added;\n                business.BusinessPlanInfo = newPlanInfo;\n            }\n            else\n            {\n                // Update existing info\n                business.BusinessPlanInfo.Plan = planTypeEnum;\n                business.BusinessPlanInfo.TotalMonthlyQuota = monthlyLimit;\n                // Ideally we shouldn't reset RemainingMessages if just upgrading mid-month unless that's policy.\n                // For now, let's reset it to the new limit to be generous, or keep it if it's lower? \n                // Let's reset it for now to ensure they get the new quota immediately.\n                business.BusinessPlanInfo.RemainingMessages = monthlyLimit; \n                \n                _db.Entry(business.BusinessPlanInfo).State = EntityState.Modified;\n            }\n            \n            await _businessRepo.SaveAsync();\n\n            await _auditLogService.SaveLogAsync(new AuditLog\n            {\n                BusinessId = business.Id,\n                ActionType = \"business.plan_assigned\",\n                Description = $\"Assigned Plan '{plan.Name}' ({planId}) to business {business.CompanyName}. Limit: {monthlyLimit}\",\n                PerformedByUserId = Guid.TryParse(_httpContextAccessor.HttpContext?.User?.FindFirst(\"id\")?.Value, out var uid) ? uid : Guid.Empty,\n                PerformedByUserName = _httpContextAccessor.HttpContext?.User?.FindFirst(\"email\")?.Value\n            });\n\n            return ResponseResult.SuccessInfo($\"âœ… Plan '{plan.Name}' assigned successfully.\");\n        }\n\n        public IQueryable<Business> Query()\n        {\n            return _businessRepo.AsQueryable();\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/BusinessModule/Services/IBusinessService.cs",
      "sha256": "9b27fd199b73b84cad94813d99eb5cb62852f36276859c227dfd483c3d598974",
      "language": "csharp",
      "size": 1482,
      "content": "using System.Runtime.CompilerServices;\nusing xbytechat.api.Features.BusinessModule.DTOs;\nusing xbytechat.api.Features.BusinessModule.Models;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Models;\nnamespace xbytechat.api.Features.BusinessModule.Services\n{\n\n    public interface IBusinessService\n    {\n        IQueryable<Business> Query();\n        Task<ResponseResult> SignupBusinessAsync(SignupBusinessDto dto); /// Signup + create admin user\n\n        Task<ResponseResult> ApproveBusinessAsync(Guid businessId);      // Admin action\n        Task<ResponseResult> RejectBusinessAsync(Guid businessId);       // Admin action\n        Task<ResponseResult> HoldBusinessAsync(Guid businessId);         // Admin action\n        Task<ResponseResult> CompleteProfileAsync(Guid businessId, ProfileCompletionDto dto); // Post-login completion\n        Task<Business?> GetBusinessByEmailAsync(string email);\n        Task<Business?> GetByIdAsync(Guid businessId);\n \n        Task<ResponseResult> UpdateBusinessAsync(Guid businessId, UpdateBusinessDto dto);\n\n        Task<List<PendingBusinessDto>> GetPendingBusinessesAsync(string role, string userId, string? status = null);\n        Task<List<ApprovedBusinessDto>> GetApprovedBusinessesAsync();\n        Task<ResponseResult> HardDeleteBusinessAsync(Guid businessId);\n\n        /// <summary>\n        /// Assigns a specific plan to a business.\n        /// </summary>\n        Task<ResponseResult> AssignPlanAsync(Guid businessId, Guid planId);\n    }\n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Controllers/CampaignAudienceController.cs",
      "sha256": "74c141a187b14cbca6760d96e6474d3dea69708cd2a608bbb54adcbd1019021b",
      "language": "csharp",
      "size": 4615,
      "content": "using System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.AspNetCore.Mvc;\nusing Serilog;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing xbytechat.api.Features.CampaignModule.Services;\nusing xbytechat.api.Shared; // User.GetBusinessId()\n\nnamespace xbytechat.api.Features.CampaignModule.Controllers\n{\n    [ApiController]\n    [Route(\"api/campaigns/{campaignId:guid}/audience\")]\n    [Authorize]\n    public sealed class CampaignAudienceController : ControllerBase\n    {\n        private readonly ICampaignAudienceAttachmentService _svc;\n\n        public CampaignAudienceController(ICampaignAudienceAttachmentService svc)\n        {\n            _svc = svc;\n        }\n\n        [HttpGet]\n        public async Task<ActionResult<CampaignAudienceDto>> GetActive([FromRoute] Guid campaignId, CancellationToken ct)\n        {\n            try\n            {\n                var businessId = User.GetBusinessId();\n                var dto = await _svc.GetActiveAsync(businessId, campaignId, ct);\n                return Ok(dto);\n            }\n            catch (KeyNotFoundException)\n            {\n                return NotFound(new { message = \"Campaign not found.\" });\n            }\n        }\n\n        [HttpGet(\"history\")]\n        public async Task<IActionResult> History([FromRoute] Guid campaignId, CancellationToken ct)\n        {\n            try\n            {\n                var businessId = User.GetBusinessId();\n                var list = await _svc.GetHistoryAsync(businessId, campaignId, ct);\n                return Ok(list);\n            }\n            catch (KeyNotFoundException)\n            {\n                return NotFound(new { message = \"Campaign not found.\" });\n            }\n        }\n\n        public sealed class ReplaceForm\n        {\n            public IFormFile File { get; set; } = default!;\n            public string? AudienceName { get; set; }\n        }\n\n        [HttpPost(\"replace\")]\n        [RequestSizeLimit(1024L * 1024L * 200L)] // 200 MB\n        public async Task<IActionResult> Replace([FromRoute] Guid campaignId, [FromForm] ReplaceForm form, CancellationToken ct)\n        {\n            var businessId = User.GetBusinessId();\n            var actor = ResolveActor();\n\n            try\n            {\n                var res = await _svc.ReplaceAsync(businessId, campaignId, form.File, form.AudienceName, actor, ct);\n                return Ok(res);\n            }\n            catch (CampaignAudienceAttachmentService.AudienceLockedException ex)\n            {\n                return Conflict(new { message = ex.Message });\n            }\n            catch (KeyNotFoundException)\n            {\n                return NotFound(new { message = \"Campaign not found.\" });\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"Replace CSV audience failed | campaign={CampaignId}\", campaignId);\n                return Problem(title: \"Replace CSV audience failed\", detail: ex.Message, statusCode: 400);\n            }\n        }\n\n        [HttpPost(\"remove\")]\n        public async Task<IActionResult> Remove([FromRoute] Guid campaignId, CancellationToken ct)\n        {\n            var businessId = User.GetBusinessId();\n            var actor = ResolveActor();\n\n            try\n            {\n                var res = await _svc.RemoveAsync(businessId, campaignId, actor, ct);\n                return Ok(res);\n            }\n            catch (CampaignAudienceAttachmentService.AudienceLockedException ex)\n            {\n                return Conflict(new { message = ex.Message });\n            }\n            catch (KeyNotFoundException)\n            {\n                return NotFound(new { message = \"Campaign not found.\" });\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"Remove CSV audience failed | campaign={CampaignId}\", campaignId);\n                return Problem(title: \"Remove CSV audience failed\", detail: ex.Message, statusCode: 400);\n            }\n        }\n\n        private string ResolveActor()\n        {\n            // Used for CampaignAudienceAttachments.DeactivatedBy audit trail.\n            var email = User.Claims.FirstOrDefault(c => c.Type.EndsWith(\"email\", StringComparison.OrdinalIgnoreCase))?.Value;\n            if (!string.IsNullOrWhiteSpace(email)) return email!;\n\n            return User.Identity?.Name\n                   ?? (User.Claims.FirstOrDefault(c => c.Type.EndsWith(\"nameidentifier\", StringComparison.OrdinalIgnoreCase))?.Value)\n                   ?? \"system\";\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Controllers/CampaignController.cs",
      "sha256": "be7fb46fbcdb9c9f9ebcd7f1b71e2988b4933d14afb5444bd77674fda22fd5c9",
      "language": "csharp",
      "size": 17157,
      "content": "using DocumentFormat.OpenXml.InkML;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing Serilog.Context;\nusing System;\nusing System.Security.Claims;\nusing System.Threading.Tasks;\nusing xbytechat.api.AuthModule.Models;\nusing xbytechat.api.Features.BusinessModule.Services;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing xbytechat.api.Features.CampaignModule.Models;\nusing xbytechat.api.Features.CampaignModule.Services;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Shared;\nusing static xbytechat.api.Features.MessagesEngine.Controllers.MessageEngineController;\n\nnamespace xbytechat.api.Features.CampaignModule.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class CampaignController : ControllerBase\n    {\n        private readonly ICampaignService _campaignService;\n        private readonly IBusinessService _businessService;\n        private readonly IMessageEngineService _messageService;\n        private readonly IHttpContextAccessor _httpContextAccessor;\n\n        public CampaignController(\n            ICampaignService campaignService,\n            IBusinessService businessService,\n            IMessageEngineService messageEngineService,\n            IHttpContextAccessor httpContextAccessor)\n        {\n            _campaignService = campaignService;\n            _businessService = businessService;\n            _messageService = messageEngineService;\n            _httpContextAccessor = httpContextAccessor;\n        }\n\n\n        [HttpGet(\"get-image-campaign\")]\n        public async Task<IActionResult> GetAll([FromQuery] string? type)\n        {\n            var businessId = GetBusinessId();\n            var items = await _campaignService.GetAllCampaignsAsync(businessId, type);\n            return Ok(items);\n        }\n    \n\n        [HttpPost(\"create-text-campaign\")]\n        public async Task<IActionResult> CreateTextCampaign([FromBody] CampaignCreateDto dto)\n        {\n            try\n            {\n                var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n                if (!Guid.TryParse(businessIdClaim, out var businessId))\n                    return Unauthorized(new { message = \"ðŸš« Invalid or missing BusinessId claim.\" });\n\n                var createdBy = User.Identity?.Name ?? \"system\";\n\n                if (string.IsNullOrWhiteSpace(dto.Name))\n                    return BadRequest(new { message = \"ðŸš« Campaign name is required.\" });\n\n                if (string.IsNullOrWhiteSpace(dto.TemplateId))\n                    return BadRequest(new { message = \"ðŸš« TemplateId is required for template campaigns.\" });\n\n            \n\n                var campaignId = await _campaignService.CreateTextCampaignAsync(dto, businessId, createdBy);\n\n                return campaignId != null\n                    ? Ok(new\n                    {\n                        success = true,\n                        message = \"âœ… Campaign created successfully\",\n                        campaignId = campaignId.Value\n                    })\n                    : BadRequest(new { success = false, message = \"âŒ Failed to create campaign\" });\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"âŒ Exception in CreateTextCampaign\");\n                return StatusCode(500, new { message = \"ðŸš¨ Internal server error\", error = ex.Message });\n            }\n        }\n\n        [HttpPost(\"create-image-campaign\")]\n        public async Task<IActionResult> CreateImageCampaign([FromBody] CampaignCreateDto dto)\n        {\n            try\n            {\n                var user = HttpContext.User;\n                var businessIdClaim = user.FindFirst(\"businessId\");\n\n                if (businessIdClaim == null || !Guid.TryParse(businessIdClaim.Value, out var businessId))\n                    return Unauthorized(new { message = \"ðŸš« Invalid or missing BusinessId claim.\" });\n\n                if (dto.MultiButtons != null && dto.MultiButtons.Any())\n                {\n                    var allowedTypes = new[] { \"url\", \"copy_code\", \"flow\", \"phone_number\", \"quick_reply\" };\n                    foreach (var button in dto.MultiButtons)\n                    {\n                        var type = button.ButtonType?.Trim().ToLower();\n\n                        if (!allowedTypes.Contains(type))\n                            return BadRequest(new { message = $\"âŒ Invalid ButtonType: '{type}' is not supported.\" });\n\n                        var needsValue = new[] { \"url\", \"flow\", \"copy_code\", \"phone_number\" };\n                        if (needsValue.Contains(type) && string.IsNullOrWhiteSpace(button.TargetUrl))\n                            return BadRequest(new { message = $\"âŒ Button '{button.ButtonText}' requires a valid TargetUrl or Value for type '{type}'.\" });\n\n                        if (button.TargetUrl?.ToLower() == \"unknown\")\n                            return BadRequest(new { message = $\"âŒ Invalid value 'unknown' found in button '{button.ButtonText}'.\" });\n                    }\n                }\n\n                var createdBy = user.Identity?.Name ?? \"system\";\n                var campaignId = await _campaignService.CreateImageCampaignAsync(businessId, dto, createdBy);\n\n                return Ok(new\n                {\n                    success = true,\n                    message = \"âœ… Campaign created successfully\",\n                    campaignId\n                });\n            }\n            catch (UnauthorizedAccessException ex)\n            {\n                return BadRequest(new { message = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"âŒ Exception in CreateImageCampaign\");\n                return StatusCode(500, new { message = \"ðŸš¨ Internal server error\", error = ex.Message });\n            }\n        }\n\n        // âœ… Moved above {id} routes\n        [HttpPost(\"{id}/assign-contacts\")]\n        public async Task<IActionResult> AssignContactsToCampaign(Guid id, [FromBody] AssignContactsDto request)\n        {\n            try\n            {\n                var businessId = GetBusinessId();\n                var success = await _campaignService.AssignContactsToCampaignAsync(id, businessId, request.ContactIds);\n\n                return success\n                    ? Ok(new { message = \"âœ… Contacts assigned\" })\n                    : BadRequest(new { message = \"âŒ Failed to assign contacts\" });\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(\"âŒ Error assigning contacts: \" + ex.Message);\n                return StatusCode(500, new { message = \"Internal error\", error = ex.Message });\n            }\n        }\n\n        [HttpDelete(\"{campaignId}/recipients/{contactId}\")]\n        public async Task<IActionResult> RemoveCampaignRecipient(Guid campaignId, Guid contactId)\n        {\n            try\n            {\n                var businessId = GetBusinessId();\n                var success = await _campaignService.RemoveRecipientAsync(businessId, campaignId, contactId);\n\n                if (!success)\n                    return NotFound(new { message = \"Recipient not found or not assigned\" });\n\n                return NoContent();\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(\"âŒ Remove recipient failed: \" + ex.Message);\n                return StatusCode(500, new { message = \"Error removing recipient\", detail = ex.Message });\n            }\n        }\n\n        // Put this inside CampaignService (same class as SendTemplateCampaignWithTypeDetectionAsync)\n        private static string? ResolveRecipientPhone(CampaignRecipient r)\n        {\n            // Try Contact first, then AudienceMember fallbacks\n            return r?.Contact?.PhoneNumber\n                ?? r?.AudienceMember?.PhoneE164\n                ?? r?.AudienceMember?.PhoneRaw;\n        }\n\n    \n        // Send All Type of campaign method \n\n        [Authorize]\n        [HttpPost(\"send-campaign/{campaignId}\")]\n        //[ProducesResponseType(typeof(ResponseResult), StatusCodes.Status202Accepted)]\n        //[ProducesResponseType(typeof(ResponseResult), StatusCodes.Status400BadRequest)]\n        //[ProducesResponseType(typeof(ResponseResult), StatusCodes.Status401Unauthorized)]\n        //[ProducesResponseType(typeof(ResponseResult), StatusCodes.Status500InternalServerError)]\n        public async Task<IActionResult> SendTemplateCampaign(Guid campaignId, CancellationToken ct)\n        {\n            using var _ = LogContext.PushProperty(\"CampaignId\", campaignId);\n\n            try\n            {\n                     var result = await _campaignService.SendTemplateCampaignWithTypeDetectionAsync(campaignId, ct);\n\n                if (result.Success) return Accepted(result);\n\n                // For now: any non-success from the service is treated as a client error\n                return BadRequest(result);\n            }\n            catch (OperationCanceledException)\n            {\n                Log.Warning(\"â›” SendTemplateCampaign cancelled\");\n                return StatusCode(StatusCodes.Status499ClientClosedRequest,\n                    ResponseResult.ErrorInfo(\"Request cancelled\"));\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"âŒ Exception while sending campaign\");\n                return StatusCode(StatusCodes.Status500InternalServerError,\n                    ResponseResult.ErrorInfo(\"ðŸš¨ Server error while sending campaign\", ex.ToString()));\n            }\n        }\n\n\n\n        [HttpPost(\"send-template-campaign/{id}\")]\n        public async Task<IActionResult> SendImageCampaign(Guid id)\n        {\n            var result = await _campaignService.SendTemplateCampaignAsync(id);\n            return result.Success ? Ok(result) : BadRequest(result);\n        }\n\n        [HttpPost(\"send/{campaignId}\")]\n        public async Task<IActionResult> SendCampaign(Guid campaignId)\n        {\n            try\n            {\n                var ipAddress = HttpContext.Connection.RemoteIpAddress?.ToString() ?? \"unknown\";\n                var userAgent = Request.Headers[\"User-Agent\"].ToString() ?? \"unknown\";\n\n                var success = await _campaignService.SendCampaignAsync(campaignId, ipAddress, userAgent);\n\n                return success\n                    ? Ok(new { success = true, message = \"âœ… Campaign sent successfully\" })\n                    : BadRequest(new { success = false, message = \"âŒ Campaign sending failed\" });\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"âŒ Exception in SendCampaign\");\n                return StatusCode(500, new { success = false, message = \"ðŸš¨ Internal Server Error\", error = ex.Message });\n            }\n        }\n\n        [HttpPut(\"{id}\")]\n        public async Task<IActionResult> UpdateCampaign(Guid id, [FromBody] CampaignCreateDto dto)\n        {\n            var result = await _campaignService.UpdateCampaignAsync(id, dto);\n            return result\n                ? Ok(new { message = \"âœï¸ Campaign updated successfully\" })\n                : BadRequest(new { message = \"âŒ Update failed â€” only draft campaigns can be edited\" });\n        }\n\n\n\n        [HttpDelete(\"{id:guid}\")]\n        public async Task<IActionResult> DeleteCampaign([FromRoute] Guid id, [FromQuery] bool force = false)\n        {\n            var businessId = GetBusinessId();\n            var opt = new CampaignDeletionOptions { Force = force };\n            var res = await _campaignService.DeleteCampaignAsync(businessId, id, opt);\n\n            return res.Status switch\n            {\n                CampaignDeletionStatus.Deleted => Ok(new\n                {\n                    message = force\n                        ? \"ðŸ—‘ï¸ Campaign deleted permanently\"\n                        : \"ðŸ—‘ï¸ Campaign deleted successfully\",\n                    telemetry = new\n                    {\n                        recipients = res.Recipients,\n                        queuedJobs = res.QueuedJobs,\n                        sendLogs = res.SendLogs\n                    }\n                }),\n                CampaignDeletionStatus.BlockedSending => Conflict(new\n                {\n                    message = \"âŒ Cannot delete while campaign is sending. Cancel or wait to finish.\"\n                }),\n                CampaignDeletionStatus.BlockedState => BadRequest(new\n                {\n                    message = \"âŒ Delete failed â€” only draft campaigns can be deleted without force.\"\n                }),\n                CampaignDeletionStatus.NotFound => NotFound(new\n                {\n                    message = \"âŒ Campaign not found.\"\n                }),\n                _ => StatusCode(500, new\n                {\n                    message = \"ðŸš¨ Internal error while deleting campaign.\"\n                })\n            };\n        }\n\n        [HttpGet(\"recipients/{id}\")]\n        public async Task<IActionResult> GetCampaignRecipients(Guid id)\n        {\n            try\n            {\n                var businessId = GetBusinessId();\n                var recipients = await _campaignService.GetRecipientsByCampaignIdAsync(id, businessId);\n                return Ok(recipients);\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(\"âŒ Error fetching campaign recipients: \" + ex.Message);\n                return StatusCode(500, new { message = \"Error fetching recipients\", detail = ex.Message });\n            }\n        }\n\n        [HttpGet(\"{id}\")]\n        public async Task<ActionResult<CampaignDto>> GetCampaignById(Guid id)\n        {\n            var businessId = GetBusinessId();\n            var campaign = await _campaignService.GetCampaignByIdAsync(id, businessId);\n\n            if (campaign == null)\n                return NotFound();\n\n            return Ok(campaign);\n        }\n\n        private Guid GetBusinessId()\n        {\n            var claim = HttpContext.User.FindFirst(\"businessId\")?.Value;\n            if (string.IsNullOrEmpty(claim))\n                throw new UnauthorizedAccessException(\"BusinessId not found in token claims.\");\n\n            return Guid.Parse(claim);\n        }\n\n        [HttpGet(\"list/{businessId:guid}\")]\n        public async Task<IActionResult> GetAvailableFlows(Guid businessId, [FromQuery] bool onlyPublished = true)\n        {\n            var items = await _campaignService.GetAvailableFlowsAsync(businessId, onlyPublished);\n            return Ok(new { success = true, items });\n        }\n\n        [HttpGet(\"check-name\")]\n        public async Task<IActionResult> CheckName([FromQuery] string name)\n        {\n            var businessId = GetBusinessId();\n            var available = await _campaignService.CheckNameAvailableAsync(businessId, name);\n            return Ok(new { available });\n        }\n\n        [HttpPut(\"{id:guid}/reschedule\")]\n        public async Task<IActionResult> Reschedule([FromRoute] Guid id, [FromBody] RescheduleDto body)\n        {\n            var businessId = GetBusinessId();\n            await _campaignService.RescheduleAsync(businessId, id, body.NewUtcTime);\n            return Ok(new { ok = true });\n        }\n\n        [HttpPost(\"{id:guid}/enqueue-now\")]\n        public async Task<IActionResult> EnqueueNow([FromRoute] Guid id)\n        {\n            var businessId = GetBusinessId();\n            await _campaignService.EnqueueNowAsync(businessId, id);\n            return Ok(new { ok = true });\n        }\n\n        [HttpPost(\"{id:guid}/cancel-schedule\")]\n        public async Task<IActionResult> CancelSchedule([FromRoute] Guid id)\n        {\n            var businessId = GetBusinessId();\n            await _campaignService.CancelScheduleAsync(businessId, id);\n            return Ok(new { ok = true });\n        }\n        [HttpGet(\"{id:guid}/usage\")]\n        public async Task<IActionResult> GetCampaignUsage([FromRoute] Guid id)\n        {\n            var businessId = GetBusinessId();\n            var usage = await _campaignService.GetCampaignUsageAsync(businessId, id);\n            if (usage == null) return NotFound(new { message = \"âŒ Campaign not found.\" });\n            return Ok(usage);\n        }\n        [HttpGet(\"paginated\")]\n        public async Task<IActionResult> GetPaginatedCampaigns([FromQuery] PaginatedRequest request)\n        {\n            var user = HttpContext.User;\n            var businessIdClaim = user.FindFirst(\"businessId\");\n\n            if (businessIdClaim == null || !Guid.TryParse(businessIdClaim.Value, out var businessId))\n                return Unauthorized(new { message = \"ðŸš« Invalid or missing BusinessId claim.\" });\n\n            var result = await _campaignService.GetPaginatedCampaignsAsync(businessId, request);\n            return Ok(result);\n        }\n\n        [HttpGet(\"debug-claims\")]\n        public IActionResult DebugClaims()\n        {\n            var user = HttpContext.User;\n            var businessId = user.FindFirst(\"businessId\")?.Value;\n\n            return Ok(new\n            {\n                name = user.Identity?.Name,\n                businessId\n            });\n        }\n\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Controllers/CampaignCsvSampleController.cs",
      "sha256": "e5c0f786b0bf827b8bfc29a5f32817bfdec13e5a041feefdb295b122796c4786",
      "language": "csharp",
      "size": 5533,
      "content": "// ðŸ“„ File: Features/CampaignModule/Controllers/CampaignCsvSampleController.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api;\nusing xbytechat.api.Features.CampaignModule.Import;   // <-- use the builder\nusing xbytechat.api.Shared;\nusing xbytechat_api.WhatsAppSettings.Services;       // User.GetBusinessId()\n\nnamespace xbytechat.api.Features.CampaignModule.Controllers\n{\n    [ApiController]\n    [Route(\"api/campaigns/{campaignId:guid}/csv-sample\")]\n    [Authorize]\n    public sealed class CampaignCsvSampleController : ControllerBase\n    {\n        private readonly AppDbContext _db;\n        private readonly CampaignCsvSchemaBuilder _schemaBuilder;\n\n        public CampaignCsvSampleController(AppDbContext db, CampaignCsvSchemaBuilder schemaBuilder)\n        {\n            _db = db;\n            _schemaBuilder = schemaBuilder;\n        }\n\n        // === Canonical schema (delegates to builder) ===\n        // GET /api/campaigns/{campaignId}/csv-sample/schema\n        [HttpGet(\"schema\")]\n        public async Task<IActionResult> GetSchema([FromRoute] Guid campaignId, CancellationToken ct = default)\n        {\n            var businessId = User.GetBusinessId();\n            if (businessId == Guid.Empty) return Unauthorized();\n\n            // Use canonical builder (parameterN, header.text_paramN, button{1..3}.url_param)\n            IReadOnlyList<string> headers;\n            try\n            {\n                headers = await _schemaBuilder.BuildAsync(businessId, campaignId, ct);\n            }\n            catch (KeyNotFoundException)\n            {\n                return NotFound();\n            }\n\n            // For backward compatibility with your FE contract:\n            // placeholderCount = number of BODY positional placeholders (parameterN)\n            var placeholderCount = headers.Count(h => h.StartsWith(\"parameter\", StringComparison.OrdinalIgnoreCase));\n\n            // Infer header meta for convenience\n            var headerSlots = headers.Count(h => h.StartsWith(\"header.text_param\", StringComparison.OrdinalIgnoreCase));\n            var headerType = headerSlots > 0 ? \"text\" : \"none\";\n            var needsUrl = false; // only true for image/video/doc templates; leave false here (data-only endpoint)\n\n            return Ok(new\n            {\n                headers,\n                placeholderCount,\n                header = new { type = headerType, needsUrl }\n            });\n        }\n\n        // GET /api/campaigns/{campaignId}/csv-sample\n        // Generates a dynamic sample based on the actual campaign schema\n        [HttpGet]\n        public async Task<IActionResult> GetDynamicSample([FromRoute] Guid campaignId, CancellationToken ct = default)\n        {\n            var businessId = User.GetBusinessId();\n            if (businessId == Guid.Empty) return Unauthorized();\n\n            IReadOnlyList<string> headers;\n            try\n            {\n                headers = await _schemaBuilder.BuildAsync(businessId, campaignId, ct);\n            }\n            catch (KeyNotFoundException)\n            {\n                return NotFound();\n            }\n\n            var sb = new StringBuilder();\n            sb.AppendLine(string.Join(\",\", headers));\n\n            // Create a dummy row\n            var row = new List<string>();\n            foreach (var h in headers)\n            {\n                var lower = h.ToLowerInvariant();\n                if (lower.Contains(\"phone\")) row.Add(\"1234567890\");\n                else if (lower.Contains(\"parameter\")) row.Add(\"value\");\n                else if (lower.Contains(\"url\")) row.Add(\"https://example.com\");\n                else row.Add(\"abc\");\n            }\n            sb.AppendLine(string.Join(\",\", row));\n\n            var bytes = Encoding.UTF8.GetBytes(sb.ToString());\n            return File(bytes, \"text/csv\", $\"sample_{campaignId}.csv\");\n        }\n\n        // GET /api/campaigns/{campaignId}/csv-sample/sample (Legacy/Generic)\n        [HttpGet(\"sample\")]\n        public IActionResult DownloadSample([FromQuery] int bodyParams = 2, [FromQuery] int headerTextParams = 1, [FromQuery] int urlButtons = 1)\n        {\n            bodyParams = Math.Max(0, Math.Min(10, bodyParams));        // safety caps\n            headerTextParams = Math.Max(0, Math.Min(5, headerTextParams));\n            urlButtons = Math.Max(0, Math.Min(3, urlButtons));\n\n            var headers = new List<string> { \"phone\" };\n\n            for (int i = 1; i <= bodyParams; i++) headers.Add($\"parameter{i}\");\n            for (int i = 1; i <= headerTextParams; i++) headers.Add($\"header.text_param{i}\");\n            for (int i = 1; i <= urlButtons; i++) headers.Add($\"button{i}.url_param\");\n\n            var example = new List<string> { \"+911234567890\" };\n            for (int i = 1; i <= bodyParams; i++) example.Add($\"body_value_{i}\");\n            for (int i = 1; i <= headerTextParams; i++) example.Add($\"header_text_{i}\");\n            for (int i = 1; i <= urlButtons; i++) example.Add($\"https://example.com/order/{{id}}\");\n\n            var sb = new StringBuilder();\n            sb.AppendLine(string.Join(\",\", headers));\n            sb.AppendLine(string.Join(\",\", example.Select(v => v.Replace(\",\", \" \"))));\n\n            var bytes = System.Text.Encoding.UTF8.GetBytes(sb.ToString());\n            return File(bytes, \"text/csv\", \"campaign_sample.csv\");\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Controllers/CampaignCsvSchemaBuilder.cs",
      "sha256": "a694fdc231c120d666b13fdfb3c1135a39ccf4e262fa351e19f7646c1acc1816",
      "language": "csharp",
      "size": 4974,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api;\nusing xbytechat.api.AuthModule.Models;\nusing xbytechat.api.WhatsAppSettings.Helpers; // TemplateJsonHelper\n\nnamespace xbytechat.api.Features.CampaignModule.Import\n{\n    /// <summary>\n    /// Builds the CSV header schema for a campaign/template.\n    /// - BODY placeholders:\n    ///     * POSITIONAL => parameter1..N\n    ///     * NAMED      => one column per distinct body token name (e.g., name, slug),\n    ///                    and we ALSO include parameter1..N for backward compatibility.\n    /// - HEADER text placeholders => header.text_param1..K\n    /// - Dynamic URL buttons => button{1..3}.url_param (only when template button has {{..}})\n    /// - Always includes \"phone\" (first column).\n    /// </summary>\n    public sealed class CampaignCsvSchemaBuilder\n    {\n        private readonly AppDbContext _db;\n\n        public CampaignCsvSchemaBuilder(AppDbContext db) => _db = db;\n\n        public async Task<IReadOnlyList<string>> BuildAsync(Guid businessId, Guid campaignId, CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty) throw new UnauthorizedAccessException(\"Invalid business id.\");\n            if (campaignId == Guid.Empty) throw new ArgumentException(\"campaignId is required.\");\n\n            // Resolve template name from Campaign\n            var campaign = await _db.Campaigns\n                .AsNoTracking()\n                .FirstOrDefaultAsync(c => c.Id == campaignId && c.BusinessId == businessId, ct)\n                ?? throw new KeyNotFoundException(\"Campaign not found.\");\n\n            var templateName = (campaign.TemplateId ?? campaign.MessageTemplate ?? \"\").Trim();\n            if (string.IsNullOrWhiteSpace(templateName))\n                throw new InvalidOperationException(\"Campaign does not have a template selected.\");\n\n            // Get the freshest active WhatsAppTemplate row for this name\n            var tpl = await _db.WhatsAppTemplates\n                .AsNoTracking()\n                .Where(t => t.BusinessId == businessId && t.Name == templateName && t.IsActive)\n                .OrderByDescending(t => t.UpdatedAt > t.CreatedAt ? t.UpdatedAt : t.CreatedAt)\n                .FirstOrDefaultAsync(ct)\n                ?? throw new KeyNotFoundException($\"Template '{templateName}' not found in cache.\");\n\n            // Parse raw JSON canonically (works even if you donâ€™t store the extra JSON columns)\n            var summary = TemplateJsonHelper.SummarizeDetailed(tpl.RawJson, tpl.Body);\n\n            // â€”â€”â€” Collect tokens â€”â€”â€”\n            var bodyCountPositional = summary.BodyParamIndices?.Distinct().Count() ?? 0;\n            var bodyNamed = summary.Placeholders\n                .Where(p => p.Location == PlaceholderLocation.Body && p.Type == PlaceholderType.Named)\n                .Select(p => p.Name!)\n                .Where(n => !string.IsNullOrWhiteSpace(n))\n                .Distinct(StringComparer.OrdinalIgnoreCase)\n                .OrderBy(n => n, StringComparer.OrdinalIgnoreCase)\n                .ToList();\n\n            var headerTextSlots = (summary.HeaderKind?.Equals(\"text\", StringComparison.OrdinalIgnoreCase) == true)\n                ? (summary.HeaderParamIndices?.Distinct().Count() ?? 0)\n                : 0;\n\n            // Buttons with a dynamic param ({{..}}) in the parameter field\n            var dynamicButtonOrders = summary.Placeholders\n                .Where(p => p.Location == PlaceholderLocation.Button && string.Equals(p.ButtonField, \"param\", StringComparison.OrdinalIgnoreCase))\n                .Select(p => p.ButtonOrder ?? 0)\n                .Where(o => o > 0 && o <= 3)\n                .Distinct()\n                .OrderBy(o => o)\n                .ToList();\n\n            // â€”â€”â€” Build headers in a stable order â€”â€”â€”\n            var headers = new List<string> { \"phone\" };\n\n            // BODY: positional or named\n            if (bodyNamed.Count > 0)\n            {\n                // â€¢ preferred: named columns\n                headers.AddRange(bodyNamed);\n                // â€¢ backward compatible: parameter1..N (with N from placeholder count)\n                for (int i = 1; i <= Math.Max(bodyCountPositional, summary.PlaceholderCount); i++)\n                    headers.Add($\"parameter{i}\");\n            }\n            else\n            {\n                for (int i = 1; i <= bodyCountPositional; i++)\n                    headers.Add($\"parameter{i}\");\n            }\n\n            // HEADER text placeholders remain numeric\n            for (int i = 1; i <= headerTextSlots; i++)\n                headers.Add($\"header.text_param{i}\");\n\n            // Dynamic URL buttons (at most 3 in Meta)\n            foreach (var ord in dynamicButtonOrders)\n                headers.Add($\"button{ord}.url_param\");\n\n            return headers;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Controllers/CampaignDispatchController.cs",
      "sha256": "9b1df1625288107f2c9ee203b10b4a17dde0444a69b9562ef7fbf8d3755d49b8",
      "language": "csharp",
      "size": 1940,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Serilog;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing xbytechat.api.Features.CampaignModule.Services;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.CampaignModule.Controllers\n{\n    [ApiController]\n    [Route(\"api/campaigns/{campaignId:guid}/dispatch\")]\n    [Authorize]\n    public class CampaignDispatchController : ControllerBase\n    {\n        private readonly ICampaignDispatcher _dispatcher;\n\n        public CampaignDispatchController(ICampaignDispatcher dispatcher)\n        {\n            _dispatcher = dispatcher;\n        }\n\n        /// <summary>\n        /// Dispatch materialized recipients to the outbound queue.\n        /// Query: mode=canary|full, count=25 (used when mode=canary).\n        /// </summary>\n        [HttpPost]\n        public async Task<ActionResult<CampaignDispatchResponseDto>> Dispatch(\n            [FromRoute] Guid campaignId,\n            [FromQuery] string mode = \"canary\",\n            [FromQuery] int count = 25,\n            CancellationToken ct = default)\n        {\n            try\n            {\n                var businessId = ResolveBusinessId();\n                var resp = await _dispatcher.DispatchAsync(businessId, campaignId, mode, count, ct);\n                return Ok(resp);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"Dispatch failed for Campaign {CampaignId}\", campaignId);\n                return Problem(title: \"Dispatch failed\", detail: ex.Message, statusCode: 400);\n            }\n        }\n\n        private Guid ResolveBusinessId()\n        {\n            var bid = User.GetBusinessId(); // unified helper\n            if (bid == Guid.Empty)\n                throw new UnauthorizedAccessException(\"Invalid or missing businessId claim.\");\n            return bid;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Controllers/CampaignDispatchPlanController.cs",
      "sha256": "fa1771645ec3aa53f0c0b793831c1a0f3bd6667a876b07d2c0494eaca0a72152",
      "language": "csharp",
      "size": 1271,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Serilog;\nusing xbytechat.api.Features.CampaignModule.Services;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.CampaignModule.Controllers\n{\n    [ApiController]\n    [Route(\"api/campaigns/{campaignId:guid}/dispatch-plan\")]\n    [Authorize]\n    public class CampaignDispatchPlanController : ControllerBase\n    {\n        private readonly ICampaignDispatchPlannerService _planner;\n\n        public CampaignDispatchPlanController(ICampaignDispatchPlannerService planner)\n        {\n            _planner = planner;\n        }\n\n        /// <summary>\n        /// Returns a read-only dispatch plan: batches, offsets, and throttle summary.\n        /// </summary>\n        [HttpGet]\n        public async Task<IActionResult> Get(Guid campaignId, [FromQuery] int limit = 2000, CancellationToken ct = default)\n        {\n            var businessId = User.GetBusinessId();\n            Log.Information(\"Dispatch plan requested {@Ctx}\", new { businessId, campaignId, limit });\n\n            var data = await _planner.PlanAsync(businessId, campaignId, limit, ct);\n            return Ok(new { success = true, data });\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Controllers/CampaignDispatchPlanExportController.cs",
      "sha256": "99c81c3dcba5bf94c119c5e35543288d8a87e691eb1f55fe071d9fee7eec30f5",
      "language": "csharp",
      "size": 1332,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Serilog;\nusing xbytechat.api.Features.CampaignModule.Services;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.CampaignModule.Controllers\n{\n    [ApiController]\n    [Route(\"api/campaigns/{campaignId:guid}/dispatch-plan.csv\")]\n    [Authorize]\n    public class CampaignDispatchPlanExportController : ControllerBase\n    {\n        private readonly ICsvExportService _csv;\n\n        public CampaignDispatchPlanExportController(ICsvExportService csv)\n        {\n            _csv = csv;\n        }\n\n        /// <summary>\n        /// Streams a CSV of the dispatch plan (batches, offsets, recipients).\n        /// </summary>\n        [HttpGet]\n        public async Task<IActionResult> Get(Guid campaignId, [FromQuery] int limit = 2000, CancellationToken ct = default)\n        {\n            var businessId = User.GetBusinessId();\n            Log.Information(\"Dispatch Plan CSV requested {@Ctx}\", new { businessId, campaignId, limit });\n\n            var bytes = await _csv.BuildDispatchPlanCsvAsync(businessId, campaignId, limit, ct);\n            var fileName = $\"dispatch_plan_{campaignId:N}.csv\";\n            return File(bytes, \"text/csv; charset=utf-8\", fileName);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Controllers/CampaignDryRunController.cs",
      "sha256": "578d68a41c396cb59025d014be7fa8a9c8776b15be6d7e098e8b5a3511502eb0",
      "language": "csharp",
      "size": 1127,
      "content": "using System;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing xbytechat.api.Features.CampaignModule.Services;\n\nnamespace xbytechat.api.Features.CampaignModule.Controllers\n{\n    [ApiController]\n    [Route(\"api/campaigns\")]\n    [Authorize]\n    public sealed class CampaignDryRunController : ControllerBase\n    {\n        private readonly ICampaignService _campaigns;\n        public CampaignDryRunController(ICampaignService campaigns) => _campaigns = campaigns;\n\n        // GET /api/campaigns/{campaignId}/dry-run?limit=20\n        [HttpGet(\"{campaignId:guid}/dry-run\")]\n        public async Task<IActionResult> DryRun([FromRoute] Guid campaignId, [FromQuery] int limit = 20)\n        {\n            if (campaignId == Guid.Empty) return BadRequest(new { message = \"Invalid campaignId\" });\n            if (limit <= 0) limit = 20;\n            if (limit > 200) limit = 200; // guardrails\n\n            var resp = await _campaigns.DryRunTemplateCampaignAsync(campaignId, limit);\n            return Ok(resp);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Controllers/CampaignMappingsController.cs",
      "sha256": "e4aa5327bae9ff9f05b0388d401b2855e319d128d59889ebd9b8c165dba29616",
      "language": "csharp",
      "size": 3321,
      "content": "using System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.CampaignModule.Services;\n\nnamespace xbytechat.api.Features.CampaignModule.Controllers\n{\n    [ApiController]\n    [Route(\"api/campaigns/{campaignId:guid}/mappings\")]\n    [Authorize] // adjust to your auth\n    public sealed class CampaignMappingsController : ControllerBase\n    {\n        private readonly IVariableMappingService _svc;\n        private readonly IMappingSuggestionService _suggest;\n\n        public CampaignMappingsController(IVariableMappingService svc, IMappingSuggestionService suggest)\n        {\n            _svc = svc;\n            _suggest = suggest;\n        }\n\n        /// <summary>\n        /// Returns saved variable mappings for a campaign.\n        /// Shape: dictionary of token -> source (e.g., \"first_name\" -> \"csv:First Name\")\n        /// </summary>\n        [HttpGet]\n        public async Task<IActionResult> GetAsync(\n            [FromRoute] Guid campaignId,\n            CancellationToken ct = default)\n        {\n            var businessId = GetBusinessIdOrThrow();\n            var map = await _svc.GetForCampaignAsync(businessId, campaignId, ct);\n            return Ok(map ?? new System.Collections.Generic.Dictionary<string, string>());\n        }\n\n        /// <summary>\n        /// Saves variable mappings for a campaign.\n        /// Body: { \"tokenA\": \"csv:HeaderA\", \"tokenB\": \"static:Hello\", ... }\n        /// </summary>\n        [HttpPost]\n        public async Task<IActionResult> SaveAsync(\n            [FromRoute] Guid campaignId,\n            [FromBody] System.Collections.Generic.Dictionary<string, string> mappings,\n            CancellationToken ct = default)\n        {\n            if (mappings is null)\n                return BadRequest(\"Body cannot be null; send a mapping dictionary.\");\n\n            var businessId = GetBusinessIdOrThrow();\n            await _svc.SaveAsync(businessId, campaignId, mappings, ct);\n            return NoContent();\n        }\n\n        /// <summary>\n        /// Suggest default mappings from CSV headers and campaign tokens.\n        /// GET /api/campaigns/{campaignId}/mappings/suggest?batchId=...\n        /// </summary>\n        [HttpGet(\"suggest\")]\n        public async Task<IActionResult> SuggestAsync(\n            [FromRoute] Guid campaignId,\n            [FromQuery] Guid batchId,\n            CancellationToken ct = default)\n        {\n            if (batchId == Guid.Empty)\n                return BadRequest(\"batchId is required.\");\n\n            var businessId = GetBusinessIdOrThrow();\n            var map = await _suggest.SuggestAsync(businessId, campaignId, batchId, ct);\n            return Ok(map);\n        }\n\n        // -- helpers --\n\n        private Guid GetBusinessIdOrThrow()\n        {\n            string? raw =\n                User?.FindFirst(\"business_id\")?.Value ??\n                User?.FindFirst(\"BusinessId\")?.Value ??\n                Request.Headers[\"X-Business-Id\"].FirstOrDefault();\n\n            if (!Guid.TryParse(raw, out var id))\n                throw new UnauthorizedAccessException(\n                    \"Business context missing. Pass X-Business-Id header or ensure the business_id claim is present.\");\n\n            return id;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Controllers/CampaignMaterializationController.cs",
      "sha256": "ba44f1458a39c736281ecc8dbed383fac7a646d34853127258aff6364bcf25d7",
      "language": "csharp",
      "size": 1417,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Serilog;\nusing xbytechat.api.Features.CampaignModule.Services;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.CampaignModule.Controllers\n{\n    [ApiController]\n    [Route(\"api/campaigns/{campaignId:guid}/materialize\")]\n    [Authorize]\n    public class CampaignMaterializationController : ControllerBase\n    {\n        private readonly ICampaignMaterializationService _materializer;\n\n        public CampaignMaterializationController(ICampaignMaterializationService materializer)\n        {\n            _materializer = materializer;\n        }\n\n        /// <summary>\n        /// Returns a page (limit) of fully materialized recipients: placeholder values and resolved button URLs.\n        /// No send, read-only.\n        /// </summary>\n        [HttpGet]\n        public async Task<IActionResult> Get(Guid campaignId, [FromQuery] int limit = 200, CancellationToken ct = default)\n        {\n            var businessId = User.GetBusinessId();\n            Log.Information(\"Materialize GET requested {@Ctx}\", new { businessId, campaignId, limit });\n\n            var data = await _materializer.MaterializeAsync(businessId, campaignId, limit, ct);\n            return Ok(new { success = true, data });\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Controllers/CampaignMaterializationExportController.cs",
      "sha256": "1b18901d4ea990ce054a6dbb6d28e9e86341034ba56f73c92987ba2a015d8aba",
      "language": "csharp",
      "size": 1330,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Serilog;\nusing xbytechat.api.Features.CampaignModule.Services;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.CampaignModule.Controllers\n{\n    [ApiController]\n    [Route(\"api/campaigns/{campaignId:guid}/materialize.csv\")]\n    [Authorize]\n    public class CampaignMaterializationExportController : ControllerBase\n    {\n        private readonly ICsvExportService _csv;\n\n        public CampaignMaterializationExportController(ICsvExportService csv)\n        {\n            _csv = csv;\n        }\n\n        /// <summary>\n        /// Streams a CSV of materialized recipients (params + button URLs).\n        /// </summary>\n        [HttpGet]\n        public async Task<IActionResult> Get(Guid campaignId, [FromQuery] int limit = 200, CancellationToken ct = default)\n        {\n            var businessId = User.GetBusinessId();\n            Log.Information(\"Materialize CSV requested {@Ctx}\", new { businessId, campaignId, limit });\n\n            var bytes = await _csv.BuildMaterializedCsvAsync(businessId, campaignId, limit, ct);\n            var fileName = $\"materialized_{campaignId:N}.csv\";\n            return File(bytes, \"text/csv; charset=utf-8\", fileName);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Controllers/CampaignMaterializeController.cs",
      "sha256": "75ff118076a1ab627e2eac5e5ad8490a32a93ec90e5638bed3c699cc6b1e5bc7",
      "language": "csharp",
      "size": 4273,
      "content": "// File: Features/CampaignModule/Controllers/CampaignMaterializeController.cs\nusing System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Serilog;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing xbytechat.api.Features.CampaignModule.Services;\nusing xbytechat.api.Shared; // User.GetBusinessId()\n\nnamespace xbytechat.api.Features.CampaignModule.Controllers\n{\n    [ApiController]\n    [Route(\"api/campaigns/{campaignId:guid}/materialize\")]\n    [Authorize]\n    public class CampaignMaterializeController : ControllerBase\n    {\n        private readonly ICampaignMaterializer _csvMaterializer;\n        private readonly ICampaignMaterializationService _recipientPreview;\n\n        public CampaignMaterializeController(\n            ICampaignMaterializer csvMaterializer,\n            ICampaignMaterializationService recipientPreview)\n        {\n            _csvMaterializer = csvMaterializer;\n            _recipientPreview = recipientPreview;\n        }\n\n        /// <summary>\n        /// CSV-based materialization. Use Persist=false for dry-run preview; Persist=true to commit Audience + CSV recipients.\n        /// </summary>\n        [HttpPost]\n        public async Task<ActionResult<CampaignCsvMaterializeResponseDto>> CsvCreate(\n            [FromRoute] Guid campaignId,\n            [FromBody] CampaignCsvMaterializeRequestDto dto,\n            CancellationToken ct)\n        {\n            try\n            {\n                if (dto is null) return BadRequest(\"Body required.\");\n\n                Guid businessId;\n                try { businessId = User.GetBusinessId(); }\n                catch { return Unauthorized(); }\n\n                var actor = ResolveActor();\n\n                Log.Information(\"Materialize request: campaign={CampaignId} persist={Persist} batch={BatchId} audience='{Audience}'\",\n                    campaignId, dto.Persist, dto.CsvBatchId, dto.AudienceName);\n\n                var result = await _csvMaterializer.CreateAsync(businessId, campaignId, dto, actor, ct);\n\n                Log.Information(\"Materialize result: campaign={CampaignId} materialized={Count} skipped={Skipped} audienceId={AudienceId}\",\n                    campaignId, result.MaterializedCount, result.SkippedCount, result.AudienceId);\n\n                return Ok(result);\n            }\n            catch (CampaignAudienceAttachmentService.AudienceLockedException ex)\n            {\n                return Conflict(new { message = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"CSV materialize failed for Campaign {CampaignId}\", campaignId);\n                return Problem(title: \"CSV materialize failed\", detail: ex.Message, statusCode: 400);\n            }\n        }\n\n        /// <summary>\n        /// Recipient-based preview (read-only), using existing recipients + contacts.\n        /// </summary>\n        [HttpGet(\"recipients\")]\n        public async Task<ActionResult<CampaignMaterializeResultDto>> RecipientPreview(\n            [FromRoute] Guid campaignId,\n            [FromQuery] int limit = 200,\n            CancellationToken ct = default)\n        {\n            try\n            {\n                Guid businessId;\n                try { businessId = User.GetBusinessId(); }\n                catch { return Unauthorized(); }\n\n                var result = await _recipientPreview.MaterializeAsync(businessId, campaignId, limit, ct);\n                return Ok(result);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"Recipient preview failed for Campaign {CampaignId}\", campaignId);\n                return Problem(title: \"Recipient preview failed\", detail: ex.Message, statusCode: 400);\n            }\n        }\n\n        private string ResolveActor()\n        {\n            var email = User.Claims.FirstOrDefault(c => c.Type.EndsWith(\"email\", StringComparison.OrdinalIgnoreCase))?.Value;\n            if (!string.IsNullOrWhiteSpace(email)) return email!;\n\n            return User.Identity?.Name\n                   ?? (User.Claims.FirstOrDefault(c => c.Type.EndsWith(\"nameidentifier\", StringComparison.OrdinalIgnoreCase))?.Value)\n                   ?? \"system\";\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Controllers/CampaignPreviewController.cs",
      "sha256": "0f88ad7bec9bc43c01918eaa6fe58c499f1926fecc2a7e9430ae6d99cc47cf36",
      "language": "csharp",
      "size": 1384,
      "content": "using System;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing xbytechat.api.Features.CampaignModule.Services;\nusing xbytechat.api.Shared; // User.GetBusinessId()\n\nnamespace xbytechat.api.Features.CampaignModule.Controllers\n{\n    [ApiController]\n    [Route(\"api/campaigns/{campaignId:guid}/preview\")]\n    [Authorize]\n    public class CampaignPreviewController : ControllerBase\n    {\n        private readonly AppDbContext _db;\n        private readonly ICampaignPreviewService _preview;\n\n        public CampaignPreviewController(AppDbContext db, ICampaignPreviewService preview)\n        {\n            _db = db; _preview = preview;\n        }\n\n        [HttpPost]\n        public async Task<ActionResult<CampaignPreviewResponseDto>> Preview(Guid campaignId, [FromBody] CampaignPreviewRequestDto req)\n        {\n            var businessId = User.GetBusinessId();\n            if (businessId == Guid.Empty) return Unauthorized();\n\n            var exists = await _db.Campaigns.AnyAsync(c => c.Id == campaignId && c.BusinessId == businessId);\n            if (!exists) return NotFound();\n\n            var data = await _preview.PreviewAsync(businessId, campaignId, req?.ContactId);\n            return Ok(data);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Controllers/CampaignRecipientController.cs",
      "sha256": "1439351d33ce2b37017fa44d06b15ae0c52b72cdfb7e7b6843820642fb1ce49b",
      "language": "csharp",
      "size": 4029,
      "content": "using Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Serilog;\nusing System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing xbytechat.api.Features.CampaignModule.Services;\nusing xbytechat.api.Shared; // User.GetBusinessId()\n\nnamespace xbytechat.api.Features.CampaignModule.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize]\n    public class CampaignRecipientController : ControllerBase\n    {\n        private readonly ICampaignRecipientService _recipientService;\n\n        public CampaignRecipientController(ICampaignRecipientService recipientService)\n        {\n            _recipientService = recipientService;\n        }\n\n        [HttpGet(\"{id}\")]\n        public async Task<ActionResult<CampaignRecipientDto>> GetRecipientById(Guid id)\n        {\n            Guid businessId;\n            try { businessId = User.GetBusinessId(); }\n            catch { return Unauthorized(); }\n\n            var recipient = await _recipientService.GetByIdAsync(businessId, id);\n            if (recipient == null)\n                return NotFound(new { message = \"Recipient not found\" });\n\n            return Ok(recipient);\n        }\n\n        [HttpGet(\"/api/campaigns/{campaignId}/recipients\")]\n        public async Task<ActionResult> GetRecipientsForCampaign(Guid campaignId)\n        {\n            Guid businessId;\n            try { businessId = User.GetBusinessId(); }\n            catch { return Unauthorized(); }\n\n            var recipients = await _recipientService.GetByCampaignIdAsync(businessId, campaignId);\n            return Ok(recipients);\n        }\n\n        [HttpPut(\"{recipientId}/status\")]\n        public async Task<ActionResult> UpdateStatus(Guid recipientId, [FromQuery] string newStatus)\n        {\n            Guid businessId;\n            try { businessId = User.GetBusinessId(); }\n            catch { return Unauthorized(); }\n\n            var success = await _recipientService.UpdateStatusAsync(businessId, recipientId, newStatus);\n            if (!success)\n                return NotFound(new { message = \"Recipient not found or update failed\" });\n\n            return Ok(new { message = \"Status updated\" });\n        }\n\n        [HttpPut(\"{recipientId}/reply\")]\n        public async Task<ActionResult> TrackReply(Guid recipientId, [FromQuery] string replyText)\n        {\n            Guid businessId;\n            try { businessId = User.GetBusinessId(); }\n            catch { return Unauthorized(); }\n\n            var success = await _recipientService.TrackReplyAsync(businessId, recipientId, replyText);\n            if (!success)\n                return NotFound(new { message = \"Recipient not found or tracking failed\" });\n\n            return Ok(new { message = \"Reply tracked\" });\n        }\n\n        [HttpGet(\"search\")]\n        public async Task<ActionResult<List<CampaignRecipientDto>>> SearchRecipients([FromQuery] string? status, [FromQuery] string? keyword)\n        {\n            Guid businessId;\n            try { businessId = User.GetBusinessId(); }\n            catch { return Unauthorized(); }\n\n            var results = await _recipientService.SearchRecipientsAsync(businessId, status, keyword);\n            return Ok(results);\n        }\n\n        [HttpPost(\"{id}/assign-contacts\")]\n        public async Task<IActionResult> AssignContacts(Guid id, [FromBody] AssignContactsDto dto)\n        {\n            try\n            {\n                Guid businessId;\n                try { businessId = User.GetBusinessId(); }\n                catch { return Unauthorized(); }\n\n                await _recipientService.AssignContactsToCampaignAsync(businessId, id, dto.ContactIds);\n                return Ok(new { message = \"Contacts assigned successfully\" });\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"Error assigning contacts to campaign\");\n                return StatusCode(500, new { message = \"Failed to assign contacts\" });\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Controllers/CampaignRetargetController.cs",
      "sha256": "82e0a7a70da1b52fae40fa16555c7257d1b6361c9cd764527f97f8adb8149fd1",
      "language": "csharp",
      "size": 1374,
      "content": "using Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing xbytechat.api.Features.CampaignModule.Services;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.CampaignModule.Controllers\n{\n    [ApiController]\n    [Authorize]\n    [Route(\"api/campaigns/retarget\")]\n    public class CampaignRetargetController : BusinessControllerBase\n    {\n        private readonly ICampaignRetargetService _svc;\n\n        public CampaignRetargetController(ICampaignRetargetService svc)\n        {\n            _svc = svc;\n        }\n        [HttpPost]\n        public async Task<IActionResult> CreateRetargetCampaign(\n            [FromBody] RetargetCampaignRequestDto dto,\n            CancellationToken ct)\n        {\n            var campaignName = dto.Name?.Trim() ?? dto.Campaign?.Name?.Trim();\n            if (string.IsNullOrWhiteSpace(campaignName))\n            {\n                return BadRequest(new { error = \"Campaign Name is required for retargeting.\" });\n            }\n\n            var createdBy = UserId.ToString();\n            var result = await _svc.CreateRetargetCampaignAsync(BusinessId, dto, createdBy, ct);\n            return Ok(result);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Controllers/CampaignRetryController.cs",
      "sha256": "ca2204f071f6a85505d1550007e2bb2fa0ea7c35a4d13542b1ed9727751b1b9f",
      "language": "csharp",
      "size": 1424,
      "content": "using System;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Serilog;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.CampaignModule.Controllers\n{\n    [ApiController]\n    [Route(\"api/campaigns\")]\n    [Authorize]\n    public sealed class CampaignRetryController : ControllerBase\n    {\n        private readonly Services.ICampaignRetryService _retry;\n\n        public CampaignRetryController(Services.ICampaignRetryService retry)\n        {\n            _retry = retry;\n        }\n\n        // POST /api/campaigns/{campaignId}/retry-failed?limit=200\n        [HttpPost(\"{campaignId:guid}/retry-failed\")]\n        public async Task<IActionResult> RetryFailed([FromRoute] Guid campaignId, [FromQuery] int limit = 200)\n        {\n            var businessId = User.GetBusinessId();\n            if (businessId == Guid.Empty)\n                return Unauthorized(new { success = false, error = \"Invalid business context.\" });\n\n            try\n            {\n                var data = await _retry.RetryFailedAsync(businessId, campaignId, limit);\n                return Ok(new { success = true, data });\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"RetryFailed error for Campaign {CampaignId}\", campaignId);\n                return BadRequest(new { success = false, error = ex.Message });\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Controllers/CampaignSendValidator.cs",
      "sha256": "cb9b4a3ee2f532a382778e8eb8e608b1f807cf30fa4ee5fa71dcb5c6de489a0c",
      "language": "csharp",
      "size": 4488,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.Json;\nusing xbytechat.api.AuthModule.Models;\nusing xbytechat.api.Features.CampaignModule.Models;\nusing xbytechat.api.Features.CampaignModule.SendEngine;\nusing xbytechat.api.WhatsAppSettings.Helpers; // TemplateJsonHelper\n\nnamespace xbytechat.api.Features.CampaignModule.SendEngine\n{\n    public interface ICampaignSendValidator\n    {\n        (bool Ok, string? Error) Validate(SendPlan plan, RecipientPlan recipient, TemplateEnvelope env, WhatsAppTemplate tmplRow);\n    }\n\n    public sealed class CampaignSendValidator : ICampaignSendValidator\n    {\n        public (bool Ok, string? Error) Validate(SendPlan plan, RecipientPlan recipient, TemplateEnvelope env, WhatsAppTemplate tmplRow)\n        {\n            // Summarize the provider-native template JSON to know how many placeholders exist\n            var summary = TemplateJsonHelper.SummarizeDetailed(tmplRow.RawJson ?? \"{}\", tmplRow.Body);\n\n            // ----- BODY: positional placeholders (parameter1..N)\n            var bodySlots = summary.BodyParamIndices?.DefaultIfEmpty(0).Max() ?? 0;\n            var bodyHave = env.BodyParams?.Count ?? 0;\n            if (bodyHave < bodySlots)\n            {\n                return (false, $\"Body parameters missing: need {bodySlots}, got {bodyHave}. Expected keys parameter1..parameter{bodySlots}.\");\n            }\n\n            // ----- HEADER: text placeholders (header.text_param1..K) only if header is Text\n            var isHeaderText = string.Equals(summary.HeaderKind ?? \"none\", \"text\", StringComparison.OrdinalIgnoreCase)\n                               || plan.HeaderKind == HeaderKind.Text;\n            if (isHeaderText)\n            {\n                var headerSlots = summary.HeaderParamIndices?.DefaultIfEmpty(0).Max() ?? 0;\n                var headerHave = env.HeaderParams?.Count ?? 0;\n                if (headerHave < headerSlots)\n                {\n                    return (false, $\"Header text parameters missing: need {headerSlots}, got {headerHave}. Expected keys header.text_param1..header.text_param{headerSlots}.\");\n                }\n            }\n\n            // ----- BUTTONS: url parameter per button position present in template\n            var urlButtonPositions = summary.Placeholders\n                .Where(p => p.Location == PlaceholderLocation.Button &&\n                            string.Equals(p.ButtonField, \"param\", StringComparison.OrdinalIgnoreCase))\n                .Select(p => p.ButtonOrder ?? 0)\n                .Where(o => o > 0 && o <= 3)\n                .Distinct()\n                .OrderBy(o => o)\n                .ToArray();\n\n            if (urlButtonPositions.Length > 0)\n            {\n                // Read per-recipient button params (prefer canonical dict, fallback to legacy array)\n                var (btnDict, btnList) = ReadButtonParams(env.PerRecipientButtonParamsJson);\n\n                foreach (var pos in urlButtonPositions)\n                {\n                    // canonical dict key\n                    var key = $\"button{pos}.url_param\";\n\n                    var hasValue =\n                        (btnDict != null && btnDict.TryGetValue(key, out var dv) && !string.IsNullOrWhiteSpace(dv))\n                        || (btnList != null && btnList.Count >= pos && !string.IsNullOrWhiteSpace(btnList[pos - 1]));\n\n                    if (!hasValue)\n                        return (false, $\"Missing per-recipient button parameter: '{key}'. Provide a value for the URL button at position {pos}.\");\n                }\n            }\n\n            return (true, null);\n        }\n\n        // Returns (dict,list) where exactly one is non-null when data is present\n        private static (Dictionary<string, string>? dict, List<string>? list) ReadButtonParams(string? json)\n        {\n            if (string.IsNullOrWhiteSpace(json))\n                return (null, null);\n\n            // try dict first (canonical)\n            try\n            {\n                var dict = JsonSerializer.Deserialize<Dictionary<string, string>>(json!);\n                if (dict is { Count: > 0 }) return (dict, null);\n            }\n            catch { /* ignore */ }\n\n            // fallback to list (legacy)\n            try\n            {\n                var list = JsonSerializer.Deserialize<List<string>>(json!);\n                if (list is { Count: > 0 }) return (null, list);\n            }\n            catch { /* ignore */ }\n\n            return (null, null);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Controllers/CampaignVariableMapController.cs",
      "sha256": "882eb072e75759c98b2257f09ada75c7721d73996978f7d35a4ce3721ee13767",
      "language": "csharp",
      "size": 1942,
      "content": "using System;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing xbytechat.api;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing xbytechat.api.Features.CampaignModule.Services;\nusing xbytechat.api.Shared; // User.GetBusinessId()\n\nnamespace xbytechat.api.Features.CampaignModule.Controllers\n{\n    [ApiController]\n    [Route(\"api/campaigns/{campaignId:guid}/variables\")]\n    [Authorize]\n    public class CampaignVariableMapController : ControllerBase\n    {\n        private readonly AppDbContext _db;\n        private readonly ICampaignVariableMapService _svc;\n\n        public CampaignVariableMapController(AppDbContext db, ICampaignVariableMapService svc)\n        { _db = db; _svc = svc; }\n\n        [HttpGet]\n        public async Task<IActionResult> Get(Guid campaignId)\n        {\n            var businessId = User.GetBusinessId();\n            if (businessId == Guid.Empty) return Unauthorized();\n\n            var exists = await _db.Campaigns.AnyAsync(c => c.Id == campaignId && c.BusinessId == businessId);\n            if (!exists) return NotFound(new { success = false, message = \"Campaign not found\" });\n\n            var data = await _svc.GetAsync(businessId, campaignId);\n            return Ok(new { success = true, data });\n        }\n\n        [HttpPost]\n        public async Task<IActionResult> Save(Guid campaignId, [FromBody] CampaignVariableMapDto body)\n        {\n            var businessId = User.GetBusinessId();\n            var userName = User.Identity?.Name ?? \"system\";\n            if (businessId == Guid.Empty) return Unauthorized();\n\n            if (body == null) return BadRequest(new { success = false, message = \"Body required\" });\n            body.CampaignId = campaignId;\n\n            var ok = await _svc.SaveAsync(businessId, body, userName);\n            return Ok(new { success = ok });\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Controllers/CsvBatchController.cs",
      "sha256": "adb9f2110c4e4ed93fd06752020663c2545b35c04cc1c3e38949026b57bbd347",
      "language": "csharp",
      "size": 5298,
      "content": "using System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.AspNetCore.Mvc;\nusing Serilog;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing xbytechat.api.Features.CampaignModule.Services;\nusing xbytechat.api.Shared;   // User.GetBusinessId()\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Features.CampaignModule.DTOs.Requests;  // ResponseResult\n\nnamespace xbytechat.api.Features.CampaignModule.Controllers\n{\n    [ApiController]\n    [Route(\"api/csv/batch\")]\n    [Authorize]\n    public class CsvBatchController : ControllerBase\n    {\n        private readonly ICsvBatchService _service;\n\n        public CsvBatchController(ICsvBatchService service)\n        {\n            _service = service;\n        }\n\n        /// <summary>Upload a CSV, create a batch, and ingest rows.</summary>\n        [HttpPost]\n        [RequestSizeLimit(1024L * 1024L * 200L)] // 200 MB\n        public async Task<IActionResult> Upload(\n            [FromForm] CsvBatchUploadForm form,\n            CancellationToken ct)\n        {\n            var businessId = User.GetBusinessId();\n            if (businessId == Guid.Empty)\n                return Unauthorized(ResponseResult.ErrorInfo(\"Invalid business\"));\n\n            if (form.File is null || form.File.Length == 0)\n                return BadRequest(ResponseResult.ErrorInfo(\"CSV file is required\"));\n\n            // soft sanity (many browsers use text/csv; don't block others)\n            var allowed = new[] { \"text/csv\", \"application/vnd.ms-excel\", \"application/octet-stream\" };\n            if (!allowed.Contains(form.File.ContentType, StringComparer.OrdinalIgnoreCase))\n                Log.Warning(\"Unusual CSV content type: {ContentType}\", form.File.ContentType);\n\n            await using var stream = form.File.OpenReadStream();\n\n            var result = await _service.CreateAndIngestAsync(\n                businessId: businessId,\n                fileName: form.File.FileName,\n                stream: stream,\n                audienceId: form.AudienceId,\n                campaignId: form.CampaignId,\n                ct: ct);\n\n            return Ok(new { success = true, data = result });\n        }\n\n\n        [HttpGet(\"{batchId:guid}\")]\n        public async Task<IActionResult> Get(Guid batchId, CancellationToken ct)\n        {\n            var businessId = User.GetBusinessId();\n            if (businessId == Guid.Empty) return Unauthorized(ResponseResult.ErrorInfo(\"Invalid business\"));\n\n            var result = await _service.GetBatchAsync(businessId, batchId, ct);\n            if (result == null) return NotFound(ResponseResult.ErrorInfo(\"Batch not found\"));\n            return Ok(new { success = true, data = result });\n        }\n\n        [HttpGet(\"{batchId:guid}/sample\")]\n        public async Task<IActionResult> Sample(Guid batchId, [FromQuery] int take = 20, CancellationToken ct = default)\n        {\n            var businessId = User.GetBusinessId();\n            if (businessId == Guid.Empty) return Unauthorized(ResponseResult.ErrorInfo(\"Invalid business\"));\n\n            var rows = await _service.GetSamplesAsync(businessId, batchId, take, ct);\n            return Ok(new { success = true, data = rows });\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> List([FromQuery] int limit = 20, CancellationToken ct = default)\n        {\n            var businessId = User.GetBusinessId();\n            if (businessId == Guid.Empty) return Unauthorized(ResponseResult.ErrorInfo(\"Invalid business\"));\n\n            var list = await _service.ListBatchesAsync(businessId, limit, ct);\n            return Ok(new { success = true, data = list });\n        }\n\n        [HttpGet(\"{batchId:guid}/rows\")]\n        public async Task<IActionResult> RowsPage(Guid batchId, [FromQuery] int skip = 0, [FromQuery] int take = 50, CancellationToken ct = default)\n        {\n            var businessId = User.GetBusinessId();\n            if (businessId == Guid.Empty) return Unauthorized(ResponseResult.ErrorInfo(\"Invalid business\"));\n\n            var page = await _service.GetRowsPageAsync(businessId, batchId, skip, take, ct);\n            return Ok(new { success = true, data = page });\n        }\n\n        //[HttpPost(\"{batchId:guid}/validate\")]\n        //public async Task<IActionResult> Validate(Guid batchId, [FromBody] CsvBatchValidationRequestDto request, CancellationToken ct = default)\n        //{\n        //    var businessId = User.GetBusinessId();\n        //    if (businessId == Guid.Empty) return Unauthorized(ResponseResult.ErrorInfo(\"Invalid business\"));\n\n        //    var result = await _service.ValidateAsync(businessId, batchId, request, ct);\n        //    return Ok(new { success = true, data = result });\n        //}\n\n        [HttpDelete(\"{batchId:guid}\")]\n        public async Task<IActionResult> Delete(Guid batchId, CancellationToken ct = default)\n        {\n            var businessId = User.GetBusinessId();\n            if (businessId == Guid.Empty) return Unauthorized(ResponseResult.ErrorInfo(\"Invalid business\"));\n\n            var ok = await _service.DeleteBatchAsync(businessId, batchId, ct);\n            return ok ? Ok(new { success = true }) : NotFound(ResponseResult.ErrorInfo(\"Batch not found\"));\n        }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Controllers/OutboundCampaignQueueController.cs",
      "sha256": "b32af6b334cd55462ca38b0506a7d1d5a4961309a1c4d260324faec64efb7c12",
      "language": "csharp",
      "size": 4153,
      "content": "using System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing xbytechat.api.Features.CampaignModule.Models;\nusing xbytechat.api.Features.CampaignModule.Services;\nusing xbytechat.api.Shared; // for User.GetBusinessId()\n\nnamespace xbytechat.api.Features.CampaignModule.Controllers\n{\n    [ApiController]\n    [Route(\"api/campaigns/{campaignId:guid}/queue\")]\n    [Authorize]\n    public class OutboundCampaignQueueController : ControllerBase\n    {\n        private readonly AppDbContext _db;\n        private readonly IOutboundCampaignQueueService _queue;\n\n        public OutboundCampaignQueueController(AppDbContext db, IOutboundCampaignQueueService queue)\n        {\n            _db = db; _queue = queue;\n        }\n\n        // GET: /api/campaigns/{id}/queue/jobs\n        [HttpGet(\"jobs\")]\n        public async Task<ActionResult<IEnumerable<OutboundCampaignJobDto>>> ListJobs(Guid campaignId)\n        {\n            var businessId = User.GetBusinessId();\n            if (businessId == Guid.Empty) return Unauthorized();\n\n            // ownership check\n            var exists = await _db.Campaigns.AnyAsync(c => c.Id == campaignId && c.BusinessId == businessId);\n            if (!exists) return NotFound();\n\n            var jobs = await _queue.GetJobsForCampaignAsync(businessId, campaignId);\n            return Ok(jobs.Select(Map));\n        }\n\n        // POST: /api/campaigns/{id}/queue/enqueue?forceDuplicate=false\n        [HttpPost(\"enqueue\")]\n        public async Task<ActionResult<object>> Enqueue(Guid campaignId, [FromQuery] bool forceDuplicate = false)\n        {\n            var businessId = User.GetBusinessId();\n            if (businessId == Guid.Empty) return Unauthorized();\n\n            var exists = await _db.Campaigns.AnyAsync(c => c.Id == campaignId && c.BusinessId == businessId);\n            if (!exists) return NotFound();\n\n            var jobId = await _queue.EnqueueAsync(businessId, campaignId, forceDuplicate);\n            return Ok(new { success = true, jobId });\n        }\n\n        // POST: /api/campaigns/{id}/queue/{jobId}/retry\n        [HttpPost(\"{jobId:guid}/retry\")]\n        public async Task<ActionResult<object>> Retry(Guid campaignId, Guid jobId)\n        {\n            var businessId = User.GetBusinessId();\n            if (businessId == Guid.Empty) return Unauthorized();\n\n            // Optional: ensure job belongs to this campaign & business\n            var job = await _db.OutboundCampaignJobs\n                .AsNoTracking()\n                .FirstOrDefaultAsync(j => j.Id == jobId && j.BusinessId == businessId && j.CampaignId == campaignId);\n\n            if (job == null) return NotFound();\n\n            var ok = await _queue.ForceRetryNowAsync(businessId, jobId);\n            return Ok(new { success = ok });\n        }\n\n        // POST: /api/campaigns/{id}/queue/{jobId}/cancel\n        [HttpPost(\"{jobId:guid}/cancel\")]\n        public async Task<ActionResult<object>> Cancel(Guid campaignId, Guid jobId)\n        {\n            var businessId = User.GetBusinessId();\n            if (businessId == Guid.Empty) return Unauthorized();\n\n            var job = await _db.OutboundCampaignJobs\n                .AsNoTracking()\n                .FirstOrDefaultAsync(j => j.Id == jobId && j.BusinessId == businessId && j.CampaignId == campaignId);\n\n            if (job == null) return NotFound();\n\n            var ok = await _queue.CancelAsync(businessId, jobId);\n            return Ok(new { success = ok });\n        }\n\n        private static OutboundCampaignJobDto Map(OutboundCampaignJob j) => new OutboundCampaignJobDto\n        {\n            Id = j.Id,\n            BusinessId = j.BusinessId,\n            CampaignId = j.CampaignId,\n            Status = j.Status,\n            Attempt = j.Attempt,\n            MaxAttempts = j.MaxAttempts,\n            NextAttemptAt = j.NextAttemptAt,\n            LastError = j.LastError,\n            CreatedAt = j.CreatedAt,\n            UpdatedAt = j.UpdatedAt\n        };\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/CountryCodes/WhatsAppPhoneValidationOptions.cs",
      "sha256": "7fcbddc921c2e01586f8d029c3df9e9a5dc5250603aea41d78d9cf6ef4c97e50",
      "language": "csharp",
      "size": 276,
      "content": "namespace xbytechat.api.Features.CampaignModule.CountryCodes\n{\n    public sealed class WhatsAppPhoneValidationOptions\n    {\n        public string Mode { get; set; } = \"allow\"; // \"allow\" or \"deny\"\n        public List<string> AllowedCountryCodes { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/AssignContactsDto.cs",
      "sha256": "8f8b9b0da213111f833dd07dd7e5189ccc02984cef1b34deb5b1d93a5d40678e",
      "language": "csharp",
      "size": 156,
      "content": "namespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    public class AssignContactsDto\n    {\n        public List<Guid> ContactIds { get; set; }\n    }\n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/CampaignAudienceDtos.cs",
      "sha256": "958e2b1191e2578f7d73ab6f8038b49a1a853a8e61013f9f7b833b79a07c5e7e",
      "language": "csharp",
      "size": 1722,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    /// <summary>\n    /// Current CSV audience attachment state for a campaign (active attachment only).\n    /// Returned by GET /api/campaigns/{campaignId}/audience.\n    /// </summary>\n    public sealed class CampaignAudienceDto\n    {\n        public Guid? AttachmentId { get; set; }\n        public Guid? AudienceId { get; set; }\n        public string? AudienceName { get; set; }\n\n        public Guid? CsvBatchId { get; set; }\n        public string? FileName { get; set; }\n        public DateTime? CreatedAt { get; set; }\n\n        public int MemberCount { get; set; }\n\n        /// <summary>\n        /// True when the campaign has already been sent (or has send logs) and the audience is immutable.\n        /// </summary>\n        public bool IsLocked { get; set; }\n    }\n\n    public sealed class CampaignAudienceHistoryItemDto\n    {\n        public Guid AttachmentId { get; set; }\n        public Guid AudienceId { get; set; }\n        public string? AudienceName { get; set; }\n\n        public Guid CsvBatchId { get; set; }\n        public string? FileName { get; set; }\n\n        public bool IsActive { get; set; }\n        public DateTime CreatedAt { get; set; }\n        public DateTime? DeactivatedAt { get; set; }\n        public string? DeactivatedBy { get; set; }\n    }\n\n    public sealed class CampaignAudienceReplaceResponseDto\n    {\n        public CampaignAudienceDto Active { get; set; } = new();\n        public int CsvRecipientsInserted { get; set; }\n    }\n\n    public sealed class CampaignAudienceRemoveResponseDto\n    {\n        public CampaignAudienceDto Active { get; set; } = new();\n        public int CsvRecipientsDeleted { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/CampaignButtonDto.cs",
      "sha256": "edeaae8d1d1c7ff60b77f0dc68a4f382420cad6364302ea6816f34938c76a45e",
      "language": "csharp",
      "size": 465,
      "content": "namespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    public class CampaignButtonDto\n    {\n        public string ButtonText { get; set; } = string.Empty; // ðŸ“ e.g., \"Buy Now\"\n        public string ButtonType { get; set; } = \"url\";         // ðŸ”˜ url | quick_reply | call\n        public string TargetUrl { get; set; } = string.Empty;  // ðŸŒ or phone/call param\n\n        public string? Value { get; set; }\n        public int Position { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/CampaignButtonParamFromMetaDto.cs",
      "sha256": "d218adbbc4e6418548f3dfe962c8b867fc7f364be490f6533d04fb5c61f17f30",
      "language": "csharp",
      "size": 391,
      "content": "namespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    public class CampaignButtonParamFromMetaDto\n    {\n        public string Text { get; set; } = string.Empty;\n        public string Type { get; set; } = string.Empty;\n        public string SubType { get; set; } = string.Empty;\n        public string Value { get; set; } = string.Empty;\n        public int Position { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/CampaignCreateDto.cs",
      "sha256": "6b6b7b78d42631d7c64b527942ea1452b1d5860ded056d77d24b634d801cd6be",
      "language": "csharp",
      "size": 1881,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.ComponentModel.DataAnnotations.Schema;\nusing xbytechat.api.Features.CTAManagement.DTOs;\nusing xbytechat.api.Features.MessagesEngine.DTOs; // Required to reference CTAButtonDto\n\nnamespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    public class CampaignCreateDto\n    {\n        public string Name { get; set; }\n\n        [Column(TypeName = \"text\")]\n        public string MessageTemplate { get; set; }\n\n        public string? TemplateId { get; set; } // âœ… Optional Meta template ID\n\n        public string? FollowUpTemplateId { get; set; } // ðŸ” Auto-reply template after interest\n\n        public string? CampaignType { get; set; } //= \"template\"; // \"text\", \"template\", \"cta\"\n\n        public Guid? CtaId { get; set; } // ðŸ”˜ For legacy CTA support (optional)\n\n        public Guid? CTAFlowConfigId { get; set; }\n        public List<CampaignButtonDto> MultiButtons { get; set; } = new(); // âœ… New multi-button support\n        public DateTime? ScheduledAt { get; set; } // ðŸ“… Optional future scheduling\n\n        //public List<Guid>? ContactIds { get; set; } // ðŸ‘¥ Target contact list\n\n        public string? ImageUrl { get; set; } // ðŸ–¼ï¸ Optional image field\n\n        public string? ImageCaption { get; set; } // ðŸ“ Optional caption\n\n        public List<Guid> ContactIds { get; set; } = new();\n\n        public List<string>? TemplateParameters { get; set; }\n        public List<CampaignButtonParamFromMetaDto>? ButtonParams { get; set; }\n\n        // Sender fields (REQUIRED for reliability)\n        public string Provider { get; set; }            // \"PINNACLE\" | \"META_CLOUD\" (UPPERCASE)\n        public string PhoneNumberId { get; set; }\n\n        public string? HeaderKind { get; set; }        // \"image\" | \"video\" | \"document\" | \"text\" | \"none\"\n        public string? HeaderMediaUrl { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/CampaignCsvMaterializeDtos.cs",
      "sha256": "56c8084a7a0a181e779d3ad774edd588567949c55bcca324c7614b3c7528098c",
      "language": "csharp",
      "size": 1503,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    public sealed class CampaignCsvMaterializeRequestDto\n    {\n        [Required] public Guid CsvBatchId { get; set; }\n        public Dictionary<string, string>? Mappings { get; set; } // token -> header or \"constant:Value\"\n        public string? PhoneField { get; set; }\n        public bool NormalizePhones { get; set; } = true;\n        public bool Deduplicate { get; set; } = true;\n        public int? Limit { get; set; } = 200;\n\n        public bool Persist { get; set; } = false;\n        public string? AudienceName { get; set; } // required when Persist=true\n    }\n\n    public sealed class CsvMaterializedRowDto\n    {\n        public int RowIndex { get; set; }\n        public string? Phone { get; set; }\n        public Dictionary<string, string> Variables { get; set; } = new();\n        public List<string> Errors { get; set; } = new();\n    }\n\n    public sealed class CampaignCsvMaterializeResponseDto\n    {\n        public Guid CampaignId { get; set; }\n        public Guid CsvBatchId { get; set; }\n        public int TotalRows { get; set; }\n        public int MaterializedCount { get; set; }\n        public int SkippedCount { get; set; }\n        public Guid? AudienceId { get; set; }          // if persisted\n        public List<CsvMaterializedRowDto> Preview { get; set; } = new();\n        public List<string> Warnings { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/CampaignDispatchDtos.cs",
      "sha256": "141796a3913c2089c829bec345ac9d929fb9d8d23826436df34de7d709426f82",
      "language": "csharp",
      "size": 884,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    public sealed class CampaignDispatchResponseDto\n    {\n        public Guid CampaignId { get; set; }\n        public string Mode { get; set; } = \"canary\"; // canary|full\n        public int RequestedCount { get; set; }\n        public int SelectedCount { get; set; }\n        public int EnqueuedCount { get; set; }\n        public List<DispatchedRecipientDto> Sample { get; set; } = new(); // small sample for debug\n        public List<string> Warnings { get; set; } = new();\n    }\n\n    public sealed class DispatchedRecipientDto\n    {\n        public Guid RecipientId { get; set; }\n        public string? Phone { get; set; }\n        public string? Status { get; set; }\n        public DateTime? MaterializedAt { get; set; }\n        public string? IdempotencyKey { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/CampaignDispatchPlanDtos.cs",
      "sha256": "11f2306c03e0faa381004558316aded4856107a52df35dde32c528be27d16f34",
      "language": "csharp",
      "size": 1870,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    public class DispatchBatchDto\n    {\n        public int BatchNumber { get; set; }\n        public int StartIndex { get; set; }\n        public int Count { get; set; }\n\n        /// <summary>Total approximate payload size for this batch in bytes (text + buttons, naive estimate).</summary>\n        public int ApproxBytes { get; set; }\n\n        /// <summary>Seconds since plan start when this batch is allowed to start (based on throttling).</summary>\n        public int OffsetSeconds { get; set; }\n\n        public List<Guid?> RecipientIds { get; set; } = new();   // when using CampaignRecipients\n        public List<string?> Phones { get; set; } = new();\n        public List<string> Notes { get; set; } = new();\n    }\n\n    public class DispatchThrottleDto\n    {\n        public string Plan { get; set; } = \"Unknown\";\n        public string Provider { get; set; } = \"Auto\";\n        public int MaxBatchSize { get; set; } = 50;\n        public int MaxPerMinute { get; set; } = 300;\n        public int ComputedBatches { get; set; }\n        public int EstimatedMinutes { get; set; }\n        public List<string> Warnings { get; set; } = new();\n    }\n\n    public class CampaignDispatchPlanResultDto\n    {\n        public Guid CampaignId { get; set; }\n        public string TemplateName { get; set; } = string.Empty;\n        public string Language { get; set; } = \"en\";\n        public int PlaceholderCount { get; set; }\n\n        public int TotalRecipients { get; set; }\n        public int TotalApproxBytes { get; set; }\n\n        public DispatchThrottleDto Throttle { get; set; } = new();\n        public List<DispatchBatchDto> Batches { get; set; } = new();\n\n        public int WarningCount { get; set; }\n        public List<string> GlobalWarnings { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/CampaignDryRunDto.cs",
      "sha256": "eb3c8b6acf0bcc6f3ce31d5d3b62a9183655a8bdcef813406921403f8625371b",
      "language": "csharp",
      "size": 1530,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    public sealed class CampaignDryRunRecipientResultDto\n    {\n        public Guid? ContactId { get; set; }\n        public string? ContactName { get; set; }\n        public string PhoneNumber { get; set; } = \"\";\n        public bool WouldSend { get; set; }\n        public List<string> Errors { get; set; } = new();\n        public List<string> Warnings { get; set; } = new();\n\n        // Provider-shaped components (Meta/Pinnacle compatible)\n        public List<object> ProviderComponents { get; set; } = new();\n    }\n\n    public sealed class CampaignDryRunResponseDto\n    {\n        public Guid CampaignId { get; set; }\n        public string CampaignType { get; set; } = \"\";\n        public string TemplateName { get; set; } = \"\";\n        public string? Language { get; set; }\n        public bool HasHeaderMedia { get; set; }\n        public int RequiredPlaceholders { get; set; }\n        public int ProvidedPlaceholders { get; set; }\n\n        public int RecipientsConsidered { get; set; }\n        public int WouldSendCount { get; set; }\n        public int ErrorCount { get; set; }\n\n        // Billability (best-effort estimate)\n        public bool EstimatedChargeable { get; set; } = true;\n        public string EstimatedConversationCategory { get; set; } = \"template_outbound\";\n        public List<string> Notes { get; set; } = new();\n\n        public List<CampaignDryRunRecipientResultDto> Results { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/CampaignDryRunDtos.cs",
      "sha256": "3ed24bbc0f923a1d28720fad67c5d2c1d8065edfb882467e24b0669d00433711",
      "language": "csharp",
      "size": 1116,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    public class CampaignDryRunIssueDto\n    {\n        public Guid? RecipientId { get; set; }\n        public Guid? ContactId { get; set; }\n        public string Phone { get; set; } = string.Empty;\n\n        /// <summary>\n        /// error | warn\n        /// </summary>\n        public string Severity { get; set; } = \"error\";\n\n        public string Message { get; set; } = string.Empty;\n    }\n\n    public class CampaignDryRunResultDto\n    {\n        public Guid CampaignId { get; set; }\n        public string TemplateName { get; set; } = string.Empty;\n        public string Language { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Placeholder count detected in the template (e.g., {{1}}, {{2}}, ...).\n        /// </summary>\n        public int PlaceholderCount { get; set; }\n\n        public int CheckedRecipients { get; set; }\n        public int ErrorCount { get; set; }\n        public int WarningCount { get; set; }\n\n        public List<CampaignDryRunIssueDto> Issues { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/CampaignDto.cs",
      "sha256": "bf33c6aa688063d8efd2734082713e23890bb97409bae31a5bc9d18c00ccd001",
      "language": "csharp",
      "size": 1223,
      "content": "using System;\nusing System.Collections.Generic;\nusing xbytechat.api.Features.CampaignModule.DTOs;\n\nnamespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    public class CampaignDto\n    {\n        public Guid Id { get; set; }\n\n        public string Name { get; set; }\n\n        public string MessageTemplate { get; set; }\n\n        public string? TemplateId { get; set; }\n        public string? MessageBody { get; set; }\n        public string? CampaignType { get; set; }\n\n        public string? Status { get; set; }\n\n        public string? ImageUrl { get; set; }\n\n        public string? ImageCaption { get; set; }\n\n        public DateTime CreatedAt { get; set; }\n\n        public DateTime? ScheduledAt { get; set; }\n\n        public Guid? CtaId { get; set; }\n\n        public CtaPreviewDto? Cta { get; set; }\n\n        public List<CampaignButtonDto> MultiButtons { get; set; } = new();\n\n        public Guid? CTAFlowConfigId { get; set; }\n        public string? CTAFlowName { get; set; }\n    }\n\n    // ðŸ“¦ Embedded DTO for CTA preview (title + button text only)\n    public class CtaPreviewDto\n    {\n        public string Title { get; set; } = string.Empty;\n\n        public string ButtonText { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/CampaignMaterializationDtos.cs",
      "sha256": "8764d77154e31907654114e66ffc6eb0c83f456db58b64632a1df0a92a139b8e",
      "language": "csharp",
      "size": 2077,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    public class ButtonResolutionDto\n    {\n        public string ButtonText { get; set; } = string.Empty;\n        public string? RawTemplateValue { get; set; } // e.g. \"https://x.com/{{1}}?q={{2}}\"\n        public string? ResolvedUrl { get; set; }\n        public List<string> UsedPlaceholders { get; set; } = new(); // e.g. [\"{{1}}\",\"{{2}}\"]\n        public List<string> MissingArguments { get; set; } = new(); // e.g. [\"{{2}}\"]\n        public List<string> Notes { get; set; } = new();\n    }\n\n    public class TemplateParamResolutionDto\n    {\n        public int Index { get; set; } // 1-based placeholder index from template ({{1}}, {{2}}, ...)\n        public string? Value { get; set; }\n        public string SourceType { get; set; } = string.Empty; // AudienceColumn | Static | Expression\n        public string? SourceKey { get; set; } // column name when SourceType = AudienceColumn\n        public bool IsMissing { get; set; }\n        public string? Note { get; set; }\n    }\n\n    public class MaterializedRecipientDto\n    {\n        public Guid? RecipientId { get; set; }      // when using CampaignRecipients\n        public Guid? ContactId { get; set; }\n        public string? Phone { get; set; }\n\n        public List<TemplateParamResolutionDto> Parameters { get; set; } = new();\n        public List<ButtonResolutionDto> Buttons { get; set; } = new();\n\n        public List<string> Warnings { get; set; } = new();\n        public List<string> Errors { get; set; } = new();\n    }\n\n    public class CampaignMaterializeResultDto\n    {\n        public Guid CampaignId { get; set; }\n        public string TemplateName { get; set; } = string.Empty;\n        public string Language { get; set; } = string.Empty;\n        public int PlaceholderCount { get; set; }\n\n        public int ReturnedCount { get; set; }\n        public int ErrorCount { get; set; }\n        public int WarningCount { get; set; }\n\n        public List<MaterializedRecipientDto> Rows { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/CampaignMaterializeDtos.cs",
      "sha256": "b0877006311fb95066d695b7004e7b9ac971424f049675ca95d2e24fbbbcced6",
      "language": "csharp",
      "size": 2046,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    public sealed class CampaignMaterializeRequestDto\n    {\n        [Required] public Guid CsvBatchId { get; set; }\n\n        /// <summary>\n        /// Optional explicit mapping: token -> CSV header name or \"constant:Value\".\n        /// If null/empty, weâ€™ll try loading saved mappings; if none exist, we fall back to header==token.\n        /// </summary>\n        public Dictionary<string, string>? Mappings { get; set; }\n\n        /// <summary>\n        /// If not provided, we will try common headers like phone, mobile, whatsapp, msisdn.\n        /// </summary>\n        public string? PhoneField { get; set; }\n\n        public bool NormalizePhones { get; set; } = true;\n        public bool Deduplicate { get; set; } = true;\n\n        /// <summary>Preview only first N rows; 0 or null means all.</summary>\n        public int? Limit { get; set; } = 200;\n\n        /// <summary>When true, materialized rows are persisted to Audience + CampaignRecipients.</summary>\n        public bool Persist { get; set; } = false;\n\n        /// <summary>Required when Persist = true.</summary>\n        public string? AudienceName { get; set; }\n    }\n\n    public sealed class MaterializedRowDto\n    {\n        public int RowIndex { get; set; }\n        public string? Phone { get; set; }\n        public Dictionary<string, string> Variables { get; set; } = new();\n        public List<string> Errors { get; set; } = new();\n    }\n\n    public sealed class CampaignMaterializeResponseDto\n    {\n        public Guid CampaignId { get; set; }\n        public Guid CsvBatchId { get; set; }\n        public int TotalRows { get; set; }\n        public int MaterializedCount { get; set; }\n        public int SkippedCount { get; set; }\n        public Guid? AudienceId { get; set; } // when persisted\n        public List<MaterializedRowDto> Preview { get; set; } = new();\n        public List<string> Warnings { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/CampaignPreviewDto.cs",
      "sha256": "ebe80e7f7af1dd5e800a15177ed1305cff9c9b04a8a9b5c000a8afc3de02d1c5",
      "language": "csharp",
      "size": 1547,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    public class CampaignPreviewRequestDto\n    {\n        // Optional: preview using a specific recipientâ€™s contact info\n        public Guid? ContactId { get; set; }\n    }\n\n    public class CampaignPreviewResponseDto\n    {\n        public Guid CampaignId { get; set; }\n        public string TemplateName { get; set; } = \"\";\n        public string Language { get; set; } = \"en_US\";\n        public int PlaceholderCount { get; set; }\n\n        public string BodyPreview { get; set; } = \"\";\n        public List<string> MissingParams { get; set; } = new();  // e.g. [\"{{2}} required but not supplied\"]\n\n        public bool HasHeaderMedia { get; set; }\n        public string? HeaderType { get; set; } // IMAGE/VIDEO/DOCUMENT (if you later persist)\n\n        public List<ButtonPreviewDto> Buttons { get; set; } = new();\n    }\n\n    public class ButtonPreviewDto\n    {\n        public int Index { get; set; }            // 0..2\n        public string Text { get; set; } = \"\";\n        public string Type { get; set; } = \"URL\"; // Meta types\n        public bool IsDynamic { get; set; }       // needs parameter\n        public string? TemplateParamBase { get; set; } // e.g. \"/r/{{1}}\"\n        public string? CampaignValue { get; set; } // what user set in campaign (for dynamic)\n        public string? TokenParam { get; set; }    // what weâ€™d send when base has {{1}}\n        public string? FinalUrlPreview { get; set; } // full tracked URL preview\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/CampaignRecipientDto.cs",
      "sha256": "028557690cc0247c25a5db36100a674f3a36f1d96ac0eba571a51fd3aa57febe",
      "language": "csharp",
      "size": 756,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    public class CampaignRecipientDto\n    {\n        public Guid Id { get; set; }\n\n        public Guid? ContactId { get; set; }\n        public string ContactName { get; set; }\n        public string ContactPhone { get; set; }\n\n        public string Status { get; set; }\n        public DateTime? SentAt { get; set; }\n\n        // ðŸ” Advanced Fields (for analytics & future automation)\n        public string? BotId { get; set; }\n        public string? MessagePreview { get; set; }\n        public string? ClickedCTA { get; set; }\n        public string? CategoryBrowsed { get; set; }\n        public string? ProductBrowsed { get; set; }\n        public bool IsAutoTagged { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/CampaignRetryDtos.cs",
      "sha256": "f6d2dd143ecf14f40ec9b5d30aad7ad83309e99f5aab199c117f31dce552d68f",
      "language": "csharp",
      "size": 539,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    public class CampaignRetryResultDto\n    {\n        public Guid CampaignId { get; set; }\n        public int ConsideredFailed { get; set; }\n        public int Retried { get; set; }\n        public int Skipped { get; set; }  // e.g., duplicates, already succeeded, or filtered out\n        public List<Guid> RecipientIdsSample { get; set; } = new(); // up to 20 IDs for quick inspection\n        public string? Note { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/CampaignSummaryDto.cs",
      "sha256": "e34665bb059ebf40c11f0bc8ab502fdbf8ed27b2139b2fcd6c48b33b07ac4bac",
      "language": "csharp",
      "size": 965,
      "content": "using System.Collections.Generic;\n\nnamespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    public class CampaignSummaryDto\n    {\n        public Guid Id { get; set; }\n        public string? Name { get; set; }\n        public string? Status { get; set; }\n        public DateTime? ScheduledAt { get; set; }\n        public DateTime CreatedAt { get; set; }\n        public int Delivered { get; set; }\n        public int Read { get; set; }\n\n        public string? ImageUrl { get; set; } // âœ… Add this\n        public string? ImageCaption { get; set; } // âœ… Add this\n        public string? CtaTitle { get; set; } // Optional: For CTA info\n        public int RecipientCount { get; set; } // Optional: To show 0/10 etc\n\n        public DateTime? SentAt { get; set; } // âœ… Added to track sent time\n\n        // âœ… Added for Preview\n        public string? MessageTemplate { get; set; } \n        public List<CampaignButtonDto>? MultiButtons { get; set; }\n    }\n        \n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/CampaignUsageDto.cs",
      "sha256": "11bbb343956c5c20a328cdab6846d82227497a5e8fbef864b3e3f71ddd503a0e",
      "language": "csharp",
      "size": 780,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    public sealed class CampaignUsageDto\n    {\n        public Guid CampaignId { get; set; }\n        public string? Name { get; set; }\n        public string Status { get; set; } = \"DRAFT\"; // DRAFT/SCHEDULED/QUEUED/SENDING/SENT/...\n        public int Recipients { get; set; }\n        public int QueuedJobs { get; set; }\n        public int SendLogs { get; set; }\n\n        // Flow linkage (for parity with CTA Flow deletion UX)\n        public bool HasFlow { get; set; }\n        public Guid? FlowId { get; set; }\n\n        // Useful timestamps for UX copy\n        public DateTime? CreatedAt { get; set; }\n        public DateTime? ScheduledAt { get; set; }\n        public DateTime? FirstSentAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/CampaignVariableMapDto.cs",
      "sha256": "09ea689514db078a870217be4fac18f0168d401c0cc23df1d1e9a96099feaa5e",
      "language": "csharp",
      "size": 936,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    public class CampaignVariableMapDto\n    {\n        public Guid CampaignId { get; set; }\n        public List<CampaignVariableMapItemDto> Items { get; set; } = new();\n    }\n\n    public class CampaignVariableMapItemDto\n    {\n        // Matches your normalized model fields\n        public string Component { get; set; } = \"\";   // \"body\", \"header\", \"button:url:1\"\n        public int Index { get; set; }                // 1..N\n\n        public string SourceType { get; set; } = \"Static\"; // ContactField | CsvColumn | Static | Expression\n        public string? SourceKey { get; set; }             // \"name\" / CSV header, etc.\n        public string? StaticValue { get; set; }\n        public string? Expression { get; set; }\n        public string? DefaultValue { get; set; }\n        public bool IsRequired { get; set; } = false;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/CsvBatchListItemDto.cs",
      "sha256": "a3ecc66b83ee911be585b7fc50285b27717bedb0f0d6a709ee1532a5116f338a",
      "language": "csharp",
      "size": 501,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    /// <summary>\n    /// Lightweight projection for listing recent CSV batches.\n    /// </summary>\n    public sealed class CsvBatchListItemDto\n    {\n        public Guid BatchId { get; set; }\n        public string? FileName { get; set; }\n        public int RowCount { get; set; }\n        public string Status { get; set; } = \"ready\"; // ready | ingesting | failed | complete\n        public DateTime CreatedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/CsvBatchRowsPageDto.cs",
      "sha256": "f884ce43dea32e9316e6d9c44036d937745a81ce2f82ea1da5625cdcd446f6a9",
      "language": "csharp",
      "size": 481,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    /// <summary>\n    /// Paged slice of CSV rows for previewing a batch.\n    /// </summary>\n    public sealed class CsvBatchRowsPageDto\n    {\n        public Guid BatchId { get; set; }\n        public int TotalRows { get; set; }\n        public int Skip { get; set; }\n        public int Take { get; set; }\n        public List<CsvRowSampleDto> Rows { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/CsvBatchValidationDtos.cs",
      "sha256": "ad1652fd6b89c2d226dd44e051a9b9c5311e7db7d377de150c8dafcd4e454bd2",
      "language": "csharp",
      "size": 1541,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    public sealed class CsvBatchValidationRequestDto\n    {\n        /// <summary>Explicit phone column to use; if null we'll try to auto-detect.</summary>\n        public string? PhoneField { get; set; }\n\n        /// <summary>Normalize phones (strip punctuation/leading zeros; add 91 for 10-digit local).</summary>\n        public bool NormalizePhones { get; set; } = true;\n\n        /// <summary>Report duplicates after normalization.</summary>\n        public bool Deduplicate { get; set; } = true;\n\n        /// <summary>Headers that must exist in the CSV.</summary>\n        public List<string>? RequiredHeaders { get; set; }\n\n        /// <summary>How many problematic rows to include in the response samples.</summary>\n        public int SampleSize { get; set; } = 20;\n    }\n\n    public sealed class CsvBatchValidationResultDto\n    {\n        public Guid BatchId { get; set; }\n        public int TotalRows { get; set; }\n\n        public string? PhoneField { get; set; }\n\n        public int MissingPhoneCount { get; set; }\n        public int DuplicatePhoneCount { get; set; }\n\n        public List<string> MissingRequiredHeaders { get; set; } = new();\n        public List<string> Warnings { get; set; } = new();\n        public List<string> Errors { get; set; } = new();\n\n        /// <summary>Sample of problematic rows (missing phone / dup / other).</summary>\n        public List<CsvRowSampleDto> ProblemSamples { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/FlowListItemDto.cs",
      "sha256": "3121c1e145f2d4fd8f1f4978f314782f0afa5d7be9ffe7be6709cfc04af7d068",
      "language": "csharp",
      "size": 246,
      "content": "namespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    public class FlowListItemDto\n    {\n        public Guid Id { get; set; }\n        public string FlowName { get; set; } = string.Empty;\n        public bool IsPublished { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/OutboundCampaignJobCreateDto.cs",
      "sha256": "31ade95e7e39a78f5fd669bc7ce9d887c7c004acd05e3e44eb0a6e487b837bd4",
      "language": "csharp",
      "size": 613,
      "content": "using System;\n\nnamespace xbytechat.api.Features.Queueing.DTOs\n{\n    /// <summary>\n    /// Minimal job creation payload for outbound campaign sends.\n    /// The worker will hydrate the template parameters from CampaignRecipient.\n    /// </summary>\n    public sealed class OutboundCampaignJobCreateDto\n    {\n        public Guid BusinessId { get; set; }\n        public Guid CampaignId { get; set; }\n        public Guid CampaignRecipientId { get; set; }\n\n        /// <summary>Deduplication key. The queue should drop duplicates with the same key.</summary>\n        public string? IdempotencyKey { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/OutboundCampaignJobDto.cs",
      "sha256": "3f95f27a03d9cf5a08d649a168cd9cf34b1e790c060f74411eb1cc8dd981f190",
      "language": "csharp",
      "size": 649,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    public class OutboundCampaignJobDto\n    {\n        public Guid Id { get; set; }\n        public Guid BusinessId { get; set; }\n        public Guid CampaignId { get; set; }\n\n        public string Status { get; set; } = \"queued\"; // queued | running | succeeded | failed | canceled\n        public int Attempt { get; set; }\n        public int MaxAttempts { get; set; }\n\n        public DateTimeOffset? NextAttemptAt { get; set; }\n        public string? LastError { get; set; }\n\n        public DateTime CreatedAt { get; set; }\n        public DateTime UpdatedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/Requests/CsvBatchUploadForm.cs",
      "sha256": "8d7abcaa0b234c79afe0fecb5e15221a682d1424f268caea86cd71181f14ceee",
      "language": "csharp",
      "size": 432,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing Microsoft.AspNetCore.Http;\n\nnamespace xbytechat.api.Features.CampaignModule.DTOs.Requests\n{\n    // Swagger-safe wrapper for multipart upload\n    public sealed class CsvBatchUploadForm\n    {\n        public Guid? AudienceId { get; set; }\n\n        [Required]\n        public IFormFile File { get; set; } = default!;\n\n        public Guid? CampaignId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/RescheduleDto.cs",
      "sha256": "ed9069221c8458a5aa8001cefe2e490c5739b33cf503b8b516e49013407283a9",
      "language": "csharp",
      "size": 180,
      "content": "namespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    public sealed class RescheduleDto\n    {\n        // must be UTC!\n        public DateTime NewUtcTime { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/RetargetCampaignRequestDto.cs",
      "sha256": "a3cc90536fd410b01c28bcab18d4c013e46218640bf42f4bb314efb7a8e18385",
      "language": "csharp",
      "size": 1295,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    /// <summary>\n    /// Retarget creates a NORMAL campaign in DB but skips audience assignment.\n    /// The selected recipients come explicitly from analytics selection.\n    /// </summary>\n    public class RetargetCampaignRequestDto\n    {\n        // Source context (optional but useful for audit + future UI)\n        public Guid SourceCampaignId { get; set; }\n        public Guid? SourceRunId { get; set; }\n        public string? SourceBucket { get; set; } // clicked | replied | failed | etc.\n\n        // The \"new campaign details\" user fills in retarget wizard\n        public string? Name { get; set; }\n        public CampaignCreateDto Campaign { get; set; } = new();\n\n        // Explicit selection\n        public List<Guid> ContactIds { get; set; } = new();      // preferred\n        public List<string> RecipientPhones { get; set; } = new(); // fallback for rows without ContactId\n\n        // Optional: safety\n        public bool Deduplicate { get; set; } = true;\n    }\n\n    public class RetargetCampaignResponseDto\n    {\n        public Guid NewCampaignId { get; set; }\n        public int MaterializedRecipients { get; set; }\n        public int SkippedDuplicates { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/SendJobDtos.cs",
      "sha256": "6e46d4af7214847bbbb20aad58770f26f7885d22c06b9fd7934ba21449e5e25f",
      "language": "csharp",
      "size": 1907,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    public enum SendJobState\n    {\n        Pending = 0,\n        Running = 1,\n        Succeeded = 2,\n        Failed = 3,\n        Canceled = 4,\n        Partial = 5\n    }\n\n    public class SendJobStartRequestDto\n    {\n        public bool Force { get; set; } = false;     // allow send even if dry-run has errors (logged loudly)\n        public int Limit { get; set; } = 2000;       // cap on planned recipients\n    }\n\n    public class SendJobStartResponseDto\n    {\n        public Guid JobId { get; set; }\n        public Guid CampaignId { get; set; }\n        public string Message { get; set; } = \"Send job queued.\";\n    }\n\n    public class SendJobBatchResultDto\n    {\n        public int BatchNumber { get; set; }\n        public int Count { get; set; }\n        public int Success { get; set; }\n        public int Failed { get; set; }\n        public int Skipped { get; set; }\n        public string Notes { get; set; } = string.Empty;\n        public int OffsetSeconds { get; set; }\n    }\n\n    public class SendJobStatusDto\n    {\n        public Guid JobId { get; set; }\n        public Guid CampaignId { get; set; }\n        public SendJobState State { get; set; }\n        public DateTimeOffset CreatedAt { get; set; }\n        public DateTimeOffset? StartedAt { get; set; }\n        public DateTimeOffset? CompletedAt { get; set; }\n\n        public int PlannedBatches { get; set; }\n        public int CompletedBatches { get; set; }\n\n        public int PlannedRecipients { get; set; }\n        public int SentSuccess { get; set; }\n        public int SentFailed { get; set; }\n        public int Skipped { get; set; }\n\n        public List<SendJobBatchResultDto> Batches { get; set; } = new();\n        public List<string> Warnings { get; set; } = new();\n        public List<string> Errors { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/VideoTemplateMessageDto.cs",
      "sha256": "d46c45dcc1d7b4109a51ea465c89038fe205538ef0d02d55804421de868b6bbb",
      "language": "csharp",
      "size": 631,
      "content": "// Features/CampaignModule/DTOs/VideoTemplateMessageDto.cs\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    public sealed class VideoTemplateMessageDto\n    {\n        public string RecipientNumber { get; set; } = \"\";\n        public string TemplateName { get; set; } = \"\";\n        public string LanguageCode { get; set; } = \"en_US\";\n\n        // URL for the video header (HTTPS)\n        public string? HeaderVideoUrl { get; set; }\n\n        public List<string> TemplateParameters { get; set; } = new();\n        public List<CampaignButtonDto> ButtonParameters { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Helpers/IVariableResolver.cs",
      "sha256": "f956c04fe5689e3e6613e4d68e1e7dd8ead05b4dd82944fddaffbda5fce24ede",
      "language": "csharp",
      "size": 316,
      "content": "using System.Collections.Generic;\n\nnamespace xbytechat.api.Features.CampaignModule.Helpers\n{\n    public interface IVariableResolver\n    {\n        Dictionary<string, string> ResolveVariables(\n            IReadOnlyDictionary<string, string> rowData,\n            IReadOnlyDictionary<string, string>? mappings);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Helpers/VariableResolver.cs",
      "sha256": "c197b1ec2533e625ecf3dfcaf4b0b493fee799da4bfc5e3daff06f171cc46716",
      "language": "csharp",
      "size": 3323,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Text.RegularExpressions;\n\nnamespace xbytechat.api.Features.CampaignModule.Helpers\n{\n    public sealed class VariableResolver : IVariableResolver\n    {\n        // Back-compat: legacy CSV columns -> canonical keys\n        //   headerpara1     => header.text_param1\n        //   buttonpara2     => button2.url_param\n        private static readonly Regex RxHeaderPara = new(@\"^headerpara(\\d+)$\",\n            RegexOptions.IgnoreCase | RegexOptions.Compiled);\n        private static readonly Regex RxButtonPara = new(@\"^buttonpara(\\d+)$\",\n            RegexOptions.IgnoreCase | RegexOptions.Compiled);\n\n        private static string CanonicalizeKey(string key)\n        {\n            if (string.IsNullOrWhiteSpace(key)) return string.Empty;\n            key = key.Trim();\n\n            var m1 = RxHeaderPara.Match(key);\n            if (m1.Success) return $\"header.text_param{m1.Groups[1].Value}\";\n\n            var m2 = RxButtonPara.Match(key);\n            if (m2.Success) return $\"button{m2.Groups[1].Value}.url_param\";\n\n            // Already canonical (parameterN, header.text_paramN, buttonX.url_param, or named body tokens)\n            return key;\n        }\n\n        public Dictionary<string, string> ResolveVariables(\n            IReadOnlyDictionary<string, string> rowData,\n            IReadOnlyDictionary<string, string>? mappings)\n        {\n            var result = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n\n            // Fast path: no explicit mappings â€” just canonicalize incoming CSV keys\n            if (mappings == null || mappings.Count == 0)\n            {\n                foreach (var kv in rowData)\n                {\n                    var canon = CanonicalizeKey(kv.Key);\n                    result[canon] = kv.Value?.Trim() ?? string.Empty;\n                }\n                return result;\n            }\n\n            // With explicit mappings: support constants and canonicalize source columns\n            foreach (var (token, srcRaw) in mappings)\n            {\n                if (string.IsNullOrWhiteSpace(token)) continue;\n\n                // Back-compat: allow mapping keys like \"headerpara1\"/\"buttonpara1\" and canonicalize them.\n                var canonToken = CanonicalizeKey(token);\n\n                var src = (srcRaw ?? string.Empty).Trim();\n\n                // Allow \"constant:VALUE\" mapping\n                if (src.StartsWith(\"constant:\", StringComparison.OrdinalIgnoreCase))\n                {\n                    result[canonToken] = src.Substring(\"constant:\".Length).Trim();\n                    continue;\n                }\n\n                // Canonicalize the source column name (handles legacy headerpara*/buttonpara*)\n                var canonSrc = CanonicalizeKey(src);\n\n                if (rowData.TryGetValue(canonSrc, out var vCanon) && vCanon != null)\n                {\n                    result[canonToken] = vCanon.Trim();\n                }\n                else if (rowData.TryGetValue(src, out var vRaw) && vRaw != null) // final fallback\n                {\n                    result[canonToken] = vRaw.Trim();\n                }\n                else\n                {\n                    result[canonToken] = string.Empty;\n                }\n            }\n\n            return result;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Models/Audience.cs",
      "sha256": "2db4c6eff72fe7fba7aa3c4f1ccd8fd9dc575292048d4d6fd27664c7a7ac0a94",
      "language": "csharp",
      "size": 1191,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.CampaignModule.Models\n{\n    /// <summary>\n    /// Logical grouping of recipients (often tied to a CsvBatch).\n    /// A campaign can materialize recipients from one Audience.\n    /// </summary>\n    public class Audience\n    {\n        [Key] public Guid Id { get; set; }\n\n        [Required] public Guid BusinessId { get; set; }\n\n        [Required, MaxLength(160)]\n        public string Name { get; set; } = \"Untitled Audience\";\n\n        [MaxLength(512)]\n        public string? Description { get; set; }  // useful in UI\n               \n        //public Guid? CampaignId { get; set; }\n        //public Campaign? Campaign { get; set; }\n\n        public Guid? CsvBatchId { get; set; }\n        public CsvBatch? CsvBatch { get; set; }\n\n        public bool IsDeleted { get; set; } = false;\n\n        public Guid? CreatedByUserId { get; set; }\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n        public DateTime? UpdatedAt { get; set; }   // audit\n\n        public ICollection<AudienceMember> Members { get; set; } = new List<AudienceMember>();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Models/AudienceMember.cs",
      "sha256": "9d7b99694c279cd7bd36310ea787ed4c4ee781e20167060799d281170358f6da",
      "language": "csharp",
      "size": 1615,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.CampaignModule.Models\n{\n    /// <summary>\n    /// A single member of an Audience. May or may not be linked to a Contact.\n    /// </summary>\n    public class AudienceMember\n    {\n        [Key] public Guid Id { get; set; }\n\n        [Required] public Guid AudienceId { get; set; }\n        public Audience Audience { get; set; } = null!;\n\n        // ðŸ†• explicit tenant for fast filtering & safety\n        [Required] public Guid BusinessId { get; set; }\n\n        /// <summary>Optional CRM link; null for non-CRM rows until promotion</summary>\n        public Guid? ContactId { get; set; }\n\n        [MaxLength(64)]\n        public string? PhoneRaw { get; set; }\n\n        [MaxLength(32)]\n        public string? PhoneE164 { get; set; }\n\n        [MaxLength(160)]\n        public string? Name { get; set; }\n\n        [MaxLength(256)]\n        public string? Email { get; set; }   // ðŸ†•\n\n        /// <summary>Additional attributes from CSV row (json)</summary>\n        public string? AttributesJson { get; set; } // keep name as-is\n\n        /// <summary>True if an â€œauto-createdâ€ CRM contact; subject to retention</summary>\n        public bool IsTransientContact { get; set; } = false;\n\n        public bool IsDeleted { get; set; } = false;  // ðŸ†•\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n        public DateTime? UpdatedAt { get; set; }      // ðŸ†•\n        public DateTime? PromotedAt { get; set; }     // when transient â†’ durable Contact\n        public Guid? CreatedByUserId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Models/Campaign.cs",
      "sha256": "023b91ed702fd11df1e6e408206c12bff9e0eccb212a7413c495303cfc69077a",
      "language": "csharp",
      "size": 3453,
      "content": "using System;\nusing System.Collections.Generic;\nusing xbytechat.api.Features.CRM.Models;\nusing xbytechat.api.Features.CampaignTracking.Models;\nusing xbytechat.api.Features.CTAManagement.Models;\nusing System.ComponentModel.DataAnnotations.Schema;\nusing xbytechat.api.Features.MessageManagement.DTOs;\nusing xbytechat.api.Features.BusinessModule.Models;\nusing xbytechat.api.Features.CTAFlowBuilder.Models; // ðŸ†• Import for CTAFlowConfig\n\nnamespace xbytechat.api.Features.CampaignModule.Models\n{\n    public class Campaign\n    {\n        public Guid Id { get; set; }\n\n        // ðŸ”— Business info\n        public Guid BusinessId { get; set; }\n        public Business Business { get; set; }\n        public Guid? CampaignId { get; set; }\n        public Campaign? SourceCampaign { get; set; }\n\n        // ðŸ“‹ Core campaign details\n        public string Name { get; set; }\n        public string MessageTemplate { get; set; }\n        public string? TemplateId { get; set; } // âœ… Meta-approved template ID\n\n        [Column(TypeName = \"text\")]\n        public string? MessageBody { get; set; } // âœ… Final resolved WhatsApp message body\n\n        public string? FollowUpTemplateId { get; set; }\n        public string? CampaignType { get; set; } // text, template, cta\n\n        // ðŸ”˜ CTA tracking (optional)\n        public Guid? CtaId { get; set; }\n        public CTADefinition? Cta { get; set; }\n\n        // ðŸ†• Link to Flow Config (optional)\n        public Guid? CTAFlowConfigId { get; set; }\n       // [ForeignKey(nameof(CTAFlowConfigId))]\n        public CTAFlowConfig? CTAFlowConfig { get; set; }\n\n        public DateTime? ScheduledAt { get; set; }\n        public string Status { get; set; } = \"Draft\"; // Draft, Scheduled, Sent\n\n        // ðŸ‘¤ Metadata\n        public string? CreatedBy { get; set; }\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n        public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;\n\n        // ðŸ—‘ï¸ Soft delete support\n        public bool IsDeleted { get; set; } = false;\n        public DateTime? DeletedAt { get; set; }\n        public string? DeletedBy { get; set; }\n\n        // ðŸ‘¥ Recipient relationship\n        public ICollection<CampaignRecipient> Recipients { get; set; }\n\n        // ðŸ“Š Logs\n        public ICollection<CampaignSendLog> SendLogs { get; set; } = new List<CampaignSendLog>();\n        public ICollection<MessageStatusLog> MessageStatusLogs { get; set; }\n\n        public string? ImageUrl { get; set; }\n        public string? ImageCaption { get; set; }\n        public string? TemplateParameters { get; set; }\n\n        public ICollection<CampaignButton> MultiButtons { get; set; } = new List<CampaignButton>();\n\n        public ICollection<MessageLog> MessageLogs { get; set; } = new List<MessageLog>();\n\n        public string? Provider { get; set; }            // UPPERCASE only\n        public string? PhoneNumberId { get; set; }\n\n        public string? TemplateSchemaSnapshot { get; set; }\n\n        public ICollection<CampaignVariableMap> VariableMaps { get; set; } = new List<CampaignVariableMap>();\n\n        //public Guid? AudienceId { get; set; }\n        //public ICollection<Audience> Audiences { get; set; } = new List<Audience>();\n\n        public string? VideoUrl { get; set; }\n        public string? DocumentUrl { get; set; }\n\n        public ICollection<CampaignAudienceAttachment> AudienceAttachments { get; set; }\n    = new List<CampaignAudienceAttachment>();\n    }\n}\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Models/CampaignAudienceAttachment.cs",
      "sha256": "d9336b2a36b378b21fb508769a89d241bf9d13b715ab58ed4b3728959d269b64",
      "language": "csharp",
      "size": 1070,
      "content": "// ðŸ“„ Features/CampaignModule/Models/CampaignAudienceAttachment.cs\nusing System;\nusing xbytechat.api.Features.BusinessModule.Models;\n\nnamespace xbytechat.api.Features.CampaignModule.Models\n{\n    public class CampaignAudienceAttachment\n    {\n        public Guid Id { get; set; }\n\n        public Guid BusinessId { get; set; }\n        public Business Business { get; set; } = default!;\n\n        public Guid CampaignId { get; set; }\n        public Campaign Campaign { get; set; } = default!;\n\n        public Guid AudienceId { get; set; }\n        public Audience Audience { get; set; } = default!;\n\n        public Guid CsvBatchId { get; set; }\n        public CsvBatch CsvBatch { get; set; } = default!;\n\n        // âœ… \"only one active attachment per campaign\"\n        public bool IsActive { get; set; } = true;\n\n        public string? FileName { get; set; }\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n        // When replaced/disabled\n        public DateTime? DeactivatedAt { get; set; }\n        public string? DeactivatedBy { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Models/CampaignButton.cs",
      "sha256": "bfca22e0aed3117f3be8b3712de4a7b229991bc3c4b02bdb1f17e43709991977",
      "language": "csharp",
      "size": 654,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CampaignModule.Models\n{\n    public class CampaignButton\n    {\n        public Guid Id { get; set; }\n\n        public Guid CampaignId { get; set; } // ðŸ”— Foreign key\n        public Campaign Campaign { get; set; }\n\n        public string Title { get; set; } = string.Empty; // Button Text (e.g. Buy Now)\n        public string Type { get; set; } = \"url\"; // Type: url, quick_reply, call, etc.\n        public string Value { get; set; } = string.Empty; // Target URL or payload\n\n        public int Position { get; set; } // Button order (1â€“3)\n        public bool IsFromTemplate { get; set; } = false;\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Models/CampaignFlowOverride.cs",
      "sha256": "c4ee719e7601cfb0eb6d67fbba7e11cbd4a57ad5be58dd84f72beead08d88370",
      "language": "csharp",
      "size": 798,
      "content": "using System.ComponentModel.DataAnnotations.Schema;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.CampaignModule.Models\n{\n    public class CampaignFlowOverride\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        [Required]\n        public Guid CampaignId { get; set; }\n\n        [Required]\n        [MaxLength(100)]\n        public string TemplateName { get; set; } = string.Empty;\n\n        [Required]\n        [MaxLength(50)]\n        public string ButtonText { get; set; } = string.Empty;\n\n        public string? OverrideNextTemplate { get; set; }\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n        public string? CreatedBy { get; set; }\n\n        [ForeignKey(\"CampaignId\")]\n        public Campaign? Campaign { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Models/CampaignRecipient.cs",
      "sha256": "ec0f719107e1e7ac5928e10245041ca32f9b14701d84deee6381b449edae8e05",
      "language": "csharp",
      "size": 1790,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.ComponentModel.DataAnnotations.Schema;\nusing xbytechat.api.Features.BusinessModule.Models;\nusing xbytechat.api.Features.CampaignTracking.Models;\nusing xbytechat.api.Features.CRM.Models;\n\nnamespace xbytechat.api.Features.CampaignModule.Models\n{\n    public class CampaignRecipient\n    {\n        public Guid Id { get; set; }\n\n        public Guid CampaignId { get; set; }\n        public Campaign? Campaign { get; set; }   // nav is optional at runtime\n\n        public Guid? ContactId { get; set; }      // â† optional FK\n        public Contact? Contact { get; set; }\n\n        public string Status { get; set; } = \"Pending\"; // Pending, Sent, Delivered, Failed, Replied\n        public DateTime? SentAt { get; set; }\n\n        public string? BotId { get; set; }\n        public string? MessagePreview { get; set; }\n        public string? ClickedCTA { get; set; }\n        public string? CategoryBrowsed { get; set; }\n        public string? ProductBrowsed { get; set; }\n        public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;\n\n        public bool IsAutoTagged { get; set; } = false;\n\n        // Logs\n        public ICollection<CampaignSendLog> SendLogs { get; set; } = new List<CampaignSendLog>();\n\n        public Guid BusinessId { get; set; }\n        public Business? Business { get; set; }\n\n        public Guid? AudienceMemberId { get; set; }\n        public AudienceMember? AudienceMember { get; set; } = null!;\n\n        [Column(TypeName = \"jsonb\")]\n        public string? ResolvedParametersJson { get; set; }\n\n        [Column(TypeName = \"jsonb\")]\n        public string? ResolvedButtonUrlsJson { get; set; }\n\n        public string? IdempotencyKey { get; set; }\n        public DateTime? MaterializedAt { get; set; }\n    }\n}\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Models/CampaignVariableMap.cs",
      "sha256": "c20c9a369db1d26855d7c1f75e480de9e892b21cc63635b31220904e75f0194b",
      "language": "csharp",
      "size": 2019,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.CampaignModule.Models\n{\n    /// <summary>\n    /// Maps a template placeholder to a data source for a specific campaign.\n    /// Examples of Component:\n    ///   \"body\", \"header\", \"button:url:1\"\n    /// Index is 1-based ({{1}}, {{2}}, ...).\n    /// </summary>\n    public class CampaignVariableMap\n    {\n        [Key] public Guid Id { get; set; }\n\n        [Required] public Guid CampaignId { get; set; }\n        public Campaign Campaign { get; set; } = null!;\n\n        /// <summary> \"body\" | \"header\" | \"button:url:1\" </summary>\n        [Required, MaxLength(64)]\n        public string Component { get; set; } = null!;\n\n        /// <summary> 1..N (corresponds to {{index}}) </summary>\n        [Required]\n        public int Index { get; set; }\n\n        /// <summary>\n        /// ContactField | CsvColumn | Static | Expression\n        /// </summary>\n        [Required, MaxLength(32)]\n        public string SourceType { get; set; } = null!;\n\n        /// <summary>\n        /// If SourceType == ContactField â†’ \"name\",\"phone\",\"email\",...\n        /// If SourceType == CsvColumn â†’ CSV header name.\n        /// Otherwise null.\n        /// </summary>\n        [MaxLength(128)]\n        public string? SourceKey { get; set; }\n\n        /// <summary>Used when SourceType == Static</summary>\n        public string? StaticValue { get; set; }\n\n        /// <summary>Optional expression (mini DSL) for computed values</summary>\n        public string? Expression { get; set; }\n\n        /// <summary>Fallback when source is empty/invalid</summary>\n        public string? DefaultValue { get; set; }\n\n        /// <summary>If true, missing value = validation error in dry-run</summary>\n        public bool IsRequired { get; set; } = false;\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n        public Guid? CreatedByUserId { get; set; }\n        public Guid BusinessId { get; set; }  // denormalized for ownership checks\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Models/CsvBatch.cs",
      "sha256": "9ab2036813c02e1428373fb89419b490fe5c4f4a0279eb40c5c2e5b8d87398cd",
      "language": "csharp",
      "size": 1513,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace xbytechat.api.Features.CampaignModule.Models\n{\n    /// <summary>\n    /// Represents a single CSV upload (file) for a business.\n    /// Stores headers and basic metadata; rows live in CsvRow.\n    /// </summary>\n    public class CsvBatch\n    {\n        [Key] public Guid Id { get; set; }\n\n        [Required] public Guid BusinessId { get; set; }\n\n        public Guid? AudienceId { get; set; }\n        /// <summary>Original filename, if available</summary>\n        [MaxLength(256)]\n        public string? FileName { get; set; }\n\n      \n        /// <summary>Comma-separated or JSON array of headers (weâ€™ll map to jsonb via DbContext)</summary>\n        public string? HeadersJson { get; set; }\n\n        /// <summary>SHA256 (or similar) of file contents for dedupe</summary>\n        [MaxLength(128)]\n        public string? Checksum { get; set; }\n\n        /// <summary>Total rows parsed (including headerless lines after validation)</summary>\n        public int RowCount { get; set; }\n\n        /// <summary>Total rows skipped due to validation</summary>\n        public int SkippedCount { get; set; }\n\n        [MaxLength(32)]\n        public string Status { get; set; } = \"ready\"; // ready | ingesting | failed | complete\n\n        public string? ErrorMessage { get; set; }\n\n        public Guid? CreatedByUserId { get; set; }\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Models/CsvBatchDtos.cs",
      "sha256": "8a302f82fd2cec1db09b6ef343902b803d507900620ea83b8e551b3e59d620c3",
      "language": "csharp",
      "size": 1008,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    public class CsvBatchUploadResultDto\n    {\n        public Guid BatchId { get; set; }\n        public Guid? AudienceId { get; set; }           // <-- nullable: matches CsvBatch.AudienceId (Guid?)\n        public int RowCount { get; set; }\n        public List<string> Headers { get; set; } = new();\n        public string Message { get; set; } = \"CSV batch created.\";\n        public string FileName { get; set; } = string.Empty;\n    }\n\n    public class CsvBatchInfoDto\n    {\n        public Guid BatchId { get; set; }\n        public Guid? AudienceId { get; set; }           // <-- nullable\n        public int RowCount { get; set; }\n        public List<string> Headers { get; set; } = new();\n        public DateTime CreatedAt { get; set; }\n    }\n\n    public class CsvRowSampleDto\n    {\n        public int RowIndex { get; set; }\n        public Dictionary<string, string?> Data { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Models/CsvRow.cs",
      "sha256": "26dc0e4b4ef801544a8e3935a243f3cb34507713dc1561f9cf08cd7895b316ba",
      "language": "csharp",
      "size": 1816,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace xbytechat.api.Features.CampaignModule.Models\n{\n    /// <summary>\n    /// One parsed CSV row. Data stored as JSON (key = header, value = cell).\n    /// RowIndex is 0-based (first data row = 0) to match streaming ingest.\n    /// </summary>\n    public class CsvRow\n    {\n        [Key] public Guid Id { get; set; }\n\n        /// <summary>Tenant scoping for fast filters</summary>\n        [Required] public Guid BusinessId { get; set; }\n\n        /// <summary>FK to CsvBatch.Id</summary>\n        [Required] public Guid BatchId { get; set; }\n        public CsvBatch Batch { get; set; } = null!;\n\n        /// <summary>0-based row number within the batch</summary>\n        [Required]\n        public int RowIndex { get; set; }\n\n        /// <summary>Raw phone, exactly as uploaded (optional convenience)</summary>\n        [MaxLength(64)]\n        public string? PhoneRaw { get; set; }\n\n        /// <summary>Normalized phone in E.164 (+&lt;country&gt;&lt;number&gt;)</summary>\n        [MaxLength(32)]\n        public string? PhoneE164 { get; set; }\n\n        /// <summary>JSON of the row: {\"header\":\"value\", ...}</summary>\n        public string RowJson { get; set; } = \"{}\";\n\n        /// <summary>\n        /// Back-compat shim for code that uses DataJson.\n        /// Not mapped to its own column; simply forwards to RowJson.\n        /// </summary>\n        [NotMapped]\n        public string? DataJson\n        {\n            get => RowJson;\n            set => RowJson = value ?? \"{}\";\n        }\n\n        /// <summary>If invalid at ingest/validation time, store reason here</summary>\n        public string? ValidationError { get; set; }\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Models/OutboundCampaignJob.cs",
      "sha256": "d9575f6ce2eee26b028d3f7d233b75faafc1be91456fee92b9d19a78ff0bf0e2",
      "language": "csharp",
      "size": 1507,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace xbytechat.api.Features.CampaignModule.Models\n{\n    /// <summary>\n    /// Queue item to send a whole campaign. Worker will call CampaignService to send.\n    /// </summary>\n    public class OutboundCampaignJob\n    {\n        [Key]\n        public Guid Id { get; set; } = Guid.NewGuid();\n\n        [Required]\n        public Guid BusinessId { get; set; }\n\n        [Required]\n        public Guid CampaignId { get; set; }\n\n        /// <summary>\n        /// queued | running | succeeded | failed\n        /// </summary>\n        [MaxLength(32)]\n        public string Status { get; set; } = \"queued\";\n\n        /// <summary>\n        /// Number of send attempts performed.\n        /// </summary>\n        public int Attempt { get; set; } = 0;\n\n        /// <summary>\n        /// Max attempts before we mark failed.\n        /// </summary>\n        public int MaxAttempts { get; set; } = 5;\n\n        /// <summary>\n        /// When this job becomes eligible for pickup (for backoff).\n        /// </summary>\n        public DateTimeOffset NextAttemptAt { get; set; } = DateTimeOffset.UtcNow;\n\n        /// <summary>\n        /// Last error string (truncated in service).\n        /// </summary>\n        [MaxLength(4000)]\n        public string? LastError { get; set; }\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n        public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Models/OutboundMessageJob.cs",
      "sha256": "a8fe42226a8e2a6e41dabd53f702ac9b75008309273bbd045a60088c9884ffbc",
      "language": "csharp",
      "size": 1725,
      "content": "using System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace xbytechat.api.Features.CampaignModule.Models\n{\n    public class OutboundMessageJob\n    {\n        [Key] public Guid Id { get; set; }\n\n        public Guid BusinessId { get; set; }\n        public Guid CampaignId { get; set; }\n        public Guid RecipientId { get; set; }\n\n        // Exactly what to send\n        public string Provider { get; set; } = string.Empty;          // DB value as-is\n        public string MediaType { get; set; } = \"text\";               // text|image|video|document\n        public string TemplateName { get; set; } = string.Empty;\n        public string LanguageCode { get; set; } \n        public string? PhoneNumberId { get; set; }                    // for Meta\n\n        // Pre-resolved components/materialization (avoid recomputation in worker)\n        public string ResolvedParamsJson { get; set; } = \"[]\";\n        public string ResolvedButtonUrlsJson { get; set; } = \"[]\";\n        public string? HeaderMediaUrl { get; set; }                   // image/video/document\n        public string? MessageBody { get; set; }                      // optional\n\n        // For idempotency (dedupe retries & restarts)\n        public string IdempotencyKey { get; set; } = string.Empty;\n\n        // Job lifecycle\n        public string Status { get; set; } = \"Pending\";               // Pending|InFlight|Sent|Failed|Dead\n        public int Attempt { get; set; } = 0;\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n        public DateTime? NextAttemptAt { get; set; }                  // backoff\n        public string? LastError { get; set; }                        // truncated\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Outbox/Channels.cs",
      "sha256": "ca54067f17dccbd7e50c182b8e84054c91fa3d13197de3544cb9d5b44eef8466",
      "language": "csharp",
      "size": 504,
      "content": "using System.Threading.Channels;\n\nnamespace XByteChat.api.Features.CampaignModule.Outbox;\n\npublic static class OutboxChannels\n{\n    public static readonly Channel<OutboundItem> SendChannel =\n        Channel.CreateBounded<OutboundItem>(new BoundedChannelOptions(10_000) { FullMode = BoundedChannelFullMode.Wait });\n\n    public static readonly Channel<MessageLog> LogChannel =\n        Channel.CreateBounded<MessageLog>(new BoundedChannelOptions(20_000) { FullMode = BoundedChannelFullMode.DropOldest });\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Outbox/OutboundModels.cs",
      "sha256": "ebd6f8966131b21aef8fe72d64a9b8844dbc9bc654f92d1658be6e28821dbe53",
      "language": "csharp",
      "size": 436,
      "content": "using xbytechat.api.Features.CampaignModule.SendEngine;\n\nnamespace XByteChat.api.Features.CampaignModule.Outbox;\n\npublic sealed record OutboundItem(\n    Guid CampaignId, Guid BusinessId, Provider Provider, string PhoneNumberId,\n    string TemplateName, string LanguageCode, HeaderKind HeaderKind, string? HeaderUrl,\n    string ParametersJson, string? ButtonParamsJson,\n    string ToPhoneE164, Guid RecipientId, string IdempotencyKey\n);\n"
    }
  ]
}
