{
  "name": "xbytechat-api/Features/Webhooks",
  "generatedAt": "2026-02-11 19:15:17 +00:00",
  "files": [
    {
      "path": "xbytechat-api/Features/Webhooks/BackgroundWorkers/WebhookAutoCleanupWorker.cs",
      "sha256": "5149c73a4fbcb11d9e501321407b1c7ae7ee660b8f7d612eca136b528f0467f2",
      "language": "csharp",
      "size": 1212,
      "content": "using xbytechat.api.Features.Webhooks.Services;\n\nnamespace xbytechat.api.Features.Webhooks.BackgroundWorkers\n{\n    public class WebhookAutoCleanupWorker : BackgroundService\n    {\n        private readonly ILogger<WebhookAutoCleanupWorker> _logger;\n        private readonly IServiceProvider _services;\n\n        public WebhookAutoCleanupWorker(IServiceProvider services, ILogger<WebhookAutoCleanupWorker> logger)\n        {\n            _services = services;\n            _logger = logger;\n        }\n\n        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n        {\n            while (!stoppingToken.IsCancellationRequested)\n            {\n                using var scope = _services.CreateScope();\n                var maintenanceService = scope.ServiceProvider.GetRequiredService<IMaintenanceService>();\n\n                if (await maintenanceService.IsAutoCleanupEnabledAsync())\n                {\n                    var count = await maintenanceService.RunCleanupAsync();\n                    _logger.LogInformation($\"üßπ Auto-cleaned {count} old webhook logs.\");\n                }\n\n                await Task.Delay(TimeSpan.FromHours(12), stoppingToken);\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/BackgroundWorkers/WebhookQueueWorker.cs",
      "sha256": "6c5ccb3f7da951f63b0828ac144f12392faabc37def6561ecfcad5a7aa253edc",
      "language": "csharp",
      "size": 3263,
      "content": "using System;\nusing System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.Webhooks.DTOs;\nusing xbytechat.api.Features.Webhooks.Services;\n\npublic class WebhookQueueWorker : BackgroundService\n{\n    private readonly IWebhookQueueService _queueService;\n    private readonly IServiceScopeFactory _scopeFactory;\n    private readonly ILogger<WebhookQueueWorker> _logger;\n\n    public WebhookQueueWorker(\n        IWebhookQueueService queueService,\n        IServiceScopeFactory scopeFactory,\n        ILogger<WebhookQueueWorker> logger)\n    {\n        _queueService = queueService;\n        _scopeFactory = scopeFactory;\n        _logger = logger;\n    }\n\n    protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n    {\n        _logger.LogInformation(\"üöÄ Webhook Queue Worker started.\");\n\n        while (!stoppingToken.IsCancellationRequested)\n        {\n            try\n            {\n                // Dequeue and clone once at the edge\n                var payload = await _queueService.DequeueAsync(stoppingToken);\n                var cloned = payload.Clone(); // keep independent of pooled reader\n                var rawJson = cloned.GetRawText(); // üëà capture raw JSON up-front\n\n                using var scope = _scopeFactory.CreateScope();\n\n                var dispatcher = scope.ServiceProvider.GetRequiredService<IWhatsAppWebhookDispatcher>();\n                var failureLogger = scope.ServiceProvider.GetRequiredService<IFailedWebhookLogService>();\n\n                try\n                {\n                    await dispatcher.DispatchAsync(cloned);\n                }\n                catch (Exception ex)\n                {\n                    _logger.LogError(ex, \"‚ùå Error while dispatching webhook payload.\");\n                    // Persist the full raw JSON so we can replay/debug later\n                    var fallback = new FailedWebhookLogDto\n                    {\n                        SourceModule = \"WebhookQueueWorker\",\n                        FailureType = \"DispatchError\",\n                        ErrorMessage = ex.Message,\n                        RawJson = string.IsNullOrWhiteSpace(rawJson) ? \"{}\" : rawJson,\n                        CreatedAt = DateTime.UtcNow\n                    };\n                    try\n                    {\n                        await failureLogger.LogFailureAsync(fallback);\n                    }\n                    catch (Exception innerEx)\n                    {\n                        _logger.LogError(innerEx, \"‚ö†Ô∏è Failed to write to FailedWebhookLogs.\");\n                    }\n                }\n            }\n            catch (OperationCanceledException)\n            {\n                _logger.LogInformation(\"üõë Graceful shutdown requested.\");\n                break;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Queue loop error (will retry shortly).\");\n                try { await Task.Delay(TimeSpan.FromSeconds(2), stoppingToken); } catch { /* ignore */ }\n            }\n        }\n\n        _logger.LogInformation(\"üõë Webhook Queue Worker stopped.\");\n    }\n}\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Controllers/FailedWebhookLogsController.cs",
      "sha256": "f16ada5c238d2293688a73b0c4428da7f91567d1ca100da1809f0b95ea65c2fc",
      "language": "csharp",
      "size": 1018,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.Tracking.Services;\nusing xbytechat.api.Features.Tracking.Models;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Webhooks.Services;\n\nnamespace xbytechat.api.Features.Tracking.Controllers\n{\n    [ApiController]\n    [Route(\"api/failed-webhooks\")]\n    public class FailedWebhookLogsController : ControllerBase\n    {\n        private readonly IFailedWebhookLogService _service;\n\n        public FailedWebhookLogsController(IFailedWebhookLogService service)\n        {\n            _service = service;\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> GetAllAsync()\n        {\n            var logs = await _service.GetAllAsync();\n            return Ok(logs);\n        }\n\n        [HttpGet(\"{id}\")]\n        public async Task<IActionResult> GetById(Guid id)\n        {\n            var log = await _service.GetByIdAsync(id);\n            if (log == null)\n                return NotFound();\n\n            return Ok(log);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Controllers/MaintenanceController.cs",
      "sha256": "2936737cca434f20b27184b1885f94a5a90a6a94453b29dc0a597b264cc6325d",
      "language": "csharp",
      "size": 3242,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Webhooks.Models;\nusing xbytechat.api.Features.Webhooks.Services;\n\nnamespace xbytechat.api.Features.Webhooks.Controllers\n{\n    [ApiController]\n    [Route(\"api/webhooks\")]\n    public class MaintenanceController : ControllerBase\n    {\n        private readonly AppDbContext _context;\n        private readonly IMaintenanceService _maintenance;\n\n        public MaintenanceController(AppDbContext context, IMaintenanceService maintenance)\n        {\n            _context = context;\n            _maintenance = maintenance;\n        }\n\n        // ‚úÖ Injected Test Log for Dev Testing\n        [HttpPost(\"inject-test-log\")]\n        public async Task<IActionResult> InjectTestLog()\n        {\n            var testLog = new FailedWebhookLog\n            {\n                SourceModule = \"WebhookQueueWorker\",\n                FailureType = \"DispatchError\",\n                ErrorMessage = \"üß™ Simulated webhook dispatch failure for testing.\",\n                RawJson = \"{\\\"sample\\\":\\\"test_payload\\\",\\\"reason\\\":\\\"unit_test\\\"}\",\n                CreatedAt = DateTime.UtcNow\n            };\n\n            _context.FailedWebhookLogs.Add(testLog);\n            await _context.SaveChangesAsync();\n\n            return Ok(new { message = \"‚úÖ Injected test log successfully.\" });\n        }\n\n        // ‚úÖ Manual Cleanup Trigger\n        [HttpPost(\"cleanup-now\")]\n        public async Task<IActionResult> CleanupNow()\n        {\n            var cutoff = DateTime.UtcNow.AddDays(-7);\n            var oldLogs = await _context.FailedWebhookLogs\n                .Where(x => x.CreatedAt < cutoff)\n                .ToListAsync();\n\n            if (!oldLogs.Any())\n                return Ok(new { message = \"‚úÖ No logs to delete.\" });\n\n            _context.FailedWebhookLogs.RemoveRange(oldLogs);\n            await _context.SaveChangesAsync();\n\n            return Ok(new { message = $\"‚úÖ Deleted {oldLogs.Count} old logs.\" });\n        }\n\n        // ‚úÖ Count of all failed logs\n        [HttpGet(\"failed/count\")]\n        public async Task<IActionResult> GetFailedCount()\n        {\n            var count = await _context.FailedWebhookLogs.CountAsync();\n            return Ok(count);\n        }\n\n        // ‚úÖ Cleanup Setting Status\n             [HttpGet(\"settings\")]\n        public async Task<IActionResult> GetCleanupStatus()\n        {\n            var enabled = await _maintenance.IsAutoCleanupEnabledAsync();\n            var lastRun = await _maintenance.GetLastCleanupTimeAsync();\n\n            return Ok(new\n            {\n                enabled,\n                lastCleanupAt = lastRun\n            });\n        }\n\n        // ‚úÖ Enable Auto Cleanup\n        [HttpPost(\"enable-cleanup\")]\n        public async Task<IActionResult> EnableCleanup()\n        {\n            await _maintenance.EnableAutoCleanupAsync();\n            return Ok(new { message = \"‚úÖ Auto-cleanup enabled.\" });\n        }\n\n        // ‚úÖ Disable Auto Cleanup\n        [HttpPost(\"disable-cleanup\")]\n        public async Task<IActionResult> DisableCleanup()\n        {\n            await _maintenance.DisableAutoCleanupAsync();\n            return Ok(new { message = \"‚úÖ Auto-cleanup disabled.\" });\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Controllers/WebhookCallback.cs",
      "sha256": "0353a97ed4f6c1349262de94a5e68f37d87955d3b6735e595aedc13f2b2f7365",
      "language": "csharp",
      "size": 2481,
      "content": "// üìÑ File: Features/Webhooks/Controllers/WebhookCallbackController.cs\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Text.Json;\nusing System.Threading;\nusing xbytechat.api.Features.Webhooks.Services;\n\nnamespace xbytechat.api.Features.Webhooks.Controllers\n{\n    [ApiController]\n    [Route(\"api/webhookcallback\")]\n    public class WebhookCallbackController : ControllerBase\n    {\n        private readonly ILogger<WebhookCallbackController> _logger;\n        private readonly IWebhookQueueService _queue;\n\n        public WebhookCallbackController(\n            ILogger<WebhookCallbackController> logger,\n            IWebhookQueueService queue)\n        {\n            _logger = logger;\n            _queue = queue;\n        }\n\n        // ‚úÖ Single POST endpoint: Pinnacle (and others) send responses here\n        [HttpPost]\n        [Consumes(\"application/json\")]\n        [Produces(\"application/json\")]\n        public IActionResult Post([FromBody] JsonElement payload, CancellationToken ct)\n        {\n            if (!Request.HasJsonContentType())\n            {\n                return BadRequest(new { error = \"Content-Type must be application/json\" });\n            }\n\n            try\n            {\n                var raw = payload.GetRawText();\n                _logger.LogInformation(\"üì• Webhook received. bytes={Len}\", raw.Length);\n\n                // Clone JsonElement before queueing\n                _queue.Enqueue(payload.Clone());\n\n                // Return 200 OK so Pinnacle won‚Äôt retry unnecessarily\n                return Ok(new { received = true });\n            }\n            catch (OperationCanceledException)\n            {\n                _logger.LogWarning(\"‚ö†Ô∏è Webhook processing cancelled by client.\");\n                return StatusCode(499);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Failed to enqueue webhook payload.\");\n                // 500 lets BSP retry later\n                return StatusCode(500, new { error = \"webhook_enqueue_failed\" });\n            }\n        }\n    }\n\n    // Small helper for JSON content-type\n    internal static class HttpRequestContentTypeExtensions\n    {\n        public static bool HasJsonContentType(this HttpRequest request)\n        {\n            if (request?.ContentType is null) return false;\n            return request.ContentType.StartsWith(\"application/json\", StringComparison.OrdinalIgnoreCase);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Controllers/WebhookTestController.cs",
      "sha256": "d3d3ac0e403d42baaa151d62e86135b71a0116ed7231d86c04b87bbd4ae6ac61",
      "language": "csharp",
      "size": 1569,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing System.Text.Json;\nusing xbytechat.api.Features.Webhooks.Services;\n\nnamespace xbytechat.api.Features.Webhooks.Controllers\n{\n    [ApiController]\n    [Route(\"api/webhooks/test\")]\n    public class WebhookTestController : ControllerBase\n    {\n        private readonly IWebhookQueueService _queue;\n\n        public WebhookTestController(IWebhookQueueService queue)\n        {\n            _queue = queue;\n        }\n\n        [HttpPost(\"simulate-failure\")]\n        public IActionResult SimulateWebhookFailure()\n        {\n            var fakePayload = new\n            {\n                entry = new[]\n                {\n                    new\n                    {\n                        changes = new[]\n                        {\n                            new\n                            {\n                                value = new\n                                {\n                                    // This will cause dispatcher to throw due to invalid structure\n                                    unexpected = \"üß™ Simulated bad structure\"\n                                }\n                            }\n                        }\n                    }\n                }\n            };\n\n            var json = JsonSerializer.Serialize(fakePayload);\n            var element = JsonDocument.Parse(json).RootElement;\n\n            _queue.Enqueue(element);\n\n            return Ok(new\n            {\n                message = \"‚úÖ Test payload enqueued to simulate failure.\",\n                enqueued = true\n            });\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Controllers/WhatsAppWebhookController.cs",
      "sha256": "62266e934e022c2fc0e5645927c04cde2ce156ce30c8c257050a07c2dfba3c50",
      "language": "csharp",
      "size": 4119,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing System.Text.Json;\nusing xbytechat.api.Features.Tracking.DTOs;\nusing xbytechat.api.Features.Webhooks.Services;\n\nnamespace xbytechat.api.Features.Webhooks.Controllers\n{\n    [ApiController]\n    [Route(\"api/webhooks/whatsapp\")]\n    public class WhatsAppWebhookController : ControllerBase\n    {\n        private readonly ILogger<WhatsAppWebhookController> _logger;\n        private readonly IConfiguration _config;\n        private readonly AppDbContext _context;\n        private readonly IWhatsAppWebhookService _webhookService;\n        private readonly IWebhookQueueService _queue;\n\n        public WhatsAppWebhookController(\n            ILogger<WhatsAppWebhookController> logger,\n            IConfiguration config,\n            AppDbContext context,\n            IWhatsAppWebhookService webhookService,\n            IWebhookQueueService queue)\n        {\n            _logger = logger;\n            _config = config;\n            _context = context;\n            _webhookService = webhookService;\n            _queue = queue;\n        }\n\n        // ‚úÖ Step 1: Meta verification endpoint (GET)\n        // Meta calls this to verify your webhook with hub.verify_token and expects you to return hub.challenge\n        [HttpGet]\n        public IActionResult VerifyWebhook(\n            [FromQuery(Name = \"hub.mode\")] string mode,\n            [FromQuery(Name = \"hub.verify_token\")] string token,\n            [FromQuery(Name = \"hub.challenge\")] string challenge)\n        {\n            _logger.LogInformation(\n                \"üîé WhatsApp webhook verification request received. mode={Mode}, tokenLength={TokenLength}\",\n                mode,\n                string.IsNullOrEmpty(token) ? 0 : token.Length);\n\n            // üîê Load your secret token from config or environment.\n            // Support multiple keys for safety/backward-compat:\n            //  - WhatsApp:MetaVerifyToken  (matches your appsettings)\n            //  - WhatsApp:MetaToken        (older name)\n            //  - WhatsApp:VerifyWebHookToken (what this code was using)\n            var expectedToken = _config[\"WhatsApp:VerifyWebHookToken\"];\n\n            if (string.IsNullOrWhiteSpace(expectedToken))\n            {\n                _logger.LogError(\n                    \"‚ùå WhatsApp webhook verification failed: no verify token configured. \" +\n                    \"Set WhatsApp:MetaVerifyToken (or WhatsApp:MetaToken / WhatsApp:VerifyWebHookToken) in configuration.\");\n                return Forbid(\"Server verify token not configured.\");\n            }\n\n            if (mode == \"subscribe\" && token == expectedToken)\n            {\n                _logger.LogInformation(\"‚úÖ WhatsApp webhook verified successfully.\");\n                return Ok(challenge); // Meta expects a 200 OK with the challenge value\n            }\n\n            _logger.LogWarning(\n                \"‚ùå WhatsApp webhook verification failed. Mode={Mode}, token did not match configured value.\",\n                mode);\n            return Forbid(\"Token mismatch.\");\n        }\n\n       \n\n        [HttpPost]\n        public IActionResult HandleStatus([FromBody] JsonElement payload)\n        {\n            try\n            {\n                var bodyString = payload.ToString();\n\n                _logger.LogInformation(\n                    \"üì• WhatsApp webhook POST received. Path={Path}, Query={Query}, Length={Length} chars.\",\n                    HttpContext.Request.Path,\n                    HttpContext.Request.QueryString.ToString(),\n                    bodyString?.Length ?? 0\n                );\n\n                var cloned = payload.Clone();\n                _queue.Enqueue(cloned);\n\n                _logger.LogInformation(\"üì• Webhook payload enqueued successfully.\");\n                return Ok(new { received = true });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Failed to enqueue WhatsApp webhook payload.\");\n                return StatusCode(500, new { error = \"Webhook queue failed\" });\n            }\n        }\n\n    }\n}\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Directory/IProviderDirectory.cs",
      "sha256": "9c5e07f8d7488efd67624a5d0b04fe85acf0163688ba6a704f500383e17210d4",
      "language": "csharp",
      "size": 995,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Directory\n{\n    /// <summary>\n    /// Resolves BusinessId from provider-specific webhook identifiers.\n    /// </summary>\n    public interface IProviderDirectory\n    {\n        /// <param name=\"provider\">\"meta\" or \"pinnacle\" (lowercase preferred)</param>\n        /// <param name=\"phoneNumberId\">Meta/Pinnacle phone_number_id (strongest key)</param>\n        /// <param name=\"displayPhoneNumber\">Formatted sending number (e.g. \"+91XXXXXXXXXX\")</param>\n        /// <param name=\"wabaId\">WhatsApp Business Account ID (Meta)</param>\n        /// <param name=\"waId\">Optional WA ID (recipient); used only as a last-ditch heuristic</param>\n        Task<Guid?> ResolveBusinessIdAsync(\n            string? provider,\n            string? phoneNumberId,\n            string? displayPhoneNumber,\n            string? wabaId,\n            string? waId,\n            CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Directory/ProviderDirectory.cs",
      "sha256": "1cecb32490d67fedaecdd7772fac54b530f8ac1d2225f7889c32c43c5584df2b",
      "language": "csharp",
      "size": 6767,
      "content": "using System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Caching.Memory;\nusing Microsoft.Extensions.Logging;\nusing xbytechat_api.WhatsAppSettings.Models;\n\nnamespace xbytechat.api.Features.Webhooks.Directory\n{\n    /// <summary>\n    /// EF-backed resolver for mapping provider identifiers to BusinessId, with a short cache.\n    /// </summary>\n    public class ProviderDirectory : IProviderDirectory\n    {\n        private readonly AppDbContext _db;\n        private readonly ILogger<ProviderDirectory> _logger;\n        private readonly IMemoryCache _cache;\n\n        // reduce DB hits during webhook bursts\n        private static readonly TimeSpan CacheTtl = TimeSpan.FromMinutes(2);\n\n        public ProviderDirectory(AppDbContext db, ILogger<ProviderDirectory> logger, IMemoryCache cache)\n        {\n            _db = db;\n            _logger = logger;\n            _cache = cache;\n        }\n        private static string NormalizeProviderKey(string? raw)\n        {\n            var p = (raw ?? \"\").Trim().ToLowerInvariant();\n            return p switch\n            {\n                \"meta\" or \"meta-cloud\" or \"meta_cloud\" => \"meta_cloud\",\n                \"pinnacle\" => \"pinnacle\",\n                _ => p\n            };\n        }\n        public async Task<Guid?> ResolveBusinessIdAsync(\n            string? provider,\n            string? phoneNumberId,\n            string? displayPhoneNumber,\n            string? wabaId,\n            string? waId,\n            CancellationToken ct = default)\n        {\n            provider = NormalizeProviderKey(provider);\n            if (provider is \"meta\" or \"meta-cloud\") provider = \"meta_cloud\";\n            var cacheKey = $\"provdir:{provider}:{phoneNumberId}:{Normalize(displayPhoneNumber)}:{wabaId}\";\n            if (_cache.TryGetValue<Guid?>(cacheKey, out var cached))\n                return cached;\n\n            try\n            {\n                // ‚öì 1) Strongest match: provider + phone_number_id\n                if (!string.IsNullOrWhiteSpace(provider) && !string.IsNullOrWhiteSpace(phoneNumberId))\n                {\n                    var hit = await QueryByAsync(provider, phoneNumberId: phoneNumberId, ct: ct);\n                    if (hit.HasValue) return CacheAndReturn(cacheKey, hit);\n                }\n\n                // ‚öì 2) Next: provider + display_phone_number (normalized)\n                var normalizedDisplay = Normalize(displayPhoneNumber);\n                if (!string.IsNullOrWhiteSpace(provider) && !string.IsNullOrWhiteSpace(normalizedDisplay))\n                {\n                    var hit = await QueryByAsync(provider, displayPhoneNumber: normalizedDisplay, ct: ct);\n                    if (hit.HasValue) return CacheAndReturn(cacheKey, hit);\n                }\n\n                // ‚öì 3) Next: provider + wabaId (Meta)\n                if (!string.IsNullOrWhiteSpace(provider) && !string.IsNullOrWhiteSpace(wabaId))\n                {\n                    var hit = await QueryByAsync(provider, wabaId: wabaId, ct: ct);\n                    if (hit.HasValue) return CacheAndReturn(cacheKey, hit);\n                }\n\n                _logger.LogWarning(\n                    \"ProviderDirectory: No match for provider={Provider}, pnid={PhoneId}, disp={Display}, waba={Waba}\",\n                    provider, phoneNumberId, normalizedDisplay, wabaId\n                );\n                return CacheAndReturn(cacheKey, null);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"ProviderDirectory lookup failed.\");\n                return null;\n            }\n        }\n\n        private Guid? CacheAndReturn(string key, Guid? value)\n        {\n            _cache.Set(key, value, CacheTtl);\n            return value;\n        }\n\n        /// <summary>\n        /// Centralized query; now materializes candidates so Normalize() runs in-memory.\n        /// </summary>\n        private async Task<Guid?> QueryByAsync(\n         string provider,\n         string? phoneNumberId = null,\n         string? displayPhoneNumber = null,\n         string? wabaId = null,\n         CancellationToken ct = default)\n        {\n            // Canonical provider (we always store in DB as CAPS)\n            provider = (provider ?? string.Empty)\n                .Trim()\n                .Replace(\"-\", \"_\")\n                .Replace(\" \", \"_\")\n                .ToUpperInvariant();\n\n            if (provider is not (\"PINNACLE\" or \"META_CLOUD\"))\n                return null;\n\n            var normDisp = Normalize(displayPhoneNumber); // your existing normalization (digits-only etc.)\n\n            // 1) Prefer exact match by sender (PhoneNumberId or display number) from WhatsAppPhoneNumbers\n            if (!string.IsNullOrWhiteSpace(phoneNumberId) || !string.IsNullOrWhiteSpace(normDisp))\n            {\n                var byNumber = await _db.WhatsAppPhoneNumbers\n                    .AsNoTracking()\n                    .Where(n => n.Provider == provider)\n                    .Where(n =>\n                        (!string.IsNullOrWhiteSpace(phoneNumberId) && n.PhoneNumberId == phoneNumberId) ||\n                        (!string.IsNullOrWhiteSpace(normDisp) && Normalize(n.WhatsAppBusinessNumber) == normDisp))\n                    .OrderByDescending(n => n.IsDefault)\n                    .ThenByDescending(n => n.UpdatedAt ?? n.CreatedAt)\n                    .Select(n => (Guid?)n.BusinessId)\n                    .FirstOrDefaultAsync(ct);\n\n                if (byNumber.HasValue)\n                    return byNumber;\n            }\n\n            // 2) Fallback: match by WABA on the settings row (still lives on settings)\n            if (!string.IsNullOrWhiteSpace(wabaId))\n            {\n                var byWaba = await _db.WhatsAppSettings\n                    .AsNoTracking()\n                    .Where(s => s.IsActive\n                                && s.Provider.ToUpper() == provider\n                                && s.WabaId == wabaId)\n                    .OrderByDescending(s => s.UpdatedAt ?? s.CreatedAt)\n                    .Select(s => (Guid?)s.BusinessId)\n                    .FirstOrDefaultAsync(ct);\n\n                if (byWaba.HasValue)\n                    return byWaba;\n            }\n\n            return null;\n        }\n\n        /// <summary>\n        /// Normalize phone formatting for robust comparisons.\n        /// </summary>\n        private static string? Normalize(string? phone)\n        {\n            if (string.IsNullOrWhiteSpace(phone)) return null;\n            var trimmed = phone.Trim();\n            var hasPlus = trimmed.StartsWith(\"+\");\n            var digits = new string(trimmed.Where(char.IsDigit).ToArray());\n            return hasPlus ? \"+\" + digits : digits;\n        }\n    }\n}\n\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/DTOs/FailedWebhookLogDto.cs",
      "sha256": "6b14d817a983f7eb6626a70cc5aceedd50b164ce0e0282dcf155a1d6eb4b5a51",
      "language": "csharp",
      "size": 391,
      "content": "using System;\n\nnamespace xbytechat.api.Features.Webhooks.DTOs\n{\n    public class FailedWebhookLogDto\n    {\n        public string? ErrorMessage { get; set; }\n        public string? SourceModule { get; set; }\n        public string? FailureType { get; set; }\n        public string RawJson { get; set; } = string.Empty;\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Models/FailedWebhookLog.cs",
      "sha256": "549e466af9a80b67809dd9e25d2bf5b9b5991ce11754225bda46dac4df1e6da6",
      "language": "csharp",
      "size": 624,
      "content": "using System;\n\nnamespace xbytechat.api.Features.Webhooks.Models\n{\n    public class FailedWebhookLog\n    {\n        public Guid Id { get; set; } = Guid.NewGuid();\n\n        // üß† Debug Metadata\n        public string? ErrorMessage { get; set; }\n        public string? SourceModule { get; set; } // e.g., StatusProcessor, ClickProcessor\n        public string? FailureType { get; set; }  // e.g., JSON_PARSE_ERROR, DB_LOOKUP_FAILED\n\n        // üì¶ Raw Data Snapshot\n        public string RawJson { get; set; } = string.Empty;\n\n        // üïí Timeline\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Models/WebhookSettings.cs",
      "sha256": "c0eeeaa5e14f839b159f28d337450f595c7604994690c66fa7df82a56c6a3093",
      "language": "csharp",
      "size": 267,
      "content": "namespace xbytechat.api.Features.Webhooks.Models\n{\n    public class WebhookSettings\n    {\n        public Guid Id { get; set; } = Guid.NewGuid();\n        public bool AutoCleanupEnabled { get; set; } = true;\n        public DateTime? LastCleanupAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Pinnacle/Controllers/PinnacleWebhookController.cs",
      "sha256": "347412f9e7ce91e2e2852339fcb267da0f2153f38df4bfe8902a1f0b4a678ca8",
      "language": "csharp",
      "size": 1235,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing System.Text.Json;\nusing xbytechat.api.Features.Webhooks.Pinnacle.Services.Adapters;\nusing xbytechat.api.Features.Webhooks.Services;\n\nnamespace xbytechat.api.Features.Webhooks.Pinnacle.Controllers\n{\n    [ApiController]\n    [Route(\"api/pinnacle/callback\")]\n    public sealed class PinnacleWebhookController : ControllerBase\n    {\n        private readonly IWebhookQueueService _queue;\n        private readonly IPinnacleToMetaAdapter _adapter;\n        private readonly ILogger<PinnacleWebhookController> _logger;\n\n        public PinnacleWebhookController(IWebhookQueueService queue, IPinnacleToMetaAdapter adapter, ILogger<PinnacleWebhookController> logger)\n        {\n            _queue = queue;\n            _adapter = adapter;\n            _logger = logger;\n        }\n\n        [HttpPost]\n        public IActionResult Post([FromBody] JsonElement body)\n        {\n            // Transform to the envelope WhatsAppWebhookDispatcher already expects\n            var metaEnvelope = _adapter.ToMetaEnvelope(body);\n            _queue.Enqueue(metaEnvelope);\n            _logger.LogInformation(\"üì® Pinnacle payload transformed and enqueued.\");\n            return Ok(new { received = true });\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Pinnacle/Services/Adapters/IPinnacleToMetaAdapter.cs",
      "sha256": "7daf100e2d244ce83b0c3f91f8e006bce5359eddf8fe6f7cf2b046f9e071c17b",
      "language": "csharp",
      "size": 364,
      "content": "using System.Text.Json;\n\nnamespace xbytechat.api.Features.Webhooks.Pinnacle.Services.Adapters\n{\n    public interface IPinnacleToMetaAdapter\n    {\n        /// <summary>Converts provider-native payload to Meta-like envelope:\n        /// { \"entry\":[{ \"changes\":[{ \"value\": { ... } }]}] }</summary>\n        JsonElement ToMetaEnvelope(JsonElement pinnPayload);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Pinnacle/Services/Adapters/PinnacleToMetaAdapter.cs",
      "sha256": "38b4863c5f4881b2196ae42ce86a47b8d92904a61daad400ab8d1e7e5db2d289",
      "language": "csharp",
      "size": 9751,
      "content": "using System.Buffers;\nusing System.Text.Json;\n\nnamespace xbytechat.api.Features.Webhooks.Pinnacle.Services.Adapters;\n\npublic sealed class PinnacleToMetaAdapter : IPinnacleToMetaAdapter\n{\n    public JsonElement ToMetaEnvelope(JsonElement p)\n    {\n        var buf = new ArrayBufferWriter<byte>();\n        using var w = new Utf8JsonWriter(buf);\n\n        w.WriteStartObject();\n        w.WritePropertyName(\"entry\");\n        w.WriteStartArray();\n        w.WriteStartObject(); // entry[0]\n        w.WritePropertyName(\"changes\");\n        w.WriteStartArray();\n        w.WriteStartObject(); // changes[0]\n        w.WritePropertyName(\"value\");\n        w.WriteStartObject();\n\n        // NEW: try to emit metadata up-front (harmless if not found)\n        WriteMetadata(p, w);\n\n        if (!TryMapStatuses(p, w) && !TryMapMessages(p, w))\n        {\n            w.WritePropertyName(\"provider_raw\");\n            p.WriteTo(w);\n        }\n\n        w.WriteEndObject(); // value\n        w.WriteEndObject(); // change\n        w.WriteEndArray();  // changes\n        w.WriteEndObject(); // entry[0]\n        w.WriteEndArray();  // entry\n        w.WriteEndObject(); // root\n        w.Flush();\n\n        var ros = new ReadOnlySequence<byte>(buf.WrittenMemory);\n        using var doc = JsonDocument.Parse(ros);\n        return doc.RootElement.Clone();\n    }\n\n    // ---- NEW ----\n    // Best-effort extraction; tolerate any Pinnacle layout you have.\n    // We only write fields if we can resolve them.\n    private static void WriteMetadata(JsonElement p, Utf8JsonWriter w)\n    {\n        string? displayPhone = null;\n        string? phoneNumberId = null;\n        string? wabaId = null;\n\n        // common guesses; add/rename to match your Pinnacle payload\n        // 1) flat\n        if (p.TryGetProperty(\"display_phone_number\", out var d1) && d1.ValueKind == JsonValueKind.String) displayPhone = d1.GetString();\n        if (p.TryGetProperty(\"phone_number_id\", out var pid1) && pid1.ValueKind == JsonValueKind.String) phoneNumberId = pid1.GetString();\n        if (p.TryGetProperty(\"waba_id\", out var wa1) && wa1.ValueKind == JsonValueKind.String) wabaId = wa1.GetString();\n\n        // 2) channel\n        if (p.TryGetProperty(\"channel\", out var ch) && ch.ValueKind == JsonValueKind.Object)\n        {\n            if (displayPhone is null && ch.TryGetProperty(\"display_phone_number\", out var d2) && d2.ValueKind == JsonValueKind.String) displayPhone = d2.GetString();\n            if (displayPhone is null && ch.TryGetProperty(\"phone\", out var d3) && d3.ValueKind == JsonValueKind.String) displayPhone = d3.GetString();\n\n            if (phoneNumberId is null && ch.TryGetProperty(\"phone_number_id\", out var pid2) && pid2.ValueKind == JsonValueKind.String) phoneNumberId = pid2.GetString();\n            if (phoneNumberId is null && ch.TryGetProperty(\"id\", out var pid3) && pid3.ValueKind == JsonValueKind.String) phoneNumberId = pid3.GetString();\n\n            if (wabaId is null && ch.TryGetProperty(\"waba_id\", out var wa2) && wa2.ValueKind == JsonValueKind.String) wabaId = wa2.GetString();\n        }\n\n        // 3) meta-style wrapper\n        if (p.TryGetProperty(\"metadata\", out var meta) && meta.ValueKind == JsonValueKind.Object)\n        {\n            if (displayPhone is null && meta.TryGetProperty(\"display_phone_number\", out var d4) && d4.ValueKind == JsonValueKind.String) displayPhone = d4.GetString();\n            if (phoneNumberId is null && meta.TryGetProperty(\"phone_number_id\", out var pid4) && pid4.ValueKind == JsonValueKind.String) phoneNumberId = pid4.GetString();\n            if (wabaId is null && meta.TryGetProperty(\"waba_id\", out var wa3) && wa3.ValueKind == JsonValueKind.String) wabaId = wa3.GetString();\n        }\n\n        if (displayPhone is null && p.TryGetProperty(\"business\", out var biz) && biz.ValueKind == JsonValueKind.Object)\n        {\n            if (biz.TryGetProperty(\"phone\", out var d5) && d5.ValueKind == JsonValueKind.String) displayPhone = d5.GetString();\n            if (biz.TryGetProperty(\"phone_id\", out var pid5) && pid5.ValueKind == JsonValueKind.String) phoneNumberId = pid5.GetString();\n        }\n\n        // Only emit if we have at least one of them.\n        if (displayPhone is not null || phoneNumberId is not null || wabaId is not null)\n        {\n            w.WritePropertyName(\"metadata\");\n            w.WriteStartObject();\n            if (displayPhone is not null) w.WriteString(\"display_phone_number\", displayPhone);\n            if (phoneNumberId is not null) w.WriteString(\"phone_number_id\", phoneNumberId);\n            if (wabaId is not null) w.WriteString(\"waba_id\", wabaId);\n            w.WriteEndObject();\n        }\n    }\n    // ---- NEW END ----\n\n    private static bool TryMapStatuses(JsonElement p, Utf8JsonWriter w)\n    {\n        string? id = null, status = null;\n        long? ts = null;\n\n        if (p.TryGetProperty(\"messageId\", out var mid) && mid.ValueKind == JsonValueKind.String) id = mid.GetString();\n        if (p.TryGetProperty(\"id\", out var pid) && pid.ValueKind == JsonValueKind.String) id ??= pid.GetString();\n        if (p.TryGetProperty(\"status\", out var st) && st.ValueKind == JsonValueKind.String) status = st.GetString();\n\n        if (p.TryGetProperty(\"timestamp\", out var t))\n        {\n            if (t.ValueKind == JsonValueKind.Number) ts = t.GetInt64();\n            else if (t.ValueKind == JsonValueKind.String && long.TryParse(t.GetString(), out var n)) ts = n;\n        }\n\n        if (p.TryGetProperty(\"data\", out var d) && d.ValueKind == JsonValueKind.Object)\n        {\n            if (id is null && d.TryGetProperty(\"id\", out var did) && did.ValueKind == JsonValueKind.String) id = did.GetString();\n            if (status is null && d.TryGetProperty(\"status\", out var ds) && ds.ValueKind == JsonValueKind.String) status = ds.GetString();\n            if (ts is null && d.TryGetProperty(\"ts\", out var dts) && dts.ValueKind == JsonValueKind.Number) ts = dts.GetInt64();\n        }\n\n        if (id is null || status is null) return false;\n\n        w.WritePropertyName(\"statuses\");\n        w.WriteStartArray();\n        w.WriteStartObject();\n        w.WriteString(\"id\", id);\n        w.WriteString(\"status\", status);\n        if (ts.HasValue) w.WriteNumber(\"timestamp\", ts.Value);\n        w.WriteEndObject();\n        w.WriteEndArray();\n        return true;\n    }\n\n    \n    private static bool TryMapMessages(JsonElement p, Utf8JsonWriter w)\n    {\n        // { \"click\": { \"title\":\"Flow Test\", \"contextId\":\"wamid..\", \"from\":\"<biz_phone?>\" , \"user\":\"<customer_wa_id?>\" } }\n        if (p.TryGetProperty(\"click\", out var c) && c.ValueKind == JsonValueKind.Object)\n        {\n            var title = c.TryGetProperty(\"title\", out var t) ? t.GetString() : null;\n            var ctxId = c.TryGetProperty(\"contextId\", out var ctx) ? ctx.GetString() : null;\n\n            // customer who clicked\n            var customerFrom = c.TryGetProperty(\"user\", out var u) && u.ValueKind == JsonValueKind.String\n                ? u.GetString()\n                : (c.TryGetProperty(\"from\", out var f1) && f1.ValueKind == JsonValueKind.String ? f1.GetString() : null);\n\n            // **business** number that sent the message (Meta provides this as context.from)\n            var businessFrom =\n                (p.TryGetProperty(\"display_phone_number\", out var d1) && d1.ValueKind == JsonValueKind.String) ? d1.GetString() :\n                (p.TryGetProperty(\"channel\", out var ch) && ch.ValueKind == JsonValueKind.Object &&\n                 ch.TryGetProperty(\"phone\", out var d2) && d2.ValueKind == JsonValueKind.String) ? d2.GetString() :\n                (c.TryGetProperty(\"from\", out var f2) && f2.ValueKind == JsonValueKind.String ? f2.GetString() : null); // last resort\n\n            if (!string.IsNullOrWhiteSpace(title) && !string.IsNullOrWhiteSpace(ctxId))\n            {\n                w.WritePropertyName(\"messages\");\n                w.WriteStartArray();\n                w.WriteStartObject();\n                w.WriteString(\"type\", \"button\");\n                w.WriteString(\"from\", customerFrom ?? \"\");          // customer wa_id\n                w.WritePropertyName(\"button\");\n                w.WriteStartObject();\n                w.WriteString(\"text\", title!);\n                w.WriteEndObject();\n                w.WritePropertyName(\"context\");\n                w.WriteStartObject();\n                w.WriteString(\"id\", ctxId!);\n                if (!string.IsNullOrWhiteSpace(businessFrom))\n                    w.WriteString(\"from\", businessFrom!);           // **important for directory resolution**\n                w.WriteEndObject();\n                w.WriteEndObject();\n                w.WriteEndArray();\n                return true;\n            }\n        }\n\n        // { \"message\": { \"from\":\"<customer_wa_id>\", \"body\":\"hi\", \"type\":\"text\" }, \"channel\":{ \"phone\":\"<biz_phone>\" } }\n        if (p.TryGetProperty(\"message\", out var m) && m.ValueKind == JsonValueKind.Object)\n        {\n            var type = m.TryGetProperty(\"type\", out var tp) ? tp.GetString() : \"text\";\n            var from = m.TryGetProperty(\"from\", out var fr) ? fr.GetString() : \"\";\n\n            w.WritePropertyName(\"messages\");\n            w.WriteStartArray();\n            w.WriteStartObject();\n            w.WriteString(\"type\", type ?? \"text\");\n            w.WriteString(\"from\", from ?? \"\");\n            if ((type ?? \"text\") == \"text\")\n            {\n                var body = m.TryGetProperty(\"body\", out var bd) ? bd.GetString() : \"\";\n                w.WritePropertyName(\"text\");\n                w.WriteStartObject();\n                w.WriteString(\"body\", body ?? \"\");\n                w.WriteEndObject();\n            }\n            w.WriteEndObject();\n            w.WriteEndArray();\n            return true;\n        }\n\n        return false;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/FailedWebhookLogCleanupService.cs",
      "sha256": "c826dbce9f60dfadb71a401a0ce48f0f5e9039181f5a18b115be558e0be38b9e",
      "language": "csharp",
      "size": 3798,
      "content": "using System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    /// <summary>\n    /// Periodic cleanup of old failed webhook logs.\n    /// Runs as a background service and exits cleanly on shutdown.\n    /// </summary>\n    public sealed class FailedWebhookLogCleanupService : BackgroundService\n    {\n        private readonly ILogger<FailedWebhookLogCleanupService> _logger;\n        private readonly IServiceScopeFactory _scopeFactory;\n        private readonly TimeSpan _interval = TimeSpan.FromHours(24); // daily run\n\n        public FailedWebhookLogCleanupService(\n            ILogger<FailedWebhookLogCleanupService> logger,\n            IServiceScopeFactory scopeFactory)\n        {\n            _logger = logger;\n            _scopeFactory = scopeFactory;\n        }\n\n        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n        {\n            _logger.LogInformation(\"üßπ FailedWebhookLogCleanupService started.\");\n\n            while (!stoppingToken.IsCancellationRequested)\n            {\n                try\n                {\n                    // If shutdown requested, bail out before touching DI / DbContext\n                    stoppingToken.ThrowIfCancellationRequested();\n\n                    using var scope = _scopeFactory.CreateScope();\n                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n\n                    var cutoff = DateTime.UtcNow.AddDays(-7);\n\n                    var oldLogs = await db.FailedWebhookLogs\n                        .Where(x => x.CreatedAt < cutoff)\n                        .ToListAsync(stoppingToken);\n\n                    if (oldLogs.Count > 0)\n                    {\n                        db.FailedWebhookLogs.RemoveRange(oldLogs);\n                        await db.SaveChangesAsync(stoppingToken);\n                        _logger.LogInformation(\n                            \"üßπ Deleted {Count} old failed webhook logs.\",\n                            oldLogs.Count\n                        );\n                    }\n                }\n                catch (OperationCanceledException) when (stoppingToken.IsCancellationRequested)\n                {\n                    // Normal shutdown ‚Äì just break the loop\n                    _logger.LogDebug(\n                        \"FailedWebhookLogCleanupService cancellation requested, exiting loop.\"\n                    );\n                    break;\n                }\n                catch (ObjectDisposedException) when (stoppingToken.IsCancellationRequested)\n                {\n                    // DI container / DbContext got disposed during shutdown; safe to ignore\n                    _logger.LogDebug(\n                        \"AppDbContext/ServiceProvider disposed during shutdown in FailedWebhookLogCleanupService.\"\n                    );\n                    break;\n                }\n                catch (Exception ex)\n                {\n                    _logger.LogError(ex, \"‚ùå Failed to clean up old webhook logs.\");\n                }\n\n                try\n                {\n                    await Task.Delay(_interval, stoppingToken);\n                }\n                catch (OperationCanceledException) when (stoppingToken.IsCancellationRequested)\n                {\n                    _logger.LogDebug(\n                        \"FailedWebhookLogCleanupService delay cancelled, exiting loop.\"\n                    );\n                    break;\n                }\n            }\n\n            _logger.LogInformation(\"üõë FailedWebhookLogCleanupService stopped.\");\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/FailedWebhookLogService.cs",
      "sha256": "3da6a5ad043773f7684b6ea9bc208441cbc36a7e53f01eacdd7c17848118c2af",
      "language": "csharp",
      "size": 1791,
      "content": "using System;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.Webhooks.DTOs;\nusing xbytechat.api.Features.Webhooks.Models;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public class FailedWebhookLogService : IFailedWebhookLogService\n    {\n        private readonly AppDbContext _context;\n        private readonly ILogger<FailedWebhookLogService> _logger;\n\n        public FailedWebhookLogService(AppDbContext context, ILogger<FailedWebhookLogService> logger)\n        {\n            _context = context;\n            _logger = logger;\n        }\n\n        public async Task LogFailureAsync(FailedWebhookLogDto dto)\n        {\n            try\n            {\n                var log = new FailedWebhookLog\n                {\n                    ErrorMessage = dto.ErrorMessage,\n                    SourceModule = dto.SourceModule,\n                    FailureType = dto.FailureType,\n                    RawJson = dto.RawJson,\n                    CreatedAt = dto.CreatedAt\n                };\n\n                await _context.FailedWebhookLogs.AddAsync(log);\n                await _context.SaveChangesAsync();\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Failed to persist webhook error log\");\n            }\n        }\n\n        public async Task<List<FailedWebhookLog>> GetAllAsync()\n        {\n            return await _context.FailedWebhookLogs\n                .OrderByDescending(x => x.CreatedAt)\n                .Take(100) // prevent DB overload\n                .ToListAsync();\n        }\n\n        public async Task<FailedWebhookLog?> GetByIdAsync(Guid id)\n        {\n            return await _context.FailedWebhookLogs.FindAsync(id);\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/IFailedWebhookLogService.cs",
      "sha256": "9366c7a087317049e7dee346a65f7ea81a76fe95fb98fe21ca457e0ed5db6a7c",
      "language": "csharp",
      "size": 396,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.Webhooks.DTOs;\nusing xbytechat.api.Features.Webhooks.Models;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public interface IFailedWebhookLogService\n    {\n        Task LogFailureAsync(FailedWebhookLogDto dto);\n        Task<List<FailedWebhookLog>> GetAllAsync();\n        Task<FailedWebhookLog?> GetByIdAsync(Guid id);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/IMaintenanceService.cs",
      "sha256": "76ef1df941e3536bbdce5e7213554b593e6431592ba6527334cf274c78357e26",
      "language": "csharp",
      "size": 323,
      "content": "namespace xbytechat.api.Features.Webhooks.Services\n{\n    public interface IMaintenanceService\n    {\n        Task<bool> IsAutoCleanupEnabledAsync();\n        Task EnableAutoCleanupAsync();\n        Task DisableAutoCleanupAsync();\n        Task<DateTime?> GetLastCleanupTimeAsync();\n        Task<int> RunCleanupAsync();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/IWebhookQueueService.cs",
      "sha256": "34e2e37f5ba5da57159852cecd9adde2f085640e1eb55a67116b5381ffa2e4b0",
      "language": "csharp",
      "size": 333,
      "content": "using System.Text.Json;\nusing xbytechat.api.Features.Tracking.DTOs;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public interface IWebhookQueueService\n    {\n        void Enqueue(JsonElement payload);\n        ValueTask<JsonElement> DequeueAsync(CancellationToken cancellationToken);\n        int GetQueueLength();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/IWhatsAppWebhookDispatcher.cs",
      "sha256": "844865d879bca5e59aa9d82cf7fabfb3ac241233391ca0544922a8902eed4a88",
      "language": "csharp",
      "size": 219,
      "content": "using System.Text.Json;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public interface IWhatsAppWebhookDispatcher\n    {\n        Task DispatchAsync(JsonElement payload);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/IWhatsAppWebhookService.cs",
      "sha256": "98275195ef353afc44e2ca27e1d7568450de21c0389a303b863809eee790fa99",
      "language": "csharp",
      "size": 302,
      "content": "using System.Text.Json;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public interface IWhatsAppWebhookService\n    {\n        Task ProcessStatusUpdateAsync(Guid businessId, string provider, JsonElement payload, CancellationToken ct = default);\n   \n    \n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/MaintenanceService.cs",
      "sha256": "c8c7e803e34fb97d2edfbaaf824d332f8de8b1483327e364e63d68dd0082a20e",
      "language": "csharp",
      "size": 2411,
      "content": "using Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Webhooks.Models;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public class MaintenanceService : IMaintenanceService\n    {\n        private readonly AppDbContext _context;\n\n        public MaintenanceService(AppDbContext context)\n        {\n            _context = context;\n        }\n\n        public async Task<bool> IsAutoCleanupEnabledAsync()\n        {\n            var setting = await _context.WebhookSettings\n                .AsNoTracking()\n                .FirstOrDefaultAsync();\n\n            return setting?.AutoCleanupEnabled ?? false;\n        }\n\n        public async Task<DateTime?> GetLastCleanupTimeAsync()\n        {\n            return await _context.WebhookSettings\n                .AsNoTracking()\n                .Select(s => s.LastCleanupAt)\n                .FirstOrDefaultAsync();\n        }\n\n        public async Task EnableAutoCleanupAsync()\n        {\n            var setting = await GetOrCreateAsync();\n            setting.AutoCleanupEnabled = true;\n            await _context.SaveChangesAsync();\n        }\n\n        public async Task DisableAutoCleanupAsync()\n        {\n            var setting = await GetOrCreateAsync();\n            setting.AutoCleanupEnabled = false;\n            await _context.SaveChangesAsync();\n        }\n\n        public async Task<int> RunCleanupAsync()\n        {\n            var threshold = DateTime.UtcNow.AddDays(-7);\n            var oldLogs = await _context.FailedWebhookLogs\n                .Where(l => l.CreatedAt < threshold)\n                .ToListAsync();\n\n            if (oldLogs.Any())\n                _context.FailedWebhookLogs.RemoveRange(oldLogs);\n\n            var setting = await GetOrCreateAsync();\n            setting.LastCleanupAt = DateTime.UtcNow;\n\n            await _context.SaveChangesAsync();\n            return oldLogs.Count;\n        }\n\n        private async Task<WebhookSettings> GetOrCreateAsync()\n        {\n            var setting = await _context.WebhookSettings.FirstOrDefaultAsync();\n            if (setting == null)\n            {\n                setting = new WebhookSettings\n                {\n                    AutoCleanupEnabled = false,\n                    LastCleanupAt = null\n                };\n                _context.WebhookSettings.Add(setting);\n                await _context.SaveChangesAsync();\n            }\n            return setting;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/ClickWebhookProcessor.cs",
      "sha256": "6ebea7391bac9ab8c7e253103360935406ecd65fac28102ae600ce685a655d9c",
      "language": "csharp",
      "size": 50653,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.IO.Pipelines;\nusing System.Text.Json;\nusing System.Threading.Tasks;\nusing xbytechat.api;\nusing xbytechat.api.DTOs.Messages;\nusing xbytechat.api.Features.CampaignTracking.Models;\nusing xbytechat.api.Features.CRM.Models;\nusing xbytechat.api.Features.CRM.Services;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\nusing xbytechat.api.Features.CTAFlowBuilder.Services;\nusing xbytechat.api.Features.CustomeApi.Models;\nusing xbytechat.api.Features.CustomeApi.Services;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.Features.Tracking.DTOs;\nusing xbytechat.api.Features.Tracking.Models;\nusing xbytechat.api.Features.Tracking.Services;\nusing xbytechat.api.Features.Webhooks.Services.Resolvers;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Shared.TrackingUtils;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    public class ClickWebhookProcessor : IClickWebhookProcessor\n    {\n        private readonly ILogger<ClickWebhookProcessor> _logger;\n        private readonly IMessageIdResolver _messageIdResolver;\n        private readonly ITrackingService _trackingService;\n        private readonly AppDbContext _context;\n        private readonly IMessageEngineService _messageEngine;\n        private readonly ICTAFlowService _flowService;\n        private readonly IFlowRuntimeService _flowRuntime;\n        private readonly IContactProfileService _contactProfile;\n        private readonly ICtaJourneyPublisher _journeyPublisher;\n        private static readonly HashSet<string> StopKeywords = new(StringComparer.Ordinal)\n        {\n            \"STOP\",\n            \"UNSUBSCRIBE\",\n            \"CANCEL\",\n            \"END\",\n            \"STOPALL\"\n        };\n\n        private static readonly HashSet<string> StartKeywords = new(StringComparer.Ordinal)\n        {\n            \"START\",\n            \"UNSTOP\",\n            \"SUBSCRIBE\"\n        };\n        public ClickWebhookProcessor(\n            ILogger<ClickWebhookProcessor> logger,\n            IMessageIdResolver messageIdResolver,\n            ITrackingService trackingService,\n            AppDbContext context,\n            IMessageEngineService messageEngine,\n            ICTAFlowService flowService,\n                        IFlowRuntimeService flowRuntime,\n                         IContactProfileService contactProfile,\n                          ICtaJourneyPublisher journeyPublisher\n            )\n        {\n            _logger = logger;\n            _messageIdResolver = messageIdResolver;\n            _trackingService = trackingService;\n            _context = context;\n            _messageEngine = messageEngine;\n            _flowService = flowService;\n            _flowRuntime = flowRuntime;\n            _contactProfile = contactProfile;\n            _journeyPublisher = journeyPublisher;\n\n        }\n\n      \n\n        public async Task ProcessClickAsync(JsonElement value)\n        {\n            _logger.LogWarning(\"üì• [ENTERED CLICK PROCESSOR]\");\n\n            try\n            {\n                if (!value.TryGetProperty(\"messages\", out var messages) || messages.GetArrayLength() == 0)\n                    return;\n\n                // ‚îÄ‚îÄ local helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n                // NOTE: Keep provider normalization consistent across webhook/runtime paths.\n                static string NormalizeProvider(string? raw)\n                {\n                    if (string.IsNullOrWhiteSpace(raw)) return string.Empty;\n                    var p = raw.Trim().Replace(\"-\", \"_\").Replace(\" \", \"_\").ToUpperInvariant();\n                    return p == \"META\" ? \"META_CLOUD\" : p;\n                }\n                static string Norm(string? s)\n                {\n                    if (string.IsNullOrWhiteSpace(s)) return string.Empty;\n                    return string.Join(' ', s.Split(new[] { ' ', '\\t', '\\r', '\\n' }, StringSplitOptions.RemoveEmptyEntries))\n                                 .Trim()\n                                 .ToLowerInvariant();\n                }\n\n                // canonical phone: keep only digits (matches how we store & search contacts)\n                static string NormalizePhone(string? raw)\n                    => new string((raw ?? string.Empty).Where(char.IsDigit).ToArray());\n\n                static string NormalizeInboundPhone(string? raw)\n                {\n                    var digits = NormalizePhone(raw);\n                    if (string.IsNullOrWhiteSpace(digits)) return string.Empty;\n\n                    var normalized = PhoneNumberNormalizer.NormalizeToE164Digits(\"+\" + digits, \"IN\");\n                    return !string.IsNullOrWhiteSpace(normalized) ? normalized : digits;\n                }\n\n                // contacts[0].profile.name (Meta shape)\n                static string? TryGetProfileName(JsonElement root)\n                {\n                    if (root.TryGetProperty(\"contacts\", out var contactsEl) &&\n                        contactsEl.ValueKind == JsonValueKind.Array &&\n                        contactsEl.GetArrayLength() > 0)\n                    {\n                        var c0 = contactsEl[0];\n                        if (c0.TryGetProperty(\"profile\", out var profEl) &&\n                            profEl.ValueKind == JsonValueKind.Object &&\n                            profEl.TryGetProperty(\"name\", out var nameEl) &&\n                            nameEl.ValueKind == JsonValueKind.String)\n                        {\n                            var n = nameEl.GetString();\n                            return string.IsNullOrWhiteSpace(n) ? null : n!.Trim();\n                        }\n                    }\n                    return null;\n                }\n\n                // optional helper (kept for future use)\n                static string ToKey(string? s)\n                {\n                    if (string.IsNullOrWhiteSpace(s)) return \"unknown\";\n                    var t = s.Trim().ToLowerInvariant();\n                    var sb = new System.Text.StringBuilder(t.Length);\n                    foreach (var ch in t)\n                    {\n                        if (char.IsLetterOrDigit(ch)) sb.Append(ch);\n                        else if (char.IsWhiteSpace(ch) || ch == '-' || ch == '_' || ch == '.') sb.Append('_');\n                    }\n                    var k = sb.ToString().Trim('_');\n                    return string.IsNullOrEmpty(k) ? \"unknown\" : k;\n                }\n                // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n                // read WA display number once (used as botId) ‚Äì optional, not strictly required\n                string botIdFromWebhook = \"\";\n                if (value.TryGetProperty(\"metadata\", out var md) &&\n                    md.TryGetProperty(\"display_phone_number\", out var dpnEl) &&\n                    dpnEl.ValueKind == JsonValueKind.String)\n                {\n                    botIdFromWebhook = NormalizePhone(dpnEl.GetString());\n                }\n\n                foreach (var msg in messages.EnumerateArray())\n                {\n                    if (!msg.TryGetProperty(\"type\", out var typeProp))\n                        continue;\n\n                    var nowUtc = DateTime.UtcNow;\n                    if (msg.TryGetProperty(\"timestamp\", out var tsProp))\n                    {\n                        long unixSeconds = 0;\n                        if (tsProp.ValueKind == JsonValueKind.String)\n                        {\n                            var tsStr = tsProp.GetString();\n                            if (!string.IsNullOrWhiteSpace(tsStr))\n                                long.TryParse(tsStr, out unixSeconds);\n                        }\n                        else if (tsProp.ValueKind == JsonValueKind.Number)\n                        {\n                            tsProp.TryGetInt64(out unixSeconds);\n                        }\n                        if (unixSeconds > 0)\n                            nowUtc = DateTimeOffset.FromUnixTimeSeconds(unixSeconds).UtcDateTime;\n                    }\n\n                    var type = typeProp.GetString();\n\n                    string? clickMessageId = msg.TryGetProperty(\"id\", out var idProp) ? idProp.GetString() : null;\n                    string? originalMessageId = msg.TryGetProperty(\"context\", out var ctx) && ctx.TryGetProperty(\"id\", out var ctxId)\n                        ? ctxId.GetString()\n                        : null;\n\n                    var fromRaw = msg.TryGetProperty(\"from\", out var fromProp) ? (fromProp.GetString() ?? \"\") : \"\";\n                    var fromDigits = NormalizeInboundPhone(fromRaw);\n                    if (string.IsNullOrWhiteSpace(fromDigits))\n                    {\n                        _logger.LogWarning(\"‚ö†Ô∏è Click webhook skipped due to invalid sender phone. from={From}\", fromRaw);\n                        continue;\n                    }\n\n                    // ‚Äî‚Äî‚Äî button label extraction\n                    string? buttonText = null;\n                    bool buttonKeyFromIdFallback = false;\n                    if (string.Equals(type, \"button\", StringComparison.OrdinalIgnoreCase))\n                    {\n                        buttonText = msg.TryGetProperty(\"button\", out var btn) &&\n                                     btn.TryGetProperty(\"text\", out var textProp)\n                                       ? textProp.GetString()?.Trim()\n                                       : null;\n                    }\n                    else if (string.Equals(type, \"interactive\", StringComparison.OrdinalIgnoreCase) &&\n                             msg.TryGetProperty(\"interactive\", out var interactive))\n                    {\n                        if (interactive.TryGetProperty(\"type\", out var intrType) &&\n                            string.Equals(intrType.GetString(), \"button_reply\", StringComparison.OrdinalIgnoreCase) &&\n                            interactive.TryGetProperty(\"button_reply\", out var br) &&\n                            br.ValueKind == JsonValueKind.Object)\n                        {\n                            // Support both title and id:\n                            // - Try title first (historical mapping uses visible text)\n                            // - Fall back to id when title is missing (provider payload shape changes)\n                            if (br.TryGetProperty(\"title\", out var titleProp) && titleProp.ValueKind == JsonValueKind.String)\n                            {\n                                buttonText = titleProp.GetString()?.Trim();\n                            }\n                            else if (br.TryGetProperty(\"id\", out var idKeyProp) && idKeyProp.ValueKind == JsonValueKind.String)\n                            {\n                                buttonText = idKeyProp.GetString()?.Trim();\n                                buttonKeyFromIdFallback = !string.IsNullOrWhiteSpace(buttonText);\n                            }\n                        }\n                        else if (interactive.TryGetProperty(\"list_reply\", out var lr) &&\n                                 lr.TryGetProperty(\"title\", out var listTitleProp))\n                        {\n                            buttonText = listTitleProp.GetString()?.Trim();\n                        }\n                    }\n\n                    if (string.IsNullOrWhiteSpace(buttonText))\n                    {\n                        _logger.LogDebug(\"‚ÑπÔ∏è Not a recognized click. type={Type}\", type);\n                        continue;\n                    }\n                    if (string.IsNullOrWhiteSpace(originalMessageId))\n                    {\n                        _logger.LogWarning(\"‚ö†Ô∏è Click received without context.id; using fallback business/contact resolution.\");\n                    }\n\n                    _logger.LogInformation(\"üñ±Ô∏è Button Click ‚Üí From: {From}, ClickId: {ClickId}, OrigMsgId: {OrigId}, Text: {Text}\",\n                        fromDigits, clickMessageId, originalMessageId, buttonText);\n\n                    // ‚Äî‚Äî Try 1/2: resolve flow context from original message ids when present\n                    var origin = !string.IsNullOrWhiteSpace(originalMessageId)\n                        ? await _context.MessageLogs\n                            .AsNoTracking()\n                            .FirstOrDefaultAsync(m =>\n                                m.MessageId == originalMessageId &&\n                                m.CTAFlowConfigId != null &&\n                                m.CTAFlowStepId != null)\n                        : null;\n\n                    Guid businessId = Guid.Empty;\n                    Guid flowId = Guid.Empty;\n                    Guid stepId = Guid.Empty;\n                    string? bundleJson = null;\n                    int? flowVersion = null;\n                    var hasFlowContext = false;\n\n                    Guid? campaignSendLogId = null; // link the click to the shown message\n                    Guid? runId = null;             // copy from parent CSL when available\n\n                    if (origin != null)\n                    {\n                        businessId = origin.BusinessId;\n                        flowId = origin.CTAFlowConfigId!.Value;\n                        stepId = origin.CTAFlowStepId!.Value;\n                        bundleJson = origin.ButtonBundleJson;\n                        flowVersion = origin.FlowVersion;\n\n                        // Map back to CSL via MessageLogId or WAMID and fetch RunId\n                        var cslInfo = await _context.CampaignSendLogs\n                            .AsNoTracking()\n                            .Where(csl => (csl.MessageLogId == origin.Id) || (csl.MessageId == originalMessageId))\n                            .OrderByDescending(csl => csl.CreatedAt)\n                            .Select(csl => new { csl.Id, csl.RunId })\n                            .FirstOrDefaultAsync();\n\n                        campaignSendLogId = cslInfo?.Id;\n                        runId = cslInfo?.RunId;\n                        hasFlowContext = true;\n                    }\n                    else if (!string.IsNullOrWhiteSpace(originalMessageId))\n                    {\n                        // ‚Äî‚Äî Try 2: first campaign message (CampaignSendLogs)\n                        var sendLog = await _context.CampaignSendLogs\n                            .Include(sl => sl.Campaign)\n                            .AsNoTracking()\n                            .FirstOrDefaultAsync(sl => sl.MessageId == originalMessageId);\n\n                        if (sendLog == null)\n                        {\n                            _logger.LogWarning(\"‚ùå No MessageLog or CampaignSendLog for original WAMID {Orig}\", originalMessageId);\n                        }\n                        else\n                        {\n                            businessId = sendLog.BusinessId != Guid.Empty\n                                ? sendLog.BusinessId\n                                : (sendLog.Campaign?.BusinessId ?? Guid.Empty);\n\n                            if (businessId == Guid.Empty)\n                            {\n                                _logger.LogWarning(\"‚ùå Could not resolve BusinessId for WAMID {Orig}\", originalMessageId);\n                            }\n                            else\n                            {\n                                campaignSendLogId = sendLog.Id;\n                                runId = sendLog.RunId;\n\n                                if (sendLog.CTAFlowConfigId.HasValue && sendLog.CTAFlowStepId.HasValue)\n                                {\n                                    flowId = sendLog.CTAFlowConfigId.Value;\n                                    stepId = sendLog.CTAFlowStepId.Value;\n                                    hasFlowContext = true;\n                                }\n                                else if (sendLog.Campaign?.CTAFlowConfigId != null)\n                                {\n                                    flowId = sendLog.Campaign.CTAFlowConfigId.Value;\n\n                                    var entry = await _context.CTAFlowSteps\n                                        .Where(s => s.CTAFlowConfigId == flowId)\n                                        .OrderBy(s => s.StepOrder)\n                                        .Select(s => s.Id)\n                                        .FirstOrDefaultAsync();\n\n                                    if (entry == Guid.Empty)\n                                    {\n                                        _logger.LogWarning(\"‚ùå No entry step found for flow {Flow}\", flowId);\n                                    }\n                                    else\n                                    {\n                                        stepId = entry;\n                                        hasFlowContext = true;\n                                    }\n                                }\n                                else\n                                {\n                                    _logger.LogWarning(\"‚ùå No flow context on CampaignSendLog for WAMID {Orig}\", originalMessageId);\n                                }\n\n                                bundleJson = sendLog.ButtonBundleJson;\n                            }\n                        }\n                    }\n\n                    // ‚Äî‚Äî Try 3: fallback business resolution by webhook display phone number\n                    if (businessId == Guid.Empty && !string.IsNullOrWhiteSpace(botIdFromWebhook))\n                    {\n                        var phoneRows = await _context.WhatsAppPhoneNumbers\n                            .AsNoTracking()\n                            .Where(n => n.IsActive)\n                            .Select(n => new { n.BusinessId, n.WhatsAppBusinessNumber })\n                            .ToListAsync();\n\n                        var bizHit = phoneRows.FirstOrDefault(n =>\n                            NormalizePhone(n.WhatsAppBusinessNumber) == botIdFromWebhook);\n\n                        if (bizHit != null)\n                            businessId = bizHit.BusinessId;\n                    }\n\n                    if (businessId == Guid.Empty)\n                    {\n                        _logger.LogWarning(\"‚ùå Could not resolve BusinessId for click. context={Orig}, from={From}\", originalMessageId, fromDigits);\n                        continue;\n                    }\n\n                    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n                    // ‚úÖ UPSERT PROFILE NAME (create-or-update) *before* next step\n                    //    ensure we look up by digits-only phone.\n                    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n                    Contact? trackedContact = null;\n                    try\n                    {\n                        var profileName = TryGetProfileName(value);\n                        if (!string.IsNullOrWhiteSpace(profileName))\n                        {\n                            trackedContact = await _context.Contacts\n                                .FirstOrDefaultAsync(c => c.BusinessId == businessId &&\n                                                          (c.PhoneNumber == fromDigits || c.PhoneNumber == fromRaw));\n\n                            if (trackedContact == null)\n                            {\n                                profileName = profileName ?? \"User\";\n                                trackedContact = new Contact\n                                {\n                                    Id = Guid.NewGuid(),\n                                    BusinessId = businessId,\n                                    PhoneNumber = fromDigits, // store canonical\n                                    Name = profileName,\n                                    ProfileName = profileName,\n                                    ProfileNameUpdatedAt = nowUtc,\n                                    CreatedAt = nowUtc,\n                                };\n                                _context.Contacts.Add(trackedContact);\n                                await _context.SaveChangesAsync();\n                                _logger.LogInformation(\"üë§ Created contact + stored WA profile '{Name}' for {Phone} (biz {Biz})\",\n                                    profileName, fromDigits, businessId);\n                            }\n                            else\n                            {\n                                var changed = false;\n\n                                if (!string.Equals(trackedContact.ProfileName, profileName, StringComparison.Ordinal))\n                                {\n                                    trackedContact.ProfileName = profileName;\n                                    trackedContact.ProfileNameUpdatedAt = nowUtc;\n                                    changed = true;\n                                }\n\n                                if (string.IsNullOrWhiteSpace(trackedContact.Name) ||\n                                    trackedContact.Name == \"WhatsApp User\" ||\n                                    trackedContact.Name == trackedContact.PhoneNumber)\n                                {\n                                    if (!string.Equals(trackedContact.Name, profileName, StringComparison.Ordinal))\n                                    {\n                                        trackedContact.Name = profileName;\n                                        changed = true;\n                                    }\n                                }\n\n                                if (changed)\n                                {\n                                    trackedContact.ProfileNameUpdatedAt = nowUtc;\n                                    await _context.SaveChangesAsync();\n                                    _logger.LogInformation(\"üë§ Updated WA profile name to '{Name}' for {Phone} (biz {Biz})\",\n                                        profileName, fromDigits, businessId);\n                                }\n                            }\n                        }\n                    }\n                    catch (Exception exProf)\n                    {\n                        _logger.LogWarning(exProf, \"‚ö†Ô∏è Failed to upsert WA profile name on click webhook.\");\n                    }\n\n                    if (trackedContact == null)\n                    {\n                        trackedContact = await _context.Contacts\n                            .FirstOrDefaultAsync(c => c.BusinessId == businessId &&\n                                                      (c.PhoneNumber == fromDigits || c.PhoneNumber == fromRaw));\n                    }\n\n                    if (trackedContact != null)\n                    {\n                        // Treat interactive click as inbound activity and reuse inbox reopen logic from InboundMessageProcessor.\n                        trackedContact.LastInboundAt = nowUtc;\n\n                        var inboxStatus = (trackedContact.InboxStatus ?? string.Empty).Trim();\n                        if (string.Equals(inboxStatus, \"Closed\", StringComparison.OrdinalIgnoreCase) ||\n                            trackedContact.IsArchived ||\n                            !trackedContact.IsActive)\n                        {\n                            trackedContact.InboxStatus = \"Open\";\n                            trackedContact.IsArchived = false;\n                            trackedContact.IsActive = true;\n                        }\n\n                        await _context.SaveChangesAsync();\n                    }\n                    else\n                    {\n                        _logger.LogWarning(\"‚ö†Ô∏è Contact not found for click activity update. biz={Biz} from={From}\", businessId, fromDigits);\n                    }\n\n                    var complianceKeyword = NormalizeKeywordToken(buttonText);\n                    if (trackedContact != null && IsStopKeyword(complianceKeyword))\n                    {\n                        trackedContact.OptStatus = ContactOptStatus.OptedOut;\n                        trackedContact.OptStatusUpdatedAt = nowUtc;\n                        trackedContact.OptOutReason = \"KeywordStop\";\n                        await _context.SaveChangesAsync();\n\n                        _logger.LogInformation(\n                            \"Compliance interceptor applied STOP on interactive click. biz={Biz} contactId={ContactId} phone={Phone}\",\n                            businessId,\n                            trackedContact.Id,\n                            trackedContact.PhoneNumber);\n                        continue;\n                    }\n\n                    if (trackedContact != null && IsStartKeyword(complianceKeyword))\n                    {\n                        trackedContact.OptStatus = ContactOptStatus.OptedIn;\n                        trackedContact.OptStatusUpdatedAt = nowUtc;\n                        trackedContact.OptOutReason = null;\n                        await _context.SaveChangesAsync();\n\n                        _logger.LogInformation(\n                            \"Compliance interceptor applied START on interactive click. biz={Biz} contactId={ContactId} phone={Phone}\",\n                            businessId,\n                            trackedContact.Id,\n                            trackedContact.PhoneNumber);\n                        continue;\n                    }\n\n                    var isOptedOutContact = trackedContact?.OptStatus == ContactOptStatus.OptedOut;\n\n                    if (!hasFlowContext)\n                    {\n                        _logger.LogWarning(\"‚ö†Ô∏è Click context unresolved. Activity updated and flow execution skipped. biz={Biz} from={From} orig={Orig}\",\n                            businessId, fromDigits, originalMessageId);\n                        continue;\n                    }\n\n                    // ‚Äî‚Äî Map clicked text -> button index via the shown bundle\n                    short? buttonIndex = null;\n                    FlowBtnBundleNode? hit = null;\n\n                    if (!string.IsNullOrWhiteSpace(bundleJson))\n                    {\n                        try\n                        {\n                            var nodes = System.Text.Json.JsonSerializer\n                                .Deserialize<List<FlowBtnBundleNode>>(bundleJson) ?? new();\n\n                            // Match by visible text OR, if inbound key came from id fallback, by stored value/payload (n.v).\n                            // This protects routing when WhatsApp stops sending the title consistently.\n                            hit =\n                                (buttonKeyFromIdFallback\n                                    ? nodes.FirstOrDefault(n => string.Equals(n.v ?? \"\", buttonText, StringComparison.OrdinalIgnoreCase))\n                                      ?? nodes.FirstOrDefault(n => Norm(n.v) == Norm(buttonText))\n                                      ?? nodes.FirstOrDefault(n => string.Equals(n.t ?? \"\", buttonText, StringComparison.OrdinalIgnoreCase))\n                                      ?? nodes.FirstOrDefault(n => Norm(n.t) == Norm(buttonText))\n                                    : nodes.FirstOrDefault(n => string.Equals(n.t ?? \"\", buttonText, StringComparison.OrdinalIgnoreCase))\n                                      ?? nodes.FirstOrDefault(n => Norm(n.t) == Norm(buttonText)));\n\n                            if (hit != null)\n                                buttonIndex = (short)hit.i;\n                        }\n                        catch (Exception ex)\n                        {\n                            _logger.LogWarning(ex, \"‚ö†Ô∏è Failed to parse ButtonBundleJson\");\n                        }\n                    }\n\n                    // ‚Äî‚Äî Fallback: find link by TEXT for this step\n                    FlowButtonLink? linkMatchedByText = null;\n                    if (buttonIndex == null)\n                    {\n                        var stepLinks = await _context.FlowButtonLinks\n                            .Where(l => l.CTAFlowStepId == stepId)\n                            .OrderBy(l => l.ButtonIndex)\n                            .ToListAsync();\n\n                        if (stepLinks.Count > 0)\n                        {\n                            linkMatchedByText = stepLinks.FirstOrDefault(l =>\n                                string.Equals(l.ButtonText ?? \"\", buttonText, StringComparison.OrdinalIgnoreCase))\n                                ?? stepLinks.FirstOrDefault(l => Norm(l.ButtonText) == Norm(buttonText));\n\n                            // If the inbound click was keyed by button_reply.id, also allow matching by stored ButtonValue.\n                            if (linkMatchedByText == null && buttonKeyFromIdFallback)\n                            {\n                                linkMatchedByText = stepLinks.FirstOrDefault(l =>\n                                    string.Equals(l.ButtonValue ?? \"\", buttonText, StringComparison.OrdinalIgnoreCase))\n                                    ?? stepLinks.FirstOrDefault(l => Norm(l.ButtonValue) == Norm(buttonText));\n                            }\n\n                            if (linkMatchedByText == null && stepLinks.Count == 1)\n                            {\n                                linkMatchedByText = stepLinks[0];\n                                _logger.LogInformation(\"üü® Falling back to single available link for step {Step}\", stepId);\n                            }\n\n                            if (linkMatchedByText != null)\n                            {\n                                buttonIndex = (short?)linkMatchedByText.ButtonIndex;\n                                _logger.LogInformation(\"‚úÖ Mapped click by TEXT to index {Idx} (flow={Flow}, step={Step})\",\n                                    buttonIndex, flowId, stepId);\n                            }\n                        }\n                    }\n\n                    if (buttonIndex == null)\n                    {\n                        _logger.LogInformation(\"üü° Button text not found in bundle or flow links. Ref={Ref}, Text='{Text}'\",\n                            originalMessageId, buttonText);\n                        continue;\n                    }\n\n                    // ‚Äî‚Äî Prefer exact link by index; otherwise use the text-matched link\n                    var link = await _flowService.GetLinkAsync(flowId, stepId, buttonIndex.Value)\n                               ?? linkMatchedByText;\n\n                    if (link == null)\n                    {\n                        _logger.LogInformation(\"üü° No button link for (flow={Flow}, step={Step}, idx={Idx})\",\n                            flowId, stepId, buttonIndex);\n                        continue;\n                    }\n\n                    // ‚Äî‚Äî Resolve index + step name (for logging)\n                    short resolvedIndex = buttonIndex ?? Convert.ToInt16(link.ButtonIndex);\n                    var stepName = await _context.CTAFlowSteps\n                        .Where(s => s.Id == stepId)\n                        .Select(s => s.TemplateToSend)\n                        .FirstOrDefaultAsync() ?? string.Empty;\n\n                    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî\n                    // üìù WRITE CLICK LOG (always, even if terminal)\n                    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî\n                    try\n                    {\n                        var clickExec = new FlowExecutionLog\n                        {\n                            Id = Guid.NewGuid(),\n                            BusinessId = businessId,\n                            FlowId = flowId,\n                            StepId = stepId,\n                            StepName = stepName,\n                            CampaignSendLogId = campaignSendLogId,\n                            MessageLogId = origin?.Id,\n                            ContactPhone = fromDigits,      // digits-only\n                            ButtonIndex = resolvedIndex,\n                            TriggeredByButton = buttonText,\n                            TemplateName = null,\n                            TemplateType = \"quick_reply\",\n                            Success = true,\n                            ExecutedAt = nowUtc,\n                            RequestId = Guid.NewGuid(),\n                            RunId = runId\n                        };\n\n                        _context.FlowExecutionLogs.Add(clickExec);\n                        await _context.SaveChangesAsync();\n                    }\n                    catch (Exception exSave)\n                    {\n                        _logger.LogWarning(exSave, \"‚ö†Ô∏è Failed to persist FlowExecutionLog (click). Continuing‚Ä¶\");\n                    }\n\n                    // ===== RUNNING CTA JOURNEY STATE UPSERT (ONLY IF THIS BIZ IS CONFIGURED) =====\n                    string runningJourney;\n\n                    // Check once if this business is configured to receive CTAJourney.\n                    // IMPORTANT: Some deployments may not have the CustomerWebhookConfigs table yet; this must not block click ‚Üí next-template sends.\n                    bool shouldTrackState = false;\n                    try\n                    {\n                        shouldTrackState = await _context.CustomerWebhookConfigs\n                            .AsNoTracking()\n                            .AnyAsync(x => x.BusinessId == businessId && x.IsActive);\n                    }\n                    catch (Npgsql.PostgresException pgEx) when (string.Equals(pgEx.SqlState, \"42P01\", StringComparison.Ordinal))\n                    {\n                        // 42P01 = undefined_table\n                        _logger.LogWarning(pgEx,\n                            \"‚ö†Ô∏è CustomerWebhookConfigs table missing; skipping CTAJourney state tracking. biz={Biz} flow={Flow} step={Step} to={To}\",\n                            businessId, flowId, stepId, fromDigits);\n                        shouldTrackState = false;\n                    }\n                    catch (Exception exTrack)\n                    {\n                        _logger.LogWarning(exTrack,\n                            \"‚ö†Ô∏è Failed to check CustomerWebhookConfigs; skipping CTAJourney state tracking. biz={Biz} flow={Flow} step={Step} to={To}\",\n                            businessId, flowId, stepId, fromDigits);\n                        shouldTrackState = false;\n                    }\n\n                    if (shouldTrackState)\n                    {\n                        try\n                        {\n                            // load current state for (business, flow, phone)\n                            var state = await _context.ContactJourneyStates\n                                .SingleOrDefaultAsync(s =>\n                                    s.BusinessId == businessId &&\n                                    s.FlowId == flowId &&\n                                    s.ContactPhone == fromDigits);\n\n                            if (state == null)\n                            {\n                                // first click -> start with this button text (original casing)\n                                state = new ContactJourneyState\n                                {\n                                    Id = Guid.NewGuid(),\n                                    BusinessId = businessId,\n                                    FlowId = flowId,\n                                    ContactPhone = fromDigits,\n                                    JourneyText = buttonText ?? string.Empty,\n                                    ClickCount = 1,\n                                    LastButtonText = buttonText,\n                                    CreatedAt = nowUtc,\n                                    UpdatedAt = nowUtc\n                                };\n                                _context.ContactJourneyStates.Add(state);\n                                await _context.SaveChangesAsync();\n                                runningJourney = state.JourneyText;\n                                _logger.LogInformation(\"üßµ Journey init: {Journey} (biz={Biz}, flow={Flow}, phone={Phone})\",\n                                    runningJourney, businessId, flowId, fromDigits);\n                            }\n                            else\n                            {\n                                // append EVERY press (duplicates allowed), keep original casing\n                                var parts = (state.JourneyText ?? string.Empty)\n                                    .Split('/', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries)\n                                    .ToList();\n\n                                if (!string.IsNullOrWhiteSpace(buttonText))\n                                    parts.Add(buttonText!);\n\n                                // cap growth\n                                const int cap = 15;\n                                if (parts.Count > cap) parts = parts.Skip(parts.Count - cap).ToList();\n\n                                state.JourneyText = string.Join('/', parts);\n                                state.ClickCount += 1;\n                                state.LastButtonText = buttonText;\n                                state.UpdatedAt = nowUtc;\n\n                                await _context.SaveChangesAsync();\n                                runningJourney = state.JourneyText ?? string.Empty;\n\n                                _logger.LogInformation(\"üßµ Journey update: {Journey} (biz={Biz}, flow={Flow}, phone={Phone})\",\n                                    runningJourney, businessId, flowId, fromDigits);\n                            }\n                        }\n                        catch (Exception exState)\n                        {\n                            _logger.LogWarning(exState, \"‚ö†Ô∏è Failed to upsert ContactJourneyState.\");\n                            // fall back to this click only\n                            runningJourney = buttonText ?? string.Empty;\n                        }\n                    }\n                    else\n                    {\n                        // Business not configured ‚Üí do NOT save any state. Just use the current button for emit.\n                        runningJourney = buttonText ?? string.Empty;\n                    }\n                    // ===== END RUNNING CTA JOURNEY STATE UPSERT =====\n\n                    // ===== CTAJourney EMIT (running journey) =====\n                    try\n                    {\n                        // contact (for userName / userPhone)\n                        var contact = await _context.Contacts\n                            .AsNoTracking()\n                            .FirstOrDefaultAsync(c => c.BusinessId == businessId && c.PhoneNumber == fromDigits);\n\n                        // Prefer sender from the originating send (keeps the same WABA)\n                        string? senderProvider = null;\n                        string? senderPhoneNumberId = null;\n\n                        if (campaignSendLogId.HasValue)\n                        {\n                            var originSend = await _context.CampaignSendLogs\n                                .AsNoTracking()\n                                .Include(s => s.Campaign)\n                                .Where(s => s.Id == campaignSendLogId.Value)\n                                .Select(s => new { s.Campaign.Provider, s.Campaign.PhoneNumberId })\n                                .FirstOrDefaultAsync();\n\n                            senderProvider = originSend?.Provider;\n                            senderPhoneNumberId = originSend?.PhoneNumberId;\n                        }\n                        if (string.IsNullOrWhiteSpace(senderPhoneNumberId) && origin?.CampaignId != null)\n                        {\n                            var originCamp = await _context.Campaigns\n                                .AsNoTracking()\n                                .Where(c => c.Id == origin.CampaignId.Value)\n                                .Select(c => new { c.Provider, c.PhoneNumberId })\n                                .FirstOrDefaultAsync();\n\n                            senderProvider ??= originCamp?.Provider;\n                            senderPhoneNumberId = originCamp?.PhoneNumberId;\n                        }\n\n                        // Map PhoneNumberId -> WhatsAppBusinessNumber, or choose a default for the same provider\n                        string? waBusinessNumber = null;\n\n                        if (!string.IsNullOrWhiteSpace(senderPhoneNumberId))\n                        {\n                            waBusinessNumber = await _context.WhatsAppPhoneNumbers\n                                .AsNoTracking()\n                                .Where(n => n.BusinessId == businessId && n.PhoneNumberId == senderPhoneNumberId)\n                                .Select(n => n.WhatsAppBusinessNumber)\n                                .FirstOrDefaultAsync();\n                        }\n\n                        if (string.IsNullOrWhiteSpace(waBusinessNumber))\n                        {\n                            var row = await _context.WhatsAppPhoneNumbers\n                                .AsNoTracking()\n                                .Where(n => n.BusinessId == businessId &&\n                                            n.IsActive &&\n                                            (string.IsNullOrEmpty(senderProvider) || n.Provider == senderProvider))\n                                .OrderByDescending(n => n.IsDefault)\n                                .ThenByDescending(n => n.UpdatedAt ?? n.CreatedAt)\n                                .Select(n => new { n.PhoneNumberId, n.WhatsAppBusinessNumber })\n                                .FirstOrDefaultAsync();\n\n                            senderPhoneNumberId ??= row?.PhoneNumberId;\n                            waBusinessNumber = row?.WhatsAppBusinessNumber;\n                        }\n\n                        var dto = CtaJourneyMapper.Build(\n                            journeyKey: runningJourney,                      // running state with original casing\n                            contact: contact,\n                            profileName: contact?.ProfileName ?? contact?.Name,\n                            userId: null,\n                            phoneNumberId: waBusinessNumber,                 // publish WA display number as bot id\n                            businessDisplayPhone: waBusinessNumber,          // same as above\n                            categoryBrowsed: null,\n                            productBrowsed: null\n                        );\n\n                        await _journeyPublisher.PublishAsync(businessId, dto, CancellationToken.None);\n                        _logger.LogInformation(\"üì§ CTAJourney posted (running): {Journey} (biz={Biz}, phone={Phone})\",\n                            dto.CTAJourney, businessId, dto.userPhone);\n                    }\n                    catch (Exception ex)\n                    {\n                        _logger.LogWarning(ex, \"‚ö†Ô∏è Failed to post CTAJourney (click). Continuing‚Ä¶\");\n                    }\n                    // ===== end CTAJourney EMIT =====\n\n                    if (isOptedOutContact)\n                    {\n                        _logger.LogInformation(\n                            \"Compliance: contact is opted out; click activity logged but flow execution skipped. biz={Biz} phone={Phone}\",\n                            businessId,\n                            fromDigits);\n                        continue;\n                    }\n\n                    // ‚Äî‚Äî If terminal/URL button: already logged the click\n                    if (link.NextStepId == null)\n                    {\n                        _logger.LogInformation(\"üîö Terminal/URL button: no NextStepId. flow={Flow}, step={Step}, idx={Idx}, text='{Text}'\",\n                            flowId, stepId, resolvedIndex, link.ButtonText);\n                        continue;\n                    }\n\n                    if (_flowRuntime == null)\n                    {\n                        _logger.LogError(\"‚ùå _flowRuntime is null. Cannot execute next step. flow={Flow}, step={Step}, idx={Idx}\", flowId, stepId, resolvedIndex);\n                        continue;\n                    }\n\n                    // ‚Äî‚Äî üîé Resolve sender from the originating campaign/send (use SAME WABA) for next step\n                    string? providerFromCampaign = null;\n                    string? phoneNumberIdFromCampaign = null;\n\n                    if (campaignSendLogId.HasValue)\n                    {\n                        var originSend = await _context.CampaignSendLogs\n                            .AsNoTracking()\n                            .Include(s => s.Campaign)\n                            .Where(s => s.Id == campaignSendLogId.Value)\n                            .Select(s => new\n                            {\n                                s.Campaign.Provider,\n                                s.Campaign.PhoneNumberId\n                            })\n                            .FirstOrDefaultAsync();\n\n                        providerFromCampaign = originSend?.Provider;\n                        phoneNumberIdFromCampaign = originSend?.PhoneNumberId;\n                    }\n                    else if (origin != null && origin.CampaignId.HasValue)\n                    {\n                        var originCamp = await _context.Campaigns\n                            .AsNoTracking()\n                            .Where(c => c.Id == origin.CampaignId.Value)\n                            .Select(c => new { c.Provider, c.PhoneNumberId })\n                            .FirstOrDefaultAsync();\n\n                        providerFromCampaign = originCamp?.Provider;\n                        phoneNumberIdFromCampaign = originCamp?.PhoneNumberId;\n                    }\n\n                    // ‚Äî‚Äî Execute next (carry sender forward)\n                    var ctxObj = new NextStepContext\n                    {\n                        BusinessId = businessId,\n                        FlowId = flowId,\n                        Version = flowVersion ?? 1,\n                        SourceStepId = stepId,\n                        TargetStepId = link.NextStepId!.Value,\n                        ButtonIndex = resolvedIndex,\n                        MessageLogId = origin?.Id ?? Guid.Empty,\n                        ContactPhone = fromDigits,     // digits-only\n                        RequestId = Guid.NewGuid(),\n                        ClickedButton = link,\n\n                        // carry same sender into the next step\n                        Provider = string.IsNullOrWhiteSpace(providerFromCampaign) ? null : NormalizeProvider(providerFromCampaign),\n                        PhoneNumberId = phoneNumberIdFromCampaign,\n                        AlwaysSend = true // force runtime to send even if it‚Äôs a loopback/same step\n                    };\n\n                     try\n                     {\n                         var result = await _flowRuntime.ExecuteNextAsync(ctxObj);\n\n                         if (!result.Success)\n                         {\n                             // Observability: webhook must return 200, but failures must not be silent.\n                             _logger.LogWarning(\n                                 \"‚ùå ExecuteNextAsync returned failure biz={Biz} phone={Phone} flow={Flow} step={Step} targetStep={Target} idx={Idx} btn='{Btn}' err={Err}\",\n                                 businessId, fromDigits, ctxObj.FlowId, ctxObj.SourceStepId, ctxObj.TargetStepId, ctxObj.ButtonIndex, buttonText, result.Error);\n                         }\n\n                         if (result.Success && !string.IsNullOrWhiteSpace(result.RedirectUrl))\n                         {\n                             _logger.LogInformation(\"üîó URL button redirect (logical): {Url}\", result.RedirectUrl);\n                         }\n                     }\n                    catch (Exception exRun)\n                    {\n                        _logger.LogError(exRun,\n                            \"‚ùå ExecuteNextAsync failed. ctx: flow={Flow} step={Step} next={Next} idx={Idx} from={From} orig={Orig} text='{Text}'\",\n                            ctxObj.FlowId, ctxObj.SourceStepId, ctxObj.TargetStepId, ctxObj.ButtonIndex, fromDigits, originalMessageId, buttonText);\n                    }\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Failed to process CTA button click.\");\n            }\n        }\n\n        private sealed class FlowBtnBundleNode\n        {\n            public int i { get; init; }\n            public string? t { get; init; }   // button text/title\n            public string? ty { get; init; }  // button type (URL/QUICK_REPLY/FLOW)\n            public string? v { get; init; }   // value/payload (e.g., URL)\n            public Guid? ns { get; init; }    // next step id\n        }\n        private static string ToKey(string? s)\n        {\n            if (string.IsNullOrWhiteSpace(s)) return \"unknown\";\n            // letters/digits ‚Üí lower, spaces/._- ‚Üí underscore, strip the rest\n            var chars = s.Trim().ToLowerInvariant()\n                .Select(ch => char.IsLetterOrDigit(ch) ? ch : '_')\n                .ToArray();\n            var key = new string(chars);\n            // squeeze duplicate underscores\n            while (key.Contains(\"__\")) key = key.Replace(\"__\", \"_\");\n            return key.Trim('_');\n        }\n\n        private static string NormalizeKeywordToken(string? text)\n        {\n            if (string.IsNullOrWhiteSpace(text)) return string.Empty;\n\n            var firstToken = text.Trim()\n                .Split(new[] { ' ', '\\t', '\\r', '\\n' }, StringSplitOptions.RemoveEmptyEntries)\n                .FirstOrDefault() ?? string.Empty;\n\n            var trimmed = firstToken.Trim().Trim('.', ',', '!', '?', ';', ':', '\"', '\\'', '(', ')', '[', ']', '{', '}');\n            return trimmed.ToUpperInvariant();\n        }\n\n        private static bool IsStopKeyword(string normalizedText) => StopKeywords.Contains(normalizedText);\n\n        private static bool IsStartKeyword(string normalizedText) => StartKeywords.Contains(normalizedText);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/IClickWebhookProcessor.cs",
      "sha256": "5c42427d1e6c36dd122b3a10412eb70d7c412baf00ce54a614491a5b1590afeb",
      "language": "csharp",
      "size": 228,
      "content": "using System.Text.Json;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    public interface IClickWebhookProcessor\n    {\n        Task ProcessClickAsync(JsonElement value);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/IInboundMessageProcessor.cs",
      "sha256": "9be236780e9f9ec360235a95d5b8ed5447c75db5fa0acf2c688ee904e8bb9a3a",
      "language": "csharp",
      "size": 250,
      "content": "using System.Text.Json;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    public interface IInboundMessageProcessor\n    {\n        Task ProcessChatAsync(JsonElement value, JsonElement message);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/InboundMessageProcessor.cs",
      "sha256": "bc6cd0f4f70a2cf2726e30d0e0c3839ad9a94d3c3e2be47c2e42b459a28ea4c0",
      "language": "csharp",
      "size": 30424,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.SignalR;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api;\nusing xbytechat.api.Features.AutoReplyBuilder.Services;\nusing xbytechat.api.Features.Automation.Services;\nusing xbytechat.api.Features.CRM.Interfaces;\nusing xbytechat.api.Features.CRM.Models;\nusing xbytechat.api.Features.Inbox.DTOs;\nusing xbytechat.api.Features.Inbox.Hubs;\nusing xbytechat.api.Features.Inbox.Services;\nusing xbytechat.api.Features.Webhooks.Directory;\nusing xbytechat.api.Features.CRM.Services;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    public class InboundMessageProcessor : IInboundMessageProcessor\n    {\n        private static readonly HashSet<string> StopKeywords = new(StringComparer.Ordinal)\n        {\n            \"STOP\",\n            \"UNSUBSCRIBE\",\n            \"CANCEL\",\n            \"END\",\n            \"STOPALL\"\n        };\n\n        private static readonly HashSet<string> StartKeywords = new(StringComparer.Ordinal)\n        {\n            \"START\",\n            \"UNSTOP\",\n            \"SUBSCRIBE\"\n        };\n\n        private readonly AppDbContext _context;\n        private readonly IHubContext<InboxHub> _hubContext;\n        private readonly ILogger<InboundMessageProcessor> _logger;\n        private readonly IInboxService _inboxService;\n        private readonly IServiceScopeFactory _serviceScopeFactory;\n        private readonly IHubContext<InboxHub> _hub;\n        private readonly IContactProfileService _contactProfile;\n        private readonly IProviderDirectory _providerDirectory;\n\n        public InboundMessageProcessor(\n            AppDbContext context,\n            IHubContext<InboxHub> hubContext,\n            ILogger<InboundMessageProcessor> logger,\n            IInboxService inboxService,\n            IServiceScopeFactory serviceScopeFactory,\n            IHubContext<InboxHub> hub,\n            IContactProfileService contactProfile,\n            IProviderDirectory providerDirectory\n        )\n        {\n            _context = context;\n            _hubContext = hubContext;\n            _logger = logger;\n            _inboxService = inboxService;\n            _serviceScopeFactory = serviceScopeFactory;\n            _hub = hub;\n            _contactProfile = contactProfile;\n            _providerDirectory = providerDirectory;\n        }\n\n        public async Task ProcessChatAsync(JsonElement value, JsonElement msg)\n        {\n            try\n            {\n                using var scope = _serviceScopeFactory.CreateScope();\n                var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n                var contactService = scope.ServiceProvider.GetRequiredService<IContactService>();\n                var chatSessionStateService = scope.ServiceProvider.GetRequiredService<IChatSessionStateService>();\n                var automationService = scope.ServiceProvider.GetRequiredService<IAutomationService>();\n                var autoReplyRuntime = scope.ServiceProvider.GetRequiredService<IAutoReplyRuntimeService>();\n                var logger = scope.ServiceProvider.GetRequiredService<ILogger<InboundMessageProcessor>>();\n                var contactProfileService = scope.ServiceProvider.GetRequiredService<IContactProfileService>();\n                var inboxService = scope.ServiceProvider.GetRequiredService<IInboxService>();\n\n                // digits-only utility\n                static string NormalizeDigits(string? s) =>\n                    string.IsNullOrWhiteSpace(s) ? \"\" : new string(s.Where(char.IsDigit).ToArray());\n\n                static string NormalizeInboundPhone(string? raw)\n                {\n                    var digits = NormalizeDigits(raw);\n                    if (string.IsNullOrWhiteSpace(digits)) return string.Empty;\n\n                    // WhatsApp webhook \"from\" is normally E.164 digits without '+'.\n                    // Add '+' before normalization to avoid region misinterpretation.\n                    var normalized = PhoneNumberNormalizer.NormalizeToE164Digits(\"+\" + digits, \"IN\");\n                    return !string.IsNullOrWhiteSpace(normalized) ? normalized : digits;\n                }\n\n                var msgType = msg.TryGetProperty(\"type\", out var typeProp)\n                    ? typeProp.GetString()\n                    : \"unknown\";\n\n                var rawContactPhone = msg.GetProperty(\"from\").GetString() ?? \"\";\n                var contactPhone = NormalizeInboundPhone(rawContactPhone);\n\n                if (string.IsNullOrWhiteSpace(contactPhone))\n                {\n                    logger.LogWarning(\"‚ùå Inbound: invalid sender phone format. from={From}\", rawContactPhone);\n                    return;\n                }\n\n                // ‚úÖ WAMID / Provider message id (used for idempotency)\n                var wamid = msg.TryGetProperty(\"id\", out var idProp) ? idProp.GetString() : null;\n                wamid = string.IsNullOrWhiteSpace(wamid) ? null : wamid.Trim();\n\n                // ‚úÖ Provider timestamp (unix seconds) ‚Üí use for SentAt ordering consistency\n                DateTime providerSentAtUtc = DateTime.UtcNow;\n                if (msg.TryGetProperty(\"timestamp\", out var tsProp))\n                {\n                    long unixSeconds = 0;\n\n                    if (tsProp.ValueKind == JsonValueKind.String)\n                    {\n                        var tsStr = tsProp.GetString();\n                        if (!string.IsNullOrWhiteSpace(tsStr))\n                            long.TryParse(tsStr, out unixSeconds);\n                    }\n                    else if (tsProp.ValueKind == JsonValueKind.Number)\n                    {\n                        tsProp.TryGetInt64(out unixSeconds);\n                    }\n\n                    if (unixSeconds > 0)\n                        providerSentAtUtc = DateTimeOffset.FromUnixTimeSeconds(unixSeconds).UtcDateTime;\n                }\n\n                var inboundEventAtUtc = providerSentAtUtc == default ? DateTime.UtcNow : providerSentAtUtc;\n\n                string? content = msgType switch\n                {\n                    \"text\" when msg.TryGetProperty(\"text\", out var t) &&\n                                t.TryGetProperty(\"body\", out var b)\n                                => b.GetString(),\n\n                    \"image\" when msg.TryGetProperty(\"image\", out var img) &&\n                                 img.TryGetProperty(\"caption\", out var cap)\n                                 => cap.GetString(),\n\n                    \"document\" when msg.TryGetProperty(\"document\", out var doc) &&\n                                    doc.TryGetProperty(\"caption\", out var dcap)\n                                    => dcap.GetString(),\n\n                    \"video\" when msg.TryGetProperty(\"video\", out var vid) &&\n                                 vid.TryGetProperty(\"caption\", out var vcap)\n                                 => vcap.GetString(),\n\n                    _ => null\n                };\n\n                string? inboundMediaId = null;\n                string? inboundMediaType = null;\n                string? inboundMimeType = null;\n                string? inboundFileName = null;\n                double? inboundLocationLat = null;\n                double? inboundLocationLon = null;\n                string? inboundLocationName = null;\n                string? inboundLocationAddress = null;\n\n                if (msgType == \"image\" && msg.TryGetProperty(\"image\", out var imgObj) && imgObj.ValueKind == JsonValueKind.Object)\n                {\n                    inboundMediaType = \"image\";\n\n                    if (imgObj.TryGetProperty(\"id\", out var mid) && mid.ValueKind == JsonValueKind.String)\n                        inboundMediaId = mid.GetString();\n\n                    if (imgObj.TryGetProperty(\"mime_type\", out var mt) && mt.ValueKind == JsonValueKind.String)\n                        inboundMimeType = mt.GetString();\n                }\n                else if (msgType == \"document\" && msg.TryGetProperty(\"document\", out var docObj) && docObj.ValueKind == JsonValueKind.Object)\n                {\n                    inboundMediaType = \"document\";\n\n                    if (docObj.TryGetProperty(\"id\", out var mid) && mid.ValueKind == JsonValueKind.String)\n                        inboundMediaId = mid.GetString();\n\n                    if (docObj.TryGetProperty(\"mime_type\", out var mt) && mt.ValueKind == JsonValueKind.String)\n                        inboundMimeType = mt.GetString();\n\n                    if (docObj.TryGetProperty(\"filename\", out var fn) && fn.ValueKind == JsonValueKind.String)\n                        inboundFileName = fn.GetString();\n                }\n                else if (msgType == \"video\" && msg.TryGetProperty(\"video\", out var vidObj) && vidObj.ValueKind == JsonValueKind.Object)\n                {\n                    inboundMediaType = \"video\";\n\n                    if (vidObj.TryGetProperty(\"id\", out var mid) && mid.ValueKind == JsonValueKind.String)\n                        inboundMediaId = mid.GetString();\n\n                    if (vidObj.TryGetProperty(\"mime_type\", out var mt) && mt.ValueKind == JsonValueKind.String)\n                        inboundMimeType = mt.GetString();\n                }\n                else if (msgType == \"audio\" && msg.TryGetProperty(\"audio\", out var audObj) && audObj.ValueKind == JsonValueKind.Object)\n                {\n                    inboundMediaType = \"audio\";\n\n                    if (audObj.TryGetProperty(\"id\", out var mid) && mid.ValueKind == JsonValueKind.String)\n                        inboundMediaId = mid.GetString();\n\n                    if (audObj.TryGetProperty(\"mime_type\", out var mt) && mt.ValueKind == JsonValueKind.String)\n                        inboundMimeType = mt.GetString();\n                }\n                else if (msgType == \"location\" && msg.TryGetProperty(\"location\", out var locObj) && locObj.ValueKind == JsonValueKind.Object)\n                {\n                    inboundMediaType = \"location\";\n\n                    if (locObj.TryGetProperty(\"latitude\", out var lat) && lat.ValueKind == JsonValueKind.Number && lat.TryGetDouble(out var v1))\n                        inboundLocationLat = v1;\n\n                    if (locObj.TryGetProperty(\"longitude\", out var lon) && lon.ValueKind == JsonValueKind.Number && lon.TryGetDouble(out var v2))\n                        inboundLocationLon = v2;\n\n                    if (locObj.TryGetProperty(\"name\", out var nm) && nm.ValueKind == JsonValueKind.String)\n                        inboundLocationName = nm.GetString();\n\n                    if (locObj.TryGetProperty(\"address\", out var addr) && addr.ValueKind == JsonValueKind.String)\n                        inboundLocationAddress = addr.GetString();\n\n                    if (string.IsNullOrWhiteSpace(content))\n                        content = inboundLocationName ?? inboundLocationAddress ?? \"Location\";\n                }\n\n                logger.LogInformation(\n                    \"üì• Inbound WA message: type={MsgType}, from={From}, wamid={Wamid}, providerTsUtc={ProviderTsUtc}, preview={Preview}\",\n                    msgType,\n                    rawContactPhone,\n                    wamid,\n                    providerSentAtUtc,\n                    content?.Length > 50 ? content[..50] : content\n                );\n\n                // 2) Resolve business via ProviderDirectory first, then fallback to WhatsAppPhoneNumbers\n                if (!value.TryGetProperty(\"metadata\", out var metadata))\n                {\n                    logger.LogWarning(\"Inbound: metadata missing on webhook payload.\");\n                    return;\n                }\n\n                string? displayNumber = metadata.TryGetProperty(\"display_phone_number\", out var dn)\n                    ? dn.GetString()\n                    : null;\n\n                string? phoneNumberId = metadata.TryGetProperty(\"phone_number_id\", out var pn)\n                    ? pn.GetString()\n                    : null;\n\n                string? wabaId = metadata.TryGetProperty(\"waba_id\", out var we)\n                    ? we.GetString()\n                    : null;\n\n                // 2.1 Prefer provider directory\n                Guid? businessId = await _providerDirectory.ResolveBusinessIdAsync(\n                    provider: \"meta_cloud\",\n                    phoneNumberId: phoneNumberId,\n                    displayPhoneNumber: displayNumber,\n                    wabaId: wabaId,\n                    waId: rawContactPhone\n                );\n\n                // 2.2 Fallback to legacy WhatsAppPhoneNumbers by display number if needed\n                if (businessId == null && !string.IsNullOrWhiteSpace(displayNumber))\n                {\n                    var cleanIncomingBiz = NormalizeDigits(displayNumber);\n\n                    var candidates = await db.WhatsAppPhoneNumbers\n                        .AsNoTracking()\n                        .Where(n => n.IsActive)\n                        .Select(n => new { n.BusinessId, n.WhatsAppBusinessNumber })\n                        .ToListAsync();\n\n                    var numHit = candidates.FirstOrDefault(n =>\n                        NormalizeDigits(n.WhatsAppBusinessNumber) == cleanIncomingBiz);\n\n                    if (numHit != null)\n                        businessId = numHit.BusinessId;\n                }\n\n                if (businessId == null || businessId == Guid.Empty)\n                {\n                    logger.LogWarning(\n                        \"‚ùå Inbound: business not resolved. phone_number_id={PhoneId}, display={Display}, waba={Waba}, from={From}, wamid={Wamid}\",\n                        phoneNumberId,\n                        displayNumber,\n                        wabaId,\n                        rawContactPhone,\n                        wamid\n                    );\n                    return;\n                }\n\n                var resolvedBusinessId = businessId.Value;\n\n                // 3) Find or create contact\n                var resolvedContact = await contactService.FindOrCreateAsync(resolvedBusinessId, contactPhone);\n                if (resolvedContact == null)\n                {\n                    logger.LogWarning(\"‚ùå Could not resolve contact for phone: {Phone}\", contactPhone);\n                    return;\n                }\n\n                // Ensure updates are applied on an entity tracked by the same DbContext instance (db).\n                var contact = await db.Contacts.FirstOrDefaultAsync(c => c.Id == resolvedContact.Id);\n                if (contact == null)\n                {\n                    contact = await db.Contacts.FirstOrDefaultAsync(c =>\n                        c.BusinessId == resolvedBusinessId &&\n                        c.PhoneNumber == contactPhone);\n                }\n                if (contact == null)\n                {\n                    logger.LogWarning(\"‚ùå Tracked contact not found after resolve for phone: {Phone}\", contactPhone);\n                    return;\n                }\n\n                var keywordToken = NormalizeKeywordToken(content);\n                var isStopKeyword = IsStopKeyword(keywordToken);\n                var isStartKeyword = IsStartKeyword(keywordToken);\n                var skipAutomationForCompliance = false;\n                var skipAutomationReason = string.Empty;\n                var complianceNowUtc = inboundEventAtUtc;\n\n                // Hard-coded compliance interceptor:\n                // STOP/START handling must run before any user-configured automation.\n                if (isStopKeyword)\n                {\n                    contact.OptStatus = ContactOptStatus.OptedOut;\n                    contact.OptStatusUpdatedAt = complianceNowUtc;\n                    contact.OptOutReason = \"KeywordStop\";\n                    skipAutomationForCompliance = true;\n                    skipAutomationReason = \"STOP keyword\";\n                }\n                else if (isStartKeyword)\n                {\n                    contact.OptStatus = ContactOptStatus.OptedIn;\n                    contact.OptStatusUpdatedAt = complianceNowUtc;\n                    contact.OptOutReason = null;\n\n                    // Safe default: do not run automation for START messages.\n                    skipAutomationForCompliance = true;\n                    skipAutomationReason = \"START keyword\";\n                }\n                else if (contact.OptStatus == ContactOptStatus.OptedOut)\n                {\n                    // Contact is opted out: keep recording inbound and inbox updates,\n                    // but block automation to avoid compliance violations/bot loops.\n                    skipAutomationForCompliance = true;\n                    skipAutomationReason = \"contact is opted out\";\n                }\n\n                static string? TryGetProfileName(JsonElement root)\n                {\n                    if (root.TryGetProperty(\"contacts\", out var contactsEl) &&\n                        contactsEl.ValueKind == JsonValueKind.Array &&\n                        contactsEl.GetArrayLength() > 0)\n                    {\n                        var c0 = contactsEl[0];\n                        if (c0.TryGetProperty(\"profile\", out var prof) &&\n                            prof.ValueKind == JsonValueKind.Object &&\n                            prof.TryGetProperty(\"name\", out var nm) &&\n                            nm.ValueKind == JsonValueKind.String)\n                        {\n                            var n = nm.GetString();\n                            return string.IsNullOrWhiteSpace(n) ? null : n!.Trim();\n                        }\n                    }\n                    return null;\n                }\n\n                var profileName = TryGetProfileName(value);\n                if (!string.IsNullOrWhiteSpace(profileName))\n                {\n                    try\n                    {\n                        await contactProfileService.UpsertProfileNameAsync(\n                            resolvedBusinessId,\n                            contactPhone,\n                            profileName!,\n                            CancellationToken.None);\n                    }\n                    catch (Exception ex)\n                    {\n                        logger.LogWarning(ex, \"‚ö†Ô∏è Failed to upsert ProfileName for {Phone}\", contactPhone);\n                    }\n                }\n\n                // 4) Read chat mode (still fine to read)\n                var mode = await chatSessionStateService.GetChatModeAsync(resolvedBusinessId, contact.Id);\n                var isAgentMode = mode == \"agent\";\n\n                // 5) Update conversation timestamps + auto-reopen on inbound (best-effort)\n                try\n                {\n                    contact.LastInboundAt = inboundEventAtUtc;\n\n                    var inboxStatus = (contact.InboxStatus ?? string.Empty).Trim();\n                    if (string.Equals(inboxStatus, \"Closed\", StringComparison.OrdinalIgnoreCase) ||\n                        contact.IsArchived ||\n                        !contact.IsActive)\n                    {\n                        contact.InboxStatus = \"Open\";\n                        contact.IsArchived = false;\n                        contact.IsActive = true;\n                    }\n\n                    // ‚úÖ persist contact updates (best effort)\n                    await db.SaveChangesAsync();\n                }\n                catch { /* best-effort */ }\n\n                // ‚úÖ Single-writer rule:\n                // Always persist inbound via InboxService. No direct db.MessageLogs.Add here.\n                var saved = await inboxService.SaveIncomingMessageAsync(new InboxMessageDto\n                {\n                    BusinessId = resolvedBusinessId,\n                    ContactId = contact.Id,\n\n                    // NOTE: your current storage convention uses RecipientPhone as the \"other party\" number\n                    RecipientPhone = contactPhone,\n\n                    MessageBody = content ?? string.Empty,\n                    MediaId = inboundMediaId,\n                    MediaType = inboundMediaType,\n                    FileName = inboundFileName,\n                    MimeType = inboundMimeType,\n                    LocationLatitude = inboundLocationLat,\n                    LocationLongitude = inboundLocationLon,\n                    LocationName = inboundLocationName,\n                    LocationAddress = inboundLocationAddress,\n                    IsIncoming = true,\n                    Status = \"received\",\n                    SentAt = providerSentAtUtc,\n\n                    // ‚úÖ Provider id (Meta WAMID) for idempotency\n                    ProviderMessageId = wamid\n                });\n\n                // Push SignalR event (prefer SentAt if available for correct thread ordering)\n                var sentAtForUi = saved.SentAt ?? saved.CreatedAt;\n\n                // ‚úÖ IMPORTANT: align payload keys with InboxHub.SendMessageToContact:\n                // use \"messageContent\" (not \"message\")\n                await _hub.Clients\n                    .Group($\"business_{resolvedBusinessId}\")\n                    .SendAsync(\"ReceiveInboxMessage\", new\n                    {\n                        contactId = contact.Id,\n                        messageContent = saved.MessageContent,\n                        isIncoming = true,\n                        senderId = (Guid?)null,\n                        status = saved.Status,\n                        sentAt = sentAtForUi,\n\n                        // ‚úÖ helps UI match / debug\n                        logId = saved.Id,\n                        messageLogId = saved.Id,\n                        providerMessageId = saved.ProviderMessageId,\n\n                        // ‚úÖ media support (image/pdf)\n                        mediaId = saved.MediaId,\n                        mediaType = saved.MediaType,\n                        fileName = saved.FileName,\n                        mimeType = saved.MimeType,\n                        locationLatitude = saved.LocationLatitude,\n                        locationLongitude = saved.LocationLongitude,\n                        locationName = saved.LocationName,\n                        locationAddress = saved.LocationAddress\n                    });\n\n                // 6) Try AutoReply runtime first, then fall back to legacy automation\n                if (skipAutomationForCompliance)\n                {\n                    logger.LogInformation(\n                        \"Compliance interceptor skipped automation. BusinessId={BusinessId}, ContactId={ContactId}, Reason={Reason}, Keyword={Keyword}\",\n                        resolvedBusinessId,\n                        contact.Id,\n                        skipAutomationReason,\n                        keywordToken\n                    );\n                }\n                else\n                {\n                    try\n                    {\n                        var triggerRaw = (content ?? string.Empty).Trim();\n                        var triggerKeyword = triggerRaw.ToLowerInvariant();\n\n                        var autoHandled = false;\n\n                        if (!string.IsNullOrWhiteSpace(triggerRaw))\n                        {\n                            var autoResult = await autoReplyRuntime.TryHandleAsync(\n                                resolvedBusinessId,\n                                contact.Id,\n                                contact.PhoneNumber,\n                                triggerRaw,\n                                CancellationToken.None\n                            );\n\n                            autoHandled = autoResult.Handled;\n\n                            if (autoResult.Handled)\n                            {\n                                logger.LogInformation(\n                                    \"ü§ñ AutoReply runtime handled inbound message. BusinessId={BusinessId}, ContactId={ContactId}, Keyword={Keyword}, SentSimpleReply={SentSimpleReply}, StartedCtaFlow={StartedCtaFlow}, AutoReplyFlowId={FlowId}, CtaFlowConfigId={CtaId}\",\n                                    resolvedBusinessId,\n                                    contact.Id,\n                                    triggerKeyword,\n                                    autoResult.SentSimpleReply,\n                                    autoResult.StartedCtaFlow,\n                                    autoResult.AutoReplyFlowId,\n                                    autoResult.CtaFlowConfigId\n                                );\n                            }\n                            else\n                            {\n                                logger.LogInformation(\n                                    \"ü§ñ AutoReply runtime did not handle message. Falling back to legacy automation. Keyword={Keyword}\",\n                                    triggerKeyword\n                                );\n                            }\n                        }\n\n                        if (!autoHandled)\n                        {\n                            var handledByLegacy = await automationService.TryRunFlowByKeywordAsync(\n                                resolvedBusinessId,\n                                triggerKeyword,\n                                contact.PhoneNumber,\n                                sourceChannel: \"whatsapp\",\n                                industryTag: \"default\");\n\n                            if (!handledByLegacy)\n                            {\n                                logger.LogInformation(\"üïµÔ∏è No automation flow matched keyword (legacy): {Keyword}\", triggerKeyword);\n                            }\n                        }\n                    }\n                    catch (Exception ex)\n                    {\n                        logger.LogError(ex, \"‚ùå AutoReply / Automation flow execution failed.\");\n                    }\n                }\n\n                logger.LogInformation(\n                    \"‚úÖ Inbound persisted via InboxService (single-writer). mode={Mode}, businessId={BusinessId}, contactId={ContactId}, wamid={Wamid}\",\n                    isAgentMode ? \"agent\" : \"bot\",\n                    resolvedBusinessId,\n                    contact.Id,\n                    wamid\n                );\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Failed to process inbound WhatsApp chat.\");\n            }\n        }\n\n        private static bool IsStopKeyword(string normalizedText)\n        {\n            return StopKeywords.Contains(normalizedText);\n        }\n\n        private static bool IsStartKeyword(string normalizedText)\n        {\n            return StartKeywords.Contains(normalizedText);\n        }\n\n        private static string NormalizeKeywordToken(string? text)\n        {\n            if (string.IsNullOrWhiteSpace(text)) return string.Empty;\n\n            var firstToken = text.Trim()\n                .Split(new[] { ' ', '\\t', '\\r', '\\n' }, StringSplitOptions.RemoveEmptyEntries)\n                .FirstOrDefault() ?? string.Empty;\n\n            var trimmed = firstToken.Trim().Trim('.', ',', '!', '?', ';', ':', '\"', '\\'', '(', ')', '[', ']', '{', '}');\n            return trimmed.ToUpperInvariant();\n        }\n\n        public async Task ProcessInteractiveAsync(JsonElement value, CancellationToken ct = default)\n        {\n            using var scope = _serviceScopeFactory.CreateScope();\n            var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n            var contactProfileService = scope.ServiceProvider.GetRequiredService<IContactProfileService>();\n            var logger = scope.ServiceProvider.GetRequiredService<ILogger<InboundMessageProcessor>>();\n\n            static string Normalize(string? number) =>\n                string.IsNullOrWhiteSpace(number) ? \"\" : new string(number.Where(char.IsDigit).ToArray());\n\n            static string? TryGetProfileName(JsonElement root)\n            {\n                if (root.TryGetProperty(\"contacts\", out var contactsEl) &&\n                    contactsEl.ValueKind == JsonValueKind.Array &&\n                    contactsEl.GetArrayLength() > 0)\n                {\n                    var c0 = contactsEl[0];\n                    if (c0.TryGetProperty(\"profile\", out var profileEl) &&\n                        profileEl.ValueKind == JsonValueKind.Object &&\n                        profileEl.TryGetProperty(\"name\", out var nameEl) &&\n                        nameEl.ValueKind == JsonValueKind.String)\n                    {\n                        var n = nameEl.GetString();\n                        return string.IsNullOrWhiteSpace(n) ? null : n!.Trim();\n                    }\n                }\n                return null;\n            }\n\n            if (!value.TryGetProperty(\"messages\", out var msgs) || msgs.ValueKind != JsonValueKind.Array || msgs.GetArrayLength() == 0)\n                return;\n\n            var msg0 = msgs[0];\n            var fromRaw = msg0.GetProperty(\"from\").GetString() ?? \"\";\n            var fromE164 = Normalize(fromRaw);\n\n            var displayNumberRaw = value.GetProperty(\"metadata\").GetProperty(\"display_phone_number\").GetString() ?? \"\";\n            var displayNumber = Normalize(displayNumberRaw);\n\n            var candidates = await db.WhatsAppPhoneNumbers\n                .AsNoTracking()\n                .Where(n => n.IsActive)\n                .Select(n => new { n.BusinessId, n.WhatsAppBusinessNumber })\n                .ToListAsync(ct);\n\n            var numHit = candidates.FirstOrDefault(n => Normalize(n.WhatsAppBusinessNumber) == displayNumber);\n            if (numHit == null)\n            {\n                logger.LogWarning(\"‚ùå Business not found for interactive webhook number: {Num}\", displayNumberRaw);\n                return;\n            }\n\n            var businessId = numHit.BusinessId;\n\n            var profileName = TryGetProfileName(value);\n            if (!string.IsNullOrWhiteSpace(profileName))\n            {\n                try\n                {\n                    await contactProfileService.UpsertProfileNameAsync(businessId, fromE164, profileName!, ct);\n                }\n                catch (Exception ex)\n                {\n                    logger.LogWarning(ex, \"‚ö†Ô∏è Failed to upsert ProfileName on interactive webhook for {Phone}\", fromE164);\n                }\n            }\n\n            // ‚Ä¶ continue your existing interactive handling\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/ITemplateWebhookProcessor.cs",
      "sha256": "6f04b24d675a88073c59204ed241e4744205e80e8d488dd464550a6105c45b7a",
      "language": "csharp",
      "size": 242,
      "content": "using System.Text.Json;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    public interface ITemplateWebhookProcessor\n    {\n        Task ProcessTemplateUpdateAsync(JsonElement payload);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/TemplateWebhookProcessor.cs",
      "sha256": "0dbe7873fcf7b84d3a4fb9d78bda6689d86cbfd4d9fd50ce1d98029aaaef0558",
      "language": "csharp",
      "size": 1391,
      "content": "using System;\nusing System.Text.Json;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Logging;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    public class TemplateWebhookProcessor : ITemplateWebhookProcessor\n    {\n        private readonly ILogger<TemplateWebhookProcessor> _logger;\n\n        public TemplateWebhookProcessor(ILogger<TemplateWebhookProcessor> logger)\n        {\n            _logger = logger;\n        }\n\n        public async Task ProcessTemplateUpdateAsync(JsonElement payload)\n        {\n            try\n            {\n                var entry = payload.GetProperty(\"entry\")[0];\n                var changes = entry.GetProperty(\"changes\")[0];\n                var value = changes.GetProperty(\"value\");\n\n                var eventType = value.GetProperty(\"event\").GetString();\n                var templateId = value.TryGetProperty(\"message_template_id\", out var idProp)\n                                 ? idProp.GetString() : \"(unknown)\";\n\n                _logger.LogInformation($\"üßæ Template Event Received: {eventType} for ID: {templateId}\");\n\n                // üß† You can store in DB or show in admin logs in the future\n\n                await Task.CompletedTask;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Failed to process template webhook update.\");\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Resolvers/IMessageIdResolver.cs",
      "sha256": "b7b826aacb41d60aaa63c0a5c7350a4384eeb07af18d899fb8199afe7e9ef3d9",
      "language": "csharp",
      "size": 463,
      "content": "using System;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Resolvers\n{\n    public interface IMessageIdResolver\n    {\n        Task<Guid?> ResolveCampaignSendLogIdAsync(string messageId);\n        Task<Guid?> ResolveMessageLogIdAsync(string messageId);\n        Task<Guid?> ResolveBusinessIdByMessageIdAsync(string messageId);\n        Task<string?> ResolveAsync(string providerMessageId, CancellationToken ct = default);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Resolvers/MessageIdResolver.cs",
      "sha256": "631816c0acf1e2bbc9d610ef2145f4ee80c89efd95d2abf8728ff32be09142e8",
      "language": "csharp",
      "size": 3838,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing Serilog;\nusing System;\nusing System.Threading.Tasks;\nusing xbytechat.api;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Resolvers\n{\n    public class MessageIdResolver : IMessageIdResolver\n    {\n        private readonly AppDbContext _context;\n        private readonly ILogger<MessageIdResolver> _logger;\n\n        public MessageIdResolver(AppDbContext context, ILogger<MessageIdResolver> logger)\n        {\n            _context = context;\n            _logger = logger;\n        }\n        public async Task<string?> ResolveAsync(string providerMessageId, CancellationToken ct = default)\n        {\n            if (string.IsNullOrWhiteSpace(providerMessageId))\n                return null;\n\n            // 1) Already a WAMID? Return as-is.\n            if (providerMessageId.StartsWith(\"wamid.\", StringComparison.OrdinalIgnoreCase))\n                return providerMessageId;\n\n            // 2) Try MessageLogs mapping (most reliable)\n            //    We pick any field that looks like a WAMID if present; otherwise fall back to MessageId.\n            var mlHit = await _context.MessageLogs.AsNoTracking()\n                .Where(m => m.ProviderMessageId == providerMessageId || m.MessageId == providerMessageId)\n                .OrderByDescending(m => m.CreatedAt)\n                .Select(m =>\n                    m.ProviderMessageId.StartsWith(\"wamid.\", StringComparison.OrdinalIgnoreCase)\n                        ? m.ProviderMessageId\n                        : (m.MessageId ?? m.ProviderMessageId))\n                .FirstOrDefaultAsync(ct);\n\n            if (!string.IsNullOrEmpty(mlHit))\n                return mlHit;\n\n            // 3) Some paths write WAMID straight into CampaignSendLogs.MessageId (no mapping required)\n            var cslHit = await _context.CampaignSendLogs.AsNoTracking()\n                .Where(c => c.MessageId == providerMessageId)\n                .OrderByDescending(c => c.CreatedAt)\n                .Select(c => c.MessageId)\n                .FirstOrDefaultAsync(ct);\n\n            if (!string.IsNullOrEmpty(cslHit))\n                return cslHit;\n\n            // 4) Fallback: return original (keeps pipeline flowing even if we can‚Äôt map)\n            _logger.LogDebug(\"MessageIdResolver: passthrough for provider id {ProviderMessageId}\", providerMessageId);\n            return providerMessageId;\n        }\n\n        public async Task<Guid?> ResolveCampaignSendLogIdAsync(string messageId)\n        {\n            var log = await _context.CampaignSendLogs\n                                .FirstOrDefaultAsync(l => l.MessageId == messageId);\n\n            if (log == null)\n            {\n                _logger.LogWarning(\"‚ö†Ô∏è CampaignSendLog not found for MessageId: {MessageId}\", messageId);\n                return null;\n            }\n\n            return log.Id;\n        }\n\n        public async Task<Guid?> ResolveMessageLogIdAsync(string messageId)\n        {\n            var log = await _context.MessageLogs\n                .AsNoTracking()\n                .FirstOrDefaultAsync(l => l.MessageId == messageId);\n\n            if (log == null)\n            {\n                _logger.LogWarning(\"‚ö†Ô∏è MessageLog not found for MessageId: {MessageId}\", messageId);\n                return null;\n            }\n\n            return log.Id;\n        }\n\n        public async Task<Guid?> ResolveBusinessIdByMessageIdAsync(string messageId)\n        {\n            var log = await _context.MessageLogs\n                .AsNoTracking()\n                .FirstOrDefaultAsync(l => l.MessageId == messageId);\n\n            if (log == null)\n            {\n                _logger.LogWarning(\"‚ö†Ô∏è MessageLog not found for MessageId: {MessageId}\", messageId);\n                return null;\n            }\n\n            return log.BusinessId;\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/WebhookQueueService.cs",
      "sha256": "23464eca5cf467cb66d274bef31125a45b4661811e291e4a8bf633d9eff412fa",
      "language": "csharp",
      "size": 2574,
      "content": "using System.Text.Json;\nusing System.Threading.Channels;\nusing Microsoft.Extensions.Logging;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public class WebhookQueueService : IWebhookQueueService\n    {\n        private readonly Channel<JsonElement> _queue;\n        private readonly ILogger<WebhookQueueService> _logger;\n\n        public WebhookQueueService(ILogger<WebhookQueueService> logger)\n        {\n            _logger = logger;\n\n            var options = new BoundedChannelOptions(5000)\n            {\n                FullMode = BoundedChannelFullMode.Wait,\n                SingleReader = true,\n                SingleWriter = false\n            };\n\n            _queue = Channel.CreateBounded<JsonElement>(options);\n\n            _logger.LogInformation(\n                \"‚úÖ WebhookQueueService initialized with capacity {Capacity}, FullMode={FullMode}, SingleReader={SingleReader}, SingleWriter={SingleWriter}.\",\n                5000,\n                options.FullMode,\n                options.SingleReader,\n                options.SingleWriter\n            );\n        }\n\n        public void Enqueue(JsonElement item)\n        {\n            // Optional: log size instead of full content to avoid noisy logs\n            var length = item.ToString()?.Length ?? 0;\n\n            if (!_queue.Writer.TryWrite(item))\n            {\n                _logger.LogError(\n                    \"‚ùå Failed to enqueue webhook payload: queue is full. CurrentCount={Count}, PayloadLength={PayloadLength}.\",\n                    _queue.Reader.Count,\n                    length\n                );\n                throw new InvalidOperationException(\"‚ö†Ô∏è Webhook queue is full.\");\n            }\n\n            _logger.LogInformation(\n                \"üì• Enqueued webhook payload successfully. CurrentCount={Count}, PayloadLength={PayloadLength}.\",\n                _queue.Reader.Count,\n                length\n            );\n        }\n\n        public async ValueTask<JsonElement> DequeueAsync(CancellationToken cancellationToken)\n        {\n            var item = await _queue.Reader.ReadAsync(cancellationToken);\n\n            // Again, just log length, not the full JSON, to keep logs readable\n            var length = item.ToString()?.Length ?? 0;\n\n            _logger.LogInformation(\n                \"üì§ Dequeued webhook payload for processing. RemainingCount={Count}, PayloadLength={PayloadLength}.\",\n                _queue.Reader.Count,\n                length\n            );\n\n            return item;\n        }\n\n        public int GetQueueLength() => _queue.Reader.Count;\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/WhatsAppWebhookDispatcher.cs",
      "sha256": "ffc88b3558f9eee9b0656e1fa3c72d28137d701c4b158cded08aceaad81caddb",
      "language": "csharp",
      "size": 18348,
      "content": "using System;\nusing System.Linq;\nusing System.Text.Json;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.Webhooks.Directory;\nusing xbytechat.api.Features.Webhooks.Pinnacle.Services.Adapters;\nusing xbytechat.api.Features.Webhooks.Services.Processors;\nusing xbytechat_api.Features.Billing.Services;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public class WhatsAppWebhookDispatcher : IWhatsAppWebhookDispatcher\n    {\n        // Removed legacy _statusProcessor on purpose\n        private readonly ITemplateWebhookProcessor _templateProcessor;\n        private readonly IClickWebhookProcessor _clickProcessor;\n        private readonly IInboundMessageProcessor _inboundMessageProcessor;\n        private readonly IWhatsAppWebhookService _webhookService;\n        private readonly IProviderDirectory _directory;\n        private readonly ILogger<WhatsAppWebhookDispatcher> _logger;\n        private readonly IPinnacleToMetaAdapter _pinnacleToMetaAdapter;\n        private readonly IBillingIngestService _billingIngest;\n\n        public WhatsAppWebhookDispatcher(\n            ITemplateWebhookProcessor templateProcessor,\n            ILogger<WhatsAppWebhookDispatcher> logger,\n            IClickWebhookProcessor clickProcessor,\n            IInboundMessageProcessor inboundMessageProcessor,\n            IWhatsAppWebhookService webhookService,\n            IProviderDirectory directory,\n            IPinnacleToMetaAdapter pinnacleToMetaAdapter,\n            IBillingIngestService billingIngest)\n        {\n            _templateProcessor = templateProcessor;\n            _logger = logger;\n            _clickProcessor = clickProcessor;\n            _inboundMessageProcessor = inboundMessageProcessor;\n            _webhookService = webhookService;\n            _directory = directory;\n            _pinnacleToMetaAdapter = pinnacleToMetaAdapter;\n            _billingIngest = billingIngest;\n        }\n\n        public async Task DispatchAsync(JsonElement payload)\n        {\n            // Keep raw payload at Debug to avoid log spam in prod\n            _logger.LogDebug(\"üì¶ Dispatcher raw payload:\\n{Payload}\", payload.GetRawText());\n\n            try\n            {\n                // 0) Detect provider & normalize into a Meta-like \"entry[].changes[].value\" envelope\n                var provider = DetectProvider(payload); // \"meta\" | \"pinnacle\" | null\n                _logger.LogInformation(\"üåê Dispatcher: detected provider={Provider}\", provider ?? \"(auto/meta)\");\n\n                var envelope = provider == \"pinnacle\"\n                    ? _pinnacleToMetaAdapter.ToMetaEnvelope(payload)\n                    : payload;\n\n                if (!envelope.TryGetProperty(\"entry\", out var entries) || entries.ValueKind != JsonValueKind.Array)\n                {\n                    _logger.LogWarning(\"‚ö†Ô∏è Dispatcher: No 'entry' array found on envelope; skipping payload.\");\n                    return;\n                }\n\n                // Compute once per envelope (micro-optimization)\n                var isStatus = IsStatusPayload(envelope);\n                _logger.LogInformation(\"üîé Dispatcher: isStatusPayload={IsStatus}\", isStatus);\n\n                foreach (var entry in entries.EnumerateArray())\n                {\n                    if (!entry.TryGetProperty(\"changes\", out var changes) || changes.ValueKind != JsonValueKind.Array)\n                    {\n                        _logger.LogDebug(\"‚ÑπÔ∏è Dispatcher: 'entry' without 'changes' array; skipping entry.\");\n                        continue;\n                    }\n\n                    foreach (var change in changes.EnumerateArray())\n                    {\n                        if (!change.TryGetProperty(\"value\", out var value) || value.ValueKind != JsonValueKind.Object)\n                        {\n                            _logger.LogDebug(\"‚ÑπÔ∏è Dispatcher: 'change' without object 'value'; skipping change.\");\n                            continue;\n                        }\n\n                        // 1) STATUS UPDATES\n                        if (isStatus)\n                        {\n                            _logger.LogInformation(\"üì¶ Dispatcher: treating envelope as STATUS payload (provider={Provider}).\", provider ?? \"meta\");\n\n                            // Resolve BusinessId using *envelope* metadata (works for Meta and adapted Pinnacle)\n                            Guid resolvedBiz = Guid.Empty;\n                            try\n                            {\n                                var hints = ExtractNumberHints(envelope, provider);\n                                _logger.LogDebug(\n                                    \"üî¢ Dispatcher: Number hints extracted. PhoneNumberId={PhoneNumberId}, DisplayPhone={DisplayPhone}, WabaId={WabaId}, WaId={WaId}\",\n                                    hints.PhoneNumberId,\n                                    hints.DisplayPhoneNumber,\n                                    hints.WabaId,\n                                    hints.WaId);\n\n                                var bid = await _directory.ResolveBusinessIdAsync(\n                                    provider: provider,\n                                    phoneNumberId: hints.PhoneNumberId,\n                                    displayPhoneNumber: hints.DisplayPhoneNumber,\n                                    wabaId: hints.WabaId,\n                                    waId: hints.WaId\n                                );\n                                if (bid.HasValue) resolvedBiz = bid.Value;\n                            }\n                            catch (Exception ex)\n                            {\n                                _logger.LogWarning(ex, \"ProviderDirectory lookup failed; proceeding without BusinessId.\");\n                            }\n\n                            // Canonical provider label for billing\n                            var providerCanonical = string.Equals(provider, \"pinnacle\", StringComparison.OrdinalIgnoreCase)\n                                ? \"PINNACLE\"\n                                : \"META_CLOUD\";\n\n                            // Only call billing ingest when BusinessId was resolved\n                            if (resolvedBiz != Guid.Empty)\n                            {\n                                try\n                                {\n                                    _logger.LogInformation(\n                                        \"üí∞ Dispatcher: routing status payload to BillingIngest for BusinessId={BusinessId}, Provider={ProviderCanonical}\",\n                                        resolvedBiz,\n                                        providerCanonical);\n\n                                    await _billingIngest.IngestFromWebhookAsync(\n                                        resolvedBiz,\n                                        providerCanonical,\n                                        envelope.GetRawText());\n                                }\n                                catch (Exception ex)\n                                {\n                                    _logger.LogWarning(ex, \"Billing ingest from webhook failed (non-fatal).\");\n                                }\n                            }\n                            else\n                            {\n                                _logger.LogWarning(\n                                    \"‚ö†Ô∏è Dispatcher: status payload had no resolved BusinessId; billing ingest will be skipped.\");\n                            }\n\n                            // Unified status updater (no legacy fallback)\n                            _logger.LogInformation(\n                                \"üì¶ Dispatcher: routing to Unified Status Updater (provider={Provider}, businessId={BusinessId})\",\n                                provider,\n                                resolvedBiz == Guid.Empty ? \"(unknown)\" : resolvedBiz.ToString());\n\n                            await _webhookService.ProcessStatusUpdateAsync(\n                                resolvedBiz,\n                                provider ?? \"meta\",\n                                envelope);\n\n                            // Note: continue to next change ‚Äî even if envelope is status-oriented,\n                            // other changes in the same webhook could be non-status in some providers.\n                            continue;\n                        }\n\n                        // 2) TEMPLATE EVENTS\n                        if (value.TryGetProperty(\"event\", out var eventType) &&\n                            eventType.GetString()?.StartsWith(\"template_\", StringComparison.Ordinal) == true)\n                        {\n                            _logger.LogInformation(\"üì¶ Dispatcher: routing to Template Processor (event={Event})\", eventType.GetString());\n                            await _templateProcessor.ProcessTemplateUpdateAsync(envelope);\n                            continue;\n                        }\n\n                        // 3) MESSAGES (clicks + inbound)\n                        if (!value.TryGetProperty(\"messages\", out var msgs) || msgs.GetArrayLength() == 0)\n                        {\n                            _logger.LogDebug(\"‚ÑπÔ∏è Dispatcher: 'value' has no 'messages' array or it is empty; skipping.\");\n                            continue;\n                        }\n\n                        foreach (var m in msgs.EnumerateArray())\n                        {\n                            if (!m.TryGetProperty(\"type\", out var typeProp))\n                            {\n                                _logger.LogDebug(\"‚ÑπÔ∏è Dispatcher: message without 'type' field; skipping message.\");\n                                continue;\n                            }\n\n                            var type = typeProp.GetString();\n                            _logger.LogDebug(\"üîç Dispatcher: inspecting message of type '{Type}'.\", type);\n\n                            // (A) Legacy quick-reply button ‚Üí CLICK\n                            if (type == \"button\")\n                            {\n                                _logger.LogInformation(\"üëâ Dispatcher: routing to Click Processor (legacy 'button').\");\n                                await _clickProcessor.ProcessClickAsync(value);\n                                continue;\n                            }\n\n                            // (B) Interactive (button_reply / list_reply) ‚Üí CLICK\n                            if (type == \"interactive\" && m.TryGetProperty(\"interactive\", out var interactive))\n                            {\n                                if (interactive.TryGetProperty(\"type\", out var interactiveType) &&\n                                    interactiveType.GetString() == \"button_reply\")\n                                {\n                                    _logger.LogInformation(\"üëâ Dispatcher: routing to Click Processor (interactive/button_reply).\");\n                                    await _clickProcessor.ProcessClickAsync(value);\n                                    continue;\n                                }\n\n                                if (interactive.TryGetProperty(\"list_reply\", out _))\n                                {\n                                    _logger.LogInformation(\"üëâ Dispatcher: routing to Click Processor (interactive/list_reply).\");\n                                    await _clickProcessor.ProcessClickAsync(value);\n                                    continue;\n                                }\n                            }\n\n                            // (C) Inbound plain message types ‚Üí INBOUND\n                            if (type is \"text\" or \"image\" or \"document\" or \"audio\" or \"video\" or \"location\")\n                            {\n                                _logger.LogInformation(\n                                    \"üí¨ Dispatcher: routing to InboundMessageProcessor (message type: {Type}, provider={Provider}).\",\n                                    type,\n                                    provider ?? \"meta\");\n\n                                await _inboundMessageProcessor.ProcessChatAsync(value, m);\n                                continue;\n                            }\n\n                            _logger.LogDebug(\"‚ÑπÔ∏è Dispatcher: message type '{Type}' not handled by dispatcher.\", type);\n                        }\n                    }\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Dispatcher failed to process WhatsApp webhook.\");\n            }\n        }\n\n        private static bool IsStatusPayload(JsonElement root)\n        {\n            // Meta-like: entry[].changes[].value.statuses\n            if (TryGetMetaValue(root, out var val) && val.Value.TryGetProperty(\"statuses\", out _))\n                return true;\n\n            // Some providers mark with \"status\" or event containing \"status\"\n            if (root.TryGetProperty(\"status\", out _)) return true;\n            if (root.TryGetProperty(\"event\", out var ev) &&\n                (ev.GetString()?.Contains(\"status\", StringComparison.OrdinalIgnoreCase) ?? false))\n                return true;\n\n            return false;\n        }\n\n        private static string? DetectProvider(JsonElement root)\n        {\n            // Heuristics by envelope\n            if (root.TryGetProperty(\"object\", out var obj) && obj.GetString() == \"whatsapp_business_account\")\n                return \"meta\";\n            if (root.TryGetProperty(\"entry\", out _))\n                return \"meta\";\n            if (root.TryGetProperty(\"event\", out _))\n                return \"pinnacle\";\n            return null;\n        }\n\n        private static bool TryGetMetaValue(JsonElement root, out (JsonElement Value, JsonElement? Change, JsonElement? Entry) res)\n        {\n            res = default;\n            if (!root.TryGetProperty(\"entry\", out var entries) || entries.ValueKind != JsonValueKind.Array || entries.GetArrayLength() == 0)\n                return false;\n\n            var entry = entries[0];\n            if (!entry.TryGetProperty(\"changes\", out var changes) || changes.ValueKind != JsonValueKind.Array || changes.GetArrayLength() == 0)\n                return false;\n\n            var change = changes[0];\n            if (!change.TryGetProperty(\"value\", out var value))\n                return false;\n\n            res = (value, change, entry);\n            return true;\n        }\n\n        private static NumberHints ExtractNumberHints(JsonElement root, string? provider)\n        {\n            var hints = new NumberHints();\n\n            // Meta (or unknown ‚Üí treat as Meta envelope)\n            if (string.Equals(provider, \"meta\", StringComparison.OrdinalIgnoreCase) || provider is null)\n            {\n                if (TryGetMetaValue(root, out var v))\n                {\n                    if (v.Value.TryGetProperty(\"metadata\", out var md))\n                    {\n                        if (md.TryGetProperty(\"phone_number_id\", out var pnid))\n                            hints.PhoneNumberId = pnid.GetString();\n\n                        if (md.TryGetProperty(\"display_phone_number\", out var disp))\n                            hints.DisplayPhoneNumber = NormalizePhone(disp.GetString());\n\n                        if (md.TryGetProperty(\"waba_id\", out var wabaFromMeta))\n                            hints.WabaId = wabaFromMeta.GetString();\n                    }\n\n                    // Some adapters put waba_id at value-level\n                    if (string.IsNullOrWhiteSpace(hints.WabaId) &&\n                        v.Value.TryGetProperty(\"waba_id\", out var wabaTop))\n                    {\n                        hints.WabaId = wabaTop.GetString();\n                    }\n\n                    // First status often carries recipient_id (WA ID)\n                    if (v.Value.TryGetProperty(\"statuses\", out var statuses) &&\n                        statuses.ValueKind == JsonValueKind.Array && statuses.GetArrayLength() > 0)\n                    {\n                        var s0 = statuses[0];\n                        if (s0.TryGetProperty(\"recipient_id\", out var rid))\n                            hints.WaId = rid.GetString();\n                    }\n                }\n            }\n            // Pinnacle (raw or adapted)\n            else if (string.Equals(provider, \"pinnacle\", StringComparison.OrdinalIgnoreCase))\n            {\n                // If your adapter produced a Meta-like envelope, this will work too:\n                if (TryGetMetaValue(root, out var v2) && v2.Value.TryGetProperty(\"metadata\", out var md2))\n                {\n                    if (md2.TryGetProperty(\"phone_number_id\", out var pnid2))\n                        hints.PhoneNumberId = pnid2.GetString();\n\n                    if (md2.TryGetProperty(\"display_phone_number\", out var disp2))\n                        hints.DisplayPhoneNumber = NormalizePhone(disp2.GetString());\n                }\n\n                // Raw Pinnacle-style fields on the envelope\n                if (string.IsNullOrWhiteSpace(hints.PhoneNumberId) &&\n                    root.TryGetProperty(\"phone_number_id\", out var pn))\n                    hints.PhoneNumberId = pn.GetString();\n\n                if (string.IsNullOrWhiteSpace(hints.DisplayPhoneNumber))\n                {\n                    if (root.TryGetProperty(\"from\", out var from))\n                        hints.DisplayPhoneNumber = NormalizePhone(from.GetString());\n                    else if (root.TryGetProperty(\"msisdn\", out var msisdn))\n                        hints.DisplayPhoneNumber = NormalizePhone(msisdn.GetString());\n                }\n\n                if (root.TryGetProperty(\"wabaId\", out var waba))\n                    hints.WabaId = waba.GetString();\n            }\n\n            return hints;\n        }\n\n        private static string? NormalizePhone(string? v)\n        {\n            if (string.IsNullOrWhiteSpace(v)) return null;\n            var t = v.Trim();\n            var keepPlus = t.StartsWith(\"+\");\n            var digits = new string(t.Where(char.IsDigit).ToArray());\n            return keepPlus ? \"+\" + digits : digits;\n        }\n\n        private struct NumberHints\n        {\n            public string? PhoneNumberId { get; set; }\n            public string? DisplayPhoneNumber { get; set; }\n            public string? WabaId { get; set; }\n            public string? WaId { get; set; }\n        }\n    }\n}\n\n\n\n\n\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/WhatsAppWebhookService.cs",
      "sha256": "6155433bf0c803bacb5afc3b03a8da671de7ed9bc94cee1c1902b6a2d1f20f3e",
      "language": "csharp",
      "size": 11899,
      "content": "// üìÑ File: Features/Webhooks/Services/WhatsAppWebhookService.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.SignalR;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.Inbox.Hubs;\nusing xbytechat.api.Features.Webhooks.Status;\nusing xbytechat.api.Infrastructure; // AppDbContext (keep as-is if correct)\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public sealed class WhatsAppWebhookService : IWhatsAppWebhookService\n    {\n        private readonly AppDbContext _context;\n        private readonly ILogger<WhatsAppWebhookService> _logger;\n        private readonly IMessageStatusUpdater _updater;\n        private readonly IHubContext<InboxHub> _hubContext;\n\n        public WhatsAppWebhookService(\n            AppDbContext context,\n            ILogger<WhatsAppWebhookService> logger,\n            IMessageStatusUpdater updater,\n            IHubContext<InboxHub> hubContext)\n        {\n            _context = context;\n            _logger = logger;\n            _updater = updater;\n            _hubContext = hubContext;\n        }\n\n        /// <summary>\n        /// Single modern entrypoint. Assumes payload is Meta-shaped (entry[].changes[].value.statuses[]).\n        /// BusinessId MUST be resolved by the caller (ProviderDirectory or equivalent).\n        /// </summary>\n        public async Task ProcessStatusUpdateAsync(Guid businessId, string provider, JsonElement payload, CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty)\n            {\n                _logger.LogWarning(\"Status update skipped: businessId is empty.\");\n                return;\n            }\n\n            provider = (provider ?? string.Empty).Trim();\n\n            static string NormalizeStatus(string? s)\n            {\n                s = (s ?? \"\").Trim().ToLowerInvariant();\n                return s switch\n                {\n                    \"sent\" => \"sent\",\n                    \"delivered\" => \"delivered\",\n                    \"read\" => \"read\",\n                    \"failed\" => \"failed\",\n                    \"deleted\" => \"deleted\",\n                    _ => s\n                };\n            }\n\n            static DateTime ParseTimestampUtc(JsonElement statusItem)\n            {\n                long unixTs = 0;\n\n                if (statusItem.TryGetProperty(\"timestamp\", out var tsProp))\n                {\n                    if (tsProp.ValueKind == JsonValueKind.String && long.TryParse(tsProp.GetString(), out var parsed))\n                        unixTs = parsed;\n                    else if (tsProp.ValueKind == JsonValueKind.Number)\n                        unixTs = tsProp.GetInt64();\n                }\n\n                return unixTs > 0\n                    ? DateTimeOffset.FromUnixTimeSeconds(unixTs).UtcDateTime\n                    : DateTime.UtcNow;\n            }\n\n            static string? TryExtractError(JsonElement statusItem)\n            {\n                // Meta shape often: errors: [{ code, title, details, error_data... }]\n                if (!statusItem.TryGetProperty(\"errors\", out var errorsEl) || errorsEl.ValueKind != JsonValueKind.Array)\n                    return null;\n\n                if (errorsEl.GetArrayLength() == 0)\n                    return null;\n\n                var e0 = errorsEl[0];\n\n                string? title = e0.TryGetProperty(\"title\", out var titleEl) ? titleEl.GetString() : null;\n                string? details = e0.TryGetProperty(\"details\", out var detailsEl) ? detailsEl.GetString() : null;\n\n                title = string.IsNullOrWhiteSpace(title) ? null : title.Trim();\n                details = string.IsNullOrWhiteSpace(details) ? null : details.Trim();\n\n                if (title == null && details == null) return null;\n\n                return title != null && details != null\n                    ? $\"{title} - {details}\"\n                    : (title ?? details);\n            }\n\n            // Parse Meta-like envelope: entry[].changes[].value.statuses[]\n            if (!payload.TryGetProperty(\"entry\", out var entries) || entries.ValueKind != JsonValueKind.Array)\n            {\n                _logger.LogWarning(\"Status payload missing 'entry' array. businessId={BusinessId}\", businessId);\n                return;\n            }\n\n            foreach (var entry in entries.EnumerateArray())\n            {\n                if (!entry.TryGetProperty(\"changes\", out var changes) || changes.ValueKind != JsonValueKind.Array)\n                    continue;\n\n                foreach (var change in changes.EnumerateArray())\n                {\n                    if (!change.TryGetProperty(\"value\", out var value) || value.ValueKind != JsonValueKind.Object)\n                        continue;\n\n                    if (!value.TryGetProperty(\"statuses\", out var statuses) || statuses.ValueKind != JsonValueKind.Array)\n                        continue;\n\n                    // ‚úÖ Performance: batch DB lookup for all ids in this statuses[] block\n                    var providerIds = new List<string>(capacity: Math.Max(4, statuses.GetArrayLength()));\n                    foreach (var st in statuses.EnumerateArray())\n                    {\n                        var id = st.TryGetProperty(\"id\", out var idProp) ? idProp.GetString() : null;\n                        if (!string.IsNullOrWhiteSpace(id))\n                            providerIds.Add(id!.Trim());\n                    }\n\n                    if (providerIds.Count == 0)\n                        continue;\n\n                    // ‚úÖ Business-scoped lookup ONLY (prevents cross-tenant updates)\n                    // We match both ProviderMessageId and MessageId to support older rows.\n                    var hits = await _context.MessageLogs\n                        .AsNoTracking()\n                        .Where(m => m.BusinessId == businessId &&\n                                    (\n                                        (m.ProviderMessageId != null && providerIds.Contains(m.ProviderMessageId)) ||\n                                        (m.MessageId != null && providerIds.Contains(m.MessageId))\n                                    ))\n                        .Select(m => new\n                        {\n                            m.Id,\n                            m.ContactId,\n                            m.ProviderMessageId,\n                            m.MessageId,\n                            m.CreatedAt\n                        })\n                        .ToListAsync(ct);\n\n                    // Map: providerId -> best match row\n                    // If both ProviderMessageId and MessageId collide, we pick the newest CreatedAt.\n                    var map = new Dictionary<string, (Guid msgLogId, Guid? contactId, string canonicalMessageId, DateTime createdAt)>(StringComparer.Ordinal);\n                    foreach (var h in hits.OrderByDescending(x => x.CreatedAt))\n                    {\n                        var canonical = (h.MessageId ?? h.ProviderMessageId ?? \"\").Trim();\n                        if (string.IsNullOrWhiteSpace(canonical)) continue;\n\n                        if (!string.IsNullOrWhiteSpace(h.ProviderMessageId))\n                        {\n                            var key = h.ProviderMessageId.Trim();\n                            if (!map.ContainsKey(key))\n                                map[key] = (h.Id, h.ContactId, canonical, h.CreatedAt);\n                        }\n\n                        if (!string.IsNullOrWhiteSpace(h.MessageId))\n                        {\n                            var key = h.MessageId.Trim();\n                            if (!map.ContainsKey(key))\n                                map[key] = (h.Id, h.ContactId, canonical, h.CreatedAt);\n                        }\n                    }\n\n                    foreach (var st in statuses.EnumerateArray())\n                    {\n                        string? providerMessageId = st.TryGetProperty(\"id\", out var idProp) ? idProp.GetString() : null;\n                        string? statusText = st.TryGetProperty(\"status\", out var statusProp) ? statusProp.GetString() : null;\n\n                        providerMessageId = string.IsNullOrWhiteSpace(providerMessageId) ? null : providerMessageId.Trim();\n                        statusText = string.IsNullOrWhiteSpace(statusText) ? null : statusText.Trim();\n\n                        if (providerMessageId == null || statusText == null)\n                        {\n                            _logger.LogWarning(\"Status item missing id or status. businessId={BusinessId}, item={Item}\",\n                                businessId, st.GetRawText());\n                            continue;\n                        }\n\n                        if (!map.TryGetValue(providerMessageId, out var row))\n                        {\n                            // ‚úÖ Critical rule: if not found within THIS business ‚Üí skip\n                            _logger.LogWarning(\n                                \"Status update skipped (no business-scoped match). businessId={BusinessId}, providerMessageId={ProviderMessageId}, status={Status}\",\n                                businessId,\n                                providerMessageId,\n                                statusText\n                            );\n                            continue;\n                        }\n\n                        var norm = NormalizeStatus(statusText);\n                        var tsUtc = ParseTimestampUtc(st);\n                        var err = TryExtractError(st);\n\n                        // ‚úÖ Industry-grade call: business-scoped updater (prevents cross-tenant updates)\n                        var ev = new StatusEvent\n                        {\n                            BusinessId = businessId,\n                            Provider = provider,\n                            ProviderMessageId = providerMessageId,\n                            State = norm switch\n                            {\n                                \"sent\" => MessageDeliveryState.Sent,\n                                \"delivered\" => MessageDeliveryState.Delivered,\n                                \"read\" => MessageDeliveryState.Read,\n                                \"failed\" => MessageDeliveryState.Failed,\n                                \"deleted\" => MessageDeliveryState.Deleted,\n                                _ => MessageDeliveryState.Sent // safe fallback; updater also guards downgrades\n                            },\n                            OccurredAt = new DateTimeOffset(tsUtc),\n                            ErrorMessage = err\n                        };\n\n                        await _updater.UpdateAsync(ev, ct);\n\n                        // SignalR: notify only the correct business group\n                        var groupName = $\"business_{businessId}\";\n                        await _hubContext.Clients.Group(groupName).SendAsync(\"MessageStatusChanged\", new\n                        {\n                            businessId,\n                            provider,\n                            providerMessageId = providerMessageId,\n                            messageId = row.canonicalMessageId, // canonical id we stored\n                            messageLogId = row.msgLogId,\n                            contactId = row.contactId,\n                            status = norm,\n                            occurredAtUtc = tsUtc,\n                            error = err\n                        }, ct);\n\n                        _logger.LogInformation(\n                            \"‚úÖ Status updated (business-scoped): businessId={BusinessId}, providerMessageId={ProviderMessageId}, status={Status}, ts={TsUtc}\",\n                            businessId, providerMessageId, norm, tsUtc\n                        );\n                    }\n                }\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Status/IMessageStatusUpdater.cs",
      "sha256": "1118d372b268de8bde2380896e85471cc6f2584def17426509a80c16fb81edf1",
      "language": "csharp",
      "size": 1629,
      "content": "// üìÑ File: Features/Webhooks/Status/IMessageStatusUpdater.cs\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Status\n{\n    public interface IMessageStatusUpdater\n    {\n        /// <summary>\n        /// ‚úÖ Only supported method (industry-grade):\n        /// Business-scoped status update to prevent cross-tenant collisions.\n        /// </summary>\n        Task<int> UpdateAsync(StatusEvent ev, CancellationToken ct = default);\n    }\n\n    public sealed class StatusEvent\n    {\n        public Guid BusinessId { get; init; }\n\n        /// <summary>Provider key: \"META_CLOUD\", \"meta_cloud\", \"pinnacle\", etc.</summary>\n        public string Provider { get; init; } = \"\";\n\n        /// <summary>\n        /// Provider message id (Meta: WAMID / \"id\").\n        /// We map this to MessageLog.ProviderMessageId (or MessageId fallback).\n        /// </summary>\n        public string ProviderMessageId { get; init; } = \"\";\n\n        /// <summary>\n        /// Optional: if you already know the CampaignSendLog row, pass it here for exact targeting.\n        /// </summary>\n        public Guid? CampaignSendLogId { get; init; }\n\n        public string? RecipientWaId { get; init; }\n\n        public MessageDeliveryState State { get; init; }\n        public DateTimeOffset OccurredAt { get; init; }\n\n        public string? ErrorCode { get; init; }\n        public string? ErrorMessage { get; init; }\n        public string? ConversationId { get; init; }\n    }\n\n    public enum MessageDeliveryState\n    {\n        Sent,\n        Delivered,\n        Read,\n        Failed,\n        Deleted\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Status/MessageStatusUpdater.cs",
      "sha256": "292d9f92db7d7efb114c244aa484519db2cb6605d3125634027bcd0fa5e79b5a",
      "language": "csharp",
      "size": 19978,
      "content": "// üìÑ File: Features/Webhooks/Status/MessageStatusUpdater.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\n\nusing xbytechat.api;\nusing xbytechat.api.Features.CRM.Models;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Infrastructure.Observability;\nusing xbytechat_api.Features.Billing.Services;\n\n\nnamespace xbytechat.api.Features.Webhooks.Status\n{\n    /// <summary>\n    /// ‚úÖ Business-scoped status pipeline updater:\n    /// - Updates MessageLogs by (BusinessId + ProviderMessageId/MessageId)\n    /// - Updates CampaignSendLogs ONLY when it can be targeted safely (by CampaignSendLogId OR BusinessId shadow-property)\n    /// - No legacy overloads (by design)\n    /// \n    /// Phase 5 (Feedback loop):\n    /// - On failed deliveries, classify errors and update Contact OptStatus/ChannelStatus\n    ///   so outbound consent guard blocks future sends deterministically.\n    /// </summary>\n    public sealed class MessageStatusUpdater : IMessageStatusUpdater\n    {\n        private readonly AppDbContext _db;\n        private readonly ILogger<MessageStatusUpdater> _log;\n        private readonly IBillingIngestService _billing;\n\n        public MessageStatusUpdater(\n            AppDbContext db,\n            ILogger<MessageStatusUpdater> log,\n            IBillingIngestService billing)\n        {\n            _db = db;\n            _log = log;\n            _billing = billing;\n        }\n\n        public async Task<int> UpdateAsync(StatusEvent ev, CancellationToken ct = default)\n        {\n            if (ev == null) return 0;\n\n            if (ev.BusinessId == Guid.Empty)\n            {\n                _log.LogWarning(\"[StatusUpdater] Skipped: BusinessId is empty.\");\n                return 0;\n            }\n\n            var providerMessageId = (ev.ProviderMessageId ?? string.Empty).Trim();\n            if (string.IsNullOrWhiteSpace(providerMessageId))\n            {\n                _log.LogWarning(\"[StatusUpdater] Skipped: ProviderMessageId is empty. businessId={BusinessId}\", ev.BusinessId);\n                return 0;\n            }\n\n            var normalized = StateToStatusString(ev.State); // sent/delivered/read/failed/deleted\n            var tsUtc = ev.OccurredAt.UtcDateTime;\n            var error = ev.ErrorMessage;\n            var errorCode = TryGetErrorCode(ev);\n\n            // Keep existing campaign + message log updates intact\n            var affectedCampaign = await TryUpdateCampaignSendLogsSafelyAsync(\n                businessId: ev.BusinessId,\n                campaignSendLogId: ev.CampaignSendLogId,\n                messageId: providerMessageId,\n                normalizedStatus: normalized,\n                tsUtc: tsUtc,\n                error: error,\n                ct: ct\n            );\n\n            var affectedMessages = await UpdateMessageLogsAsync(\n                businessId: ev.BusinessId,\n                messageId: providerMessageId,\n                normalizedStatus: normalized,\n                tsUtc: tsUtc,\n                error: error,\n                ct: ct\n            );\n\n            if (normalized == \"failed\")\n            {\n                // Compliance feedback loop: failed delivery signals may update contact health\n                // so future outbound sends are blocked by the centralized guard.\n                await TryUpdateContactHealthOnFailureAsync(\n                    businessId: ev.BusinessId,\n                    messageId: providerMessageId,\n                    errorCode: errorCode,\n                    errorMessage: error,\n                    ev: ev,\n                    ct: ct\n                );\n            }\n\n            if (affectedCampaign == 0 && affectedMessages == 0)\n            {\n                _log.LogWarning(\n                    \"[StatusUpdater] No rows updated. businessId={BusinessId}, messageId={MessageId}, status={Status}\",\n                    ev.BusinessId,\n                    providerMessageId,\n                    normalized\n                );\n            }\n            else\n            {\n                if (normalized == \"failed\") MetricsRegistry.MessagesFailed.Add(1);\n                else if (normalized == \"sent\") MetricsRegistry.MessagesSent.Add(1);\n            }\n\n            return affectedCampaign + affectedMessages;\n        }\n\n        private async Task<int> UpdateMessageLogsAsync(\n            Guid businessId,\n            string messageId,\n            string normalizedStatus,\n            DateTime tsUtc,\n            string? error,\n            CancellationToken ct)\n        {\n            // ‚úÖ STRICT business scope + ‚úÖ OUTGOING ONLY\n            var mlQuery = _db.MessageLogs\n                .Where(m => m.BusinessId == businessId && !m.IsIncoming)\n                .Where(m => m.ProviderMessageId == messageId || m.MessageId == messageId);\n\n            // Avoid downgrades:\n            // - delivered must not overwrite read\n            // - sent should only move from Queued/empty\n            // - failed should not overwrite delivered/read\n\n            if (normalizedStatus == \"delivered\")\n            {\n                return await mlQuery\n                    .Where(m => m.Status != \"Read\" && m.Status != \"read\")\n                    .ExecuteUpdateAsync(s => s\n                        .SetProperty(m => m.Status, \"Delivered\")\n                        .SetProperty(m => m.SentAt, m => m.SentAt ?? tsUtc), ct);\n            }\n\n            if (normalizedStatus == \"read\")\n            {\n                return await mlQuery.ExecuteUpdateAsync(s => s\n                    .SetProperty(m => m.Status, \"Read\")\n                    .SetProperty(m => m.SentAt, m => m.SentAt ?? tsUtc), ct);\n            }\n\n            if (normalizedStatus == \"failed\")\n            {\n                return await mlQuery\n                    .Where(m =>\n                        m.Status != \"Delivered\" && m.Status != \"delivered\" &&\n                        m.Status != \"Read\" && m.Status != \"read\")\n                    .ExecuteUpdateAsync(s => s\n                        .SetProperty(m => m.Status, \"Failed\")\n                        .SetProperty(m => m.ErrorMessage, error)\n                        .SetProperty(m => m.SentAt, m => m.SentAt ?? tsUtc), ct);\n            }\n\n            if (normalizedStatus == \"sent\")\n            {\n                return await mlQuery\n                    .Where(m =>\n                        m.Status == null ||\n                        m.Status == \"\" ||\n                        m.Status == \"Queued\" ||\n                        m.Status == \"queued\")\n                    .ExecuteUpdateAsync(s => s\n                        .SetProperty(m => m.Status, \"Sent\")\n                        .SetProperty(m => m.SentAt, m => m.SentAt ?? tsUtc), ct);\n            }\n\n            if (normalizedStatus == \"deleted\")\n            {\n                return await mlQuery.ExecuteUpdateAsync(s => s\n                    .SetProperty(m => m.Status, \"Deleted\")\n                    .SetProperty(m => m.ErrorMessage, error), ct);\n            }\n\n            return 0;\n        }\n\n        private async Task<int> TryUpdateCampaignSendLogsSafelyAsync(\n            Guid businessId,\n            Guid? campaignSendLogId,\n            string messageId,\n            string normalizedStatus,\n            DateTime tsUtc,\n            string? error,\n            CancellationToken ct)\n        {\n            try\n            {\n                var csl = _db.CampaignSendLogs.AsQueryable();\n\n                if (campaignSendLogId.HasValue && campaignSendLogId.Value != Guid.Empty)\n                {\n                    csl = csl.Where(x => x.Id == campaignSendLogId.Value);\n                }\n                else\n                {\n                    // ‚úÖ STRICT business scope using shadow property\n                    csl = csl.Where(x =>\n                        EF.Property<Guid>(x, \"BusinessId\") == businessId &&\n                        x.MessageId == messageId\n                    );\n                }\n\n                if (normalizedStatus == \"delivered\")\n                {\n                    return await csl.ExecuteUpdateAsync(s => s\n                        .SetProperty(x => x.ErrorMessage, error)\n                        .SetProperty(x => x.DeliveredAt, tsUtc)\n                        .SetProperty(x => x.SendStatus, \"Delivered\")\n                        .SetProperty(x => x.SentAt, x => x.SentAt ?? tsUtc), ct);\n                }\n\n                if (normalizedStatus == \"read\")\n                {\n                    return await csl.ExecuteUpdateAsync(s => s\n                        .SetProperty(x => x.ErrorMessage, error)\n                        .SetProperty(x => x.ReadAt, tsUtc)\n                        .SetProperty(x => x.SendStatus, \"Read\")\n                        .SetProperty(x => x.SentAt, x => x.SentAt ?? tsUtc)\n                        .SetProperty(x => x.DeliveredAt, x => x.DeliveredAt ?? tsUtc), ct);\n                }\n\n                if (normalizedStatus == \"failed\")\n                {\n                    return await csl.ExecuteUpdateAsync(s => s\n                        .SetProperty(x => x.ErrorMessage, error)\n                        .SetProperty(x => x.SendStatus, \"Failed\")\n                        .SetProperty(x => x.SentAt, x => x.SentAt ?? tsUtc), ct);\n                }\n\n                if (normalizedStatus == \"sent\")\n                {\n                    return await csl.ExecuteUpdateAsync(s => s\n                        .SetProperty(x => x.ErrorMessage, error)\n                        .SetProperty(x => x.SentAt, x => x.SentAt ?? tsUtc)\n                        .SetProperty(x => x.SendStatus, \"Sent\"), ct);\n                }\n\n                if (normalizedStatus == \"deleted\")\n                {\n                    return await csl.ExecuteUpdateAsync(s => s\n                        .SetProperty(x => x.ErrorMessage, error)\n                        .SetProperty(x => x.SendStatus, \"Deleted\"), ct);\n                }\n\n                return await csl.ExecuteUpdateAsync(s => s\n                    .SetProperty(x => x.ErrorMessage, error), ct);\n            }\n            catch (Exception ex)\n            {\n                _log.LogWarning(\n                    ex,\n                    \"[StatusUpdater] CampaignSendLogs update skipped to preserve tenant safety. businessId={BusinessId}, messageId={MessageId}\",\n                    businessId,\n                    messageId\n                );\n                return 0;\n            }\n        }\n\n        private static string StateToStatusString(MessageDeliveryState state) => state switch\n        {\n            MessageDeliveryState.Sent => \"sent\",\n            MessageDeliveryState.Delivered => \"delivered\",\n            MessageDeliveryState.Read => \"read\",\n            MessageDeliveryState.Failed => \"failed\",\n            MessageDeliveryState.Deleted => \"deleted\",\n            _ => \"unknown\"\n        };\n\n        // Conservative classifier: update contact state only on high-confidence failure signals.\n        private static (bool optedOut, bool invalidNumber, string? reason) ClassifyFailure(string? errorCode, string? errorMessage)\n        {\n            var code = (errorCode ?? string.Empty).Trim().ToUpperInvariant();\n            var msg = (errorMessage ?? string.Empty).Trim().ToUpperInvariant();\n\n            // Strong evidence: recipient blocked or explicit provider-side opt-out.\n            if (ContainsAny(msg,\n                    \"BLOCKED BY USER\", \"RECIPIENT BLOCKED\", \"USER BLOCKED\", \"HAS BLOCKED\", \"RECIPIENT_HAS_BLOCKED\",\n                    \"OPTED OUT\", \"UNSUBSCRIBE\", \"UNSUBSCRIBED\", \"USER REQUESTED TO STOP\") ||\n                ContainsAny(code, \"BLOCKED\", \"OPT_OUT\", \"UNSUBSCRIBE\"))\n            {\n                return (true, false, \"ProviderBlocked\");\n            }\n\n            // Strong evidence: number is invalid or not a WhatsApp account.\n            if (ContainsAny(msg,\n                    \"NOT A WHATSAPP USER\", \"DOES NOT EXIST\", \"INVALID PHONE\", \"INVALID NUMBER\",\n                    \"PHONE NUMBER IS NOT VALID\", \"NO WHATSAPP ACCOUNT\") ||\n                ContainsAny(code, \"INVALID_NUMBER\", \"NOT_WHATSAPP_USER\", \"NUMBER_DOES_NOT_EXIST\"))\n            {\n                return (false, true, null);\n            }\n\n            return (false, false, null);\n        }\n\n        private async Task TryUpdateContactHealthOnFailureAsync(\n            Guid businessId,\n            string messageId,\n            string? errorCode,\n            string? errorMessage,\n            StatusEvent ev,\n            CancellationToken ct)\n        {\n            var classification = ClassifyFailure(errorCode, errorMessage);\n            if (!classification.optedOut && !classification.invalidNumber) return;\n\n            try\n            {\n                // Prefer MessageLog context first (contact id + recipient are already in this updater's data path).\n                var messageContext = await _db.MessageLogs\n                    .AsNoTracking()\n                    .Where(m => m.BusinessId == businessId && !m.IsIncoming)\n                    .Where(m => m.ProviderMessageId == messageId || m.MessageId == messageId)\n                    .Select(m => new { m.ContactId, m.RecipientNumber })\n                    .FirstOrDefaultAsync(ct);\n\n                Guid? contactId = messageContext?.ContactId;\n                string? recipientPhone = messageContext?.RecipientNumber;\n\n                // Fallback recipient extraction from StatusEvent only if needed.\n                recipientPhone ??= TryGetEventRecipient(ev);\n                var lookupCandidates = BuildPhoneLookupCandidates(recipientPhone);\n\n                Contact? contact = null;\n\n                if (contactId.HasValue && contactId.Value != Guid.Empty)\n                {\n                    contact = await _db.Contacts.FirstOrDefaultAsync(\n                        c => c.BusinessId == businessId && c.Id == contactId.Value,\n                        ct);\n                }\n\n                if (contact == null && lookupCandidates.Count > 0)\n                {\n                    contact = await _db.Contacts.FirstOrDefaultAsync(\n                        c => c.BusinessId == businessId && lookupCandidates.Contains(c.PhoneNumber),\n                        ct);\n                }\n\n                if (contact == null)\n                {\n                    _log.LogWarning(\n                        \"[StatusUpdater] Failure classified but contact not found. businessId={BusinessId}, messageId={MessageId}\",\n                        businessId,\n                        messageId);\n                    return;\n                }\n\n                var nowUtc = DateTime.UtcNow;\n                var changed = false;\n\n                // Idempotency guard: update timestamps only when state actually changes.\n                if (classification.invalidNumber && contact.ChannelStatus != ContactChannelStatus.InvalidNumber)\n                {\n                    contact.ChannelStatus = ContactChannelStatus.InvalidNumber;\n                    contact.ChannelStatusUpdatedAt = nowUtc;\n                    changed = true;\n                }\n\n                // Only set opted-out on explicit high-confidence opt-out signals.\n                if (classification.optedOut && contact.OptStatus != ContactOptStatus.OptedOut)\n                {\n                    contact.OptStatus = ContactOptStatus.OptedOut;\n                    contact.OptStatusUpdatedAt = nowUtc;\n                    contact.OptOutReason = \"ProviderBlocked\";\n                    changed = true;\n                }\n\n                if (!changed) return;\n\n                await _db.SaveChangesAsync(ct);\n\n                _log.LogInformation(\n                    \"[StatusUpdater] Contact health updated from failed status. businessId={BusinessId}, contactId={ContactId}, phone={Phone}, opt={OptStatus}, channel={ChannelStatus}\",\n                    businessId,\n                    contact.Id,\n                    contact.PhoneNumber,\n                    contact.OptStatus,\n                    contact.ChannelStatus);\n            }\n            catch (Exception ex)\n            {\n                _log.LogWarning(\n                    ex,\n                    \"[StatusUpdater] Contact health update skipped after failed status. businessId={BusinessId}, messageId={MessageId}\",\n                    businessId,\n                    messageId);\n            }\n        }\n\n        private static bool ContainsAny(string source, params string[] patterns)\n        {\n            if (string.IsNullOrWhiteSpace(source)) return false;\n            return patterns.Any(p => source.Contains(p, StringComparison.OrdinalIgnoreCase));\n        }\n\n        private static string NormalizeDigitsOnly(string? value)\n            => new string((value ?? string.Empty).Where(char.IsDigit).ToArray());\n\n        private static string NormalizePhoneForLookup(string? value)\n        {\n            var raw = (value ?? string.Empty).Trim();\n            if (string.IsNullOrWhiteSpace(raw)) return string.Empty;\n\n            var normalized = PhoneNumberNormalizer.NormalizeToE164Digits(raw, \"IN\");\n            if (!string.IsNullOrWhiteSpace(normalized))\n                return normalized;\n\n            var digits = NormalizeDigitsOnly(raw);\n            if (string.IsNullOrWhiteSpace(digits))\n                return string.Empty;\n\n            normalized = PhoneNumberNormalizer.NormalizeToE164Digits(\"+\" + digits, \"IN\");\n            if (!string.IsNullOrWhiteSpace(normalized))\n                return normalized;\n\n            return digits;\n        }\n\n        private static List<string> BuildPhoneLookupCandidates(string? value)\n        {\n            var raw = (value ?? string.Empty).Trim();\n            var candidates = new HashSet<string>(StringComparer.Ordinal);\n            var normalized = NormalizePhoneForLookup(raw);\n            var digits = NormalizeDigitsOnly(raw);\n\n            if (!string.IsNullOrWhiteSpace(normalized))\n            {\n                candidates.Add(normalized);\n                candidates.Add(\"+\" + normalized);\n\n                if (normalized.Length == 12 && normalized.StartsWith(\"91\", StringComparison.Ordinal))\n                    candidates.Add(normalized.Substring(2));\n            }\n\n            if (!string.IsNullOrWhiteSpace(digits))\n            {\n                candidates.Add(digits);\n                candidates.Add(\"+\" + digits);\n\n                if (digits.Length == 10)\n                {\n                    candidates.Add(\"91\" + digits);\n                    candidates.Add(\"+91\" + digits);\n                }\n                else if (digits.Length == 12 && digits.StartsWith(\"91\", StringComparison.Ordinal))\n                {\n                    candidates.Add(digits.Substring(2));\n                }\n            }\n\n            if (!string.IsNullOrWhiteSpace(raw))\n                candidates.Add(raw);\n\n            return candidates.Where(x => !string.IsNullOrWhiteSpace(x)).ToList();\n        }\n\n        private static string? TryGetErrorCode(StatusEvent ev)\n        {\n            // Keep this reflection-based to avoid coupling to provider-specific event shapes.\n            var type = ev.GetType();\n            var value =\n                type.GetProperty(\"ErrorCode\")?.GetValue(ev)?.ToString() ??\n                type.GetProperty(\"ProviderErrorCode\")?.GetValue(ev)?.ToString() ??\n                type.GetProperty(\"Code\")?.GetValue(ev)?.ToString();\n\n            return string.IsNullOrWhiteSpace(value) ? null : value.Trim();\n        }\n\n        private static string? TryGetEventRecipient(StatusEvent ev)\n        {\n            // Use only if message/campaign linkage cannot provide recipient resolution.\n            var type = ev.GetType();\n            var value =\n                type.GetProperty(\"RecipientNumber\")?.GetValue(ev)?.ToString() ??\n                type.GetProperty(\"To\")?.GetValue(ev)?.ToString() ??\n                type.GetProperty(\"PhoneNumber\")?.GetValue(ev)?.ToString();\n\n            return string.IsNullOrWhiteSpace(value) ? null : value.Trim();\n        }\n    }\n}\n"
    }
  ]
}
