{
  "name": "xbytechat-api/Features/CustomFields",
  "generatedAt": "2026-02-11 19:15:17 +00:00",
  "files": [
    {
      "path": "xbytechat-api/Features/CustomFields/Controllers/CustomFieldsController.cs",
      "sha256": "ecf01929abd50cfb7140cfea5df6189af25ebc85d7cef8081b4cdbb33023abb5",
      "language": "csharp",
      "size": 6451,
      "content": "using System;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.AccessControl.PermissionAttributes;\nusing xbytechat.api.Features.AccessControl.Seeder;\nusing xbytechat.api.Features.CustomFields.Dtos;\nusing xbytechat.api.Features.CustomFields.Services;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.CustomFields.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize]\n    public sealed class CustomFieldsController : ControllerBase\n    {\n        private readonly ICustomFieldsService _service;\n\n        public CustomFieldsController(ICustomFieldsService service)\n        {\n            _service = service;\n        }\n\n        private Guid GetBusinessIdOrReject(out IActionResult? errorResult)\n        {\n            errorResult = null;\n\n            var businessId = HttpContext.User.GetBusinessId();\n            if (businessId == Guid.Empty)\n            {\n                errorResult = Unauthorized(ResponseResult.ErrorInfo(\"Missing BusinessId in user claims.\"));\n                return Guid.Empty;\n            }\n\n            return businessId;\n        }\n\n        // --------------------------------------------------------------------\n        // Definitions (READ = allow any authenticated user in the business)\n        // --------------------------------------------------------------------\n\n        /// <summary>\n        /// READ schema for the given entityType (e.g. CONTACT).\n        /// ✅ MVP: Allow any authenticated user (business-scoped). This matches the current CRM module behavior.\n        /// Later you can add a dedicated permission like: customfields.view\n        /// </summary>\n        [HttpGet(\"definitions\")]\n        public async Task<IActionResult> GetDefinitions(\n            [FromQuery] string entityType = \"CONTACT\",\n            [FromQuery] bool includeInactive = false)\n        {\n            var bizId = GetBusinessIdOrReject(out var err);\n            if (err != null) return err;\n\n            var rows = await _service.GetDefinitionsAsync(bizId, entityType, includeInactive);\n            return Ok(ResponseResult.SuccessInfo(\"✅ Custom field definitions fetched.\", rows));\n        }\n\n        /// <summary>\n        /// Managing schema is an \"admin-ish\" action.\n        /// Reusing TagsEdit for now as the closest existing CRM admin permission.\n        /// (Later: introduce customfields.manage / customfields.edit)\n        /// </summary>\n        [HttpPost(\"definitions\")]\n        \n        public async Task<IActionResult> CreateDefinition([FromBody] CreateCustomFieldDefinitionDto dto)\n        {\n            var bizId = GetBusinessIdOrReject(out var err);\n            if (err != null) return err;\n\n            var created = await _service.CreateDefinitionAsync(bizId, dto);\n            return Ok(ResponseResult.SuccessInfo(\"✅ Custom field definition created.\", created));\n        }\n\n        [HttpPut(\"definitions/{fieldId:guid}\")]\n        \n        public async Task<IActionResult> UpdateDefinition([FromRoute] Guid fieldId, [FromBody] UpdateCustomFieldDefinitionDto dto)\n        {\n            var bizId = GetBusinessIdOrReject(out var err);\n            if (err != null) return err;\n\n            var updated = await _service.UpdateDefinitionAsync(bizId, fieldId, dto);\n            return Ok(ResponseResult.SuccessInfo(\"✅ Custom field definition updated.\", updated));\n        }\n\n        [HttpDelete(\"definitions/{fieldId:guid}\")]\n       \n        public async Task<IActionResult> DeactivateDefinition([FromRoute] Guid fieldId)\n        {\n            var bizId = GetBusinessIdOrReject(out var err);\n            if (err != null) return err;\n\n            var ok = await _service.DeactivateDefinitionAsync(bizId, fieldId);\n            return Ok(ResponseResult.SuccessInfo(ok ? \"✅ Field deactivated.\" : \"ℹ️ Field not found.\", ok));\n        }\n\n        // --------------------------------------------------------------------\n        // Values (READ = allow any authenticated user in the business)\n        // --------------------------------------------------------------------\n\n        /// <summary>\n        /// ✅ MVP: Allow reading values for any authenticated user (business-scoped).\n        /// Later you can gate with a dedicated permission like: customfields.values.view\n        /// </summary>\n        [HttpGet(\"values\")]\n        public async Task<IActionResult> GetValues([FromQuery] string entityType, [FromQuery] Guid entityId)\n        {\n            var bizId = GetBusinessIdOrReject(out var err);\n            if (err != null) return err;\n\n            if (entityId == Guid.Empty)\n                return BadRequest(ResponseResult.ErrorInfo(\"EntityId is required.\"));\n\n            var rows = await _service.GetValuesAsync(bizId, entityType, entityId);\n            return Ok(ResponseResult.SuccessInfo(\"✅ Custom field values fetched.\", rows));\n        }\n\n        /// <summary>\n        /// Upserting values changes CRM data. Keep it strict for MVP.\n        /// Reusing TagsEdit for now as \"CRM admin/edit\" gate.\n        /// </summary>\n        [HttpPut(\"values\")]\n      \n        public async Task<IActionResult> UpsertValues([FromBody] UpsertCustomFieldValuesDto dto)\n        {\n            var bizId = GetBusinessIdOrReject(out var err);\n            if (err != null) return err;\n\n            await _service.UpsertValuesAsync(bizId, dto);\n            return Ok(ResponseResult.SuccessInfo(\"✅ Custom field values saved.\", true));\n        }\n\n        /// <summary>\n        /// Convenience endpoint for UI: fetch active definitions + current values.\n        /// ✅ MVP: Allow any authenticated user (business-scoped) so the page can load.\n        /// </summary>\n        [HttpGet(\"schema-with-values\")]\n        public async Task<IActionResult> GetSchemaWithValues([FromQuery] string entityType, [FromQuery] Guid entityId)\n        {\n            var bizId = GetBusinessIdOrReject(out var err);\n            if (err != null) return err;\n\n            if (entityId == Guid.Empty)\n                return BadRequest(ResponseResult.ErrorInfo(\"EntityId is required.\"));\n\n            var data = await _service.GetSchemaWithValuesAsync(bizId, entityType, entityId);\n\n            return Ok(ResponseResult.SuccessInfo(\"✅ Schema + values fetched.\", new\n            {\n                definitions = data.Definitions,\n                values = data.Values\n            }));\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomFields/Dtos/CreateCustomFieldDefinitionDto.cs",
      "sha256": "5c8d8fbec4a4956c22be7fbd07d8f9db34147173a9fdaa5df90ac021ab2be2ba",
      "language": "csharp",
      "size": 1119,
      "content": "using System.Text.Json;\n\nnamespace xbytechat.api.Features.CustomFields.Dtos\n{\n    /// <summary>\n    /// Request DTO to create a custom field definition.\n    /// </summary>\n    public sealed class CreateCustomFieldDefinitionDto\n    {\n        public string EntityType { get; set; } = \"Contact\";\n\n        /// <summary>\n        /// Stable internal key (snake_case recommended).\n        /// </summary>\n        public string Key { get; set; } = string.Empty;\n\n        /// <summary>\n        /// UI label.\n        /// </summary>\n        public string Label { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Data type as string:\n        /// \"Text\", \"Number\", \"Date\", \"Boolean\", \"SingleSelect\", \"MultiSelect\"\n        /// </summary>\n        public string DataType { get; set; } = \"Text\";\n\n        /// <summary>\n        /// For select types: options and any future metadata.\n        /// Example: {\"options\":[\"Retail\",\"Wholesale\"]}\n        /// </summary>\n        public JsonElement? Options { get; set; }\n\n        public bool IsRequired { get; set; } = false;\n\n        public int SortOrder { get; set; } = 0;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomFields/Dtos/CustomFieldDefinitionDto.cs",
      "sha256": "900fcaef78d5af086eeb456dce5c60463f20c8ae8623ba97d7426459f9b9111d",
      "language": "csharp",
      "size": 1322,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CustomFields.Dtos\n{\n    /// <summary>\n    /// Response DTO for a Custom Field Definition (schema).\n    /// </summary>\n    public sealed class CustomFieldDefinitionDto\n    {\n        public Guid Id { get; set; }\n\n        public string EntityType { get; set; } = \"Contact\";\n\n        /// <summary>\n        /// Stable internal key (snake_case recommended).\n        /// Example: gst_number\n        /// </summary>\n        public string Key { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Human label shown in UI.\n        /// Example: \"GST Number\"\n        /// </summary>\n        public string Label { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Data type as string to avoid enum-serialization surprises across clients.\n        /// Example: \"Text\", \"Number\", \"Date\", \"Boolean\", \"SingleSelect\", \"MultiSelect\"\n        /// </summary>\n        public string DataType { get; set; } = \"Text\";\n\n        /// <summary>\n        /// Options metadata stored as JSON (for select types).\n        /// Example: {\"options\":[\"A\",\"B\",\"C\"]}\n        /// </summary>\n        public string? OptionsJson { get; set; }\n\n        public bool IsRequired { get; set; }\n\n        public bool IsActive { get; set; } = true;\n\n        public int SortOrder { get; set; } = 0;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomFields/Dtos/CustomFieldValueDto.cs",
      "sha256": "bdec3fe529d4fa6e940e5e065fcd5c69913cde775c085ec0a13d70ce39009cf0",
      "language": "csharp",
      "size": 496,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CustomFields.Dtos\n{\n    /// <summary>\n    /// Represents a stored value for a field for a specific entity record.\n    /// Returned to the UI as raw JSON (ValueJson).\n    /// </summary>\n    public sealed class CustomFieldValueDto\n    {\n        public Guid FieldId { get; set; }\n\n        /// <summary>\n        /// Stored jsonb payload (we store as {\"value\": ...}).\n        /// </summary>\n        public string ValueJson { get; set; } = \"{}\";\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomFields/Dtos/UpdateCustomFieldDefinitionDto.cs",
      "sha256": "c9ce1b7b1191fb5ff90d5864a744ede5b399aa8e956a107abf8777de98f15694",
      "language": "csharp",
      "size": 793,
      "content": "using System.Text.Json;\n\nnamespace xbytechat.api.Features.CustomFields.Dtos\n{\n    /// <summary>\n    /// Request DTO to update a custom field definition.\n    /// We keep it flexible; service decides what fields are allowed to change.\n    /// </summary>\n    public sealed class UpdateCustomFieldDefinitionDto\n    {\n\n        public string? Label { get; set; }\n        /// <summary>\n        /// Optional: allow changing datatype later if you want,\n        /// but by default we typically keep datatype immutable.\n        /// </summary>\n        public string? DataType { get; set; }\n\n        public JsonElement? Options { get; set; }\n\n        public bool IsRequired { get; set; } = false;\n\n        public bool IsActive { get; set; } = true;\n\n        public int SortOrder { get; set; } = 0;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomFields/Dtos/UpsertCustomFieldValuesDto.cs",
      "sha256": "244c2783ce9d142c608569b620b83fe2d8470941dc4f76f116d5145398fefe4d",
      "language": "csharp",
      "size": 1019,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Text.Json;\n\nnamespace xbytechat.api.Features.CustomFields.Dtos\n{\n    /// <summary>\n    /// Bulk upsert values for one record (e.g., one Contact).\n    /// </summary>\n    public sealed class UpsertCustomFieldValuesDto\n    {\n        public string EntityType { get; set; } = \"CONTACT\";\n\n        /// <summary>\n        /// Record id (e.g., ContactId).\n        /// </summary>\n        public Guid EntityId { get; set; }\n\n        /// <summary>\n        /// Values to upsert.\n        /// Service will wrap each into {\"value\": <this>} for storage.\n        /// </summary>\n        public List<UpsertCustomFieldValueItemDto> Values { get; set; } = new();\n    }\n\n    public sealed class UpsertCustomFieldValueItemDto\n    {\n        public Guid FieldId { get; set; }\n\n        /// <summary>\n        /// Typed value as JSON.\n        /// Examples: \"abc\", 123, true, \"2025-12-14T00:00:00Z\", [\"A\",\"B\"]\n        /// </summary>\n        public JsonElement? Value { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomFields/Models/CustomFieldDataType.cs",
      "sha256": "c34fd6245abd51bdeb61eb68ccc716e4dac10e038ae2caac971a7119712a1765",
      "language": "csharp",
      "size": 397,
      "content": "namespace xbytechat.api.Features.CustomFields.Models\n{\n    /// <summary>\n    /// Supported field data types for Custom Fields.\n    /// Stored as string in DB for readability and forward compatibility.\n    /// </summary>\n    public enum CustomFieldDataType\n    {\n        Text = 1,\n        Number = 2,\n        Date = 3,\n        Boolean = 4,\n        SingleSelect = 5,\n        MultiSelect = 6\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomFields/Models/CustomFieldDefinition.cs",
      "sha256": "c77155600842690a22f247b27ed7e8abc865ace70e10d1dd55d5f5f6d09fb9be",
      "language": "csharp",
      "size": 1889,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CustomFields.Models\n{\n    /// <summary>\n    /// Defines a custom field (schema) for a Business and an EntityType (e.g., Contact).\n    /// Example:\n    ///  - EntityType = \"Contact\"\n    ///  - Key = \"gst_number\"\n    ///  - Label = \"GST Number\"\n    ///  - DataType = Text\n    /// </summary>\n    public sealed class CustomFieldDefinition\n    {\n        public Guid Id { get; set; }\n\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// Target entity type. Keep it flexible as string so we can reuse this module later:\n        /// \"Contact\", \"Conversation\", \"MessageLog\", etc.\n        /// </summary>\n        public string EntityType { get; set; } = \"Contact\";\n\n        /// <summary>\n        /// Stable key used internally (snake_case recommended).\n        /// Example: gst_number, preferred_language\n        /// </summary>\n        public string Key { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Human-friendly label shown in UI.\n        /// Example: \"GST Number\"\n        /// </summary>\n        public string Label { get; set; } = string.Empty;\n\n        public CustomFieldDataType DataType { get; set; } = CustomFieldDataType.Text;\n\n        /// <summary>\n        /// For select types: store options, UI metadata, validation rules etc.\n        /// Stored as jsonb.\n        /// Example: {\"options\":[\"A\",\"B\",\"C\"]}\n        /// </summary>\n        public string? OptionsJson { get; set; }\n\n        public bool IsRequired { get; set; } = false;\n\n        public bool IsActive { get; set; } = true;\n\n        public int SortOrder { get; set; } = 0;\n\n        public DateTime CreatedAtUtc { get; set; } = DateTime.UtcNow;\n\n        /// <summary>\n        /// Updated automatically by your UpdatedAtUtcInterceptor.\n        /// </summary>\n        public DateTime UpdatedAtUtc { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomFields/Models/CustomFieldValue.cs",
      "sha256": "b426921280a31a2ae1fa61ba8114eaa6060b51724f4c794ba261a46e00d06fa7",
      "language": "csharp",
      "size": 1590,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CustomFields.Models\n{\n    /// <summary>\n    /// Stores a field value for a specific entity record.\n    /// Example:\n    ///  - EntityType = \"Contact\"\n    ///  - EntityId = Contact.Id\n    ///  - FieldId = CustomFieldDefinition.Id\n    ///  - ValueJson = {\"value\":\"27ABCDE1234F1Z5\"} or {\"value\":true} etc.\n    /// </summary>\n    public sealed class CustomFieldValue\n    {\n        public Guid Id { get; set; }\n\n        public Guid BusinessId { get; set; }\n\n        public string EntityType { get; set; } = \"Contact\";\n\n        /// <summary>\n        /// The record id (e.g., ContactId) this value belongs to.\n        /// </summary>\n        public Guid EntityId { get; set; }\n\n        public Guid FieldId { get; set; }\n\n        /// <summary>\n        /// JSON payload holding the typed value.\n        /// For simplicity we always store jsonb. UI/service enforces shape.\n        /// Example:\n        ///  {\"value\":\"text\"}\n        ///  {\"value\":123}\n        ///  {\"value\":true}\n        ///  {\"value\":\"2025-12-14T00:00:00Z\"}\n        ///  {\"value\":[\"A\",\"B\"]}\n        /// </summary>\n        public string ValueJson { get; set; } = \"{}\";\n\n        public bool IsActive { get; set; } = true;\n\n        public DateTime CreatedAtUtc { get; set; } = DateTime.UtcNow;\n\n        /// <summary>\n        /// Updated automatically by your UpdatedAtUtcInterceptor.\n        /// </summary>\n        public DateTime UpdatedAtUtc { get; set; } = DateTime.UtcNow;\n\n        // Navigation (optional but helpful)\n        public CustomFieldDefinition? Field { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomFields/Services/CustomFieldsService.cs",
      "sha256": "a737e85a6564984ca45fab12ff85378dfe5d642e8523f851c20e21be7f75cf1e",
      "language": "csharp",
      "size": 11843,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.Json;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.CustomFields.Dtos;\nusing xbytechat.api.Features.CustomFields.Models;\n\nnamespace xbytechat.api.Features.CustomFields.Services\n{\n    public sealed class CustomFieldsService : ICustomFieldsService\n    {\n        private readonly AppDbContext _db;\n\n        // key: snake_case recommended, enforce stable internal keys\n        private static readonly Regex KeyRegex = new(\"^[a-z][a-z0-9_]{0,119}$\", RegexOptions.Compiled);\n\n        public CustomFieldsService(AppDbContext db)\n        {\n            _db = db;\n        }\n\n        public async Task<List<CustomFieldDefinitionDto>> GetDefinitionsAsync(Guid businessId, string entityType, bool includeInactive)\n        {\n            var et = NormalizeEntityType(entityType);\n\n            var q = _db.CustomFieldDefinitions\n                .AsNoTracking()\n                .Where(x => x.BusinessId == businessId && x.EntityType == et);\n\n            if (!includeInactive)\n                q = q.Where(x => x.IsActive);\n\n            var rows = await q.OrderBy(x => x.SortOrder).ThenBy(x => x.Label).ToListAsync();\n\n            return rows.Select(MapDefinition).ToList();\n        }\n\n        public async Task<CustomFieldDefinitionDto> CreateDefinitionAsync(Guid businessId, CreateCustomFieldDefinitionDto dto)\n        {\n            var et = NormalizeEntityType(dto.EntityType);\n            var key = NormalizeKey(dto.Key);\n\n            ValidateDefinitionInputs(key, dto.Label);\n\n            // DB unique index exists, but we still do a friendly pre-check for better error messages.\n            var exists = await _db.CustomFieldDefinitions\n                .AnyAsync(x => x.BusinessId == businessId && x.EntityType == et && x.Key == key);\n\n            if (exists)\n                throw new InvalidOperationException($\"Custom field key '{key}' already exists for entity '{et}'.\");\n\n            var entity = new CustomFieldDefinition\n            {\n                Id = Guid.NewGuid(),\n                BusinessId = businessId,\n                EntityType = et,\n                Key = key,\n                Label = dto.Label.Trim(),\n                DataType = ParseDataType(dto.DataType),\n                OptionsJson = NormalizeOptions(dto.Options),\n                IsRequired = dto.IsRequired,\n                IsActive = true,\n                SortOrder = dto.SortOrder\n            };\n\n            _db.CustomFieldDefinitions.Add(entity);\n            await _db.SaveChangesAsync();\n\n            return MapDefinition(entity);\n        }\n\n        public async Task<CustomFieldDefinitionDto> UpdateDefinitionAsync(Guid businessId, Guid fieldId, UpdateCustomFieldDefinitionDto dto)\n        {\n            var entity = await _db.CustomFieldDefinitions\n                .FirstOrDefaultAsync(x => x.Id == fieldId && x.BusinessId == businessId);\n\n            if (entity == null)\n                throw new KeyNotFoundException(\"Custom field definition not found.\");\n\n            // Do NOT allow changing EntityType/Key in MVP (prevents breaking existing data + joins).\n            if (!string.IsNullOrWhiteSpace(dto.Label))\n                entity.Label = dto.Label.Trim();\n\n            if (!string.IsNullOrWhiteSpace(dto.DataType))\n                entity.DataType = ParseDataType(dto.DataType);\n\n            if (dto.Options != null)\n                entity.OptionsJson = NormalizeOptions(dto.Options);\n\n            entity.IsRequired = dto.IsRequired;\n            entity.IsActive = dto.IsActive;\n            entity.SortOrder = dto.SortOrder;\n\n            await _db.SaveChangesAsync();\n            return MapDefinition(entity);\n        }\n\n        public async Task<bool> DeactivateDefinitionAsync(Guid businessId, Guid fieldId)\n        {\n            var entity = await _db.CustomFieldDefinitions\n                .FirstOrDefaultAsync(x => x.Id == fieldId && x.BusinessId == businessId);\n\n            if (entity == null) return false;\n\n            entity.IsActive = false;\n            await _db.SaveChangesAsync();\n            return true;\n        }\n\n        public async Task<List<CustomFieldValueDto>> GetValuesAsync(Guid businessId, string entityType, Guid entityId)\n        {\n            var et = NormalizeEntityType(entityType);\n\n            var rows = await _db.CustomFieldValues\n                .AsNoTracking()\n                .Where(x => x.BusinessId == businessId && x.EntityType == et && x.EntityId == entityId)\n                .ToListAsync();\n\n            return rows.Select(x => new CustomFieldValueDto\n            {\n                FieldId = x.FieldId,\n                ValueJson = x.ValueJson ?? \"{}\"\n            }).ToList();\n        }\n\n        public async Task UpsertValuesAsync(Guid businessId, UpsertCustomFieldValuesDto dto)\n        {\n            var et = NormalizeEntityType(dto.EntityType);\n\n            if (dto.EntityId == Guid.Empty)\n                throw new ArgumentException(\"EntityId is required.\");\n\n            if (dto.Values == null || dto.Values.Count == 0)\n                return;\n\n            // Load definitions once, validate field ownership + types\n            var fieldIds = dto.Values.Select(v => v.FieldId).Distinct().ToList();\n\n            var defs = await _db.CustomFieldDefinitions\n                .AsNoTracking()\n                .Where(x => x.BusinessId == businessId && x.EntityType == et && fieldIds.Contains(x.Id) && x.IsActive)\n                .ToListAsync();\n\n            if (defs.Count != fieldIds.Count)\n                throw new InvalidOperationException(\"One or more fields are invalid/inactive for this business/entity.\");\n\n            var defMap = defs.ToDictionary(x => x.Id, x => x);\n\n            // Fetch existing values for this entity+fields\n            var existing = await _db.CustomFieldValues\n                .Where(x => x.BusinessId == businessId && x.EntityType == et && x.EntityId == dto.EntityId && fieldIds.Contains(x.FieldId))\n                .ToListAsync();\n\n            var existingMap = existing.ToDictionary(x => x.FieldId, x => x);\n\n            foreach (var item in dto.Values)\n            {\n                if (item.FieldId == Guid.Empty)\n                    throw new ArgumentException(\"FieldId is required.\");\n\n                var def = defMap[item.FieldId];\n                var wrapped = WrapAndValidateValue(def, item.Value);\n\n                if (existingMap.TryGetValue(item.FieldId, out var row))\n                {\n                    row.ValueJson = wrapped;\n                }\n                else\n                {\n                    _db.CustomFieldValues.Add(new CustomFieldValue\n                    {\n                        Id = Guid.NewGuid(),\n                        BusinessId = businessId,\n                        EntityType = et,\n                        EntityId = dto.EntityId,\n                        FieldId = item.FieldId,\n                        ValueJson = wrapped\n                    });\n                }\n            }\n\n            await _db.SaveChangesAsync();\n        }\n\n        public async Task<(List<CustomFieldDefinitionDto> Definitions, List<CustomFieldValueDto> Values)> GetSchemaWithValuesAsync(\n            Guid businessId, string entityType, Guid entityId)\n        {\n            var defs = await GetDefinitionsAsync(businessId, entityType, includeInactive: false);\n            var vals = await GetValuesAsync(businessId, entityType, entityId);\n            return (defs, vals);\n        }\n\n        // ---------------- helpers ----------------\n\n        private static string NormalizeEntityType(string entityType)\n        {\n            var et = (entityType ?? \"\").Trim();\n            if (string.IsNullOrWhiteSpace(et)) et = \"CONTACT\";\n            return et.ToUpperInvariant(); // canonical storage + comparisons\n        }\n\n        private static string NormalizeKey(string key)\n        {\n            var k = (key ?? \"\").Trim().ToLowerInvariant();\n            if (!KeyRegex.IsMatch(k))\n                throw new ArgumentException(\"Key must be snake_case (a-z, 0-9, underscore), max 120 chars.\");\n            return k;\n        }\n\n        private static void ValidateDefinitionInputs(string key, string label)\n        {\n            if (string.IsNullOrWhiteSpace(label))\n                throw new ArgumentException(\"Label is required.\");\n\n            if (label.Trim().Length > 200)\n                throw new ArgumentException(\"Label too long (max 200).\");\n\n            // key already validated by regex\n        }\n\n        private static CustomFieldDataType ParseDataType(string? dataType)\n        {\n            var raw = (dataType ?? \"Text\").Trim();\n\n            if (Enum.TryParse<CustomFieldDataType>(raw, ignoreCase: true, out var dt))\n                return dt;\n\n            throw new ArgumentException($\"Invalid DataType '{raw}'.\");\n        }\n\n        private static string? NormalizeOptions(JsonElement? options)\n        {\n            if (options == null) return null;\n\n            var kind = options.Value.ValueKind;\n            if (kind is JsonValueKind.Null or JsonValueKind.Undefined)\n                return null;\n\n            // (Recommended) options should be object/array, not a primitive\n            if (kind is not (JsonValueKind.Object or JsonValueKind.Array))\n                throw new ArgumentException(\"Options must be a JSON object or array.\");\n\n            // JsonElement is already validated JSON. Store normalized JSON text.\n            return options.Value.GetRawText();\n        }\n\n        private static string WrapAndValidateValue(CustomFieldDefinition def, JsonElement? value)\n        {\n            // Required check\n            if (def.IsRequired && (value == null || value.Value.ValueKind == JsonValueKind.Null))\n                throw new ArgumentException($\"Field '{def.Label}' is required.\");\n\n            // Minimal type checks (MVP). You can extend later.\n            if (value != null && value.Value.ValueKind != JsonValueKind.Null)\n            {\n                switch (def.DataType)\n                {\n                    case CustomFieldDataType.Number:\n                        if (value.Value.ValueKind != JsonValueKind.Number)\n                            throw new ArgumentException($\"Field '{def.Label}' must be a number.\");\n                        break;\n\n                    case CustomFieldDataType.Boolean:\n                        if (value.Value.ValueKind is not (JsonValueKind.True or JsonValueKind.False))\n                            throw new ArgumentException($\"Field '{def.Label}' must be boolean.\");\n                        break;\n\n                    case CustomFieldDataType.MultiSelect:\n                        if (value.Value.ValueKind != JsonValueKind.Array)\n                            throw new ArgumentException($\"Field '{def.Label}' must be an array.\");\n                        break;\n\n                    default:\n                        // Text/Date/SingleSelect/etc -> keep permissive for MVP\n                        break;\n                }\n            }\n\n            // Wrap into {\"value\": ...}\n            var wrapped = JsonSerializer.Serialize(new Dictionary<string, object?>\n            {\n                [\"value\"] = value?.Deserialize<object?>()\n            });\n\n            return wrapped;\n        }\n\n        private static CustomFieldDefinitionDto MapDefinition(CustomFieldDefinition x)\n        {\n            return new CustomFieldDefinitionDto\n            {\n                Id = x.Id,\n                EntityType = x.EntityType,\n                Key = x.Key,\n                Label = x.Label,\n                DataType = x.DataType.ToString(),\n                OptionsJson = x.OptionsJson,\n                IsRequired = x.IsRequired,\n                IsActive = x.IsActive,\n                SortOrder = x.SortOrder\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomFields/Services/ICustomFieldsService.cs",
      "sha256": "ef65bd10b54038c7ddd79b8a0ffe8acb8d0dbf49ebac02f3f6270f6341771c22",
      "language": "csharp",
      "size": 1190,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CustomFields.Dtos;\n\nnamespace xbytechat.api.Features.CustomFields.Services\n{\n    public interface ICustomFieldsService\n    {\n        Task<List<CustomFieldDefinitionDto>> GetDefinitionsAsync(Guid businessId, string entityType, bool includeInactive);\n        Task<CustomFieldDefinitionDto> CreateDefinitionAsync(Guid businessId, CreateCustomFieldDefinitionDto dto);\n        Task<CustomFieldDefinitionDto> UpdateDefinitionAsync(Guid businessId, Guid fieldId, UpdateCustomFieldDefinitionDto dto);\n        Task<bool> DeactivateDefinitionAsync(Guid businessId, Guid fieldId);\n\n        Task<List<CustomFieldValueDto>> GetValuesAsync(Guid businessId, string entityType, Guid entityId);\n        Task UpsertValuesAsync(Guid businessId, UpsertCustomFieldValuesDto dto);\n\n        /// <summary>\n        /// Convenience endpoint for UI: returns schema + current values for a record.\n        /// </summary>\n        Task<(List<CustomFieldDefinitionDto> Definitions, List<CustomFieldValueDto> Values)> GetSchemaWithValuesAsync(\n            Guid businessId, string entityType, Guid entityId);\n    }\n}\n"
    }
  ]
}
