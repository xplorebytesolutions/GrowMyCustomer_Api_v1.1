{
  "name": "xbytechat-api/Features/Inbox",
  "generatedAt": "2026-02-11 19:15:17 +00:00",
  "files": [
    {
      "path": "xbytechat-api/Features/Inbox/Controllers/InboxController.cs",
      "sha256": "3d0e927289537b66319358696495d025ff3f9a5f6c17877f661a19cd1dec1f3e",
      "language": "csharp",
      "size": 9876,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Inbox.DTOs;\nusing xbytechat.api.Features.Inbox.Services;\nusing xbytechat.api.Helpers;\nusing Microsoft.AspNetCore.Authorization;\nusing xbytechat.api.Shared;\nusing Microsoft.AspNetCore.SignalR;\nusing xbytechat.api.Features.Inbox.Hubs;\n\nnamespace xbytechat.api.Features.Inbox.Controllers\n{\n    [ApiController]\n    [Route(\"api/inbox\")]\n    public class InboxController : ControllerBase\n    {\n        private readonly IInboxService _inboxService;\n        private readonly IHubContext<InboxHub> _hubContext; // ‚úÖ for SignalR push\n        private readonly IUnreadCountService _unreadCountService;\n\n        public InboxController(\n            IInboxService inboxService,\n            IHubContext<InboxHub> hubContext,\n            IUnreadCountService unreadCountService)\n        {\n            _inboxService = inboxService;\n            _hubContext = hubContext;\n            _unreadCountService = unreadCountService;\n        }\n\n        /// <summary>\n        /// Send a new message from UI or system.\n        /// </summary>\n        [HttpPost(\"send\")]\n        public async Task<IActionResult> SendMessage([FromBody] InboxMessageDto dto)\n        {\n            if (dto == null || string.IsNullOrWhiteSpace(dto.MessageBody))\n                return BadRequest(\"Message content is required.\");\n\n            var result = await _inboxService.SaveOutgoingMessageAsync(dto);\n            return Ok(result);\n        }\n\n        /// <summary>\n        /// Receive a message from external source (e.g., WhatsApp webhook).\n        /// </summary>\n        [HttpPost(\"receive\")]\n        public async Task<IActionResult> ReceiveMessage([FromBody] InboxMessageDto dto)\n        {\n            if (dto == null || string.IsNullOrWhiteSpace(dto.MessageBody))\n                return BadRequest(\"Incoming message content is required.\");\n\n            // ‚úÖ Ensure IDs are present\n            if (dto.BusinessId == Guid.Empty || dto.ContactId == Guid.Empty)\n                return BadRequest(\"BusinessId and ContactId are required.\");\n\n            // 1) Persist the inbound message\n            var result = await _inboxService.SaveIncomingMessageAsync(dto);\n\n            // 2) Push the real-time message to everyone in this business\n            var groupName = $\"business_{dto.BusinessId}\";\n            await _hubContext.Clients.Group(groupName).SendAsync(\"ReceiveInboxMessage\", new\n            {\n                contactId = dto.ContactId,\n                messageContent = dto.MessageBody,  // ‚úÖ aligned with frontend\n                from = dto.RecipientPhone,\n                status = \"Delivered\",\n                sentAt = DateTime.UtcNow,\n                isIncoming = true\n            });\n\n            // 3) Tell clients to refresh their own unread snapshot (per-user)\n            //    We cannot compute per-user unread here (no userId in webhook context),\n            //    so we emit a refresh signal that clients handle by calling GET /inbox/unread-counts.\n            await _hubContext.Clients.Group(groupName)\n                .SendAsync(\"UnreadCountChanged\", new { refresh = true });\n\n            return Ok(result);\n        }\n\n        /// <summary>\n        /// Fetch message history between agent and customer using business token + contactId.\n        /// </summary>\n        [HttpGet(\"messages\")]\n        public async Task<IActionResult> GetMessagesByContact([FromQuery] Guid contactId)\n        {\n            if (contactId == Guid.Empty)\n                return BadRequest(\"ContactId is required.\");\n\n            var businessId = User.GetBusinessId();\n            var messages = await _inboxService.GetMessagesByContactAsync(businessId, contactId);\n            return Ok(messages);\n        }\n\n        [HttpGet(\"conversation\")]\n        public async Task<IActionResult> GetConversation(\n            [FromQuery] Guid businessId,\n            [FromQuery] string userPhone,\n            [FromQuery] string contactPhone)\n        {\n            if (businessId == Guid.Empty || string.IsNullOrWhiteSpace(userPhone) || string.IsNullOrWhiteSpace(contactPhone))\n                return BadRequest(\"Invalid input.\");\n\n            var messages = await _inboxService.GetConversationAsync(businessId, userPhone, contactPhone);\n            return Ok(messages);\n        }\n\n        [HttpPost(\"mark-read\")]\n        public async Task<IActionResult> MarkMessagesAsRead([FromQuery] Guid contactId)\n        {\n            if (contactId == Guid.Empty)\n                return BadRequest(\"ContactId is required.\");\n\n            var businessId = User.GetBusinessId();\n            await _inboxService.MarkMessagesAsReadAsync(businessId, contactId);\n            return Ok();\n        }\n\n        [HttpGet(\"unread-counts\")]\n        public async Task<IActionResult> GetUnreadCounts()\n        {\n            var businessId = User.GetBusinessId();\n            var userId = User.GetUserId();\n\n            if (businessId == null || userId == null)\n                return Unauthorized();\n\n            var counts = await _unreadCountService.GetUnreadCountsAsync(businessId, userId);\n            return Ok(counts);\n        }\n    }\n}\n\n//using Microsoft.AspNetCore.Mvc;\n//using System;\n//using System.Threading.Tasks;\n//using xbytechat.api.Features.Inbox.DTOs;\n//using xbytechat.api.Features.Inbox.Services;\n//using xbytechat.api.Helpers;\n//using Microsoft.AspNetCore.Authorization;\n//using xbytechat.api.Shared;\n//using Microsoft.AspNetCore.SignalR;\n//using xbytechat.api.Features.Inbox.Hubs;\n//namespace xbytechat.api.Features.Inbox.Controllers\n//{\n//    [ApiController]\n//    [Route(\"api/inbox\")]\n//    public class InboxController : ControllerBase\n//    {\n//        private readonly IInboxService _inboxService;\n//        private readonly IHubContext<InboxHub> _hubContext; // ‚úÖ for SignalR push\n//        private readonly IUnreadCountService _unreadCountService;\n//        public InboxController(IInboxService inboxService, IHubContext<InboxHub> hubContext, IUnreadCountService unreadCountService)\n//        {\n//            _inboxService = inboxService;\n//            _hubContext = hubContext;\n//            _unreadCountService = unreadCountService;   \n//        }\n\n//        /// <summary>\n//        /// Send a new message from UI or system.\n//        /// </summary>\n//        [HttpPost(\"send\")]\n//        public async Task<IActionResult> SendMessage([FromBody] InboxMessageDto dto)\n//        {\n//            if (dto == null || string.IsNullOrWhiteSpace(dto.MessageBody))\n//                return BadRequest(\"Message content is required.\");\n\n//            var result = await _inboxService.SaveOutgoingMessageAsync(dto);\n//            return Ok(result);\n//        }\n\n//        /// <summary>\n//        /// Receive a message from external source (e.g., WhatsApp webhook).\n//        /// </summary>\n//        [HttpPost(\"receive\")]\n//        public async Task<IActionResult> ReceiveMessage([FromBody] InboxMessageDto dto)\n//        {\n//            if (dto == null || string.IsNullOrWhiteSpace(dto.MessageBody))\n//                return BadRequest(\"Incoming message content is required.\");\n\n//            var result = await _inboxService.SaveIncomingMessageAsync(dto);\n\n//            // ‚úÖ Also broadcast in real-time to clients in this business group\n//            var groupName = $\"business_{dto.BusinessId}\";\n//            await _hubContext.Clients.Group(groupName).SendAsync(\"ReceiveInboxMessage\", new\n//            {\n//                contactId = dto.ContactId,\n//                messageContent = dto.MessageBody,  // ‚úÖ aligned with frontend\n//                from = dto.RecipientPhone,\n//                status = \"Delivered\",\n//                sentAt = DateTime.UtcNow,\n//                isIncoming = true\n//            });\n\n//            return Ok(result);\n//        }\n\n//        /// <summary>\n//        /// Fetch message history between agent and customer using business token + contactId.\n//        /// </summary>\n//        [HttpGet(\"messages\")]\n//        public async Task<IActionResult> GetMessagesByContact([FromQuery] Guid contactId)\n//        {\n//            if (contactId == Guid.Empty)\n//                return BadRequest(\"ContactId is required.\");\n\n//            var businessId = User.GetBusinessId();\n//            var messages = await _inboxService.GetMessagesByContactAsync(businessId, contactId);\n//            return Ok(messages);\n//        }\n\n//        [HttpGet(\"conversation\")]\n//        public async Task<IActionResult> GetConversation(\n//            [FromQuery] Guid businessId,\n//            [FromQuery] string userPhone,\n//            [FromQuery] string contactPhone)\n//        {\n//            if (businessId == Guid.Empty || string.IsNullOrWhiteSpace(userPhone) || string.IsNullOrWhiteSpace(contactPhone))\n//                return BadRequest(\"Invalid input.\");\n\n//            var messages = await _inboxService.GetConversationAsync(businessId, userPhone, contactPhone);\n//            return Ok(messages);\n//        }\n\n//        [HttpPost(\"mark-read\")]\n//        public async Task<IActionResult> MarkMessagesAsRead([FromQuery] Guid contactId)\n//        {\n//            if (contactId == Guid.Empty)\n//                return BadRequest(\"ContactId is required.\");\n\n//            var businessId = User.GetBusinessId();\n//            await _inboxService.MarkMessagesAsReadAsync(businessId, contactId);\n//            return Ok();\n//        }\n\n\n//        [HttpGet(\"unread-counts\")]\n//        public async Task<IActionResult> GetUnreadCounts()\n//        {\n//            var businessId = User.GetBusinessId();\n//            var userId = User.GetUserId();\n\n//            if (businessId == null || userId == null)\n//                return Unauthorized();\n\n//            var counts = await _unreadCountService.GetUnreadCountsAsync(\n//                businessId, userId);\n\n//            return Ok(counts);\n//        }\n//    }\n//}\n\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Controllers/QuickRepliesController.cs",
      "sha256": "5033e3cdc140676bd4e47f6ea2fbf18d4cdcfd15e2d7b88c646fd6709a0bdc0d",
      "language": "csharp",
      "size": 7869,
      "content": "using Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Serilog;\nusing xbytechat.api.Features.Inbox.DTOs;\nusing xbytechat.api.Features.Inbox.Services;\nusing xbytechat.api.Helpers; // for User.GetBusinessId(), GetUserId()\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.Inbox.Controllers\n{\n    [Authorize]\n    [ApiController]\n    [Route(\"api/quick-replies\")]\n    public class QuickRepliesController : ControllerBase\n    {\n        private readonly IQuickReplyService _service;\n\n        public QuickRepliesController(IQuickReplyService service) => _service = service;\n\n        [HttpGet]\n        public async Task<IActionResult> GetAll([FromQuery] string? q = null,\n            [FromQuery] string scope = \"all\")\n        {\n            var businessId = User.GetBusinessId();\n            var userId = User.GetUserId();\n\n            // Guid is a value type, so null-checks are useless.\n            // Treat Guid.Empty as \"no id in claims\".\n            if (businessId == Guid.Empty || userId == Guid.Empty)\n                return Unauthorized();\n\n            bool includeBusiness = scope is \"all\" or \"business\";\n            bool includePersonal = scope is \"all\" or \"personal\";\n\n            var list = await _service.GetAllAsync(businessId, userId, q, includeBusiness, includePersonal);\n            return Ok(list);\n        }\n\n        [HttpPost]\n        public async Task<IActionResult> Create([FromBody] QuickReplyCreateDto dto)\n        {\n            var businessId = User.GetBusinessId();\n            var userId = User.GetUserId();\n\n            if (businessId == Guid.Empty || userId == Guid.Empty)\n                return Unauthorized();\n\n            var actor = User.Identity?.Name\n                        ?? (userId != Guid.Empty ? userId.ToString() : \"system\");\n\n            Log.Information(\"Create QuickReply requested by {@Actor}\", actor);\n            var result = await _service.CreateAsync(businessId, userId, actor, dto);\n            return Ok(result);\n        }\n\n        [HttpPut(\"{id:guid}\")]\n        public async Task<IActionResult> Update([FromRoute] Guid id, [FromBody] QuickReplyUpdateDto dto)\n        {\n            var businessId = User.GetBusinessId();\n            var userId = User.GetUserId();\n\n            if (businessId == Guid.Empty || userId == Guid.Empty)\n                return Unauthorized();\n\n            var actor = User.Identity?.Name\n                        ?? (userId != Guid.Empty ? userId.ToString() : \"system\");\n\n            Log.Information(\"Update QuickReply {@QuickReplyId} by {@Actor}\", id, actor);\n            var result = await _service.UpdateAsync(businessId, userId, actor, id, dto);\n            return Ok(result);\n        }\n\n        [HttpPatch(\"{id:guid}/toggle\")]\n        public async Task<IActionResult> Toggle([FromRoute] Guid id, [FromQuery] bool active = true)\n        {\n            var businessId = User.GetBusinessId();\n            var userId = User.GetUserId();\n\n            if (businessId == Guid.Empty || userId == Guid.Empty)\n                return Unauthorized();\n\n            var actor = User.Identity?.Name\n                        ?? (userId != Guid.Empty ? userId.ToString() : \"system\");\n\n            Log.Information(\"Toggle QuickReply {@QuickReplyId} -> {Active} by {@Actor}\", id, active, actor);\n            var result = await _service.ToggleActiveAsync(businessId, userId, actor, id, active);\n            return Ok(result);\n        }\n\n        [HttpDelete(\"{id:guid}\")]\n        public async Task<IActionResult> Delete([FromRoute] Guid id)\n        {\n            var businessId = User.GetBusinessId();\n            var userId = User.GetUserId();\n\n            if (businessId == Guid.Empty || userId == Guid.Empty)\n                return Unauthorized();\n\n            var actor = User.Identity?.Name\n                        ?? (userId != Guid.Empty ? userId.ToString() : \"system\");\n\n            Log.Information(\"Delete QuickReply {@QuickReplyId} by {@Actor}\", id, actor);\n            var result = await _service.DeleteAsync(businessId, userId, actor, id);\n            return Ok(result);\n        }\n    }\n}\n\n\n//using Microsoft.AspNetCore.Authorization;\n//using Microsoft.AspNetCore.Mvc;\n//using Serilog;\n//using xbytechat.api.Features.Inbox.DTOs;\n//using xbytechat.api.Features.Inbox.Services;\n//using xbytechat.api.Helpers; // for User.GetBusinessId(), GetUserId()\n//using xbytechat.api.Shared;\n\n//namespace xbytechat.api.Features.Inbox.Controllers\n//{\n//    [Authorize]\n//    [ApiController]\n//    [Route(\"api/quick-replies\")]\n//    public class QuickRepliesController : ControllerBase\n//    {\n//        private readonly IQuickReplyService _service;\n\n//        public QuickRepliesController(IQuickReplyService service) => _service = service;\n\n//        [HttpGet]\n//        public async Task<IActionResult> GetAll([FromQuery] string? q = null,\n//            [FromQuery] string scope = \"all\")\n//        {\n//            var businessId = User.GetBusinessId();\n//            var userId = User.GetUserId();\n\n//            if (businessId == null || userId == null) return Unauthorized();\n\n//            bool includeBusiness = scope is \"all\" or \"business\";\n//            bool includePersonal = scope is \"all\" or \"personal\";\n\n//            var list = await _service.GetAllAsync(businessId, userId, q, includeBusiness, includePersonal);\n//            return Ok(list);\n//        }\n\n//        [HttpPost]\n//        public async Task<IActionResult> Create([FromBody] QuickReplyCreateDto dto)\n//        {\n//            var businessId = User.GetBusinessId();\n//            var userId = User.GetUserId();\n//            var actor = User.Identity?.Name ?? userId.ToString() ?? \"system\";\n\n//            if (businessId == null || userId == null) return Unauthorized();\n\n//            Log.Information(\"Create QuickReply requested by {@Actor}\", actor);\n//            var result = await _service.CreateAsync(businessId, userId, actor, dto);\n//            return Ok(result);\n//        }\n\n//        [HttpPut(\"{id:guid}\")]\n//        public async Task<IActionResult> Update([FromRoute] Guid id, [FromBody] QuickReplyUpdateDto dto)\n//        {\n//            var businessId = User.GetBusinessId();\n//            var userId = User.GetUserId();\n//            var actor = User.Identity?.Name ?? userId.ToString() ?? \"system\";\n\n//            if (businessId == null || userId == null) return Unauthorized();\n\n//            Log.Information(\"Update QuickReply {@QuickReplyId} by {@Actor}\", id, actor);\n//            var result = await _service.UpdateAsync(businessId, userId, actor, id, dto);\n//            return Ok(result);\n//        }\n\n//        [HttpPatch(\"{id:guid}/toggle\")]\n//        public async Task<IActionResult> Toggle([FromRoute] Guid id, [FromQuery] bool active = true)\n//        {\n//            var businessId = User.GetBusinessId();\n//            var userId = User.GetUserId();\n//            var actor = User.Identity?.Name ?? userId.ToString() ?? \"system\";\n\n//            if (businessId == null || userId == null) return Unauthorized();\n\n//            Log.Information(\"Toggle QuickReply {@QuickReplyId} -> {Active} by {@Actor}\", id, active, actor);\n//            var result = await _service.ToggleActiveAsync(businessId, userId, actor, id, active);\n//            return Ok(result);\n//        }\n\n//        [HttpDelete(\"{id:guid}\")]\n//        public async Task<IActionResult> Delete([FromRoute] Guid id)\n//        {\n//            var businessId = User.GetBusinessId();\n//            var userId = User.GetUserId();\n//            var actor = User.Identity?.Name ?? userId.ToString() ?? \"system\";\n\n//            if (businessId == null || userId == null) return Unauthorized();\n\n//            Log.Information(\"Delete QuickReply {@QuickReplyId} by {@Actor}\", id, actor);\n//            var result = await _service.DeleteAsync(businessId, userId, actor, id);\n//            return Ok(result);\n//        }\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/DTOs/InboxMessageDto.cs",
      "sha256": "bbe5d988e9fd84c5d20f75ed4a389cc2a814c5c84434c9f4a297b84aba02ab7c",
      "language": "csharp",
      "size": 1832,
      "content": "// üìÑ File: Features/Inbox/DTOs/InboxMessageDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.Inbox.DTOs\n{\n    public class InboxMessageDto\n    {\n        public Guid BusinessId { get; set; }\n        public string RecipientPhone { get; set; }\n        public string MessageBody { get; set; }\n        public Guid? ContactId { get; set; }\n        public Guid? CTAFlowStepId { get; set; }\n        public Guid? CTAFlowConfigId { get; set; }\n        public Guid? CampaignId { get; set; }\n        public string? CampaignName { get; set; }       // üÜï To show in chat bubble\n        public string? RenderedBody { get; set; }\n\n        public bool IsIncoming { get; set; }            // üÜï Needed for bubble side\n        public string Status { get; set; }              // üÜï For message ticks\n        public DateTime SentAt { get; set; }            // üÜï For timestamp\n\n        // ‚úÖ NEW: Provider/WAMID idempotency key (Meta \"messages[0].id\")\n        public string? ProviderMessageId { get; set; }\n\n        // ‚úÖ NEW: WhatsApp native media (for inbound/outbound attachments)\n        // Stored as media_id (not public URL) to avoid hosting files ourselves.\n        public string? MediaId { get; set; }            // WhatsApp Cloud API media_id\n        public string? MediaType { get; set; }          // \"image\" | \"document\" | \"video\" | \"audio\" | \"location\"\n        public string? FileName { get; set; }           // original filename (if available)\n        public string? MimeType { get; set; }           // e.g. \"image/jpeg\", \"application/pdf\"\n\n        // ?? WhatsApp location message fields (no MediaId)\n        public double? LocationLatitude { get; set; }\n        public double? LocationLongitude { get; set; }\n        public string? LocationName { get; set; }\n        public string? LocationAddress { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/DTOs/QuickReplyDtos.cs",
      "sha256": "90ec17a9a8c369db09ac8c28b8296c766c31ea78badd34e53397522a8bc08e00",
      "language": "csharp",
      "size": 1460,
      "content": "using System.ComponentModel.DataAnnotations;\nusing xbytechat.api.Features.Inbox.Models;\n\nnamespace xbytechat.api.Features.Inbox.DTOs\n{\n    public sealed class QuickReplyDto\n    {\n        public Guid Id { get; set; }\n        public Guid BusinessId { get; set; }\n        public Guid? OwnerUserId { get; set; }\n        public QuickReplyScope Scope { get; set; }\n        public string Title { get; set; } = string.Empty;\n        public string Body { get; set; } = string.Empty;\n        public string? TagsCsv { get; set; }\n        public string? Language { get; set; }\n        public bool IsActive { get; set; }\n        public DateTime UpdatedAt { get; set; }\n    }\n\n    public sealed class QuickReplyCreateDto\n    {\n        [Required, MaxLength(120)] public string Title { get; set; } = string.Empty;\n        [Required] public string Body { get; set; } = string.Empty;\n        [MaxLength(240)] public string? TagsCsv { get; set; }\n        [MaxLength(8)] public string? Language { get; set; }\n        public QuickReplyScope Scope { get; set; } = QuickReplyScope.Personal;\n    }\n\n    public sealed class QuickReplyUpdateDto\n    {\n        [Required, MaxLength(120)] public string Title { get; set; } = string.Empty;\n        [Required] public string Body { get; set; } = string.Empty;\n        [MaxLength(240)] public string? TagsCsv { get; set; }\n        [MaxLength(8)] public string? Language { get; set; }\n        public bool IsActive { get; set; } = true;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/DTOs/SendInboxMessageDto.cs",
      "sha256": "1ad0e0e61748e9f9e1fab32e1fe533c57a6c8d586694e55aa5b531359804de90",
      "language": "csharp",
      "size": 462,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.Inbox.DTOs\n{\n    /// <summary>\n    /// DTO sent from frontend when a user sends a new message.\n    /// </summary>\n    public class SendInboxMessageDto\n    {\n        [Required]\n        public Guid ContactId { get; set; }\n\n        [Required]\n        public string MessageBody { get; set; }\n\n        public string? MediaUrl { get; set; } // Optional image or file\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/DTOs/SendMessageInputDto.cs",
      "sha256": "3c76bd2b5ce839064134b72aa2114c14c73a98109c680671f5e7c463867f221a",
      "language": "csharp",
      "size": 249,
      "content": "namespace xbytechat.api.Features.Inbox.DTOs\n{\n    public class SendMessageInputDto\n    {\n        public Guid ContactId { get; set; } // üîÅ REMOVE the \"?\" (nullable) unless needed\n        public string Message { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/DTOs/TextOnlyMessageSendDto.cs",
      "sha256": "2d322145a5e6410decb150b108c7d74a656201d9be027b99b02d1c261b4ed4fc",
      "language": "csharp",
      "size": 247,
      "content": "namespace xbytechat.api.Features.Inbox.DTOs\n{\n    public class TextOnlyMessageSendDto\n    {\n        public Guid BusinessId { get; set; }\n\n        public string RecipientNumber { get; set; }\n\n        public string TextContent { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Hubs/InboxHub.cs",
      "sha256": "dc50a81d23d6ff48b0dc5d21dc8631e25679ea931e3a2a1865b1746ebe9b80d4",
      "language": "csharp",
      "size": 9092,
      "content": "using Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.SignalR;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.Features.Inbox.Services;\nusing xbytechat.api.Models;\nusing xbytechat.api.Features.Inbox.Models;\nusing xbytechat.api.Shared;\nusing xbytechat.api.Features.Inbox.DTOs;\n\nnamespace xbytechat.api.Features.Inbox.Hubs\n{\n    [Authorize]\n    public sealed class InboxHub : Hub\n    {\n        private readonly AppDbContext _db;\n        private readonly IMessageEngineService _messageService;\n        private readonly IUnreadCountService _unreadCountService;\n        private readonly ILogger<InboxHub> _logger;\n\n        public InboxHub(\n            AppDbContext db,\n            IMessageEngineService messageService,\n            IUnreadCountService unreadCountService,\n            ILogger<InboxHub> logger)\n        {\n            _db = db;\n            _messageService = messageService;\n            _unreadCountService = unreadCountService;\n            _logger = logger;\n        }\n\n        public override async Task OnConnectedAsync()\n        {\n            //var businessId = Context.User.GetBusinessId();\n            var businessId = Context.User.ResolveBusinessId(Context.GetHttpContext()!);\n            if (businessId == Guid.Empty)\n            {\n                _logger.LogWarning(\"InboxHub connect: missing BusinessId claim. Conn={ConnId}\", Context.ConnectionId);\n                await base.OnConnectedAsync();\n                return;\n            }\n\n            var groupName = GetBusinessGroupName(businessId);\n\n            await Groups.AddToGroupAsync(Context.ConnectionId, groupName);\n            _logger.LogInformation(\"InboxHub connected. Group={Group} Conn={ConnId} UserIdentifier={UserId}\",\n                groupName, Context.ConnectionId, Context.UserIdentifier);\n\n            await base.OnConnectedAsync();\n        }\n\n        public override async Task OnDisconnectedAsync(Exception? exception)\n        {\n           // var businessId = Context.User.GetBusinessId();\n            var businessId = Context.User.ResolveBusinessId(Context.GetHttpContext()!);\n            if (businessId != Guid.Empty)\n            {\n                var groupName = GetBusinessGroupName(businessId);\n                try { await Groups.RemoveFromGroupAsync(Context.ConnectionId, groupName); } catch { /* ignore */ }\n\n                _logger.LogInformation(\"InboxHub disconnected. Group={Group} Conn={ConnId}\", groupName, Context.ConnectionId);\n            }\n\n            await base.OnDisconnectedAsync(exception);\n        }\n\n        // ‚úÖ Frontend should invoke: connection.invoke(\"SendMessageToContact\", { contactId, message })\n        public async Task SendMessageToContact(SendMessageInputDto dto)\n        {\n            if (dto == null)\n                return;\n\n            if (dto.ContactId == Guid.Empty || string.IsNullOrWhiteSpace(dto.Message))\n            {\n                _logger.LogWarning(\"SendMessageToContact invalid payload. ContactId={ContactId}\", dto.ContactId);\n                return;\n            }\n\n           // var businessId = Context.User.GetBusinessId();\n            var businessId = Context.User.ResolveBusinessId(Context.GetHttpContext()!);\n            var userId = Context.User.GetUserId();\n\n            if (businessId == Guid.Empty || userId == Guid.Empty)\n            {\n                _logger.LogWarning(\"SendMessageToContact missing BusinessId/UserId. Conn={ConnId}\", Context.ConnectionId);\n                return;\n            }\n\n            try\n            {\n                // ‚úÖ Lookup recipient phone number from Contacts\n                var contact = await _db.Contacts\n                    .Where(c => c.BusinessId == businessId && c.Id == dto.ContactId)\n                    .FirstOrDefaultAsync();\n\n                if (contact == null || string.IsNullOrWhiteSpace(contact.PhoneNumber))\n                {\n                    _logger.LogWarning(\"SendMessageToContact contact not found or missing phone. BusinessId={BusinessId} ContactId={ContactId}\",\n                        businessId, dto.ContactId);\n\n                    await Clients.Caller.SendAsync(\"ReceiveInboxMessage\", new\n                    {\n                        contactId = dto.ContactId,\n                        messageContent = dto.Message,\n                        from = userId,\n                        status = \"Failed\",\n                        error = \"Invalid contact\"\n                    });\n\n                    return;\n                }\n\n                var sendDto = new TextMessageSendDto\n                {\n                    BusinessId = businessId,\n                    ContactId = dto.ContactId,\n                    RecipientNumber = contact.PhoneNumber,\n                    TextContent = dto.Message\n                };\n\n                var result = await _messageService.SendTextDirectAsync(sendDto);\n\n                var inboxMessage = new\n                {\n                    contactId = dto.ContactId,\n                    messageContent = dto.Message,\n                    from = userId,\n                    status = result.Success ? \"Sent\" : \"Failed\",\n                    sentAt = DateTime.UtcNow,\n                    logId = result.LogId,\n                    senderId = userId,\n                    isIncoming = false\n                };\n\n                // Caller always gets it\n                await Clients.Caller.SendAsync(\"ReceiveInboxMessage\", inboxMessage);\n\n                // Others in the same business get it\n                var groupName = GetBusinessGroupName(businessId);\n                await Clients.GroupExcept(groupName, Context.ConnectionId)\n                    .SendAsync(\"ReceiveInboxMessage\", inboxMessage);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"SendMessageToContact failed. BusinessId={BusinessId} ContactId={ContactId}\",\n                    businessId, dto.ContactId);\n\n                await Clients.Caller.SendAsync(\"ReceiveInboxMessage\", new\n                {\n                    contactId = dto.ContactId,\n                    messageContent = dto.Message,\n                    from = userId,\n                    status = \"Failed\",\n                    error = \"Server error\"\n                });\n            }\n        }\n\n      \n        public async Task MarkAsRead(Guid contactId)\n        {\n            if (contactId == Guid.Empty)\n                return;\n\n            var userId = Context.User.GetUserId();\n           // var businessId = Context.User.GetBusinessId();\n            var businessId = Context.User.ResolveBusinessId(Context.GetHttpContext()!);\n            if (userId == Guid.Empty || businessId == Guid.Empty)\n                return;\n\n            try\n            {\n                var now = DateTime.UtcNow;\n\n                // ‚úÖ Upsert ContactRead\n                var readEntry = await _db.ContactReads\n                    .FirstOrDefaultAsync(r => r.BusinessId == businessId && r.ContactId == contactId && r.UserId == userId);\n\n                if (readEntry == null)\n                {\n                    _db.ContactReads.Add(new ContactRead\n                    {\n                        Id = Guid.NewGuid(),\n                        BusinessId = businessId,\n                        ContactId = contactId,\n                        UserId = userId,\n                        LastReadAt = now\n                    });\n                }\n                else\n                {\n                    readEntry.LastReadAt = now;\n                }\n\n                await _db.SaveChangesAsync();\n\n                // ‚úÖ CRITICAL FIX:\n                // UnreadCountService returns ONLY contacts with unread > 0.\n                // If this contact becomes 0, it will be missing from the dictionary,\n                // so the frontend would never clear the old badge.\n                // Force-send an explicit \"0\" for this contact to the caller.\n                await Clients.Caller.SendAsync(\"UnreadCountChanged\", new\n                {\n                    contactId = contactId,\n                    unreadCount = 0\n                });\n\n                // ‚úÖ Caller also gets their full unread map (for other chats)\n                var unreadCounts = await _unreadCountService.GetUnreadCountsAsync(businessId, userId);\n                await Clients.Caller.SendAsync(\"UnreadCountChanged\", unreadCounts);\n\n                // ‚úÖ Others get \"refresh your own\" signal\n                var groupName = GetBusinessGroupName(businessId);\n                await Clients.GroupExcept(groupName, Context.ConnectionId)\n                    .SendAsync(\"UnreadCountChanged\", new { refresh = true });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex,\n                    \"MarkAsRead failed. BusinessId={BusinessId} UserId={UserId} ContactId={ContactId}\",\n                    businessId, userId, contactId);\n            }\n        }\n\n        private static string GetBusinessGroupName(Guid businessId) => $\"business_{businessId}\";\n    }\n}\n\n\n\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Models/ChatSessionState.cs",
      "sha256": "fa6184f30e1715455ee5b84ae75264c5cc2d46ed4f1721014141ed9036dfda64",
      "language": "csharp",
      "size": 500,
      "content": "namespace xbytechat.api.Features.Inbox.Models\n{\n    public class ChatSessionState\n    {\n        public Guid Id { get; set; } = Guid.NewGuid();\n        public Guid BusinessId { get; set; }\n        public Guid ContactId { get; set; }\n\n        public string Mode { get; set; } = \"automation\"; // values: \"automation\" | \"agent\"\n        public DateTime LastUpdatedAt { get; set; } = DateTime.UtcNow;\n\n        // Optional: track who switched the mode\n        public string? UpdatedBy { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Models/ContactRead.cs",
      "sha256": "aa4dd9980bc6485cf1c4981bf7dfff84f32dcfbacc6c9dbc3be4ba0429c065c6",
      "language": "csharp",
      "size": 474,
      "content": "using System;\n\nnamespace xbytechat.api.Features.Inbox.Models\n{\n    public class ContactRead\n    {\n        public Guid Id { get; set; }\n\n        // üîó FK to Contact\n        public Guid ContactId { get; set; }\n\n        // üîó FK to User (Agent)\n        public Guid UserId { get; set; }\n\n        // üìÖ Last time this agent opened this contact's chat\n        public DateTime LastReadAt { get; set; } = DateTime.UtcNow;\n\n        public Guid BusinessId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Models/QuickReply.cs",
      "sha256": "8b5cba0c3d3af40a8abf6fd445648c0671b6fb294489fcae8c2d8b438291e285",
      "language": "csharp",
      "size": 1180,
      "content": "using System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace xbytechat.api.Features.Inbox.Models\n{\n    public enum QuickReplyScope { Personal = 0, Business = 2 }\n\n    [Table(\"QuickReplies\")]\n    public class QuickReply\n    {\n        [Key] public Guid Id { get; set; }\n        [Required] public Guid BusinessId { get; set; }\n        public Guid? OwnerUserId { get; set; }                // null for Business scope\n\n        [Required, MaxLength(120)] public string Title { get; set; } = string.Empty;\n        [Required] public string Body { get; set; } = string.Empty;\n\n        [MaxLength(240)] public string? TagsCsv { get; set; }\n        [MaxLength(8)] public string? Language { get; set; }   // e.g. \"en\", \"hi\"\n\n        public QuickReplyScope Scope { get; set; } = QuickReplyScope.Personal;\n        public bool IsActive { get; set; } = true;\n        public bool IsDeleted { get; set; } = false;\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n        public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;\n        public string? CreatedBy { get; set; }\n        public string? UpdatedBy { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Repositories/IInboxRepository.cs",
      "sha256": "dc286300119f9a71db85e3f3bae523d75fbf4b7887ccbeacb7aa08166b152045",
      "language": "csharp",
      "size": 1070,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Inbox.Repositories\n{\n    public interface IInboxRepository\n    {\n        Task<List<MessageLog>> GetConversationAsync(Guid businessId, string userPhone, string contactPhone, int limit = 50);\n        Task<MessageLog?> GetLastMessageAsync(Guid businessId, string userPhone, string contactPhone);\n\n        Task AddMessageAsync(MessageLog message);\n        Task SaveChangesAsync();\n\n        Task<List<MessageLog>> GetMessagesByContactIdAsync(Guid businessId, Guid contactId);\n\n        Task<Dictionary<Guid, int>> GetUnreadMessageCountsAsync(Guid businessId);\n        Task MarkMessagesAsReadAsync(Guid businessId, Guid contactId);\n\n        Task<Dictionary<Guid, int>> GetUnreadCountsForUserAsync(Guid businessId, Guid userId);\n\n        // ‚úÖ Step 3: Soft idempotency helper\n        // Used to prevent duplicate inbound inserts when webhook retries arrive.\n        Task<MessageLog?> FindByProviderMessageIdAsync(Guid businessId, string providerMessageId);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Repositories/InboxRepository.cs",
      "sha256": "b9fbbc9cfee67371f563d25176d036696839f4ce37465c843bfb4d13ee4bb90d",
      "language": "csharp",
      "size": 5051,
      "content": "using Microsoft.EntityFrameworkCore;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Inbox.Repositories\n{\n    public class InboxRepository : IInboxRepository\n    {\n        private readonly AppDbContext _context;\n\n        public InboxRepository(AppDbContext context)\n        {\n            _context = context;\n        }\n\n        public async Task<List<MessageLog>> GetConversationAsync(Guid businessId, string userPhone, string contactPhone, int limit = 50)\n        {\n            return await _context.MessageLogs\n                .Where(m => m.BusinessId == businessId &&\n                            ((m.RecipientNumber == contactPhone && m.IsIncoming == false) ||\n                             (m.RecipientNumber == userPhone && m.IsIncoming == true)))\n                .OrderByDescending(m => m.CreatedAt)\n                .Take(limit)\n                .ToListAsync();\n        }\n\n        public async Task<MessageLog?> GetLastMessageAsync(Guid businessId, string userPhone, string contactPhone)\n        {\n            return await _context.MessageLogs\n                .Where(m => m.BusinessId == businessId &&\n                            ((m.RecipientNumber == contactPhone && m.IsIncoming == false) ||\n                             (m.RecipientNumber == userPhone && m.IsIncoming == true)))\n                .OrderByDescending(m => m.CreatedAt)\n                .FirstOrDefaultAsync();\n        }\n\n        public async Task AddMessageAsync(MessageLog message)\n        {\n            await _context.MessageLogs.AddAsync(message);\n        }\n\n        public async Task SaveChangesAsync()\n        {\n            await _context.SaveChangesAsync();\n        }\n\n        public async Task<List<MessageLog>> GetMessagesByContactIdAsync(Guid businessId, Guid contactId)\n        {\n            return await _context.MessageLogs\n                .Include(m => m.SourceCampaign)\n                .Where(m => m.BusinessId == businessId && m.ContactId == contactId)\n                .OrderBy(m => m.CreatedAt)\n                .ToListAsync();\n        }\n\n        public async Task<Dictionary<Guid, int>> GetUnreadMessageCountsAsync(Guid businessId)\n        {\n            return await _context.MessageLogs\n                .Where(m => m.BusinessId == businessId &&\n                            m.IsIncoming &&\n                            m.Status != \"Read\" &&\n                            m.ContactId != null)\n                .GroupBy(m => m.ContactId!.Value)\n                .Select(g => new { ContactId = g.Key, Count = g.Count() })\n                .ToDictionaryAsync(x => x.ContactId, x => x.Count);\n        }\n\n        public async Task MarkMessagesAsReadAsync(Guid businessId, Guid contactId)\n        {\n            var unreadMessages = await _context.MessageLogs\n                .Where(m => m.BusinessId == businessId &&\n                            m.ContactId == contactId &&\n                            m.IsIncoming &&\n                            m.Status != \"Read\")\n                .ToListAsync();\n\n            foreach (var msg in unreadMessages)\n                msg.Status = \"Read\";\n\n            await _context.SaveChangesAsync();\n        }\n\n        public async Task<Dictionary<Guid, int>> GetUnreadCountsForUserAsync(Guid businessId, Guid userId)\n        {\n            var contactReads = await _context.ContactReads\n                .Where(r => r.UserId == userId)\n                .ToDictionaryAsync(r => r.ContactId, r => r.LastReadAt);\n\n            var allMessages = await _context.MessageLogs\n                .Where(m => m.BusinessId == businessId && m.IsIncoming && m.ContactId != null)\n                .ToListAsync();\n\n            var unreadCounts = allMessages\n                .GroupBy(m => m.ContactId!.Value)\n                .ToDictionary(\n                    g => g.Key,\n                    g => g.Count(m =>\n                        !contactReads.ContainsKey(g.Key) ||\n                        (m.SentAt ?? m.CreatedAt) > contactReads[g.Key])\n                );\n\n            return unreadCounts;\n        }\n\n        // ‚úÖ Step 4: Soft idempotency lookup (BusinessId + ProviderMessageId/WAMID)\n        // Used by InboxService to avoid inserting duplicate inbound rows when Meta retries webhooks.\n        public async Task<MessageLog?> FindByProviderMessageIdAsync(Guid businessId, string providerMessageId)\n        {\n            if (businessId == Guid.Empty) return null;\n            if (string.IsNullOrWhiteSpace(providerMessageId)) return null;\n\n            var wamid = providerMessageId.Trim();\n\n            // IMPORTANT:\n            // - Use ProviderMessageId only for webhook idempotency.\n            // - Do NOT match against MessageId here (prevents cross-path collisions).\n            return await _context.MessageLogs\n                .AsNoTracking()\n                .FirstOrDefaultAsync(m =>\n                    m.BusinessId == businessId &&\n                    m.ProviderMessageId != null &&\n                    m.ProviderMessageId == wamid\n                );\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Services/AgentAssignmentService.cs",
      "sha256": "de9062b213ba63cb8695f407ede5c9e8d52a589e0dc1c7a4c5c79fd243389e4e",
      "language": "csharp",
      "size": 1104,
      "content": "using System;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Logging;\n\nnamespace xbytechat.api.Features.Inbox.Services\n{\n    public class AgentAssignmentService : IAgentAssignmentService\n    {\n        private readonly ILogger<AgentAssignmentService> _logger;\n\n        public AgentAssignmentService(ILogger<AgentAssignmentService> logger)\n        {\n            _logger = logger;\n        }\n\n        public Task<bool> IsAgentAvailableAsync(Guid businessId)\n        {\n            // üîß TODO: Replace with real logic based on your agent pool\n            _logger.LogInformation(\"Checking if agent is available for business {BusinessId}\", businessId);\n            return Task.FromResult(true); // Assume always available for MVP\n        }\n\n        public Task AssignAgentToContactAsync(Guid businessId, Guid contactId)\n        {\n            // üîß TODO: Save agent-contact assignment to DB or notify a human agent\n            _logger.LogInformation(\"Assigning agent to contact {ContactId} for business {BusinessId}\", contactId, businessId);\n            return Task.CompletedTask;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Services/ChatSessionStateService.cs",
      "sha256": "5c6672bd07d87501ca9d46e38085cbec03455bae6cc943c8b8df505a7c73808e",
      "language": "csharp",
      "size": 2964,
      "content": "using Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.AutoReplyBuilder.Models;\nusing xbytechat.api.Features.Inbox.Models;\n\nnamespace xbytechat.api.Features.Inbox.Services\n{\n    public class ChatSessionStateService : IChatSessionStateService\n    {\n        private readonly AppDbContext _db;\n\n        public ChatSessionStateService(AppDbContext db)\n        {\n            _db = db;\n        }\n\n        // ‚úÖ Returns current chat mode: \"agent\" or \"auto\"\n        public async Task<string> GetChatModeAsync(Guid businessId, Guid contactId)\n        {\n            var session = await _db.ChatSessionStates\n                .FirstOrDefaultAsync(s => s.BusinessId == businessId && s.ContactId == contactId);\n\n            return session?.Mode ?? \"auto\"; // Default to auto\n        }\n\n        // ‚úÖ Switches to agent mode\n        public async Task SwitchToAgentModeAsync(Guid businessId, Guid contactId)\n        {\n            await UpsertChatModeAsync(businessId, contactId, \"agent\");\n        }\n\n        // ‚úÖ Switches to automation mode\n        public async Task SwitchToAutomationModeAsync(Guid businessId, Guid contactId)\n        {\n            await UpsertChatModeAsync(businessId, contactId, \"auto\");\n        }\n\n        // ‚úÖ Shared logic to insert or update session state\n        private async Task UpsertChatModeAsync(Guid businessId, Guid contactId, string mode)\n        {\n            var existing = await _db.ChatSessionStates\n                .FirstOrDefaultAsync(s => s.BusinessId == businessId && s.ContactId == contactId);\n\n            if (existing != null)\n            {\n                existing.Mode = mode;\n                existing.LastUpdatedAt = DateTime.UtcNow;\n            }\n            else\n            {\n                _db.ChatSessionStates.Add(new ChatSessionState\n                {\n                    BusinessId = businessId,\n                    ContactId = contactId,\n                    Mode = mode,\n                    LastUpdatedAt = DateTime.UtcNow\n                });\n            }\n\n            await _db.SaveChangesAsync();\n        }\n\n        public async Task SetChatModeAsync(Guid businessId, Guid contactId, string mode)\n        {\n            var state = await _db.ChatSessionStates\n                .FirstOrDefaultAsync(x => x.BusinessId == businessId && x.ContactId == contactId);\n\n            if (state == null)\n            {\n                // Insert new if not exists\n                state = new ChatSessionState\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    ContactId = contactId,\n                    Mode = mode,\n                    LastUpdatedAt = DateTime.UtcNow\n                };\n                _db.ChatSessionStates.Add(state);\n            }\n            else\n            {\n                state.Mode = mode;\n                state.LastUpdatedAt = DateTime.UtcNow;\n            }\n\n            await _db.SaveChangesAsync();\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Services/IAgentAssignmentService.cs",
      "sha256": "1eae6f670d61efc4cd6f430a93cf7188c26a6d521ae49cd50ab926aa5bc027ee",
      "language": "csharp",
      "size": 286,
      "content": "using System;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Inbox.Services\n{\n    public interface IAgentAssignmentService\n    {\n        Task<bool> IsAgentAvailableAsync(Guid businessId);\n        Task AssignAgentToContactAsync(Guid businessId, Guid contactId);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Services/IChatSessionStateService.cs",
      "sha256": "3ade6df9341ebca2e5a478331e57315273317bc803a529a4e068cccc323f1693",
      "language": "csharp",
      "size": 404,
      "content": "namespace xbytechat.api.Features.Inbox.Services\n{\n    public interface IChatSessionStateService\n    {\n        Task<string> GetChatModeAsync(Guid businessId, Guid contactId);\n        Task SwitchToAgentModeAsync(Guid businessId, Guid contactId);\n        Task SwitchToAutomationModeAsync(Guid businessId, Guid contactId);\n        Task SetChatModeAsync(Guid businessId, Guid contactId, string mode);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Services/IInboxService.cs",
      "sha256": "58b2b14fb055263d0f08348900a55c5cbd62c16609e1b4ba082beb34a84efc49",
      "language": "csharp",
      "size": 885,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Inbox.DTOs;\nusing xbytechat.api.Features.MessageManagement.DTOs;\n\nnamespace xbytechat.api.Features.Inbox.Services\n{\n    public interface IInboxService\n    {\n        Task<List<MessageLog>> GetConversationAsync(Guid businessId, string userPhone, string contactPhone, int limit = 50);\n        Task<MessageLog> SaveIncomingMessageAsync(InboxMessageDto dto);\n        Task<MessageLog> SaveOutgoingMessageAsync(InboxMessageDto dto);\n        Task<List<MessageLogDto>> GetMessagesByContactAsync(Guid businessId, Guid contactId);\n        Task<Dictionary<Guid, int>> GetUnreadMessageCountsAsync(Guid businessId);\n        Task MarkMessagesAsReadAsync(Guid businessId, Guid contactId);\n\n        Task<Dictionary<Guid, int>> GetUnreadCountsForUserAsync(Guid businessId, Guid userId);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Services/InboxService.cs",
      "sha256": "8f45defa7b8f6ffc93027a8d5cd7092e26d98b0a80c0956f5c457c043e52cea1",
      "language": "csharp",
      "size": 6707,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Inbox.DTOs;\nusing xbytechat.api.Features.Inbox.Repositories;\nusing xbytechat.api.Features.MessageManagement.DTOs;\n\nnamespace xbytechat.api.Features.Inbox.Services\n{\n    public class InboxService : IInboxService\n    {\n        private readonly IInboxRepository _repository;\n\n        public InboxService(IInboxRepository repository)\n        {\n            _repository = repository;\n        }\n\n        public async Task<List<MessageLog>> GetConversationAsync(Guid businessId, string userPhone, string contactPhone, int limit = 50)\n        {\n            return await _repository.GetConversationAsync(businessId, userPhone, contactPhone, limit);\n        }\n\n        public async Task<MessageLog> SaveIncomingMessageAsync(InboxMessageDto dto)\n        {\n            // ‚úÖ Soft idempotency on (BusinessId + ProviderMessageId) if available.\n            // Normalize ProviderMessageId to avoid \"space\" duplicates.\n            var providerMessageId = string.IsNullOrWhiteSpace(dto.ProviderMessageId)\n                ? null\n                : dto.ProviderMessageId.Trim();\n\n            if (!string.IsNullOrWhiteSpace(providerMessageId))\n            {\n                var existing = await _repository.FindByProviderMessageIdAsync(dto.BusinessId, providerMessageId);\n                if (existing != null)\n                    return existing;\n            }\n\n            // ‚úÖ SentAt: caller should pass provider timestamp when available; otherwise fall back to server time.\n            var sentAtUtc = dto.SentAt == default ? DateTime.UtcNow : dto.SentAt;\n\n            var message = new MessageLog\n            {\n                Id = Guid.NewGuid(),\n                BusinessId = dto.BusinessId,\n\n                RecipientNumber = dto.RecipientPhone,\n                MessageContent = dto.MessageBody,\n\n                MediaId = dto.MediaId,\n                MediaType = dto.MediaType,\n                FileName = dto.FileName,\n                MimeType = dto.MimeType,\n                LocationLatitude = dto.LocationLatitude,\n                LocationLongitude = dto.LocationLongitude,\n                LocationName = dto.LocationName,\n                LocationAddress = dto.LocationAddress,\n\n                IsIncoming = true,\n\n                // ‚úÖ Keep status consistent for UI (incoming should never be updated by delivery webhooks now)\n                Status = string.IsNullOrWhiteSpace(dto.Status) ? \"Received\" : dto.Status.Trim(),\n                SentAt = sentAtUtc,\n\n                // ‚úÖ CreatedAt = insert time (server truth)\n                CreatedAt = DateTime.UtcNow,\n\n                ProviderMessageId = providerMessageId,\n\n                ContactId = dto.ContactId,\n                CTAFlowStepId = dto.CTAFlowStepId,\n                CTAFlowConfigId = dto.CTAFlowConfigId,\n                CampaignId = dto.CampaignId,\n                RenderedBody = dto.RenderedBody\n            };\n\n            await _repository.AddMessageAsync(message);\n            await _repository.SaveChangesAsync();\n\n            return message;\n        }\n\n        public async Task<MessageLog> SaveOutgoingMessageAsync(InboxMessageDto dto)\n        {\n            // Outgoing WAMID may be unknown at creation time.\n            // If present (e.g., send returns WAMID and we call this after), add idempotency to avoid duplicates.\n            var providerMessageId = string.IsNullOrWhiteSpace(dto.ProviderMessageId)\n                ? null\n                : dto.ProviderMessageId.Trim();\n\n            if (!string.IsNullOrWhiteSpace(providerMessageId))\n            {\n                var existing = await _repository.FindByProviderMessageIdAsync(dto.BusinessId, providerMessageId);\n                if (existing != null)\n                    return existing;\n            }\n\n            var sentAtUtc = dto.SentAt == default ? DateTime.UtcNow : dto.SentAt;\n\n            var message = new MessageLog\n            {\n                Id = Guid.NewGuid(),\n                BusinessId = dto.BusinessId,\n\n                RecipientNumber = dto.RecipientPhone,\n                MessageContent = dto.MessageBody,\n\n                MediaId = dto.MediaId,\n                MediaType = dto.MediaType,\n                FileName = dto.FileName,\n                MimeType = dto.MimeType,\n                LocationLatitude = dto.LocationLatitude,\n                LocationLongitude = dto.LocationLongitude,\n                LocationName = dto.LocationName,\n                LocationAddress = dto.LocationAddress,\n\n                IsIncoming = false,\n\n                // ‚úÖ Default outgoing status\n                Status = string.IsNullOrWhiteSpace(dto.Status) ? \"Queued\" : dto.Status.Trim(),\n                SentAt = sentAtUtc,\n\n                CreatedAt = DateTime.UtcNow,\n\n                ProviderMessageId = providerMessageId,\n\n                ContactId = dto.ContactId,\n                CTAFlowStepId = dto.CTAFlowStepId,\n                CTAFlowConfigId = dto.CTAFlowConfigId,\n                CampaignId = dto.CampaignId,\n                RenderedBody = dto.RenderedBody\n            };\n\n            await _repository.AddMessageAsync(message);\n            await _repository.SaveChangesAsync();\n\n            return message;\n        }\n\n        public async Task<List<MessageLogDto>> GetMessagesByContactAsync(Guid businessId, Guid contactId)\n        {\n            var messages = await _repository.GetMessagesByContactIdAsync(businessId, contactId);\n\n            return messages.Select(m => new MessageLogDto\n            {\n                Id = m.Id,\n                ContactId = m.ContactId,\n                RecipientNumber = m.RecipientNumber,\n                MessageContent = m.MessageContent,\n                CreatedAt = m.CreatedAt,\n                IsIncoming = m.IsIncoming,\n                RenderedBody = m.RenderedBody,\n                CampaignId = m.CampaignId,\n                CampaignName = m.SourceCampaign?.Name,\n                CTAFlowConfigId = m.CTAFlowConfigId,\n                CTAFlowStepId = m.CTAFlowStepId\n            }).ToList();\n        }\n\n        public async Task<Dictionary<Guid, int>> GetUnreadMessageCountsAsync(Guid businessId)\n        {\n            return await _repository.GetUnreadMessageCountsAsync(businessId);\n        }\n\n        public async Task MarkMessagesAsReadAsync(Guid businessId, Guid contactId)\n        {\n            await _repository.MarkMessagesAsReadAsync(businessId, contactId);\n        }\n\n        public async Task<Dictionary<Guid, int>> GetUnreadCountsForUserAsync(Guid businessId, Guid userId)\n        {\n            return await _repository.GetUnreadCountsForUserAsync(businessId, userId);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Services/IQuickReplyService.cs",
      "sha256": "531cc91cab752357d88cfa2483ab059e7a9ffdcfe4507a3105595cc17e33c1c0",
      "language": "csharp",
      "size": 816,
      "content": "using xbytechat.api.Features.Inbox.DTOs;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.Inbox.Services\n{\n    public interface IQuickReplyService\n    {\n        Task<List<QuickReplyDto>> GetAllAsync(Guid businessId, Guid userId,\n            string? search = null, bool includeBusiness = true, bool includePersonal = true);\n\n        Task<ResponseResult> CreateAsync(Guid businessId, Guid userId, string actor, QuickReplyCreateDto dto);\n        Task<ResponseResult> UpdateAsync(Guid businessId, Guid userId, string actor, Guid id, QuickReplyUpdateDto dto);\n        Task<ResponseResult> ToggleActiveAsync(Guid businessId, Guid userId, string actor, Guid id, bool isActive);\n        Task<ResponseResult> DeleteAsync(Guid businessId, Guid userId, string actor, Guid id);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Services/IUnreadCountService.cs",
      "sha256": "a7e51e22be544e5387038cd46027d2a58f968fbe1db1a3d792cde75ac9bfd4de",
      "language": "csharp",
      "size": 272,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Inbox.Services\n{\n    public interface IUnreadCountService\n    {\n        Task<Dictionary<Guid, int>> GetUnreadCountsAsync(Guid businessId, Guid userId);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Services/QuickReplyService.cs",
      "sha256": "594274585168680028dd399dbf8b94c4efa5438224541ec8ee1140c4a2482253",
      "language": "csharp",
      "size": 8104,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing xbytechat.api.Features.Inbox.DTOs;\nusing xbytechat.api.Features.Inbox.Models;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.Inbox.Services\n{\n    public class QuickReplyService : IQuickReplyService\n    {\n        private readonly AppDbContext _db;\n\n        public QuickReplyService(AppDbContext db) => _db = db;\n\n        public async Task<List<QuickReplyDto>> GetAllAsync(Guid businessId, Guid userId,\n            string? search = null, bool includeBusiness = true, bool includePersonal = true)\n        {\n            var q = _db.Set<QuickReply>()\n                .AsNoTracking()\n                .Where(qr => qr.BusinessId == businessId && !qr.IsDeleted && qr.IsActive);\n\n            if (!includeBusiness) q = q.Where(x => x.Scope == QuickReplyScope.Personal);\n            if (!includePersonal) q = q.Where(x => x.Scope == QuickReplyScope.Business);\n            if (includePersonal && includeBusiness == false)\n                q = q.Where(x => x.OwnerUserId == userId || x.Scope == QuickReplyScope.Business);\n            else if (includePersonal)\n                q = q.Where(x => x.Scope == QuickReplyScope.Business || x.OwnerUserId == userId);\n\n            if (!string.IsNullOrWhiteSpace(search))\n            {\n                var s = search.Trim().ToLower();\n                q = q.Where(x =>\n                    x.Title.ToLower().Contains(s) ||\n                    x.Body.ToLower().Contains(s) ||\n                    (x.TagsCsv != null && x.TagsCsv.ToLower().Contains(s)));\n            }\n\n            return await q\n                .OrderByDescending(x => x.Scope)\n                .ThenBy(x => x.Title)\n                .Select(x => new QuickReplyDto\n                {\n                    Id = x.Id,\n                    BusinessId = x.BusinessId,\n                    OwnerUserId = x.OwnerUserId,\n                    Scope = x.Scope,\n                    Title = x.Title,\n                    Body = x.Body,\n                    TagsCsv = x.TagsCsv,\n                    Language = x.Language,\n                    IsActive = x.IsActive,\n                    UpdatedAt = x.UpdatedAt\n                }).ToListAsync();\n        }\n\n        public async Task<ResponseResult> CreateAsync(Guid businessId, Guid userId, string actor, QuickReplyCreateDto dto)\n        {\n            try\n            {\n                var entity = new QuickReply\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    OwnerUserId = dto.Scope == QuickReplyScope.Personal ? userId : null,\n                    Scope = dto.Scope,\n                    Title = dto.Title.Trim(),\n                    Body = dto.Body,\n                    TagsCsv = dto.TagsCsv,\n                    Language = dto.Language,\n                    IsActive = true,\n                    CreatedAt = DateTime.UtcNow,\n                    UpdatedAt = DateTime.UtcNow,\n                    CreatedBy = actor,\n                    UpdatedBy = actor\n                };\n\n                _db.Add(entity);\n                await _db.SaveChangesAsync();\n\n                Log.Information(\"QuickReply created {@QuickReplyId} for business {@BusinessId} by {@Actor}\",\n                    entity.Id, businessId, actor);\n\n                return ResponseResult.SuccessInfo(\"‚úÖ Quick reply created.\");\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"Error creating quick reply for business {BusinessId}\", businessId);\n                return ResponseResult.ErrorInfo(\"‚ùå Failed to create quick reply.\", ex.ToString()); // pattern like Campaign. :contentReference[oaicite:3]{index=3}\n            }\n        }\n\n        public async Task<ResponseResult> UpdateAsync(Guid businessId, Guid userId, string actor, Guid id, QuickReplyUpdateDto dto)\n        {\n            try\n            {\n                var entity = await _db.Set<QuickReply>()\n                    .FirstOrDefaultAsync(x => x.Id == id && x.BusinessId == businessId && !x.IsDeleted);\n\n                if (entity == null)\n                    return ResponseResult.ErrorInfo(\"‚ùå Quick reply not found.\");\n\n                // Only owner can edit personal; business-scope allowed for now\n                if (entity.Scope == QuickReplyScope.Personal && entity.OwnerUserId != userId)\n                    return ResponseResult.ErrorInfo(\"‚õî You cannot edit another user's personal quick reply.\");\n\n                entity.Title = dto.Title.Trim();\n                entity.Body = dto.Body;\n                entity.TagsCsv = dto.TagsCsv;\n                entity.Language = dto.Language;\n                entity.IsActive = dto.IsActive;\n                entity.UpdatedAt = DateTime.UtcNow;\n                entity.UpdatedBy = actor;\n\n                await _db.SaveChangesAsync();\n\n                Log.Information(\"QuickReply updated {@QuickReplyId} for business {@BusinessId} by {@Actor}\",\n                    id, businessId, actor);\n\n                return ResponseResult.SuccessInfo(\"‚úÖ Quick reply updated.\");\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"Error updating quick reply {@QuickReplyId} for business {BusinessId}\", id, businessId);\n                return ResponseResult.ErrorInfo(\"‚ùå Failed to update quick reply.\", ex.ToString()); // campaign-style. :contentReference[oaicite:4]{index=4}\n            }\n        }\n\n        public async Task<ResponseResult> ToggleActiveAsync(Guid businessId, Guid userId, string actor, Guid id, bool isActive)\n        {\n            try\n            {\n                var entity = await _db.Set<QuickReply>()\n                    .FirstOrDefaultAsync(x => x.Id == id && x.BusinessId == businessId && !x.IsDeleted);\n\n                if (entity == null)\n                    return ResponseResult.ErrorInfo(\"‚ùå Quick reply not found.\");\n\n                if (entity.Scope == QuickReplyScope.Personal && entity.OwnerUserId != userId)\n                    return ResponseResult.ErrorInfo(\"‚õî You cannot modify another user's personal quick reply.\");\n\n                entity.IsActive = isActive;\n                entity.UpdatedAt = DateTime.UtcNow;\n                entity.UpdatedBy = actor;\n                await _db.SaveChangesAsync();\n\n                Log.Information(\"QuickReply toggled {@QuickReplyId} -> {IsActive} by {@Actor}\",\n                    id, isActive, actor);\n\n                return ResponseResult.SuccessInfo(isActive ? \"‚úÖ Enabled.\" : \"‚úÖ Disabled.\");\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"Error toggling quick reply {@QuickReplyId}\", id);\n                return ResponseResult.ErrorInfo(\"‚ùå Failed to toggle quick reply.\", ex.ToString());\n            }\n        }\n\n        public async Task<ResponseResult> DeleteAsync(Guid businessId, Guid userId, string actor, Guid id)\n        {\n            try\n            {\n                var entity = await _db.Set<QuickReply>()\n                    .FirstOrDefaultAsync(x => x.Id == id && x.BusinessId == businessId && !x.IsDeleted);\n\n                if (entity == null)\n                    return ResponseResult.ErrorInfo(\"‚ùå Quick reply not found.\");\n\n                if (entity.Scope == QuickReplyScope.Personal && entity.OwnerUserId != userId)\n                    return ResponseResult.ErrorInfo(\"‚õî You cannot delete another user's personal quick reply.\");\n\n                entity.IsDeleted = true;\n                entity.IsActive = false;\n                entity.UpdatedAt = DateTime.UtcNow;\n                entity.UpdatedBy = actor;\n\n                await _db.SaveChangesAsync();\n\n                Log.Information(\"QuickReply soft-deleted {@QuickReplyId} by {@Actor}\", id, actor);\n                return ResponseResult.SuccessInfo(\"üóëÔ∏è Deleted.\");\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"Error deleting quick reply {@QuickReplyId}\", id);\n                return ResponseResult.ErrorInfo(\"‚ùå Failed to delete quick reply.\", ex.ToString());\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Services/UnreadCountService.cs",
      "sha256": "783deeff0e4866ddc454bb9d642e26f173a37a45b82a87ad3f75c6150fdecd74",
      "language": "csharp",
      "size": 1537,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.Inbox.Services\n{\n    public class UnreadCountService : IUnreadCountService\n    {\n        private readonly AppDbContext _db;\n\n        public UnreadCountService(AppDbContext db)\n        {\n            _db = db;\n        }\n\n        public async Task<Dictionary<Guid, int>> GetUnreadCountsAsync(Guid businessId, Guid userId)\n        {\n            if (businessId == Guid.Empty || userId == Guid.Empty)\n                return new Dictionary<Guid, int>();\n\n            var userReads = _db.ContactReads.AsNoTracking()\n                .Where(r => r.BusinessId == businessId && r.UserId == userId);\n\n            var query = _db.MessageLogs.AsNoTracking()\n                .Where(m => m.BusinessId == businessId && m.IsIncoming && m.ContactId != null)\n                .GroupJoin(\n                    userReads,\n                    m => m.ContactId,\n                    r => r.ContactId,\n                    (m, rj) => new { m, rj }\n                )\n                .SelectMany(x => x.rj.DefaultIfEmpty(), (x, r) => new { x.m, r })\n                .Where(x => x.r == null || (x.m.SentAt ?? x.m.CreatedAt) > x.r.LastReadAt)\n                .GroupBy(x => x.m.ContactId!.Value)\n                .Select(g => new { ContactId = g.Key, Count = g.Count() });\n\n            return await query.ToDictionaryAsync(x => x.ContactId, x => x.Count);\n        }\n    }\n}\n\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/SignalR/NameUserIdProvider.cs",
      "sha256": "a634119a30658c1936e6d36db5e2a6a0a715e39bb50651261139ca883a92262b",
      "language": "csharp",
      "size": 810,
      "content": "using Microsoft.AspNetCore.SignalR;\nusing System.Security.Claims;\n\nnamespace xbytechat.api.SignalR\n{\n    public sealed class NameUserIdProvider : IUserIdProvider\n    {\n        public string? GetUserId(HubConnectionContext connection)\n        {\n            var user = connection.User;\n            if (user == null) return null;\n\n            // Prefer NameIdentifier\n            var id = user.FindFirstValue(ClaimTypes.NameIdentifier);\n            if (!string.IsNullOrWhiteSpace(id)) return id;\n\n            // Fallbacks (depending on how JWT was created)\n            id = user.FindFirstValue(\"sub\");\n            if (!string.IsNullOrWhiteSpace(id)) return id;\n\n            id = user.FindFirstValue(\"userId\");\n            if (!string.IsNullOrWhiteSpace(id)) return id;\n\n            return null;\n        }\n    }\n}\n"
    }
  ]
}
