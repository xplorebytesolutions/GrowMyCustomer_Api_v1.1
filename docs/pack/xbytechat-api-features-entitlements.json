{
  "name": "xbytechat-api/Features/Entitlements",
  "generatedAt": "2026-02-11 19:15:17 +00:00",
  "files": [
    {
      "path": "xbytechat-api/Features/Entitlements/Controllers/BusinessPermissionOverridesController.cs",
      "sha256": "35228864f3a058afa42ee724d48b3665982a89b904a064c2d4471dd985d6aa2d",
      "language": "csharp",
      "size": 1898,
      "content": "using System;\nusing System.Security.Claims;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.Entitlements.DTOs;\nusing xbytechat.api.Features.Entitlements.Services;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.Entitlements.Controllers\n{\n    [ApiController]\n    [Route(\"api/admin/businesses/{businessId:guid}/permission-overrides\")]\n    [Authorize(Roles = \"admin,partner,reseller\")]\n    public sealed class BusinessPermissionOverridesController : ControllerBase\n    {\n        private readonly IBusinessPermissionOverrideService _service;\n\n        public BusinessPermissionOverridesController(IBusinessPermissionOverrideService service)\n        {\n            _service = service;\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> Get(Guid businessId)\n        {\n            var rows = await _service.GetAsync(businessId);\n            return Ok(ResponseResult.SuccessInfo(\"‚úÖ Overrides fetched.\", rows));\n        }\n\n        [HttpPost]\n        public async Task<IActionResult> Upsert(Guid businessId, [FromBody] UpsertBusinessPermissionOverrideDto dto)\n        {\n            var actorUserId = GetUserId();\n            var res = await _service.UpsertAsync(businessId, actorUserId, dto);\n            return Ok(res);\n        }\n\n        [HttpDelete(\"{permissionCode}\")]\n        public async Task<IActionResult> Revoke(Guid businessId, string permissionCode)\n        {\n            var actorUserId = GetUserId();\n            var res = await _service.RevokeByPermissionCodeAsync(businessId, actorUserId, permissionCode);\n            return Ok(res);\n        }\n\n        private Guid GetUserId()\n        {\n            var raw = User.FindFirstValue(\"id\") ?? User.FindFirstValue(ClaimTypes.NameIdentifier);\n            return Guid.TryParse(raw, out var id) ? id : Guid.Empty;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Controllers/EntitlementsController.cs",
      "sha256": "0c435fe50cb96bd08c30f57eb23775a506bd85d7555798508742e38ecc668977",
      "language": "csharp",
      "size": 3151,
      "content": "#nullable enable\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.Entitlements.DTOs;\nusing xbytechat.api.Features.Entitlements.Services;\nusing xbytechat.api.Helpers; // ‚úÖ Use shared helpers for claims\n\nnamespace xbytechat.api.Features.Entitlements.Controllers\n{\n    [ApiController]\n    [Route(\"api/entitlements\")]\n    [Authorize]\n    public sealed class EntitlementsController : ControllerBase\n    {\n        private readonly IQuotaService _quota;\n\n        // Roles are stored lower-case in JWT (JwtTokenService),\n        // so we treat \"admin\" and \"superadmin\" as global admins.\n        private const string AdminRoleAdmin = \"admin\";\n        private const string AdminRoleSuperAdmin = \"superadmin\";\n\n        public EntitlementsController(IQuotaService quota)\n        {\n            _quota = quota;\n        }\n\n        // Helpers\n        private Guid? TryGetCallerBusinessId()\n        {\n            // Centralized logic: reads \"businessId\" claim.\n            var id = UserContextHelper.GetBusinessId(User);\n            return id == Guid.Empty ? (Guid?)null : id;\n        }\n\n        private bool IsAdmin()\n        {\n            return User.IsInRole(AdminRoleAdmin) || User.IsInRole(AdminRoleSuperAdmin);\n        }\n\n        private bool IsAuthorizedFor(Guid targetBusinessId)\n        {\n            if (IsAdmin()) return true;\n\n            var callerBiz = TryGetCallerBusinessId();\n            return callerBiz.HasValue && callerBiz.Value == targetBusinessId;\n        }\n\n        // GET /api/entitlements/{businessId}\n        [HttpGet(\"{businessId:guid}\")]\n        public async Task<ActionResult<EntitlementsSnapshotDto>> GetSnapshot(\n            Guid businessId,\n            CancellationToken ct)\n        {\n            if (!IsAuthorizedFor(businessId))\n                return Forbid();\n\n            var dto = await _quota.GetSnapshotAsync(businessId, ct);\n            return Ok(dto);\n        }\n\n        // POST /api/entitlements/{businessId}/check\n        [HttpPost(\"{businessId:guid}/check\")]\n        public async Task<ActionResult<EntitlementResultDto>> Check(\n            Guid businessId,\n            [FromBody] EntitlementCheckDto? req,\n            CancellationToken ct)\n        {\n            if (!IsAuthorizedFor(businessId))\n                return Forbid();\n\n            if (req is null)\n                return BadRequest(\"Request body is required.\");\n\n            if (string.IsNullOrWhiteSpace(req.QuotaKey))\n                return BadRequest(\"QuotaKey required.\");\n\n            var amount = Math.Max(1, req.Amount);\n\n            var result = req.ConsumeOnSuccess\n                ? await _quota.CheckAndConsumeAsync(businessId, req.QuotaKey, amount, ct)\n                : await _quota.CheckAsync(businessId, req.QuotaKey, amount, ct);\n\n            if (!result.Allowed)\n                // 429 payload shape is already what your axios interceptor expects:\n                // { allowed:false, quotaKey, limit, remaining, message }\n                return StatusCode(429, result);\n\n            return Ok(result);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Controllers/PlanQuotasAdminController.cs",
      "sha256": "615f8f0b670d3e8aef239a57b9a5125959a2a63e18f417e08a8b52d2b99da7c3",
      "language": "csharp",
      "size": 5876,
      "content": "// üìÑ Features/Entitlements/Controllers/PlanQuotasAdminController.cs\n#nullable enable\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Entitlements.DTOs;\nusing xbytechat.api.Features.Entitlements.Models;\n\nnamespace xbytechat.api.Features.Entitlements.Controllers\n{\n    /// <summary>\n    /// Admin endpoints to manage default quotas per plan.\n    /// These are the rows in PlanQuotas table.\n    /// </summary>\n    [ApiController]\n    [Route(\"api/admin/plans/{planId:guid}/quotas\")]\n    [Authorize(Roles = \"superadmin,partneradmin,admin\")]\n    public sealed class PlanQuotasAdminController : ControllerBase\n    {\n        private readonly AppDbContext _db;\n\n        public PlanQuotasAdminController(AppDbContext db)\n        {\n            _db = db;\n        }\n\n        // GET /admin/plans/{planId}/quotas\n        [HttpGet]\n        public async Task<ActionResult<List<PlanQuotaDto>>> GetForPlan(\n            Guid planId,\n            CancellationToken ct)\n        {\n            // Validate plan exists (defensive)\n            var planExists = await _db.Plans\n                .AsNoTracking()\n                .AnyAsync(p => p.Id == planId, ct);\n\n            if (!planExists)\n                return NotFound(new { message = \"Plan not found\" });\n\n            var quotas = await _db.PlanQuotas\n                .AsNoTracking()\n                .Where(q => q.PlanId == planId)\n                .OrderBy(q => q.QuotaKey)\n                .Select(q => new PlanQuotaDto\n                {\n                    Id = q.Id,\n                    PlanId = q.PlanId,\n                    QuotaKey = q.QuotaKey,\n                    Limit = q.Limit,\n                    Period = q.Period,\n                    DenialMessage = q.DenialMessage\n                })\n                .ToListAsync(ct);\n\n            return Ok(quotas);\n        }\n\n        // PUT /admin/plans/{planId}/quotas\n        //\n        // Simple \"upsert by QuotaKey\" semantics:\n        // - Existing PlanQuota with same PlanId + QuotaKey is updated\n        // - New QuotaKey rows are inserted\n        // - Quotas not present in payload are kept (no destructive delete here)\n        [HttpPut]\n        public async Task<IActionResult> UpsertForPlan(\n            Guid planId,\n            [FromBody] List<PlanQuotaDto> payload,\n            CancellationToken ct)\n        {\n            if (payload is null)\n                return BadRequest(new { message = \"Payload is required\" });\n\n            // Normalize keys to upper-case for comparisons (used only in-memory)\n            static string Normalize(string key) =>\n                (key ?? string.Empty).Trim().ToUpperInvariant();\n\n            // Ensure plan exists\n            var planExists = await _db.Plans\n                .AsNoTracking()\n                .AnyAsync(p => p.Id == planId, ct);\n\n            if (!planExists)\n                return NotFound(new { message = \"Plan not found\" });\n\n            var incoming = payload\n                .Where(p => !string.IsNullOrWhiteSpace(p.QuotaKey))\n                .Select(p => new\n                {\n                    Raw = p,\n                    NormalizedKey = Normalize(p.QuotaKey!)\n                })\n                .ToList();\n\n            if (!incoming.Any())\n                return BadRequest(new { message = \"At least one quota with a QuotaKey is required.\" });\n\n            var keys = incoming\n                .Select(i => i.NormalizedKey)\n                .Distinct()\n                .ToList();\n\n            // ‚úÖ IMPORTANT: bring data into memory first, then call Normalize\n            var existingAllForPlan = await _db.PlanQuotas\n                .Where(q => q.PlanId == planId)\n                .ToListAsync(ct);\n\n            // optional: only keep rows whose normalized key is in payload keys\n            var existing = existingAllForPlan\n                .Where(q => keys.Contains(Normalize(q.QuotaKey)))\n                .ToList();\n            // üëâ NEW: delete quotas that are no longer present in the payload\n            var toDelete = existingAllForPlan\n                .Where(q => !keys.Contains(Normalize(q.QuotaKey)))\n                .ToList();\n\n            if (toDelete.Count > 0)\n            {\n                _db.PlanQuotas.RemoveRange(toDelete);\n            }\n\n            foreach (var item in incoming)\n            {\n                var dto = item.Raw;\n                var normalizedKey = item.NormalizedKey;\n\n                var entity = existing\n                    .FirstOrDefault(q => Normalize(q.QuotaKey) == normalizedKey);\n\n                if (entity is null)\n                {\n                    // Insert new row\n                    entity = new PlanQuota\n                    {\n                        Id = Guid.NewGuid(),\n                        PlanId = planId,\n                        QuotaKey = normalizedKey,\n                        Limit = dto.Limit,\n                        Period = dto.Period,\n                        DenialMessage = dto.DenialMessage,\n                        CreatedAt = DateTime.UtcNow,\n                        UpdatedAt = DateTime.UtcNow\n                    };\n\n                    _db.PlanQuotas.Add(entity);\n                    existing.Add(entity); // keep in local list too\n                }\n                else\n                {\n                    // Update existing row\n                    entity.QuotaKey = normalizedKey;\n                    entity.Limit = dto.Limit;\n                    entity.Period = dto.Period;\n                    entity.DenialMessage = dto.DenialMessage;\n                    entity.UpdatedAt = DateTime.UtcNow;\n                }\n            }\n\n            await _db.SaveChangesAsync(ct);\n            return NoContent();\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/DTOs/BusinessPermissionOverrideDto.cs",
      "sha256": "4d6d1c3548668dc2d58ec10bdf14d99a0040aa00f17e5b9c221c804ef481dd6e",
      "language": "csharp",
      "size": 561,
      "content": "using System;\n\nnamespace xbytechat.api.Features.Entitlements.DTOs\n{\n    public sealed class BusinessPermissionOverrideDto\n    {\n        public Guid Id { get; set; }\n        public Guid BusinessId { get; set; }\n        public string PermissionCode { get; set; } = \"\";\n        public bool IsGranted { get; set; }\n        public bool IsRevoked { get; set; }\n        public string? Reason { get; set; }\n        public DateTime? ExpiresAtUtc { get; set; }\n        public DateTime CreatedAtUtc { get; set; }\n        public DateTime UpdatedAtUtc { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/DTOs/EntitlementCheckDto.cs",
      "sha256": "e3c6863b705bec9193d677f8cf0d408345f812e955b06ffd375f8ef38d9fcb4f",
      "language": "csharp",
      "size": 1422,
      "content": "using System.Collections.Generic;\n\nnamespace xbytechat.api.Features.Entitlements.DTOs\n{\n    public sealed class EntitlementCheckDto\n    {\n        public string QuotaKey { get; set; } = default!;\n        public long Amount { get; set; } = 1;\n        public bool ConsumeOnSuccess { get; set; } = true;\n    }\n\n    public sealed class EntitlementResultDto\n    {\n        public bool Allowed { get; set; }\n        public string QuotaKey { get; set; } = default!;\n        public long? Limit { get; set; }           // null if unlimited\n        public long? Remaining { get; set; }       // null if unlimited\n        public string? Message { get; set; }\n    }\n\n    public sealed class EntitlementsSnapshotDto\n    {\n        public IEnumerable<string> GrantedPermissions { get; set; } = new List<string>();\n        public IEnumerable<QuotaSnapshotItemDto> Quotas { get; set; } = new List<QuotaSnapshotItemDto>();\n    }\n\n    public sealed class QuotaSnapshotItemDto\n    {\n        public string QuotaKey { get; set; } = default!;\n        public string Period { get; set; } = default!; // \"Daily\"/\"Monthly\"/\"Lifetime\"\n        public long? Limit { get; set; }               // null => unlimited\n        public long Consumed { get; set; }\n        public long? Remaining { get; set; }           // null => unlimited\n        public string? DenialMessage { get; set; }\n        public string WindowStartUtc { get; set; } = default!;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/DTOs/PlanQuotaDto.cs",
      "sha256": "eb3560e2218f3b7d2750e2a68fdf6a3f140f99a35665bf31e9d34671ad1611e3",
      "language": "csharp",
      "size": 738,
      "content": "// üìÑ Features/Entitlements/DTOs/PlanQuotaDto.cs\nusing System;\nusing xbytechat.api.Features.Entitlements.Models;\n\nnamespace xbytechat.api.Features.Entitlements.DTOs\n{\n    /// <summary>\n    /// Admin-facing DTO for default quotas configured per plan.\n    /// </summary>\n    public sealed class PlanQuotaDto\n    {\n        public Guid Id { get; set; }\n\n        public Guid PlanId { get; set; }\n\n        // Canonical key, e.g. \"MESSAGES_PER_MONTH\"\n        public string QuotaKey { get; set; } = string.Empty;\n\n        // -1 => unlimited\n        public long Limit { get; set; }\n\n        public QuotaPeriod Period { get; set; }\n\n        // Optional UX text used when quota is denied\n        public string? DenialMessage { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/DTOs/UpsertBusinessPermissionOverrideDto.cs",
      "sha256": "47e05889e89c82df2a1179abc49c58d3bbbdf5bc41a8ea8b211c4ff7fd41045e",
      "language": "csharp",
      "size": 410,
      "content": "using System;\n\nnamespace xbytechat.api.Features.Entitlements.DTOs\n{\n    public sealed class UpsertBusinessPermissionOverrideDto\n    {\n        public string PermissionCode { get; set; } = \"\";\n        public bool IsGranted { get; set; }           // true = grant, false = deny\n        public string? Reason { get; set; }\n        public DateTime? ExpiresAtUtc { get; set; }   // optional temporary unlock\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Models/BusinessPermissionOverride.cs",
      "sha256": "907872c4ee9b0aa63e85ed3d353d11cee3d8ee71af448f037371e95381d071d4",
      "language": "csharp",
      "size": 2004,
      "content": "using System;\nusing xbytechat.api.Features.AccessControl.Models;\nusing xbytechat.api.Features.BusinessModule.Models;\nusing xbytechat.api.Models.BusinessModel;\n\nnamespace xbytechat.api.Features.Entitlements.Models\n{\n    /// <summary>\n    /// Business-level permission override.\n    /// Used ONLY by internal admins (SuperAdmin/Partner/Reseller) to grant/deny permissions\n    /// beyond plan defaults (VIP, pilots, temporary unlocks).\n    ///\n    /// NOTE:\n    /// - This overrides PLAN-level availability for a business.\n    /// - It still should NOT bypass ROLE limitations when computing \"effective permissions\"\n    ///   for a staff user (we will enforce that in the entitlement calculation step).\n    /// </summary>\n    public sealed class BusinessPermissionOverride\n    {\n        public Guid Id { get; set; } = Guid.NewGuid();\n\n        public Guid BusinessId { get; set; }\n        public Business? Business { get; set; }\n\n        public Guid PermissionId { get; set; }\n        public Permission? Permission { get; set; }\n\n        /// <summary>\n        /// true = grant, false = deny.\n        /// </summary>\n        public bool IsGranted { get; set; }\n\n        /// <summary>\n        /// Soft revoke / disable the override.\n        /// </summary>\n        public bool IsRevoked { get; set; }\n\n        /// <summary>\n        /// Optional reason for auditability (VIP deal, pilot, migration, support).\n        /// </summary>\n        public string? Reason { get; set; }\n\n        /// <summary>\n        /// Optional expiry for temporary unlocks.\n        /// If set and expired, override should be ignored by entitlement computation.\n        /// </summary>\n        public DateTime? ExpiresAtUtc { get; set; }\n\n        /// <summary>\n        /// Who applied this override (admin user id).\n        /// </summary>\n        public Guid? CreatedByUserId { get; set; }\n\n        public DateTime CreatedAtUtc { get; set; } = DateTime.UtcNow;\n        public DateTime UpdatedAtUtc { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Models/BusinessQuotaOverride.cs",
      "sha256": "b1f87eedb2763fc2bb19f50e1a992e2d4adb2e86477ab1f04f0b3bd6f9a17fb6",
      "language": "csharp",
      "size": 848,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace xbytechat.api.Features.Entitlements.Models\n{\n    [Table(\"BusinessQuotaOverrides\")]\n    public sealed class BusinessQuotaOverride\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        [Required]\n        public Guid BusinessId { get; set; }\n\n        [Required, MaxLength(128)]\n        public string QuotaKey { get; set; } = default!; // same key as PlanQuota\n\n        public long? Limit { get; set; }     // null => fallback to plan\n        public bool? IsUnlimited { get; set; } // true => unlimited regardless of plan\n\n        public DateTime? ExpiresAt { get; set; } // null => permanent\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n        public DateTime? UpdatedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Models/BusinessUsageCounter.cs",
      "sha256": "85f37a61b7bf3227782bc452a7088746e129334cf37722d55a788faac363a1fc",
      "language": "csharp",
      "size": 928,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\nusing xbytechat.api.Features.Entitlements.Models;\n\nnamespace xbytechat.api.Features.Entitlements.Models\n{\n    [Table(\"BusinessUsageCounters\")]\n    public sealed class BusinessUsageCounter\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        [Required]\n        public Guid BusinessId { get; set; }\n\n        [Required, MaxLength(128)]\n        public string QuotaKey { get; set; } = default!;\n\n        public QuotaPeriod Period { get; set; }\n\n        // To support resets, store the window start for this counter.\n        public DateTime WindowStartUtc { get; set; }\n\n        // Current consumed units within the window.\n        public long Consumed { get; set; }\n\n        public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Models/PlanQuota.cs",
      "sha256": "215c4b1b07bd49b5499c1f3f1435739fd47ce44cc493aca1925d91e20c441573",
      "language": "csharp",
      "size": 989,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\nusing xbytechat.api.Features.Entitlements.Models;\n\nnamespace xbytechat.api.Features.Entitlements.Models\n{\n    [Table(\"PlanQuotas\")]\n    public sealed class PlanQuota\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        [Required]\n        public Guid PlanId { get; set; } // FK to AccessControl Plan\n\n        // Case-insensitive programmatic key, e.g., \"MessagesPerMonth\"\n        [Required, MaxLength(128)]\n        public string QuotaKey { get; set; } = default!;\n\n        public long Limit { get; set; }            // -1 => unlimited\n        public QuotaPeriod Period { get; set; }    // Daily/Monthly/Lifetime\n\n        // Optional UX copy shown to user on denial\n        [MaxLength(256)]\n        public string? DenialMessage { get; set; }\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n        public DateTime? UpdatedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Models/QuotaPeriod.cs",
      "sha256": "375d8f9e16fc912410137ae6208999b6580602bb4635bd5180e67f40ca8a1da7",
      "language": "csharp",
      "size": 189,
      "content": "namespace xbytechat.api.Features.Entitlements.Models\n{\n    public enum QuotaPeriod\n    {\n        Lifetime = 0,  // never resets automatically\n        Daily = 1,\n        Monthly = 2\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/QuotaKeys.cs",
      "sha256": "14149e987392ec3d22e757e52540d860518860a40a594846459035ec0428eec6",
      "language": "csharp",
      "size": 591,
      "content": "// üìÑ Features/Entitlements/QuotaKeys.cs\nnamespace xbytechat.api.Features.Entitlements\n{\n\n    public static class QuotaKeys\n    {\n        // How many messages a business can send in a given period (usually Monthly)\n        public const string MessagesPerMonth = \"MESSAGES_PER_MONTH\";\n\n        public const string MessagesPerDay = \"MESSAGES_PER_DAY\";\n        // How many campaigns can be sent per day\n        public const string CampaignsPerDay = \"CAMPAIGNS_PER_DAY\";\n\n        // How many templates can exist in total\n        public const string TemplatesTotal = \"TEMPLATES_TOTAL\";\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Seed/EntitlementsSeeder.cs",
      "sha256": "39a6c25c6d3cda63542eea996b67df2e21973a2afb10a93da008b33613f626d5",
      "language": "csharp",
      "size": 1273,
      "content": "using System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Entitlements.Models;\nusing Microsoft.EntityFrameworkCore;\n\nnamespace xbytechat.api.Features.Entitlements.Seed\n{\n    public static class EntitlementsSeeder\n    {\n        public static async Task SeedAsync(AppDbContext db, Guid planId)\n        {\n            var defaults = new[]\n            {\n                new PlanQuota { Id = Guid.NewGuid(), PlanId = planId, QuotaKey = \"MESSAGES_PER_MONTH\", Limit = 10000, Period = QuotaPeriod.Monthly, DenialMessage = \"Monthly message limit reached.\" },\n                new PlanQuota { Id = Guid.NewGuid(), PlanId = planId, QuotaKey = \"CAMPAIGNS_PER_DAY\",   Limit = 10,    Period = QuotaPeriod.Daily,   DenialMessage = \"Daily campaign limit reached.\" },\n                new PlanQuota { Id = Guid.NewGuid(), PlanId = planId, QuotaKey = \"TEMPLATES_TOTAL\",     Limit = -1,    Period = QuotaPeriod.Lifetime } // unlimited\n            };\n\n            foreach (var q in defaults)\n            {\n                var exists = await db.PlanQuotas.AnyAsync(p => p.PlanId == planId && p.QuotaKey.ToUpper() == q.QuotaKey.ToUpper());\n                if (!exists) db.PlanQuotas.Add(q);\n            }\n            await db.SaveChangesAsync();\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Services/BusinessPermissionOverrideService.cs",
      "sha256": "f1476ef9f4df036296db1c58cc8dd4c56abf0bd53d73d89d4539f24a4a506984",
      "language": "csharp",
      "size": 4988,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.Entitlements.DTOs;\nusing xbytechat.api.Features.Entitlements.Models;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.Entitlements.Services\n{\n    public sealed class BusinessPermissionOverrideService : IBusinessPermissionOverrideService\n    {\n        private readonly AppDbContext _db;\n        private readonly ILogger<BusinessPermissionOverrideService> _logger;\n\n        public BusinessPermissionOverrideService(AppDbContext db, ILogger<BusinessPermissionOverrideService> logger)\n        {\n            _db = db;\n            _logger = logger;\n        }\n\n        public async Task<List<BusinessPermissionOverrideDto>> GetAsync(Guid businessId)\n        {\n            var now = DateTime.UtcNow;\n\n            return await _db.BusinessPermissionOverrides\n                .AsNoTracking()\n                .Where(x => x.BusinessId == businessId && !x.IsRevoked)\n                .OrderByDescending(x => x.UpdatedAtUtc)\n                .Select(x => new BusinessPermissionOverrideDto\n                {\n                    Id = x.Id,\n                    BusinessId = x.BusinessId,\n                    PermissionCode = x.Permission!.Code,\n                    IsGranted = x.IsGranted,\n                    IsRevoked = x.IsRevoked,\n                    Reason = x.Reason,\n                    ExpiresAtUtc = x.ExpiresAtUtc,\n                    CreatedAtUtc = x.CreatedAtUtc,\n                    UpdatedAtUtc = x.UpdatedAtUtc\n                })\n                .ToListAsync();\n        }\n\n        public async Task<ResponseResult> UpsertAsync(Guid businessId, Guid actorUserId, UpsertBusinessPermissionOverrideDto dto)\n        {\n            var code = (dto.PermissionCode ?? \"\").Trim();\n            if (string.IsNullOrWhiteSpace(code))\n                return ResponseResult.ErrorInfo(\"‚ùå PermissionCode is required.\");\n\n            var perm = await _db.Permissions.FirstOrDefaultAsync(p => p.IsActive && p.Code == code.ToUpper());\n            if (perm == null)\n                return ResponseResult.ErrorInfo(\"‚ùå Invalid permission code.\");\n\n            var row = await _db.BusinessPermissionOverrides\n                .FirstOrDefaultAsync(x => x.BusinessId == businessId && x.PermissionId == perm.Id);\n\n            if (row == null)\n            {\n                row = new BusinessPermissionOverride\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    PermissionId = perm.Id,\n                    IsGranted = dto.IsGranted,\n                    IsRevoked = false,\n                    Reason = dto.Reason?.Trim(),\n                    ExpiresAtUtc = dto.ExpiresAtUtc,\n                    CreatedByUserId = actorUserId,\n                    CreatedAtUtc = DateTime.UtcNow,\n                    UpdatedAtUtc = DateTime.UtcNow\n                };\n                _db.BusinessPermissionOverrides.Add(row);\n            }\n            else\n            {\n                row.IsGranted = dto.IsGranted;\n                row.IsRevoked = false;\n                row.Reason = dto.Reason?.Trim();\n                row.ExpiresAtUtc = dto.ExpiresAtUtc;\n                row.UpdatedAtUtc = DateTime.UtcNow;\n            }\n\n            await _db.SaveChangesAsync();\n\n            _logger.LogInformation(\"‚úÖ Business permission override upserted. BusinessId={BusinessId}, Permission={Permission}, Granted={Granted}, ActorUserId={ActorUserId}\",\n                businessId, perm.Code, dto.IsGranted, actorUserId);\n\n            return ResponseResult.SuccessInfo(\"‚úÖ Override saved.\");\n        }\n\n        public async Task<ResponseResult> RevokeByPermissionCodeAsync(Guid businessId, Guid actorUserId, string permissionCode)\n        {\n            var code = (permissionCode ?? \"\").Trim();\n            if (string.IsNullOrWhiteSpace(code))\n                return ResponseResult.ErrorInfo(\"‚ùå PermissionCode is required.\");\n\n            var perm = await _db.Permissions.FirstOrDefaultAsync(p => p.IsActive && p.Code == code.ToUpper());\n            if (perm == null)\n                return ResponseResult.ErrorInfo(\"‚ùå Invalid permission code.\");\n\n            var row = await _db.BusinessPermissionOverrides\n                .FirstOrDefaultAsync(x => x.BusinessId == businessId && x.PermissionId == perm.Id && !x.IsRevoked);\n\n            if (row == null)\n                return ResponseResult.ErrorInfo(\"‚ùå Override not found.\");\n\n            row.IsRevoked = true;\n            row.UpdatedAtUtc = DateTime.UtcNow;\n\n            await _db.SaveChangesAsync();\n\n            _logger.LogInformation(\"‚úÖ Business permission override revoked. BusinessId={BusinessId}, Permission={Permission}, ActorUserId={ActorUserId}\",\n                businessId, perm.Code, actorUserId);\n\n            return ResponseResult.SuccessInfo(\"‚úÖ Override revoked.\");\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Services/IBusinessPermissionOverrideService.cs",
      "sha256": "39241c7ba297699b2f42ead4ecbf93f50ac5e3c1de7a5301519a5e43b9753641",
      "language": "csharp",
      "size": 594,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Entitlements.DTOs;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.Entitlements.Services\n{\n    public interface IBusinessPermissionOverrideService\n    {\n        Task<List<BusinessPermissionOverrideDto>> GetAsync(Guid businessId);\n        Task<ResponseResult> UpsertAsync(Guid businessId, Guid actorUserId, UpsertBusinessPermissionOverrideDto dto);\n        Task<ResponseResult> RevokeByPermissionCodeAsync(Guid businessId, Guid actorUserId, string permissionCode);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Services/IQuotaService.cs",
      "sha256": "55c9229cb163efbc7ef1621a7f2fa061a1299f8b85046402a2e3708327f41648",
      "language": "csharp",
      "size": 784,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Entitlements.DTOs;\n\nnamespace xbytechat.api.Features.Entitlements.Services\n{\n    public interface IQuotaService\n    {\n        Task<EntitlementResultDto> CheckAsync(Guid businessId, string quotaKey, long amount, CancellationToken ct);\n        Task<EntitlementResultDto> CheckAndConsumeAsync(Guid businessId, string quotaKey, long amount, CancellationToken ct);\n\n        Task<EntitlementsSnapshotDto> GetSnapshotAsync(Guid businessId, CancellationToken ct);\n\n        // Utility to ensure counters are on the correct window (creates or rolls window if needed)\n        Task EnsureWindowAsync(Guid businessId, string quotaKey, CancellationToken ct);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Services/QuotaService.cs",
      "sha256": "40ae3242c46c1445b58726fcc9f0e2c46511b0ca1a783eb400f57767329879aa",
      "language": "csharp",
      "size": 15037,
      "content": "using System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Entitlements.DTOs;\nusing xbytechat.api.Features.Entitlements.Models;\nusing xbytechat.api.Features.Entitlements.Services;\nusing xbytechat.api.Features.AccessControl.Models; // your Plan/PlanPermission namespace as applicable\n\nnamespace xbytechat.api.Features.Entitlements.Services\n{\n    public sealed class QuotaService : IQuotaService\n    {\n        private readonly AppDbContext _db;\n\n        public QuotaService(AppDbContext db)\n        {\n            _db = db;\n        }\n\n        // Normalize keys to uppercase to keep lookups stable on non-CI collations\n        private static string NK(string key) => key.Trim().ToUpperInvariant();\n\n        private static DateTime CurrentWindowStartUtc(QuotaPeriod p, DateTime nowUtc)\n        {\n            return p switch\n            {\n                QuotaPeriod.Daily => new DateTime(nowUtc.Year, nowUtc.Month, nowUtc.Day, 0, 0, 0, DateTimeKind.Utc),\n                QuotaPeriod.Monthly => new DateTime(nowUtc.Year, nowUtc.Month, 1, 0, 0, 0, DateTimeKind.Utc),\n                _ => DateTime.UnixEpoch\n            };\n        }\n\n        private async Task<(QuotaPeriod Period, long? Limit, string? Denial)> ResolveEffectiveLimitAsync(Guid businessId, string quotaKey, CancellationToken ct)\n        {\n            quotaKey = NK(quotaKey);\n\n            // resolve business planId\n            var business = await _db.Businesses\n                .AsNoTracking()\n                .Where(b => b.Id == businessId)\n                .Select(b => new { b.Id, b.PlanId })\n                .FirstOrDefaultAsync(ct);\n\n            if (business is null)\n                return (QuotaPeriod.Lifetime, 0, \"Business not found.\");\n\n            // override first\n            var ovr = await _db.BusinessQuotaOverrides\n                .AsNoTracking()\n                .Where(o => o.BusinessId == businessId && o.QuotaKey.ToUpper() == quotaKey)\n                .FirstOrDefaultAsync(ct);\n\n            if (ovr is not null && (ovr.ExpiresAt == null || ovr.ExpiresAt > DateTime.UtcNow))\n            {\n                if (ovr.IsUnlimited == true)\n                    return (QuotaPeriod.Lifetime, null, null); // unlimited\n\n                if (ovr.Limit.HasValue)\n                {\n                    // Need period: fall back to plan period (must exist)\n                    var pq = await _db.PlanQuotas.AsNoTracking()\n                        .Where(p => p.PlanId == business.PlanId && p.QuotaKey.ToUpper() == quotaKey)\n                        .Select(p => new { p.Period, p.DenialMessage })\n                        .FirstOrDefaultAsync(ct);\n\n                    if (pq is null)\n                        return (QuotaPeriod.Lifetime, ovr.Limit!.Value, null); // custom limit without period -> treat as lifetime\n\n                    return (pq.Period, ovr.Limit!.Value, pq.DenialMessage);\n                }\n                // if override exists but no limit/isUnlimited set, fall back to plan\n            }\n\n            // plan default\n            var planQuota = await _db.PlanQuotas.AsNoTracking()\n                .Where(p => p.PlanId == business.PlanId && p.QuotaKey.ToUpper() == quotaKey)\n                .FirstOrDefaultAsync(ct);\n\n            if (planQuota is null)\n                return (QuotaPeriod.Lifetime, 0, \"Quota not defined for plan.\"); // deny by default\n\n            if (planQuota.Limit < 0)\n                return (planQuota.Period, null, planQuota.DenialMessage); // unlimited\n\n            return (planQuota.Period, planQuota.Limit, planQuota.DenialMessage);\n        }\n\n        private async Task<BusinessUsageCounter> GetOrCreateCounterAsync(Guid businessId, string quotaKey, QuotaPeriod period, CancellationToken ct)\n        {\n            quotaKey = NK(quotaKey);\n            var now = DateTime.UtcNow;\n            var winStart = CurrentWindowStartUtc(period, now);\n\n            var counter = await _db.BusinessUsageCounters.FirstOrDefaultAsync(\n                c => c.BusinessId == businessId && c.QuotaKey.ToUpper() == quotaKey &&\n                     c.Period == period && c.WindowStartUtc == winStart, ct);\n\n            if (counter is not null) return counter;\n\n            counter = new BusinessUsageCounter\n            {\n                Id = Guid.NewGuid(),\n                BusinessId = businessId,\n                QuotaKey = quotaKey,\n                Period = period,\n                WindowStartUtc = winStart,\n                Consumed = 0,\n                CreatedAt = now,\n                UpdatedAt = now\n            };\n            _db.BusinessUsageCounters.Add(counter);\n\n            try\n            {\n                await _db.SaveChangesAsync(ct);\n                return counter;\n            }\n            catch (DbUpdateException)\n            {\n                // Another thread created it; fetch the existing row\n                return await _db.BusinessUsageCounters.FirstAsync(\n                    c => c.BusinessId == businessId && c.QuotaKey.ToUpper() == quotaKey &&\n                         c.Period == period && c.WindowStartUtc == winStart, ct);\n            }\n        }\n\n        public async Task EnsureWindowAsync(Guid businessId, string quotaKey, CancellationToken ct)\n        {\n            var (period, _, _) = await ResolveEffectiveLimitAsync(businessId, quotaKey, ct);\n            await GetOrCreateCounterAsync(businessId, quotaKey, period, ct);\n        }\n\n        public async Task<EntitlementResultDto> CheckAsync(Guid businessId, string quotaKey, long amount, CancellationToken ct)\n        {\n            quotaKey = NK(quotaKey);\n            var (period, limit, denial) = await ResolveEffectiveLimitAsync(businessId, quotaKey, ct);\n\n            if (limit is null) // unlimited\n            {\n                return new EntitlementResultDto\n                {\n                    Allowed = true,\n                    QuotaKey = quotaKey,\n                    Limit = null,\n                    Remaining = null\n                };\n            }\n\n            var counter = await GetOrCreateCounterAsync(businessId, quotaKey, period, ct);\n\n            var remaining = limit.Value - counter.Consumed;\n            var allowed = remaining >= amount;\n\n            return new EntitlementResultDto\n            {\n                Allowed = allowed,\n                QuotaKey = quotaKey,\n                Limit = limit.Value,\n                Remaining = Math.Max(0, remaining),\n                Message = allowed ? null : (denial ?? \"Quota limit reached.\")\n            };\n        }\n\n        public async Task<EntitlementResultDto> CheckAndConsumeAsync(Guid businessId, string quotaKey, long amount, CancellationToken ct)\n        {\n            quotaKey = NK(quotaKey);\n            var (period, limit, denial) = await ResolveEffectiveLimitAsync(businessId, quotaKey, ct);\n\n            if (limit is null) // unlimited\n            {\n                // No increment needed; still return success\n                return new EntitlementResultDto { Allowed = true, QuotaKey = quotaKey, Limit = null, Remaining = null };\n            }\n\n            var now = DateTime.UtcNow;\n            var winStart = CurrentWindowStartUtc(period, now);\n\n            // Atomic consume in a single SQL statement\n            // UPDATE ... SET Consumed = Consumed + @amount WHERE ... AND Consumed + @amount <= @limit\n            var updated = await _db.BusinessUsageCounters\n                .Where(c =>\n                    c.BusinessId == businessId &&\n                    c.QuotaKey.ToUpper() == quotaKey &&\n                    c.Period == period &&\n                    c.WindowStartUtc == winStart &&\n                    c.Consumed + amount <= limit.Value)\n                .ExecuteUpdateAsync(up =>\n                    up.SetProperty(c => c.Consumed, c => c.Consumed + amount)\n                      .SetProperty(c => c.UpdatedAt, _ => now), ct);\n\n            if (updated == 0)\n            {\n                // Ensure the row exists; if missing, create and retry once\n                var existed = await _db.BusinessUsageCounters.AnyAsync(c =>\n                    c.BusinessId == businessId &&\n                    c.QuotaKey.ToUpper() == quotaKey &&\n                    c.Period == period &&\n                    c.WindowStartUtc == winStart, ct);\n\n                if (!existed)\n                {\n                    var counter = new BusinessUsageCounter\n                    {\n                        Id = Guid.NewGuid(),\n                        BusinessId = businessId,\n                        QuotaKey = quotaKey,\n                        Period = period,\n                        WindowStartUtc = winStart,\n                        Consumed = 0,\n                        CreatedAt = now,\n                        UpdatedAt = now\n                    };\n                    _db.BusinessUsageCounters.Add(counter);\n                    await _db.SaveChangesAsync(ct);\n\n                    // retry atomic consume\n                    updated = await _db.BusinessUsageCounters\n                        .Where(c =>\n                            c.BusinessId == businessId &&\n                            c.QuotaKey.ToUpper() == quotaKey &&\n                            c.Period == period &&\n                            c.WindowStartUtc == winStart &&\n                            c.Consumed + amount <= limit.Value)\n                        .ExecuteUpdateAsync(up =>\n                            up.SetProperty(c => c.Consumed, c => c.Consumed + amount)\n                              .SetProperty(c => c.UpdatedAt, _ => now), ct);\n                }\n            }\n\n            if (updated == 0)\n            {\n                // Denied\n                var current = await _db.BusinessUsageCounters.AsNoTracking()\n                    .Where(c =>\n                        c.BusinessId == businessId &&\n                        c.QuotaKey.ToUpper() == quotaKey &&\n                        c.Period == period &&\n                        c.WindowStartUtc == winStart)\n                    .Select(c => c.Consumed)\n                    .FirstOrDefaultAsync(ct);\n\n                var remaining = Math.Max(0, limit.Value - current);\n\n                return new EntitlementResultDto\n                {\n                    Allowed = false,\n                    QuotaKey = quotaKey,\n                    Limit = limit.Value,\n                    Remaining = remaining,\n                    Message = denial ?? \"Quota limit reached.\"\n                };\n            }\n\n            // Success path‚Äîfetch updated consumed to compute remaining\n            var consumed = await _db.BusinessUsageCounters.AsNoTracking()\n                .Where(c =>\n                    c.BusinessId == businessId &&\n                    c.QuotaKey.ToUpper() == quotaKey &&\n                    c.Period == period &&\n                    c.WindowStartUtc == winStart)\n                .Select(c => c.Consumed)\n                .FirstAsync(ct);\n\n            return new EntitlementResultDto\n            {\n                Allowed = true,\n                QuotaKey = quotaKey,\n                Limit = limit.Value,\n                Remaining = Math.Max(0, limit.Value - consumed)\n            };\n        }\n\n        public async Task<EntitlementsSnapshotDto> GetSnapshotAsync(Guid businessId, CancellationToken ct)\n        {\n            // Resolve plan once\n            var planId = await _db.Businesses.AsNoTracking()\n                .Where(b => b.Id == businessId)\n                .Select(b => b.PlanId)\n                .FirstAsync(ct);\n\n            var now = DateTime.UtcNow;\n\n            // ‚úÖ Permission codes for this plan (base)\n            var planPerms = await _db.PlanPermissions\n                .AsNoTracking()\n                .Where(pp => pp.PlanId == planId && pp.IsActive && pp.Permission.IsActive)\n                .Select(pp => pp.Permission.Code)\n                .ToListAsync(ct);\n\n            // ‚úÖ Make it mutable + deduped\n            var grantedSet = new HashSet<string>(planPerms, StringComparer.OrdinalIgnoreCase);\n\n            // ‚úÖ Apply BUSINESS permission overrides (grant adds, deny removes)\n            // Keeps /entitlements snapshot aligned with JWT minting logic in AuthService\n            var permOverrides = await _db.BusinessPermissionOverrides\n                .AsNoTracking()\n                .Where(o =>\n                    o.BusinessId == businessId &&\n                    !o.IsRevoked &&\n                    (o.ExpiresAtUtc == null || o.ExpiresAtUtc > now) &&\n                    o.Permission.IsActive)\n                .Select(o => new\n                {\n                    Code = o.Permission.Code,\n                    o.IsGranted\n                })\n                .ToListAsync(ct);\n\n            foreach (var o in permOverrides)\n            {\n                if (string.IsNullOrWhiteSpace(o.Code)) continue;\n\n                if (o.IsGranted)\n                    grantedSet.Add(o.Code);\n                else\n                    grantedSet.Remove(o.Code);\n            }\n\n            // Quotas ‚Äì sequential to avoid DbContext concurrency issues\n            var planQuotas = await _db.PlanQuotas.AsNoTracking()\n                .Where(pq => pq.PlanId == planId)\n                .ToListAsync(ct);\n\n            var overrides = await _db.BusinessQuotaOverrides.AsNoTracking()\n                .Where(o => o.BusinessId == businessId &&\n                            (o.ExpiresAt == null || o.ExpiresAt > now))\n                .ToListAsync(ct);\n\n            var items = new List<QuotaSnapshotItemDto>();\n\n            foreach (var pq in planQuotas)\n            {\n                var key = NK(pq.QuotaKey);\n\n                long? limit = overrides.FirstOrDefault(o => NK(o.QuotaKey) == key) is { } o\n                    ? (o.IsUnlimited == true ? null : o.Limit ?? (pq.Limit < 0 ? (long?)null : pq.Limit))\n                    : (pq.Limit < 0 ? (long?)null : pq.Limit);\n\n                var winStart = CurrentWindowStartUtc(pq.Period, now);\n\n                var consumed = await _db.BusinessUsageCounters.AsNoTracking()\n                    .Where(c => c.BusinessId == businessId &&\n                                c.QuotaKey.ToUpper() == key &&\n                                c.Period == pq.Period &&\n                                c.WindowStartUtc == winStart)\n                    .Select(c => c.Consumed)\n                    .FirstOrDefaultAsync(ct);\n\n                items.Add(new QuotaSnapshotItemDto\n                {\n                    QuotaKey = key,\n                    Period = pq.Period.ToString(),\n                    Limit = limit,\n                    Consumed = consumed,\n                    Remaining = limit is null ? null : Math.Max(0, limit.Value - consumed),\n                    DenialMessage = pq.DenialMessage,\n                    WindowStartUtc = winStart.ToString(\"u\")\n                });\n            }\n\n            return new EntitlementsSnapshotDto\n            {\n                GrantedPermissions = grantedSet.OrderBy(x => x).ToList(),\n                Quotas = items\n            };\n        }\n\n\n    }\n}\n"
    }
  ]
}
