{
  "name": "xbytechat-api/Features/AccessControl",
  "generatedAt": "2026-02-11 19:15:17 +00:00",
  "files": [
    {
      "path": "xbytechat-api/Features/AccessControl/BusinessRolePermissions/Controllers/BusinessRolePermissionsController.cs",
      "sha256": "7acb74fa2c5be573a4c15e5416ade17859d09fe4251d30b4f1c714a1799058cd",
      "language": "csharp",
      "size": 2624,
      "content": "using System;\nusing System.Security.Claims;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.AccessControl.BusinessRolePermissions.DTOs;\nusing xbytechat.api.Features.AccessControl.BusinessRolePermissions.Services;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.AccessControl.BusinessRolePermissions.Controllers\n{\n    [ApiController]\n    [Route(\"api/accesscontrol/business-roles/{roleId:guid}/permissions\")]\n    [Authorize]\n    //[Authorize(Policy = Policies.AdminOrOwner)]\n    public sealed class BusinessRolePermissionsController : ControllerBase\n    {\n        private readonly IBusinessRolePermissionsService _service;\n\n        public BusinessRolePermissionsController(IBusinessRolePermissionsService service)\n        {\n            _service = service;\n        }\n\n        private Guid GetBusinessId()\n        {\n            var raw =\n                User.FindFirstValue(\"BusinessId\") ??\n                User.FindFirstValue(\"businessId\") ??\n                User.FindFirstValue(\"bid\");\n\n            if (Guid.TryParse(raw, out var id)) return id;\n\n            throw new UnauthorizedAccessException(\"BusinessId claim missing.\");\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> Get([FromRoute] Guid roleId)\n        {\n            var businessId = GetBusinessId();\n\n            try\n            {\n                var res = await _service.GetAsync(businessId, roleId);\n                return Ok(ResponseResult.SuccessInfo(\"âœ… Role permissions fetched.\", res));\n            }\n            catch (KeyNotFoundException)\n            {\n                return NotFound(ResponseResult.ErrorInfo(\"Role not found.\"));\n            }\n            catch (InvalidOperationException ex)\n            {\n                return Conflict(ResponseResult.ErrorInfo(ex.Message));\n            }\n        }\n\n        [HttpPut]\n        public async Task<IActionResult> Replace([FromRoute] Guid roleId, [FromBody] UpdateBusinessRolePermissionsDto dto)\n        {\n            var businessId = GetBusinessId();\n\n            try\n            {\n                var res = await _service.ReplaceAsync(businessId, roleId, dto);\n                return Ok(ResponseResult.SuccessInfo(\"âœ… Role permissions updated.\", res));\n            }\n            catch (KeyNotFoundException)\n            {\n                return NotFound(ResponseResult.ErrorInfo(\"Role not found.\"));\n            }\n            catch (InvalidOperationException ex)\n            {\n                return Conflict(ResponseResult.ErrorInfo(ex.Message));\n            }\n        }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/BusinessRolePermissions/DTOs/BusinessRolePermissionsDto.cs",
      "sha256": "154b92d362a82f5fe4fce5f6cea860b984076ea48ff02054e3322ef1576b2bbb",
      "language": "csharp",
      "size": 300,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.AccessControl.BusinessRolePermissions.DTOs\n{\n    public sealed class BusinessRolePermissionsDto\n    {\n        public Guid RoleId { get; set; }\n        public List<string> PermissionCodes { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/BusinessRolePermissions/DTOs/UpdateBusinessRolePermissionsDto.cs",
      "sha256": "e4c99a793bd37931757c2cdf76ecf546b58eb99dbe1a6aa0da22761829ad9838",
      "language": "csharp",
      "size": 315,
      "content": "using System.Collections.Generic;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.AccessControl.BusinessRolePermissions.DTOs\n{\n    public sealed class UpdateBusinessRolePermissionsDto\n    {\n        [Required]\n        public List<string> PermissionCodes { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/BusinessRolePermissions/Services/BusinessRolePermissionsService.cs",
      "sha256": "cb7da8667cf3509042541fafda8d111e78d6473c6509f46307c337fd2890024d",
      "language": "csharp",
      "size": 4260,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.AccessControl.BusinessRolePermissions.DTOs;\n\nnamespace xbytechat.api.Features.AccessControl.BusinessRolePermissions.Services\n{\n    public sealed class BusinessRolePermissionsService : IBusinessRolePermissionsService\n    {\n        private readonly AppDbContext _db;\n\n        public BusinessRolePermissionsService(AppDbContext db)\n        {\n            _db = db;\n        }\n\n        public async Task<BusinessRolePermissionsDto> GetAsync(Guid businessId, Guid roleId)\n        {\n            // Ensure role belongs to this business and is not a system role\n            var role = await _db.Roles.AsNoTracking()\n                .Where(r => r.Id == roleId && r.BusinessId == businessId)\n                .Select(r => new { r.Id, r.BusinessId })\n                .FirstOrDefaultAsync();\n\n            if (role == null)\n                throw new KeyNotFoundException(\"Role not found.\");\n\n            if (role.BusinessId == null)\n                throw new InvalidOperationException(\"System role permissions cannot be managed here.\");\n\n            var codes = await _db.RolePermissions.AsNoTracking()\n                .Where(rp => rp.RoleId == roleId)\n                .Join(_db.Permissions.AsNoTracking(),\n                      rp => rp.PermissionId,\n                      p => p.Id,\n                      (rp, p) => p.Code)\n                .Distinct()\n                .OrderBy(x => x)\n                .ToListAsync();\n\n            return new BusinessRolePermissionsDto\n            {\n                RoleId = roleId,\n                PermissionCodes = codes\n            };\n        }\n\n        public async Task<BusinessRolePermissionsDto> ReplaceAsync(Guid businessId, Guid roleId, UpdateBusinessRolePermissionsDto dto)\n        {\n            var role = await _db.Roles\n                .Where(r => r.Id == roleId && r.BusinessId == businessId)\n                .FirstOrDefaultAsync();\n\n            if (role == null)\n                throw new KeyNotFoundException(\"Role not found.\");\n\n            if (role.BusinessId == null)\n                throw new InvalidOperationException(\"System role permissions cannot be managed here.\");\n\n            // Normalize codes (trim + distinct + uppercase optional)\n            var requestedCodes = (dto.PermissionCodes ?? new List<string>())\n                .Select(x => (x ?? \"\").Trim())\n                .Where(x => !string.IsNullOrWhiteSpace(x))\n                .Distinct(StringComparer.OrdinalIgnoreCase)\n                .ToList();\n\n            // Validate permission codes exist\n            var perms = await _db.Permissions.AsNoTracking()\n                .Where(p => requestedCodes.Contains(p.Code))\n                .Select(p => new { p.Id, p.Code })\n                .ToListAsync();\n\n            var foundCodes = perms.Select(p => p.Code).ToHashSet(StringComparer.OrdinalIgnoreCase);\n            var missing = requestedCodes.Where(c => !foundCodes.Contains(c)).ToList();\n            if (missing.Count > 0)\n                throw new InvalidOperationException($\"Unknown permission codes: {string.Join(\", \", missing)}\");\n\n            // Replace mappings in one transaction\n            await using var tx = await _db.Database.BeginTransactionAsync();\n\n            var old = await _db.RolePermissions\n                .Where(rp => rp.RoleId == roleId)\n                .ToListAsync();\n\n            if (old.Count > 0)\n                _db.RolePermissions.RemoveRange(old);\n\n            if (perms.Count > 0)\n            {\n                var newRows = perms.Select(p => new Models.RolePermission\n                {\n                    Id = Guid.NewGuid(),\n                    RoleId = roleId,\n                    PermissionId = p.Id,\n                    AssignedAt = DateTime.UtcNow\n                }).ToList();\n\n                await _db.RolePermissions.AddRangeAsync(newRows);\n            }\n\n            await _db.SaveChangesAsync();\n            await tx.CommitAsync();\n\n            return new BusinessRolePermissionsDto\n            {\n                RoleId = roleId,\n                PermissionCodes = perms.Select(p => p.Code).OrderBy(x => x).ToList()\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/BusinessRolePermissions/Services/IBusinessRolePermissionsService.cs",
      "sha256": "78f9809b6d3b958490dbf89094e2d16d43d1e31ad315d271ebfd847ec4cf2479",
      "language": "csharp",
      "size": 471,
      "content": "using System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.AccessControl.BusinessRolePermissions.DTOs;\n\nnamespace xbytechat.api.Features.AccessControl.BusinessRolePermissions.Services\n{\n    public interface IBusinessRolePermissionsService\n    {\n        Task<BusinessRolePermissionsDto> GetAsync(Guid businessId, Guid roleId);\n        Task<BusinessRolePermissionsDto> ReplaceAsync(Guid businessId, Guid roleId, UpdateBusinessRolePermissionsDto dto);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/BusinessRoles/Controllers/BusinessRolesController.cs",
      "sha256": "449be1b4eefc0b2c89e0fc079845987f1fff9186bfcde58edcfa10546061b994",
      "language": "csharp",
      "size": 3927,
      "content": "using System;\nusing System.Security.Claims;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.AccessControl.BusinessRoles.DTOs;\nusing xbytechat.api.Features.AccessControl.BusinessRoles.Services;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.AccessControl.BusinessRoles.Controllers\n{\n\n    [ApiController]\n    [Route(\"api/accesscontrol/business-roles\")]\n    [Authorize]\n    //[Authorize(Policy = Policies.AdminOrOwner)]\n    public sealed class BusinessRolesController : ControllerBase\n    {\n        private readonly IBusinessRoleService _service;\n\n        public BusinessRolesController(IBusinessRoleService service)\n        {\n            _service = service;\n        }\n\n        // âœ… IMPORTANT:\n        // Replace this with your existing \"get businessId from claims\" helper if you already have one.\n        private Guid GetBusinessId()\n        {\n            var raw =\n                User.FindFirstValue(\"BusinessId\") ??\n                User.FindFirstValue(\"businessId\") ??\n                User.FindFirstValue(\"bid\");\n\n            if (Guid.TryParse(raw, out var id)) return id;\n\n            throw new UnauthorizedAccessException(\"BusinessId claim missing.\");\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> GetAll([FromQuery] bool includeInactive = false)\n        {\n            var businessId = GetBusinessId();\n            var rows = await _service.GetAllAsync(businessId, includeInactive);\n            return Ok(ResponseResult.SuccessInfo(\"âœ… Roles fetched.\", rows));\n        }\n\n        [HttpGet(\"{id:guid}\")]\n        public async Task<IActionResult> GetById([FromRoute] Guid id)\n        {\n            var businessId = GetBusinessId();\n            var row = await _service.GetByIdAsync(businessId, id);\n            if (row == null)\n                return NotFound(ResponseResult.ErrorInfo(\"Role not found.\"));\n            return Ok(ResponseResult.SuccessInfo(\"âœ… Role fetched.\", row));\n        }\n\n        [HttpPost]\n        public async Task<IActionResult> Create([FromBody] BusinessRoleCreateDto dto)\n        {\n            var businessId = GetBusinessId();\n\n            try\n            {\n                var created = await _service.CreateAsync(businessId, dto);\n                return Ok(ResponseResult.SuccessInfo(\"âœ… Role created.\", created));\n            }\n            catch (InvalidOperationException ex)\n            {\n                return Conflict(ResponseResult.ErrorInfo(ex.Message));\n            }\n        }\n\n        [HttpPut(\"{id:guid}\")]\n        public async Task<IActionResult> Update([FromRoute] Guid id, [FromBody] BusinessRoleUpdateDto dto)\n        {\n            var businessId = GetBusinessId();\n\n            try\n            {\n                var updated = await _service.UpdateAsync(businessId, id, dto);\n                return Ok(ResponseResult.SuccessInfo(\"âœ… Role updated.\", updated));\n            }\n            catch (KeyNotFoundException)\n            {\n                return NotFound(ResponseResult.ErrorInfo(\"Role not found.\"));\n            }\n            catch (InvalidOperationException ex)\n            {\n                return Conflict(ResponseResult.ErrorInfo(ex.Message));\n            }\n        }\n\n        [HttpDelete(\"{id:guid}\")]\n        public async Task<IActionResult> Deactivate([FromRoute] Guid id)\n        {\n            var businessId = GetBusinessId();\n\n            try\n            {\n                await _service.DeactivateAsync(businessId, id);\n                return Ok(ResponseResult.SuccessInfo(\"âœ… Role deactivated.\", null));\n            }\n            catch (KeyNotFoundException)\n            {\n                return NotFound(ResponseResult.ErrorInfo(\"Role not found.\"));\n            }\n            catch (InvalidOperationException ex)\n            {\n                return Conflict(ResponseResult.ErrorInfo(ex.Message));\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/BusinessRoles/DTOs/BusinessRoleCreateDto.cs",
      "sha256": "a4473be42d9dc9546ed28cf309bfd9562a1a276e0231c67ac10d9d937147d784",
      "language": "csharp",
      "size": 339,
      "content": "using System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.AccessControl.BusinessRoles.DTOs\n{\n    public sealed class BusinessRoleCreateDto\n    {\n        [Required]\n        [MaxLength(50)]\n        public string Name { get; set; } = \"\";\n\n        [MaxLength(200)]\n        public string? Description { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/BusinessRoles/DTOs/BusinessRoleDto.cs",
      "sha256": "a7659cf36e346e9f869a01332ca13c910e6b30cdecbedbbd73604658ea3fe346",
      "language": "csharp",
      "size": 362,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AccessControl.BusinessRoles.DTOs\n{\n    public sealed class BusinessRoleDto\n    {\n        public Guid Id { get; set; }\n        public string Name { get; set; } = \"\";\n        public string? Description { get; set; }\n        public bool IsActive { get; set; }\n        public DateTime CreatedAt { get; set; }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/BusinessRoles/DTOs/BusinessRoleUpdateDto.cs",
      "sha256": "c783b3bbee6bd149cb7f00ee0a35b15e0eb886bf5fe67e0abcbccbde16008630",
      "language": "csharp",
      "size": 339,
      "content": "using System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.AccessControl.BusinessRoles.DTOs\n{\n    public sealed class BusinessRoleUpdateDto\n    {\n        [Required]\n        [MaxLength(50)]\n        public string Name { get; set; } = \"\";\n\n        [MaxLength(200)]\n        public string? Description { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/BusinessRoles/Services/BusinessRoleService.cs",
      "sha256": "40051f334cd81d618fb6d659ac0ef5d657832b3cedf1367e5b915b63fbe0b5f4",
      "language": "csharp",
      "size": 4855,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.AccessControl.BusinessRoles.DTOs;\nusing xbytechat.api.Features.AccessControl.Models;\nusing xbytechat.api.Models; // Role model lives here in most projects\n\nnamespace xbytechat.api.Features.AccessControl.BusinessRoles.Services\n{\n    public sealed class BusinessRoleService : IBusinessRoleService\n    {\n        private readonly AppDbContext _db;\n\n        public BusinessRoleService(AppDbContext db)\n        {\n            _db = db;\n        }\n\n        public async Task<List<BusinessRoleDto>> GetAllAsync(Guid businessId, bool includeInactive = false)\n        {\n            var q = _db.Roles.AsNoTracking()\n                .Where(r => r.BusinessId == businessId);\n\n            if (!includeInactive)\n                q = q.Where(r => r.IsActive);\n\n            var rows = await q\n                .OrderBy(r => r.Name)\n                .Select(r => new BusinessRoleDto\n                {\n                    Id = r.Id,\n                    Name = r.Name,\n                    Description = r.Description,\n                    IsActive = r.IsActive,\n                    CreatedAt = r.CreatedAt\n                })\n                .ToListAsync();\n\n            return rows;\n        }\n\n        public async Task<BusinessRoleDto?> GetByIdAsync(Guid businessId, Guid roleId)\n        {\n            return await _db.Roles.AsNoTracking()\n                .Where(r => r.Id == roleId && r.BusinessId == businessId)\n                .Select(r => new BusinessRoleDto\n                {\n                    Id = r.Id,\n                    Name = r.Name,\n                    Description = r.Description,\n                    IsActive = r.IsActive,\n                    CreatedAt = r.CreatedAt\n                })\n                .FirstOrDefaultAsync();\n        }\n\n        public async Task<BusinessRoleDto> CreateAsync(Guid businessId, BusinessRoleCreateDto dto)\n        {\n            var name = dto.Name.Trim();\n\n            // Industry-grade: protect system roles (BusinessId == null) from being created/edited here\n            var role = new Role\n            {\n                Id = Guid.NewGuid(),\n                BusinessId = businessId,\n                Name = name,\n                Description = dto.Description?.Trim(),\n                IsActive = true,\n                CreatedAt = DateTime.UtcNow\n            };\n\n            _db.Roles.Add(role);\n\n            try\n            {\n                await _db.SaveChangesAsync();\n            }\n            catch (DbUpdateException)\n            {\n                // Likely your unique index (BusinessId + Name where IsActive=true)\n                throw new InvalidOperationException($\"Role '{name}' already exists.\");\n            }\n\n            return new BusinessRoleDto\n            {\n                Id = role.Id,\n                Name = role.Name,\n                Description = role.Description,\n                IsActive = role.IsActive,\n                CreatedAt = role.CreatedAt\n            };\n        }\n\n        public async Task<BusinessRoleDto> UpdateAsync(Guid businessId, Guid roleId, BusinessRoleUpdateDto dto)\n        {\n            var role = await _db.Roles\n                .Where(r => r.Id == roleId && r.BusinessId == businessId)\n                .FirstOrDefaultAsync();\n\n            if (role == null)\n                throw new KeyNotFoundException(\"Role not found.\");\n\n            // Safety: never allow updating system roles from business endpoints\n            if (role.BusinessId == null)\n                throw new InvalidOperationException(\"System roles cannot be edited.\");\n\n            role.Name = dto.Name.Trim();\n            role.Description = dto.Description?.Trim();\n\n            try\n            {\n                await _db.SaveChangesAsync();\n            }\n            catch (DbUpdateException)\n            {\n                throw new InvalidOperationException($\"Role '{role.Name}' already exists.\");\n            }\n\n            return new BusinessRoleDto\n            {\n                Id = role.Id,\n                Name = role.Name,\n                Description = role.Description,\n                IsActive = role.IsActive,\n                CreatedAt = role.CreatedAt\n            };\n        }\n\n        public async Task DeactivateAsync(Guid businessId, Guid roleId)\n        {\n            var role = await _db.Roles\n                .Where(r => r.Id == roleId && r.BusinessId == businessId)\n                .FirstOrDefaultAsync();\n\n            if (role == null)\n                throw new KeyNotFoundException(\"Role not found.\");\n\n            if (role.BusinessId == null)\n                throw new InvalidOperationException(\"System roles cannot be deactivated.\");\n\n            role.IsActive = false;\n\n            await _db.SaveChangesAsync();\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/BusinessRoles/Services/IBusinessRoleService.cs",
      "sha256": "1279dc57ca820dcd4bcaff73624c9c4df323e5a88375ff7fd0926aff022917fe",
      "language": "csharp",
      "size": 688,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.AccessControl.BusinessRoles.DTOs;\n\nnamespace xbytechat.api.Features.AccessControl.BusinessRoles.Services\n{\n    public interface IBusinessRoleService\n    {\n        Task<List<BusinessRoleDto>> GetAllAsync(Guid businessId, bool includeInactive = false);\n        Task<BusinessRoleDto?> GetByIdAsync(Guid businessId, Guid roleId);\n        Task<BusinessRoleDto> CreateAsync(Guid businessId, BusinessRoleCreateDto dto);\n        Task<BusinessRoleDto> UpdateAsync(Guid businessId, Guid roleId, BusinessRoleUpdateDto dto);\n        Task DeactivateAsync(Guid businessId, Guid roleId);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Controllers/PermissionController.cs",
      "sha256": "f3ef162fea0e7bd86c0bf3b538aad49c8e9e7af7213b4b00adac8b994e3e103f",
      "language": "csharp",
      "size": 3705,
      "content": "// ðŸ“„ Features/AccessControl/Controllers/PermissionController.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.AccessControl.DTOs;\nusing xbytechat.api.Features.AccessControl.Services;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.AccessControl.Controllers\n{\n    [ApiController]\n    [Route(\"api/permission\")]\n    [Authorize]\n    public class PermissionController : ControllerBase\n    {\n        private readonly IPermissionService _permissionService;\n\n        public PermissionController(IPermissionService permissionService)\n        {\n            _permissionService = permissionService;\n        }\n\n        // --- Existing grouped endpoint (kept for compatibility) ---\n        // GET /api/permission/grouped\n        [HttpGet(\"grouped\")]\n        public async Task<IActionResult> GetGroupedPermissions(CancellationToken ct)\n        {\n            var grouped = await _permissionService.GetGroupedPermissionsAsync();\n            return Ok(ResponseResult.SuccessInfo(\"Permissions grouped by category\", grouped));\n        }\n\n        // --- New CRUD endpoints used by PermissionsPage ---\n\n        // GET /api/permission\n        [HttpGet]\n        [Authorize(Roles = \"superadmin,partneradmin,admin\")]\n        public async Task<ActionResult<IEnumerable<PermissionSummaryDto>>> GetAll(\n            CancellationToken ct)\n        {\n            var list = await _permissionService.GetAllAsync(ct);\n            return Ok(list); // React expects a plain array\n        }\n\n        // POST /api/permission\n        [HttpPost]\n        [Authorize(Roles = \"superadmin,partneradmin,admin\")]\n        public async Task<ActionResult<PermissionSummaryDto>> Create(\n            [FromBody] PermissionUpsertDto dto,\n            CancellationToken ct)\n        {\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(ModelState);\n            }\n\n            try\n            {\n                var created = await _permissionService.CreateAsync(dto, ct);\n                return Ok(created);\n            }\n            catch (InvalidOperationException ex)\n            {\n                return BadRequest(new { message = ex.Message });\n            }\n        }\n\n        // PUT /api/permission/{id}\n        [HttpPut(\"{id:guid}\")]\n        [Authorize(Roles = \"superadmin,partneradmin,admin\")]\n        public async Task<ActionResult<PermissionSummaryDto>> Update(\n            Guid id,\n            [FromBody] PermissionUpsertDto dto,\n            CancellationToken ct)\n        {\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(ModelState);\n            }\n\n            try\n            {\n                var updated = await _permissionService.UpdateAsync(id, dto, ct);\n                return Ok(updated);\n            }\n            catch (KeyNotFoundException)\n            {\n                return NotFound();\n            }\n            catch (InvalidOperationException ex)\n            {\n                return BadRequest(new { message = ex.Message });\n            }\n        }\n\n        // DELETE /api/permission/{id}  (soft delete)\n        [HttpDelete(\"{id:guid}\")]\n        [Authorize(Roles = \"superadmin,partneradmin,admin\")]\n        public async Task<IActionResult> Deactivate(\n            Guid id,\n            CancellationToken ct)\n        {\n            try\n            {\n                await _permissionService.DeactivateAsync(id, ct);\n                return NoContent();\n            }\n            catch (KeyNotFoundException)\n            {\n                return NotFound();\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Controllers/PlanController.cs",
      "sha256": "c92adfe00eb0924a8d179eca1db384ff01b69baa4a632166b2677c4a6bbb4d42",
      "language": "csharp",
      "size": 8014,
      "content": "using Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.AccessControl.DTOs;\nusing xbytechat.api.Features.AccessControl.Services;\nusing xbytechat.api.Helpers; // âœ… For ResponseResult\n\nnamespace xbytechat.api.Features.AccessControl.Controllers\n{\n    [Route(\"api/[controller]\")]\n    [ApiController]\n    [Authorize]\n    public class PlanController : ControllerBase\n    {\n        private readonly IPlanService _planService;\n        private readonly IPermissionCacheService _permissionCacheService;\n        private readonly ILogger<PlanController> _logger;\n        public PlanController(IPlanService planService, IPermissionCacheService permissionCacheService, ILogger<PlanController> logger)\n        {\n            _planService = planService;\n            _permissionCacheService = permissionCacheService;\n            _logger = logger;\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> GetPlans()\n        {\n            try\n            {\n                var plans = await _planService.GetAllPlansAsync();\n                return Ok(plans); // Return plain array\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Failed to load plans\");\n                return BadRequest(new { message = \"Failed to load plans\", error = ex.Message });\n            }\n        }\n\n        [HttpGet(\"{planId}/permissions\")]\n        public async Task<IActionResult> GetPlanPermissions(Guid planId)\n        {\n            try\n            {\n               // var permissions = await _planService.GetPermissionsForPlanAsync(planId);\n                var permissions = await _permissionCacheService.GetPlanPermissionsAsync(planId);\n\n                return Ok(permissions);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Failed to load permissions for plan {PlanId}\", planId);\n                return BadRequest(new { message = \"Failed to load permissions\", error = ex.Message });\n            }\n        }\n\n     \n        [HttpPost(\"Create\")]\n        [Authorize(Roles = \"superadmin,partneradmin,admin\")]\n        public async Task<IActionResult> CreatePlan([FromBody] CreatePlanDto dto)\n        {\n            if (string.IsNullOrWhiteSpace(dto.Code) || string.IsNullOrWhiteSpace(dto.Name))\n                return BadRequest(new { message = \"Code and Name are required\" });\n\n            try\n            {\n                var newPlanId = await _planService.CreatePlanAsync(dto);\n                return Ok(new { id = newPlanId, message = \"Plan created successfully\" });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Failed to create plan {PlanName}\", dto.Name);\n                return BadRequest(new { message = \"Failed to create plan\", error = ex.Message });\n            }\n        }\n\n        [HttpPut(\"{planId}\")]\n        [Authorize(Roles = \"superadmin,partneradmin,admin\")]\n        public async Task<IActionResult> UpdatePlan(Guid planId, [FromBody] UpdatePlanDto dto)\n        {\n            if (string.IsNullOrWhiteSpace(dto.Code) || string.IsNullOrWhiteSpace(dto.Name))\n                return BadRequest(new { message = \"Code and Name are required\" });\n\n            try\n            {\n                var updated = await _planService.UpdatePlanAsync(planId, dto);\n                if (!updated)\n                    return NotFound(new { message = \"Plan not found\" });\n\n                return Ok(new { message = \"Plan updated successfully\" });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Failed to update plan {PlanId}\", planId);\n                return BadRequest(new { message = \"Failed to update plan\", error = ex.Message });\n            }\n        }\n\n        [HttpDelete(\"{planId}\")]\n        [Authorize(Roles = \"superadmin,partneradmin,admin\")]\n        public async Task<IActionResult> DeletePlan(Guid planId)\n        {\n            try\n            {\n                var deleted = await _planService.DeletePlanAsync(planId);\n                if (!deleted)\n                    return NotFound(new { message = \"Plan not found or already inactive\" });\n                // âœ… Clear cache when plan is deleted\n                _permissionCacheService.ClearPlanPermissionsCache(planId);\n                return Ok(new { message = \"Plan deleted successfully\" });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Failed to delete plan {PlanId}\", planId);\n                return BadRequest(new { message = \"Failed to delete plan\", error = ex.Message });\n            }\n        }\n      \n        [HttpGet(\"me/permissions\")]\n        public async Task<IActionResult> GetMyPlanPermissions(CancellationToken ct)\n        {\n            var role = User.FindFirst(\"role\")?.Value ?? string.Empty;\n\n            // Admin-like roles don't need a plan\n            if (role is \"superadmin\" or \"admin\" or \"partner\" or \"reseller\")\n                return Ok(new\n                {\n                    planId = (Guid?)null,\n                    plan = (PlanDto?)null,\n                    permissions = new[] { \"*\" }\n                });\n\n            var planIdStr = User.FindFirst(\"plan_id\")?.Value;\n            if (!Guid.TryParse(planIdStr, out var planId))\n                return Ok(new\n                {\n                    planId = (Guid?)null,\n                    plan = (PlanDto?)null,\n                    permissions = Array.Empty<string>()\n                });\n\n            // permissions (cached)\n            var permissionEntities = await _permissionCacheService.GetPlanPermissionsAsync(planId);\n            var codes = permissionEntities\n                .Where(p => p.IsActive)\n                .Select(p => p.Code)\n                .Distinct()\n                .ToList();\n\n            // âœ… Fetch the plan once and return it as PlanDto\n            var planDto = await _planService.GetByIdAsync(planId, ct);\n\n            return Ok(new\n            {\n                planId,\n                plan = planDto,     // PlanDto or null\n                permissions = codes\n            });\n        }\n\n        // ðŸ“„ Features/AccessControl/Controllers/PlanController.cs\n        //[HttpPut(\"{planId:guid}/permissions\")]\n        //[Authorize(Roles = \"superadmin,partneradmin,admin\")]\n        //public async Task<IActionResult> UpdatePlanPermissions(\n        //    Guid planId,\n        //    [FromBody] UpdatePlanPermissionsRequest body,\n        //    CancellationToken ct)\n        //{\n        //    var actor = User?.Identity?.Name ?? \"system\";\n        //    await _planService.UpdatePlanPermissionsAsync(\n        //        planId,\n        //        body.PermissionIds,     // must be named PermissionIds\n        //        body.ReplaceAll,        // default true\n        //        actor,\n        //        ct);\n\n        //    return NoContent(); // 204\n        //}\n        [HttpPut(\"{planId:guid}/permissions\")]\n        [Authorize(Roles = \"superadmin,partneradmin,admin\")]\n        public async Task<IActionResult> UpdatePlanPermissions(\n    Guid planId,\n    [FromBody] UpdatePlanPermissionsRequest body,\n    CancellationToken ct)\n        {\n            var actor = User?.Identity?.Name ?? \"system\";\n\n            await _planService.UpdatePlanPermissionsAsync(\n                planId,\n                body.PermissionIds,\n                body.ReplaceAll,\n                actor,\n                ct);\n\n            // âœ… CRITICAL: clear cache so changes apply instantly\n            _permissionCacheService.ClearPlanPermissionsCache(planId);\n\n            return NoContent(); // 204\n        }\n\n        // ðŸ“„ Features/AccessControl/DTOs/UpdatePlanPermissionsRequest.cs\n        public sealed class UpdatePlanPermissionsRequest\n        {\n            public List<Guid> PermissionIds { get; set; } = new();\n            public bool ReplaceAll { get; set; } = true;\n        }\n\n\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Controllers/UserPermissionsController.cs",
      "sha256": "950672bd933736c854e3a9e88b13449a6458b03a05c906c78e9c5916d8c48787",
      "language": "csharp",
      "size": 7589,
      "content": "#nullable enable\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.AuthModule.Models;\nusing xbytechat.api.Features.AccessControl.Models;\n\nnamespace xbytechat.api.Features.AccessControl.Controllers\n{\n    /// <summary>\n    /// Manage per-user permission overrides.\n    ///\n    /// Important:\n    /// - We do NOT calculate effective permissions here.\n    ///   Plan â†’ permissions is handled by Plan/AccessControl services.\n    /// - This controller only manages rows in UserPermission (allow/deny overrides).\n    ///   The UI can merge:\n    ///     a) plan permissions  + \n    ///     b) these overrides\n    ///   to show the final state for each feature.\n    /// </summary>\n    [ApiController]\n    [Route(\"api/admin/users/{userId:guid}/permissions\")]\n    [Authorize(Roles = \"admin\")]\n    public sealed class UserPermissionsController : ControllerBase\n    {\n        private readonly AppDbContext _db;\n\n        public UserPermissionsController(AppDbContext db)\n        {\n            _db = db;\n        }\n\n        // --------- DTOs (you can later move them to Features/AccessControl/DTOs) ---------\n\n        public sealed class UserPermissionOverrideDto\n        {\n            public Guid PermissionId { get; set; }\n            public string Code { get; set; } = string.Empty;\n            public string Name { get; set; } = string.Empty;\n\n            /// <summary>\n            /// true  = explicit allow\n            /// false = explicit deny\n            /// </summary>\n            public bool IsGranted { get; set; }\n\n            /// <summary>\n            /// true  = override is logically removed (soft delete)\n            /// false = active override\n            /// </summary>\n            public bool IsRevoked { get; set; }\n\n            public DateTime AssignedAt { get; set; }\n            public string? AssignedBy { get; set; }\n        }\n\n        public sealed class UpsertUserPermissionRequest\n        {\n            public Guid PermissionId { get; set; }\n\n            /// <summary>\n            /// true  = allow\n            /// false = deny\n            /// </summary>\n            public bool IsGranted { get; set; }\n        }\n\n        // ---------------- GET: list overrides for a user ----------------\n\n        /// <summary>\n        /// Returns all active overrides for the given user.\n        /// The UI should combine this with plan permissions to show final state.\n        /// </summary>\n        [HttpGet]\n        public async Task<ActionResult<List<UserPermissionOverrideDto>>> GetOverridesForUser(\n            Guid userId,\n            CancellationToken ct)\n        {\n            // Ensure the user exists (optional but nice for admin UX)\n            var userExists = await _db.Set<User>()\n                .AnyAsync(u => u.Id == userId, ct);\n\n            if (!userExists)\n            {\n                return NotFound($\"User {userId} not found.\");\n            }\n\n            var overrides = await _db.Set<UserPermission>()\n                .AsNoTracking()\n                .Where(up => up.UserId == userId && !up.IsRevoked)\n                .Include(up => up.Permission)\n                .OrderBy(up => up.Permission.Code)\n                .Select(up => new UserPermissionOverrideDto\n                {\n                    PermissionId = up.PermissionId,\n                    Code = up.Permission.Code,\n                    Name = up.Permission.Name,\n                    IsGranted = up.IsGranted,\n                    IsRevoked = up.IsRevoked,\n                    AssignedAt = up.AssignedAt,\n                    AssignedBy = up.AssignedBy\n                })\n                .ToListAsync(ct);\n\n            return overrides;\n        }\n\n        // ---------------- POST: create/update override ----------------\n\n        /// <summary>\n        /// Create or update an override for the given user & permission.\n        /// If row exists, we update IsGranted and clear IsRevoked.\n        /// </summary>\n        [HttpPost]\n        public async Task<ActionResult<UserPermissionOverrideDto>> UpsertOverride(\n            Guid userId,\n            [FromBody] UpsertUserPermissionRequest request,\n            CancellationToken ct)\n        {\n            if (request.PermissionId == Guid.Empty)\n            {\n                return BadRequest(\"PermissionId is required.\");\n            }\n\n            var user = await _db.Set<User>()\n                .FirstOrDefaultAsync(u => u.Id == userId, ct);\n\n            if (user is null)\n            {\n                return NotFound($\"User {userId} not found.\");\n            }\n\n            var permission = await _db.Set<Permission>()\n                .FirstOrDefaultAsync(p => p.Id == request.PermissionId, ct);\n\n            if (permission is null)\n            {\n                return NotFound($\"Permission {request.PermissionId} not found.\");\n            }\n\n            var existing = await _db.Set<UserPermission>()\n                .FirstOrDefaultAsync(\n                    up => up.UserId == userId && up.PermissionId == request.PermissionId,\n                    ct);\n\n            if (existing is null)\n            {\n                existing = new UserPermission\n                {\n                    Id = Guid.NewGuid(),\n                    UserId = userId,\n                    PermissionId = request.PermissionId,\n                    IsGranted = request.IsGranted,\n                    IsRevoked = false,\n                    AssignedAt = DateTime.UtcNow,\n                    AssignedBy = User?.Identity?.Name ?? \"system\"\n                };\n\n                await _db.Set<UserPermission>().AddAsync(existing, ct);\n            }\n            else\n            {\n                existing.IsGranted = request.IsGranted;\n                existing.IsRevoked = false;\n                existing.AssignedAt = DateTime.UtcNow;\n                existing.AssignedBy = User?.Identity?.Name ?? existing.AssignedBy;\n            }\n\n            await _db.SaveChangesAsync(ct);\n\n            var dto = new UserPermissionOverrideDto\n            {\n                PermissionId = existing.PermissionId,\n                Code = permission.Code,\n                Name = permission.Name,\n                IsGranted = existing.IsGranted,\n                IsRevoked = existing.IsRevoked,\n                AssignedAt = existing.AssignedAt,\n                AssignedBy = existing.AssignedBy\n            };\n\n            return Ok(dto);\n        }\n\n        // ---------------- DELETE: soft-remove override ----------------\n\n        /// <summary>\n        /// Soft deletes an override by setting IsRevoked = true.\n        /// Effective permission will fall back to plan-level mapping.\n        /// </summary>\n        [HttpDelete(\"{permissionId:guid}\")]\n        public async Task<IActionResult> DeleteOverride(\n            Guid userId,\n            Guid permissionId,\n            CancellationToken ct)\n        {\n            var overrideRow = await _db.Set<UserPermission>()\n                .FirstOrDefaultAsync(\n                    up => up.UserId == userId && up.PermissionId == permissionId,\n                    ct);\n\n            if (overrideRow is null)\n            {\n                return NotFound();\n            }\n\n            overrideRow.IsRevoked = true;\n            // Optional: also reset grant flag â€“ your entitlement logic can ignore revoked rows anyway\n            // overrideRow.IsGranted = false;\n\n            await _db.SaveChangesAsync(ct);\n            return NoContent();\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/CreatePlanDto.cs",
      "sha256": "15d5b4b092dc0019db6a3e33fc6ea49a5bd2e02c9c4fabde02403dc9c32feb90",
      "language": "csharp",
      "size": 320,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AccessControl.DTOs\n{\n    public class CreatePlanDto\n    {\n        public string Code { get; set; } // e.g. \"FREE\", \"SMART\"\n        public string Name { get; set; }\n        public string? Description { get; set; }\n        public bool IsActive { get; set; } = true;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/GroupedPermissionDto.cs",
      "sha256": "d31e43145b8ed5908bd705af1dc96740d163615a183c30dc69b6d72097d37a76",
      "language": "csharp",
      "size": 255,
      "content": "using xbytechat.api.Features.AccessControl.Models;\n\nnamespace xbytechat.api.Features.AccessControl.DTOs\n{\n    public class GroupedPermissionDto\n    {\n        public string Group { get; set; }\n        public List<Permission> Features { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/PermissionDto.cs",
      "sha256": "46bfdeaa2a7dfa7bdaa56ed6c991868bae5fcc8ffb88cff1cc82d329e51eb92f",
      "language": "csharp",
      "size": 353,
      "content": "namespace xbytechat.api.Features.AccessControl.DTOs\n{\n    public class PermissionDto\n    {\n        public Guid Id { get; set; }\n        public string Code { get; set; }\n        public string Name { get; set; }\n        public string? Group { get; set; }\n        public string? Description { get; set; }\n        public bool IsActive { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/PermissionSummaryDto.cs",
      "sha256": "2ace6d04b01d7f967838d51fe0d7e0e0650479e1663c18f2559ca8246adf3e55",
      "language": "csharp",
      "size": 607,
      "content": "// ðŸ“„ Features/AccessControl/DTOs/PermissionSummaryDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.AccessControl.DTOs\n{\n    /// <summary>\n    /// Flat DTO used by the Permissions admin grid.\n    /// </summary>\n    public sealed class PermissionSummaryDto\n    {\n        public Guid Id { get; set; }\n\n        public string Code { get; set; } = default!;\n        public string Name { get; set; } = default!;\n\n        public string? Group { get; set; }\n        public string? Description { get; set; }\n\n        public bool IsActive { get; set; }\n        public DateTime CreatedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/PermissionUpsertDto.cs",
      "sha256": "bc57fdb6495dbd689898b10e6b6afe9a7fc02feca1e3453f8a10250f48651a02",
      "language": "csharp",
      "size": 797,
      "content": "// ðŸ“„ Features/AccessControl/DTOs/PermissionUpsertDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.AccessControl.DTOs\n{\n    /// <summary>\n    /// Payload for creating or updating a Permission.\n    /// Code is immutable once created (UI disables it for edit).\n    /// </summary>\n    public sealed class PermissionUpsertDto\n    {\n        [Required]\n        [MaxLength(200)]\n        public string Code { get; set; } = default!; // e.g. \"MESSAGING.SEND.TEXT\"\n\n        [Required]\n        [MaxLength(200)]\n        public string Name { get; set; } = default!; // friendly label\n\n        [MaxLength(200)]\n        public string? Group { get; set; } // \"Messaging\", \"Campaigns\", etc.\n\n        [MaxLength(1000)]\n        public string? Description { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/PlanDto.cs",
      "sha256": "87bcc89fbc963d131fcc246a1bde5d2d1a9198a61fac73a55b6b985644c8ee89",
      "language": "csharp",
      "size": 303,
      "content": "namespace xbytechat.api.Features.AccessControl.DTOs\n{\n    public class PlanDto\n    {\n        public Guid Id { get; set; }\n        public string Code { get; set; }\n        public string Name { get; set; }\n        public string Description { get; set; }\n        public bool IsActive { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/RoleDto.cs",
      "sha256": "890bec8d90e7068a2c8e49c4249b761506cdb9c26b2fd5a470bf14c6013954cf",
      "language": "csharp",
      "size": 479,
      "content": "namespace xbytechat.api.Features.AccessControl.DTOs;\n\n// DTO: Role details used across layers\npublic class RoleDto\n{\n    /// <summary>Unique identifier of the role.</summary>\n    public Guid Id { get; set; }\n\n   \n    public string Role { get; set; } = default!;\n\n   \n    public string Code { get; set; } = default!;\n\n   \n    public string? Description { get; set; }\n\n    \n    public bool IsActive { get; set; }\n\n       public RoleDto() { }\n\n    // Convenience constructor\n    \n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/UpdatePlanDto.cs",
      "sha256": "e4a09d8fd1c1ff0cb720be4ff2ba80df60e06fc54795e1e2a23fd06b16bf8956",
      "language": "csharp",
      "size": 273,
      "content": "namespace xbytechat.api.Features.AccessControl.DTOs\n{\n    public class UpdatePlanDto\n    {\n        public string Name { get; set; }\n        public string Code { get; set; }\n        public string Description { get; set; }\n        public bool IsActive { get; set; }\n    }\n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/UpdatePlanPermissionsRequest.cs",
      "sha256": "fb7246c045dc67de4e1841a2e77749da563069e5e02ebe856df70f4bb28e9c42",
      "language": "csharp",
      "size": 269,
      "content": "namespace xbytechat.api.Features.AccessControl.DTOs\n{\n    public class UpdatePlanPermissionsRequest\n    {\n        public List<Guid> PermissionIds { get; set; } = new();\n        public bool ReplaceAll { get; set; } = true; // optional flag your controller reads\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/UpdateRolePermissionsDto.cs",
      "sha256": "e00530db11a422793d96b8905211218a03a8e810c601034c76b75fbba37d40db",
      "language": "csharp",
      "size": 291,
      "content": "using System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.AccessControl.DTOs\n{\n    public class UpdateRolePermissionsDto\n    {\n        [Required]\n        public List<Guid> PermissionIds { get; set; } = new();\n        public bool ReplaceAll { get; set; } = true;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/UpdateUserPermissionsDto.cs",
      "sha256": "aea509c8f87c9fda5473534a5c9926fd3af7d09a1041c2832071d1aa5ba60b31",
      "language": "csharp",
      "size": 416,
      "content": "using System.Collections.Generic;\n\nnamespace xbytechat.api.Features.AccessControl.DTOs.UserPermissions\n{\n    public sealed class UpdateUserPermissionsDto\n    {\n        /// <summary>\n        /// List of Permission.Code values that should be enabled for this user.\n        /// Anything not in this list will be removed.\n        /// </summary>\n        public List<string> PermissionCodes { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/UpsertPermissionRequest.cs",
      "sha256": "f925b63f73851fa7462e56c3f9b53a56476af6cb976cbe35d813efd03db7889b",
      "language": "csharp",
      "size": 633,
      "content": "// ðŸ“ Features/AccessControl/DTOs/UpsertPermissionRequest.cs\nnamespace xbytechat.api.Features.AccessControl.DTOs\n{\n    public class UpsertPermissionRequest\n    {\n        // Code is required only on create. On update, we ignore it.\n        public string Code { get; set; } = string.Empty;\n\n        public string Name { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Logical group/module/workspace, e.g. \"Messaging\", \"Campaigns\", \"CRM\".\n        /// This maps to Permission.Group in the model.\n        /// </summary>\n        public string? Group { get; set; }\n\n        public string? Description { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/UserPermissions.cs",
      "sha256": "2f1985d1584fedd86c23fe360a05781bd5ab974fe2833c7ba1222e55c531ee6e",
      "language": "csharp",
      "size": 340,
      "content": "namespace xbytechat.api.Features.AccessControl.DTOs.UserPermissions\n{\n    public sealed class UserPermissionItemDto\n    {\n        public string PermissionCode { get; set; } = default!;\n        public string Name { get; set; } = default!;\n        public string? Description { get; set; }\n        public bool IsAssigned { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/UserPermissionSummaryDto.cs",
      "sha256": "9d6539a51791e64bf141f4f8aea394a0befa161294ac9a6e2c794fdbdde78b60",
      "language": "csharp",
      "size": 440,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.AccessControl.DTOs.UserPermissions\n{\n    public sealed class UserPermissionSummaryDto\n    {\n        public Guid UserId { get; set; }\n        public string UserEmail { get; set; } = default!;\n        public Guid BusinessId { get; set; }\n        public Guid PlanId { get; set; }\n\n        public List<UserPermissionItemDto> Items { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Models/Permission.cs",
      "sha256": "22c58f1f832014c6129b075f027045a186874bc7c20d0f312befe1d658bb0ab4",
      "language": "csharp",
      "size": 832,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.AccessControl.Models\n{\n    public class Permission\n    {\n        public Guid Id { get; set; }\n\n        public string Code { get; set; } // Unique key like \"ViewDashboard\"\n\n        public string Name { get; set; } // Friendly name like \"View Dashboard\"\n\n        public string? Group { get; set; } // Optional grouping, e.g., \"CRM\", \"Catalog\", \"Admin\"\n\n        public string? Description { get; set; }\n\n        public bool IsActive { get; set; } = true;\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n        public ICollection<RolePermission> RolePermissions { get; set; }\n\n        public ICollection<UserPermission> UserPermissions { get; set; }\n\n        public ICollection<PlanPermission> PlanPermissions { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Models/Plan.cs",
      "sha256": "9f3414b6a49c2c27b0784e659367f5f64258b19e19195a52a4248936020542be",
      "language": "csharp",
      "size": 758,
      "content": "using System;\nusing System.Collections.Generic;\nusing xbytechat.api.Features.BusinessModule.Models;\n\nnamespace xbytechat.api.Features.AccessControl.Models\n{\n    public class Plan\n    {\n        public Guid Id { get; set; }\n\n        public string Code { get; set; } // e.g. \"FREE\", \"SMART\", \"ADVANCED\"\n        public string Name { get; set; } // Friendly display name\n\n        public string? Description { get; set; }\n\n        public bool IsActive { get; set; } = true;\n\n        public bool IsInternal { get; set; } = false;\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n        public ICollection<PlanPermission> PlanPermissions { get; set; }\n        public ICollection<Business> Businesses { get; set; } = new List<Business>();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Models/PlanPermission.cs",
      "sha256": "e6e65f0ae33c19e9d2585d73812bcf99ed207d52ac6d804a3c2bf86b3152eca7",
      "language": "csharp",
      "size": 525,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AccessControl.Models\n{\n    public class PlanPermission\n    {\n        public Guid Id { get; set; }\n\n        public Guid PlanId { get; set; }\n        public Plan Plan { get; set; }\n\n        public Guid PermissionId { get; set; }\n        public Permission Permission { get; set; }\n\n        public bool IsActive { get; set; } = true;\n\n        public DateTime AssignedAt { get; set; } = DateTime.UtcNow;\n        public string? AssignedBy { get; set; } // Admin email or ID\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Models/Role.cs",
      "sha256": "9b8fb241048424da26b269048106f4771195ce236ea1c94a6e322a2d98dd99df",
      "language": "csharp",
      "size": 907,
      "content": "using System;\nusing System.Collections.Generic;\nusing xbytechat.api.AuthModule.Models;\nusing xbytechat.api.Features.BusinessModule.Models;\n\nnamespace xbytechat.api.Features.AccessControl.Models\n{\n    public class Role\n    {\n        public Guid Id { get; set; }\n\n        public string Name { get; set; } // e.g. SuperAdmin, PartnerAdmin, BusinessAdmin, Staff, etc.\n\n        public string? Description { get; set; }\n        public Guid? BusinessId { get; set; }\n\n        public Business? Business { get; set; }\n\n        public bool IsSystemDefined { get; set; } = false; // true for SuperAdmin, PartnerAdmin\n\n        public bool IsActive { get; set; } = true;\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n        public ICollection<RolePermission> RolePermissions { get; set; }\n        public ICollection<User> Users { get; set; } // ðŸ§© One-to-many relation: Role â†’ Users\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Models/RolePermission.cs",
      "sha256": "d9b31669bec3fbda1b95c89def9a6cc641e0dd21f5e38583b8dae4c0239b9a8a",
      "language": "csharp",
      "size": 619,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AccessControl.Models\n{\n    public class RolePermission\n    {\n        public Guid Id { get; set; }\n\n        public Guid RoleId { get; set; }\n        public Role Role { get; set; }\n\n        public Guid PermissionId { get; set; }\n        public Permission Permission { get; set; }\n\n        public DateTime AssignedAt { get; set; } = DateTime.UtcNow;\n        public string? AssignedBy { get; set; } // Admin user email or ID\n\n        public bool IsActive { get; set; } = true; // âœ… Add this line\n        public bool IsRevoked { get; set; } = false; // âœ… Required\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Models/UserPermission.cs",
      "sha256": "6b85321ec68fced21477222e85ac56594106c4654b5d99061c42bc1c46d876aa",
      "language": "csharp",
      "size": 677,
      "content": "using System;\nusing xbytechat.api.AuthModule.Models;\n\nnamespace xbytechat.api.Features.AccessControl.Models\n{\n    public class UserPermission\n    {\n        public Guid Id { get; set; }\n\n        public Guid UserId { get; set; }\n        public User User { get; set; }\n\n        public Guid PermissionId { get; set; }\n        public Permission Permission { get; set; }\n\n        public bool IsGranted { get; set; } = true; // âœ… true = allow, false = explicitly deny\n\n        public DateTime AssignedAt { get; set; } = DateTime.UtcNow;\n        public string? AssignedBy { get; set; } // Admin or system\n\n        public bool IsRevoked { get; set; } = false; // âœ… Required\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/PermissionAttributes/HasPermissionAttribute.cs",
      "sha256": "34dacbeb415c4d4f132196679c11cb68619fb2a180528ef22d17ef65a8df364b",
      "language": "csharp",
      "size": 2885,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing Microsoft.AspNetCore.Mvc.Filters;\nusing Microsoft.Extensions.DependencyInjection;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.AccessControl.Services;\n\nnamespace xbytechat.api.Features.AccessControl.PermissionAttributes\n{\n    /// <summary>\n    /// Enforces a permission code on API endpoints.\n    /// Priority:\n    /// 1) hasAllAccess=true => allow (admin/superadmin/partner/reseller)\n    /// 2) permissions claim contains code => allow\n    /// 3) fallback (legacy): plan_id -> plan permissions cache\n    /// </summary>\n    public class HasPermissionAttribute : Attribute, IAsyncAuthorizationFilter\n    {\n        private readonly string _permissionCode;\n\n        public HasPermissionAttribute(string permissionCode) => _permissionCode = permissionCode;\n\n        public async Task OnAuthorizationAsync(AuthorizationFilterContext context)\n        {\n            var user = context.HttpContext.User;\n\n            if (user?.Identity?.IsAuthenticated != true)\n            {\n                context.Result = new ForbidResult();\n                return;\n            }\n\n            // âœ… 1) All-access shortcut (admins)\n            var hasAllAccessClaim = user.FindFirst(\"hasAllAccess\")?.Value;\n            if (string.Equals(hasAllAccessClaim, \"true\", StringComparison.OrdinalIgnoreCase))\n                return;\n\n            // âœ… 2) Prefer the JWT permissions claim (fast, no DB hit)\n            var permsClaim = user.FindFirst(\"permissions\")?.Value;\n            if (!string.IsNullOrWhiteSpace(permsClaim))\n            {\n                var perms = new HashSet<string>(\n                    permsClaim.Split(',', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries),\n                    StringComparer.OrdinalIgnoreCase\n                );\n\n                if (perms.Contains(_permissionCode))\n                    return;\n\n                context.Result = new ForbidResult();\n                return;\n            }\n\n            // ðŸ§¯ 3) Legacy fallback: plan-only (kept for backward compatibility)\n            var planIdClaim = user.FindFirst(\"plan_id\")?.Value;\n            if (string.IsNullOrWhiteSpace(planIdClaim) || !Guid.TryParse(planIdClaim, out var planId))\n            {\n                context.Result = new ForbidResult();\n                return;\n            }\n\n            var permissionService = context.HttpContext.RequestServices\n                .GetRequiredService<IPermissionCacheService>();\n\n            var planPermissions = await permissionService.GetPlanPermissionsAsync(planId);\n\n            var hasPermission = planPermissions.Any(p =>\n                string.Equals(p.Code, _permissionCode, StringComparison.OrdinalIgnoreCase));\n\n            if (!hasPermission)\n                context.Result = new ForbidResult();\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Seeder/PermissionConstants.cs",
      "sha256": "47104d91bf08a96917121e247b83aac03fe402f24bb851d3fa4b1b9ee5375469",
      "language": "csharp",
      "size": 1126,
      "content": "namespace xbytechat.api.Features.AccessControl.Seeder\n{\n    public static class PermissionConstants\n    {\n        public static class Dashboard\n        {\n            public const string View = \"dashboard.view\";\n        }\n\n        public static class Campaigns\n        {\n            public const string View = \"campaign.view\";\n            public const string Create = \"campaign.create\";\n            public const string Delete = \"campaign.delete\";\n        }\n\n        public static class Products\n        {\n            public const string View = \"product.view\";\n            public const string Create = \"product.create\";\n            public const string Delete = \"product.delete\";\n        }\n\n        public static class CRM\n        {\n            public const string ContactsView = \"contacts.view\";\n            public const string TagsEdit = \"tags.edit\";\n        }\n\n        public static class Admin\n        {\n            public const string BusinessApprove = \"admin.business.approve\";\n            public const string ViewLogs = \"admin.logs.view\";\n        }\n\n        // ðŸ†• Add more modules and permissions here as needed\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Seeder/RolePermissionMapping.cs",
      "sha256": "47f001a1b2d6404c28e73be68faf79485c10c1c0a7dab0a5346cc06fff4f049a",
      "language": "csharp",
      "size": 1302,
      "content": "namespace xbytechat.api.Features.AccessControl.Seeder\n{\n    public static class RolePermissionMapping\n    {\n        public static readonly Dictionary<string, List<string>> RolePermissions = new()\n        {\n            [\"admin\"] = new()\n            {\n                PermissionConstants.Dashboard.View,\n                PermissionConstants.Campaigns.View,\n                PermissionConstants.Campaigns.Create,\n                PermissionConstants.Campaigns.Delete,\n                PermissionConstants.Products.View,\n                PermissionConstants.Products.Create,\n                PermissionConstants.Products.Delete,\n                PermissionConstants.CRM.ContactsView,\n                PermissionConstants.CRM.TagsEdit,\n                PermissionConstants.Admin.BusinessApprove,\n                PermissionConstants.Admin.ViewLogs\n            },\n\n            [\"business\"] = new()\n            {\n                PermissionConstants.Dashboard.View,\n                PermissionConstants.Campaigns.View,\n                PermissionConstants.CRM.ContactsView,\n                PermissionConstants.Products.View\n            },\n\n            [\"staff\"] = new()\n            {\n                PermissionConstants.Dashboard.View,\n                PermissionConstants.CRM.ContactsView\n            }\n        };\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Services/AccessControlService.cs",
      "sha256": "f17819dd1f6c0fa4be4623805f2738e2f6bad0def67f22495cef7f9bf9382d3a",
      "language": "csharp",
      "size": 7050,
      "content": "\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Security.Claims;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.AuthModule.Models;\nusing xbytechat.api.Features.AccessControl.Models;\nusing xbytechat.api.Repositories.Interfaces;\nusing System.Linq.Expressions;\n\n\nnamespace xbytechat.api.Features.AccessControl.Services\n{\n    public class AccessControlService : IAccessControlService\n    {\n        private readonly IGenericRepository<User> _userRepo;\n        private readonly IGenericRepository<RolePermission> _rolePermissionRepo;\n        private readonly IGenericRepository<UserPermission> _userPermissionRepo;\n        private readonly IGenericRepository<Permission> _permissionRepo;\n        private readonly AppDbContext _context;\n        public AccessControlService(\n            IGenericRepository<User> userRepo,\n            IGenericRepository<RolePermission> rolePermissionRepo,\n            IGenericRepository<UserPermission> userPermissionRepo,\n            IGenericRepository<Permission> permissionRepo, AppDbContext context\n        )\n        {\n            _userRepo = userRepo;\n            _rolePermissionRepo = rolePermissionRepo;\n            _userPermissionRepo = userPermissionRepo;\n            _permissionRepo = permissionRepo;\n            _context = context;\n        }\n\n        /// <summary>\n        /// âœ… Fetch all permissions (Role-based + User-specific) for a given user\n        /// </summary>\n        //public async Task<List<string>> GetPermissionsAsync(Guid userId)\n        //{\n        //    var user = await _userRepo.FindByIdAsync(userId);\n        //    if (user == null || user.RoleId == null)\n        //        return new List<string>();\n\n        //    // ðŸ” Get Role-based permissions\n        //    var rolePerms = await _rolePermissionRepo\n        //        .WhereAsync(rp => rp.RoleId == user.RoleId && !rp.IsRevoked);\n\n        //    // ðŸ” Get User-specific extra permissions\n        //    var userPerms = await _userPermissionRepo\n        //        .WhereAsync(up => up.UserId == userId && !up.IsRevoked);\n\n        //    // ðŸ§  Merge permission IDs\n        //    var permissionIds = rolePerms.Select(r => r.PermissionId)\n        //        .Union(userPerms.Select(u => u.PermissionId))\n        //        .Distinct()\n        //        .ToList();\n\n        //    // ðŸŽ¯ Get full permission names from Permission table\n        //    var allPerms = await _permissionRepo\n        //        .WhereAsync(p => permissionIds.Contains(p.Id));\n\n        //    return allPerms.Select(p => p.Code).Distinct().ToList(); // Use Code (standard)\n        //}\n\n        public async Task<IEnumerable<Permission>> GetAllPermissionsAsync()\n        {\n            return await _permissionRepo.WhereAsync(p => p.IsActive);\n        }\n\n\n        public async Task<List<string>> GetPermissionsAsync(Guid userId)\n        {\n            var user = await _userRepo.FindByIdAsync(userId);\n\n            if (user == null || user.RoleId == null)\n                return new List<string>();\n\n            // ðŸš€ Bypass: SuperAdmin always gets full access\n            if (user.Role != null && user.Role.Name.Equals(\"superadmin\", StringComparison.OrdinalIgnoreCase))\n            {\n                var allPerms = await _permissionRepo.GetAllAsync();\n                return allPerms.Select(p => p.Code).Distinct().ToList();\n            }\n\n            // ðŸ” Get Role-based permissions\n            var rolePerms = await _rolePermissionRepo\n                .WhereAsync(rp => rp.RoleId == user.RoleId && !rp.IsRevoked);\n\n            // ðŸ” Get User-specific extra permissions\n            var userPerms = await _userPermissionRepo\n                .WhereAsync(up => up.UserId == userId && !up.IsRevoked);\n\n            // ðŸ§  Merge permission IDs\n            var permissionIds = rolePerms.Select(r => r.PermissionId)\n                .Union(userPerms.Select(u => u.PermissionId))\n                .Distinct()\n                .ToList();\n\n            // ðŸŽ¯ Get full permission names from Permission table\n            var allAllowedPerms = await _permissionRepo\n                .WhereAsync(p => permissionIds.Contains(p.Id));\n\n            return allAllowedPerms.Select(p => p.Code).Distinct().ToList();\n        }\n\n        public bool HasPermission(ClaimsPrincipal user, string requiredPermission)\n        {\n            if (user == null || string.IsNullOrWhiteSpace(requiredPermission))\n                return false;\n\n            // ðŸš€ Bypass for top roles\n            var roleClaim = user.Claims.FirstOrDefault(c =>\n                c.Type == ClaimTypes.Role || c.Type.Equals(\"role\", StringComparison.OrdinalIgnoreCase)\n            )?.Value;\n\n            if (!string.IsNullOrWhiteSpace(roleClaim))\n            {\n                if (roleClaim.Equals(\"superadmin\", StringComparison.OrdinalIgnoreCase) ||\n                    roleClaim.Equals(\"admin\", StringComparison.OrdinalIgnoreCase) ||\n                    roleClaim.Equals(\"partner\", StringComparison.OrdinalIgnoreCase) ||\n                    roleClaim.Equals(\"reseller\", StringComparison.OrdinalIgnoreCase))\n                    return true;\n            }\n\n            var required = requiredPermission.Trim();\n\n            // âœ… Collect permissions from claim(s), supporting CSV and alternate claim keys\n            var set = new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n\n            void AddCsv(string? csv)\n            {\n                if (string.IsNullOrWhiteSpace(csv)) return;\n\n                foreach (var p in csv.Split(',', StringSplitOptions.RemoveEmptyEntries))\n                {\n                    var code = p.Trim();\n                    if (!string.IsNullOrWhiteSpace(code))\n                        set.Add(code);\n                }\n            }\n\n            // primary: \"permissions\" (your JWT uses this)\n            foreach (var c in user.Claims.Where(c => c.Type == \"permissions\"))\n                AddCsv(c.Value);\n\n            // fallback: \"permission\" (rare, but avoids break if someone changes token later)\n            var alt = user.Claims.FirstOrDefault(c => c.Type == \"permission\")?.Value;\n            AddCsv(alt);\n\n            return set.Contains(required);\n        }\n\n        /// <summary>\n        /// âœ… Runtime permission checker (for controller/middleware)\n        /// </summary>\n        //public bool HasPermission(ClaimsPrincipal user, string requiredPermission)\n        //{\n        //    var perms = user.Claims\n        //        .Where(c => c.Type == \"permissions\")\n        //        .Select(c => c.Value)\n        //        .ToList();\n\n        //    return perms.Contains(requiredPermission);\n        //}\n\n        public async Task<List<string>> GetPermissionsByPlanIdAsync(Guid? planId)\n        {\n            if (!planId.HasValue)\n                return new List<string>();\n\n            return await _context.PlanPermissions\n                .Where(pp => pp.PlanId == planId.Value && pp.IsActive)\n                .Select(pp => pp.Permission.Code)\n                .ToListAsync();\n        }\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Services/IAccessControlService.cs",
      "sha256": "a7175ca2ec5d8ac4aae9b09095d675ab36d2c52dd6a62b3d23c6b6990de055e2",
      "language": "csharp",
      "size": 853,
      "content": "//using System.Collections.Generic;\n//using System.Threading.Tasks;\n//using xbytechat.api.Features.AccessControl.Models;\n\n//namespace xbytechat.api.Features.AccessControl.Services\n//{\n//    public interface IAccessControlService\n//    {\n//        Task<IEnumerable<Permission>> GetAllPermissionsAsync();\n//        Task<IEnumerable<Permission>> GetPermissionsAsync(Guid userId);\n\n//    }\n//}\n\n\nusing System.Security.Claims;\nusing xbytechat.api.Features.AccessControl.Models;\n\nnamespace xbytechat.api.Features.AccessControl.Services\n{\n    public interface IAccessControlService\n    {\n        Task<List<string>> GetPermissionsAsync(Guid userId);\n        bool HasPermission(ClaimsPrincipal user, string permission);\n        Task<IEnumerable<Permission>> GetAllPermissionsAsync();\n        Task<List<string>> GetPermissionsByPlanIdAsync(Guid? planId);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Services/IPermissionService.cs.cs",
      "sha256": "9b90beeeaaf8c3d5077265251342d6ae3cf51e442106d302d2a143b7b00ae417",
      "language": "csharp",
      "size": 1071,
      "content": "// ðŸ“„ Features/AccessControl/Services/IPermissionService.cs.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.AccessControl.DTOs;\n\nnamespace xbytechat.api.Features.AccessControl.Services\n{\n    public interface IPermissionService\n    {\n        // Existing grouped view (used by older UI / internal tools)\n        Task<IEnumerable<GroupedPermissionDto>> GetGroupedPermissionsAsync();\n\n        // New flat CRUD endpoints\n        Task<IReadOnlyList<PermissionSummaryDto>> GetAllAsync(\n            CancellationToken ct = default);\n\n        Task<PermissionSummaryDto> CreateAsync(\n            PermissionUpsertDto dto,\n            CancellationToken ct = default);\n\n        Task<PermissionSummaryDto> UpdateAsync(\n            Guid id,\n            PermissionUpsertDto dto,\n            CancellationToken ct = default);\n\n        /// <summary>\n        /// Soft-delete / deactivate a permission.\n        /// </summary>\n        Task DeactivateAsync(Guid id, CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Services/IPlanService.cs",
      "sha256": "52ab5621692cbe324646331e6ac2ee6a1c4b4fe9fdfc5b75e602322a29263f19",
      "language": "csharp",
      "size": 1128,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.AccessControl.DTOs;\nusing xbytechat.api.Features.AccessControl.Models;\n\nnamespace xbytechat.api.Features.AccessControl.Services\n{\n    public interface IPlanService\n    {\n        Task<IEnumerable<PlanDto>> GetAllPlansAsync();\n        Task<IEnumerable<PermissionDto>> GetPermissionsForPlanAsync(Guid planId);\n       // Task UpdatePlanPermissionsAsync(Guid planId, List<Guid> permissionIds);\n        Task<Guid> CreatePlanAsync(CreatePlanDto dto);\n        Task<bool> DeletePlanAsync(Guid planId);\n        Task<bool> UpdatePlanAsync(Guid planId, UpdatePlanDto dto);\n\n        // New methods for permissions\n        Task<List<PermissionDto>> GetPlanPermissionsAsync(Guid planId);\n        //Task UpdatePlanPermissionsAsync(Guid planId, List<Guid> permissionIds);\n        Task UpdatePlanPermissionsAsync(\n    Guid planId,\n    IReadOnlyCollection<Guid> permissionIds,\n    bool replaceAll,\n    string? assignedBy,\n    CancellationToken ct);\n        Task<PlanDto?> GetByIdAsync(Guid planId, CancellationToken ct = default);\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Services/PermissionCacheService.cs",
      "sha256": "c268071425295dc74c3f7323b4ebcbc3f413d9eaea473b6b55ada75cc0117ea9",
      "language": "csharp",
      "size": 1696,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Caching.Memory;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.AccessControl.Models;\n\nnamespace xbytechat.api.Features.AccessControl.Services\n{\n    public interface IPermissionCacheService\n    {\n        Task<List<Permission>> GetPlanPermissionsAsync(Guid planId);\n        void ClearPlanPermissionsCache(Guid planId);\n    }\n\n    public class PermissionCacheService : IPermissionCacheService\n    {\n        private readonly AppDbContext _context;\n        private readonly IMemoryCache _cache;\n        private const string CacheKeyPrefix = \"plan_permissions_\";\n\n        public PermissionCacheService(AppDbContext context, IMemoryCache cache)\n        {\n            _context = context;\n            _cache = cache;\n        }\n\n        public async Task<List<Permission>> GetPlanPermissionsAsync(Guid planId)\n        {\n            var cacheKey = $\"{CacheKeyPrefix}{planId}\";\n\n            // Try to get from cache\n            if (_cache.TryGetValue(cacheKey, out List<Permission> cachedPermissions))\n                return cachedPermissions;\n\n            // Fetch from DB\n            var permissions = await _context.PlanPermissions\n                .Where(pp => pp.PlanId == planId && pp.IsActive)\n                .Select(pp => pp.Permission)\n                .ToListAsync();\n\n            // Store in cache\n            _cache.Set(cacheKey, permissions, TimeSpan.FromHours(1));\n\n            return permissions;\n        }\n\n        public void ClearPlanPermissionsCache(Guid planId)\n        {\n            _cache.Remove($\"{CacheKeyPrefix}{planId}\");\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Services/PermissionService.cs",
      "sha256": "ae835be421a784aa982c1f38056103da2edb440cc7794714ff48ac0c3dfaa0fa",
      "language": "csharp",
      "size": 5344,
      "content": "// ðŸ“„ Features/AccessControl/Services/PermissionService.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.AccessControl.DTOs;\nusing xbytechat.api.Features.AccessControl.Models;\n\nnamespace xbytechat.api.Features.AccessControl.Services\n{\n    public class PermissionService : IPermissionService\n    {\n        private readonly AppDbContext _context;\n\n        public PermissionService(AppDbContext context)\n        {\n            _context = context;\n        }\n\n        public async Task<IEnumerable<GroupedPermissionDto>> GetGroupedPermissionsAsync()\n        {\n            // Legacy / grouped view (kept for compatibility)\n            return await _context.Permissions\n                .Where(p => p.IsActive)\n                .GroupBy(p => p.Group ?? \"Ungrouped\")\n                .Select(g => new GroupedPermissionDto\n                {\n                    Group = g.Key,\n                    Features = g.ToList()\n                })\n                .ToListAsync();\n        }\n\n        public async Task<IReadOnlyList<PermissionSummaryDto>> GetAllAsync(\n            CancellationToken ct = default)\n        {\n            return await _context.Permissions\n                .OrderBy(p => p.Group)\n                .ThenBy(p => p.Code)\n                .Select(p => new PermissionSummaryDto\n                {\n                    Id = p.Id,\n                    Code = p.Code,\n                    Name = p.Name,\n                    Group = p.Group,\n                    Description = p.Description,\n                    IsActive = p.IsActive,\n                    CreatedAt = p.CreatedAt\n                })\n                .ToListAsync(ct);\n        }\n\n        public async Task<PermissionSummaryDto> CreateAsync(\n            PermissionUpsertDto dto,\n            CancellationToken ct = default)\n        {\n            if (dto == null) throw new ArgumentNullException(nameof(dto));\n\n            var code = dto.Code?.Trim();\n            var name = dto.Name?.Trim();\n\n            if (string.IsNullOrWhiteSpace(code) || string.IsNullOrWhiteSpace(name))\n            {\n                throw new InvalidOperationException(\"Code and Name are required.\");\n            }\n\n            var normalizedCode = code.ToUpperInvariant();\n\n            var exists = await _context.Permissions\n                .AnyAsync(p => p.Code == normalizedCode, ct);\n\n            if (exists)\n            {\n                throw new InvalidOperationException(\n                    $\"Permission code '{normalizedCode}' already exists.\");\n            }\n\n            var permission = new Permission\n            {\n                Id = Guid.NewGuid(),\n                Code = normalizedCode,\n                Name = name,\n                Group = string.IsNullOrWhiteSpace(dto.Group)\n                    ? null\n                    : dto.Group!.Trim(),\n                Description = string.IsNullOrWhiteSpace(dto.Description)\n                    ? null\n                    : dto.Description!.Trim(),\n                IsActive = true,\n                CreatedAt = DateTime.UtcNow\n            };\n\n            _context.Permissions.Add(permission);\n            await _context.SaveChangesAsync(ct);\n\n            return ToSummary(permission);\n        }\n\n        public async Task<PermissionSummaryDto> UpdateAsync(\n            Guid id,\n            PermissionUpsertDto dto,\n            CancellationToken ct = default)\n        {\n            if (dto == null) throw new ArgumentNullException(nameof(dto));\n\n            var permission = await _context.Permissions\n                .FirstOrDefaultAsync(p => p.Id == id, ct);\n\n            if (permission == null)\n                throw new KeyNotFoundException(\"Permission not found.\");\n\n            var name = dto.Name?.Trim();\n            if (string.IsNullOrWhiteSpace(name))\n                throw new InvalidOperationException(\"Name is required.\");\n\n            // Code is intentionally immutable (UI keeps it disabled).\n            permission.Name = name;\n            permission.Group = string.IsNullOrWhiteSpace(dto.Group)\n                ? null\n                : dto.Group!.Trim();\n            permission.Description = string.IsNullOrWhiteSpace(dto.Description)\n                ? null\n                : dto.Description!.Trim();\n\n            await _context.SaveChangesAsync(ct);\n\n            return ToSummary(permission);\n        }\n\n        public async Task DeactivateAsync(Guid id, CancellationToken ct = default)\n        {\n            var permission = await _context.Permissions\n                .FirstOrDefaultAsync(p => p.Id == id, ct);\n\n            if (permission == null)\n                throw new KeyNotFoundException(\"Permission not found.\");\n\n            if (!permission.IsActive)\n                return;\n\n            permission.IsActive = false;\n            await _context.SaveChangesAsync(ct);\n        }\n\n        private static PermissionSummaryDto ToSummary(Permission p)\n        {\n            return new PermissionSummaryDto\n            {\n                Id = p.Id,\n                Code = p.Code,\n                Name = p.Name,\n                Group = p.Group,\n                Description = p.Description,\n                IsActive = p.IsActive,\n                CreatedAt = p.CreatedAt\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Services/PlanService.cs",
      "sha256": "c4e23f3ca4fc67f7f1340294e9d4851943aa91acc14b4d402fe4116f1822a63c",
      "language": "csharp",
      "size": 11164,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.AccessControl.DTOs;\nusing xbytechat.api.Features.AccessControl.Models;\n\nnamespace xbytechat.api.Features.AccessControl.Services\n{\n    public class PlanService : IPlanService\n    {\n        private readonly AppDbContext _context;\n        private readonly ILogger<PlanService> _logger;\n        private readonly IPermissionCacheService _permissionCacheService;\n\n        public PlanService(AppDbContext context, ILogger<PlanService> logger, IPermissionCacheService permissionCacheService)\n        {\n            _context = context;\n            _logger = logger;\n            _permissionCacheService = permissionCacheService;\n        }\n\n\n\n        public async Task<IEnumerable<PlanDto>> GetAllPlansAsync()\n        {\n            return await _context.Plans\n                .Where(p => p.IsActive)\n                .Select(p => new PlanDto\n                {\n                    Id = p.Id,\n                    Code = p.Code,\n                    Name = p.Name,\n                    Description = p.Description,\n                    IsActive = p.IsActive\n                })\n                .ToListAsync();\n        }\n        public async Task<IEnumerable<PermissionDto>> GetPermissionsForPlanAsync(Guid planId)\n        {\n            return await _context.PlanPermissions\n                .Where(pp => pp.PlanId == planId && pp.IsActive)\n                .Select(pp => new PermissionDto\n                {\n                    Id = pp.Permission.Id,\n                    Code = pp.Permission.Code,\n                    Name = pp.Permission.Name,\n                    Group = pp.Permission.Group,\n                    Description = pp.Permission.Description,\n                    IsActive = pp.Permission.IsActive\n                })\n                .ToListAsync();\n        }\n        public async Task<PlanDto?> GetByIdAsync(Guid planId, CancellationToken ct = default)\n        {\n            return await _context.Plans\n                .AsNoTracking()\n                .Where(p => p.Id == planId)\n                .Select(p => new PlanDto\n                {\n                    Id = p.Id,\n                    Code = p.Code,\n                    Name = p.Name,\n                    Description = p.Description,\n                    IsActive = p.IsActive\n                })\n                .FirstOrDefaultAsync(ct);\n        }\n\n        //public async Task<IEnumerable<Permission>> GetPermissionsForPlanAsync(Guid planId)\n        //{\n        //    _logger.LogInformation(\"Fetching permissions for plan {PlanId}\", planId);\n        //    try\n        //    {\n        //        return await _context.PlanPermissions\n        //            .Where(pp => pp.PlanId == planId && pp.IsActive)\n        //            .Include(pp => pp.Permission)\n        //            .Select(pp => pp.Permission)\n        //            .AsNoTracking()\n        //            .ToListAsync();\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        _logger.LogError(ex, \"Error fetching permissions for plan {PlanId}\", planId);\n        //        throw;\n        //    }\n        //}\n\n        //public async Task UpdatePlanPermissionsAsync(Guid planId, List<Guid> permissionIds)\n        //{\n        //    _logger.LogInformation(\"Updating permissions for plan {PlanId}\", planId);\n        //    try\n        //    {\n        //        // Remove all existing permissions for the plan\n        //        var existing = await _context.PlanPermissions\n        //            .Where(pp => pp.PlanId == planId)\n        //            .ToListAsync();\n\n        //        _context.PlanPermissions.RemoveRange(existing);\n\n        //        // Add new permissions\n        //        var newPlanPermissions = permissionIds.Select(pid => new PlanPermission\n        //        {\n        //            Id = Guid.NewGuid(),\n        //            PlanId = planId,\n        //            PermissionId = pid,\n        //            IsActive = true,\n        //            AssignedAt = DateTime.UtcNow,\n        //            AssignedBy = \"System\"\n        //        });\n\n        //        await _context.PlanPermissions.AddRangeAsync(newPlanPermissions);\n        //        await _context.SaveChangesAsync();\n        //        _logger.LogInformation(\"Permissions updated for plan {PlanId}\", planId);\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        _logger.LogError(ex, \"Error updating permissions for plan {PlanId}\", planId);\n        //        throw;\n        //    }\n        //}\n\n        public async Task<Guid> CreatePlanAsync(CreatePlanDto dto)\n        {\n            _logger.LogInformation(\"Creating new plan: {PlanName}\", dto.Name);\n            try\n            {\n                var plan = new Plan\n                {\n                    Id = Guid.NewGuid(),\n                    Code = dto.Code,\n                    Name = dto.Name,\n                    Description = dto.Description,\n                    IsActive = dto.IsActive\n                };\n\n                _context.Plans.Add(plan);\n                await _context.SaveChangesAsync();\n\n                _logger.LogInformation(\"Plan created with ID: {PlanId}\", plan.Id);\n                return plan.Id;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error creating plan {PlanName}\", dto.Name);\n                throw;\n            }\n        }\n\n        public async Task<bool> DeletePlanAsync(Guid planId)\n        {\n            _logger.LogInformation(\"Deleting (soft) plan {PlanId}\", planId);\n            try\n            {\n                var plan = await _context.Plans.FirstOrDefaultAsync(p => p.Id == planId);\n                if (plan == null || !plan.IsActive)\n                {\n                    _logger.LogWarning(\"Plan not found or already inactive: {PlanId}\", planId);\n                    return false;\n                }\n\n                plan.IsActive = false;\n                _context.Plans.Update(plan);\n                await _context.SaveChangesAsync();\n\n                _logger.LogInformation(\"Plan {PlanId} soft deleted.\", planId);\n                return true;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error deleting plan {PlanId}\", planId);\n                throw;\n            }\n        }\n\n        public async Task<bool> UpdatePlanAsync(Guid planId, UpdatePlanDto dto)\n        {\n            _logger.LogInformation(\"Updating plan {PlanId}\", planId);\n            try\n            {\n                var plan = await _context.Plans.FirstOrDefaultAsync(p => p.Id == planId);\n                if (plan == null)\n                {\n                    _logger.LogWarning(\"Plan not found: {PlanId}\", planId);\n                    return false;\n                }\n\n                plan.Code = dto.Code;\n                plan.Name = dto.Name;\n                plan.Description = dto.Description;\n                plan.IsActive = dto.IsActive;\n\n                _context.Plans.Update(plan);\n                await _context.SaveChangesAsync();\n\n                _logger.LogInformation(\"Plan {PlanId} updated successfully.\", planId);\n                return true;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error updating plan {PlanId}\", planId);\n                throw;\n            }\n        }\n\n        public async Task UpdatePlanPermissionsAsync(\n         Guid planId,\n         IReadOnlyCollection<Guid> permissionIds,\n         bool replaceAll,\n         string? assignedBy,\n         CancellationToken ct)\n        {\n            using var trx = await _context.Database.BeginTransactionAsync(ct);\n\n            var existing = await _context.PlanPermissions\n                .Where(pp => pp.PlanId == planId)\n                .ToListAsync(ct);\n\n            var want = new HashSet<Guid>(permissionIds);\n            var byPerm = existing.ToDictionary(pp => pp.PermissionId);\n\n            // upsert requested permissions â†’ Active\n            foreach (var pid in want)\n            {\n                if (byPerm.TryGetValue(pid, out var row))\n                {\n                    if (!row.IsActive)\n                    {\n                        row.IsActive = true;\n                        row.AssignedAt = DateTime.UtcNow;\n                        row.AssignedBy = assignedBy;\n                        _context.PlanPermissions.Update(row);\n                    }\n                }\n                else\n                {\n                    _context.PlanPermissions.Add(new PlanPermission\n                    {\n                        Id = Guid.NewGuid(),\n                        PlanId = planId,\n                        PermissionId = pid,\n                        IsActive = true,\n                        AssignedAt = DateTime.UtcNow,\n                        AssignedBy = assignedBy\n                    });\n                }\n            }\n\n            // replaceAll => deactivate anything not requested\n            if (replaceAll)\n            {\n                foreach (var row in existing)\n                {\n                    if (!want.Contains(row.PermissionId) && row.IsActive)\n                    {\n                        row.IsActive = false;\n                        _context.PlanPermissions.Update(row);\n                    }\n                }\n            }\n\n            await _context.SaveChangesAsync(ct);\n            await trx.CommitAsync(ct);\n\n            // Bust the plan permission cache\n            _permissionCacheService.ClearPlanPermissionsCache(planId);\n        }\n\n\n\n        //public async Task UpdatePlanPermissionsAsync(Guid planId, List<Guid> permissionIds)\n        //{\n        //    // Remove old mappings\n        //    var existing = await _context.PlanPermissions\n        //        .Where(pp => pp.PlanId == planId)\n        //        .ToListAsync();\n        //    _context.PlanPermissions.RemoveRange(existing);\n\n        //    // Add new mappings\n        //    var newMappings = permissionIds.Select(pid => new PlanPermission\n        //    {\n        //        PlanId = planId,\n        //        PermissionId = pid,\n        //        AssignedAt = DateTime.UtcNow,\n        //        AssignedBy = \"system\" // replace with logged-in admin\n        //    });\n\n        //    await _context.PlanPermissions.AddRangeAsync(newMappings);\n        //    await _context.SaveChangesAsync();\n        //    //// Clear cache\n        //    _permissionCacheService.ClearPlanPermissionsCache(planId);\n        //}\n        public async Task<List<PermissionDto>> GetPlanPermissionsAsync(Guid planId)\n        {\n            return await _context.PlanPermissions\n                .Where(pp => pp.PlanId == planId && pp.IsActive)\n                .Select(pp => new PermissionDto\n                {\n                    Id = pp.Permission.Id,\n                    Code = pp.Permission.Code,\n                    Name = pp.Permission.Name,\n                    Group = pp.Permission.Group,\n                    Description = pp.Permission.Description\n                })\n                .ToListAsync();\n        }\n    }\n}\n"
    }
  ]
}
