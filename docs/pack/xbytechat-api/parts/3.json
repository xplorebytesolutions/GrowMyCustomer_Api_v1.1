{
  "name": "xbytechat-api",
  "part": 3,
  "of": 33,
  "generatedAt": "2026-02-11 19:15:17 +00:00",
  "files": [
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/CampaignService.cs",
      "sha256": "a5f2d9e9149b605adbe19b929d46632044417cfd80e7dad32648ca2b0de0f17b",
      "language": "csharp",
      "size": 206436,
      "content": "\nusing Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing xbytechat.api.Features.CampaignModule.Models;\nusing xbytechat.api.Shared;\nusing xbytechat.api.Features.CampaignTracking.Models;\nusing xbytechat.api.Services.Messages.Interfaces;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.Helpers;\nusing xbytechat_api.WhatsAppSettings.Services;\nusing xbytechat.api.Shared.utility;\nusing xbytechat.api.WhatsAppSettings.DTOs;\nusing xbytechat.api.Features.Tracking.Services;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\n\nusing xbytechat.api.WhatsAppSettings.Services;\nusing xbytechat_api.Features.Billing.Services;\nusing System.Text.RegularExpressions;\nusing xbytechat.api.Common.Utils;\nusing xbytechat.api.Features.TemplateModule.Services;\nusing System.Linq;\nusing xbytechat.api.Features.BusinessModule.Models;\nusing xbytechat.api.Features.CampaignModule.Services.SendPipeline;\nusing System.Text.Json;\nusing Newtonsoft.Json;\nusing xbytechat.api.AuthModule.Models;\nusing xbytechat.api.Features.CRM.Dtos;\nusing xbytechat.api.Features.CRM.Models;\nusing xbytechat.api.Features.CRM.Timelines.Services;\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    public partial class CampaignService : ICampaignService\n    {\n        private readonly AppDbContext _context;\n        private readonly IMessageService _messageService;\n        private readonly IServiceProvider _serviceProvider;\n        private readonly ILeadTimelineService _timelineService;\n        private readonly IMessageEngineService _messageEngineService;\n        private readonly IWhatsAppTemplateFetcherService _templateFetcherService;\n        private readonly IUrlBuilderService _urlBuilderService;\n        private readonly IWhatsAppSenderService _whisatsAppSenderService;\n        private readonly IBillingIngestService _billingIngest;\n\n        private readonly IWhatsAppSettingsService _whatsAppSettingsService;\n        // private readonly Serilog.ILogger _logger = Log.ForContext<CampaignService>();\n        // CampaignService.cs (fields)\n\n\n        private readonly ILogger<CampaignService> _logger;\n        public CampaignService(AppDbContext context, IMessageService messageService,\n                               IServiceProvider serviceProvider,\n                               ILeadTimelineService timelineService,\n                               IMessageEngineService messageEngineService,\n                               IWhatsAppTemplateFetcherService templateFetcherService,\n                               IUrlBuilderService urlBuilderService,\n                               IWhatsAppSenderService whatsAppSenderService, IBillingIngestService billingIngest,\n                               ILogger<CampaignService> logger, IWhatsAppSettingsService whatsAppSettingsService\n                               )\n        {\n            _context = context;\n            _messageService = messageService;\n            _serviceProvider = serviceProvider;\n            _timelineService = timelineService; // ‚úÖ new\n            _messageEngineService = messageEngineService;\n            _templateFetcherService = templateFetcherService;\n            _urlBuilderService = urlBuilderService;\n            _whisatsAppSenderService = whatsAppSenderService;\n            _billingIngest = billingIngest;\n            _logger = logger;\n            _whatsAppSettingsService = whatsAppSettingsService;\n\n\n        }\n\n\n\n\n        #region Private method\n        private static string? ResolvePerRecipientValue(CampaignRecipient r, string key)\n        {\n            if (string.IsNullOrWhiteSpace(r.ResolvedButtonUrlsJson)) return null;\n            try\n            {\n                var dict = JsonConvert.DeserializeObject<Dictionary<string, string>>(r.ResolvedButtonUrlsJson)\n                           ?? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n                return dict.TryGetValue(key, out var v) ? v : null;\n            }\n            catch { return null; }\n        }\n        private static List<string> BuildBodyParametersForRecipient(Campaign campaign, CampaignRecipient r)\n        {\n            // Preferred: frozen params on recipient (string[])\n            if (!string.IsNullOrWhiteSpace(r.ResolvedParametersJson))\n            {\n                try\n                {\n                    var arr = JsonConvert.DeserializeObject<string[]>(r.ResolvedParametersJson);\n                    if (arr != null) return arr.ToList();\n                }\n                catch { /* ignore */ }\n            }\n\n            // Fallback: campaign.TemplateParameters (stored as JSON array of strings)\n            try\n            {\n                return TemplateParameterHelper.ParseTemplateParams(campaign.TemplateParameters).ToList();\n            }\n            catch\n            {\n                return new List<string>();\n            }\n        }\n        private static Dictionary<string, string> BuildButtonParametersForRecipient(Campaign campaign, CampaignRecipient r)\n        {\n            var dict = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n\n            // 1) Recipient-specific vars (from CSV materialization)\n            if (!string.IsNullOrWhiteSpace(r.ResolvedButtonUrlsJson))\n            {\n                try\n                {\n                    var d = JsonConvert.DeserializeObject<Dictionary<string, string>>(r.ResolvedButtonUrlsJson);\n                    if (d != null)\n                    {\n                        foreach (var kv in d)\n                            dict[kv.Key] = kv.Value ?? string.Empty;\n                    }\n                }\n                catch { /* ignore */ }\n            }\n\n            // 2) Header fallbacks from campaign (only ImageUrl exists in this branch)\n            if (!dict.ContainsKey(\"header.image_url\") && !string.IsNullOrWhiteSpace(campaign.ImageUrl))\n                dict[\"header.image_url\"] = campaign.ImageUrl!;\n\n            // NOTE:\n            // We do NOT touch header.video_url/header.document_url here,\n            // because Campaign.VideoUrl/DocumentUrl do not exist in this branch.\n\n            // 3) Button URL fallbacks from campaign buttons\n            if (campaign.MultiButtons != null)\n            {\n                foreach (var b in campaign.MultiButtons.OrderBy(b => b.Position).Take(3))\n                {\n                    var key = $\"button{b.Position}.url_param\";\n                    if (!dict.ContainsKey(key) && !string.IsNullOrWhiteSpace(b.Value))\n                        dict[key] = b.Value!;\n                }\n            }\n\n            return dict;\n        }\n        private async Task<(Guid? entryStepId, string? entryTemplate)> ResolveFlowEntryAsync(Guid businessId, Guid? flowId)\n        {\n            if (!flowId.HasValue || flowId.Value == Guid.Empty) return (null, null);\n\n            var flow = await _context.CTAFlowConfigs\n                 .AsNoTracking()\n                .Include(f => f.Steps)\n                    .ThenInclude(s => s.ButtonLinks)\n                .FirstOrDefaultAsync(f => f.Id == flowId.Value && f.BusinessId == businessId && f.IsActive);\n\n            if (flow == null || flow.Steps == null || flow.Steps.Count == 0) return (null, null);\n\n            var incoming = new HashSet<Guid>(\n                flow.Steps.SelectMany(s => s.ButtonLinks)\n                          .Where(l => l.NextStepId.HasValue)\n                          .Select(l => l.NextStepId!.Value)\n            );\n\n            var entry = flow.Steps\n                .OrderBy(s => s.StepOrder)\n                .FirstOrDefault(s => !incoming.Contains(s.Id));\n\n            return entry == null ? (null, null) : (entry.Id, entry.TemplateToSend);\n        }\n\n        #endregion\n\n        #region Get All Types of Get and Update and Delete Methods\n\n        //public async Task<List<CampaignSummaryDto>> GetAllCampaignsAsync(Guid businessId)\n        //{\n        //    return await _context.Campaigns\n        //        .Where(c => c.BusinessId == businessId)\n        //        .OrderByDescending(c => c.CreatedAt)\n        //        .Select(c => new CampaignSummaryDto\n        //        {\n        //            Id = c.Id,\n        //            Name = c.Name,\n        //            Status = c.Status,\n        //            ScheduledAt = c.ScheduledAt,\n        //            CreatedAt = c.CreatedAt,\n\n        //        })\n        //        .ToListAsync();\n        //}\n        public async Task<CampaignDto?> GetCampaignByIdAsync(Guid campaignId, Guid businessId)\n        {\n            var campaign = await _context.Campaigns\n                .AsNoTracking()\n                .Include(c => c.Cta)\n                .Include(c => c.MultiButtons)\n                .Include(c => c.CTAFlowConfig)\n                .FirstOrDefaultAsync(c => c.Id == campaignId && c.BusinessId == businessId);\n\n            if (campaign == null) return null;\n\n            return new CampaignDto\n            {\n                Id = campaign.Id,\n                Name = campaign.Name,\n                MessageTemplate = campaign.MessageTemplate,\n                MessageBody = campaign.MessageBody,\n                TemplateId = campaign.TemplateId,\n                CampaignType = campaign.CampaignType,\n                Status = campaign.Status,\n                ImageUrl = campaign.ImageUrl,\n                ImageCaption = campaign.ImageCaption,\n                CreatedAt = campaign.CreatedAt,\n                ScheduledAt = campaign.ScheduledAt,\n                CtaId = campaign.CtaId,\n                Cta = campaign.Cta == null ? null : new CtaPreviewDto\n                {\n                    Title = campaign.Cta.Title,\n                    ButtonText = campaign.Cta.ButtonText\n                },\n                MultiButtons = campaign.MultiButtons?\n                    .Select(b => new CampaignButtonDto\n                    {\n                        ButtonText = b.Title,\n                        ButtonType = b.Type,\n                        TargetUrl = b.Value\n                    }).ToList() ?? new List<CampaignButtonDto>(),\n                // ‚úÖ Flow surface to UI\n                CTAFlowConfigId = campaign.CTAFlowConfigId,\n                CTAFlowName = campaign.CTAFlowConfig?.FlowName\n            };\n        }\n        // Returns the entry step (no incoming links) and its template name.\n        // If flow is missing/invalid, returns (null, null) and caller should ignore.\n\n        public async Task<List<CampaignSummaryDto>> GetAllCampaignsAsync(Guid businessId, string? type = null)\n        {\n            var query = _context.Campaigns\n                .Where(c => c.BusinessId == businessId)\n                .AsQueryable();\n\n            if (!string.IsNullOrEmpty(type))\n                query = query.Where(c => c.CampaignType == type);\n\n            return await query\n                .OrderByDescending(c => c.CreatedAt)\n                .Select(c => new CampaignSummaryDto\n                {\n                    Id = c.Id,\n                    Name = c.Name,\n                    Status = c.Status,\n                    ScheduledAt = c.ScheduledAt,\n                    CreatedAt = c.CreatedAt,\n                    ImageUrl = c.ImageUrl,            // ‚úÖ Now mapped\n                    ImageCaption = c.ImageCaption,    // ‚úÖ Now mapped\n                    CtaTitle = c.Cta != null ? c.Cta.Title : null,  // optional\n                    RecipientCount = c.Recipients.Count(),\n                    SentAt = c.Status == \"Sent\" || c.Status == \"Completed\" ? c.UpdatedAt : null, // ‚úÖ Map SentAt\n                    MessageTemplate = c.MessageTemplate, // ‚úÖ Map for preview\n                    MultiButtons = c.MultiButtons.Select(b => new CampaignButtonDto \n                    {\n                        ButtonText = b.Title,\n                        ButtonType = b.Type, \n                        Value = b.Value, \n                        Position = b.Position \n                    }).ToList()\n                })\n                .ToListAsync();\n        }\n\n        public async Task<List<ContactDto>> GetRecipientsByCampaignIdAsync(Guid campaignId, Guid businessId)\n        {\n            var recipients = await _context.CampaignRecipients\n                .Include(r => r.Contact)\n                .Where(r => r.CampaignId == campaignId && r.Contact.BusinessId == businessId)\n                .Select(r => new ContactDto\n                {\n                    Id = r.Contact.Id,\n                    Name = r.Contact.Name,\n                    PhoneNumber = r.Contact.PhoneNumber,\n                    Email = r.Contact.Email,\n                    LeadSource = r.Contact.LeadSource,\n                    CreatedAt = r.Contact.CreatedAt\n                })\n                .ToListAsync();\n\n            return recipients;\n        }\n\n        public async Task<PaginatedResponse<CampaignSummaryDto>> GetPaginatedCampaignsAsync(Guid businessId, PaginatedRequest request)\n        {\n            var query = _context.Campaigns\n                .Where(c => c.BusinessId == businessId)\n                .OrderByDescending(c => c.CreatedAt);\n\n            var total = await query.CountAsync();\n\n            var items = await query\n                .Skip((request.Page - 1) * request.PageSize)\n                .Take(request.PageSize)\n                .Select(c => new CampaignSummaryDto\n                {\n                    Id = c.Id,\n                    Name = c.Name,\n                    Status = c.Status,\n                    ScheduledAt = c.ScheduledAt,\n                    CreatedAt = c.CreatedAt,\n                    SentAt = c.Status == \"Sent\" || c.Status == \"Completed\" ? c.UpdatedAt : null, // ‚úÖ Map SentAt\n                    MessageTemplate = c.MessageTemplate, // ‚úÖ Map for preview\n                    MultiButtons = c.MultiButtons.Select(b => new CampaignButtonDto \n                    {\n                        ButtonText = b.Title,\n                        ButtonType = b.Type, \n                        Value = b.Value, \n                        Position = b.Position \n                    }).ToList()\n                })\n                .ToListAsync();\n\n            return new PaginatedResponse<CampaignSummaryDto>\n            {\n                Items = items,\n                TotalCount = total,\n                Page = request.Page,\n                PageSize = request.PageSize\n            };\n        }\n        public async Task<bool> UpdateCampaignAsync(Guid id, CampaignCreateDto dto)\n        {\n            var campaign = await _context.Campaigns.FindAsync(id);\n            if (campaign == null || campaign.Status != \"Draft\")\n                return false;\n\n            // ‚úÖ Extract BusinessId from current campaign\n            var businessId = campaign.BusinessId;\n\n            // ‚úÖ Optional CTA ownership validation\n            if (dto.CtaId.HasValue)\n            {\n                var cta = await _context.CTADefinitions\n                    .FirstOrDefaultAsync(c => c.Id == dto.CtaId && c.BusinessId == businessId && c.IsActive);\n\n                if (cta == null)\n                    throw new UnauthorizedAccessException(\"‚ùå The selected CTA does not belong to your business or is inactive.\");\n            }\n\n            // ‚úèÔ∏è Update campaign fields\n            campaign.Name = dto.Name;\n            campaign.MessageTemplate = dto.MessageTemplate;\n            campaign.TemplateId = dto.TemplateId;\n            campaign.FollowUpTemplateId = dto.FollowUpTemplateId;\n            campaign.CampaignType = dto.CampaignType;\n            campaign.CtaId = dto.CtaId;\n            campaign.ImageUrl = dto.ImageUrl;\n            campaign.ImageCaption = dto.ImageCaption;\n            campaign.UpdatedAt = DateTime.UtcNow;\n            // üîí Step 2.1: Refresh snapshot on update when template may have changed\n            try\n            {\n                var effectiveTemplateName = !string.IsNullOrWhiteSpace(campaign.TemplateId)\n                    ? campaign.TemplateId!\n                    : (campaign.MessageTemplate ?? \"\");\n\n                if (!string.IsNullOrWhiteSpace(effectiveTemplateName))\n                {\n                    var snapshotMeta = await _templateFetcherService.GetTemplateMetaAsync(\n                        businessId,\n                        effectiveTemplateName,\n                        language: null,\n                        provider: campaign.Provider\n                    );\n\n                    campaign.TemplateSchemaSnapshot = snapshotMeta != null\n                        ? JsonConvert.SerializeObject(snapshotMeta)\n                        : JsonConvert.SerializeObject(new\n                        {\n                            Provider = campaign.Provider ?? \"\",\n                            TemplateName = effectiveTemplateName,\n                            Language = \"\" // unknown if not in provider meta\n                        });\n                }\n            }\n            catch (Exception ex)\n            {\n                Log.Warning(ex, \"‚ö†Ô∏è Template schema snapshot (update) failed for campaign {CampaignId}\", id);\n            }\n\n            await _context.SaveChangesAsync();\n            return true;\n        }\n\n        public async Task<CampaignDeletionResult> DeleteCampaignAsync(\n        Guid businessId,\n        Guid id,\n        CampaignDeletionOptions options,\n        CancellationToken ct = default)\n        {\n            // 1) Ownership + existence\n            var campaign = await _context.Campaigns\n                .FirstOrDefaultAsync(c => c.Id == id && c.BusinessId == businessId, ct);\n\n            if (campaign == null)\n                return CampaignDeletionResult.NotFound();\n\n            // 2) Usage snapshot (for UX & guards)\n            var recipients = await _context.CampaignRecipients.CountAsync(r => r.CampaignId == id, ct);\n\n            var activeJobStatuses = new[] { \"queued\", \"pending\", \"retry\", \"scheduled\", \"inprogress\", \"processing\", \"sending\" };\n            var queuedJobs = await _context.OutboundCampaignJobs\n                .CountAsync(j => j.CampaignId == id && activeJobStatuses.Contains((j.Status ?? \"\").ToLower()), ct);\n\n            var sendLogs = await _context.CampaignSendLogs.CountAsync(s => s.CampaignId == id, ct);\n\n            var isSending = ((campaign.Status ?? \"\").Equals(\"sending\", StringComparison.OrdinalIgnoreCase)) || queuedJobs > 0;\n\n            if (isSending && !options.Force)\n                return CampaignDeletionResult.BlockedSending(recipients, queuedJobs, sendLogs);\n\n            var clean = recipients == 0 && queuedJobs == 0 && sendLogs == 0;\n            if (!options.Force && !clean)\n                return CampaignDeletionResult.BlockedState(recipients, queuedJobs, sendLogs);\n\n            // 3) Transaction: purge RESTRICT chains first, then remove campaign (CASCADE handles the rest)\n            await using var tx = await _context.Database.BeginTransactionAsync(ct);\n            try\n            {\n                // 3A) Collect dependent ids (for TrackingLogs purge)\n                var msgIds = await _context.MessageLogs\n                    .Where(m => m.BusinessId == businessId && m.CampaignId == id)\n                    .Select(m => m.Id)\n                    .ToListAsync(ct);\n\n                var sendIds = await _context.CampaignSendLogs\n                    .Where(s => s.BusinessId == businessId && s.CampaignId == id)\n                    .Select(s => s.Id)\n                    .ToListAsync(ct);\n\n                // 3B) Purge TrackingLogs (FKs to Campaign/MessageLog/SendLog are RESTRICT)\n#if NET7_0_OR_GREATER\n                await _context.TrackingLogs\n                    .Where(t => t.CampaignId == id\n                        || (t.MessageLogId != null && msgIds.Contains(t.MessageLogId.Value))\n                        || (t.CampaignSendLogId != null && sendIds.Contains(t.CampaignSendLogId.Value)))\n                    .ExecuteDeleteAsync(ct);\n#else\n        // EF Core < 7 fallback\n                    await _db.Database.ExecuteSqlRawAsync(@\"\n            DELETE FROM \"\"TrackingLogs\"\"\n            WHERE \"\"CampaignId\"\" = {0}\n               OR (\"\"MessageLogId\"\" IS NOT NULL AND \"\"MessageLogId\"\" = ANY({1}))\n               OR (\"\"CampaignSendLogId\"\" IS NOT NULL AND \"\"CampaignSendLogId\"\" = ANY({2}));\n            \", new object[] { id, msgIds.ToArray(), sendIds.ToArray() }, ct);\n#endif\n\n                // 3C) Clear any outstanding jobs (if not configured to cascade)\n#if NET7_0_OR_GREATER\n                await _context.OutboundCampaignJobs\n                    .Where(j => j.CampaignId == id)\n                    .ExecuteDeleteAsync(ct);\n#else\n        var jobs = await _db.OutboundCampaignJobs.Where(j => j.CampaignId == id).ToListAsync(ct);\n        _db.OutboundCampaignJobs.RemoveRange(jobs);\n        await _db.SaveChangesAsync(ct);\n#endif\n\n                // 3D) Delete the campaign (CASCADE removes audiences, members, recipients,\n                //     send logs, message logs, status logs, etc. per your Fluent config)\n                _context.Campaigns.Remove(campaign);\n                await _context.SaveChangesAsync(ct);\n\n                await tx.CommitAsync(ct);\n\n                return CampaignDeletionResult.Deleted(recipients, queuedJobs, sendLogs);\n            }\n            catch (DbUpdateException)\n            {\n                await tx.RollbackAsync(ct);\n                return new CampaignDeletionResult { Status = CampaignDeletionStatus.Error };\n            }\n        }\n\n        #endregion\n\n        #region // üÜï CreateCampaignAsync(Text/Image)\n\n\n      \n        public async Task<Guid?> CreateTextCampaignAsync(CampaignCreateDto dto, Guid businessId, string createdBy)\n        {\n            // ‚úÖ Normalize campaign name once (trim + case-insensitive key)\n            var normalizedName = (dto?.Name ?? string.Empty).Trim();\n            var nameKey = normalizedName.ToLowerInvariant();\n\n            // ‚úÖ Duplicate-name guard (per business)\n            var nameExists = await _context.Campaigns\n                .AsNoTracking()\n                .AnyAsync(c =>\n                    c.BusinessId == businessId &&\n                    c.Name != null &&\n                    c.Name.ToLower() == nameKey\n                // && !c.IsDeleted   // üîÅ Enable if Campaign supports soft delete\n                );\n\n            if (nameExists)\n                throw new InvalidOperationException(\"A campaign with this name already exists for this business. Please choose a different name.\");\n\n            // ‚úÖ Transaction: campaign + recipients + buttons + (maybe) job must be atomic\n            await using var tx = await _context.Database.BeginTransactionAsync();\n\n            try\n            {\n                var campaignId = Guid.NewGuid();\n\n                // Parse template parameters once\n                var parsedParams = TemplateParameterHelper.ParseTemplateParams(\n                    JsonConvert.SerializeObject(dto.TemplateParameters ?? new List<string>())\n                );\n\n                // Validate + resolve sender (optional)\n                string? providerNorm = null;\n                if (!string.IsNullOrWhiteSpace(dto.PhoneNumberId))\n                {\n                    var pair = await _whisatsAppSenderService.ResolveSenderPairAsync(businessId, dto.PhoneNumberId);\n                    if (pair == null)\n                        throw new InvalidOperationException(\"‚ùå Selected sender is invalid or does not belong to this business.\");\n                    providerNorm = pair.Value.Provider; // normalized to UPPER\n                }\n\n                // Flow id from UI (null/empty => no flow)\n                Guid? incomingFlowId = (dto.CTAFlowConfigId.HasValue && dto.CTAFlowConfigId.Value != Guid.Empty)\n                    ? dto.CTAFlowConfigId.Value\n                    : (Guid?)null;\n\n                Guid? savedFlowId = incomingFlowId;\n\n                // FLOW VALIDATION (align starting template if flow provided)\n                string selectedTemplateName = dto.TemplateId ?? dto.MessageTemplate ?? string.Empty;\n\n                CTAFlowConfig? flow = null;\n                CTAFlowStep? entryStep = null;\n\n                if (incomingFlowId.HasValue)\n                {\n                    flow = await _context.CTAFlowConfigs\n                        .Include(f => f.Steps).ThenInclude(s => s.ButtonLinks)\n                        .FirstOrDefaultAsync(f =>\n                            f.Id == incomingFlowId.Value &&\n                            f.BusinessId == businessId &&\n                            f.IsActive);\n\n                    if (flow != null)\n                    {\n                        var allIncoming = new HashSet<Guid>(flow.Steps\n                            .SelectMany(s => s.ButtonLinks)\n                            .Where(l => l.NextStepId.HasValue)\n                            .Select(l => l.NextStepId!.Value));\n\n                        entryStep = flow.Steps\n                            .OrderBy(s => s.StepOrder)\n                            .FirstOrDefault(s => !allIncoming.Contains(s.Id));\n\n                        if (entryStep != null &&\n                            !string.Equals(selectedTemplateName, entryStep.TemplateToSend, StringComparison.OrdinalIgnoreCase))\n                        {\n                            selectedTemplateName = entryStep.TemplateToSend;\n                        }\n                    }\n                }\n\n                // Fetch template strictly from DB\n                var template = await _templateFetcherService.GetTemplateByNameAsync(\n                    businessId,\n                    selectedTemplateName,\n                    includeButtons: true\n                );\n                if (template == null)\n                    throw new InvalidOperationException($\"Template '{selectedTemplateName}' not found.\");\n\n                var templateBody = template.Body ?? string.Empty;\n                var resolvedBody = TemplateParameterHelper.FillPlaceholders(templateBody, parsedParams);\n\n                // Header kind + URL logic\n                var headerKind = (template.HeaderKind ?? dto.HeaderKind ?? \"none\").Trim().ToLowerInvariant();\n\n                if (!string.IsNullOrWhiteSpace(dto.HeaderKind) &&\n                    !string.Equals(headerKind, dto.HeaderKind.Trim().ToLowerInvariant(), StringComparison.Ordinal))\n                {\n                    throw new InvalidOperationException($\"Selected template requires a '{headerKind}' header, but request specified '{dto.HeaderKind}'.\");\n                }\n\n                bool isMediaHeader = headerKind is \"image\" or \"video\" or \"document\";\n\n                string? headerUrl = string.IsNullOrWhiteSpace(dto.HeaderMediaUrl)\n                    ? (headerKind == \"image\" ? dto.ImageUrl : null)\n                    : dto.HeaderMediaUrl;\n\n                if (isMediaHeader && string.IsNullOrWhiteSpace(headerUrl))\n                    throw new InvalidOperationException(\"‚ùå Header media URL is required for this template.\");\n\n                string finalCampaignType = isMediaHeader\n                    ? headerKind\n                    : (dto.CampaignType ?? \"text\").Trim().ToLowerInvariant();\n\n                if (finalCampaignType is not (\"image\" or \"video\" or \"document\"))\n                    finalCampaignType = \"text\";\n\n                var campaign = new Campaign\n                {\n                    Id = campaignId,\n                    BusinessId = businessId,\n\n                    // ‚úÖ store trimmed name\n                    Name = normalizedName,\n\n                    MessageTemplate = dto.MessageTemplate,\n                    TemplateId = selectedTemplateName,\n\n                    FollowUpTemplateId = dto.FollowUpTemplateId,\n                    CampaignType = finalCampaignType,\n                    CtaId = dto.CtaId,\n                    CTAFlowConfigId = savedFlowId,\n\n                    ScheduledAt = dto.ScheduledAt,\n                    CreatedBy = createdBy,\n                    CreatedAt = DateTime.UtcNow,\n                    UpdatedAt = DateTime.UtcNow,\n\n                    Status = \"Draft\",\n\n                    ImageUrl = headerKind == \"image\" ? headerUrl : null,\n                    ImageCaption = dto.ImageCaption,\n                    VideoUrl = headerKind == \"video\" ? headerUrl : null,\n                    DocumentUrl = headerKind == \"document\" ? headerUrl : null,\n\n                    TemplateParameters = JsonConvert.SerializeObject(dto.TemplateParameters ?? new List<string>()),\n                    MessageBody = resolvedBody,\n\n                    Provider = providerNorm,\n                    PhoneNumberId = dto.PhoneNumberId\n                };\n\n                // Snapshot template schema\n                try\n                {\n                    var snapshotMeta = await _templateFetcherService.GetTemplateMetaAsync(\n                        businessId,\n                        selectedTemplateName,\n                        language: null,\n                        provider: providerNorm?.ToLowerInvariant()\n                    );\n\n                    campaign.TemplateSchemaSnapshot = snapshotMeta != null\n                        ? JsonConvert.SerializeObject(snapshotMeta)\n                        : JsonConvert.SerializeObject(new\n                        {\n                            Provider = providerNorm ?? \"\",\n                            TemplateName = selectedTemplateName,\n                            Language = template.Language ?? \"\"\n                        });\n                }\n                catch (Exception ex)\n                {\n                    Log.Warning(ex, \"‚ö†Ô∏è Template schema snapshot failed for campaign {CampaignId}\", campaignId);\n                }\n\n                await _context.Campaigns.AddAsync(campaign);\n\n                // Recipients\n                if (dto.ContactIds != null && dto.ContactIds.Any())\n                {\n                    // ‚úÖ Optional: dedupe contactIds to avoid duplicate recipient rows\n                    var uniqueContactIds = dto.ContactIds.Distinct().ToList();\n\n                    var recipients = uniqueContactIds.Select(contactId => new CampaignRecipient\n                    {\n                        Id = Guid.NewGuid(),\n                        CampaignId = campaignId,\n                        ContactId = contactId,\n                        BusinessId = businessId,\n                        Status = \"Pending\",\n                        SentAt = null,\n                        UpdatedAt = DateTime.UtcNow\n                    });\n\n                    await _context.CampaignRecipients.AddRangeAsync(recipients);\n                }\n\n                // Custom buttons from FE\n                if (dto.MultiButtons != null && dto.MultiButtons.Any())\n                {\n                    var buttons = dto.MultiButtons\n                        .Where(btn => !string.IsNullOrWhiteSpace(btn.ButtonText) && !string.IsNullOrWhiteSpace(btn.TargetUrl))\n                        .Take(3)\n                        .Select((btn, index) => new CampaignButton\n                        {\n                            Id = Guid.NewGuid(),\n                            CampaignId = campaignId,\n                            Title = btn.ButtonText,\n                            Type = btn.ButtonType ?? \"url\",\n                            Value = btn.TargetUrl,\n                            Position = index + 1,\n                            IsFromTemplate = false\n                        });\n\n                    await _context.CampaignButtons.AddRangeAsync(buttons);\n                }\n\n                // Buttons from template meta\n                if (template.ButtonParams?.Count > 0)\n                {\n                    var buttonsToSave = new List<CampaignButton>();\n                    var userButtons = dto.ButtonParams ?? new List<CampaignButtonParamFromMetaDto>();\n\n                    var total = Math.Min(3, template.ButtonParams.Count);\n                    for (int i = 0; i < total; i++)\n                    {\n                        var tplBtn = template.ButtonParams[i];\n                        var isDynamic = (tplBtn.ParameterValue?.Contains(\"{{1}}\") ?? false);\n\n                        var userBtn = userButtons.FirstOrDefault(b => b.Position == i + 1);\n                        var valueToSave = (isDynamic && userBtn != null)\n                            ? userBtn.Value?.Trim()\n                            : tplBtn.ParameterValue;\n\n                        buttonsToSave.Add(new CampaignButton\n                        {\n                            Id = Guid.NewGuid(),\n                            CampaignId = campaignId,\n                            Title = tplBtn.Text,\n                            Type = tplBtn.Type,\n                            Value = valueToSave,\n                            Position = i + 1,\n                            IsFromTemplate = true\n                        });\n                    }\n\n                    await _context.CampaignButtons.AddRangeAsync(buttonsToSave);\n                }\n\n                // schedule-aware status + enqueue job\n                var nowUtc = DateTime.UtcNow;\n                if (campaign.ScheduledAt.HasValue && campaign.ScheduledAt.Value > nowUtc)\n                {\n                    campaign.Status = \"Queued\";\n                    campaign.UpdatedAt = nowUtc;\n\n                    var job = new OutboundCampaignJob\n                    {\n                        Id = Guid.NewGuid(),\n                        BusinessId = businessId,\n                        CampaignId = campaign.Id,\n                        Status = \"queued\",\n                        Attempt = 0,\n                        MaxAttempts = 5,\n                        NextAttemptAt = campaign.ScheduledAt.Value\n                    };\n                    await _context.OutboundCampaignJobs.AddAsync(job);\n                }\n                else\n                {\n                    campaign.Status = \"Draft\";\n                }\n\n                await _context.SaveChangesAsync();\n                await tx.CommitAsync();\n\n                Log.Information(\"‚úÖ Campaign '{Name}' created | Type:{Type} | Header:{HeaderKind} | FlowId:{Flow} | EntryTemplate:{Entry} | Sender:{Provider}/{PhoneId} | Recipients:{Contacts} | ScheduledAt:{ScheduledAt} | Status:{Status}\",\n                    normalizedName, finalCampaignType, headerKind,\n                    savedFlowId,\n                    entryStep?.TemplateToSend ?? selectedTemplateName,\n                    providerNorm,\n                    dto.PhoneNumberId,\n                    dto.ContactIds?.Count ?? 0,\n                    campaign.ScheduledAt,\n                    campaign.Status);\n\n                return campaignId;\n            }\n            catch (Exception ex)\n            {\n                await tx.RollbackAsync();\n                Log.Error(ex, \"‚ùå Failed to create campaign\");\n                return null;\n            }\n        }\n\n      \n        public async Task<Guid> CreateImageCampaignAsync(Guid businessId, CampaignCreateDto dto, string createdBy)\n        {\n            // ‚úÖ Normalize campaign name once (trim + case-insensitive key)\n            var normalizedName = (dto?.Name ?? string.Empty).Trim();\n            var nameKey = normalizedName.ToLowerInvariant();\n\n            // ‚úÖ Duplicate-name guard (per business)\n            var nameExists = await _context.Campaigns\n                .AsNoTracking()\n                .AnyAsync(c =>\n                    c.BusinessId == businessId &&\n                    c.Name != null &&\n                    c.Name.ToLower() == nameKey\n                // && !c.IsDeleted   // üîÅ Enable if Campaign supports soft delete\n                );\n\n            if (nameExists)\n                throw new InvalidOperationException(\"A campaign with this name already exists for this business. Please choose a different name.\");\n\n            var campaignId = Guid.NewGuid();\n\n            // ‚úÖ Transaction: campaign + recipients + buttons must be atomic\n            await using var tx = await _context.Database.BeginTransactionAsync();\n\n            try\n            {\n                // üîÅ Parse/normalize template parameters once\n                var parsedParams = TemplateParameterHelper.ParseTemplateParams(\n                    JsonConvert.SerializeObject(dto.TemplateParameters ?? new List<string>())\n                );\n\n                // üîÑ Flow id from UI (null/empty => no flow). We will persist this as-is.\n                Guid? incomingFlowId = (dto.CTAFlowConfigId.HasValue && dto.CTAFlowConfigId.Value != Guid.Empty)\n                    ? dto.CTAFlowConfigId.Value\n                    : (Guid?)null;\n\n                // We will save this value regardless of validation outcome\n                Guid? savedFlowId = incomingFlowId;\n\n                // ============================================================\n                // üß© FLOW VALIDATION (only to align the starting template)\n                // ============================================================\n                string selectedTemplateName = dto.TemplateId ?? dto.MessageTemplate ?? string.Empty;\n\n                CTAFlowConfig? flow = null;\n                CTAFlowStep? entryStep = null;\n\n                if (incomingFlowId.HasValue)\n                {\n                    // load flow with steps+links and verify ownership\n                    flow = await _context.CTAFlowConfigs\n                        .Include(f => f.Steps).ThenInclude(s => s.ButtonLinks)\n                        .FirstOrDefaultAsync(f =>\n                            f.Id == incomingFlowId.Value &&\n                            f.BusinessId == businessId &&\n                            f.IsActive);\n\n                    if (flow == null)\n                    {\n                        Log.Warning(\"‚ùå Flow {FlowId} not found/active for business {Biz}. Will persist FlowId but not align template.\",\n                            incomingFlowId, businessId);\n                    }\n                    else\n                    {\n                        // compute entry step: step with NO incoming links\n                        var allIncoming = new HashSet<Guid>(flow.Steps\n                            .SelectMany(s => s.ButtonLinks)\n                            .Where(l => l.NextStepId.HasValue)\n                            .Select(l => l.NextStepId!.Value));\n\n                        entryStep = flow.Steps\n                            .OrderBy(s => s.StepOrder)\n                            .FirstOrDefault(s => !allIncoming.Contains(s.Id));\n\n                        if (entryStep == null)\n                        {\n                            Log.Warning(\"‚ùå Flow {FlowId} has no entry step. Persisting FlowId but not aligning template.\", flow.Id);\n                        }\n                        else if (!string.Equals(selectedTemplateName, entryStep.TemplateToSend, StringComparison.OrdinalIgnoreCase))\n                        {\n                            Log.Information(\"‚ÑπÔ∏è Aligning selected template '{Sel}' to flow entry '{Entry}'.\",\n                                selectedTemplateName, entryStep.TemplateToSend);\n                            selectedTemplateName = entryStep.TemplateToSend;\n                        }\n                    }\n                }\n                else\n                {\n                    Log.Information(\"‚ÑπÔ∏è No flow attached to image campaign '{Name}'. Proceeding as plain template campaign.\", normalizedName);\n                }\n\n                // üß† Fetch template (for body + buttons) using the aligned/selected template name\n                var template = await _templateFetcherService.GetTemplateByNameAsync(\n                    businessId,\n                    selectedTemplateName,\n                    includeButtons: true\n                );\n\n                // üß† Resolve message body using template body (if available) else dto.MessageTemplate\n                var templateBody = template?.Body ?? dto.MessageTemplate ?? string.Empty;\n                var resolvedBody = TemplateParameterHelper.FillPlaceholders(templateBody, parsedParams);\n\n                // üéØ Step 1: Create campaign (CTAFlowConfigId now always = savedFlowId)\n                var campaign = new Campaign\n                {\n                    Id = campaignId,\n                    BusinessId = businessId,\n\n                    // ‚úÖ store trimmed name\n                    Name = normalizedName,\n\n                    // store the (possibly aligned) template name\n                    MessageTemplate = dto.MessageTemplate,      // keep original text for UI if you use it\n                    TemplateId = selectedTemplateName,          // ensure start template matches flow entry when available\n\n                    FollowUpTemplateId = dto.FollowUpTemplateId,\n                    CampaignType = \"image\",\n                    CtaId = dto.CtaId,\n                    CTAFlowConfigId = savedFlowId,              // üëà persist what UI sent (or null if no flow)\n\n                    ScheduledAt = dto.ScheduledAt,\n                    CreatedBy = createdBy,\n                    CreatedAt = DateTime.UtcNow,\n                    UpdatedAt = DateTime.UtcNow,\n                    Status = \"Draft\",\n\n                    // image-specific fields\n                    ImageUrl = dto.ImageUrl,\n                    ImageCaption = dto.ImageCaption,\n\n                    // params/body snapshot (useful for previews & auditing)\n                    TemplateParameters = JsonConvert.SerializeObject(dto.TemplateParameters ?? new List<string>()),\n                    MessageBody = resolvedBody\n                };\n\n                // üîí Step 2.1: Snapshot template schema (image path)\n                try\n                {\n                    var snapshotMeta = await _templateFetcherService.GetTemplateMetaAsync(\n                        businessId,\n                        selectedTemplateName,\n                        language: null,\n                        provider: null\n                    );\n\n                    campaign.TemplateSchemaSnapshot = snapshotMeta != null\n                        ? JsonConvert.SerializeObject(snapshotMeta)\n                        : JsonConvert.SerializeObject(new\n                        {\n                            Provider = \"\",\n                            TemplateName = selectedTemplateName,\n                            Language = template?.Language ?? \"\"\n                        });\n                }\n                catch (Exception ex)\n                {\n                    Log.Warning(ex, \"‚ö†Ô∏è Template schema snapshot failed for (image) campaign {CampaignId}\", campaignId);\n                }\n\n                await _context.Campaigns.AddAsync(campaign);\n\n                // ‚úÖ Step 2: Assign contacts (leave SentAt null until send)\n                if (dto.ContactIds != null && dto.ContactIds.Any())\n                {\n                    // ‚úÖ Optional: dedupe contactIds to avoid duplicate recipient rows\n                    var uniqueContactIds = dto.ContactIds.Distinct().ToList();\n\n                    var recipients = uniqueContactIds.Select(contactId => new CampaignRecipient\n                    {\n                        Id = Guid.NewGuid(),\n                        CampaignId = campaignId,\n                        ContactId = contactId,\n                        BusinessId = businessId,\n                        Status = \"Pending\",\n                        SentAt = null,\n                        UpdatedAt = DateTime.UtcNow\n                    });\n\n                    await _context.CampaignRecipients.AddRangeAsync(recipients);\n                }\n\n                // ‚úÖ Step 3a: Save manual buttons from frontend\n                if (dto.MultiButtons != null && dto.MultiButtons.Any())\n                {\n                    var buttons = dto.MultiButtons\n                        .Where(btn => !string.IsNullOrWhiteSpace(btn.ButtonText) && !string.IsNullOrWhiteSpace(btn.TargetUrl))\n                        .Take(3)\n                        .Select((btn, index) => new CampaignButton\n                        {\n                            Id = Guid.NewGuid(),\n                            CampaignId = campaignId,\n                            Title = btn.ButtonText,\n                            Type = btn.ButtonType ?? \"url\",\n                            Value = btn.TargetUrl,\n                            Position = index + 1,\n                            IsFromTemplate = false\n                        });\n\n                    await _context.CampaignButtons.AddRangeAsync(buttons);\n                }\n\n                // ======================== Dynamic buttons merge ========================\n                if (template != null && template.ButtonParams?.Count > 0)\n                {\n                    var buttonsToSave = new List<CampaignButton>();\n                    var userButtons = dto.ButtonParams ?? new List<CampaignButtonParamFromMetaDto>();\n\n                    var total = Math.Min(3, template.ButtonParams.Count);\n                    for (int i = 0; i < total; i++)\n                    {\n                        var tplBtn = template.ButtonParams[i];\n                        var isDynamic = (tplBtn.ParameterValue?.Contains(\"{{1}}\") ?? false);\n\n                        var userBtn = userButtons.FirstOrDefault(b => b.Position == i + 1);\n                        var valueToSave = (isDynamic && userBtn != null)\n                            ? userBtn.Value?.Trim()\n                            : tplBtn.ParameterValue;\n\n                        buttonsToSave.Add(new CampaignButton\n                        {\n                            Id = Guid.NewGuid(),\n                            CampaignId = campaignId,\n                            Title = tplBtn.Text,\n                            Type = tplBtn.Type,\n                            Value = valueToSave,\n                            Position = i + 1,\n                            IsFromTemplate = true\n                        });\n                    }\n\n                    await _context.CampaignButtons.AddRangeAsync(buttonsToSave);\n                }\n                // ======================================================================\n\n                await _context.SaveChangesAsync();\n                await tx.CommitAsync();\n\n                Log.Information(\"‚úÖ Image campaign '{Name}' created | FlowId: {Flow} | EntryTemplate: {Entry} | Recipients: {Contacts} | UserButtons: {ManualButtons} | TemplateButtons: {TemplateButtons} | Params: {Params}\",\n                    normalizedName,\n                    savedFlowId,\n                    entryStep?.TemplateToSend ?? selectedTemplateName,\n                    dto.ContactIds?.Count ?? 0,\n                    dto.MultiButtons?.Count ?? 0,\n                    template?.ButtonParams?.Count ?? 0,\n                    dto.TemplateParameters?.Count ?? 0\n                );\n\n                return campaignId;\n            }\n            catch\n            {\n                await tx.RollbackAsync();\n                throw;\n            }\n        }\n\n\n\n        #endregion\n\n\n        public async Task<bool> SendCampaignAsync(Guid campaignId, string ipAddress, string userAgent)\n        {\n            // 1) Load campaign (no tracking)\n            var campaign = await _context.Campaigns\n                .Where(c => c.Id == campaignId)\n                .Select(c => new { c.Id, c.BusinessId, c.TemplateId, MessageTemplate = c.MessageTemplate })\n                .AsNoTracking()\n                .FirstOrDefaultAsync();\n\n            if (campaign == null)\n            {\n                Log.Warning(\"üö´ Campaign {CampaignId} not found\", campaignId);\n                return false;\n            }\n\n            // 1.1) Resolve active WA settings ‚Üí Provider + sender (optional)\n            var wa = await _whatsAppSettingsService.GetSettingsByBusinessIdAsync(campaign.BusinessId);\n            //if (wa is null)\n            //return ResponseResult.ErrorInfo(\"‚ùå WhatsApp settings not found for this business.\");\n\n            //.AsNoTracking()\n            //.Where(w => w.BusinessId == campaign.BusinessId && w.IsActive)\n            //.FirstOrDefaultAsync();\n\n            var provider = wa.Provider;\n            var phoneNumberId = wa.PhoneNumberId;         // optional\n\n            // 2) Load recipients with explicit LEFT JOINs to Contact and AudienceMember\n            var recipients = await (\n                from r in _context.CampaignRecipients.AsNoTracking()\n                where r.CampaignId == campaignId\n\n                join c in _context.Contacts.AsNoTracking()\n                    on r.ContactId equals c.Id into cg\n                from c in cg.DefaultIfEmpty()\n\n                join am in _context.AudienceMembers.AsNoTracking()\n                    on r.AudienceMemberId equals am.Id into amg\n                from am in amg.DefaultIfEmpty()\n\n                select new\n                {\n                    r.Id,\n                    r.ContactId,\n                    Phone = c != null && c.PhoneNumber != null ? c.PhoneNumber : am!.PhoneE164,\n                    Name = c != null && c.Name != null ? c.Name : am!.Name,\n                    ParamsJson = r.ResolvedParametersJson\n                })\n                .Where(x => !string.IsNullOrWhiteSpace(x.Phone))\n                .ToListAsync();\n\n            if (recipients.Count == 0)\n            {\n                Log.Warning(\"üö´ Campaign {CampaignId} has no recipients\", campaignId);\n                return false;\n            }\n\n            // 3) Mark Sending\n            var campaignRow = await _context.Campaigns.FirstAsync(c => c.Id == campaign.Id);\n            campaignRow.Status = \"Sending\";\n            campaignRow.UpdatedAt = DateTime.UtcNow;\n            await _context.SaveChangesAsync();\n\n            // 4) Parallel send\n            var throttleLimit = 5;\n            var total = recipients.Count;\n            var sent = 0;\n            var failed = 0;\n\n            await Parallel.ForEachAsync(\n                recipients,\n                new ParallelOptions { MaxDegreeOfParallelism = throttleLimit },\n                async (r, ct) =>\n                {\n                    try\n                    {\n                        var phone = r.Phone!;\n                        // NOTE: we intentionally do NOT inject profile name here.\n                        // Parameters come from frozen ResolvedParametersJson (if any).\n                        var parameters = ParseParams(r.ParamsJson);\n\n                        using var scope = _serviceProvider.CreateScope();\n                        var scopedDb = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n\n                        var dto = new SimpleTemplateMessageDto\n                        {\n                            Provider = provider,                 // ‚úÖ REQUIRED by send method\n                            PhoneNumberId = phoneNumberId,       // optional sender override\n                            RecipientNumber = phone,\n                            TemplateName = campaign.TemplateId ?? campaign.MessageTemplate,\n                            TemplateParameters = parameters      // ‚úÖ use frozen params (or empty list)\n                        };\n\n                        var result = await _messageEngineService\n                            .SendTemplateMessageSimpleAsync(campaign.BusinessId, dto);\n\n                        var sendLog = new CampaignSendLog\n                        {\n                            Id = Guid.NewGuid(),\n                            BusinessId = campaign.BusinessId,\n                            CampaignId = campaign.Id,\n                            ContactId = r.ContactId,            // Guid? OK to be null\n                            RecipientId = r.Id,\n                            TemplateId = campaign.TemplateId,\n                            MessageBody = campaign.MessageTemplate,\n                            MessageId = result.MessageId,       // ‚úÖ capture WAMID\n                            SendStatus = result.Success ? \"Sent\" : \"Failed\",\n                            ErrorMessage = result.Message,\n                            SentAt = DateTime.UtcNow,\n                            CreatedAt = DateTime.UtcNow,\n                            SourceChannel = \"whatsapp\",\n                            IpAddress = ipAddress,\n                            DeviceInfo = userAgent\n                            // (Optional) ButtonBundleJson = SnapshotTemplateButtons(...);\n                        };\n\n                        await scopedDb.CampaignSendLogs.AddAsync(sendLog, ct);\n\n                        var rec = await scopedDb.CampaignRecipients.FirstOrDefaultAsync(x => x.Id == r.Id, ct);\n                        if (rec != null)\n                        {\n                            rec.Status = result.Success ? \"Sent\" : \"Failed\";\n                            rec.MessagePreview = campaign.MessageTemplate;\n                            rec.SentAt = DateTime.UtcNow;\n                            rec.UpdatedAt = DateTime.UtcNow;\n                        }\n\n                        await scopedDb.SaveChangesAsync(ct);\n\n                        if (result.Success) Interlocked.Increment(ref sent);\n                        else Interlocked.Increment(ref failed);\n                    }\n                    catch (Exception ex)\n                    {\n                        Interlocked.Increment(ref failed);\n                        Log.Error(ex, \"‚ùå Send failed for recipient: {RecipientId}\", r.Id);\n                    }\n                });\n\n            // 5) Finalize\n            campaignRow = await _context.Campaigns.FirstAsync(c => c.Id == campaignId);\n            campaignRow.Status = \"Sent\";\n            campaignRow.UpdatedAt = DateTime.UtcNow;\n            await _context.SaveChangesAsync();\n\n            Log.Information(\"üì§ Campaign {CampaignId} sent via template to {Count} recipients (‚úÖ {Sent}, ‚ùå {Failed})\",\n                campaignId, total, sent, failed);\n\n            return sent > 0;\n\n            // ---- local helpers ----\n            static List<string> ParseParams(string? json)\n            {\n                if (string.IsNullOrWhiteSpace(json)) return new List<string>();\n                try\n                {\n                    var arr = System.Text.Json.JsonSerializer.Deserialize<List<string>>(json);\n                    return arr ?? new List<string>();\n                }\n                catch\n                {\n                    return new List<string>();\n                }\n            }\n        }\n        public async Task<bool> SendCampaignInParallelAsync(Guid campaignId, string ipAddress, string userAgent)\n        {\n            var campaign = await _context.Campaigns\n                .Include(c => c.Recipients)\n                .ThenInclude(r => r.Contact)\n                .FirstOrDefaultAsync(c => c.Id == campaignId);\n\n            if (campaign == null || campaign.Recipients.Count == 0)\n            {\n                Log.Warning(\"üö´ Campaign not found or has no recipients\");\n                return false;\n            }\n\n            campaign.Status = \"Sending\";\n            campaign.UpdatedAt = DateTime.UtcNow;\n            await _context.SaveChangesAsync();\n\n            int maxParallelism = 5;\n\n#if NET6_0_OR_GREATER\n            await Parallel.ForEachAsync(campaign.Recipients, new ParallelOptions\n            {\n                MaxDegreeOfParallelism = maxParallelism\n            },\n            async (recipient, cancellationToken) =>\n            {\n                await SendToRecipientAsync(campaign, recipient, ipAddress, userAgent);\n            });\n#else\n    var tasks = campaign.Recipients.Select(recipient =>\n        SendToRecipientAsync(campaign, recipient, ipAddress, userAgent)\n    );\n    await Task.WhenAll(tasks);\n#endif\n\n            campaign.Status = \"Sent\";\n            campaign.UpdatedAt = DateTime.UtcNow;\n            await _context.SaveChangesAsync();\n\n            Log.Information(\"üì§ Campaign {CampaignId} sent in parallel to {Count} recipients\", campaign.Id, campaign.Recipients.Count);\n            return true;\n        }\n        private async Task SendToRecipientAsync(Campaign campaign, CampaignRecipient recipient, string ip, string ua)\n        {\n            try\n            {\n                var dto = new SimpleTemplateMessageDto\n                {\n                    RecipientNumber = recipient.Contact.PhoneNumber,\n                    TemplateName = campaign.TemplateId,// campaign.MessageTemplate,\n                    TemplateParameters = new List<string> { recipient.Contact.Name ?? \"Customer\" }\n                };\n\n                var result = await _messageEngineService.SendTemplateMessageSimpleAsync(campaign.BusinessId, dto);\n\n\n                var log = new CampaignSendLog\n                {\n                    Id = Guid.NewGuid(),\n                    CampaignId = campaign.Id,\n                    ContactId = recipient.ContactId,\n                    RecipientId = recipient.Id,\n                    TemplateId = campaign.TemplateId,\n                    MessageBody = campaign.MessageTemplate,\n                    MessageId = null,\n                    SendStatus = result.Success ? \"Sent\" : \"Failed\",\n                    ErrorMessage = result.Message,\n                    SentAt = DateTime.UtcNow,\n                    CreatedAt = DateTime.UtcNow,\n                    SourceChannel = \"whatsapp\",\n                    IpAddress = ip,\n                    DeviceInfo = ua\n                };\n\n                lock (_context)\n                {\n                    _context.CampaignSendLogs.Add(log);\n                    recipient.Status = result.Success ? \"Sent\" : \"Failed\";\n                    recipient.MessagePreview = campaign.MessageTemplate;\n                    recipient.SentAt = DateTime.UtcNow;\n                    recipient.UpdatedAt = DateTime.UtcNow;\n                }\n\n                await _context.SaveChangesAsync();\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed to send template to recipient: {RecipientId}\", recipient.Id);\n            }\n        }\n\n        public async Task<bool> RemoveRecipientAsync(Guid businessId, Guid campaignId, Guid contactId)\n        {\n            var entry = await _context.CampaignRecipients\n                .FirstOrDefaultAsync(r =>\n                    r.CampaignId == campaignId &&\n                    r.ContactId == contactId &&\n                    r.Campaign.BusinessId == businessId); // ‚úÖ Filter by related Campaign.BusinessId\n\n            if (entry == null)\n                return false;\n\n            _context.CampaignRecipients.Remove(entry);\n            await _context.SaveChangesAsync();\n            return true;\n        }\n\n        public async Task<bool> AssignContactsToCampaignAsync(Guid campaignId, Guid businessId, List<Guid> contactIds)\n        {\n            var campaign = await _context.Campaigns\n                .Include(c => c.Recipients)\n                .FirstOrDefaultAsync(c => c.Id == campaignId && c.BusinessId == businessId);\n\n            if (campaign == null)\n                return false;\n\n            var newRecipients = contactIds.Select(id => new CampaignRecipient\n            {\n                Id = Guid.NewGuid(),\n                CampaignId = campaignId,\n                ContactId = id,\n                BusinessId = businessId,\n                Status = \"Pending\",\n                SentAt = null,\n                UpdatedAt = DateTime.UtcNow\n            });\n\n            _context.CampaignRecipients.AddRange(newRecipients);\n            await _context.SaveChangesAsync();\n            return true;\n        }\n\n        // This is the Entry point to send Temaplte (Text Based and Image Based)\n        public async Task<ResponseResult> SendTemplateCampaignAsync(Guid campaignId)\n        {\n            try\n            {\n                var campaign = await _context.Campaigns\n                    .Include(c => c.Recipients)\n                        .ThenInclude(r => r.Contact) // üß† include contact details\n                    .Include(c => c.MultiButtons)\n                    .FirstOrDefaultAsync(c => c.Id == campaignId && !c.IsDeleted);\n\n                if (campaign == null)\n                    return ResponseResult.ErrorInfo(\"‚ùå Campaign not found.\");\n\n                if (campaign.Recipients == null || !campaign.Recipients.Any())\n                    return ResponseResult.ErrorInfo(\"‚ùå No recipients assigned to this campaign.\");\n\n                var templateName = campaign.MessageTemplate;\n                var templateId = campaign.TemplateId;\n                var language = \"en_US\"; // Optional: make dynamic later\n                var isImageTemplate = !string.IsNullOrEmpty(campaign.ImageUrl);\n\n                var templateParams = JsonConvert.DeserializeObject<List<string>>(campaign.TemplateParameters ?? \"[]\");\n\n                int success = 0, failed = 0;\n\n                foreach (var recipient in campaign.Recipients)\n                {\n                    var messageDto = new ImageTemplateMessageDto\n                    {\n                        // BusinessId = campaign.BusinessId,\n                        RecipientNumber = recipient.Contact.PhoneNumber,\n                        TemplateName = templateName,\n                        LanguageCode = language,\n                        HeaderImageUrl = isImageTemplate ? campaign.ImageUrl : null,\n                        TemplateParameters = templateParams,\n                        ButtonParameters = campaign.MultiButtons\n                            .OrderBy(b => b.Position)\n                            .Take(3)\n                            .Select(btn => new CampaignButtonDto\n                            {\n                                ButtonText = btn.Title,\n                                ButtonType = btn.Type,\n                                TargetUrl = btn.Value\n                            }).ToList()\n                    };\n\n                    // ‚úÖ Call the image/template sender\n                    var sendResult = await _messageEngineService.SendImageTemplateMessageAsync(messageDto, campaign.BusinessId);\n                    var isSuccess = sendResult.ToString().ToLower().Contains(\"messages\");\n\n                    var log = new MessageLog\n                    {\n                        Id = Guid.NewGuid(),\n                        BusinessId = campaign.BusinessId,\n                        RecipientNumber = recipient.Contact.PhoneNumber,\n                        MessageContent = campaign.MessageBody,// templateName,\n                        MediaUrl = campaign.ImageUrl,\n                        Status = isSuccess ? \"Sent\" : \"Failed\",\n                        ErrorMessage = isSuccess ? null : \"API Failure\",\n                        RawResponse = JsonConvert.SerializeObject(sendResult),\n                        CreatedAt = DateTime.UtcNow,\n                        SentAt = DateTime.UtcNow\n                    };\n\n                    await _context.MessageLogs.AddAsync(log);\n\n                    if (isSuccess) success++;\n                    else failed++;\n                }\n\n                await _context.SaveChangesAsync();\n                return ResponseResult.SuccessInfo($\"‚úÖ Sent: {success}, ‚ùå Failed: {failed}\");\n            }\n            catch (Exception ex)\n            {\n                return ResponseResult.ErrorInfo(\"‚ùå Unexpected error during campaign send.\", ex.ToString());\n            }\n        }\n\n   \n        public async Task<ResponseResult> SendTemplateCampaignWithTypeDetectionAsync(Guid campaignId, CancellationToken ct = default)\n        {\n            var correlationId = Guid.NewGuid();\n            var sw = System.Diagnostics.Stopwatch.StartNew();\n            using var scope = _logger.BeginScope(new Dictionary<string, object>\n            {\n                [\"corr\"] = correlationId,\n                [\"campaignId\"] = campaignId\n            });\n\n            _logger.LogInformation(\"[SendDetect] BEGIN send for campaign {CampaignId}\", campaignId);\n\n            // 1) Load a slim campaign snapshot\n            var campaignSnap = await _context.Campaigns\n                .AsNoTracking()\n                .Where(c => c.Id == campaignId && !c.IsDeleted)\n                .Select(c => new\n                {\n                    c.Id,\n                    c.BusinessId,\n                    c.CampaignType,\n                    c.TemplateId,\n                    c.MessageTemplate,\n                    c.TemplateParameters,\n                    c.ImageUrl,\n                    c.VideoUrl,\n                    c.DocumentUrl,\n                    c.CTAFlowConfigId,\n                    Recipients = c.Recipients\n                        .Where(r =>\n                            (r.Contact != null && r.Contact.PhoneNumber != null && r.Contact.PhoneNumber != \"\") ||\n                            (r.AudienceMember != null && (\n                                (r.AudienceMember.PhoneE164 != null && r.AudienceMember.PhoneE164 != \"\") ||\n                                (r.AudienceMember.PhoneRaw != null && r.AudienceMember.PhoneRaw != \"\")\n                            )))\n                        .Select(r => new\n                        {\n                            r.Id,\n                            r.ContactId,\n                            ContactPhone = r.Contact != null ? r.Contact.PhoneNumber : null,\n                            ContactName = r.Contact != null ? r.Contact.Name : null,\n                            AMPhoneE164 = r.AudienceMember != null ? r.AudienceMember.PhoneE164 : null,\n                            AMPhoneRaw = r.AudienceMember != null ? r.AudienceMember.PhoneRaw : null,\n                            AMName = r.AudienceMember != null ? r.AudienceMember.Name : null,\n                            AMAttributes = r.AudienceMember != null ? r.AudienceMember.AttributesJson : null\n                        })\n                        .ToList(),\n                    Buttons = c.MultiButtons\n                        .Select(b => new { b.Id, b.Position, b.Title, b.Type, b.Value })\n                        .ToList()\n                })\n                .FirstOrDefaultAsync(ct);\n\n            if (campaignSnap == null)\n            {\n                _logger.LogWarning(\"[SendDetect] ‚ùå Campaign not found\");\n                return ResponseResult.ErrorInfo(\"‚ùå Campaign not found.\");\n            }\n\n            _logger.LogInformation(\"[SendDetect] Loaded campaign snapshot: biz={Biz} recipients={Recipients} tplId={TplId} msgTpl={MsgTpl}\",\n                campaignSnap.BusinessId, campaignSnap.Recipients.Count, campaignSnap.TemplateId, campaignSnap.MessageTemplate);\n\n            if (campaignSnap.Recipients.Count == 0)\n            {\n                _logger.LogWarning(\"[SendDetect] ‚ö†Ô∏è No valid recipients with phone. total=0\");\n                return ResponseResult.ErrorInfo(\"‚ö†Ô∏è No valid recipients with phone numbers (checked Contact.PhoneNumber and AudienceMember.PhoneE164/PhoneRaw).\");\n            }\n\n            // 2) Flow entry template\n            var (_, entryTemplate) = await ResolveFlowEntryAsync(campaignSnap.BusinessId, campaignSnap.CTAFlowConfigId);\n            var tplName =\n                !string.IsNullOrWhiteSpace(entryTemplate) ? entryTemplate! :\n                !string.IsNullOrWhiteSpace(campaignSnap.TemplateId) ? campaignSnap.TemplateId! :\n                !string.IsNullOrWhiteSpace(campaignSnap.MessageTemplate) ? campaignSnap.MessageTemplate! :\n                string.Empty;\n\n            if (string.IsNullOrWhiteSpace(tplName))\n            {\n                _logger.LogWarning(\"[SendDetect] ‚ùå No template name (TemplateId/MessageTemplate/FlowEntry empty).\");\n                return ResponseResult.ErrorInfo(\"‚ùå Campaign has no template name (TemplateId/MessageTemplate is empty).\");\n            }\n\n            _logger.LogInformation(\"[SendDetect] Using template '{TplName}' (flowEntry={FlowEntry}, TemplateId={TplId}, MessageTemplate={MsgTpl})\",\n                tplName, entryTemplate, campaignSnap.TemplateId, campaignSnap.MessageTemplate);\n\n            // 3) Provider from settings\n            var setting = await _context.WhatsAppSettings\n                .AsNoTracking()\n                .Where(s => s.BusinessId == campaignSnap.BusinessId && s.IsActive)\n                .OrderByDescending(s => s.UpdatedAt ?? s.CreatedAt)\n                .FirstOrDefaultAsync(ct);\n\n            if (setting == null)\n            {\n                _logger.LogWarning(\"[SendDetect] ‚ùå WhatsApp settings not found for biz={Biz}\", campaignSnap.BusinessId);\n                return ResponseResult.ErrorInfo(\"‚ùå WhatsApp settings not found for this business.\");\n            }\n\n            var providerFromDb = (setting.Provider ?? string.Empty).Trim();\n            var providerUpper = providerFromDb.ToUpperInvariant();\n            _logger.LogInformation(\"[SendDetect] Provider={Provider}\", providerFromDb);\n\n            // 4) Template row from DB\n            var templateRow = await _context.WhatsAppTemplates\n                .AsNoTracking()\n                .Where(t => t.BusinessId == campaignSnap.BusinessId\n                         && t.IsActive\n                         && t.Name == tplName\n                         && t.Provider == providerUpper)\n                .OrderByDescending(t => t.UpdatedAt)\n                .ThenByDescending(t => t.LastSyncedAt)\n                .FirstOrDefaultAsync(ct);\n\n            if (templateRow == null)\n            {\n                _logger.LogWarning(\"[SendDetect] ‚ùå Template not found in DB. biz={Biz} provider={Provider} name={Name}\",\n                    campaignSnap.BusinessId, providerFromDb, tplName);\n                return ResponseResult.ErrorInfo(\"‚ùå Campaign template not found in DB for this provider.\");\n            }\n\n            _logger.LogInformation(\"[SendDetect] Template row ok: name={Name} lang={Lang} status={Status} bodyLen={Len} placeholderCount(DB)={PC}\",\n                templateRow.Name, templateRow.LanguageCode, templateRow.Status, templateRow.Body?.Length ?? 0, templateRow.BodyVarCount);\n\n            // Recompute BODY placeholder count (supports POSITIONAL vs NAMED)\n            int recomputedBodyCount = 0;\n            try\n            {\n                recomputedBodyCount = CountBodyPlaceholdersFromRaw(\n                    templateRow.RawJson,\n                    templateRow.Body,\n                    templateRow.ParameterFormat\n                );\n\n                if (recomputedBodyCount != Math.Max(0, templateRow.BodyVarCount))\n                {\n                    _logger.LogWarning(\"[SendDetect] PlaceholderCount mismatch: DB={DbCount} recomputed(BODY)={Recomputed} tpl={Tpl}\",\n                        templateRow.BodyVarCount, recomputedBodyCount, templateRow.Name);\n                }\n                else\n                {\n                    _logger.LogDebug(\"[SendDetect] PlaceholderCount verified: {Count}\", recomputedBodyCount);\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"[SendDetect] Failed to recompute BODY placeholder count for tpl={Tpl}\", templateRow.Name);\n            }\n\n            // 5) Infer media type\n            var headerKind = TemplateHeaderInspector.Infer(templateRow);\n            var inferredType = TemplateHeaderInspector.ToMediaType(headerKind);\n\n            var mediaType = (campaignSnap.CampaignType ?? string.Empty).Trim();\n            mediaType = string.IsNullOrEmpty(mediaType) || mediaType.Equals(\"auto\", StringComparison.OrdinalIgnoreCase)\n                ? inferredType\n                : mediaType.ToLowerInvariant();\n\n            _logger.LogInformation(\"[SendDetect] MediaType resolved: campaignType={CampaignType} inferred={Inferred} => chosen={Chosen}\",\n                campaignSnap.CampaignType, inferredType, mediaType);\n\n            // 6) Validate media URLs\n            if (mediaType == \"image\" && string.IsNullOrWhiteSpace(campaignSnap.ImageUrl))\n                return ResponseResult.ErrorInfo(\"üö´ Image template requires ImageUrl on the campaign.\");\n            if (mediaType == \"video\" && string.IsNullOrWhiteSpace(campaignSnap.VideoUrl))\n                return ResponseResult.ErrorInfo(\"üö´ Video template requires VideoUrl on the campaign.\");\n            if (mediaType == \"document\" && string.IsNullOrWhiteSpace(campaignSnap.DocumentUrl))\n                return ResponseResult.ErrorInfo(\"üö´ Document template requires DocumentUrl on the campaign.\");\n\n            // 6.1 Parameter mapping support\n            var parameterFormat = templateRow.ParameterFormat; // \"POSITIONAL\" | \"NAMED\"\n            var bodyParamNames = ExtractBodyParamNamesFromTemplate(templateRow.RawJson, templateRow.Body, parameterFormat);\n\n            // 7) Rehydrate light Campaign for downstream\n            var campaign = new Campaign\n            {\n                Id = campaignSnap.Id,\n                BusinessId = campaignSnap.BusinessId,\n                CampaignType = mediaType,\n                TemplateId = tplName,\n                MessageTemplate = tplName,\n                TemplateParameters = campaignSnap.TemplateParameters,\n                ImageUrl = campaignSnap.ImageUrl,\n                VideoUrl = campaignSnap.VideoUrl,\n                DocumentUrl = campaignSnap.DocumentUrl,\n                CTAFlowConfigId = campaignSnap.CTAFlowConfigId,\n                Provider = providerFromDb,\n                MultiButtons = campaignSnap.Buttons\n                    .OrderBy(b => b.Position)\n                    .Select(b => new CampaignButton\n                    {\n                        Id = b.Id,\n                        Position = b.Position,\n                        Title = b.Title,\n                        Type = b.Type,\n                        Value = b.Value\n                    })\n                    .ToList(),\n                Recipients = campaignSnap.Recipients.Select(r => new CampaignRecipient\n                {\n                    Id = r.Id,\n                    ContactId = r.ContactId,\n                    Contact = r.ContactPhone != null ? new Contact\n                    {\n                        PhoneNumber = r.ContactPhone,\n                        Name = r.ContactName\n                    } : null,\n                    AudienceMember = (r.AMPhoneE164 != null || r.AMPhoneRaw != null) ? new AudienceMember\n                    {\n                        PhoneE164 = r.AMPhoneE164,\n                        PhoneRaw = r.AMPhoneRaw,\n                        Name = r.AMName,\n                        AttributesJson = r.AMAttributes\n                    } : null\n                }).ToList()\n            };\n\n            // 8) Unified enqueue (text | image | video | document)\n            {\n                var enqueueSw = System.Diagnostics.Stopwatch.StartNew();\n\n                var wa = await _whatsAppSettingsService.GetSettingsByBusinessIdAsync(campaign.BusinessId);\n                if (wa is null)\n                    return ResponseResult.ErrorInfo(\"‚ùå WhatsApp settings not found.\");\n\n                var languageCode = string.IsNullOrWhiteSpace(templateRow.LanguageCode) ? \"en_US\" : templateRow.LanguageCode!.Trim();\n\n                var buttonsOrdered = campaign.MultiButtons?\n                    .Select((b, idx) => new { Btn = b, idx })\n                    .OrderBy(x => (int?)x.Btn.Position ?? int.MaxValue)\n                    .ThenBy(x => x.idx)\n                    .Select(x => x.Btn)\n                    .ToList() ?? new List<CampaignButton>();\n\n                string? phoneNumberId = !string.IsNullOrWhiteSpace(campaign.PhoneNumberId)\n                    ? campaign.PhoneNumberId\n                    : wa.PhoneNumberId;\n\n                var isMeta = string.Equals(providerFromDb, \"META_CLOUD\", StringComparison.OrdinalIgnoreCase);\n                if (isMeta && string.IsNullOrWhiteSpace(phoneNumberId))\n                    return ResponseResult.ErrorInfo(\"‚ùå No PhoneNumberId configured for Meta Cloud sender.\");\n\n                static string? ResolvePhone(CampaignRecipient r) =>\n                    r?.Contact?.PhoneNumber ?? r?.AudienceMember?.PhoneE164 ?? r?.AudienceMember?.PhoneRaw;\n\n                var placeholderCount = Math.Max(0, recomputedBodyCount);\n\n                var templateMeta = new TemplateMetadataDto\n                {\n                    Name = templateRow.Name,\n                    Language = languageCode,\n                    Body = templateRow.Body,\n                    PlaceholderCount = placeholderCount,\n                    ButtonParams = string.IsNullOrWhiteSpace(templateRow.UrlButtons)\n                        ? new List<ButtonMetadataDto>()\n                        : (JsonConvert.DeserializeObject<List<ButtonMetadataDto>>(templateRow.UrlButtons!)\n                            ?? new List<ButtonMetadataDto>())\n                };\n\n                _logger.LogInformation(\"[SendDetect] Buttons: templateHas={TplBtnCount} campaignHas={CampBtnCount}\",\n                    templateMeta.ButtonParams.Count, buttonsOrdered.Count);\n\n                var now = DateTime.UtcNow;\n                var items = new List<(CampaignRecipient r, string paramsJson, string btnsJson, string? headerUrl, string idemKey)>();\n\n                int recipientsWithPhone = 0, recipientsMissingParams = 0;\n                foreach (var r in campaign.Recipients)\n                {\n                    var phone = ResolvePhone(r);\n                    if (string.IsNullOrWhiteSpace(phone))\n                    {\n                        _logger.LogWarning(\"[SendDetect] Skip recipient {RecipientId}: empty phone\", r.Id);\n                        continue;\n                    }\n                    recipientsWithPhone++;\n\n                    // BODY params (now supports POSITIONAL and NAMED)\n                    var resolvedParams = GetRecipientBodyParams(\n                        r,\n                        placeholderCount,\n                        campaign.TemplateParameters,\n                        bodyParamNames,\n                        parameterFormat\n                    );\n\n                    // Missing parameter check ‚Äî use FILLED count (not just list length)\n                    var filled = resolvedParams.Count(v => !string.IsNullOrWhiteSpace(v));\n                    if (placeholderCount > 0 && filled < placeholderCount)\n                    {\n                        recipientsMissingParams++;\n                        var why = $\"Missing body parameter(s): expected {placeholderCount}, got {filled}.\";\n                        _logger.LogWarning(\"[SendDetect] Skip recipient {RecipientId}: {Why} resolved=[{Vals}] phone={Phone}\",\n                            r.Id, why, string.Join(\"|\", resolvedParams), phone);\n\n                        var logIdLocal = Guid.NewGuid();\n                        _context.MessageLogs.Add(new MessageLog\n                        {\n                            Id = logIdLocal,\n                            BusinessId = campaign.BusinessId,\n                            CampaignId = campaign.Id,\n                            ContactId = r.ContactId,\n                            RecipientNumber = phone,\n                            MessageContent = campaign.TemplateId,\n                            Status = \"Failed\",\n                            ErrorMessage = why,\n                            RawResponse = \"{\\\"local_error\\\":\\\"missing_template_body_params\\\"}\",\n                            CreatedAt = now,\n                            Source = \"campaign\",\n                            CTAFlowConfigId = campaign.CTAFlowConfigId\n                        });\n\n                        await _context.CampaignSendLogs.AddAsync(new CampaignSendLog\n                        {\n                            Id = Guid.NewGuid(),\n                            CampaignId = campaign.Id,\n                            BusinessId = campaign.BusinessId,\n                            ContactId = r.ContactId,\n                            RecipientId = r.Id,\n                            MessageBody = campaign.MessageBody ?? campaign.TemplateId,\n                            TemplateId = campaign.TemplateId!,\n                            SendStatus = \"Failed\",\n                            MessageLogId = logIdLocal,\n                            ErrorMessage = why,\n                            CreatedAt = now,\n                            CTAFlowConfigId = campaign.CTAFlowConfigId\n                        }, ct);\n\n                        continue;\n                    }\n\n                    // Resolve dynamic URL buttons for snapshot (using your existing builders)\n                    var contactForTemplating = r.Contact ?? new Contact\n                    {\n                        Id = Guid.Empty,\n                        BusinessId = campaign.BusinessId,\n                        PhoneNumber = phone,\n                        Name = r.Contact?.Name ?? r.AudienceMember?.Name ?? \"Customer\"\n                    };\n\n                    var dummySendLogId = Guid.NewGuid();\n                    List<string> resolvedButtonUrls;\n\n                    var btnComponents = string.Equals(providerFromDb, \"PINNACLE\", StringComparison.OrdinalIgnoreCase)\n                        ? BuildTextTemplateComponents_Pinnacle(resolvedParams, buttonsOrdered, templateMeta, dummySendLogId, contactForTemplating, out resolvedButtonUrls)\n                        : BuildTextTemplateComponents_Meta(resolvedParams, buttonsOrdered, templateMeta, dummySendLogId, contactForTemplating, out resolvedButtonUrls);\n\n                    _logger.LogDebug(\"[SendDetect] Recipient {RecipientId}: bodyResolved=[{Vals}] btnResolved=[{BtnVals}] btnCompCount={BtnCompCount}\",\n                        r.Id, string.Join(\"|\", resolvedParams), string.Join(\" , \", resolvedButtonUrls ?? new List<string>()), (btnComponents?.Count ?? 0));\n\n                    // persist materialization snapshot\n                    var recStub = new CampaignRecipient { Id = r.Id };\n                    _context.CampaignRecipients.Attach(recStub);\n                    recStub.ResolvedParametersJson = JsonConvert.SerializeObject(resolvedParams);\n                    recStub.ResolvedButtonUrlsJson = JsonConvert.SerializeObject(resolvedButtonUrls);\n                    recStub.MaterializedAt = now;\n                    recStub.UpdatedAt = now;\n\n                    string? headerUrl = mediaType switch\n                    {\n                        \"image\" => campaign.ImageUrl,\n                        \"video\" => campaign.VideoUrl,\n                        \"document\" => campaign.DocumentUrl,\n                        _ => null\n                    };\n\n                    var paramsJson = JsonConvert.SerializeObject(resolvedParams);\n                    var btnsJson = JsonConvert.SerializeObject(resolvedButtonUrls);\n                    var idemKey = Idempotency.Sha256(\n                        $\"{campaign.Id}|{phone}|{campaign.TemplateId}|{paramsJson}|{btnsJson}|{mediaType}|{headerUrl}\");\n\n                    items.Add((r, paramsJson, btnsJson, headerUrl, idemKey));\n\n                    _logger.LogInformation(\"[SendDetect] +EnqueueCandidate recipient={RecipientId} phone={Phone} idemKeyHashPrefix={Hash}\",\n                        r.Id, phone, idemKey.Substring(0, 8));\n                }\n\n                await _context.SaveChangesAsync(ct);\n\n                _logger.LogInformation(\"[SendDetect] Recipients summary: withPhone={WithPhone} missingParams={Missing} candidates={Candidates}\",\n                    recipientsWithPhone, recipientsMissingParams, items.Count);\n\n                if (items.Count == 0)\n                    return ResponseResult.ErrorInfo(\"No messages enqueued. Missing data for all recipients.\");\n\n                try\n                {\n                    _logger.LogInformation(\"[SendDetect] EnqueueOutboundJobsAsync start: mediaType={Media} template={Tpl} lang={Lang} phoneNumberId={PhoneId}\",\n                        mediaType, campaign.TemplateId, languageCode, phoneNumberId);\n\n                    await EnqueueOutboundJobsAsync(\n                        campaign: campaign,\n                        provider: providerFromDb,\n                        mediaType: mediaType,\n                        templateName: campaign.TemplateId!,\n                        languageCode: languageCode,\n                        phoneNumberId: phoneNumberId,\n                        items: items\n                    );\n\n                    enqueueSw.Stop();\n                    _logger.LogInformation(\"[SendDetect] Enqueue done in {Ms} ms. Items={Count}\", enqueueSw.ElapsedMilliseconds, items.Count);\n\n                    // ‚úÖ FIX: Explicitly update Campaign status because campaignSnap was AsNoTracking()\n                    var campaignToUpdate = new Campaign { Id = campaignId, Status = \"Processing\" }; // or \"Sending\"\n                    _context.Campaigns.Attach(campaignToUpdate);\n                    _context.Entry(campaignToUpdate).Property(x => x.Status).IsModified = true;\n                    await _context.SaveChangesAsync(ct);\n\n                    sw.Stop();\n                    _logger.LogInformation(\"[SendDetect] ‚úÖ SUCCESS in {Ms} ms\", sw.ElapsedMilliseconds);\n\n                    return ResponseResult.SuccessInfo($\"üì§ Enqueued {items.Count} {mediaType} message(s) for async delivery.\");\n                }\n                catch (Exception ex)\n                {\n                    enqueueSw.Stop();\n                    _logger.LogError(ex, \"[SendDetect] ‚ùå Enqueue failed after {Ms} ms\", enqueueSw.ElapsedMilliseconds);\n                    return ResponseResult.ErrorInfo(\"‚ùå Failed to enqueue outbound jobs.\");\n                }\n            }\n\n            // ‚îÄ‚îÄ local: BODY placeholder counter (POSITIONAL vs NAMED) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n            int CountBodyPlaceholdersFromRaw(string? raw, string? bodyFallback, string? parameterFormat = null)\n            {\n                try\n                {\n                    if (!string.IsNullOrWhiteSpace(raw))\n                    {\n                        using var doc = System.Text.Json.JsonDocument.Parse(raw);\n                        if (doc.RootElement.TryGetProperty(\"components\", out var comps) &&\n                            comps.ValueKind == System.Text.Json.JsonValueKind.Array)\n                        {\n                            foreach (var c in comps.EnumerateArray())\n                            {\n                                if (c.TryGetProperty(\"type\", out var typeProp) &&\n                                    string.Equals(typeProp.GetString(), \"BODY\", StringComparison.OrdinalIgnoreCase))\n                                {\n                                    if (c.TryGetProperty(\"text\", out var textProp))\n                                    {\n                                        var body = textProp.GetString();\n                                        return CountCurlies(body, parameterFormat);\n                                    }\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n                catch (System.Text.Json.JsonException)\n                {\n                    // ignore parse errors\n                }\n                catch { /* diagnostics only */ }\n\n                return CountCurlies(bodyFallback, parameterFormat);\n\n                static int CountCurlies(string? s, string? parameterFormat)\n                {\n                    if (string.IsNullOrEmpty(s)) return 0;\n\n                    var fmt = (parameterFormat ?? \"POSITIONAL\").Trim().ToUpperInvariant();\n\n                    if (fmt == \"POSITIONAL\")\n                    {\n                        // Only {{1}}, {{2}}, ...\n                        return System.Text.RegularExpressions.Regex.Matches(s, @\"\\{\\{\\s*\\d+\\s*\\}\\}\").Count;\n                    }\n                    else if (fmt == \"NAMED\")\n                    {\n                        // Only {{name_like_this}}\n                        return System.Text.RegularExpressions.Regex.Matches(s, @\"\\{\\{\\s*[A-Za-z_][A-Za-z0-9_]*\\s*\\}\\}\").Count;\n                    }\n\n                    return 0;\n                }\n            }\n        }\n\n\n        private static List<string> GetRecipientBodyParams(\n            CampaignRecipient r,\n            int expectedCount,\n            string? campaignTemplateParameters,\n            List<string>? bodyParamNames,\n            string? parameterFormat)\n        {\n            // 1) Start from campaign-level values (often \"[]\", i.e., empty)\n            var values = TemplateParameterHelper.ParseTemplateParams(campaignTemplateParameters)?.ToList()\n                         ?? new List<string>();\n\n            // 2) Trim/pad to expected slots\n            if (values.Count > expectedCount) values = values.Take(expectedCount).ToList();\n            while (values.Count < expectedCount) values.Add(string.Empty);\n\n            // 3) Fill gaps from per-recipient attributes\n            var fmt = (parameterFormat ?? \"POSITIONAL\").Trim().ToUpperInvariant();\n            var attrs = ParseAttributes(r); // e.g., { parameter1: \"Nicolus Benz\", parameter2: \"Email\" }\n\n            if (attrs != null)\n            {\n                if (fmt == \"POSITIONAL\")\n                {\n                    for (int i = 0; i < expectedCount; i++)\n                    {\n                        if (!string.IsNullOrWhiteSpace(values[i])) continue;\n\n                        var key = \"parameter\" + (i + 1);      // {{1}} ‚Üê parameter1, {{2}} ‚Üê parameter2 ...\n                        if (attrs.TryGetValue(key, out var v) && !string.IsNullOrWhiteSpace(v))\n                            values[i] = v!;\n                    }\n                }\n                else if (fmt == \"NAMED\" && bodyParamNames != null && bodyParamNames.Count > 0)\n                {\n                    // Map named placeholders from attributes with matching keys\n                    var nameToIndex = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);\n                    for (int i = 0; i < bodyParamNames.Count; i++)\n                        if (!nameToIndex.ContainsKey(bodyParamNames[i])) nameToIndex[bodyParamNames[i]] = i;\n\n                    foreach (var kv in attrs)\n                    {\n                        if (nameToIndex.TryGetValue(kv.Key, out var idx) &&\n                            idx < values.Count &&\n                            string.IsNullOrWhiteSpace(values[idx]) &&\n                            !string.IsNullOrWhiteSpace(kv.Value))\n                        {\n                            values[idx] = kv.Value!;\n                        }\n                    }\n                }\n            }\n\n            // 4) Friendly default for slot 1 if still empty\n            if (expectedCount > 0 && values.Count > 0 && string.IsNullOrWhiteSpace(values[0]))\n                values[0] = r?.Contact?.Name ?? r?.AudienceMember?.Name ?? string.Empty;\n\n            // 5) Normalize whitespace\n            for (int i = 0; i < values.Count; i++)\n                values[i] = values[i]?.Trim() ?? string.Empty;\n\n            return values;\n        }\n        private static Dictionary<string, string>? ParseAttributes(CampaignRecipient r)\n        {\n            var raw = r?.AudienceMember?.AttributesJson;\n            if (string.IsNullOrWhiteSpace(raw)) return null;\n\n            try\n            {\n                var obj = JsonConvert.DeserializeObject<Dictionary<string, object>>(raw);\n                if (obj == null) return null;\n\n                var dict = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n                foreach (var kv in obj)\n                    dict[kv.Key] = kv.Value?.ToString() ?? string.Empty;\n\n                return dict;\n            }\n            catch\n            {\n                return null;\n            }\n        }\n\n        private static List<string>? ExtractBodyParamNamesFromTemplate(string? rawJson, string? bodyFallback, string? parameterFormat)\n        {\n            var fmt = (parameterFormat ?? \"POSITIONAL\").Trim().ToUpperInvariant();\n            if (fmt != \"NAMED\") return null;\n\n            // 1) Try provider RAW JSON ‚Üí components[type=BODY].text\n            string? bodyText = null;\n            if (!string.IsNullOrWhiteSpace(rawJson))\n            {\n                try\n                {\n                    using var doc = System.Text.Json.JsonDocument.Parse(rawJson);\n                    if (doc.RootElement.TryGetProperty(\"components\", out var comps) &&\n                        comps.ValueKind == System.Text.Json.JsonValueKind.Array)\n                    {\n                        foreach (var c in comps.EnumerateArray())\n                        {\n                            if (c.TryGetProperty(\"type\", out var tp) &&\n                                string.Equals(tp.GetString(), \"BODY\", StringComparison.OrdinalIgnoreCase) &&\n                                c.TryGetProperty(\"text\", out var tprop))\n                            {\n                                bodyText = tprop.GetString();\n                                break;\n                            }\n                        }\n                    }\n                }\n                catch { /* ignore malformed provider JSON */ }\n            }\n\n            bodyText ??= bodyFallback;\n            if (string.IsNullOrWhiteSpace(bodyText)) return new List<string>(0);\n\n            // 2) Pull {{name_like_this}} in order; keep unique, valid identifiers\n            var names = new List<string>();\n            var seen = new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n            foreach (System.Text.RegularExpressions.Match m in\n                     System.Text.RegularExpressions.Regex.Matches(bodyText, @\"\\{\\{\\s*([A-Za-z_][A-Za-z0-9_]*)\\s*\\}\\}\"))\n            {\n                var name = m.Groups[1].Value;\n                if (seen.Add(name)) names.Add(name);\n            }\n            return names;\n        }\n\n        public async Task<ResponseResult> SendTextTemplateCampaignAsync(Campaign campaign)\n        {\n            try\n            {\n                if (campaign == null || campaign.IsDeleted)\n                    return ResponseResult.ErrorInfo(\"‚ùå Invalid campaign.\");\n                if (campaign.Recipients == null || campaign.Recipients.Count == 0)\n                    return ResponseResult.ErrorInfo(\"‚ùå No recipients to send.\");\n\n                var businessId = campaign.BusinessId;\n\n                // 0) Filter recipients that actually have a phone\n                static string? ResolveRecipientPhone(CampaignRecipient r) =>\n                    r?.Contact?.PhoneNumber ?? r?.AudienceMember?.PhoneE164 ?? r?.AudienceMember?.PhoneRaw;\n\n                var recipients = campaign.Recipients\n                    .Where(r => !string.IsNullOrWhiteSpace(ResolveRecipientPhone(r)))\n                    .ToList();\n\n                if (recipients.Count == 0)\n                    return ResponseResult.ErrorInfo(\"‚ö†Ô∏è No valid recipients with phone numbers (Contact/AudienceMember).\");\n\n                // 1) Flow/template selection\n                var (_, entryTemplate) = await ResolveFlowEntryAsync(businessId, campaign.CTAFlowConfigId);\n                var templateKey = !string.IsNullOrWhiteSpace(entryTemplate)\n                    ? entryTemplate!.Trim()\n                    : (campaign.TemplateId ?? campaign.MessageTemplate ?? \"\").Trim();\n\n                if (string.IsNullOrWhiteSpace(templateKey))\n                    return ResponseResult.ErrorInfo(\"‚ùå No template selected.\");\n\n                // 2) WhatsApp settings\n                var wa = await _whatsAppSettingsService.GetSettingsByBusinessIdAsync(businessId);\n                if (wa is null)\n                    return ResponseResult.ErrorInfo(\"‚ùå WhatsApp settings not found.\");\n\n                // DB stores Provider in UPPERCASE\n                var provider = (wa.Provider ?? string.Empty).Trim();\n                var providerUpper = provider.ToUpperInvariant();\n\n                // 3) Fetch template from DB (NO network)\n                // Try provider TemplateId first; if not found, fall back to Name.\n                WhatsAppTemplate? templateRow = await _context.WhatsAppTemplates\n                    .AsNoTracking()\n                    .Where(t => t.BusinessId == businessId &&\n                                t.IsActive &&\n                                t.Provider == providerUpper &&\n                                t.TemplateId == templateKey)\n                    .OrderByDescending(t => t.UpdatedAt)\n                    .ThenByDescending(t => t.LastSyncedAt)\n                    .FirstOrDefaultAsync();\n\n                if (templateRow is null)\n                {\n                    templateRow = await _context.WhatsAppTemplates\n                        .AsNoTracking()\n                        .Where(t => t.BusinessId == businessId &&\n                                    t.IsActive &&\n                                    t.Provider == providerUpper &&\n                                    t.Name == templateKey)\n                        .OrderByDescending(t => t.UpdatedAt)\n                        .ThenByDescending(t => t.LastSyncedAt)\n                        .FirstOrDefaultAsync();\n                }\n\n                if (templateRow == null)\n                    return ResponseResult.ErrorInfo(\"‚ùå Template not found in DB for this business/provider.\");\n\n                // Map DB row -> DTO used by builders\n                var templateMeta = new TemplateMetadataDto\n                {\n                    Name = templateRow.Name,\n                    Language = templateRow.LanguageCode,\n                    Body = templateRow.Body,\n                    // FINAL MODEL: body-only placeholders live in BodyVarCount\n                    PlaceholderCount = Math.Max(0, templateRow.BodyVarCount),\n                    ButtonParams = ParseUrlButtonsToButtonMeta(templateRow.UrlButtons)\n                };\n\n                var languageCode = (templateMeta.Language ?? \"\").Trim();\n                if (string.IsNullOrWhiteSpace(languageCode))\n                    return ResponseResult.ErrorInfo(\"‚ùå Template language missing in DB.\");\n\n                // 4) Campaign buttons (order by Position)\n                var buttons = campaign.MultiButtons?.OrderBy(b => b.Position).ToList()\n                              ?? new List<CampaignButton>();\n\n                // Sender override; if missing, use WA DTO value\n                string? phoneNumberIdOverride = !string.IsNullOrWhiteSpace(campaign.PhoneNumberId)\n                    ? campaign.PhoneNumberId\n                    : wa.PhoneNumberId;\n\n                // Meta Cloud must have a PhoneNumberId\n                if (providerUpper == \"META_CLOUD\" && string.IsNullOrWhiteSpace(phoneNumberIdOverride))\n                    return ResponseResult.ErrorInfo(\"‚ùå No PhoneNumberId configured for Meta Cloud sender.\");\n\n                // 5) Optional flow entry step id\n                Guid? entryStepId = null;\n                if (campaign.CTAFlowConfigId.HasValue)\n                {\n                    entryStepId = await _context.CTAFlowSteps\n                        .Where(s => s.CTAFlowConfigId == campaign.CTAFlowConfigId.Value)\n                        .OrderBy(s => s.StepOrder)\n                        .Select(s => (Guid?)s.Id)\n                        .FirstOrDefaultAsync();\n                }\n\n                // 6) Freeze button bundle for click-tracking (from template meta)\n                string? buttonBundleJson = null;\n                if (templateMeta.ButtonParams is { Count: > 0 })\n                {\n                    var bundle = templateMeta.ButtonParams\n                        .OrderBy(b => b.Index)\n                        .Take(3)\n                        .Select((b, i) => new\n                        {\n                            i,\n                            position = i + 1,\n                            text = (b.Text ?? \"\").Trim(),\n                            type = b.Type,\n                            subType = b.SubType\n                        })\n                        .ToList();\n                    buttonBundleJson = JsonConvert.SerializeObject(bundle);\n                }\n\n                // 7) Preload AudienceMember phone/name for recipients that don‚Äôt have a Contact\n                var neededMemberIds = recipients\n                    .Where(x => x.ContactId == null && x.AudienceMemberId != null)\n                    .Select(x => x.AudienceMemberId!.Value)\n                    .Distinct()\n                    .ToList();\n\n                var audienceLookup = neededMemberIds.Count == 0\n                    ? new Dictionary<Guid, (string Phone, string? Name)>()\n                    : await _context.AudienceMembers.AsNoTracking()\n                        .Where(m => m.BusinessId == businessId && neededMemberIds.Contains(m.Id))\n                        .Select(m => new { m.Id, m.PhoneE164, m.PhoneRaw, m.Name })\n                        .ToDictionaryAsync(\n                            x => x.Id,\n                            x => (Phone: string.IsNullOrWhiteSpace(x.PhoneE164) ? (x.PhoneRaw ?? \"\") : x.PhoneE164,\n                                  Name: x.Name)\n                        );\n\n                int successCount = 0, failureCount = 0;\n                var now = DateTime.UtcNow;\n                // Derive format + named BODY param names from the stored template\n                var parameterFormat = (templateRow.ParameterFormat ?? \"POSITIONAL\").Trim().ToUpperInvariant();\n                var bodyParamNames = ExtractBodyParamNamesFromTemplate(templateRow.RawJson, templateRow.Body, parameterFormat);\n\n                foreach (var r in recipients)\n                {\n                    // Resolve actual phone + fallback name\n                    var phone = ResolveRecipientPhone(r);\n                    string? name = r.Contact?.Name;\n\n                    if (string.IsNullOrWhiteSpace(phone) && r.AudienceMemberId != null &&\n                        audienceLookup.TryGetValue(r.AudienceMemberId.Value, out var a) &&\n                        !string.IsNullOrWhiteSpace(a.Phone))\n                    {\n                        phone = a.Phone;\n                        name ??= a.Name ?? \"Customer\";\n                    }\n\n                    if (string.IsNullOrWhiteSpace(phone))\n                    {\n                        failureCount++;\n                        continue; // nothing to send to\n                    }\n\n                    // For templating only (do NOT attach to EF)\n                    var contactForTemplating = r.Contact ?? new Contact\n                    {\n                        Id = Guid.Empty,\n                        BusinessId = businessId,\n                        PhoneNumber = phone,\n                        Name = name ?? \"Customer\"\n                    };\n\n                    var runId = Guid.NewGuid();\n                    var campaignSendLogId = Guid.NewGuid();\n\n                    // BODY params per recipient\n                    // var resolvedParams = GetRecipientBodyParams(r, templateMeta.PlaceholderCount, campaign.TemplateParameters);\n                    var resolvedParams = GetRecipientBodyParams(\n                        r,\n                        templateMeta.PlaceholderCount,\n                        campaign.TemplateParameters,\n                        bodyParamNames,\n                        parameterFormat\n                    );\n                    // If template expects body placeholders, block send when blanks exist\n                    if (templateMeta.PlaceholderCount > 0 && resolvedParams.Any(string.IsNullOrWhiteSpace))\n                    {\n                        failureCount++;\n                        var why = $\"Missing body parameter(s): expected {templateMeta.PlaceholderCount}, got {resolvedParams.Count(x => !string.IsNullOrWhiteSpace(x))} filled.\";\n\n                        // Attach recipient stub to update without creating related entities\n                        var recStub1 = new CampaignRecipient { Id = r.Id };\n                        _context.CampaignRecipients.Attach(recStub1);\n                        recStub1.MaterializedAt = now;\n                        recStub1.UpdatedAt = now;\n                        recStub1.ResolvedParametersJson = JsonConvert.SerializeObject(resolvedParams);\n\n                        // Log locally as a failed send without calling provider\n                        var logIdLocal = Guid.NewGuid();\n                        _context.MessageLogs.Add(new MessageLog\n                        {\n                            Id = logIdLocal,\n                            BusinessId = businessId,\n                            CampaignId = campaign.Id,\n                            ContactId = r.ContactId, // may be null\n                            RecipientNumber = phone,\n                            MessageContent = campaign.MessageBody,\n                            Status = \"Failed\",\n                            ErrorMessage = why,\n                            RawResponse = \"{\\\"local_error\\\":\\\"missing_template_body_params\\\"}\",\n                            CreatedAt = now,\n                            Source = \"campaign\",\n                            CTAFlowConfigId = campaign.CTAFlowConfigId,\n                            CTAFlowStepId = entryStepId,\n                            ButtonBundleJson = buttonBundleJson,\n                            RunId = runId\n                        });\n\n                        await _context.CampaignSendLogs.AddAsync(new CampaignSendLog\n                        {\n                            Id = campaignSendLogId,\n                            CampaignId = campaign.Id,\n                            BusinessId = businessId,\n                            ContactId = r.ContactId,  // may be null\n                            RecipientId = r.Id,\n                            MessageBody = campaign.MessageBody ?? templateKey,\n                            TemplateId = templateKey,\n                            SendStatus = \"Failed\",\n                            MessageLogId = logIdLocal,\n                            ErrorMessage = why,\n                            CreatedAt = now,\n                            CreatedBy = campaign.CreatedBy,\n                            CTAFlowConfigId = campaign.CTAFlowConfigId,\n                            CTAFlowStepId = entryStepId,\n                            ButtonBundleJson = buttonBundleJson,\n                            RunId = runId\n                        });\n\n                        continue; // skip provider call\n                    }\n\n                    // Build components using DB template meta\n                    List<string> resolvedButtonUrls;\n                    object components = providerUpper == \"PINNACLE\"\n                        ? BuildTextTemplateComponents_Pinnacle(resolvedParams, buttons, templateMeta, campaignSendLogId, contactForTemplating, out resolvedButtonUrls)\n                        : BuildTextTemplateComponents_Meta(resolvedParams, buttons, templateMeta, campaignSendLogId, contactForTemplating, out resolvedButtonUrls);\n\n                    var payload = new\n                    {\n                        messaging_product = \"whatsapp\",\n                        to = phone,\n                        type = \"template\",\n                        template = new\n                        {\n                            name = templateKey,\n                            language = new { code = languageCode }, // from DB\n                            components\n                        }\n                    };\n\n                    // Freeze recipient materialization BEFORE send ‚Äî attach via STUB\n                    var recStub2 = new CampaignRecipient { Id = r.Id };\n                    _context.CampaignRecipients.Attach(recStub2);\n                    recStub2.ResolvedParametersJson = JsonConvert.SerializeObject(resolvedParams);\n                    recStub2.ResolvedButtonUrlsJson = JsonConvert.SerializeObject(resolvedButtonUrls);\n                    recStub2.MaterializedAt = now;\n                    recStub2.UpdatedAt = now;\n                    recStub2.IdempotencyKey = Idempotency.Sha256($\"{campaign.Id}|{phone}|{templateKey}|{recStub2.ResolvedParametersJson}|{recStub2.ResolvedButtonUrlsJson}\");\n\n                    var result = await _messageEngineService.SendPayloadAsync(businessId, providerUpper, payload, phoneNumberIdOverride);\n\n                    var logId = Guid.NewGuid();\n                    _context.MessageLogs.Add(new MessageLog\n                    {\n                        Id = logId,\n                        BusinessId = businessId,\n                        CampaignId = campaign.Id,\n                        ContactId = r.ContactId, // may be null\n                        RecipientNumber = phone,\n                        MessageContent = templateKey,\n                        Status = result.Success ? \"Sent\" : \"Failed\",\n                        MessageId = result.MessageId,\n                        ErrorMessage = result.ErrorMessage,\n                        RawResponse = result.RawResponse,\n                        CreatedAt = now,\n                        SentAt = result.Success ? now : (DateTime?)null,\n                        Source = \"campaign\",\n                        CTAFlowConfigId = campaign.CTAFlowConfigId,\n                        CTAFlowStepId = entryStepId,\n                        ButtonBundleJson = buttonBundleJson,\n                        RunId = runId\n                    });\n\n                    await _billingIngest.IngestFromSendResponseAsync(\n                        businessId: businessId,\n                        messageLogId: logId,\n                        provider: providerUpper,\n                        rawResponseJson: result.RawResponse ?? \"{}\"\n                    );\n\n                    await _context.CampaignSendLogs.AddAsync(new CampaignSendLog\n                    {\n                        Id = campaignSendLogId,\n                        CampaignId = campaign.Id,\n                        BusinessId = businessId,\n                        ContactId = r.ContactId,  // may be null\n                        RecipientId = r.Id,\n                        MessageBody = campaign.MessageBody ?? templateKey,\n                        TemplateId = templateKey,\n                        SendStatus = result.Success ? \"Sent\" : \"Failed\",\n                        MessageLogId = logId,\n                        MessageId = result.MessageId,\n                        ErrorMessage = result.ErrorMessage,\n                        CreatedAt = now,\n                        SentAt = result.Success ? now : (DateTime?)null,\n                        CreatedBy = campaign.CreatedBy,\n                        CTAFlowConfigId = campaign.CTAFlowConfigId,\n                        CTAFlowStepId = entryStepId,\n                        ButtonBundleJson = buttonBundleJson,\n                        RunId = runId\n                    });\n\n                    if (result.Success) successCount++; else failureCount++;\n                }\n\n                await _context.SaveChangesAsync();\n                return ResponseResult.SuccessInfo($\"üì§ Sent to {successCount} recipients. ‚ùå Failed for {failureCount}.\");\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"Error while sending text template campaign\");\n                return ResponseResult.ErrorInfo(\"üö® Unexpected error while sending campaign.\", ex.ToString());\n            }\n        }\n\n        private static List<ButtonMetadataDto> ParseUrlButtonsToButtonMeta(string? urlButtonsJson)\n        {\n            if (string.IsNullOrWhiteSpace(urlButtonsJson)) return new List<ButtonMetadataDto>();\n\n            try\n            {\n                var arr = Newtonsoft.Json.Linq.JArray.Parse(urlButtonsJson);\n                var list = new List<ButtonMetadataDto>(arr.Count);\n\n                foreach (var j in arr)\n                {\n                    var idx = (int?)(j?[\"index\"]) ?? list.Count;\n                    list.Add(new ButtonMetadataDto\n                    {\n                        Index = idx,\n                        Type = \"URL\",\n                        SubType = \"url\",\n                        Text = \"\",          // label isn‚Äôt stored in UrlButtons; keep empty\n                        ParameterValue = null        // may be resolved later; parameters exist in j[\"parameters\"]\n                    });\n                }\n                return list;\n            }\n            catch\n            {\n                return new List<ButtonMetadataDto>();\n            }\n        }\n\n        private static bool IsHttpsMp4Url(string? url, out string? normalizedError)\n        {\n            normalizedError = null;\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                normalizedError = \"Missing VideoUrl.\";\n                return false;\n            }\n\n            if (!Uri.TryCreate(url.Trim(), UriKind.Absolute, out var uri))\n            {\n                normalizedError = \"VideoUrl is not a valid absolute URL.\";\n                return false;\n            }\n\n            if (!uri.Scheme.Equals(\"https\", StringComparison.OrdinalIgnoreCase))\n            {\n                normalizedError = \"VideoUrl must use HTTPS.\";\n                return false;\n            }\n\n            var ext = Path.GetExtension(uri.AbsolutePath);\n            if (!ext.Equals(\".mp4\", StringComparison.OrdinalIgnoreCase))\n            {\n                normalizedError = \"VideoUrl must point to an .mp4 file.\";\n                return false;\n            }\n\n            return true;\n        }\n        public async Task<ResponseResult> SendVideoTemplateCampaignAsync(Campaign campaign)\n        {\n            try\n            {\n                if (campaign == null || campaign.IsDeleted)\n                    return ResponseResult.ErrorInfo(\"‚ùå Invalid campaign.\");\n                if (campaign.Recipients == null || campaign.Recipients.Count == 0)\n                    return ResponseResult.ErrorInfo(\"‚ùå No recipients to send.\");\n\n                var businessId = campaign.BusinessId;\n\n                static string? PhoneOf(CampaignRecipient r) =>\n                    r?.Contact?.PhoneNumber ?? r?.AudienceMember?.PhoneE164 ?? r?.AudienceMember?.PhoneRaw;\n\n                var recipients = campaign.Recipients.Where(r => !string.IsNullOrWhiteSpace(PhoneOf(r))).ToList();\n                if (recipients.Count == 0)\n                    return ResponseResult.ErrorInfo(\"‚ö†Ô∏è No valid recipients with phone numbers.\");\n\n                // Flow/template selection\n                var (_, entryTemplate) = await ResolveFlowEntryAsync(businessId, campaign.CTAFlowConfigId);\n                var templateKey = !string.IsNullOrWhiteSpace(entryTemplate)\n                    ? entryTemplate!.Trim()\n                    : (campaign.TemplateId ?? campaign.MessageTemplate ?? \"\").Trim();\n                if (string.IsNullOrWhiteSpace(templateKey))\n                    return ResponseResult.ErrorInfo(\"‚ùå No template selected.\");\n\n                // Validate header media URL (must be https .mp4)\n                var videoUrl = (campaign.VideoUrl ?? campaign.ImageUrl ?? \"\").Trim();\n                if (!IsHttpsMp4Url(videoUrl, out var vErr))\n                    return ResponseResult.ErrorInfo(\"üö´ Invalid VideoUrl\", vErr);\n\n                // 1) WhatsApp settings\n                var wa = await _whatsAppSettingsService.GetSettingsByBusinessIdAsync(businessId);\n                if (wa is null)\n                    return ResponseResult.ErrorInfo(\"‚ùå WhatsApp settings not found.\");\n\n                // DB stores Provider UPPERCASE\n                var providerUpper = (wa.Provider ?? string.Empty).Trim().ToUpperInvariant();\n\n                // 2) Fetch template from DB (NO network) ‚Äî try TemplateId first, then Name\n                WhatsAppTemplate? templateRow = await _context.WhatsAppTemplates\n                    .AsNoTracking()\n                    .Where(t => t.BusinessId == businessId &&\n                                t.IsActive &&\n                                t.Provider == providerUpper &&\n                                t.TemplateId == templateKey)\n                    .OrderByDescending(t => t.UpdatedAt)\n                    .ThenByDescending(t => t.LastSyncedAt)\n                    .FirstOrDefaultAsync();\n\n                if (templateRow is null)\n                {\n                    templateRow = await _context.WhatsAppTemplates\n                        .AsNoTracking()\n                        .Where(t => t.BusinessId == businessId &&\n                                    t.IsActive &&\n                                    t.Provider == providerUpper &&\n                                    t.Name == templateKey)\n                        .OrderByDescending(t => t.UpdatedAt)\n                        .ThenByDescending(t => t.LastSyncedAt)\n                        .FirstOrDefaultAsync();\n                }\n\n                if (templateRow == null)\n                    return ResponseResult.ErrorInfo(\"‚ùå Template metadata not found in DB.\");\n\n                var templateMeta = new TemplateMetadataDto\n                {\n                    Name = templateRow.Name,\n                    Language = templateRow.LanguageCode,\n                    Body = templateRow.Body,\n                    // FINAL MODEL: BODY-only placeholder count\n                    PlaceholderCount = Math.Max(0, templateRow.BodyVarCount),\n                    // If you need URL-button structure, adapt UrlButtons here:\n                    ButtonParams = ParseUrlButtonsToButtonMeta(templateRow.UrlButtons)\n                };\n\n                var languageCode = (templateMeta.Language ?? \"\").Trim();\n                if (string.IsNullOrWhiteSpace(languageCode))\n                    return ResponseResult.ErrorInfo(\"‚ùå Template language missing in DB.\");\n\n                // 3) Sender id\n                string? phoneNumberIdOverride = !string.IsNullOrWhiteSpace(campaign.PhoneNumberId)\n                    ? campaign.PhoneNumberId\n                    : wa.PhoneNumberId;\n\n                if (providerUpper == \"META_CLOUD\" && string.IsNullOrWhiteSpace(phoneNumberIdOverride))\n                    return ResponseResult.ErrorInfo(\"‚ùå No PhoneNumberId configured for Meta Cloud sender.\");\n\n                // 4) Optional flow entry step id\n                Guid? entryStepId = null;\n                if (campaign.CTAFlowConfigId.HasValue)\n                {\n                    entryStepId = await _context.CTAFlowSteps\n                        .Where(s => s.CTAFlowConfigId == campaign.CTAFlowConfigId.Value)\n                        .OrderBy(s => s.StepOrder)\n                        .Select(s => (Guid?)s.Id)\n                        .FirstOrDefaultAsync();\n                }\n\n                // 5) Freeze button bundle for UI click tracking\n                string? buttonBundleJson = null;\n                if (templateMeta.ButtonParams is { Count: > 0 })\n                {\n                    var bundle = templateMeta.ButtonParams\n                        .OrderBy(b => b.Index)\n                        .Take(3)\n                        .Select((b, i) => new { i, position = i + 1, text = (b.Text ?? \"\").Trim(), type = b.Type, subType = b.SubType })\n                        .ToList();\n                    buttonBundleJson = JsonConvert.SerializeObject(bundle);\n                }\n\n                // 6) Audience lookup for missing contacts\n                var neededMemberIds = recipients\n                    .Where(x => x.ContactId == null && x.AudienceMemberId != null)\n                    .Select(x => x.AudienceMemberId!.Value)\n                    .Distinct()\n                    .ToList();\n\n                var audienceLookup = neededMemberIds.Count == 0\n                    ? new Dictionary<Guid, (string Phone, string? Name)>()\n                    : await _context.AudienceMembers.AsNoTracking()\n                        .Where(m => m.BusinessId == businessId && neededMemberIds.Contains(m.Id))\n                        .Select(m => new { m.Id, m.PhoneE164, m.PhoneRaw, m.Name })\n                        .ToDictionaryAsync(\n                            x => x.Id,\n                            x => (Phone: string.IsNullOrWhiteSpace(x.PhoneE164) ? (x.PhoneRaw ?? \"\") : x.PhoneE164,\n                                  Name: x.Name)\n                        );\n\n                int successCount = 0, failureCount = 0;\n                var now = DateTime.UtcNow;\n\n                foreach (var r in recipients)\n                {\n                    var phone = PhoneOf(r);\n                    string? name = r.Contact?.Name;\n\n                    if (string.IsNullOrWhiteSpace(phone) && r.AudienceMemberId != null &&\n                        audienceLookup.TryGetValue(r.AudienceMemberId.Value, out var a) &&\n                        !string.IsNullOrWhiteSpace(a.Phone))\n                    {\n                        phone = a.Phone;\n                        name ??= a.Name ?? \"Customer\";\n                    }\n                    if (string.IsNullOrWhiteSpace(phone))\n                    {\n                        failureCount++;\n                        continue;\n                    }\n\n                    var runId = Guid.NewGuid();\n                    var campaignSendLogId = Guid.NewGuid();\n\n                    // ‚úÖ Provider-specific component builder\n                    bool built;\n                    List<object> components;\n                    string? buildErr;\n                    if (providerUpper == \"META_CLOUD\")\n                        built = BuildVideoTemplateComponents_Meta(videoUrl, templateMeta, r, out components, out buildErr);\n                    else\n                        built = BuildVideoTemplateComponents_Pinnacle(videoUrl, templateMeta, r, out components, out buildErr);\n\n                    if (!built)\n                    {\n                        failureCount++;\n                        _logger.LogWarning(\"[VideoTpl] Component build failed campaign={CampaignId} phone={Phone}: {Err}\",\n                            campaign.Id, phone, buildErr);\n\n                        _context.CampaignSendLogs.Add(new CampaignSendLog\n                        {\n                            Id = campaignSendLogId,\n                            CampaignId = campaign.Id,\n                            BusinessId = businessId,\n                            ContactId = r.ContactId,\n                            RecipientId = r.Id,\n                            MessageBody = campaign.MessageBody ?? templateKey,\n                            TemplateId = templateKey,\n                            SendStatus = \"Failed\",\n                            ErrorMessage = $\"component-build: {buildErr}\",\n                            CreatedAt = now,\n                            CreatedBy = campaign.CreatedBy,\n                            CTAFlowConfigId = campaign.CTAFlowConfigId,\n                            CTAFlowStepId = entryStepId,\n                            ButtonBundleJson = buttonBundleJson,\n                            RunId = runId,\n                            SourceChannel = \"video_template\"\n                        });\n                        continue;\n                    }\n\n                    var payload = new\n                    {\n                        messaging_product = \"whatsapp\",\n                        to = phone,\n                        type = \"template\",\n                        template = new\n                        {\n                            name = templateKey,\n                            language = new { code = languageCode },\n                            components\n                        }\n                    };\n\n                    // Attach recipient via stub to avoid accidental inserts of related entities\n                    var recStub = new CampaignRecipient { Id = r.Id };\n                    _context.CampaignRecipients.Attach(recStub);\n                    recStub.MaterializedAt = recStub.MaterializedAt ?? now;\n                    recStub.UpdatedAt = now;\n                    recStub.IdempotencyKey = Idempotency.Sha256(\n                        $\"{campaign.Id}|{phone}|{templateKey}|{videoUrl}|{recStub.ResolvedParametersJson}|{recStub.ResolvedButtonUrlsJson}\");\n\n                    var result = await _messageEngineService.SendPayloadAsync(businessId, providerUpper, payload, phoneNumberIdOverride);\n\n                    var logId = Guid.NewGuid();\n                    _context.MessageLogs.Add(new MessageLog\n                    {\n                        Id = logId,\n                        BusinessId = businessId,\n                        CampaignId = campaign.Id,\n                        ContactId = r.ContactId,\n                        RecipientNumber = phone,\n                        MessageContent = templateKey,\n                        MediaUrl = videoUrl,\n                        Status = result.Success ? \"Sent\" : \"Failed\",\n                        MessageId = result.MessageId,\n                        ErrorMessage = result.ErrorMessage,\n                        RawResponse = result.RawResponse,\n                        CreatedAt = now,\n                        SentAt = result.Success ? now : (DateTime?)null,\n                        Source = \"campaign\",\n                        CTAFlowConfigId = campaign.CTAFlowConfigId,\n                        CTAFlowStepId = entryStepId,\n                        ButtonBundleJson = buttonBundleJson,\n                        RunId = runId,\n                        Provider = providerUpper,\n                        ProviderMessageId = result.MessageId\n                    });\n\n                    await _billingIngest.IngestFromSendResponseAsync(\n                        businessId: businessId,\n                        messageLogId: logId,\n                        provider: providerUpper,\n                        rawResponseJson: result.RawResponse ?? \"{}\"\n                    );\n\n                    await _context.CampaignSendLogs.AddAsync(new CampaignSendLog\n                    {\n                        Id = campaignSendLogId,\n                        CampaignId = campaign.Id,\n                        BusinessId = businessId,\n                        ContactId = r.ContactId,\n                        RecipientId = r.Id,\n                        MessageBody = campaign.MessageBody ?? templateKey,\n                        TemplateId = templateKey,\n                        SendStatus = result.Success ? \"Sent\" : \"Failed\",\n                        MessageLogId = logId,\n                        MessageId = result.MessageId,\n                        ErrorMessage = result.ErrorMessage,\n                        CreatedAt = now,\n                        SentAt = result.Success ? now : (DateTime?)null,\n                        CreatedBy = campaign.CreatedBy,\n                        CTAFlowConfigId = campaign.CTAFlowConfigId,\n                        CTAFlowStepId = entryStepId,\n                        ButtonBundleJson = buttonBundleJson,\n                        RunId = runId,\n                        SourceChannel = \"video_template\"\n                    });\n\n                    if (result.Success) successCount++; else failureCount++;\n                }\n\n                await _context.SaveChangesAsync();\n                return ResponseResult.SuccessInfo($\"üé¨ Video template sent to {successCount} recipients. ‚ùå Failed for {failureCount}.\");\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"Error while sending video template campaign\");\n                return ResponseResult.ErrorInfo(\"üö® Unexpected error while sending video campaign.\", ex.ToString());\n            }\n        }\n\n        \n\n    \n        private bool BuildVideoTemplateComponents_Meta(\n            string videoUrl, TemplateMetadataDto templateMeta,\n            CampaignRecipient r, out List<object> components, out string? error)\n        {\n            components = new List<object>();\n            error = null;\n\n            if (string.IsNullOrWhiteSpace(videoUrl))\n            {\n                error = \"required header VIDEO url is missing\";\n                return false;\n            }\n\n            // HEADER (video)\n            components.Add(new Dictionary<string, object>\n            {\n                [\"type\"] = \"header\",\n                [\"parameters\"] = new object[]\n                {\n            new Dictionary<string, object>\n            {\n                [\"type\"] = \"video\",\n                [\"video\"] = new Dictionary<string, object>\n                {\n                    [\"link\"] = videoUrl\n                }\n            }\n                }\n            });\n\n            // BODY {{1..N}}\n            var count = Math.Max(0, templateMeta.PlaceholderCount);\n            var bodyParams = DeserializeBodyParams(r.ResolvedParametersJson, count);\n            if (count > 0)\n            {\n                // If template expects text params, enforce presence\n                var missing = MissingIndices(bodyParams, count);\n                if (missing.Count > 0)\n                {\n                    error = $\"missing body params at {{ {string.Join(\",\", missing)} }}\";\n                    return false;\n                }\n\n                components.Add(new\n                {\n                    type = \"body\",\n                    parameters = bodyParams.Select(p => new Dictionary<string, object>\n                    {\n                        [\"type\"] = \"text\",\n                        [\"text\"] = p ?? string.Empty\n                    }).ToList()\n                });\n            }\n\n            // URL BUTTON parameters (only when template declares dynamic pieces)\n            if (templateMeta.ButtonParams != null && templateMeta.ButtonParams.Count > 0)\n            {\n                var urlDict = DeserializeButtonDict(r.ResolvedButtonUrlsJson);\n                var total = Math.Min(3, templateMeta.ButtonParams.Count);\n\n                for (int i = 0; i < total; i++)\n                {\n                    var bp = templateMeta.ButtonParams[i];\n                    var subType = (bp.SubType ?? \"url\").ToLowerInvariant();\n                    var paramMask = bp.ParameterValue?.Trim();\n\n                    // Only dynamic URL buttons need a \"text\" parameter\n                    if (!string.Equals(subType, \"url\", StringComparison.OrdinalIgnoreCase))\n                        continue;\n\n                    var isDynamic = !string.IsNullOrWhiteSpace(paramMask) && paramMask.Contains(\"{{\");\n                    if (!isDynamic) continue;\n\n                    // materializer persisted: button{1..3}.url_param\n                    var key = $\"button{i + 1}.url_param\";\n                    if (!urlDict.TryGetValue(key, out var dyn) || string.IsNullOrWhiteSpace(dyn))\n                    {\n                        error = $\"missing dynamic URL param for {key}\";\n                        return false;\n                    }\n\n                    components.Add(new Dictionary<string, object>\n                    {\n                        [\"type\"] = \"button\",\n                        [\"sub_type\"] = \"url\",\n                        [\"index\"] = i.ToString(), // \"0\",\"1\",\"2\"\n                        [\"parameters\"] = new object[]\n                        {\n                    new Dictionary<string, object> { [\"type\"] = \"text\", [\"text\"] = dyn }\n                        }\n                    });\n                }\n            }\n\n            return true;\n        }\n\n        private bool BuildVideoTemplateComponents_Pinnacle(\n                string videoUrl,\n                TemplateMetadataDto templateMeta,\n                CampaignRecipient r,\n        out List<object> components,\n        out string? error)\n        {\n            // If Pinnacle uses same structure as Meta for templates, we can reuse Meta logic.\n            // If they require a different header/media envelope, adapt here.\n            return BuildVideoTemplateComponents_Meta(videoUrl, templateMeta, r, out components, out error);\n        }\n        private static Dictionary<string, string> DeserializeButtonDict(string? json)\n        {\n            try\n            {\n                return string.IsNullOrWhiteSpace(json)\n                    ? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)\n                    : JsonConvert.DeserializeObject<Dictionary<string, string>>(json!)\n                      ?? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n            }\n            catch\n            {\n                return new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n            }\n        }\n        private static List<int> MissingIndices(List<string> bodyParams, int count)\n        {\n            var miss = new List<int>();\n            for (int i = 0; i < count; i++)\n            {\n                if (string.IsNullOrWhiteSpace(i < bodyParams.Count ? bodyParams[i] : null))\n                    miss.Add(i + 1); // 1-based for readability\n            }\n            return miss;\n        }\n        // ---------- helpers ----------\n        private static List<string> DeserializeBodyParams(string? json, int expectedCount)\n        {\n            try\n            {\n                var arr = string.IsNullOrWhiteSpace(json)\n                    ? Array.Empty<string>()\n                    : JsonConvert.DeserializeObject<string[]>(json!) ?? Array.Empty<string>();\n\n                // pad/trim to template placeholder count\n                var list = new List<string>(Enumerable.Repeat(string.Empty, Math.Max(expectedCount, 0)));\n                for (int i = 0; i < Math.Min(expectedCount, arr.Length); i++)\n                    list[i] = arr[i] ?? string.Empty;\n                return list;\n            }\n            catch\n            {\n                return new List<string>(Enumerable.Repeat(string.Empty, Math.Max(expectedCount, 0)));\n            }\n        }\n        private static readonly Regex PlaceholderRe = new(@\"\\{\\{\\s*(\\d+)\\s*\\}\\}\", RegexOptions.Compiled);\n\n        private string BuildTokenParam(Guid campaignSendLogId, int buttonIndex, string? buttonTitle, string destinationUrlAbsolute)\n        {\n            var full = _urlBuilderService.BuildTrackedButtonUrl(campaignSendLogId, buttonIndex, buttonTitle, destinationUrlAbsolute);\n            var pos = full.LastIndexOf(\"/r/\", StringComparison.OrdinalIgnoreCase);\n            return (pos >= 0) ? full[(pos + 3)..] : full; // fallback: if not found, return full (rare)\n        }\n\n        private static string NormalizeAbsoluteUrlOrThrowForButton(string input, string buttonTitle, int buttonIndex)\n        {\n            if (string.IsNullOrWhiteSpace(input))\n                throw new ArgumentException($\"Destination is required for button '{buttonTitle}' (index {buttonIndex}).\");\n\n            // Trim + strip control chars\n            var cleaned = new string(input.Trim().Where(c => !char.IsControl(c)).ToArray());\n            if (cleaned.Length == 0)\n                throw new ArgumentException($\"Destination is required for button '{buttonTitle}' (index {buttonIndex}).\");\n\n            // Allow tel: and WhatsApp deep links\n            if (cleaned.StartsWith(\"tel:\", StringComparison.OrdinalIgnoreCase) ||\n                cleaned.StartsWith(\"wa:\", StringComparison.OrdinalIgnoreCase) ||\n                cleaned.StartsWith(\"https://wa.me/\", StringComparison.OrdinalIgnoreCase))\n            {\n                return cleaned; // Accept as-is\n            }\n\n            // Normal web links\n            if (Uri.TryCreate(cleaned, UriKind.Absolute, out var uri) &&\n                (uri.Scheme.Equals(Uri.UriSchemeHttp, StringComparison.OrdinalIgnoreCase) ||\n                 uri.Scheme.Equals(Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase)))\n            {\n                return uri.ToString();\n            }\n\n            // Reject everything else\n            throw new ArgumentException(\n                $\"Destination must be an absolute http/https/tel/wa URL for button '{buttonTitle}' (index {buttonIndex}). Got: '{input}'\");\n        }\n\n        private static bool LooksLikeAbsoluteBaseUrlWithPlaceholder(string? templateUrl)\n        {\n            if (string.IsNullOrWhiteSpace(templateUrl)) return false;\n            var s = templateUrl.Trim();\n            if (!s.Contains(\"{{\")) return false;\n\n            // Probe by replacing common placeholders with a char\n            var probe = PlaceholderRe.Replace(s, \"x\");\n            return Uri.TryCreate(probe, UriKind.Absolute, out var abs) &&\n                   (abs.Scheme.Equals(Uri.UriSchemeHttp, StringComparison.OrdinalIgnoreCase) ||\n                    abs.Scheme.Equals(Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase));\n        }\n\n        private static object[] BuildBodyParameters(List<string>? templateParams, int requiredCount)\n        {\n            if (requiredCount <= 0) return Array.Empty<object>();\n\n            var src = templateParams ?? new List<string>();\n            if (src.Count > requiredCount) src = src.Take(requiredCount).ToList();\n            while (src.Count < requiredCount) src.Add(string.Empty);\n\n            return src.Select(p => (object)new { type = \"text\", text = p ?? string.Empty }).ToArray();\n        }\n\n        private static string NormalizePhoneForTel(string? raw)\n        {\n            if (string.IsNullOrWhiteSpace(raw)) return \"\";\n            var p = raw.Trim();\n            var digits = new string(p.Where(char.IsDigit).ToArray());\n            // keep leading + if present initially; always output +<digits>\n            return \"+\" + digits;\n        }\n\n        private static string ReplaceAllPlaceholdersWith(string template, string replacement)\n        {\n            if (string.IsNullOrWhiteSpace(template)) return string.Empty;\n            return PlaceholderRe.Replace(template, _ => replacement ?? string.Empty);\n        }\n\n        // ======================================================\n        // META ‚Äî TEXT TEMPLATE COMPONENTS\n        // ======================================================\n\n\n        // New overload with resolvedButtonUrls\n        private List<object> BuildTextTemplateComponents_Meta(\n            List<string> templateParams,\n            List<CampaignButton>? buttonList,\n            TemplateMetadataDto templateMeta,\n            Guid campaignSendLogId,\n            Contact contact,\n            out List<string> resolvedButtonUrls)\n        {\n            var components = new List<object>();\n            resolvedButtonUrls = new List<string>();\n\n            // BODY: send exactly PlaceholderCount\n            if (templateMeta.PlaceholderCount > 0)\n            {\n                var bodyParams = BuildBodyParameters(templateParams, templateMeta.PlaceholderCount);\n                components.Add(new { type = \"body\", parameters = bodyParams });\n            }\n\n            // No buttons or template has no button params\n            if (buttonList == null || buttonList.Count == 0 ||\n                templateMeta.ButtonParams == null || templateMeta.ButtonParams.Count == 0)\n                return components;\n\n            // Ensure index alignment with the template by ordering by Position (then original index)\n            var orderedButtons = buttonList\n                .Select((b, idx) => new { Btn = b, idx })\n                .OrderBy(x => (int?)x.Btn.Position ?? int.MaxValue)\n                .ThenBy(x => x.idx)\n                .Select(x => x.Btn)\n                .ToList();\n\n            var total = Math.Min(3, Math.Min(orderedButtons.Count, templateMeta.ButtonParams.Count));\n\n            // Phone normalization (for optional {{1}} substitution on campaign button value)\n            var phone = NormalizePhoneForTel(contact?.PhoneNumber);\n            var encodedPhone = Uri.EscapeDataString(phone);\n\n            for (int i = 0; i < total; i++)\n            {\n                var meta = templateMeta.ButtonParams[i];\n                var subType = (meta.SubType ?? \"url\").ToLowerInvariant();\n                var metaParam = meta.ParameterValue?.Trim();\n\n                // Meta needs parameters ONLY for dynamic URL buttons\n                if (!string.Equals(subType, \"url\", StringComparison.OrdinalIgnoreCase))\n                    continue;\n\n                var isDynamic = !string.IsNullOrWhiteSpace(metaParam) && metaParam.Contains(\"{{\");\n                if (!isDynamic)\n                    continue;\n\n                var btn = orderedButtons[i];\n                var btnType = (btn?.Type ?? \"URL\").ToUpperInvariant();\n                if (!string.Equals(btnType, \"URL\", StringComparison.OrdinalIgnoreCase))\n                {\n                    // If template expects dynamic URL at this index and your campaign button isn't URL, skip to avoid provider error\n                    continue;\n                }\n\n                var valueRaw = btn.Value?.Trim();\n                if (string.IsNullOrWhiteSpace(valueRaw))\n                {\n                    throw new InvalidOperationException(\n                        $\"Template requires a dynamic URL at button index {i}, but campaign button value is empty.\");\n                }\n\n                // Optional phone substitution in destination (support any {{n}})\n                var resolvedDestination = PlaceholderRe.Replace(valueRaw, m =>\n                {\n                    if (!int.TryParse(m.Groups[1].Value, out var n)) return \"\";\n                    if (n == 1) return encodedPhone; // convention: {{1}} can be phone\n                    var idx = n - 1;\n                    return (idx >= 0 && idx < templateParams.Count) ? (templateParams[idx] ?? \"\") : \"\";\n                });\n\n                resolvedDestination = NormalizeAbsoluteUrlOrThrowForButton(resolvedDestination, btn.Title ?? \"\", i);\n\n                // Build both; choose which to send based on template base style\n                var fullTrackedUrl = _urlBuilderService.BuildTrackedButtonUrl(campaignSendLogId, i, btn.Title, resolvedDestination);\n                var tokenParam = BuildTokenParam(campaignSendLogId, i, btn.Title, resolvedDestination);\n\n                var templateHasAbsoluteBase = LooksLikeAbsoluteBaseUrlWithPlaceholder(metaParam);\n                var valueToSend = templateHasAbsoluteBase ? tokenParam : fullTrackedUrl;\n\n                components.Add(new Dictionary<string, object>\n                {\n                    [\"type\"] = \"button\",\n                    [\"sub_type\"] = \"url\",\n                    [\"index\"] = i.ToString(), // \"0\"/\"1\"/\"2\"\n                    [\"parameters\"] = new[] {\n                new Dictionary<string, object> { [\"type\"] = \"text\", [\"text\"] = valueToSend }\n            }\n                });\n\n                // Provider-resolved URL (what the client actually clicks):\n                // replace all placeholders in provider template with the parameter we sent.\n                var providerResolved = ReplaceAllPlaceholdersWith(metaParam ?? \"\", valueToSend);\n                resolvedButtonUrls.Add(providerResolved);\n            }\n\n            return components;\n        }\n\n        // ======================================================\n        // PINNACLE ‚Äî TEXT TEMPLATE COMPONENTS\n        // ======================================================\n\n        // Back-compat wrapper (old signature)\n        private List<object> BuildTextTemplateComponents_Pinnacle(\n            List<string> templateParams,\n            List<CampaignButton>? buttonList,\n            TemplateMetadataDto templateMeta,\n            Guid campaignSendLogId,\n            Contact contact)\n        {\n            return BuildTextTemplateComponents_Pinnacle(\n                templateParams, buttonList, templateMeta, campaignSendLogId, contact, out _);\n        }\n\n        // New overload with resolvedButtonUrls\n        private List<object> BuildTextTemplateComponents_Pinnacle(\n            List<string> templateParams,\n            List<CampaignButton>? buttonList,\n            TemplateMetadataDto templateMeta,\n            Guid campaignSendLogId,\n            Contact contact,\n            out List<string> resolvedButtonUrls)\n        {\n            var components = new List<object>();\n            resolvedButtonUrls = new List<string>();\n\n            // BODY: Pinnacle is strict ‚Üí always send exactly PlaceholderCount\n            if (templateMeta.PlaceholderCount > 0)\n            {\n                var bodyParams = BuildBodyParameters(templateParams, templateMeta.PlaceholderCount);\n                components.Add(new { type = \"body\", parameters = bodyParams });\n            }\n\n            // No buttons to map ‚Üí return body-only\n            if (buttonList == null || buttonList.Count == 0 ||\n                templateMeta.ButtonParams == null || templateMeta.ButtonParams.Count == 0)\n                return components;\n\n            // Ensure index alignment with the template by ordering by Position (then original index)\n            var orderedButtons = buttonList\n                .Select((b, idx) => new { Btn = b, idx })\n                .OrderBy(x => (int?)x.Btn.Position ?? int.MaxValue)\n                .ThenBy(x => x.idx)\n                .Select(x => x.Btn)\n                .ToList();\n\n            var total = Math.Min(3, Math.Min(orderedButtons.Count, templateMeta.ButtonParams.Count));\n\n            // Phone normalization (for optional {{1}} substitution on campaign button value)\n            var phone = NormalizePhoneForTel(contact?.PhoneNumber);\n            var encodedPhone = Uri.EscapeDataString(phone);\n\n            for (int i = 0; i < total; i++)\n            {\n                var meta = templateMeta.ButtonParams[i];\n                var subType = (meta.SubType ?? \"url\").ToLowerInvariant();\n                var metaParam = meta.ParameterValue?.Trim();\n\n                // This path supports dynamic URL params only\n                if (!string.Equals(subType, \"url\", StringComparison.OrdinalIgnoreCase))\n                    continue;\n\n                var isDynamic = !string.IsNullOrWhiteSpace(metaParam) && metaParam.Contains(\"{{\");\n                if (!isDynamic)\n                    continue;\n\n                var btn = orderedButtons[i];\n                var btnType = (btn?.Type ?? \"URL\").ToUpperInvariant();\n                if (!string.Equals(btnType, \"URL\", StringComparison.OrdinalIgnoreCase))\n                {\n                    throw new InvalidOperationException(\n                        $\"Template expects a dynamic URL at button index {i}, but campaign button type is '{btn?.Type}'.\");\n                }\n\n                var valueRaw = btn?.Value?.Trim();\n                if (string.IsNullOrWhiteSpace(valueRaw))\n                {\n                    throw new InvalidOperationException(\n                        $\"Template requires a dynamic URL at button index {i}, but campaign button value is empty.\");\n                }\n\n                // Optional phone + param substitution (support any {{n}})\n                var resolvedDestination = PlaceholderRe.Replace(valueRaw, m =>\n                {\n                    if (!int.TryParse(m.Groups[1].Value, out var n)) return \"\";\n                    if (n == 1) return encodedPhone;\n                    var idx = n - 1;\n                    return (idx >= 0 && idx < templateParams.Count) ? (templateParams[idx] ?? \"\") : \"\";\n                });\n\n                // Validate + normalize absolute URL\n                resolvedDestination = NormalizeAbsoluteUrlOrThrowForButton(resolvedDestination, btn!.Title ?? \"\", i);\n\n                // Build both options: full tracked URL vs token param (for absolute-base placeholders)\n                var fullTrackedUrl = _urlBuilderService.BuildTrackedButtonUrl(campaignSendLogId, i, btn.Title, resolvedDestination);\n                var tokenParam = BuildTokenParam(campaignSendLogId, i, btn.Title, resolvedDestination);\n\n                var templateHasAbsoluteBase = LooksLikeAbsoluteBaseUrlWithPlaceholder(metaParam);\n                var valueToSend = templateHasAbsoluteBase ? tokenParam : fullTrackedUrl;\n\n                // Pinnacle payload shape (kept aligned with Meta)\n                components.Add(new Dictionary<string, object>\n                {\n                    [\"type\"] = \"button\",\n                    [\"sub_type\"] = \"url\",\n                    [\"index\"] = i.ToString(),\n                    [\"parameters\"] = new[] {\n                new Dictionary<string, object> { [\"type\"] = \"text\", [\"text\"] = valueToSend }\n            }\n                });\n\n                // Provider-resolved URL (what the user will open)\n                var providerResolved = ReplaceAllPlaceholdersWith(metaParam ?? \"\", valueToSend);\n                resolvedButtonUrls.Add(providerResolved);\n            }\n\n            return components;\n        }\n\n        #region SendImagetemplate\n        public async Task<ResponseResult> SendImageTemplateCampaignAsync(Campaign campaign)\n        {\n            try\n            {\n                if (campaign == null || campaign.IsDeleted)\n                    return ResponseResult.ErrorInfo(\"‚ùå Invalid campaign.\");\n                if (campaign.Recipients == null || campaign.Recipients.Count == 0)\n                    return ResponseResult.ErrorInfo(\"‚ùå No recipients to send.\");\n\n                var businessId = campaign.BusinessId;\n\n                static string? ResolveRecipientPhone(CampaignRecipient r) =>\n                    r?.Contact?.PhoneNumber ?? r?.AudienceMember?.PhoneE164 ?? r?.AudienceMember?.PhoneRaw;\n\n                var recipients = campaign.Recipients\n                    .Where(r => !string.IsNullOrWhiteSpace(ResolveRecipientPhone(r)))\n                    .ToList();\n\n                if (recipients.Count == 0)\n                    return ResponseResult.ErrorInfo(\"‚ö†Ô∏è No valid recipients with phone numbers (Contact/AudienceMember).\");\n\n                // Flow/template selection\n                var (_, entryTemplate) = await ResolveFlowEntryAsync(businessId, campaign.CTAFlowConfigId);\n                var templateKey = !string.IsNullOrWhiteSpace(entryTemplate)\n                    ? entryTemplate!.Trim()\n                    : (campaign.TemplateId ?? campaign.MessageTemplate ?? \"\").Trim();\n\n                if (string.IsNullOrWhiteSpace(templateKey))\n                    return ResponseResult.ErrorInfo(\"‚ùå No template selected.\");\n\n                // WhatsApp settings\n                var wa = await _whatsAppSettingsService.GetSettingsByBusinessIdAsync(businessId);\n                if (wa is null)\n                    return ResponseResult.ErrorInfo(\"‚ùå WhatsApp settings not found.\");\n\n                // DB stores Provider in UPPERCASE\n                var providerUpper = (wa.Provider ?? string.Empty).Trim().ToUpperInvariant();\n                if (providerUpper != \"META_CLOUD\" && providerUpper != \"PINNACLE\")\n                    return ResponseResult.ErrorInfo($\"‚ùå Unsupported provider configured: {providerUpper}\");\n\n                // Template from DB (try TemplateId first, then Name)\n                WhatsAppTemplate? templateRow = await _context.WhatsAppTemplates\n                    .AsNoTracking()\n                    .Where(t => t.BusinessId == businessId &&\n                                t.IsActive &&\n                                t.Provider == providerUpper &&\n                                t.TemplateId == templateKey)\n                    .OrderByDescending(t => t.UpdatedAt)\n                    .ThenByDescending(t => t.LastSyncedAt)\n                    .FirstOrDefaultAsync();\n\n                if (templateRow is null)\n                {\n                    templateRow = await _context.WhatsAppTemplates\n                        .AsNoTracking()\n                        .Where(t => t.BusinessId == businessId &&\n                                    t.IsActive &&\n                                    t.Provider == providerUpper &&\n                                    t.Name == templateKey)\n                        .OrderByDescending(t => t.UpdatedAt)\n                        .ThenByDescending(t => t.LastSyncedAt)\n                        .FirstOrDefaultAsync();\n                }\n\n                if (templateRow == null)\n                    return ResponseResult.ErrorInfo(\"‚ùå Template metadata not found in DB.\");\n\n                // Map DB row -> DTO your builders need\n                var tmplMeta = new TemplateMetadataDto\n                {\n                    Name = templateRow.Name,\n                    Language = templateRow.LanguageCode,\n                    Body = templateRow.Body,\n                    // FINAL MODEL: body-only placeholder count:\n                    PlaceholderCount = Math.Max(0, templateRow.BodyVarCount),\n                    ButtonParams = ParseUrlButtonsToButtonMeta(templateRow.UrlButtons)\n\n                };\n                var parameterFormat = (templateRow.ParameterFormat ?? \"POSITIONAL\").Trim().ToUpperInvariant();\n                var bodyParamNames = ExtractBodyParamNamesFromTemplate(templateRow.RawJson, templateRow.Body, parameterFormat);\n                var languageCode = (tmplMeta.Language ?? \"\").Trim();\n                if (string.IsNullOrWhiteSpace(languageCode))\n                    return ResponseResult.ErrorInfo(\"‚ùå Template language missing in DB.\");\n\n                // Sender (campaign override ‚Üí DTO)\n                string? phoneNumberIdOverride = !string.IsNullOrWhiteSpace(campaign.PhoneNumberId)\n                    ? campaign.PhoneNumberId\n                    : wa.PhoneNumberId;\n\n                if (providerUpper == \"META_CLOUD\" && string.IsNullOrWhiteSpace(phoneNumberIdOverride))\n                    return ResponseResult.ErrorInfo(\"‚ùå No PhoneNumberId configured for Meta Cloud sender.\");\n\n                // Flow entry step id\n                Guid? entryStepId = null;\n                if (campaign.CTAFlowConfigId.HasValue)\n                {\n                    entryStepId = await _context.CTAFlowSteps\n                        .Where(s => s.CTAFlowConfigId == campaign.CTAFlowConfigId.Value)\n                        .OrderBy(s => s.StepOrder)\n                        .Select(s => (Guid?)s.Id)\n                        .FirstOrDefaultAsync();\n                }\n\n                // Freeze button bundle (for analytics)\n                string? buttonBundleJson = null;\n                if (tmplMeta.ButtonParams is { Count: > 0 })\n                {\n                    var bundle = tmplMeta.ButtonParams\n                        .OrderBy(b => b.Index)\n                        .Take(3)\n                        .Select((b, i) => new { i, position = i + 1, text = (b.Text ?? \"\").Trim(), type = b.Type, subType = b.SubType })\n                        .ToList();\n                    buttonBundleJson = JsonConvert.SerializeObject(bundle);\n                }\n\n                // Prefetch AudienceMembers for recipients without Contact\n                var neededMemberIds = recipients\n                    .Where(x => x.ContactId == null && x.AudienceMemberId != null)\n                    .Select(x => x.AudienceMemberId!.Value)\n                    .Distinct()\n                    .ToList();\n\n                var audienceLookup = neededMemberIds.Count == 0\n                    ? new Dictionary<Guid, (string Phone, string? Name)>()\n                    : await _context.AudienceMembers.AsNoTracking()\n                        .Where(m => m.BusinessId == businessId && neededMemberIds.Contains(m.Id))\n                        .Select(m => new { m.Id, m.PhoneE164, m.PhoneRaw, m.Name })\n                        .ToDictionaryAsync(\n                            x => x.Id,\n                            x => (Phone: string.IsNullOrWhiteSpace(x.PhoneE164) ? (x.PhoneRaw ?? \"\") : x.PhoneE164,\n                                  Name: x.Name)\n                        );\n\n                // Campaign buttons (stable order)\n                var buttons = campaign.MultiButtons?\n                    .Select((b, idx) => new { Btn = b, idx })\n                    .OrderBy(x => (int?)x.Btn.Position ?? int.MaxValue)\n                    .ThenBy(x => x.idx)\n                    .Select(x => x.Btn)\n                    .ToList() ?? new List<CampaignButton>();\n\n                int successCount = 0, failureCount = 0;\n                var now = DateTime.UtcNow;\n\n                foreach (var r in recipients)\n                {\n                    var phone = ResolveRecipientPhone(r);\n                    string? name = r.Contact?.Name;\n\n                    if (string.IsNullOrWhiteSpace(phone) && r.AudienceMemberId != null &&\n                        audienceLookup.TryGetValue(r.AudienceMemberId.Value, out var a) &&\n                        !string.IsNullOrWhiteSpace(a.Phone))\n                    {\n                        phone = a.Phone;\n                        name ??= a.Name ?? \"Customer\";\n                    }\n\n                    if (string.IsNullOrWhiteSpace(phone))\n                    {\n                        failureCount++;\n                        continue;\n                    }\n\n                    // Synthetic contact for templating only\n                    var contactForTemplating = r.Contact ?? new Contact\n                    {\n                        Id = Guid.Empty,\n                        BusinessId = businessId,\n                        PhoneNumber = phone,\n                        Name = name ?? \"Customer\"\n                    };\n\n                    // BODY params per recipient (positional only; your final model‚Äôs hot path)\n                    //var resolvedParams = GetRecipientBodyParams(r, tmplMeta.PlaceholderCount, campaign.TemplateParameters);\n                    var resolvedParams = GetRecipientBodyParams(\n                           r,\n                           tmplMeta.PlaceholderCount, campaign.TemplateParameters, bodyParamNames, parameterFormat\n                        );\n                    if (tmplMeta.PlaceholderCount > 0 && resolvedParams.Any(string.IsNullOrWhiteSpace))\n                    {\n                        failureCount++;\n                        var why = $\"Missing body parameter(s): expected {tmplMeta.PlaceholderCount}, got {resolvedParams.Count(x => !string.IsNullOrWhiteSpace(x))} filled.\";\n\n                        var recStubMiss = new CampaignRecipient { Id = r.Id };\n                        _context.CampaignRecipients.Attach(recStubMiss);\n                        recStubMiss.MaterializedAt = now;\n                        recStubMiss.UpdatedAt = now;\n                        recStubMiss.ResolvedParametersJson = JsonConvert.SerializeObject(resolvedParams);\n\n                        var logIdLocal = Guid.NewGuid();\n                        _context.MessageLogs.Add(new MessageLog\n                        {\n                            Id = logIdLocal,\n                            BusinessId = businessId,\n                            CampaignId = campaign.Id,\n                            ContactId = r.ContactId,\n                            RecipientNumber = phone,\n                            MessageContent = templateKey,\n                            MediaUrl = campaign.ImageUrl,\n                            Status = \"Failed\",\n                            ErrorMessage = why,\n                            RawResponse = \"{\\\"local_error\\\":\\\"missing_template_body_params\\\"}\",\n                            CreatedAt = now,\n                            Source = \"campaign\",\n                            CTAFlowConfigId = campaign.CTAFlowConfigId,\n                            CTAFlowStepId = entryStepId,\n                            ButtonBundleJson = buttonBundleJson\n                        });\n\n                        await _context.CampaignSendLogs.AddAsync(new CampaignSendLog\n                        {\n                            Id = Guid.NewGuid(),\n                            CampaignId = campaign.Id,\n                            BusinessId = businessId,\n                            ContactId = r.ContactId,\n                            RecipientId = r.Id,\n                            MessageBody = campaign.MessageBody ?? templateKey,\n                            TemplateId = templateKey,\n                            SendStatus = \"Failed\",\n                            MessageLogId = logIdLocal,\n                            ErrorMessage = why,\n                            CreatedAt = now,\n                            CTAFlowConfigId = campaign.CTAFlowConfigId,\n                            CTAFlowStepId = entryStepId,\n                            ButtonBundleJson = buttonBundleJson\n                        });\n\n                        continue;\n                    }\n\n                    // Build components and resolve dynamic URL buttons\n                    var runId = Guid.NewGuid();\n                    var campaignSendLogId = Guid.NewGuid();\n                    List<string> resolvedButtonUrls;\n\n                    _ = (providerUpper == \"PINNACLE\")\n                        ? BuildImageTemplateComponents_Pinnacle(\n                            campaign.ImageUrl, resolvedParams, buttons, tmplMeta, campaignSendLogId, contactForTemplating, out resolvedButtonUrls)\n                        : BuildImageTemplateComponents_Meta(\n                            campaign.ImageUrl, resolvedParams, buttons, tmplMeta, campaignSendLogId, contactForTemplating, out resolvedButtonUrls);\n\n                    // Attach recipient via stub before send\n                    var recStub = new CampaignRecipient { Id = r.Id };\n                    _context.CampaignRecipients.Attach(recStub);\n                    recStub.ResolvedParametersJson = JsonConvert.SerializeObject(resolvedParams);\n                    recStub.ResolvedButtonUrlsJson = JsonConvert.SerializeObject(resolvedButtonUrls);\n                    recStub.MaterializedAt = now;\n                    recStub.UpdatedAt = now;\n                    recStub.IdempotencyKey = Idempotency.Sha256(\n                        $\"{campaign.Id}|{phone}|{templateKey}|{recStub.ResolvedParametersJson}|{recStub.ResolvedButtonUrlsJson}|{campaign.ImageUrl}|{campaign.ImageCaption}\");\n\n                    // Send via engine\n                    var dto = new ImageTemplateMessageDto\n                    {\n                        BusinessId = businessId,\n                        Provider = providerUpper,\n                        PhoneNumberId = phoneNumberIdOverride,\n                        RecipientNumber = phone,\n                        TemplateName = templateKey,\n                        LanguageCode = languageCode,\n                        HeaderImageUrl = campaign.ImageUrl,\n                        TemplateBody = campaign.MessageBody,\n                        TemplateParameters = resolvedParams,\n                        ButtonParameters = buttons.Take(3).Select(b => new CampaignButtonDto\n                        {\n                            ButtonText = b.Title,\n                            ButtonType = b.Type,\n                            TargetUrl = b.Value\n                        }).ToList(),\n                        CTAFlowConfigId = campaign.CTAFlowConfigId,\n                        CTAFlowStepId = entryStepId\n                    };\n\n                    var result = await _messageEngineService.SendImageTemplateMessageAsync(dto, businessId);\n\n                    var logId = Guid.NewGuid();\n                    _context.MessageLogs.Add(new MessageLog\n                    {\n                        Id = logId,\n                        BusinessId = businessId,\n                        CampaignId = campaign.Id,\n                        ContactId = r.ContactId,\n                        RecipientNumber = phone,\n                        MessageContent = templateKey,\n                        MediaUrl = campaign.ImageUrl,\n                        Status = result.Success ? \"Sent\" : \"Failed\",\n                        MessageId = result.MessageId,\n                        ErrorMessage = result.ErrorMessage,\n                        RawResponse = result.RawResponse,\n                        CreatedAt = now,\n                        SentAt = result.Success ? now : (DateTime?)null,\n                        Source = \"campaign\",\n                        CTAFlowConfigId = campaign.CTAFlowConfigId,\n                        CTAFlowStepId = entryStepId,\n                        ButtonBundleJson = buttonBundleJson,\n                        RunId = runId\n                    });\n\n                    await _billingIngest.IngestFromSendResponseAsync(\n                        businessId: businessId,\n                        messageLogId: logId,\n                        provider: providerUpper,\n                        rawResponseJson: result.RawResponse ?? \"{}\"\n                    );\n\n                    await _context.CampaignSendLogs.AddAsync(new CampaignSendLog\n                    {\n                        Id = campaignSendLogId,\n                        CampaignId = campaign.Id,\n                        BusinessId = businessId,\n                        ContactId = r.ContactId,\n                        RecipientId = r.Id,\n                        MessageBody = campaign.MessageBody ?? templateKey,\n                        TemplateId = templateKey,\n                        SendStatus = result.Success ? \"Sent\" : \"Failed\",\n                        MessageLogId = logId,\n                        MessageId = result.MessageId,\n                        ErrorMessage = result.ErrorMessage,\n                        CreatedAt = now,\n                        SentAt = result.Success ? now : (DateTime?)null,\n                        CTAFlowConfigId = campaign.CTAFlowConfigId,\n                        CTAFlowStepId = entryStepId,\n                        ButtonBundleJson = buttonBundleJson,\n                        RunId = runId\n                    });\n\n                    if (result.Success) successCount++; else failureCount++;\n                }\n\n                await _context.SaveChangesAsync();\n                return ResponseResult.SuccessInfo($\"üì§ Sent to {successCount} recipients. ‚ùå Failed for {failureCount}.\");\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"Error while sending image template campaign\");\n                return ResponseResult.ErrorInfo(\"üö® Unexpected error while sending campaign.\", ex.ToString());\n            }\n        }\n\n        // Storage shape [{ index, parameters: [...] }] ‚Üí your ButtonMetadataDto\n\n        private List<object> BuildImageTemplateComponents_Pinnacle(\n       string? imageUrl,\n       List<string> templateParams,\n       List<CampaignButton>? buttonList,\n       TemplateMetadataDto templateMeta,\n       Guid campaignSendLogId,\n       Contact contact,\n       out List<string> resolvedButtonUrls)\n        {\n            var components = new List<object>();\n            resolvedButtonUrls = new List<string>();\n\n            // Header\n            if (!string.IsNullOrWhiteSpace(imageUrl) && templateMeta.HasImageHeader)\n            {\n                components.Add(new\n                {\n                    type = \"header\",\n                    parameters = new object[]\n                    {\n                new { type = \"image\", image = new { link = imageUrl } }\n                    }\n                });\n            }\n\n            // Body\n            if (templateMeta.PlaceholderCount > 0 && templateParams?.Count > 0)\n            {\n                components.Add(new\n                {\n                    type = \"body\",\n                    parameters = templateParams.Select(p => new { type = \"text\", text = p }).ToArray()\n                });\n            }\n\n            // Buttons\n            if (buttonList == null || buttonList.Count == 0 ||\n                templateMeta.ButtonParams == null || templateMeta.ButtonParams.Count == 0)\n                return components;\n\n            var total = Math.Min(3, Math.Min(buttonList.Count, templateMeta.ButtonParams.Count));\n\n            // phone for optional {{1}}\n            var phone = string.IsNullOrWhiteSpace(contact?.PhoneNumber) ? \"\" :\n                        (contact.PhoneNumber.StartsWith(\"+\") ? contact.PhoneNumber : \"+\" + contact.PhoneNumber);\n            var encodedPhone = Uri.EscapeDataString(phone);\n\n            for (int i = 0; i < total; i++)\n            {\n                var btn = buttonList[i];\n                var meta = templateMeta.ButtonParams[i];\n                var subtype = (meta.SubType ?? \"url\").ToLowerInvariant();\n                var metaParam = meta.ParameterValue?.Trim() ?? string.Empty; // e.g. \"/r/{{1}}\"\n                var isDynamic = metaParam.Contains(\"{{\");\n\n                if (!isDynamic)\n                {\n                    // static provider button at this index ‚Äî no parameters to send\n                    components.Add(new Dictionary<string, object>\n                    {\n                        [\"type\"] = \"button\",\n                        [\"sub_type\"] = subtype,\n                        [\"index\"] = i\n                    });\n                    continue;\n                }\n\n                var valueRaw = btn?.Value?.Trim();\n                if (string.IsNullOrWhiteSpace(valueRaw)) continue;\n\n                // Optional phone substitution + body params {{n}}\n                var resolvedDestination = PlaceholderRe.Replace(valueRaw, m =>\n                {\n                    if (!int.TryParse(m.Groups[1].Value, out var n)) return \"\";\n                    if (n == 1) return encodedPhone;\n                    var idx = n - 1;\n                    return (idx >= 0 && idx < templateParams.Count) ? (templateParams[idx] ?? \"\") : \"\";\n                });\n\n                // Track + token (same pattern as text path)\n                var fullTrackedUrl = _urlBuilderService.BuildTrackedButtonUrl(campaignSendLogId, i, btn.Title, resolvedDestination);\n                var tokenParam = BuildTokenParam(campaignSendLogId, i, btn.Title, resolvedDestination);\n\n                var templateHasAbsoluteBase = LooksLikeAbsoluteBaseUrlWithPlaceholder(metaParam);\n                var valueToSend = templateHasAbsoluteBase ? tokenParam : fullTrackedUrl;\n\n                components.Add(new Dictionary<string, object>\n                {\n                    [\"type\"] = \"button\",\n                    [\"sub_type\"] = subtype,\n                    [\"index\"] = i,\n                    [\"parameters\"] = new[] { new Dictionary<string, object> { [\"type\"] = \"text\", [\"text\"] = valueToSend } }\n                });\n\n                // what the client will actually open once provider composes the URL\n                var providerResolved = ReplaceAllPlaceholdersWith(metaParam, valueToSend);\n                resolvedButtonUrls.Add(providerResolved);\n            }\n\n            return components;\n        }\n\n\n        private List<object> BuildImageTemplateComponents_Meta(\n       string? imageUrl,\n       List<string> templateParams,\n       List<CampaignButton>? buttonList,\n       TemplateMetadataDto templateMeta,\n       Guid campaignSendLogId,\n       Contact contact,\n       out List<string> resolvedButtonUrls)\n        {\n            var components = new List<object>();\n            resolvedButtonUrls = new List<string>();\n\n            // Header\n            if (!string.IsNullOrWhiteSpace(imageUrl) && templateMeta.HasImageHeader)\n            {\n                components.Add(new\n                {\n                    type = \"header\",\n                    parameters = new[]\n                    {\n                new { type = \"image\", image = new { link = imageUrl } }\n            }\n                });\n            }\n\n            // Body\n            if (templateMeta.PlaceholderCount > 0 && templateParams?.Count > 0)\n            {\n                components.Add(new\n                {\n                    type = \"body\",\n                    parameters = templateParams.Select(p => new { type = \"text\", text = p }).ToArray()\n                });\n            }\n\n            // Dynamic URL buttons only\n            if (buttonList == null || buttonList.Count == 0 ||\n                templateMeta.ButtonParams == null || templateMeta.ButtonParams.Count == 0)\n                return components;\n\n            var total = Math.Min(3, Math.Min(buttonList.Count, (templateMeta.ButtonParams?.Count() ?? 0)));\n            var phone = string.IsNullOrWhiteSpace(contact?.PhoneNumber) ? \"\" :\n                        (contact.PhoneNumber.StartsWith(\"+\") ? contact.PhoneNumber : \"+\" + contact.PhoneNumber);\n            var encodedPhone = Uri.EscapeDataString(phone);\n\n            for (int i = 0; i < total; i++)\n            {\n                var meta = templateMeta.ButtonParams[i];\n                var metaParam = meta.ParameterValue?.Trim();\n                var isDynamic = !string.IsNullOrWhiteSpace(metaParam) && metaParam.Contains(\"{{\");\n                if (!isDynamic) continue;\n\n                var btn = buttonList[i];\n                var valueRaw = btn.Value?.Trim();\n                if (string.IsNullOrWhiteSpace(valueRaw)) continue;\n\n                var subtype = (meta.SubType ?? \"url\").ToLowerInvariant();\n\n                // {{n}} substitution ({{1}} := phone)\n                var resolvedDestination = PlaceholderRe.Replace(valueRaw, m =>\n                {\n                    if (!int.TryParse(m.Groups[1].Value, out var n)) return \"\";\n                    if (n == 1) return encodedPhone;\n                    var idx = n - 1;\n                    return (idx >= 0 && idx < templateParams.Count) ? (templateParams[idx] ?? \"\") : \"\";\n                });\n\n                var fullTrackedUrl = _urlBuilderService.BuildTrackedButtonUrl(campaignSendLogId, i, btn.Title, resolvedDestination);\n                var tokenParam = BuildTokenParam(campaignSendLogId, i, btn.Title, resolvedDestination);\n\n                var templateHasAbsoluteBase = LooksLikeAbsoluteBaseUrlWithPlaceholder(metaParam);\n                var valueToSend = templateHasAbsoluteBase ? tokenParam : fullTrackedUrl;\n\n                components.Add(new Dictionary<string, object>\n                {\n                    [\"type\"] = \"button\",\n                    [\"sub_type\"] = subtype,      // \"url\"\n                    [\"index\"] = i.ToString(), // \"0\"/\"1\"/\"2\" for Meta\n                    [\"parameters\"] = new[] { new Dictionary<string, object> { [\"type\"] = \"text\", [\"text\"] = valueToSend } }\n                });\n\n                var providerResolved = ReplaceAllPlaceholdersWith(metaParam ?? \"\", valueToSend);\n                resolvedButtonUrls.Add(providerResolved);\n            }\n\n            return components;\n        }\n\n\n        private List<object> BuildVideoTemplateComponents_Pinnacle(\n            string? videoUrl,\n            List<string> templateParams,\n            List<CampaignButton>? buttonList,\n            TemplateMetadataDto templateMeta,\n            Guid campaignSendLogId,\n            Contact contact)\n        {\n            var components = new List<object>();\n\n            // --- Header (VIDEO) ---\n            // TemplateMetadataDto has no HeaderType/HasVideoHeader ‚Üí emit header when URL is present.\n            if (!string.IsNullOrWhiteSpace(videoUrl))\n            {\n                components.Add(new\n                {\n                    type = \"header\",\n                    parameters = new object[]\n                    {\n                new { type = \"video\", video = new { link = videoUrl } }\n                    }\n                });\n            }\n\n            // --- Body ---\n            var bodyCount = templateMeta?.PlaceholderCount ?? 0;\n            if (templateParams != null && templateParams.Count > 0 && bodyCount > 0)\n            {\n                components.Add(new\n                {\n                    type = \"body\",\n                    parameters = templateParams.Select(p => new { type = \"text\", text = p ?? string.Empty }).ToArray()\n                });\n            }\n\n            // --- Buttons (URL buttons only; indexes 0..2) ---\n            if (buttonList != null && buttonList.Count > 0)\n            {\n                components.AddRange(BuildPinnacleUrlButtons(buttonList));\n            }\n\n            return components;\n        }\n\n        // Works with either CampaignButton (Type/Value) or CampaignButtonDto (ButtonType/TargetUrl).\n        private static IEnumerable<object> BuildPinnacleUrlButtons(IEnumerable<object> rawButtons)\n        {\n            // keep incoming order; cap at 3\n            var ordered = (rawButtons ?? Enumerable.Empty<object>()).Take(3).ToList();\n            var n = ordered is ICollection<object> col ? col.Count : ordered.Count();\n\n            for (int i = 0; i < n; i++)\n            {\n                var b = ordered[i];\n\n                // Try to read \"Type\" or \"ButtonType\"\n                var typeProp = b.GetType().GetProperty(\"Type\") ?? b.GetType().GetProperty(\"ButtonType\");\n                var typeVal = (typeProp?.GetValue(b) as string)?.Trim().ToLowerInvariant() ?? \"url\";\n                if (typeVal != \"url\") continue;\n\n                // Try to read \"Value\" (CampaignButton) or \"TargetUrl\" (CampaignButtonDto)\n                var valueProp = b.GetType().GetProperty(\"Value\") ?? b.GetType().GetProperty(\"TargetUrl\");\n                var paramText = (valueProp?.GetValue(b) as string) ?? string.Empty;\n\n                // If there is a per-recipient URL param, include it; otherwise emit static URL button (no parameters).\n                if (!string.IsNullOrWhiteSpace(paramText))\n                {\n                    yield return new\n                    {\n                        type = \"button\",\n                        sub_type = \"url\",\n                        index = i, // 0-based\n                        parameters = new object[]\n                        {\n                    new { type = \"text\", text = paramText }\n                        }\n                    };\n                }\n                else\n                {\n                    yield return new\n                    {\n                        type = \"button\",\n                        sub_type = \"url\",\n                        index = i\n                    };\n                }\n            }\n        }\n\n        private static List<object> BuildVideoTemplateComponents_Meta(\n                string? videoUrl,\n                List<string>? templateParams,\n                List<CampaignButtonDto>? buttonParams,\n                TemplateMetadataDto? templateMeta)\n        {\n            var components = new List<object>();\n\n            // We‚Äôre in the VIDEO sender path, so add header only if a URL is present.\n            if (!string.IsNullOrWhiteSpace(videoUrl))\n            {\n                components.Add(new\n                {\n                    type = \"header\",\n                    parameters = new object[]\n                    {\n                new { type = \"video\", video = new { link = videoUrl } }\n                    }\n                });\n            }\n\n            // Body placeholders: use meta.PlaceholderCount if available, otherwise list length.\n            var bodyCount = templateMeta?.PlaceholderCount ?? templateParams?.Count ?? 0;\n            if (bodyCount > 0 && (templateParams?.Count ?? 0) > 0)\n            {\n                components.Add(new\n                {\n                    type = \"body\",\n                    parameters = templateParams!.Select(p => new { type = \"text\", text = p ?? string.Empty }).ToArray()\n                });\n            }\n\n            // Buttons (URL buttons only). See helper below.\n            if (buttonParams != null && buttonParams.Count > 0)\n            {\n                components.AddRange(BuildMetaTemplateButtons(buttonParams, templateMeta));\n            }\n\n            return components;\n        }\n\n        private static IEnumerable<object> BuildMetaTemplateButtons(\n            List<CampaignButtonDto> buttons,\n            TemplateMetadataDto? templateMeta)   // meta unused here; kept for future expansion\n        {\n            // Keep incoming order; cap at 3\n            var ordered = (buttons ?? new List<CampaignButtonDto>())\n                .Take(3)\n                .ToList();\n\n            // Avoid Count ambiguity by caching n\n            int n = ordered is ICollection<CampaignButtonDto> col ? col.Count : ordered.Count();\n\n            for (int i = 0; i < n; i++)\n            {\n                var b = ordered[i];\n\n                // Only URL buttons are supported for parameterized Meta buttons\n                var isUrl = string.Equals(b?.ButtonType, \"url\", StringComparison.OrdinalIgnoreCase);\n                if (!isUrl) continue;\n\n                // If we have a per-recipient param (TargetUrl), include a parameter; else emit static button\n                var paramText = b?.TargetUrl ?? string.Empty;\n                var needsParam = !string.IsNullOrWhiteSpace(paramText);\n\n                if (needsParam)\n                {\n                    yield return new\n                    {\n                        type = \"button\",\n                        sub_type = \"url\",\n                        index = i, // Meta uses 0-based indexes\n                        parameters = new object[]\n                        {\n                    new { type = \"text\", text = paramText }\n                        }\n                    };\n                }\n                else\n                {\n                    yield return new\n                    {\n                        type = \"button\",\n                        sub_type = \"url\",\n                        index = i\n                    };\n                }\n            }\n        }\n\n\n        public async Task<List<FlowListItemDto>> GetAvailableFlowsAsync(Guid businessId, bool onlyPublished = true)\n        {\n            return await _context.CTAFlowConfigs\n                .AsNoTracking()\n                .Where(f => f.BusinessId == businessId && f.IsActive && (!onlyPublished || f.IsPublished))\n                .OrderByDescending(f => f.UpdatedAt)\n                .Select(f => new FlowListItemDto\n                {\n                    Id = f.Id,\n                    FlowName = f.FlowName,\n                    IsPublished = f.IsPublished\n                })\n                .ToListAsync();\n        }\n        // ===================== DRY RUN (Step 2.3) =====================\n\n        public async Task<CampaignDryRunResponseDto> DryRunTemplateCampaignAsync(Guid campaignId, int maxRecipients = 20)\n        {\n            var resp = new CampaignDryRunResponseDto { CampaignId = campaignId };\n\n            // Load campaign + recipients (+Contact +AudienceMember) + buttons\n            var campaign = await _context.Campaigns\n                .Include(c => c.Recipients).ThenInclude(r => r.Contact)\n                .Include(c => c.Recipients).ThenInclude(r => r.AudienceMember)\n                .Include(c => c.MultiButtons)\n                .FirstOrDefaultAsync(c => c.Id == campaignId && !c.IsDeleted);\n\n            if (campaign == null)\n            {\n                resp.Notes.Add(\"Campaign not found.\");\n                return resp;\n            }\n\n            resp.CampaignType = campaign.CampaignType ?? \"text\";\n\n            // Resolve entry template name from flow if present, else fall back\n            var (_, entryTemplate) = await ResolveFlowEntryAsync(campaign.BusinessId, campaign.CTAFlowConfigId);\n            var templateName = !string.IsNullOrWhiteSpace(entryTemplate)\n                ? entryTemplate!\n                : (campaign.TemplateId ?? campaign.MessageTemplate ?? \"\");\n\n            if (string.IsNullOrWhiteSpace(templateName))\n            {\n                resp.Notes.Add(\"Template name is missing.\");\n                return resp;\n            }\n\n            // Fetch provider template metadata once (language, placeholders, button schema)\n            var templateMeta = await _templateFetcherService.GetTemplateByNameAsync(\n                campaign.BusinessId, templateName, includeButtons: true);\n\n            resp.TemplateName = templateName;\n\n            if (templateMeta == null)\n            {\n                resp.Notes.Add($\"Template metadata not found for business. Name='{templateName}'.\");\n                return resp;\n            }\n\n            resp.Language = (templateMeta.Language ?? \"\").Trim();\n            resp.HasHeaderMedia = templateMeta.HasImageHeader;\n\n            if (string.IsNullOrWhiteSpace(resp.Language))\n                resp.Notes.Add(\"Template language is not specified on metadata.\");\n\n            // Ensure non-null param list for builders (snapshot provided params)\n            var providedParams = TemplateParameterHelper.ParseTemplateParams(campaign.TemplateParameters)\n                                 ?? new List<string>();\n\n            resp.RequiredPlaceholders = Math.Max(0, templateMeta.PlaceholderCount);\n            resp.ProvidedPlaceholders = providedParams.Count;\n\n            if (resp.RequiredPlaceholders != resp.ProvidedPlaceholders)\n                resp.Notes.Add($\"Placeholder mismatch: template requires {resp.RequiredPlaceholders}, provided {resp.ProvidedPlaceholders}. Consider re-snapshotting parameters.\");\n\n            // Dynamic URL button check (template expects params) vs campaign button values\n            var templButtons = templateMeta.ButtonParams ?? new List<ButtonMetadataDto>();\n            bool templateHasDynamicUrl = templButtons.Any(b =>\n                string.Equals(b.SubType ?? \"url\", \"url\", StringComparison.OrdinalIgnoreCase) &&\n                !string.IsNullOrWhiteSpace(b.ParameterValue) &&\n                b.ParameterValue!.Contains(\"{{\"));\n\n            if (templateHasDynamicUrl)\n            {\n                var hasCampaignUrlValues = (campaign.MultiButtons ?? new List<CampaignButton>())\n                    .Any(cb => !string.IsNullOrWhiteSpace(cb.Value));\n                if (!hasCampaignUrlValues)\n                    resp.Notes.Add(\"Template defines dynamic URL button(s) with placeholders, but campaign has no URL button values configured.\");\n            }\n\n            // Provider normalization for preview\n            var provider = (campaign.Provider ?? \"META_CLOUD\").Trim().ToUpperInvariant();\n            if (provider != \"PINNACLE\" && provider != \"META_CLOUD\")\n            {\n                resp.Notes.Add($\"Invalid provider on campaign: '{campaign.Provider}'. Dry run will assume META_CLOUD.\");\n                provider = \"META_CLOUD\";\n            }\n\n            // Slice some recipients (prefer latest activity; CreatedAt is not on CampaignRecipient)\n            var recipients = (campaign.Recipients ?? new List<CampaignRecipient>())\n     .OrderByDescending(r => (DateTime?)r.UpdatedAt\n                              ?? r.MaterializedAt\n                              ?? r.SentAt\n                              ?? DateTime.MinValue)\n     .Take(Math.Clamp(maxRecipients, 1, 200))\n     .ToList();\n\n            resp.RecipientsConsidered = recipients.Count;\n\n            // Helper: resolve a phone for a recipient\n            static string? ResolveRecipientPhone(CampaignRecipient r) =>\n                r?.Contact?.PhoneNumber ?? r?.AudienceMember?.PhoneE164 ?? r?.AudienceMember?.PhoneRaw;\n\n            int okCount = 0, errCount = 0;\n\n            foreach (var r in recipients)\n            {\n                var phoneResolved = ResolveRecipientPhone(r) ?? \"\";\n                var contactName = r.Contact?.Name ?? r.AudienceMember?.Name;\n\n                var one = new CampaignDryRunRecipientResultDto\n                {\n                    ContactId = r.ContactId,\n                    ContactName = contactName,\n                    PhoneNumber = phoneResolved\n                };\n\n                // Phone checks (presence + basic shape)\n                var phone = (one.PhoneNumber ?? string.Empty).Trim();\n                if (string.IsNullOrEmpty(phone))\n                {\n                    one.Errors.Add(\"Recipient phone missing (no Contact and no AudienceMember phone).\");\n                }\n                else if (!Regex.IsMatch(phone, @\"^\\+?\\d{8,15}$\"))\n                {\n                    one.Warnings.Add(\"Recipient phone may be invalid (basic format check failed).\");\n                }\n\n                try\n                {\n                    // Always synthesize a contact to avoid null derefs in builders\n                    var contactForTemplating = r.Contact ?? new Contact\n                    {\n                        Id = Guid.Empty,\n                        BusinessId = campaign.BusinessId,\n                        PhoneNumber = phoneResolved,\n                        Name = contactName ?? \"Customer\"\n                    };\n\n                    // Buttons ordered like send path: by Position then original index; limit 3\n                    var buttons = (campaign.MultiButtons ?? new List<CampaignButton>())\n                        .Select((b, idx) => new { Btn = b, idx })\n                        .OrderBy(x => (int?)x.Btn.Position ?? int.MaxValue)\n                        .ThenBy(x => x.idx)\n                        .Select(x => x.Btn)\n                        .Take(3)\n                        .ToList();\n\n                    // Build components for preview (match send path) ‚Äî single call, discard out URLs\n                    List<object> components;\n                    var isImage = (campaign.CampaignType ?? \"text\")\n                        .Equals(\"image\", StringComparison.OrdinalIgnoreCase);\n\n                    if (isImage)\n                    {\n                        components = (provider == \"PINNACLE\")\n                            ? BuildImageTemplateComponents_Pinnacle(\n                                campaign.ImageUrl, providedParams, buttons, templateMeta, Guid.NewGuid(), contactForTemplating, out _)\n                            : BuildImageTemplateComponents_Meta(\n                                campaign.ImageUrl, providedParams, buttons, templateMeta, Guid.NewGuid(), contactForTemplating, out _);\n                    }\n                    else\n                    {\n                        components = (provider == \"PINNACLE\")\n                            ? BuildTextTemplateComponents_Pinnacle(\n                                providedParams, buttons, templateMeta, Guid.NewGuid(), contactForTemplating, out _)\n                            : BuildTextTemplateComponents_Meta(\n                                providedParams, buttons, templateMeta, Guid.NewGuid(), contactForTemplating, out _);\n                    }\n\n                    // Additional validations like the send path: blank required params\n                    if (templateMeta.PlaceholderCount > 0 &&\n                        (providedParams.Count < templateMeta.PlaceholderCount ||\n                         providedParams.Take(templateMeta.PlaceholderCount).Any(string.IsNullOrWhiteSpace)))\n                    {\n                        one.Errors.Add($\"Missing body parameter(s): template requires {templateMeta.PlaceholderCount}, provided {providedParams.Count} (or some blank).\");\n                    }\n\n                    one.ProviderComponents = components;\n                    one.WouldSend = one.Errors.Count == 0;\n                    if (one.WouldSend) okCount++; else errCount++;\n                }\n                catch (Exception ex)\n                {\n                    one.Errors.Add(ex.Message);\n                    one.WouldSend = false;\n                    errCount++;\n                }\n\n                resp.Results.Add(one);\n            }\n\n            resp.WouldSendCount = okCount;\n            resp.ErrorCount = errCount;\n\n            // Billability (best-effort)\n            resp.EstimatedChargeable = true;\n            resp.EstimatedConversationCategory = \"template_outbound\";\n            if (!resp.Notes.Any(n => n.Contains(\"Template messages are typically chargeable\")))\n                resp.Notes.Add(\"Estimation: Template messages are typically chargeable and start a new conversation unless covered by free-entry flows.\");\n\n            return resp;\n        }\n\n        private static List<CampaignButtonDto> MapButtonVarsToButtonDtos(Dictionary<string, string>? vars)\n        {\n            var list = new List<CampaignButtonDto>();\n            if (vars == null || vars.Count == 0) return list;\n\n            // We only care about URL buttons 1..3; take the param text\n            for (var i = 1; i <= 3; i++)\n            {\n                if (vars.TryGetValue($\"button{i}.url_param\", out var param) && !string.IsNullOrWhiteSpace(param))\n                {\n                    list.Add(new CampaignButtonDto\n                    {\n                        ButtonText = $\"Button {i}\",   // optional; purely cosmetic\n                        ButtonType = \"url\",\n                        TargetUrl = param\n                    });\n                }\n            }\n            return list;\n        }\n        private async Task<ResponseResult> SendDocumentTemplateCampaignAsync(Campaign campaign)\n        {\n            var sw = System.Diagnostics.Stopwatch.StartNew();\n            _logger.LogInformation(\"[DocSend] Begin. campaignId={CampaignId}\", campaign.Id);\n\n            // force an IEnumerable ‚Üí List and use a distinct name to avoid symbol collisions\n            var recipientsList = (campaign.Recipients ?? Enumerable.Empty<CampaignRecipient>())\n                    .Where(r =>\n                    !string.IsNullOrWhiteSpace(r.Contact?.PhoneNumber) ||\n                    !string.IsNullOrWhiteSpace(r.AudienceMember?.PhoneE164))\n                         .ToList();\n\n            // Use Any() (robust even if someone shadows Count somewhere)\n            if (!recipientsList.Any())\n                return ResponseResult.ErrorInfo(\"‚ö†Ô∏è No valid recipients with phone numbers.\");\n\n            var templateName = campaign.MessageTemplate;\n            var languageCode = \"en_US\"; // keep consistent with your image/video path\n            var provider = (campaign.Provider ?? \"META\").ToUpperInvariant();\n            var phoneNumberId = campaign.PhoneNumberId;\n\n            // optional static fallback (we don't have Campaign.DocumentUrl in this branch)\n            var staticDocUrl = campaign.ImageUrl;\n\n            var ok = 0; var fail = 0;\n\n            foreach (var r in recipientsList)\n            {\n                var to = r.Contact?.PhoneNumber ?? r.AudienceMember?.PhoneE164 ?? \"\";\n                if (string.IsNullOrWhiteSpace(to)) continue;\n\n                try\n                {\n                    // These helpers were added earlier:\n                    var templateParams = BuildBodyParametersForRecipient(campaign, r);\n                    var buttonVars = BuildButtonParametersForRecipient(campaign, r);\n                    var buttonsDto = MapButtonVarsToButtonDtos(buttonVars);\n                    // Per-recipient doc header; no campaign-level DocumentUrl in this branch\n                    var headerDocUrl = ResolvePerRecipientValue(r, \"header.document_url\") ?? staticDocUrl;\n\n                    var dto = new DocumentTemplateMessageDto\n                    {\n                        BusinessId = campaign.BusinessId,\n                        RecipientNumber = to,\n                        TemplateName = templateName,\n                        LanguageCode = languageCode,\n                        HeaderDocumentUrl = headerDocUrl,\n                        // match your DTO property names exactly ‚Äî use the ones your MessageEngine expects:\n                        Parameters = templateParams,   // or TemplateParameters if that's your DTO\n                        Buttons = buttonsDto,      // or ButtonParameters if that's your DTO\n                        Provider = provider,\n                        PhoneNumberId = phoneNumberId,\n                        CTAFlowConfigId = campaign.CTAFlowConfigId,\n                        TemplateBody = campaign.MessageBody\n                    };\n\n                    var sent = await _messageEngineService.SendDocumentTemplateMessageAsync(dto, campaign.BusinessId);\n                    var success = sent.Success;\n\n                    if (success) ok++; else fail++;\n\n                    await LogSendAsync(campaign, r, to, provider, success, headerDocUrl, \"document\");\n                    _logger.LogInformation(\"[DocSend] to={To} success={Success}\", to, success);\n                }\n                catch (Exception ex)\n                {\n                    fail++;\n                    _logger.LogError(ex, \"[DocSend] failed to={To}\", to);\n                    await LogSendAsync(campaign, r, to, provider, false, staticDocUrl, \"document\", ex.Message);\n                }\n            }\n\n            sw.Stop();\n            var msg = $\"Document campaign finished. Success={ok}, Failed={fail}\";\n            _logger.LogInformation(\"[DocSend] Done. campaignId={CampaignId} {Msg}\", campaign.Id, msg);\n\n            return fail == 0 ? ResponseResult.SuccessInfo(msg) : ResponseResult.ErrorInfo(msg);\n        }\n        private Task LogSendAsync(\n                    Campaign campaign,\n                    CampaignRecipient recipient,\n                    string to, string provider,\n                    bool success, string? headerUrl,\n                    string channel, string? error = null)\n        {\n            _logger.LogInformation(\n                \"[SendLog] campaignId={CampaignId} to={To} provider={Provider} channel={Channel} success={Success} headerUrl={HeaderUrl} error={Error}\",\n                campaign.Id, to, provider, channel, success, headerUrl, error);\n\n            // If/when you have a CampaignSendLogs table, insert there instead.\n            return Task.CompletedTask;\n        }\n\n        private static string[] ReadResolvedParams(CampaignRecipient r)\n        {\n            var s = r?.ResolvedParametersJson;\n            if (string.IsNullOrWhiteSpace(s)) return Array.Empty<string>();\n            try\n            {\n                return JsonConvert.DeserializeObject<string[]>(s) ?? Array.Empty<string>();\n            }\n            catch\n            {\n                return Array.Empty<string>();\n            }\n        }\n\n        private static Dictionary<string, string> ReadResolvedButtonVars(CampaignRecipient r)\n        {\n            var s = r?.ResolvedButtonUrlsJson;\n            var dict = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n            if (string.IsNullOrWhiteSpace(s)) return dict;\n            try\n            {\n                return JsonConvert.DeserializeObject<Dictionary<string, string>>(s)\n                       ?? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n            }\n            catch\n            {\n                return dict;\n            }\n        }\n\n        private static string? TryGetHeaderMedia(Dictionary<string, string> vars, params string[] keys)\n        {\n            foreach (var k in keys)\n                if (!string.IsNullOrWhiteSpace(k) && vars.TryGetValue(k, out var v) && !string.IsNullOrWhiteSpace(v))\n                    return v;\n            return null;\n        }\n\n        public Task<object> SendVideoTemplateMessageAsync(VideoTemplateMessageDto dto, Guid businessId)\n        {\n            throw new NotImplementedException();\n        }\n\n        public async Task<bool> CheckNameAvailableAsync(Guid businessId, string name)\n        {\n            var exists = await _context.Campaigns\n                .AsNoTracking()\n                .AnyAsync(c => c.BusinessId == businessId && c.Name == name);\n            return !exists;\n        }\n\n        public async Task RescheduleAsync(Guid businessId, Guid campaignId, DateTime newUtcTime)\n        {\n            var now = DateTime.UtcNow;\n            if (newUtcTime <= now) throw new InvalidOperationException(\"New time must be in the future (UTC).\");\n\n            var c = await _context.Campaigns.FirstOrDefaultAsync(x => x.Id == campaignId && x.BusinessId == businessId);\n            if (c == null) throw new KeyNotFoundException(\"Campaign not found.\");\n\n            c.ScheduledAt = newUtcTime;\n            c.Status = \"Queued\"; // UI can show as ‚ÄúScheduled‚Äù\n            c.UpdatedAt = now;\n\n            var job = await _context.OutboundCampaignJobs\n                .FirstOrDefaultAsync(j => j.CampaignId == campaignId && j.Status == \"queued\");\n\n            if (job != null)\n            {\n                job.NextAttemptAt = newUtcTime;\n                job.UpdatedAt = now;\n            }\n            else\n            {\n                await _context.OutboundCampaignJobs.AddAsync(new OutboundCampaignJob\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    CampaignId = campaignId,\n                    Status = \"queued\",\n                    Attempt = 0,\n                    MaxAttempts = 5,\n                    NextAttemptAt = newUtcTime,\n                    CreatedAt = now,\n                    UpdatedAt = now\n                });\n            }\n\n            await _context.SaveChangesAsync();\n        }\n\n        public async Task EnqueueNowAsync(Guid businessId, Guid campaignId)\n        {\n            var now = DateTime.UtcNow;\n\n            var c = await _context.Campaigns.FirstOrDefaultAsync(x => x.Id == campaignId && x.BusinessId == businessId);\n            if (c == null) throw new KeyNotFoundException(\"Campaign not found.\");\n\n            var job = await _context.OutboundCampaignJobs\n                .FirstOrDefaultAsync(j => j.CampaignId == campaignId && j.Status == \"queued\");\n\n            if (job == null)\n            {\n                job = new OutboundCampaignJob\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    CampaignId = campaignId,\n                    Status = \"queued\",\n                    Attempt = 0,\n                    MaxAttempts = 5,\n                    CreatedAt = now,\n                };\n                await _context.OutboundCampaignJobs.AddAsync(job);\n            }\n            job.NextAttemptAt = now;\n            job.UpdatedAt = now;\n\n            c.ScheduledAt = null;\n            c.Status = \"Queued\";\n            c.UpdatedAt = now;\n\n            await _context.SaveChangesAsync();\n        }\n\n        public async Task CancelScheduleAsync(Guid businessId, Guid campaignId)\n        {\n            var now = DateTime.UtcNow;\n\n            var c = await _context.Campaigns.FirstOrDefaultAsync(x => x.Id == campaignId && x.BusinessId == businessId);\n            if (c == null) throw new KeyNotFoundException(\"Campaign not found.\");\n\n            var job = await _context.OutboundCampaignJobs\n                .FirstOrDefaultAsync(j => j.CampaignId == campaignId && j.Status == \"queued\");\n\n            if (job != null)\n            {\n                job.Status = \"canceled\";\n                job.UpdatedAt = now;\n            }\n\n            c.ScheduledAt = null;\n            c.Status = \"Draft\";\n            c.UpdatedAt = now;\n\n            await _context.SaveChangesAsync();\n        }\n        public async Task<CampaignUsageDto?> GetCampaignUsageAsync(Guid businessId, Guid campaignId)\n        {\n            // Base campaign (scoped to business & not deleted)\n            var baseRow = await _context.Campaigns\n                .AsNoTracking()\n                .Where(c => c.Id == campaignId && c.BusinessId == businessId && !c.IsDeleted)\n                .Select(c => new\n                {\n                    c.Id,\n                    c.BusinessId,\n                    c.Name,\n                    c.Status,\n                    c.CreatedAt,\n                    c.ScheduledAt,\n                    c.CTAFlowConfigId\n                })\n                .FirstOrDefaultAsync();\n\n            if (baseRow == null) return null;\n\n            var statusNorm = (baseRow.Status ?? string.Empty).Trim().ToUpperInvariant();\n            if (string.IsNullOrWhiteSpace(statusNorm)) statusNorm = \"DRAFT\";\n\n            // Counts\n            var recipientsCount = await _context.CampaignRecipients\n                .AsNoTracking()\n                .Where(r => r.CampaignId == campaignId)\n                .CountAsync();\n\n            var queuedJobsCount = await _context.OutboundCampaignJobs\n                .AsNoTracking()\n                .Where(j => j.CampaignId == campaignId)\n                .CountAsync();\n\n            var sendLogsCount = await _context.CampaignSendLogs\n                .AsNoTracking()\n                .Where(l => l.CampaignId == campaignId)\n                .CountAsync();\n\n            // Compute FirstSentAt from logs (since Campaign has no FirstSentAt column)\n            var firstSentAt = await _context.CampaignSendLogs\n                .AsNoTracking()\n                .Where(l => l.CampaignId == campaignId)\n                .OrderBy(l => l.SentAt ?? l.CreatedAt) // prefer SentAt if present, else CreatedAt\n                .Select(l => (DateTime?)(l.SentAt ?? l.CreatedAt))\n                .FirstOrDefaultAsync();\n\n            return new CampaignUsageDto\n            {\n                CampaignId = baseRow.Id,\n                Name = baseRow.Name,\n                Status = statusNorm,                  // string, normalized\n                Recipients = recipientsCount,             // int\n                QueuedJobs = queuedJobsCount,             // int\n                SendLogs = sendLogsCount,               // int\n                HasFlow = baseRow.CTAFlowConfigId.HasValue,\n                FlowId = baseRow.CTAFlowConfigId,\n                CreatedAt = baseRow.CreatedAt,           // DateTime?\n                ScheduledAt = baseRow.ScheduledAt,         // DateTime?\n                FirstSentAt = firstSentAt                  // DateTime? (from logs)\n            };\n        }\n\n        private async Task EnqueueOutboundJobsAsync(\n           Campaign campaign,\n           string provider,\n           string mediaType,\n           string templateName,\n           string languageCode,\n           string? phoneNumberId,\n           IEnumerable<(CampaignRecipient r, string paramsJson, string btnsJson, string? headerUrl, string idemKey)> items,\n           CancellationToken ct = default)\n        {\n            const int batchSize = 500;\n            var buffer = new List<OutboundMessageJob>(batchSize);\n            var now = DateTime.UtcNow;\n\n            foreach (var it in items)\n            {\n                buffer.Add(new OutboundMessageJob\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = campaign.BusinessId,\n                    CampaignId = campaign.Id,\n                    RecipientId = it.r.Id,\n                    Provider = (provider ?? string.Empty).Trim(),\n                    MediaType = mediaType,\n                    TemplateName = templateName,\n                    LanguageCode = languageCode,\n                    PhoneNumberId = phoneNumberId,\n                    ResolvedParamsJson = it.paramsJson,\n                    ResolvedButtonUrlsJson = it.btnsJson,\n                    HeaderMediaUrl = it.headerUrl,\n                    MessageBody = campaign.MessageBody,\n                    // ‚úÖ Allow repeats ‚Äî do not use idempotency for campaign sends\n                    IdempotencyKey = null,\n                    Status = \"Pending\",\n                    Attempt = 0,\n                    CreatedAt = now,\n                    NextAttemptAt = now,\n\n                });\n\n                if (buffer.Count >= batchSize)\n                {\n                    _context.OutboundMessageJobs.AddRange(buffer);\n                    await _context.SaveChangesAsync(ct);\n                    buffer.Clear();\n                }\n            }\n\n            if (buffer.Count > 0)\n            {\n                _context.OutboundMessageJobs.AddRange(buffer);\n                await _context.SaveChangesAsync(ct);\n                buffer.Clear();\n            }\n        }\n\n\n\n    }\n    #endregion\n}\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/CsvBatchService.cs",
      "sha256": "e384bad82c7e9ccd676f053de057e91a5d3b5b41c0f189477d35952ee8d72c1c",
      "language": "csharp",
      "size": 57445,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing xbytechat.api;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing xbytechat.api.Features.CampaignModule.Models;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    public class CsvBatchService : ICsvBatchService\n    {\n        private readonly AppDbContext _db;\n\n        public CsvBatchService(AppDbContext db)\n        {\n            _db = db;\n        }\n\n        // ----------------------------\n        // Upload + ingest\n        // ----------------------------\n        public async Task<CsvBatchUploadResultDto> CreateAndIngestAsync(\n            Guid businessId,\n            string fileName,\n            Stream stream,\n            Guid? audienceId = null,\n            Guid? campaignId = null,\n            CancellationToken ct = default)\n        {\n            // If we‚Äôre in a campaign context and no audience was supplied, create one now.\n            Audience? audience = null;\n            if (audienceId is null && campaignId is not null)\n            {\n                var campaignExists = await _db.Campaigns\n                    .AnyAsync(c => c.Id == campaignId && c.BusinessId == businessId, ct);\n\n                if (!campaignExists)\n                    throw new InvalidOperationException(\"Campaign not found for this business.\");\n\n                audience = new Audience\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                  //  CampaignId = campaignId,\n                    Name = Path.GetFileNameWithoutExtension(fileName) + \" (CSV)\",\n                    CreatedAt = DateTime.UtcNow,\n                    IsDeleted = false\n                };\n\n                _db.Audiences.Add(audience);\n                await _db.SaveChangesAsync(ct);\n                audienceId = audience.Id;\n            }\n\n            // 1) Create batch shell\n            var batch = new CsvBatch\n            {\n                Id = Guid.NewGuid(),\n                BusinessId = businessId,\n                AudienceId = audienceId,\n                FileName = fileName,\n                CreatedAt = DateTime.UtcNow,\n                Status = \"ingesting\",\n                RowCount = 0,\n                SkippedCount = 0,\n                HeadersJson = null\n            };\n\n            _db.CsvBatches.Add(batch);\n            await _db.SaveChangesAsync(ct);\n\n            // Keep both sides in sync if we created the audience here.\n            if (audience is not null)\n            {\n                audience.CsvBatchId = batch.Id;\n                await _db.SaveChangesAsync(ct);\n            }\n\n            try\n            {\n                stream.Position = 0;\n                using var reader = new StreamReader(\n                    stream,\n                    Encoding.UTF8,\n                    detectEncodingFromByteOrderMarks: true,\n                    bufferSize: 1024,\n                    leaveOpen: true);\n\n                string? headerLine = await reader.ReadLineAsync();\n                if (string.IsNullOrWhiteSpace(headerLine))\n                {\n                    var headers = new List<string> { \"phone\" };\n                    batch.HeadersJson = JsonSerializer.Serialize(headers);\n                    batch.Status = \"ready\";\n                    await _db.SaveChangesAsync(ct);\n                    if (campaignId.HasValue && batch.AudienceId.HasValue)\n                    {\n                        await UpsertCampaignAttachmentAsync(\n                            businessId: businessId,\n                            campaignId: campaignId.Value,\n                            audienceId: batch.AudienceId.Value,\n                            csvBatchId: batch.Id,\n                            fileName: fileName,\n                            ct: ct);\n                    }\n\n                    Log.Warning(\"CSV had no header line. Created batch {BatchId} with fallback 'phone' header.\", batch.Id);\n\n                    return new CsvBatchUploadResultDto\n                    {\n                        BatchId = batch.Id,\n                        AudienceId = batch.AudienceId,\n                        FileName = batch.FileName ?? string.Empty,\n                        RowCount = 0,\n                        Headers = headers\n                    };\n                }\n\n                var delim = DetectDelimiter(headerLine);\n                var headersParsed = ParseCsvLine(headerLine, delim)\n                    .Select(h => h.Trim())\n                    .Where(h => !string.IsNullOrEmpty(h))\n                    .ToList();\n\n                if (headersParsed.Count == 0)\n                    headersParsed = new List<string> { \"phone\" };\n\n                batch.HeadersJson = JsonSerializer.Serialize(headersParsed);\n                await _db.SaveChangesAsync(ct);\n\n                var rowsBuffer = new List<CsvRow>(capacity: 1024);\n                int rowIndex = 0;\n\n                // Detect the phone column once from header\n                string? phoneHeader =\n                    headersParsed.FirstOrDefault(h =>\n                        PhoneHeaderCandidates.Any(c => c.Equals(h, StringComparison.OrdinalIgnoreCase)))\n                    ?? headersParsed.FirstOrDefault(h => h.Equals(\"phone\", StringComparison.OrdinalIgnoreCase));\n\n                if (phoneHeader == null)\n                {\n                    Log.Warning(\"CsvBatch {BatchId}: no phone-like header found. Headers={Headers}\",\n                        batch.Id, string.Join(\", \", headersParsed));\n                }\n\n                while (!reader.EndOfStream)\n                {\n                    var line = await reader.ReadLineAsync();\n                    if (line is null) break;\n                    if (string.IsNullOrWhiteSpace(line)) continue;\n\n                    var cols = ParseCsvLine(line, delim);\n\n                    var dict = new Dictionary<string, string?>(StringComparer.OrdinalIgnoreCase);\n                    for (int i = 0; i < headersParsed.Count; i++)\n                    {\n                        var key = headersParsed[i];\n                        var val = i < cols.Count ? cols[i]?.Trim() : null;\n                        dict[key] = val;\n                    }\n\n                    // Pull phone value\n                    string? phoneRaw = null;\n                    if (!string.IsNullOrEmpty(phoneHeader))\n                        dict.TryGetValue(phoneHeader, out phoneRaw);\n\n                    // ‚úÖ Canonical phone identity: E.164 digits-only (NO '+')\n                    var phoneE164Digits = PhoneNumberNormalizer.NormalizeToE164Digits(phoneRaw, \"IN\");\n                    var phoneErr = (phoneE164Digits is null && !string.IsNullOrWhiteSpace(phoneRaw))\n                        ? \"Invalid phone (could not normalize to E.164 digits-only).\"\n                        : \"\";\n\n                    rowsBuffer.Add(new CsvRow\n                    {\n                        Id = Guid.NewGuid(),\n                        BusinessId = businessId,\n                        BatchId = batch.Id,\n                        RowIndex = rowIndex++,\n\n                        PhoneRaw = phoneRaw,\n                        PhoneE164 = phoneE164Digits, // ‚úÖ digits-only canonical\n                        ValidationError = (phoneE164Digits is null && !string.IsNullOrWhiteSpace(phoneRaw)) ? phoneErr : null,\n\n                        // Persist entire row as JSON\n                        RowJson = JsonSerializer.Serialize(dict)\n                    });\n\n                    if (rowsBuffer.Count >= 1000)\n                    {\n                        _db.CsvRows.AddRange(rowsBuffer);\n                        await _db.SaveChangesAsync(ct);\n                        rowsBuffer.Clear();\n                    }\n                }\n\n                if (rowsBuffer.Count > 0)\n                {\n                    _db.CsvRows.AddRange(rowsBuffer);\n                    await _db.SaveChangesAsync(ct);\n                }\n\n                batch.RowCount = rowIndex;\n                batch.Status = \"ready\";\n                await _db.SaveChangesAsync(ct);\n\n                // ‚úÖ STEP 3: Promote valid CSV rows into AudienceMembers (only when AudienceId exists)\n                if (batch.AudienceId.HasValue)\n                {\n                    await PromoteRowsToAudienceMembersAsync(\n                        businessId: businessId,\n                        batchId: batch.Id,\n                        audienceId: batch.AudienceId.Value,\n                        ct: ct);\n                }\n\n                // FIX: campaign attachment upsert must run regardless of header branch (when in campaign context).\n                if (campaignId.HasValue && batch.AudienceId.HasValue)\n                {\n                    await UpsertCampaignAttachmentAsync(\n                        businessId: businessId,\n                        campaignId: campaignId.Value,\n                        audienceId: batch.AudienceId.Value,\n                        csvBatchId: batch.Id,\n                        fileName: fileName,\n                        ct: ct);\n                }\n\n                Log.Information(\"CsvBatch {BatchId} ingested: {Rows} rows; headers={HeaderCount}\",\n                    batch.Id, batch.RowCount, headersParsed.Count);\n\n                return new CsvBatchUploadResultDto\n                {\n                    BatchId = batch.Id,\n                    AudienceId = batch.AudienceId,\n                    FileName = batch.FileName ?? string.Empty,\n                    RowCount = batch.RowCount,\n                    Headers = headersParsed\n                };\n            }\n            catch (Exception ex)\n            {\n                batch.Status = \"failed\";\n                batch.ErrorMessage = ex.Message;\n                await _db.SaveChangesAsync(ct);\n                Log.Error(ex, \"CSV ingest failed for batch {BatchId}\", batch.Id);\n                throw;\n            }\n        }\n\n        // ‚úÖ Step 3 implementation\n        // Promote CsvRows -> AudienceMembers (upsert + reactivate soft-deletes)\n        private async Task PromoteRowsToAudienceMembersAsync(\n            Guid businessId,\n            Guid batchId,\n            Guid audienceId,\n            CancellationToken ct)\n        {\n            var now = DateTime.UtcNow;\n\n            // Build a first-seen map per unique phone (so we can keep a representative PhoneRaw)\n            // NOTE: This streams from DB, memory cost = #unique phones (acceptable for MVP).\n            var firstByPhone = new Dictionary<string, string?>(StringComparer.Ordinal);\n            var phoneSet = new HashSet<string>(StringComparer.Ordinal);\n\n            var rowsQuery = _db.CsvRows\n                .AsNoTracking()\n                .Where(r => r.BusinessId == businessId && r.BatchId == batchId && r.PhoneE164 != null && r.PhoneE164 != \"\")\n                .OrderBy(r => r.RowIndex)\n                .Select(r => new { r.PhoneE164, r.PhoneRaw });\n\n            await foreach (var r in rowsQuery.AsAsyncEnumerable().WithCancellation(ct))\n            {\n                var phone = r.PhoneE164!;\n                if (phoneSet.Add(phone))\n                {\n                    firstByPhone[phone] = r.PhoneRaw;\n                }\n            }\n\n            if (phoneSet.Count == 0)\n            {\n                Log.Information(\"CsvBatch {BatchId}: no valid phones to promote to AudienceMembers.\", batchId);\n                return;\n            }\n\n            // Load existing members for this audience (so we can skip duplicates / reactivate)\n            var existing = await _db.Set<AudienceMember>()\n                .Where(m => m.BusinessId == businessId && m.AudienceId == audienceId && m.PhoneE164 != null)\n                .ToListAsync(ct);\n\n            var existingByPhone = existing\n                .Where(m => !string.IsNullOrWhiteSpace(m.PhoneE164))\n                .GroupBy(m => m.PhoneE164!)\n                .ToDictionary(g => g.Key, g => g.First(), StringComparer.Ordinal);\n\n            var toInsert = new List<AudienceMember>();\n\n            foreach (var phone in phoneSet)\n            {\n                if (existingByPhone.TryGetValue(phone, out var m))\n                {\n                    // Reactivate if soft-deleted\n                    if (m.IsDeleted)\n                    {\n                        m.IsDeleted = false;\n                        m.UpdatedAt = now;\n                    }\n\n                    // Keep raw for audit/debug (optional)\n                    if (string.IsNullOrWhiteSpace(m.PhoneRaw))\n                        m.PhoneRaw = firstByPhone.TryGetValue(phone, out var pr) ? pr : null;\n\n                    continue;\n                }\n\n                toInsert.Add(new AudienceMember\n                {\n                    Id = Guid.NewGuid(),\n                    AudienceId = audienceId,\n                    BusinessId = businessId,\n\n                    // CSV members might not be real CRM Contacts yet\n                    ContactId = null,\n                    IsTransientContact = true,\n\n                    Name = null,\n                    Email = null,\n                    PhoneRaw = firstByPhone.TryGetValue(phone, out var raw) ? raw : null,\n                    PhoneE164 = phone,\n\n                    AttributesJson = null,\n                    IsDeleted = false,\n                    CreatedAt = now,\n                    UpdatedAt = now\n                });\n            }\n\n            if (toInsert.Count > 0)\n            {\n                await _db.Set<AudienceMember>().AddRangeAsync(toInsert, ct);\n                await _db.SaveChangesAsync(ct);\n            }\n\n            Log.Information(\n                \"Promoted CsvRows -> AudienceMembers | biz={Biz} audience={AudienceId} batch={BatchId} uniquePhones={Unique} inserted={Inserted}\",\n                businessId, audienceId, batchId, phoneSet.Count, toInsert.Count);\n        }\n\n        // ----------------------------\n        // Batch info\n        // ----------------------------\n        public async Task<CsvBatchInfoDto?> GetBatchAsync(Guid businessId, Guid batchId, CancellationToken ct = default)\n        {\n            var batch = await _db.CsvBatches\n                .AsNoTracking()\n                .FirstOrDefaultAsync(b => b.Id == batchId && b.BusinessId == businessId, ct);\n\n            if (batch == null) return null;\n\n            var headers = SafeParseHeaderArray(batch.HeadersJson);\n\n            return new CsvBatchInfoDto\n            {\n                BatchId = batch.Id,\n                AudienceId = batch.AudienceId,\n                RowCount = batch.RowCount,\n                Headers = headers,\n                CreatedAt = batch.CreatedAt\n            };\n        }\n\n        // ----------------------------\n        // Samples\n        // ----------------------------\n        public async Task<IReadOnlyList<CsvRowSampleDto>> GetSamplesAsync(\n            Guid businessId,\n            Guid batchId,\n            int take = 20,\n            CancellationToken ct = default)\n        {\n            if (take <= 0) take = 20;\n            if (take > 100) take = 100;\n\n            var batch = await _db.CsvBatches\n                .AsNoTracking()\n                .Where(b => b.Id == batchId && b.BusinessId == businessId)\n                .Select(b => new { b.Id, b.HeadersJson, b.RowCount })\n                .FirstOrDefaultAsync(ct);\n\n            if (batch is null)\n                throw new KeyNotFoundException(\"Batch not found.\");\n\n            if (batch.RowCount <= 0)\n                return Array.Empty<CsvRowSampleDto>();\n\n            var headerList = SafeParseHeaderArray(batch.HeadersJson);\n\n            var rows = await _db.CsvRows\n                .AsNoTracking()\n                .Where(r => r.BusinessId == businessId && r.BatchId == batchId)\n                .OrderBy(r => r.RowIndex)\n                .Take(take)\n                .Select(r => new { r.RowIndex, r.DataJson })\n                .ToListAsync(ct);\n\n            var result = new List<CsvRowSampleDto>(rows.Count);\n            foreach (var r in rows)\n            {\n                var dict = SafeParseDict(r.DataJson);\n\n                var ordered = new Dictionary<string, string?>(headerList.Count, StringComparer.OrdinalIgnoreCase);\n                foreach (var h in headerList)\n                {\n                    dict.TryGetValue(h, out var v);\n                    ordered[h] = v;\n                }\n\n                result.Add(new CsvRowSampleDto\n                {\n                    RowIndex = r.RowIndex,\n                    Data = ordered\n                });\n            }\n\n            return result;\n        }\n\n        // ----------------------------\n        // List / Page / Delete / Validate\n        // ----------------------------\n        public async Task<List<CsvBatchListItemDto>> ListBatchesAsync(Guid businessId, int limit = 20, CancellationToken ct = default)\n        {\n            if (limit <= 0) limit = 20;\n            if (limit > 100) limit = 100;\n\n            return await _db.CsvBatches\n                .AsNoTracking()\n                .Where(b => b.BusinessId == businessId)\n                .OrderByDescending(b => b.CreatedAt)\n                .Take(limit)\n                .Select(b => new CsvBatchListItemDto\n                {\n                    BatchId = b.Id,\n                    FileName = b.FileName,\n                    RowCount = b.RowCount,\n                    Status = b.Status,\n                    CreatedAt = b.CreatedAt\n                })\n                .ToListAsync(ct);\n        }\n\n        public async Task<CsvBatchRowsPageDto> GetRowsPageAsync(Guid businessId, Guid batchId, int skip, int take, CancellationToken ct = default)\n        {\n            if (take <= 0) take = 50;\n            if (take > 200) take = 200;\n            if (skip < 0) skip = 0;\n\n            var exists = await _db.CsvBatches.AsNoTracking()\n                .AnyAsync(b => b.Id == batchId && b.BusinessId == businessId, ct);\n            if (!exists) throw new KeyNotFoundException(\"CSV batch not found.\");\n\n            var total = await _db.CsvRows.AsNoTracking()\n                .Where(r => r.BusinessId == businessId && r.BatchId == batchId)\n                .CountAsync(ct);\n\n            var rows = await _db.CsvRows.AsNoTracking()\n                .Where(r => r.BusinessId == businessId && r.BatchId == batchId)\n                .OrderBy(r => r.RowIndex)\n                .Skip(skip)\n                .Take(take)\n                .Select(r => new CsvRowSampleDto\n                {\n                    RowIndex = r.RowIndex,\n                    Data = SafeParseDict(r.DataJson)\n                })\n                .ToListAsync(ct);\n\n            return new CsvBatchRowsPageDto\n            {\n                BatchId = batchId,\n                TotalRows = total,\n                Skip = skip,\n                Take = take,\n                Rows = rows\n            };\n        }\n\n        public async Task<bool> DeleteBatchAsync(Guid businessId, Guid batchId, CancellationToken ct = default)\n        {\n            var batch = await _db.CsvBatches\n                .FirstOrDefaultAsync(b => b.Id == batchId && b.BusinessId == businessId, ct);\n\n            if (batch == null) return false;\n\n            using var tx = await _db.Database.BeginTransactionAsync(ct);\n            try\n            {\n                var rows = _db.CsvRows.Where(r => r.BusinessId == businessId && r.BatchId == batchId);\n                _db.CsvRows.RemoveRange(rows);\n\n                _db.CsvBatches.Remove(batch);\n\n                await _db.SaveChangesAsync(ct);\n                await tx.CommitAsync(ct);\n                return true;\n            }\n            catch\n            {\n                await tx.RollbackAsync(ct);\n                throw;\n            }\n        }\n\n        private static readonly string[] PhoneHeaderCandidates =\n        {\n            \"phone\", \"phone_number\", \"phonenumber\", \"phoneNumber\", \"phone-no\", \"phone_no\",\n            \"mobile\", \"mobile_number\", \"mobilenumber\", \"whatsapp\", \"whatsapp_no\", \"whatsapp_number\"\n        };\n\n        public async Task<CsvBatchValidationResultDto> ValidateAsync(\n            Guid businessId,\n            Guid batchId,\n            CsvBatchValidationRequestDto request,\n            CancellationToken ct = default)\n        {\n            if (request is null) throw new ArgumentNullException(nameof(request));\n            if (request.SampleSize <= 0) request.SampleSize = 20;\n            if (request.SampleSize > 100) request.SampleSize = 100;\n\n            var batch = await _db.CsvBatches.AsNoTracking()\n                .Where(b => b.BusinessId == businessId && b.Id == batchId)\n                .Select(b => new { b.Id, b.HeadersJson, b.RowCount })\n                .FirstOrDefaultAsync(ct);\n\n            if (batch == null) throw new KeyNotFoundException(\"CSV batch not found.\");\n\n            var headers = SafeParseHeaderArray(batch.HeadersJson);\n            var headerSet = new HashSet<string>(headers, StringComparer.OrdinalIgnoreCase);\n\n            var result = new CsvBatchValidationResultDto\n            {\n                BatchId = batchId,\n                TotalRows = batch.RowCount\n            };\n\n            if (request.RequiredHeaders != null && request.RequiredHeaders.Count > 0)\n            {\n                foreach (var req in request.RequiredHeaders)\n                {\n                    if (!headerSet.Contains(req))\n                        result.MissingRequiredHeaders.Add(req);\n                }\n\n                if (result.MissingRequiredHeaders.Count > 0)\n                    result.Errors.Add(\"Required headers are missing.\");\n            }\n\n            var phoneField = request.PhoneField;\n            if (string.IsNullOrWhiteSpace(phoneField))\n                phoneField = PhoneHeaderCandidates.FirstOrDefault(headerSet.Contains);\n\n            result.PhoneField = phoneField;\n\n            if (string.IsNullOrWhiteSpace(phoneField))\n            {\n                result.Errors.Add(\"No phone field provided or detected.\");\n                return result;\n            }\n\n            var seenPhones = new HashSet<string>(StringComparer.Ordinal);\n            var problemSamples = new List<CsvRowSampleDto>();\n\n            var rowsQuery = _db.CsvRows.AsNoTracking()\n                .Where(r => r.BusinessId == businessId && r.BatchId == batchId)\n                .OrderBy(r => r.RowIndex)\n                .Select(r => new { r.RowIndex, r.DataJson });\n\n            await foreach (var row in rowsQuery.AsAsyncEnumerable().WithCancellation(ct))\n            {\n                var dict = SafeParseDict(row.DataJson);\n                dict.TryGetValue(phoneField, out var rawPhone);\n\n                var normalized = PhoneNumberNormalizer.NormalizeToE164Digits(rawPhone, \"IN\");\n                var phoneErr = normalized is null ? \"Invalid phone (could not normalize to E.164 digits-only).\" : \"\";\n\n                if (string.IsNullOrWhiteSpace(normalized))\n                {\n                    result.MissingPhoneCount++;\n\n                    if (problemSamples.Count < request.SampleSize)\n                    {\n                        var dictWithErr = SafeParseDict(row.DataJson);\n                        dictWithErr[\"__phone_error__\"] = phoneErr;\n                        problemSamples.Add(new CsvRowSampleDto { RowIndex = row.RowIndex, Data = dictWithErr });\n                    }\n                    continue;\n                }\n\n                if (request.Deduplicate && !seenPhones.Add(normalized))\n                {\n                    result.DuplicatePhoneCount++;\n\n                    if (problemSamples.Count < request.SampleSize)\n                    {\n                        var dictWithErr = SafeParseDict(row.DataJson);\n                        dictWithErr[\"__phone_error__\"] = \"Duplicate phone after normalization.\";\n                        problemSamples.Add(new CsvRowSampleDto { RowIndex = row.RowIndex, Data = dictWithErr });\n                    }\n                }\n            }\n\n            result.ProblemSamples = problemSamples;\n\n            if (result.MissingPhoneCount > 0)\n                result.Errors.Add(\"Some rows are missing phone numbers.\");\n            if (result.DuplicatePhoneCount > 0)\n                result.Warnings.Add(\"Duplicate phone numbers detected (after normalization).\");\n\n            return result;\n        }\n\n        // ----------------------------\n        // helpers\n        // ----------------------------\n        private static List<string> SafeParseHeaderArray(string? json)\n        {\n            try\n            {\n                return string.IsNullOrWhiteSpace(json)\n                    ? new List<string>()\n                    : (JsonSerializer.Deserialize<List<string>>(json) ?? new List<string>());\n            }\n            catch { return new List<string>(); }\n        }\n\n        private static Dictionary<string, string?> SafeParseDict(string? json)\n        {\n            try\n            {\n                return string.IsNullOrWhiteSpace(json)\n                    ? new Dictionary<string, string?>()\n                    : (JsonSerializer.Deserialize<Dictionary<string, string?>>(json) ??\n                       new Dictionary<string, string?>());\n            }\n            catch { return new Dictionary<string, string?>(); }\n        }\n\n        private static char DetectDelimiter(string headerLine)\n        {\n            var candidates = new[] { ',', ';', '\\t' };\n            var counts = candidates.Select(c => (c, count: headerLine.Count(ch => ch == c))).ToList();\n            var best = counts.OrderByDescending(x => x.count).First();\n            return best.count > 0 ? best.c : ',';\n        }\n\n        private static List<string> ParseCsvLine(string line, char delimiter)\n        {\n            var result = new List<string>();\n            if (line == null) return result;\n\n            var sb = new StringBuilder();\n            bool inQuotes = false;\n\n            for (int i = 0; i < line.Length; i++)\n            {\n                var c = line[i];\n\n                if (inQuotes)\n                {\n                    if (c == '\"')\n                    {\n                        if (i + 1 < line.Length && line[i + 1] == '\"')\n                        {\n                            sb.Append('\"');\n                            i++;\n                        }\n                        else\n                        {\n                            inQuotes = false;\n                        }\n                    }\n                    else\n                    {\n                        sb.Append(c);\n                    }\n                }\n                else\n                {\n                    if (c == delimiter)\n                    {\n                        result.Add(sb.ToString());\n                        sb.Clear();\n                    }\n                    else if (c == '\"')\n                    {\n                        inQuotes = true;\n                    }\n                    else\n                    {\n                        sb.Append(c);\n                    }\n                }\n            }\n\n            result.Add(sb.ToString());\n            return result;\n        }\n\n        private async Task UpsertCampaignAttachmentAsync(\n    Guid businessId,\n    Guid campaignId,\n    Guid audienceId,\n    Guid csvBatchId,\n    string? fileName,\n    CancellationToken ct)\n        {\n            // 1) deactivate current active attachment (if any)\n            var active = await _db.CampaignAudienceAttachments\n                .FirstOrDefaultAsync(x =>\n                    x.BusinessId == businessId &&\n                    x.CampaignId == campaignId &&\n                    x.IsActive, ct);\n\n            if (active != null)\n            {\n                active.IsActive = false;\n                active.DeactivatedAt = DateTime.UtcNow;\n                active.DeactivatedBy ??= \"system\";\n            }\n\n            // 2) create new active attachment\n            var attach = new CampaignAudienceAttachment\n            {\n                Id = Guid.NewGuid(),\n                BusinessId = businessId,\n                CampaignId = campaignId,\n                AudienceId = audienceId,\n                CsvBatchId = csvBatchId,\n                FileName = fileName,\n                IsActive = true,\n                CreatedAt = DateTime.UtcNow\n            };\n\n            _db.CampaignAudienceAttachments.Add(attach);\n\n            await _db.SaveChangesAsync(ct);\n        }\n\n    }\n}\n\n\n\n//using System;\n//using System.Collections.Generic;\n//using System.IO;\n//using System.Linq;\n//using System.Text;\n//using System.Text.Json;\n//using System.Text.RegularExpressions;\n//using System.Threading;\n//using System.Threading.Tasks;\n//using Microsoft.EntityFrameworkCore;\n//using Serilog;\n//using xbytechat.api;\n//using xbytechat.api.Features.CampaignModule.DTOs;\n//using xbytechat.api.Features.CampaignModule.Models;\n//using Microsoft.Extensions.Options;\n//using xbytechat.api.Features.CampaignModule.CountryCodes;\n//namespace xbytechat.api.Features.CampaignModule.Services\n//{\n//    public class CsvBatchService : ICsvBatchService\n//    {\n//        private readonly AppDbContext _db;\n\n//        public CsvBatchService(AppDbContext db)\n//        {\n//            _db = db;\n\n//        }\n\n//        // ----------------------------\n//        // Upload + ingest\n//        // ----------------------------\n//        public async Task<CsvBatchUploadResultDto> CreateAndIngestAsync(\n//        Guid businessId,\n//        string fileName,\n//        Stream stream,\n//        Guid? audienceId = null,\n//        Guid? campaignId = null,\n//        CancellationToken ct = default)\n//        {\n//            // If we‚Äôre in a campaign context and no audience was supplied, create one now.\n//            Audience? audience = null;\n//            if (audienceId is null && campaignId is not null)\n//            {\n//                var campaignExists = await _db.Campaigns\n//                    .AnyAsync(c => c.Id == campaignId && c.BusinessId == businessId, ct);\n//                if (!campaignExists)\n//                    throw new InvalidOperationException(\"Campaign not found for this business.\");\n\n//                audience = new Audience\n//                {\n//                    Id = Guid.NewGuid(),\n//                    BusinessId = businessId,\n//                    CampaignId = campaignId,                  // ‚Üê link to campaign (so delete cascades)\n//                    Name = Path.GetFileNameWithoutExtension(fileName) + \" (CSV)\",\n//                    CreatedAt = DateTime.UtcNow,\n//                    IsDeleted = false\n//                };\n\n//                _db.Audiences.Add(audience);\n//                await _db.SaveChangesAsync(ct);              // get Audience.Id\n//                audienceId = audience.Id;                    // feed it into the batch\n//            }\n\n//            // 1) Create batch shell (now with a guaranteed AudienceId if campaignId was provided)\n//            var batch = new CsvBatch\n//            {\n//                Id = Guid.NewGuid(),\n//                BusinessId = businessId,\n//                AudienceId = audienceId,                     // ‚Üê no longer null for campaign CSVs\n//                FileName = fileName,\n//                CreatedAt = DateTime.UtcNow,\n//                Status = \"ingesting\",\n//                RowCount = 0,\n//                SkippedCount = 0,\n//                HeadersJson = null\n//            };\n\n//            _db.CsvBatches.Add(batch);\n//            await _db.SaveChangesAsync(ct);\n\n//            // Keep both sides in sync if we created the audience here.\n//            if (audience is not null)\n//            {\n//                audience.CsvBatchId = batch.Id;              // ‚Üê your model maps this too\n//                await _db.SaveChangesAsync(ct);\n//            }\n\n//            try\n//            {\n//                // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ your existing parsing logic (unchanged) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n//                stream.Position = 0;\n//                using var reader = new StreamReader(stream, Encoding.UTF8, detectEncodingFromByteOrderMarks: true, bufferSize: 1024, leaveOpen: true);\n\n//                string? headerLine = await reader.ReadLineAsync();\n//                if (string.IsNullOrWhiteSpace(headerLine))\n//                {\n//                    var headers = new List<string> { \"phone\" };\n//                    batch.HeadersJson = JsonSerializer.Serialize(headers);\n//                    batch.Status = \"ready\";\n//                    await _db.SaveChangesAsync(ct);\n\n//                    Log.Warning(\"CSV had no header line. Created batch {BatchId} with fallback 'phone' header.\", batch.Id);\n\n//                    return new CsvBatchUploadResultDto\n//                    {\n//                        BatchId = batch.Id,\n//                        AudienceId = batch.AudienceId,\n//                        FileName = batch.FileName ?? string.Empty,\n//                        RowCount = 0,\n//                        Headers = headers\n//                    };\n//                }\n\n//                var delim = DetectDelimiter(headerLine);\n//                var headersParsed = ParseCsvLine(headerLine, delim)\n//                    .Select(h => h.Trim())\n//                    .Where(h => !string.IsNullOrEmpty(h))\n//                    .ToList();\n\n//                if (headersParsed.Count == 0)\n//                    headersParsed = new List<string> { \"phone\" };\n\n//                //batch.HeadersJson = JsonSerializer.Serialize(headersParsed);\n//                //await _db.SaveChangesAsync(ct);\n\n//                //var rowsBuffer = new List<CsvRow>(capacity: 1024);\n//                //int rowIndex = 0;\n//                batch.HeadersJson = JsonSerializer.Serialize(headersParsed);\n//                await _db.SaveChangesAsync(ct);\n\n//                var rowsBuffer = new List<CsvRow>(capacity: 1024);\n//                int rowIndex = 0;\n\n//                // Detect the phone column once from the header row.\n//                // We try common names; falls back to exact \"phone\" if present.\n//                string? phoneHeader =\n//                    headersParsed.FirstOrDefault(h =>\n//                        PhoneHeaderCandidates.Any(c => c.Equals(h, StringComparison.OrdinalIgnoreCase)))\n//                    ?? headersParsed.FirstOrDefault(h => h.Equals(\"phone\", StringComparison.OrdinalIgnoreCase));\n\n//                if (phoneHeader == null)\n//                {\n//                    Log.Warning(\"CsvBatch {BatchId}: no phone-like header found. Headers={Headers}\",\n//                        batch.Id, string.Join(\", \", headersParsed));\n//                }\n\n//                while (!reader.EndOfStream)\n//                {\n//                    var line = await reader.ReadLineAsync();\n//                    if (line is null) break;\n//                    if (string.IsNullOrWhiteSpace(line)) continue;\n\n//                    var cols = ParseCsvLine(line, delim);\n\n//                    var dict = new Dictionary<string, string?>(StringComparer.OrdinalIgnoreCase);\n//                    for (int i = 0; i < headersParsed.Count; i++)\n//                    {\n//                        var key = headersParsed[i];\n//                        var val = i < cols.Count ? cols[i]?.Trim() : null;\n//                        dict[key] = val;\n//                    }\n\n//                    // Pull phone value (if we detected a phone header)\n//                    string? phoneRaw = null;\n//                    if (!string.IsNullOrEmpty(phoneHeader))\n//                    {\n//                        dict.TryGetValue(phoneHeader, out phoneRaw);\n//                    }\n\n//                    // Normalize using your existing validator (E.164); capture error if any\n//                    string? phoneErr;\n//                    var phoneE164 = NormalizeToE164OrError(phoneRaw, out phoneErr);\n\n//                    // Buffer the row with both raw + normalized phone and the whole row JSON\n//                    rowsBuffer.Add(new CsvRow\n//                    {\n//                        Id = Guid.NewGuid(),\n//                        BusinessId = businessId,\n//                        BatchId = batch.Id,\n//                        RowIndex = rowIndex++,\n\n//                        PhoneRaw = phoneRaw,\n//                        PhoneE164 = phoneE164,\n//                        ValidationError = (phoneE164 is null && !string.IsNullOrWhiteSpace(phoneRaw)) ? phoneErr : null,\n\n//                        // Persist the entire row as JSON (your model maps DataJson -> RowJson)\n//                        RowJson = JsonSerializer.Serialize(dict)\n//                    });\n\n\n//                    if (rowsBuffer.Count >= 1000)\n//                    {\n//                        _db.CsvRows.AddRange(rowsBuffer);\n//                        await _db.SaveChangesAsync(ct);\n//                        rowsBuffer.Clear();\n//                    }\n//                }\n\n//                if (rowsBuffer.Count > 0)\n//                {\n//                    _db.CsvRows.AddRange(rowsBuffer);\n//                    await _db.SaveChangesAsync(ct);\n//                }\n\n//                batch.RowCount = rowIndex;\n//                batch.Status = \"ready\";\n//                await _db.SaveChangesAsync(ct);\n\n//                Log.Information(\"CsvBatch {BatchId} ingested: {Rows} rows; headers={HeaderCount}\", batch.Id, batch.RowCount, headersParsed.Count);\n\n//                return new CsvBatchUploadResultDto\n//                {\n//                    BatchId = batch.Id,\n//                    AudienceId = batch.AudienceId,           // now reliably set for campaign CSVs\n//                    FileName = batch.FileName ?? string.Empty,\n//                    RowCount = batch.RowCount,\n//                    Headers = headersParsed\n//                };\n//            }\n//            catch (Exception ex)\n//            {\n//                batch.Status = \"failed\";\n//                batch.ErrorMessage = ex.Message;\n//                await _db.SaveChangesAsync(ct);\n//                Log.Error(ex, \"CSV ingest failed for batch {BatchId}\", batch.Id);\n//                throw;\n//            }\n//        }\n\n//        // ----------------------------\n//        // Batch info\n//        // ----------------------------\n//        private async Task<CsvBatchUploadResultDto> IngestCoreAsync(\n//            Guid businessId,\n//            string fileName,\n//            Stream stream,\n//            CancellationToken ct)\n//        {\n//            // Minimal ‚Äústage only‚Äù helper (kept in case other code calls it)\n//            var batch = new CsvBatch\n//            {\n//                Id = Guid.NewGuid(),\n//                BusinessId = businessId,\n//                FileName = fileName,\n//                CreatedAt = DateTime.UtcNow,\n//                Status = \"ready\",\n//                HeadersJson = null,\n//                RowCount = 0,\n//                SkippedCount = 0,\n//                ErrorMessage = null\n//            };\n//            _db.CsvBatches.Add(batch);\n//            await _db.SaveChangesAsync(ct);\n\n//            Log.Information(\"CsvBatch {BatchId} staged for business {Biz}\", batch.Id, businessId);\n\n//            return new CsvBatchUploadResultDto\n//            {\n//                BatchId = batch.Id,\n//                AudienceId = null,\n//                FileName = fileName,\n//                RowCount = 0,\n//                Headers = new List<string>(),\n//                Message = \"CSV batch created.\"\n//            };\n//        }\n\n//        public async Task<CsvBatchInfoDto?> GetBatchAsync(Guid businessId, Guid batchId, CancellationToken ct = default)\n//        {\n//            var batch = await _db.CsvBatches\n//                .AsNoTracking()\n//                .FirstOrDefaultAsync(b => b.Id == batchId && b.BusinessId == businessId, ct);\n\n//            if (batch == null) return null;\n\n//            var headers = SafeParseHeaderArray(batch.HeadersJson);\n\n//            return new CsvBatchInfoDto\n//            {\n//                BatchId = batch.Id,\n//                AudienceId = batch.AudienceId,\n//                RowCount = batch.RowCount,\n//                Headers = headers,\n//                CreatedAt = batch.CreatedAt\n//            };\n//        }\n\n//        // ----------------------------\n//        // Samples (single implementation)\n//        // ----------------------------\n//        public async Task<IReadOnlyList<CsvRowSampleDto>> GetSamplesAsync(\n//            Guid businessId,\n//            Guid batchId,\n//            int take = 20,\n//            CancellationToken ct = default)\n//        {\n//            if (take <= 0) take = 20;\n//            if (take > 100) take = 100;\n\n//            var batch = await _db.CsvBatches\n//                .AsNoTracking()\n//                .Where(b => b.Id == batchId && b.BusinessId == businessId)\n//                .Select(b => new { b.Id, b.HeadersJson, b.RowCount })\n//                .FirstOrDefaultAsync(ct);\n\n//            if (batch is null)\n//                throw new KeyNotFoundException(\"Batch not found.\");\n\n//            // If no rows yet, return empty samples gracefully\n//            if (batch.RowCount <= 0)\n//                return Array.Empty<CsvRowSampleDto>();\n\n//            var headerList = SafeParseHeaderArray(batch.HeadersJson);\n\n//            var rows = await _db.CsvRows\n//                .AsNoTracking()\n//                .Where(r => r.BusinessId == businessId && r.BatchId == batchId)\n//                .OrderBy(r => r.RowIndex)\n//                .Take(take)\n//                .Select(r => new { r.RowIndex, r.DataJson })\n//                .ToListAsync(ct);\n\n//            var result = new List<CsvRowSampleDto>(rows.Count);\n//            foreach (var r in rows)\n//            {\n//                var dict = SafeParseDict(r.DataJson);\n\n//                // Ensure consistent header order (fill missing with null)\n//                var ordered = new Dictionary<string, string?>(headerList.Count, StringComparer.OrdinalIgnoreCase);\n//                foreach (var h in headerList)\n//                {\n//                    dict.TryGetValue(h, out var v);\n//                    ordered[h] = v;\n//                }\n\n//                result.Add(new CsvRowSampleDto\n//                {\n//                    RowIndex = r.RowIndex,\n//                    Data = ordered\n//                });\n//            }\n\n//            return result;\n//        }\n\n//        // ----------------------------\n//        // List / Page / Delete / Validate\n//        // ----------------------------\n//        public async Task<List<CsvBatchListItemDto>> ListBatchesAsync(Guid businessId, int limit = 20, CancellationToken ct = default)\n//        {\n//            if (limit <= 0) limit = 20;\n//            if (limit > 100) limit = 100;\n\n//            return await _db.CsvBatches\n//                .AsNoTracking()\n//                .Where(b => b.BusinessId == businessId)\n//                .OrderByDescending(b => b.CreatedAt)\n//                .Take(limit)\n//                .Select(b => new CsvBatchListItemDto\n//                {\n//                    BatchId = b.Id,\n//                    FileName = b.FileName,\n//                    RowCount = b.RowCount,\n//                    Status = b.Status,\n//                    CreatedAt = b.CreatedAt\n//                })\n//                .ToListAsync(ct);\n//        }\n\n//        public async Task<CsvBatchRowsPageDto> GetRowsPageAsync(Guid businessId, Guid batchId, int skip, int take, CancellationToken ct = default)\n//        {\n//            if (take <= 0) take = 50;\n//            if (take > 200) take = 200;\n//            if (skip < 0) skip = 0;\n\n//            var exists = await _db.CsvBatches.AsNoTracking()\n//                .AnyAsync(b => b.Id == batchId && b.BusinessId == businessId, ct);\n//            if (!exists) throw new KeyNotFoundException(\"CSV batch not found.\");\n\n//            var total = await _db.CsvRows.AsNoTracking()\n//                .Where(r => r.BusinessId == businessId && r.BatchId == batchId)\n//                .CountAsync(ct);\n\n//            var rows = await _db.CsvRows.AsNoTracking()\n//                .Where(r => r.BusinessId == businessId && r.BatchId == batchId)\n//                .OrderBy(r => r.RowIndex)\n//                .Skip(skip)\n//                .Take(take)\n//                .Select(r => new CsvRowSampleDto\n//                {\n//                    RowIndex = r.RowIndex,\n//                    Data = SafeParseDict(r.DataJson)\n//                })\n//                .ToListAsync(ct);\n\n//            return new CsvBatchRowsPageDto\n//            {\n//                BatchId = batchId,\n//                TotalRows = total,\n//                Skip = skip,\n//                Take = take,\n//                Rows = rows\n//            };\n//        }\n\n//        public async Task<bool> DeleteBatchAsync(Guid businessId, Guid batchId, CancellationToken ct = default)\n//        {\n//            var batch = await _db.CsvBatches\n//                .FirstOrDefaultAsync(b => b.Id == batchId && b.BusinessId == businessId, ct);\n\n//            if (batch == null) return false;\n\n//            using var tx = await _db.Database.BeginTransactionAsync(ct);\n//            try\n//            {\n//                var rows = _db.CsvRows.Where(r => r.BusinessId == businessId && r.BatchId == batchId);\n//                _db.CsvRows.RemoveRange(rows);\n\n//                _db.CsvBatches.Remove(batch);\n\n//                await _db.SaveChangesAsync(ct);\n//                await tx.CommitAsync(ct);\n//                return true;\n//            }\n//            catch\n//            {\n//                await tx.RollbackAsync(ct);\n//                throw;\n//            }\n//        }\n\n//        private static readonly string[] PhoneHeaderCandidates =\n//        {  \"phone\", \"phone_number\", \"phonenumber\", \"phoneNumber\", \"phone-no\", \"phone_no\",\n//             \"mobile\", \"mobile_number\", \"mobilenumber\", \"whatsapp\", \"whatsapp_no\", \"whatsapp_number\" };\n\n//        public async Task<CsvBatchValidationResultDto> ValidateAsync(\n//            Guid businessId,\n//            Guid batchId,\n//            CsvBatchValidationRequestDto request,\n//            CancellationToken ct = default)\n//        {\n//            if (request is null) throw new ArgumentNullException(nameof(request));\n//            if (request.SampleSize <= 0) request.SampleSize = 20;\n//            if (request.SampleSize > 100) request.SampleSize = 100;\n\n//            var batch = await _db.CsvBatches.AsNoTracking()\n//                .Where(b => b.BusinessId == businessId && b.Id == batchId)\n//                .Select(b => new { b.Id, b.HeadersJson, b.RowCount })\n//                .FirstOrDefaultAsync(ct);\n\n//            if (batch == null) throw new KeyNotFoundException(\"CSV batch not found.\");\n\n//            var headers = SafeParseHeaderArray(batch.HeadersJson);\n//            var headerSet = new HashSet<string>(headers, StringComparer.OrdinalIgnoreCase);\n\n//            var result = new CsvBatchValidationResultDto\n//            {\n//                BatchId = batchId,\n//                TotalRows = batch.RowCount\n//            };\n\n//            // Required headers check\n//            if (request.RequiredHeaders != null && request.RequiredHeaders.Count > 0)\n//            {\n//                foreach (var req in request.RequiredHeaders)\n//                {\n//                    if (!headerSet.Contains(req))\n//                        result.MissingRequiredHeaders.Add(req);\n//                }\n\n//                if (result.MissingRequiredHeaders.Count > 0)\n//                    result.Errors.Add(\"Required headers are missing.\");\n//            }\n\n//            // Determine phone field\n//            var phoneField = request.PhoneField;\n//            if (string.IsNullOrWhiteSpace(phoneField))\n//                phoneField = PhoneHeaderCandidates.FirstOrDefault(headerSet.Contains);\n\n//            result.PhoneField = phoneField;\n\n//            if (string.IsNullOrWhiteSpace(phoneField))\n//            {\n//                result.Errors.Add(\"No phone field provided or detected.\");\n//                return result; // cannot scan rows without a phone column\n//            }\n\n//            // Scan rows for phone presence & duplicates\n//            var seenPhones = new HashSet<string>(StringComparer.Ordinal);\n//            var problemSamples = new List<CsvRowSampleDto>();\n\n//            var rowsQuery = _db.CsvRows.AsNoTracking()\n//                .Where(r => r.BusinessId == businessId && r.BatchId == batchId)\n//                .OrderBy(r => r.RowIndex)\n//                .Select(r => new { r.RowIndex, r.DataJson });\n\n//            await foreach (var row in rowsQuery.AsAsyncEnumerable().WithCancellation(ct))\n//            {\n//                var dict = SafeParseDict(row.DataJson);\n//                dict.TryGetValue(phoneField, out var rawPhone);\n\n//                // var normalized = NormalizePhoneMaybe(rawPhone, request.NormalizePhones);\n//                var normalized = NormalizeToE164OrError(rawPhone, out var phoneErr);\n//                var isProblem = false;\n\n//                if (string.IsNullOrWhiteSpace(normalized))\n//                {\n//                    // failed normalization ‚Üí treat as missing/invalid phone\n//                    result.MissingPhoneCount++;\n//                    isProblem = true;\n//                    if (problemSamples.Count < request.SampleSize)\n//                    {\n//                        // include the error text in the sample row so UI can show why it failed\n//                        var dictWithErr = SafeParseDict(row.DataJson);\n//                        dictWithErr[\"__phone_error__\"] = phoneErr;\n//                        problemSamples.Add(new CsvRowSampleDto { RowIndex = row.RowIndex, Data = dictWithErr });\n//                    }\n//                }\n//                else if (request.Deduplicate && !seenPhones.Add(normalized))\n//                {\n//                    result.DuplicatePhoneCount++;\n//                    isProblem = true;\n//                }\n\n//                if (isProblem && problemSamples.Count < request.SampleSize)\n//                {\n//                    problemSamples.Add(new CsvRowSampleDto\n//                    {\n//                        RowIndex = row.RowIndex,\n//                        Data = dict\n//                    });\n//                }\n//            }\n\n//            result.ProblemSamples = problemSamples;\n\n//            if (result.MissingPhoneCount > 0)\n//                result.Errors.Add(\"Some rows are missing phone numbers.\");\n//            if (result.DuplicatePhoneCount > 0)\n//                result.Warnings.Add(\"Duplicate phone numbers detected (after normalization).\");\n\n//            return result;\n//        }\n\n//        // ----------------------------\n//        // helpers\n//        // ----------------------------\n//        private static List<string> SafeParseHeaderArray(string? json)\n//        {\n//            try\n//            {\n//                return string.IsNullOrWhiteSpace(json)\n//                    ? new List<string>()\n//                    : (JsonSerializer.Deserialize<List<string>>(json) ?? new List<string>());\n//            }\n//            catch { return new List<string>(); }\n//        }\n\n//        private static Dictionary<string, string?> SafeParseDict(string? json)\n//        {\n//            try\n//            {\n//                return string.IsNullOrWhiteSpace(json)\n//                    ? new Dictionary<string, string?>()\n//                    : (JsonSerializer.Deserialize<Dictionary<string, string?>>(json) ??\n//                       new Dictionary<string, string?>());\n//            }\n//            catch { return new Dictionary<string, string?>(); }\n//        }\n\n//        private static char DetectDelimiter(string headerLine)\n//        {\n//            var candidates = new[] { ',', ';', '\\t' };\n//            var counts = candidates.Select(c => (c, count: headerLine.Count(ch => ch == c))).ToList();\n//            var best = counts.OrderByDescending(x => x.count).First();\n//            return best.count > 0 ? best.c : ',';\n//        }\n\n//        /// <summary>\n//        /// CSV parser with delimiter support: handles commas/semicolons/tabs, double quotes,\n//        /// and escaped quotes (\"\"). It does NOT support embedded newlines inside quoted fields.\n//        /// </summary>\n//        private static List<string> ParseCsvLine(string line, char delimiter)\n//        {\n//            var result = new List<string>();\n//            if (line == null) return result;\n\n//            var sb = new StringBuilder();\n//            bool inQuotes = false;\n\n//            for (int i = 0; i < line.Length; i++)\n//            {\n//                var c = line[i];\n\n//                if (inQuotes)\n//                {\n//                    if (c == '\"')\n//                    {\n//                        // Handle escaped quote \"\"\n//                        if (i + 1 < line.Length && line[i + 1] == '\"')\n//                        {\n//                            sb.Append('\"');\n//                            i++;\n//                        }\n//                        else\n//                        {\n//                            inQuotes = false;\n//                        }\n//                    }\n//                    else\n//                    {\n//                        sb.Append(c);\n//                    }\n//                }\n//                else\n//                {\n//                    if (c == delimiter)\n//                    {\n//                        result.Add(sb.ToString());\n//                        sb.Clear();\n//                    }\n//                    else if (c == '\"')\n//                    {\n//                        inQuotes = true;\n//                    }\n//                    else\n//                    {\n//                        sb.Append(c);\n//                    }\n//                }\n//            }\n\n//            result.Add(sb.ToString());\n//            return result;\n//        }\n\n\n//        private static readonly HashSet<string> VALID_CC = new(StringComparer.Ordinal)\n//        {\n//            // 1-digit\n//            \"1\",          // NANP (US/CA)\n//            // 2-digit - common targets\n//            \"20\",\"27\",\"30\",\"31\",\"32\",\"33\",\"34\",\"36\",\"39\",\"40\",\"41\",\"43\",\"44\",\"45\",\"46\",\"47\",\"48\",\"49\",\n//            \"51\",\"52\",\"53\",\"54\",\"55\",\"56\",\"57\",\"58\",\"60\",\"61\",\"62\",\"63\",\"64\",\"65\",\"66\",\n//            \"81\",\"82\",\"84\",\"86\",\"90\",\"91\",\"92\",\"93\",\"94\",\"95\",\"98\",\n//            // 3-digit - GCC & a few others you likely need\n//            \"966\",\"971\"   // SA, AE\n//        };\n\n//        private static string? NormalizeToE164OrError(string? input, out string error)\n//        {\n//            error = \"\";\n//            if (string.IsNullOrWhiteSpace(input)) { error = \"Empty phone.\"; return null; }\n\n//            var s = input.Trim();\n\n//            // Case A: already +E.164\n//            if (s.StartsWith(\"+\", StringComparison.Ordinal))\n//            {\n//                if (!IsE164(s)) { error = \"Must be +E.164: '+' followed by 8‚Äì15 digits.\"; return null; }\n\n//                var noPlus = s.Substring(1);\n//                var cc = ExtractCcByLongestPrefix(noPlus);\n//                if (string.IsNullOrEmpty(cc)) { error = \"Unsupported country code.\"; return null; }\n\n//                // basic NN sanity for a few big markets; keep permissive otherwise\n//                var nn = noPlus.Substring(cc.Length);\n//                if (!PassesBasicNationalLength(cc, nn)) { error = $\"Invalid national length for +{cc}.\"; return null; }\n\n//                return s;\n//            }\n\n//            // Case B: digits only\n//            var digits = new string(s.Where(char.IsDigit).ToArray());\n//            if (digits.Length < 11 || digits.Length > 15)\n//            { error = \"Include country code (11‚Äì15 digits if no '+').\"; return null; }\n\n//            var cc2 = ExtractCcByLongestPrefix(digits);\n//            if (string.IsNullOrEmpty(cc2))\n//            { error = \"Unsupported country code.\"; return null; }\n\n//            var nn2 = digits.Substring(cc2.Length);\n//            if (!PassesBasicNationalLength(cc2, nn2))\n//            { error = $\"Invalid national length for +{cc2}.\"; return null; }\n\n//            return \"+\" + digits;\n//        }\n\n//        private static bool IsE164(string s)\n//        {\n//            if (s.Length < 9 || s.Length > 16) return false; // '+' + 8..15 digits\n//            for (int i = 1; i < s.Length; i++) if (!char.IsDigit(s[i])) return false;\n//            return true;\n//        }\n\n//        private static string ExtractCcByLongestPrefix(string digitsNoPlus)\n//        {\n//            if (digitsNoPlus.Length >= 3 && VALID_CC.Contains(digitsNoPlus[..3])) return digitsNoPlus[..3];\n//            if (digitsNoPlus.Length >= 2 && VALID_CC.Contains(digitsNoPlus[..2])) return digitsNoPlus[..2];\n//            if (digitsNoPlus.Length >= 1 && VALID_CC.Contains(digitsNoPlus[..1])) return digitsNoPlus[..1];\n//            return \"\";\n//        }\n\n\n//        // Pragmatic checks for common markets; keep permissive for others (4..12)\n//        private static bool PassesBasicNationalLength(string cc, string nn)\n//        {\n//            if (cc == \"1\") return nn.Length == 10; // NANP\n//            if (cc == \"91\") return nn.Length == 10; // India\n//            if (cc == \"94\") return nn.Length == 9;  // Sri Lanka\n//            if (cc == \"966\") return nn.Length == 9;  // Saudi Arabia\n//            return nn.Length >= 4 && nn.Length <= 12;\n//        }\n\n//    }\n//}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/CsvExportService.cs",
      "sha256": "98366ed493eba2967478ea12bedd43b2d0c3a355667e89f23db3a6dd734554a9",
      "language": "csharp",
      "size": 7057,
      "content": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Serilog;\nusing xbytechat.api.Features.CampaignModule.Services;\nusing xbytechat.api.Features.CampaignModule.DTOs;\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    public interface ICsvExportService\n    {\n        Task<byte[]> BuildMaterializedCsvAsync(Guid businessId, Guid campaignId, int limit = 200, CancellationToken ct = default);\n        Task<byte[]> BuildDispatchPlanCsvAsync(Guid businessId, Guid campaignId, int limit = 2000, CancellationToken ct = default);\n    }\n\n    /// <summary>\n    /// Small CSV builder for exporting materialized rows and dispatch plans.\n    /// Uses UTF-8 with BOM for Excel friendliness. Escapes fields per RFC4180.\n    /// </summary>\n    public class CsvExportService : ICsvExportService\n    {\n        private readonly ICampaignMaterializationService _materializer;\n        private readonly ICampaignDispatchPlannerService _planner;\n\n        public CsvExportService(\n            ICampaignMaterializationService materializer,\n            ICampaignDispatchPlannerService planner)\n        {\n            _materializer = materializer;\n            _planner = planner;\n        }\n\n        public async Task<byte[]> BuildMaterializedCsvAsync(Guid businessId, Guid campaignId, int limit = 200, CancellationToken ct = default)\n        {\n            var data = await _materializer.MaterializeAsync(businessId, campaignId, limit, ct);\n\n            // Header is dynamic based on placeholder count and button count.\n            // Columns:\n            // RecipientId,ContactId,Phone,Param1..ParamN,Btn1Text,Btn1Url,...,Warnings,Errors\n            var maxParam = data.PlaceholderCount;\n            var maxButtons = data.Rows.Max(r => r.Buttons.Count);\n\n            var sb = new StringBuilder();\n            using var writer = new StringWriter(sb);\n\n            // Write header\n            writer.Write(\"RecipientId,ContactId,Phone\");\n            for (int i = 1; i <= maxParam; i++) writer.Write($\",Param{i}\");\n            for (int b = 1; b <= maxButtons; b++) writer.Write($\",Btn{b}Text,Btn{b}Url\");\n            writer.Write(\",Warnings,Errors\");\n            writer.WriteLine();\n\n            foreach (var row in data.Rows)\n            {\n                WriteCsv(writer, row.RecipientId?.ToString());\n                writer.Write(\",\");\n                WriteCsv(writer, row.ContactId?.ToString());\n                writer.Write(\",\");\n                WriteCsv(writer, row.Phone);\n\n                // Params 1..N (pad missing)\n                for (int i = 1; i <= maxParam; i++)\n                {\n                    writer.Write(\",\");\n                    var val = row.Parameters.FirstOrDefault(p => p.Index == i)?.Value;\n                    WriteCsv(writer, val);\n                }\n\n                // Buttons (pad missing)\n                for (int b = 0; b < maxButtons; b++)\n                {\n                    var btn = b < row.Buttons.Count ? row.Buttons[b] : null;\n                    writer.Write(\",\");\n                    WriteCsv(writer, btn?.ButtonText);\n                    writer.Write(\",\");\n                    WriteCsv(writer, btn?.ResolvedUrl);\n                }\n\n                writer.Write(\",\");\n                WriteCsv(writer, string.Join(\" | \", row.Warnings));\n                writer.Write(\",\");\n                WriteCsv(writer, string.Join(\" | \", row.Errors));\n                writer.WriteLine();\n            }\n\n            // Return as UTF-8 with BOM for Excel compatibility\n            var utf8withBom = new UTF8Encoding(encoderShouldEmitUTF8Identifier: true);\n            return utf8withBom.GetBytes(sb.ToString());\n        }\n\n        public async Task<byte[]> BuildDispatchPlanCsvAsync(Guid businessId, Guid campaignId, int limit = 2000, CancellationToken ct = default)\n        {\n            var plan = await _planner.PlanAsync(businessId, campaignId, limit, ct);\n\n            var sb = new StringBuilder();\n            using var writer = new StringWriter(sb);\n\n            // Plan metadata preface (comment-style rows start with '#')\n            writer.WriteLine($\"# CampaignId,{plan.CampaignId}\");\n            writer.WriteLine($\"# TemplateName,{Escape(plan.TemplateName)}\");\n            writer.WriteLine($\"# Language,{Escape(plan.Language)}\");\n            writer.WriteLine($\"# PlaceholderCount,{plan.PlaceholderCount}\");\n            writer.WriteLine($\"# TotalRecipients,{plan.TotalRecipients}\");\n            writer.WriteLine($\"# ProviderPlan,{Escape(plan.Throttle.Plan)}\");\n            writer.WriteLine($\"# Provider,{Escape(plan.Throttle.Provider)}\");\n            writer.WriteLine($\"# MaxBatchSize,{plan.Throttle.MaxBatchSize}\");\n            writer.WriteLine($\"# MaxPerMinute,{plan.Throttle.MaxPerMinute}\");\n            writer.WriteLine($\"# ComputedBatches,{plan.Throttle.ComputedBatches}\");\n            writer.WriteLine($\"# EstimatedMinutes,{plan.Throttle.EstimatedMinutes}\");\n            if (plan.GlobalWarnings.Any())\n                writer.WriteLine($\"# GlobalWarnings,{Escape(string.Join(\" | \", plan.GlobalWarnings))}\");\n            if (plan.Throttle.Warnings.Any())\n                writer.WriteLine($\"# ThrottleWarnings,{Escape(string.Join(\" | \", plan.Throttle.Warnings))}\");\n\n            writer.WriteLine(); // blank line\n\n            // Batches table header\n            writer.WriteLine(\"BatchNumber,OffsetSeconds,StartIndex,Count,ApproxBytes,Phones,RecipientIds,Notes\");\n\n            foreach (var b in plan.Batches)\n            {\n                WriteCsv(writer, b.BatchNumber.ToString());\n                writer.Write(\",\");\n                WriteCsv(writer, b.OffsetSeconds.ToString());\n                writer.Write(\",\");\n                WriteCsv(writer, b.StartIndex.ToString());\n                writer.Write(\",\");\n                WriteCsv(writer, b.Count.ToString());\n                writer.Write(\",\");\n                WriteCsv(writer, b.ApproxBytes.ToString());\n                writer.Write(\",\");\n                WriteCsv(writer, string.Join(\" \", b.Phones.Select(p => p ?? \"\")));\n                writer.Write(\",\");\n                WriteCsv(writer, string.Join(\" \", b.RecipientIds.Select(id => id?.ToString() ?? \"\")));\n                writer.Write(\",\");\n                WriteCsv(writer, string.Join(\" | \", b.Notes));\n                writer.WriteLine();\n            }\n\n            var utf8withBom = new UTF8Encoding(encoderShouldEmitUTF8Identifier: true);\n            return utf8withBom.GetBytes(sb.ToString());\n        }\n\n        private static void WriteCsv(TextWriter writer, string? value)\n        {\n            writer.Write(Escape(value ?? \"\"));\n        }\n\n        private static string Escape(string input)\n        {\n            // RFC4180-style: quote if contains comma, quote or newline; escape quotes by doubling\n            var needsQuote = input.Contains(',') || input.Contains('\"') || input.Contains('\\n') || input.Contains('\\r');\n            if (!needsQuote) return input;\n            return $\"\\\"{input.Replace(\"\\\"\", \"\\\"\\\"\")}\\\"\";\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/ICampaignAudienceAttachmentService.cs",
      "sha256": "b9ccbfca837478429ebbd9dba1bdcf2520ce82cc03aaa45a16763823dbe44892",
      "language": "csharp",
      "size": 2135,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Http;\nusing xbytechat.api.Features.CampaignModule.DTOs;\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    public interface ICampaignAudienceAttachmentService\n    {\n        Task<CampaignAudienceDto> GetActiveAsync(Guid businessId, Guid campaignId, CancellationToken ct = default);\n        Task<IReadOnlyList<CampaignAudienceHistoryItemDto>> GetHistoryAsync(Guid businessId, Guid campaignId, CancellationToken ct = default);\n\n        /// <summary>\n        /// Replaces the active CSV audience before send. This deactivates the previous attachment (history is preserved),\n        /// rebuilds ONLY CSV-derived recipients (AudienceMemberId != null), and leaves manual recipients intact.\n        /// </summary>\n        Task<CampaignAudienceReplaceResponseDto> ReplaceAsync(\n            Guid businessId,\n            Guid campaignId,\n            IFormFile csvFile,\n            string? audienceName,\n            string actor,\n            CancellationToken ct = default);\n\n        /// <summary>\n        /// Removes/detaches the active CSV audience before send. This deactivates the attachment (history is preserved)\n        /// and deletes ONLY CSV-derived recipients (AudienceMemberId != null).\n        /// </summary>\n        Task<CampaignAudienceRemoveResponseDto> RemoveAsync(\n            Guid businessId,\n            Guid campaignId,\n            string actor,\n            CancellationToken ct = default);\n\n        /// <summary>\n        /// Shared persist path for POST /api/campaigns/{campaignId}/materialize when Persist=true.\n        /// This keeps attachments + CSV-derived recipients aligned with what the user just materialized.\n        /// </summary>\n        Task<CampaignAudienceReplaceResponseDto> ReplaceFromMaterializationAsync(\n            Guid businessId,\n            Guid campaignId,\n            CampaignCsvMaterializeRequestDto request,\n            IReadOnlyList<CsvMaterializedRowDto> materializedRows,\n            string actor,\n            CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/ICampaignDispatcher.cs",
      "sha256": "7ea08b6385a5f9c2861a417d0ba9ed59f386c613614b462ffbaa53ace5cb56e8",
      "language": "csharp",
      "size": 652,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CampaignModule.DTOs;\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    public interface ICampaignDispatcher\n    {\n        /// <summary>\n        /// mode: \"canary\" (use count) or \"full\" (ignore count, select all ready).\n        /// count: when mode=canary, number of recipients to enqueue (default 25).\n        /// </summary>\n        Task<CampaignDispatchResponseDto> DispatchAsync(\n            Guid businessId,\n            Guid campaignId,\n            string mode,\n            int count,\n            CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/ICampaignDryRunService.cs",
      "sha256": "8ee4671e2a7d2ac659e127e72121295904129c5d31e82fad35401dc50f10a717",
      "language": "csharp",
      "size": 662,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CampaignModule.DTOs;\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    /// <summary>\n    /// Validates a campaign for send safety without actually sending any message.\n    /// </summary>\n    public interface ICampaignDryRunService\n    {\n        /// <summary>\n        /// Run dry-run validation for a campaign. Should not mutate state.\n        /// </summary>\n        Task<CampaignDryRunResultDto> ValidateAsync(\n            Guid businessId,\n            Guid campaignId,\n            int limit = 200,\n            CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/ICampaignMaterializationService.cs",
      "sha256": "45174c0e9b318f8f145ffd682ecf042a166872989ec0a9637342c3fe47d8fa6d",
      "language": "csharp",
      "size": 358,
      "content": "using xbytechat.api.Features.CampaignModule.DTOs;\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    public interface ICampaignMaterializationService\n    {\n        Task<CampaignMaterializeResultDto> MaterializeAsync(\n        Guid businessId,\n        Guid campaignId,\n        int limit = 200,\n            CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/ICampaignMaterializer.cs",
      "sha256": "98d32de9d130b65ea77f9381f92fb27bdbd3750a534fc8f6579854bd4201cc94",
      "language": "csharp",
      "size": 479,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CampaignModule.DTOs;\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    public interface ICampaignMaterializer\n    {\n        Task<CampaignCsvMaterializeResponseDto> CreateAsync(\n            Guid businessId,\n            Guid campaignId,\n            CampaignCsvMaterializeRequestDto request,\n            string actor,\n            CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/ICampaignRecipientService.cs",
      "sha256": "5e8fc7101147a1ce4ef9a7aa408f53df15d24e1007bdd060e227ba4346b98e7e",
      "language": "csharp",
      "size": 833,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CampaignModule.DTOs;\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    public interface ICampaignRecipientService\n    {\n        Task<CampaignRecipientDto?> GetByIdAsync(Guid businessId, Guid id);\n        Task<List<CampaignRecipientDto>> GetByCampaignIdAsync(Guid businessId, Guid campaignId);\n\n        Task<bool> UpdateStatusAsync(Guid businessId, Guid recipientId, string newStatus);\n        Task<bool> TrackReplyAsync(Guid businessId, Guid recipientId, string replyText);\n        Task<List<CampaignRecipientDto>> SearchRecipientsAsync(Guid businessId, string? status = null, string? keyword = null);\n\n        Task AssignContactsToCampaignAsync(Guid businessId, Guid campaignId, List<Guid> contactIds);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/ICampaignRetargetService.cs",
      "sha256": "a56b1279013a76edce5098e6fc02cf37a7bae51bcc75d7c5c9641128a0246d5f",
      "language": "csharp",
      "size": 447,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CampaignModule.DTOs;\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    public interface ICampaignRetargetService\n    {\n        Task<RetargetCampaignResponseDto> CreateRetargetCampaignAsync(\n            Guid businessId,\n            RetargetCampaignRequestDto dto,\n            string createdBy,\n            CancellationToken ct);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/ICampaignRetryService.cs",
      "sha256": "77b2d8c8b67c691891ba7e6e1b014af847932714edcd60acfd419c092aa3c4bc",
      "language": "csharp",
      "size": 274,
      "content": "using xbytechat.api.Features.CampaignModule.DTOs;\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    public interface ICampaignRetryService\n    {\n        Task<CampaignRetryResultDto> RetryFailedAsync(Guid businessId, Guid campaignId, int limit = 200);\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/ICampaignService.cs",
      "sha256": "9e06f9bf595c8415ff43f4f1af6bfab07085dcf77d740b06debdc2e2901bef23",
      "language": "csharp",
      "size": 2979,
      "content": "using System;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing xbytechat.api.Shared;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Features.CampaignModule.Models;\nusing xbytechat.api.Features.CRM.Dtos;\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    public interface ICampaignService\n    {\n        /// üÜï Create a new campaign with recipients\n        Task<Guid?> CreateTextCampaignAsync(CampaignCreateDto dto, Guid businessId, string createdBy);\n\n        /// ‚úèÔ∏è Update an existing draft campaign\n        Task<bool> UpdateCampaignAsync(Guid id, CampaignCreateDto dto);\n\n      \n        /// üìã Get all campaigns for the business\n        //Task<List<CampaignSummaryDto>> GetAllCampaignsAsync(Guid businessId);\n\n        /// üìÑ Get paginated campaigns\n        Task<PaginatedResponse<CampaignSummaryDto>> GetPaginatedCampaignsAsync(Guid businessId, PaginatedRequest request);\n        /// üöÄ Trigger campaign send flow (template message to all recipients)\n        Task<bool> SendCampaignAsync(Guid campaignId, string ipAddress, string userAgent);\n        Task<Guid> CreateImageCampaignAsync(Guid businessId, CampaignCreateDto dto, string createdBy);\n        Task<List<CampaignSummaryDto>> GetAllCampaignsAsync(Guid businessId, string? type = null);\n        Task<List<ContactDto>> GetRecipientsByCampaignIdAsync(Guid campaignId, Guid businessId);\n        Task<bool> RemoveRecipientAsync(Guid businessId, Guid campaignId, Guid contactId);\n        Task<CampaignDto?> GetCampaignByIdAsync(Guid campaignId, Guid businessId);\n        Task<bool> AssignContactsToCampaignAsync(Guid campaignId, Guid businessId, List<Guid> contactIds);\n\n        Task<ResponseResult> SendTemplateCampaignAsync(Guid campaignId);\n\n        Task<ResponseResult> SendTemplateCampaignWithTypeDetectionAsync(Guid campaignId, CancellationToken ct = default);\n\n        Task<ResponseResult> SendTextTemplateCampaignAsync(Campaign campaign);\n        Task<ResponseResult> SendImageTemplateCampaignAsync(Campaign campaign);\n\n        Task<List<FlowListItemDto>> GetAvailableFlowsAsync(Guid businessId, bool onlyPublished = true);\n\n        Task<CampaignDryRunResponseDto> DryRunTemplateCampaignAsync(Guid campaignId, int maxRecipients = 20);\n        Task<object> SendVideoTemplateMessageAsync(VideoTemplateMessageDto dto, Guid businessId);\n\n        Task<bool> CheckNameAvailableAsync(Guid businessId, string name);\n        Task RescheduleAsync(Guid businessId, Guid campaignId, DateTime newUtcTime);\n        Task EnqueueNowAsync(Guid businessId, Guid campaignId);\n        Task CancelScheduleAsync(Guid businessId, Guid campaignId);\n        Task<CampaignDeletionResult> DeleteCampaignAsync(\n            Guid businessId,\n            Guid id,\n            CampaignDeletionOptions options,\n            CancellationToken ct = default);\n        Task<CampaignUsageDto?> GetCampaignUsageAsync(Guid businessId, Guid campaignId);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/ICsvBatchService.cs",
      "sha256": "354a34ab57d057ccd0d3fade616e9e149d7e6a5c697c3d81a1d0347999f14d6f",
      "language": "csharp",
      "size": 1601,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CampaignModule.DTOs;\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    public interface ICsvBatchService\n    {\n        //Task<CsvBatchUploadResultDto> CreateAndIngestAsync(\n        //    Guid businessId,\n        //    string fileName,\n        //    Stream stream,\n        //    Guid? audienceId = null,\n        //    CancellationToken ct = default\n        //);\n    \n            Task<CsvBatchUploadResultDto> CreateAndIngestAsync(\n                Guid businessId,\n                string fileName,\n                Stream stream,\n                Guid? audienceId = null,\n                Guid? campaignId = null,\n                CancellationToken ct = default);\n      \n\n        Task<CsvBatchInfoDto?> GetBatchAsync(Guid businessId, Guid batchId, CancellationToken ct = default);\n        Task<IReadOnlyList<CsvRowSampleDto>> GetSamplesAsync(Guid businessId, Guid batchId, int take = 20, CancellationToken ct = default);\n        Task<CsvBatchValidationResultDto> ValidateAsync(Guid businessId, Guid batchId, CsvBatchValidationRequestDto request, CancellationToken ct = default);\n        Task<List<CsvBatchListItemDto>> ListBatchesAsync(Guid businessId, int limit = 20, CancellationToken ct = default);\n        Task<CsvBatchRowsPageDto> GetRowsPageAsync(Guid businessId, Guid batchId, int skip, int take, CancellationToken ct = default);\n        Task<bool> DeleteBatchAsync(Guid businessId, Guid batchId, CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/IMappingSuggestionService.cs",
      "sha256": "010ea9f12699609fa3addd18141bfba7bcf3ec585a43200b86cf3a2f8f0ef038",
      "language": "csharp",
      "size": 641,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    /// <summary>\n    /// Suggests a token->source mapping (\"csv:Header\" or \"static:\") given a campaign and CSV batch.\n    /// Uses Campaign.TemplateParameters if present; otherwise derives tokens from CSV headers.\n    /// </summary>\n    public interface IMappingSuggestionService\n    {\n        Task<Dictionary<string, string>> SuggestAsync(\n            Guid businessId,\n            Guid campaignId,\n            Guid batchId,\n            CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/Interface.cs",
      "sha256": "b499bed78d394052736ab9f463d1f5737462a52f755329e27050b2f72a1b846c",
      "language": "csharp",
      "size": 104,
      "content": "namespace xbytechat.api.Features.CampaignModule.Services\n{\n    public interface Interface\n    {\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/IOutboundCampaignQueueService.cs",
      "sha256": "a085fb2166af4a18a8f3499aa61280313e0c0dbd358fbaa54eb9562e8337fc80",
      "language": "csharp",
      "size": 1044,
      "content": "using System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CampaignModule.Models;\nusing xbytechat.api.Features.Queueing.DTOs;\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    public interface IOutboundCampaignQueueService\n    {\n        Task<Guid> EnqueueAsync(Guid businessId, Guid campaignId, bool forceDuplicate = false);\n        Task<bool> MarkSucceededAsync(Guid jobId);\n        Task<bool> MarkFailedAsync(Guid jobId, string error, bool scheduleRetry = true);\n\n        Task<List<OutboundCampaignJob>> GetJobsForCampaignAsync(Guid businessId, Guid campaignId);\n        Task<OutboundCampaignJob?> GetActiveJobForCampaignAsync(Guid businessId, Guid campaignId);\n        Task<bool> CancelAsync(Guid businessId, Guid jobId);     // set to \"canceled\" (if queued/running)\n        Task<bool> ForceRetryNowAsync(Guid businessId, Guid jobId); // set to \"queued\", NextAttemptAt=now (no attempt++)\n        Task<int> EnqueueBulkAsync(IEnumerable<OutboundCampaignJobCreateDto> jobs, CancellationToken ct = default);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/IVariableMappingService.cs",
      "sha256": "dcf57112809de6e4dc9c3b7957cc9d591c65cace2d51cd24fc0795b6b12b8c5a",
      "language": "csharp",
      "size": 992,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    /// <summary>\n    /// Loads saved variable mappings for a campaign (e.g., token -> CSV header or \"constant:...\").\n    /// Current project does not require this to complete 2.4; this is a seam for future use.\n    /// </summary>\n    public interface IVariableMappingService\n    {\n        /// <returns>\n        /// Dictionary mapping variable token -> source (CSV header name or \"constant:Value\").\n        /// Return an empty dictionary when nothing is saved.\n        /// </returns>\n        Task<Dictionary<string, string>> GetForCampaignAsync(\n            Guid businessId,\n            Guid campaignId,\n            CancellationToken ct = default);\n        Task SaveAsync(\n           Guid businessId,\n           Guid campaignId,\n           Dictionary<string, string> mappings,\n           CancellationToken ct = default);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/MappingSuggestionService.cs",
      "sha256": "e6a82a860c5406f0e22ef3c89577a8c06081e49d21add5f9bc6682c0dc974dd3",
      "language": "csharp",
      "size": 5965,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.Json;\nusing System.Text.RegularExpressions;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api;\nusing xbytechat.api.Features.CampaignModule.Models;\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    /// <summary>\n    /// Heuristics:\n    /// - If Campaign.TemplateParameters is a JSON array of tokens, suggest for those tokens.\n    /// - Else, derive tokens by normalizing CSV headers (lowercase, alnum only, '_' joined).\n    /// - Match by normalized equality/contains; special-case phone names.\n    /// - Unmatched tokens get \"static:\" so UI shows a clear placeholder.\n    /// </summary>\n    public sealed class MappingSuggestionService : IMappingSuggestionService\n    {\n        private readonly AppDbContext _db;\n\n        private static readonly string[] PhoneHeaderCandidates =\n        {\n            \"phone\", \"mobile\", \"whatsapp\", \"msisdn\", \"whatsapp_number\", \"contact\", \"contact_number\"\n        };\n\n        public MappingSuggestionService(AppDbContext db) => _db = db;\n\n        public async Task<Dictionary<string, string>> SuggestAsync(\n            Guid businessId,\n            Guid campaignId,\n            Guid batchId,\n            CancellationToken ct = default)\n        {\n            // Load campaign to read TemplateParameters (if present)\n            var campaign = await _db.Campaigns.AsNoTracking()\n                .Where(c => c.Id == campaignId && c.BusinessId == businessId)\n                .Select(c => new { c.Id, c.BusinessId, c.TemplateParameters })\n                .FirstOrDefaultAsync(ct);\n\n            if (campaign == null) throw new KeyNotFoundException(\"Campaign not found.\");\n\n            // Load batch headers\n            var batch = await _db.CsvBatches.AsNoTracking()\n                .Where(b => b.Id == batchId && b.BusinessId == businessId)\n                .Select(b => new { b.HeadersJson })\n                .FirstOrDefaultAsync(ct);\n\n            if (batch == null) throw new KeyNotFoundException(\"CSV batch not found.\");\n\n            var headers = ParseHeaders(batch.HeadersJson);\n            var normHeaders = headers.ToDictionary(h => Normalize(h), h => h, StringComparer.OrdinalIgnoreCase);\n\n            // Determine tokens\n            var tokens = ParseTemplateTokens(campaign.TemplateParameters);\n            if (tokens.Count == 0)\n            {\n                // Fall back: derive tokens directly from headers\n                tokens = headers.Select(Normalize).Where(s => !string.IsNullOrWhiteSpace(s)).Distinct(StringComparer.OrdinalIgnoreCase).ToList();\n            }\n\n            // Suggestion: token -> source\n            var suggestions = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n\n            foreach (var token in tokens)\n            {\n                var normToken = Normalize(token);\n\n                // 1) direct equality with header\n                if (normHeaders.TryGetValue(normToken, out var exactHeader))\n                {\n                    suggestions[token] = $\"csv:{exactHeader}\";\n                    continue;\n                }\n\n                // 2) phone special-case\n                if (IsPhoneToken(normToken))\n                {\n                    var headerPick = headers.FirstOrDefault(h => PhoneHeaderCandidates.Contains(Normalize(h)));\n                    if (!string.IsNullOrEmpty(headerPick))\n                    {\n                        suggestions[token] = $\"csv:{headerPick}\";\n                        continue;\n                    }\n                }\n\n                // 3) contains / fuzzy-lite\n                var contains = headers.FirstOrDefault(h => Normalize(h).Contains(normToken, StringComparison.OrdinalIgnoreCase));\n                if (!string.IsNullOrEmpty(contains))\n                {\n                    suggestions[token] = $\"csv:{contains}\";\n                    continue;\n                }\n\n                // 4) default: static placeholder (UI can highlight to user)\n                suggestions[token] = \"static:\";\n            }\n\n            return suggestions;\n        }\n\n        private static List<string> ParseHeaders(string? headersJson)\n        {\n            if (string.IsNullOrWhiteSpace(headersJson)) return new List<string>();\n            try\n            {\n                var arr = JsonSerializer.Deserialize<List<string>>(headersJson);\n                return arr?.Where(h => !string.IsNullOrWhiteSpace(h)).ToList() ?? new List<string>();\n            }\n            catch\n            {\n                // Fallback: maybe comma-separated\n                return headersJson.Split(',').Select(s => s.Trim()).Where(s => s.Length > 0).ToList();\n            }\n        }\n\n        private static List<string> ParseTemplateTokens(string? templateParametersJson)\n        {\n            if (string.IsNullOrWhiteSpace(templateParametersJson)) return new List<string>();\n            try\n            {\n                var arr = JsonSerializer.Deserialize<List<string>>(templateParametersJson);\n                return arr?.Where(t => !string.IsNullOrWhiteSpace(t)).ToList() ?? new List<string>();\n            }\n            catch\n            {\n                return new List<string>();\n            }\n        }\n\n        private static bool IsPhoneToken(string normToken)\n        {\n            if (string.IsNullOrWhiteSpace(normToken)) return false;\n            if (PhoneHeaderCandidates.Contains(normToken)) return true;\n            return normToken.Contains(\"phone\") || normToken.Contains(\"mobile\") || normToken.Contains(\"whatsapp\");\n        }\n\n        private static string Normalize(string s)\n        {\n            var lowered = (s ?? \"\").Trim().ToLowerInvariant();\n            if (lowered.Length == 0) return lowered;\n            var alnum = Regex.Replace(lowered, @\"[^a-z0-9]+\", \"_\");\n            alnum = Regex.Replace(alnum, \"_{2,}\", \"_\").Trim('_');\n            return alnum;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/NoopVariableMappingService.cs",
      "sha256": "24a343d03f2ab867121a8ebfe09ebcf7672fb7a3261095b6dc2322633e1ae722",
      "language": "csharp",
      "size": 984,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    /// <summary>\n    /// Default stub: returns no saved mappings.\n    /// Swap this out later with a DB-backed implementation that reads CampaignVariableMap.\n    /// </summary>\n    public sealed class NoopVariableMappingService : IVariableMappingService\n    {\n        public Task<Dictionary<string, string>> GetForCampaignAsync(\n            Guid businessId,\n            Guid campaignId,\n            CancellationToken ct = default)\n        {\n            return Task.FromResult(new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase));\n        }\n\n        public Task SaveAsync(\n           Guid businessId,\n           Guid campaignId,\n           Dictionary<string, string> mappings,\n           CancellationToken ct = default)\n        {\n            // no-op\n            return Task.CompletedTask;\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/OutboundCampaignQueueService.cs",
      "sha256": "b81f57bff9d0409d1f72e2347814800b56d2a94f6696ce7a5ae1500b38c9648b",
      "language": "csharp",
      "size": 8110,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;                       // <-- add\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api;\nusing xbytechat.api.Features.CampaignModule.Models;\nusing xbytechat.api.Features.Queueing.DTOs;    // <-- add for OutboundCampaignJobCreateDto\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    public class OutboundCampaignQueueService : IOutboundCampaignQueueService\n    {\n        private readonly AppDbContext _db;\n        private readonly ILogger<OutboundCampaignQueueService> _log;\n\n        public OutboundCampaignQueueService(AppDbContext db, ILogger<OutboundCampaignQueueService> log)\n        {\n            _db = db; _log = log;\n        }\n\n        public async Task<Guid> EnqueueAsync(Guid businessId, Guid campaignId, bool forceDuplicate = false)\n        {\n            if (!forceDuplicate)\n            {\n                var existing = await _db.OutboundCampaignJobs\n                    .Where(j => j.CampaignId == campaignId && (j.Status == \"queued\" || j.Status == \"running\"))\n                    .OrderByDescending(j => j.CreatedAt)\n                    .FirstOrDefaultAsync();\n\n                if (existing != null)\n                {\n                    var found = await _db.Campaigns\n                        .FirstOrDefaultAsync(c => c.Id == campaignId && c.BusinessId == businessId);\n\n                    if (found != null && found.Status != \"Queued\")\n                    {\n                        found.Status = \"Queued\";\n                        found.UpdatedAt = DateTime.UtcNow;\n                        await _db.SaveChangesAsync();\n                    }\n\n                    _log.LogInformation(\"Campaign {CampaignId} already queued/running. Job={JobId}\", campaignId, existing.Id);\n                    return existing.Id;\n                }\n            }\n\n            var job = new OutboundCampaignJob\n            {\n                BusinessId = businessId,\n                CampaignId = campaignId,\n                Status = \"queued\",\n                Attempt = 0,\n                MaxAttempts = 5,\n                NextAttemptAt = DateTimeOffset.UtcNow\n            };\n\n            _db.OutboundCampaignJobs.Add(job);\n\n            var row = await _db.Campaigns\n                .FirstOrDefaultAsync(c => c.Id == campaignId && c.BusinessId == businessId);\n\n            if (row != null)\n            {\n                row.Status = \"Queued\";\n                row.UpdatedAt = DateTime.UtcNow;\n            }\n\n            await _db.SaveChangesAsync();\n            return job.Id;\n        }\n\n        public async Task<bool> MarkSucceededAsync(Guid jobId)\n        {\n            var j = await _db.OutboundCampaignJobs.FindAsync(jobId);\n            if (j == null) return false;\n\n            j.Attempt += 1;\n            j.Status = \"succeeded\";\n            j.UpdatedAt = DateTime.UtcNow;\n\n            await _db.SaveChangesAsync();\n            return true;\n        }\n\n        public async Task<bool> MarkFailedAsync(Guid jobId, string error, bool scheduleRetry = true)\n        {\n            var j = await _db.OutboundCampaignJobs.FindAsync(jobId);\n            if (j == null) return false;\n\n            j.Attempt += 1;\n            j.LastError = Truncate(error, 3900);\n            j.UpdatedAt = DateTime.UtcNow;\n\n            if (!scheduleRetry || j.Attempt >= j.MaxAttempts)\n            {\n                j.Status = \"failed\";\n            }\n            else\n            {\n                var backoff = j.Attempt switch\n                {\n                    1 => TimeSpan.FromMinutes(1),\n                    2 => TimeSpan.FromMinutes(5),\n                    3 => TimeSpan.FromMinutes(15),\n                    4 => TimeSpan.FromMinutes(60),\n                    _ => TimeSpan.FromMinutes(180)\n                };\n                j.Status = \"queued\";\n                j.NextAttemptAt = DateTimeOffset.UtcNow.Add(backoff);\n            }\n\n            await _db.SaveChangesAsync();\n            return true;\n        }\n\n        public async Task<List<OutboundCampaignJob>> GetJobsForCampaignAsync(Guid businessId, Guid campaignId)\n        {\n            return await _db.OutboundCampaignJobs\n                .Where(j => j.BusinessId == businessId && j.CampaignId == campaignId)\n                .OrderByDescending(j => j.CreatedAt)\n                .ToListAsync();\n        }\n\n        public async Task<OutboundCampaignJob?> GetActiveJobForCampaignAsync(Guid businessId, Guid campaignId)\n        {\n            return await _db.OutboundCampaignJobs\n                .Where(j => j.BusinessId == businessId && j.CampaignId == campaignId &&\n                            (j.Status == \"queued\" || j.Status == \"running\"))\n                .OrderBy(j => j.CreatedAt)\n                .FirstOrDefaultAsync();\n        }\n\n        public async Task<bool> CancelAsync(Guid businessId, Guid jobId)\n        {\n            var j = await _db.OutboundCampaignJobs.FirstOrDefaultAsync(x => x.Id == jobId && x.BusinessId == businessId);\n            if (j == null) return false;\n\n            if (j.Status == \"queued\" || j.Status == \"running\")\n            {\n                j.Status = \"canceled\";\n                j.UpdatedAt = DateTime.UtcNow;\n                await _db.SaveChangesAsync();\n\n                var campaign = await _db.Campaigns.FirstOrDefaultAsync(c => c.Id == j.CampaignId && c.BusinessId == businessId);\n                if (campaign != null)\n                {\n                    var hasActive = await _db.OutboundCampaignJobs.AnyAsync(x =>\n                        x.CampaignId == j.CampaignId &&\n                        x.BusinessId == businessId &&\n                        (x.Status == \"queued\" || x.Status == \"running\"));\n\n                    if (!hasActive && (campaign.Status == \"Queued\" || campaign.Status == \"Sending\"))\n                    {\n                        campaign.Status = \"Draft\";\n                        campaign.UpdatedAt = DateTime.UtcNow;\n                        await _db.SaveChangesAsync();\n                    }\n                }\n                return true;\n            }\n            return false;\n        }\n\n        public async Task<bool> ForceRetryNowAsync(Guid businessId, Guid jobId)\n        {\n            var j = await _db.OutboundCampaignJobs.FirstOrDefaultAsync(x => x.Id == jobId && x.BusinessId == businessId);\n            if (j == null) return false;\n\n            j.Status = \"queued\";\n            j.NextAttemptAt = DateTimeOffset.UtcNow;\n            j.UpdatedAt = DateTime.UtcNow;\n\n            var campaign = await _db.Campaigns.FirstOrDefaultAsync(c => c.Id == j.CampaignId && c.BusinessId == businessId);\n            if (campaign != null && campaign.Status != \"Queued\")\n            {\n                campaign.Status = \"Queued\";\n                campaign.UpdatedAt = DateTime.UtcNow;\n            }\n\n            await _db.SaveChangesAsync();\n            return true;\n        }\n\n        // NEW: bulk enqueue used by CampaignDispatcher\n        public Task<int> EnqueueBulkAsync(IEnumerable<OutboundCampaignJobCreateDto> jobs, CancellationToken ct = default)\n        {\n            // For now, just log & return a deduped count. Replace with real queue later.\n            var list = (jobs ?? Enumerable.Empty<OutboundCampaignJobCreateDto>()).ToList();\n\n            // Deduplicate by provided IdempotencyKey (or fallback to a stable composite)\n            var enqueuedCount = list\n                .GroupBy(j => string.IsNullOrWhiteSpace(j.IdempotencyKey)\n                                ? $\"{j.CampaignId}:{j.CampaignRecipientId}\"\n                                : j.IdempotencyKey)\n                .Count();\n\n            _log.LogInformation(\"Bulk enqueue requested: {Requested} jobs, deduped to {Enqueued}\",\n                list.Count, enqueuedCount);\n\n            // TODO: push to a real queue/bus and persist queue records as needed.\n            return Task.FromResult(enqueuedCount);\n        }\n\n        private static string Truncate(string s, int max) =>\n            string.IsNullOrEmpty(s) ? s : (s.Length <= max ? s : s.Substring(0, max));\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/OutboundCampaignSendWorker.cs",
      "sha256": "87b84f4ac6b994c6b307f46968b63be7090fa022a3681ae696e01ae348432261",
      "language": "csharp",
      "size": 13092,
      "content": "using System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api;\nusing xbytechat.api.Features.CampaignModule.Services;\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    /// <summary>\n    /// Claims due OutboundCampaignJobs and invokes the campaign sender.\n    /// Uses ExecuteUpdateAsync to flip Campaign.Status without tracking entities,\n    /// eliminating \"already being tracked\" conflicts.\n    /// </summary>\n    public class OutboundCampaignSendWorker : BackgroundService\n    {\n        private readonly IServiceProvider _sp;\n        private readonly ILogger<OutboundCampaignSendWorker> _log;\n\n        // Global cap & polling cadence\n        private const int MaxParallel = 3;\n        private static readonly TimeSpan SweepEvery = TimeSpan.FromSeconds(10);\n\n        public OutboundCampaignSendWorker(IServiceProvider sp, ILogger<OutboundCampaignSendWorker> log)\n        {\n            _sp = sp;\n            _log = log;\n        }\n\n        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n        {\n            // small warm-up delay\n            await Task.Delay(TimeSpan.FromSeconds(5), stoppingToken);\n\n            while (!stoppingToken.IsCancellationRequested)\n            {\n                try\n                {\n                    using var scope = _sp.CreateScope();\n                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n\n                    var now = DateTime.UtcNow;\n\n                    // Find up to MaxParallel due jobs\n                    var due = await db.OutboundCampaignJobs\n                        .Where(j => j.Status == \"queued\" && j.NextAttemptAt <= now)\n                        .OrderBy(j => j.NextAttemptAt)\n                        .ThenBy(j => j.CreatedAt)\n                        .Take(MaxParallel)\n                        .ToListAsync(stoppingToken);\n\n                    // Claim jobs (do NOT increment Attempt here)\n                    foreach (var job in due)\n                    {\n                        job.Status = \"running\";\n                        job.UpdatedAt = DateTime.UtcNow;\n                    }\n\n                    if (due.Count > 0)\n                        await db.SaveChangesAsync(stoppingToken);\n\n                    // Process in parallel within this sweep\n                    var tasks = due.Select(job => ProcessJobAsync(job.Id, stoppingToken)).ToArray();\n                    await Task.WhenAll(tasks);\n                }\n                catch (Exception ex)\n                {\n                    _log.LogWarning(ex, \"Send queue sweep failed\");\n                }\n\n                await Task.Delay(SweepEvery, stoppingToken);\n            }\n        }\n\n        private async Task ProcessJobAsync(Guid jobId, CancellationToken ct)\n        {\n            using var scope = _sp.CreateScope();\n            var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n            var queue = scope.ServiceProvider.GetRequiredService<IOutboundCampaignQueueService>();\n            var campaignService = scope.ServiceProvider.GetRequiredService<ICampaignService>();\n            var log = scope.ServiceProvider.GetRequiredService<ILogger<OutboundCampaignSendWorker>>();\n\n            var job = await db.OutboundCampaignJobs.FirstOrDefaultAsync(j => j.Id == jobId, ct);\n            if (job == null) return;\n\n            // Flip to \"Sending\" (no entity tracked)\n            await db.Campaigns\n                .Where(c => c.Id == job.CampaignId && c.BusinessId == job.BusinessId && c.Status != \"Sending\")\n                .ExecuteUpdateAsync(s => s\n                    .SetProperty(c => c.Status, _ => \"Sending\")\n                    .SetProperty(c => c.UpdatedAt, _ => DateTime.UtcNow),\n                    ct);\n\n            try\n            {\n                // Call by ID only ‚Äì service manages its own DbContext/queries\n                var result = await campaignService.SendTemplateCampaignWithTypeDetectionAsync(job.CampaignId);\n\n                if (result.Success)\n                {\n                    await db.Campaigns\n                        .Where(c => c.Id == job.CampaignId && c.BusinessId == job.BusinessId)\n                        .ExecuteUpdateAsync(s => s\n                            .SetProperty(c => c.Status, _ => \"Sent\")\n                            .SetProperty(c => c.UpdatedAt, _ => DateTime.UtcNow),\n                            ct);\n\n                    await queue.MarkSucceededAsync(job.Id);\n                    log.LogInformation(\"Job {Job} succeeded for campaign {Campaign}\", jobId, job.CampaignId);\n                }\n                else\n                {\n                    var willRetry = job.Attempt + 1 < job.MaxAttempts;\n                    var nextStatus = willRetry ? \"Queued\" : \"Failed\";\n\n                    await db.Campaigns\n                        .Where(c => c.Id == job.CampaignId && c.BusinessId == job.BusinessId)\n                        .ExecuteUpdateAsync(s => s\n                            .SetProperty(c => c.Status, _ => nextStatus)\n                            .SetProperty(c => c.UpdatedAt, _ => DateTime.UtcNow),\n                            ct);\n\n                    await queue.MarkFailedAsync(job.Id, result.Message ?? \"Unknown send error\", scheduleRetry: true);\n                    log.LogWarning(\"Job {Job} failed for campaign {Campaign}: {Msg}\", jobId, job.CampaignId, result.Message);\n                }\n            }\n            catch (Exception ex)\n            {\n                var willRetry = job.Attempt + 1 < job.MaxAttempts;\n                var nextStatus = willRetry ? \"Queued\" : \"Failed\";\n\n                await db.Campaigns\n                    .Where(c => c.Id == job.CampaignId && c.BusinessId == job.BusinessId)\n                    .ExecuteUpdateAsync(s => s\n                        .SetProperty(c => c.Status, _ => nextStatus)\n                        .SetProperty(c => c.UpdatedAt, _ => DateTime.UtcNow),\n                        ct);\n\n                await queue.MarkFailedAsync(job.Id, ex.ToString(), scheduleRetry: true);\n                log.LogWarning(ex, \"Job {Job} exception for campaign {Campaign}\", jobId, job.CampaignId);\n            }\n        }\n    }\n}\n\n\n//////using System;\n//////using System.Linq;\n//////using System.Threading;\n//////using System.Threading.Tasks;\n//////using Microsoft.EntityFrameworkCore;\n//////using Microsoft.Extensions.DependencyInjection;\n//////using Microsoft.Extensions.Hosting;\n//////using Microsoft.Extensions.Logging;\n//////using xbytechat.api;\n//////using xbytechat.api.Features.CampaignModule.Services;\n\n//////namespace xbytechat.api.Features.CampaignModule.Services\n//////{\n//////    /// <summary>\n//////    /// Background worker that claims due jobs and invokes CampaignService to send.\n//////    /// Flips Campaign.Status for truthful UI: Queued -> Sending -> Sent / Queued / Failed\n//////    /// </summary>\n//////    public class OutboundCampaignSendWorker : BackgroundService\n//////    {\n//////        private readonly IServiceProvider _sp;\n//////        private readonly ILogger<OutboundCampaignSendWorker> _log;\n\n//////        // Simple global concurrency cap & polling cadence\n//////        private const int MaxParallel = 3;\n//////        private static readonly TimeSpan SweepEvery = TimeSpan.FromSeconds(10);\n//////        private readonly IDbContextFactory<AppDbContext> _dbFactory;\n\n//////        public OutboundCampaignSendWorker(IServiceProvider sp, ILogger<OutboundCampaignSendWorker> log, IDbContextFactory<AppDbContext> dbFactory)\n//////        {\n//////            _sp = sp; _log = log;\n//////            _dbFactory = dbFactory;\n//////        }\n\n//////        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n//////        {\n//////            await Task.Delay(TimeSpan.FromSeconds(5), stoppingToken);\n\n//////            while (!stoppingToken.IsCancellationRequested)\n//////            {\n//////                try\n//////                {\n//////                    using var scope = _sp.CreateScope();\n//////                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n\n//////                    var now = DateTimeOffset.UtcNow;\n\n//////                    // Find up to MaxParallel due jobs\n//////                    var due = await db.OutboundCampaignJobs\n//////                        .Where(j => j.Status == \"queued\" && j.NextAttemptAt <= now)\n//////                        .OrderBy(j => j.NextAttemptAt)\n//////                        .ThenBy(j => j.CreatedAt)\n//////                        .Take(MaxParallel)\n//////                        .ToListAsync(stoppingToken);\n\n//////                    // Claim jobs (do NOT increment Attempt here)\n//////                    foreach (var job in due)\n//////                    {\n//////                        job.Status = \"running\";\n//////                        job.UpdatedAt = DateTime.UtcNow;\n//////                    }\n//////                    if (due.Count > 0)\n//////                        await db.SaveChangesAsync(stoppingToken);\n\n//////                    var tasks = due.Select(job => ProcessJobAsync(job.Id, stoppingToken)).ToArray();\n//////                    await Task.WhenAll(tasks);\n//////                }\n//////                catch (Exception ex)\n//////                {\n//////                    _log.LogWarning(ex, \"Send queue sweep failed\");\n//////                }\n\n//////                await Task.Delay(SweepEvery, stoppingToken);\n//////            }\n//////        }\n\n//////        private async Task ProcessJobAsync(Guid jobId, CancellationToken ct)\n//////        {\n//////            using var scope = _sp.CreateScope();\n//////            var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n//////            var queue = scope.ServiceProvider.GetRequiredService<IOutboundCampaignQueueService>();\n//////            var campaignService = scope.ServiceProvider.GetRequiredService<ICampaignService>();\n//////            var log = scope.ServiceProvider.GetRequiredService<ILogger<OutboundCampaignSendWorker>>();\n\n//////            var job = await db.OutboundCampaignJobs.FirstOrDefaultAsync(j => j.Id == jobId, ct);\n//////            if (job == null) return;\n\n//////            // Mark Campaign -> Sending\n//////            var campaign = await db.Campaigns\n//////                .FirstOrDefaultAsync(c => c.Id == job.CampaignId && c.BusinessId == job.BusinessId, ct);\n\n//////            if (campaign != null && campaign.Status != \"Sending\")\n//////            {\n//////                campaign.Status = \"Sending\";\n//////                campaign.UpdatedAt = DateTime.UtcNow;\n//////                await db.SaveChangesAsync(ct);\n//////            }\n\n//////            try\n//////            {\n//////                var result = await campaignService.SendTemplateCampaignWithTypeDetectionAsync(job.CampaignId);\n\n//////                if (result.Success)\n//////                {\n//////                    if (campaign != null)\n//////                    {\n//////                        campaign.Status = \"Sent\";\n//////                        campaign.UpdatedAt = DateTime.UtcNow;\n//////                        await db.SaveChangesAsync(ct);\n//////                    }\n\n//////                    await queue.MarkSucceededAsync(job.Id);\n//////                    log.LogInformation(\"Job {Job} succeeded for campaign {Campaign}\", jobId, job.CampaignId);\n//////                }\n//////                else\n//////                {\n//////                    // Compute whether we will retry BEFORE calling MarkFailed (Attempt not yet incremented)\n//////                    var willRetry = job.Attempt + 1 < job.MaxAttempts;\n\n//////                    if (campaign != null)\n//////                    {\n//////                        campaign.Status = willRetry ? \"Queued\" : \"Failed\";\n//////                        campaign.UpdatedAt = DateTime.UtcNow;\n//////                        await db.SaveChangesAsync(ct);\n//////                    }\n\n//////                    await queue.MarkFailedAsync(job.Id, result.Message ?? \"Unknown send error\", scheduleRetry: true);\n//////                    log.LogWarning(\"Job {Job} failed for campaign {Campaign}: {Msg}\", jobId, job.CampaignId, result.Message);\n//////                }\n//////            }\n//////            catch (Exception ex)\n//////            {\n//////                var willRetry = job.Attempt + 1 < job.MaxAttempts;\n\n//////                if (campaign != null)\n//////                {\n//////                    campaign.Status = willRetry ? \"Queued\" : \"Failed\";\n//////                    campaign.UpdatedAt = DateTime.UtcNow;\n//////                    await db.SaveChangesAsync(ct);\n//////                }\n\n//////                await queue.MarkFailedAsync(job.Id, ex.ToString(), scheduleRetry: true);\n//////                log.LogWarning(ex, \"Job {Job} exception for campaign {Campaign}\", jobId, job.CampaignId);\n//////            }\n//////        }\n//////    }\n//////}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Workers/OutboundSenderWorker.cs",
      "sha256": "331cf2348d4034bdd995f63bc3a02151a27a3e4853a280a60994e8c68913ab50",
      "language": "csharp",
      "size": 32501,
      "content": "// üìÑ File: Features/CampaignModule/Workers/OutboundSenderWorker.cs\nusing System;\nusing System.Collections.Concurrent;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Text.Json;\nusing System.Text.RegularExpressions;\nusing System.Threading;\nusing System.Threading.Channels;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Logging;\nusing Npgsql;\n\nusing xbytechat.api;\nusing xbytechat.api.Features.CampaignModule.Models;\nusing xbytechat.api.Features.CampaignTracking.Logging;\nusing xbytechat.api.Features.CampaignTracking.Models;\nusing xbytechat.api.Features.MessageLogging.Services;\nusing xbytechat.api.Features.MessagesEngine.Abstractions;\nusing xbytechat.api.Features.CampaignModule.SendEngine;\nusing xbytechat_api.Features.Billing.Services;\nusing xbytechat.api.Infrastructure.Observability;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.WhatsAppSettings.Helpers;\nusing xbytechat.api.AuthModule.Models;\n\nnamespace xbytechat.api.Features.CampaignModule.Workers\n{\n    public class OutboundSenderWorker : BackgroundService\n    {\n        private readonly IServiceProvider _sp;\n        private readonly ILogger<OutboundSenderWorker> _log;\n        private readonly Channel<OutboundMessageJob> _channel;\n        private const int DEFAULT_MAX_ATTEMPTS = 3;\n\n        // Concurrency caps\n        private readonly int _globalDop = 32;   // total parallel consumers\n        private readonly int _perNumberDop = 8; // per (provider, PhoneNumberId)\n\n        private readonly TimeSpan _pollInterval = TimeSpan.FromSeconds(1);\n        private static readonly TimeSpan _flightTimeout = TimeSpan.FromMinutes(5);\n\n        private int _inChannel;\n        private readonly Random _rand = new();\n\n        // =========================[ Template Button Cache + Parsers ]=========================\n        private static readonly ConcurrentDictionary<string, IReadOnlyList<ButtonMeta>> _btnCache =\n            new(StringComparer.Ordinal);\n\n        private static readonly Regex RxButtonTypeMeta = new(@\"^\\s*url\\s*$\", RegexOptions.IgnoreCase | RegexOptions.Compiled);\n        private static readonly Regex RxButtonTypePinn = new(@\"^\\s*url\\s*$\", RegexOptions.IgnoreCase | RegexOptions.Compiled);\n\n        private static string CacheKeyForTemplate(WhatsAppTemplate tpl)\n            => $\"{tpl.BusinessId}|{tpl.Provider}|{tpl.Name}|{tpl.LanguageCode}\".ToUpperInvariant();\n\n        private static IReadOnlyList<ButtonMeta> GetTemplateButtonsCached(WhatsAppTemplate tpl)\n            => _btnCache.GetOrAdd(CacheKeyForTemplate(tpl), _ => ParseButtonsFromTemplateRow(tpl));\n\n        private static IReadOnlyList<ButtonMeta> ParseButtonsFromTemplateRow(WhatsAppTemplate tpl)\n        {\n            if (!string.IsNullOrWhiteSpace(tpl.UrlButtons))\n            {\n                try\n                {\n                    using var doc = JsonDocument.Parse(tpl.UrlButtons);\n                    if (doc.RootElement.ValueKind == JsonValueKind.Array)\n                    {\n                        var list = new List<ButtonMeta>(capacity: 3);\n                        foreach (var el in doc.RootElement.EnumerateArray())\n                        {\n                            var text = el.TryGetProperty(\"ButtonText\", out var pText) ? pText.GetString() ?? \"\" :\n                                       el.TryGetProperty(\"Text\", out var pText2) ? pText2.GetString() ?? \"\" : \"\";\n                            var type = el.TryGetProperty(\"ButtonType\", out var pType) ? pType.GetString() ?? \"\" :\n                                       el.TryGetProperty(\"Type\", out var pType2) ? pType2.GetString() ?? \"\" : \"\";\n                            var url = el.TryGetProperty(\"TargetUrl\", out var pUrl) ? pUrl.GetString() : null;\n\n                            if (!string.IsNullOrWhiteSpace(text) && !string.IsNullOrWhiteSpace(type))\n                                list.Add(new ButtonMeta(text, type, url));\n                        }\n                        return list;\n                    }\n                }\n                catch { /* fallthrough */ }\n            }\n\n            if (!string.IsNullOrWhiteSpace(tpl.RawJson))\n            {\n                try\n                {\n                    using var doc = JsonDocument.Parse(tpl.RawJson);\n\n                    JsonElement comps = default;\n                    if (doc.RootElement.TryGetProperty(\"template\", out var tplNode) &&\n                        tplNode.TryGetProperty(\"components\", out var comps1))\n                    {\n                        comps = comps1;\n                    }\n                    else if (doc.RootElement.TryGetProperty(\"components\", out var comps2))\n                    {\n                        comps = comps2;\n                    }\n\n                    if (comps.ValueKind == JsonValueKind.Array)\n                    {\n                        var list = new List<ButtonMeta>(capacity: 3);\n\n                        foreach (var c in comps.EnumerateArray())\n                        {\n                            if (!c.TryGetProperty(\"type\", out var tProp)) continue;\n                            if (!string.Equals(tProp.GetString(), \"button\", StringComparison.OrdinalIgnoreCase)) continue;\n\n                            var isUrl =\n                                (c.TryGetProperty(\"sub_type\", out var st) && RxButtonTypeMeta.IsMatch(st.GetString() ?? \"\")) ||\n                                (c.TryGetProperty(\"subType\", out var st2) && RxButtonTypePinn.IsMatch(st2.GetString() ?? \"\"));\n\n                            if (!isUrl) continue;\n\n                            string text = \"Open\";\n                            string type = \"url\";\n                            string? url = null;\n\n                            if (c.TryGetProperty(\"parameters\", out var pars) && pars.ValueKind == JsonValueKind.Array)\n                            {\n                                foreach (var p in pars.EnumerateArray())\n                                {\n                                    if (p.TryGetProperty(\"text\", out var txtProp))\n                                    {\n                                        var v = txtProp.GetString();\n                                        if (!string.IsNullOrWhiteSpace(v)) { url = v; break; }\n                                    }\n                                }\n                            }\n\n                            list.Add(new ButtonMeta(text, type, url));\n                            if (list.Count >= 3) break;\n                        }\n\n                        return list;\n                    }\n                }\n                catch { /* ignore */ }\n            }\n\n            return Array.Empty<ButtonMeta>();\n        }\n        // =====================================================================================\n\n        public OutboundSenderWorker(IServiceProvider sp, ILogger<OutboundSenderWorker> log)\n        {\n            _sp = sp;\n            _log = log;\n\n            _channel = Channel.CreateBounded<OutboundMessageJob>(new BoundedChannelOptions(5000)\n            {\n                SingleReader = false,\n                SingleWriter = false,\n                FullMode = BoundedChannelFullMode.Wait\n            });\n        }\n\n\n\n        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n        {\n            using var cts = CancellationTokenSource.CreateLinkedTokenSource(stoppingToken);\n            var ct = cts.Token;\n\n            var consumers = Enumerable.Range(0, _globalDop)\n                .Select(_ => Task.Run(() => ConsumeAsync(ct), ct))\n                .ToArray();\n\n            var producer = Task.Run(() => ProduceAsync(ct), ct);\n\n            var all = consumers.Append(producer).ToArray();\n\n            try\n            {\n                await Task.WhenAll(all);\n            }\n            catch\n            {\n                try { cts.Cancel(); } catch { /* ignore */ }\n                throw;\n            }\n        }\n\n        private async Task ProduceAsync(CancellationToken ct)\n        {\n            const int ChannelCapacity = 5000;\n\n            var idleDelay = _pollInterval;\n            var maxIdleDelay = TimeSpan.FromSeconds(1);\n            var longIdleDelay = TimeSpan.FromSeconds(30);\n            int consecutiveEmpty = 0;\n\n            const string sql = @\"\nWITH cte AS (\n    SELECT \"\"Id\"\"\n    FROM \"\"OutboundMessageJobs\"\"\n    WHERE \"\"Status\"\" = 'Pending'\n      AND (\"\"NextAttemptAt\"\" IS NULL OR \"\"NextAttemptAt\"\" <= NOW())\n    ORDER BY \"\"NextAttemptAt\"\" NULLS FIRST, \"\"CreatedAt\"\"\n    FOR UPDATE SKIP LOCKED\n    LIMIT @take\n)\nUPDATE \"\"OutboundMessageJobs\"\" j\nSET \"\"Status\"\" = 'InFlight',\n    \"\"NextAttemptAt\"\" = NOW() + make_interval(secs => @flight),\n    \"\"LastError\"\" = NULL\nWHERE j.\"\"Id\"\" IN (SELECT \"\"Id\"\" FROM cte)\nRETURNING j.*;\";\n\n            try { await Task.Delay(_rand.Next(100, 500), ct); } catch { /* ignore */ }\n\n            while (!ct.IsCancellationRequested)\n            {\n                try\n                {\n                    using var scope = _sp.CreateScope();\n                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n\n                    var approxCount = Volatile.Read(ref _inChannel);\n                    var budget = Math.Max(0, ChannelCapacity - approxCount);\n\n                    if (budget <= 0)\n                    {\n                        await Task.Delay(idleDelay, ct);\n                        idleDelay = TimeSpan.FromMilliseconds(\n                            Math.Min(maxIdleDelay.TotalMilliseconds, idleDelay.TotalMilliseconds * 1.25)\n                        );\n                        continue;\n                    }\n\n                    // idleDelay = _pollInterval; // ‚ùå BAD: This was resetting the backoff every time!\n\n                    var take = Math.Min(budget, 2000);\n                    var flightSecs = (int)Math.Ceiling(_flightTimeout.TotalSeconds);\n\n                    var takeParam = new NpgsqlParameter<int>(\"take\", take);\n                    var flightParam = new NpgsqlParameter<int>(\"flight\", flightSecs);\n\n                    var prevTimeout = db.Database.GetCommandTimeout();\n                    db.Database.SetCommandTimeout(5);\n\n                    List<OutboundMessageJob> jobs;\n                    try\n                    {\n                        jobs = await db.OutboundMessageJobs\n                            .FromSqlRaw(sql, takeParam, flightParam)\n                            .AsNoTracking()\n                            .ToListAsync(ct);\n                    }\n                    finally\n                    {\n                        db.Database.SetCommandTimeout(prevTimeout);\n                    }\n\n                    foreach (var job in jobs)\n                    {\n                        await _channel.Writer.WriteAsync(job, ct);\n                        Interlocked.Increment(ref _inChannel);\n                    }\n\n                    if (jobs.Count == 0)\n                    {\n                        consecutiveEmpty++;\n                        var jitterMs = _rand.Next(0, 200);\n                        var delay = idleDelay + TimeSpan.FromMilliseconds(jitterMs);\n\n                        if (consecutiveEmpty >= 8 && idleDelay >= maxIdleDelay)\n                            delay = longIdleDelay + TimeSpan.FromMilliseconds(jitterMs);\n\n                        await Task.Delay(delay, ct);\n\n                        if (idleDelay < maxIdleDelay)\n                        {\n                            idleDelay = TimeSpan.FromMilliseconds(\n                                Math.Min(maxIdleDelay.TotalMilliseconds, idleDelay.TotalMilliseconds * 2)\n                            );\n                        }\n                    }\n                    else\n                    {\n                        consecutiveEmpty = 0;\n                        idleDelay = _pollInterval; // ‚úÖ Correct: Reset only when we found work\n                    }\n                }\n                catch (TaskCanceledException)\n                {\n                }\n                catch (Exception ex)\n                {\n                    _log.LogError(ex, \"[Outbox] Producer loop error\");\n                    try { await Task.Delay(TimeSpan.FromSeconds(2), ct); } catch { /* ignore */ }\n                }\n            }\n        }\n\n        // ---- keyed concurrency gate (per sender) ---------------------------------------\n        private sealed class KeyedSemaphore\n        {\n            private readonly ConcurrentDictionary<string, SemaphoreSlim> _map = new();\n            public async Task<IDisposable> AcquireAsync(string key, int dop, CancellationToken ct)\n            {\n                var sem = _map.GetOrAdd(key, _ => new SemaphoreSlim(dop));\n                await sem.WaitAsync(ct);\n                return new Releaser(sem);\n            }\n            private sealed class Releaser : IDisposable\n            {\n                private readonly SemaphoreSlim _s;\n                public Releaser(SemaphoreSlim s) => _s = s;\n                public void Dispose() => _s.Release();\n            }\n        }\n        private static readonly KeyedSemaphore _perSenderGate = new();\n        // -------------------------------------------------------------------------------\n\n        // Best-effort extraction of provider message id from a Meta success body\n        private static string? TryExtractProviderMessageId(string? raw)\n        {\n            if (string.IsNullOrWhiteSpace(raw)) return null;\n            try\n            {\n                using var doc = JsonDocument.Parse(raw);\n                if (doc.RootElement.TryGetProperty(\"messages\", out var msgs) &&\n                    msgs.ValueKind == JsonValueKind.Array &&\n                    msgs.GetArrayLength() > 0 &&\n                    msgs[0].TryGetProperty(\"id\", out var idProp))\n                {\n                    return idProp.GetString();\n                }\n            }\n            catch { /* ignore */ }\n            return null;\n        }\n\n        private async Task ConsumeAsync(CancellationToken ct)\n        {\n            static async Task<(string Phone, Guid? ContactId, string? ContactName)> ResolveRecipientAsync(\n     AppDbContext db, Guid recipientId, CancellationToken ct2)\n            {\n                var row = await db.CampaignRecipients\n                    .AsNoTracking()\n                    .Where(r => r.Id == recipientId)\n                    .Select(r => new\n                    {\n                        Phone = r.Contact != null\n                            ? r.Contact.PhoneNumber\n                            : (r.AudienceMember != null ? (r.AudienceMember.PhoneE164 ?? r.AudienceMember.PhoneRaw) : null),\n\n                        ContactId = (Guid?)(r.Contact != null ? r.Contact.Id : null),\n                        ContactName = r.Contact != null ? r.Contact.Name : null\n                    })\n                    .FirstOrDefaultAsync(ct2);\n\n                return (row?.Phone ?? string.Empty, row?.ContactId, row?.ContactName);\n            }\n\n            while (await _channel.Reader.WaitToReadAsync(ct))\n            {\n                if (!_channel.Reader.TryRead(out var job))\n                    continue;\n\n                Interlocked.Decrement(ref _inChannel);\n\n                try\n                {\n                    using var scope = _sp.CreateScope();\n                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n                    var engine = scope.ServiceProvider.GetRequiredService<IMessageEngineService>();\n                    var billing = scope.ServiceProvider.GetRequiredService<IBillingIngestService>();\n                    var logger = scope.ServiceProvider.GetRequiredService<ILogger<OutboundSenderWorker>>();\n                    var logSink = scope.ServiceProvider.GetRequiredService<ICampaignLogSink>();\n                    var limiter = scope.ServiceProvider.GetRequiredService<xbytechat.api.Infrastructure.RateLimiting.IPhoneNumberRateLimiter>();\n                    var messageLogSink = scope.ServiceProvider.GetRequiredService<IMessageLogSink>();\n                    var builder = scope.ServiceProvider.GetRequiredService<ITemplatePayloadBuilder>();\n                    var validator = scope.ServiceProvider.GetRequiredService<ICampaignSendValidator>();\n\n                    var senderKey = $\"{job.Provider}|{job.PhoneNumberId}\";\n\n                    using (await _perSenderGate.AcquireAsync(senderKey, _perNumberDop, ct))\n                    {\n                        var lease = await limiter.AcquireAsync(senderKey, ct);\n                        if (!lease.IsAcquired)\n                        {\n                            await Task.Delay(50, ct);\n                            continue;\n                        }\n\n                        var (recipientPhone, contactId, contactName) = await ResolveRecipientAsync(db, job.RecipientId, ct);\n\n                        if (string.IsNullOrWhiteSpace(recipientPhone))\n                        {\n                            job.Status = \"Failed\";\n                            job.Attempt += 1;\n                            job.LastError = \"Recipient phone not found.\";\n                            var backoff1 = (int)Math.Min(60, Math.Pow(2, job.Attempt) * 2);\n                            job.NextAttemptAt = DateTime.UtcNow.AddSeconds(backoff1);\n                            db.Update(job);\n                            await db.SaveChangesAsync(ct);\n\n                            logger.LogWarning(\"[Outbox] Recipient phone not found. job={JobId} recipient={RecipientId}\", job.Id, job.RecipientId);\n                            MetricsRegistry.MessagesFailed.Add(1);\n                            continue;\n                        }\n\n                        var lang = job.LanguageCode ?? \"en_US\";\n                        var tmplRow = await db.WhatsAppTemplates\n                            .AsNoTracking()\n                            .FirstOrDefaultAsync(t =>\n                                t.BusinessId == job.BusinessId &&\n                                t.Provider == job.Provider &&\n                                t.Name == job.TemplateName &&\n                                t.LanguageCode == lang,\n                                ct);\n\n                        if (tmplRow == null)\n                        {\n                            job.Status = \"Failed\";\n                            job.Attempt += 1;\n                            job.LastError = $\"Template not found: {job.TemplateName} ({lang}) for {job.Provider}.\";\n                            var backoff = (int)Math.Min(60, Math.Pow(2, job.Attempt) * 2);\n                            job.NextAttemptAt = DateTime.UtcNow.AddSeconds(backoff);\n                            db.Update(job);\n                            await db.SaveChangesAsync(ct);\n\n                            logger.LogWarning(\"[Outbox] Template not found. job={JobId} template={Template} lang={Lang} provider={Provider}\",\n                                job.Id, job.TemplateName, lang, job.Provider);\n                            MetricsRegistry.MessagesFailed.Add(1);\n                            continue;\n                        }\n\n                        HeaderKind headerKind = tmplRow.HeaderKind?.ToLowerInvariant() switch\n                        {\n                            \"text\" => HeaderKind.Text,\n                            \"image\" => HeaderKind.Image,\n                            \"video\" => HeaderKind.Video,\n                            \"document\" => HeaderKind.Document,\n                            \"none\" or null => HeaderKind.None,\n                            _ => HeaderKind.None\n                        };\n                        if (headerKind == HeaderKind.None && !string.IsNullOrWhiteSpace(job.MediaType))\n                        {\n                            headerKind = job.MediaType.ToLowerInvariant() switch\n                            {\n                                \"text\" => HeaderKind.Text,\n                                \"image\" => HeaderKind.Image,\n                                \"video\" => HeaderKind.Video,\n                                \"document\" => HeaderKind.Document,\n                                _ => HeaderKind.None\n                            };\n                        }\n\n                        var providerEnum = ProviderUtil.Parse(job.Provider);\n                        var buttonsFromTemplate = GetTemplateButtonsCached(tmplRow);\n\n                        var plan = new SendPlan(\n                            BusinessId: job.BusinessId,\n                            Provider: providerEnum,\n                            PhoneNumberId: job.PhoneNumberId!,\n                            TemplateName: job.TemplateName!,\n                            LanguageCode: lang,\n                            HeaderKind: headerKind,\n                            HeaderUrl: job.HeaderMediaUrl,\n                            Buttons: buttonsFromTemplate\n                        );\n\n                        var recipient = new RecipientPlan(\n                            RecipientId: job.RecipientId,\n                            ToPhoneE164: recipientPhone,\n                            ParametersJson: job.ResolvedParamsJson ?? \"[]\",\n                            ButtonParamsJson: job.ResolvedButtonUrlsJson,\n                            IdempotencyKey: job.IdempotencyKey ?? $\"{job.CampaignId}:{recipientPhone}:{job.TemplateName}\"\n                        );\n\n                        var envelope = builder.Build(plan, recipient);\n\n                        var (ok, error) = validator.Validate(plan, recipient, envelope, tmplRow);\n                        if (!ok)\n                        {\n                            job.Status = \"Failed\";\n                            job.Attempt += 1;\n                            job.LastError = error ?? \"Validation failed.\";\n                            var backoff = (int)Math.Min(60, Math.Pow(2, job.Attempt) * 2);\n                            job.NextAttemptAt = DateTime.UtcNow.AddSeconds(backoff);\n                            db.Update(job);\n                            await db.SaveChangesAsync(ct);\n\n                            logger.LogWarning(\"[Outbox] Validation failed job={JobId} error={Error}\", job.Id, job.LastError);\n                            MetricsRegistry.MessagesFailed.Add(1);\n                            continue;\n                        }\n\n                        object payload = providerEnum switch\n                        {\n                            Provider.MetaCloud =>\n                                scope.ServiceProvider.GetRequiredService<MetaCloudPayloadMapper>()\n                                    .BuildPayload(plan, recipient, envelope),\n\n                            Provider.Pinnacle =>\n                                scope.ServiceProvider.GetRequiredService<PinnaclePayloadMapper>()\n                                    .BuildPayload(plan, recipient, envelope),\n\n                            _ => throw new InvalidOperationException(\"Unknown provider\")\n                        };\n\n                        var sw = Stopwatch.StartNew();\n                        var engineResult = await engine.SendPayloadAsync(job.BusinessId, job.Provider, payload, job.PhoneNumberId);\n                        sw.Stop();\n                        MetricsRegistry.SendLatencyMs.Record(sw.Elapsed.TotalMilliseconds);\n\n                        if (!engineResult.Success)\n                        {\n                            var err = engineResult.ErrorMessage ?? string.Empty;\n                            if (err.Contains(\"429\", StringComparison.Ordinal) ||\n                                err.Contains(\"Too Many Requests\", StringComparison.OrdinalIgnoreCase))\n                            {\n                                limiter.UpdateLimits(senderKey, permitsPerSecond: 5, burst: 5);\n                                MetricsRegistry.RateLimited429s.Add(1);\n                            }\n                        }\n\n                        // ‚úÖ Surface provider ID and raw body for visibility\n                        var providerMsgId = !string.IsNullOrWhiteSpace(engineResult.MessageId)\n                            ? engineResult.MessageId\n                            : TryExtractProviderMessageId(engineResult.RawResponse);\n\n                        if (engineResult.Success)\n                        {\n                            logger.LogInformation(\"Provider send OK | providerMessageId={ProviderId} job={JobId} to={To}\",\n                                providerMsgId, job.Id, recipientPhone);\n                        }\n                        else\n                        {\n                            logger.LogWarning(\"Provider send FAILED | job={JobId} to={To} error={Error} body={Body}\",\n                                job.Id, recipientPhone, engineResult.ErrorMessage, engineResult.RawResponse);\n                        }\n\n                        // Persist MessageLogs (COPY sink)\n                        var now = DateTime.UtcNow;\n                        var runId = Guid.NewGuid();\n                        var logId = Guid.NewGuid();\n\n                        logger.LogInformation(\n                            \"[OutboundSenderWorker] Enqueue MessageLog id={LogId} recipient={RecipientId} job={JobId}\",\n                            logId, job.RecipientId, job.Id);\n\n                        messageLogSink.Enqueue(new MessageLog\n                        {\n                            Id = logId,\n                            BusinessId = job.BusinessId,\n                            CampaignId = job.CampaignId,\n                            ContactId = contactId,                 // ‚úÖ ADD\n                            RecipientNumber = recipientPhone,\n                            MessageContent = job.TemplateName,\n                            MediaUrl = job.HeaderMediaUrl,\n                            Status = engineResult.Success ? \"Sent\" : \"Failed\",\n                            MessageId = providerMsgId,\n                            ErrorMessage = engineResult.ErrorMessage,\n                            RawResponse = engineResult.RawResponse,\n                            CreatedAt = now,\n                            SentAt = engineResult.Success ? now : (DateTime?)null,\n                            Source = \"campaign\",\n                            RunId = runId,\n                            Provider = job.Provider,\n                            ProviderMessageId = providerMsgId,\n                            IsIncoming = false,\n                            IsChargeable = false\n                        });\n\n                        // Batched CampaignSendLog (COPY via sink)\n                        logSink.Enqueue(new CampaignLogRecord(\n                            Id: Guid.NewGuid(),\n                            RunId: runId,\n                            MessageId: providerMsgId,\n                            CampaignId: job.CampaignId,\n                           \n                            ContactId: contactId,\n                            RecipientId: job.RecipientId,\n                            MessageBody: job.MessageBody ?? job.TemplateName,\n                            TemplateId: job.TemplateName,\n                            SendStatus: engineResult.Success ? \"Sent\" : \"Failed\",\n                            ErrorMessage: engineResult.ErrorMessage,\n                            CreatedAt: now,\n                            CreatedBy: \"system\",\n                            SentAt: engineResult.Success ? now : (DateTime?)null,\n                            DeliveredAt: null,\n                            ReadAt: null,\n                            IpAddress: null,\n                            DeviceInfo: null,\n                            MacAddress: null,\n                            SourceChannel: \"campaign\",\n                            DeviceType: null,\n                            Browser: null,\n                            Country: null,\n                            City: null,\n                            IsClicked: false,\n                            ClickedAt: null,\n                            ClickType: null,\n                            RetryCount: job.Attempt,\n                            LastRetryAt: now,\n                            LastRetryStatus: engineResult.Success ? \"Success\" : \"Failed\",\n                            AllowRetry: job.Attempt < DEFAULT_MAX_ATTEMPTS,\n                            MessageLogId: logId,\n                            BusinessId: job.BusinessId,\n                            CTAFlowConfigId: null,\n                            CTAFlowStepId: null,\n                            ButtonBundleJson: null\n                        ));\n                        logger.LogDebug(\"[Outbox] Resolved recipient. recipientId={RecipientId} phone={Phone} contactId={ContactId} name={Name}\",\n                      job.RecipientId, recipientPhone, contactId, contactName);\n\n                        // Update job (retry/backoff if needed)\n                        job.Status = engineResult.Success ? \"Sent\" : \"Failed\";\n                        job.Attempt += 1;\n                        job.LastError = engineResult.ErrorMessage;\n\n                        if (!engineResult.Success)\n                        {\n                            var backoffSecs = (int)Math.Min(60, Math.Pow(2, job.Attempt) * 2);\n                            job.NextAttemptAt = DateTime.UtcNow.AddSeconds(backoffSecs);\n                            MetricsRegistry.MessagesFailed.Add(1);\n                        }\n                        else\n                        {\n                            job.NextAttemptAt = null;\n                            MetricsRegistry.MessagesSent.Add(1);\n                        }\n\n                        db.Update(job);\n                        await db.SaveChangesAsync(ct);\n\n                        // üîç Check if all messages for this campaign are done\n                        try \n                        {\n                            var hasPending = await db.OutboundMessageJobs\n                                .AnyAsync(j => j.CampaignId == job.CampaignId \n                                            && j.Status != \"Sent\" \n                                            && j.Status != \"Failed\", ct);\n\n                            if (!hasPending)\n                            {\n                                 var cmp = await db.Campaigns.FindAsync(new object[] { job.CampaignId }, ct);\n                                 if (cmp != null && cmp.Status != \"Sent\" && cmp.Status != \"Completed\")\n                                 {\n                                     cmp.Status = \"Sent\"; \n                                     cmp.UpdatedAt = DateTime.UtcNow;\n                                     db.Update(cmp);\n                                     await db.SaveChangesAsync(ct);\n                                     logger.LogInformation(\"‚úÖ Campaign {CampaignId} marked as SENT (all jobs done).\", job.CampaignId);\n                                 }\n                            }\n                        }\n                        catch (Exception ex)\n                        {\n                            logger.LogError(ex, \"‚ö†Ô∏è Campaign status update failed for {CampaignId}\", job.CampaignId);\n                        }\n\n                        await billing.IngestFromSendResponseAsync(\n                            job.BusinessId,\n                            logId,\n                            job.Provider,\n                            engineResult.RawResponse ?? \"{}\"\n                        );\n                    }\n                }\n                catch (TaskCanceledException)\n                {\n                }\n                catch (Exception ex)\n                {\n                    try\n                    {\n                        using var scope = _sp.CreateScope();\n                        var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n                        job.Status = \"Failed\";\n                        job.Attempt += 1;\n                        job.LastError = ex.Message;\n                        var backoffSecs = (int)Math.Min(60, Math.Pow(2, job.Attempt) * 2);\n                        job.NextAttemptAt = DateTime.UtcNow.AddSeconds(backoffSecs);\n                        db.Update(job);\n                        await db.SaveChangesAsync(ct);\n                    }\n                    catch { /* swallow */ }\n\n                    MetricsRegistry.MessagesFailed.Add(1);\n                    _log.LogError(ex, \"[Outbox] Consume error job={JobId}\", job.Id);\n                }\n            }\n        }\n    }\n}\n\n\n\n\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Workers/OutboxReaperWorker.cs",
      "sha256": "62e23d9733ccd68ae2166ca2bc11a9b2024183cf0b91163984e6d7e40e7d2f15",
      "language": "csharp",
      "size": 3194,
      "content": "using Microsoft.EntityFrameworkCore;\n\nnamespace xbytechat.api.Features.CampaignModule.Workers\n{\n    public sealed class OutboxReaperWorker : BackgroundService\n    {\n        private readonly IServiceProvider _sp;\n        private readonly ILogger<OutboxReaperWorker> _log;\n\n        // How often we sweep\n        private static readonly TimeSpan SweepEvery = TimeSpan.FromSeconds(30);\n\n        // Keep in sync with your sender logic / DEFAULT_MAX_ATTEMPTS\n        private const int MAX_ATTEMPTS = 3;\n\n        public OutboxReaperWorker(IServiceProvider sp, ILogger<OutboxReaperWorker> log)\n        {\n            _sp = sp;\n            _log = log;\n        }\n\n        // OutboxReaperWorker.cs\n        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n        {\n            while (!stoppingToken.IsCancellationRequested)\n            {\n                try\n                {\n                    using var scope = _sp.CreateScope();\n                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n                    var now = DateTime.UtcNow;\n\n                    // ---- Recover stale InFlight jobs (no Random in the expression) ----\n                    var jitterSeconds = 2 + (int)((ulong)DateTime.UtcNow.Ticks % 3); // 2..4s\n                    var backoffAt = now.AddSeconds(jitterSeconds);\n\n                    var recovered = await db.OutboundMessageJobs\n                        .Where(j => j.Status == \"InFlight\" &&\n                                    j.NextAttemptAt != null &&\n                                    j.NextAttemptAt < now)\n                        .ExecuteUpdateAsync(s => s\n                            .SetProperty(j => j.Status, _ => \"Pending\")\n                            .SetProperty(j => j.NextAttemptAt, _ => backoffAt)\n                            .SetProperty(j => j.LastError, _ => \"Recovered from stale in-flight\"),\n                            stoppingToken);\n\n                    // ---- Kill over-retried jobs ----\n                    const int MAX_ATTEMPTS = 3;\n                    var killed = await db.OutboundMessageJobs\n                        .Where(j => (j.Status == \"Pending\" || j.Status == \"Failed\" || j.Status == \"InFlight\") &&\n                                    j.Attempt >= MAX_ATTEMPTS)\n                        .ExecuteUpdateAsync(s => s\n                            .SetProperty(j => j.Status, _ => \"Dead\")\n                            .SetProperty(j => j.NextAttemptAt, _ => (DateTime?)null)\n                            .SetProperty(j => j.LastError, _ => \"Max attempts exceeded\"),\n                            stoppingToken);\n\n                    if (recovered > 0 || killed > 0)\n                        _log.LogInformation(\"[OutboxReaper] recovered={Recovered} killed={Killed}\", recovered, killed);\n                }\n                catch (TaskCanceledException) { /* shutdown */ }\n                catch (Exception ex)\n                {\n                    _log.LogError(ex, \"[OutboxReaper] sweep failed\");\n                }\n\n                try { await Task.Delay(TimeSpan.FromSeconds(30), stoppingToken); }\n                catch (TaskCanceledException) { /* shutdown */ }\n            }\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Config/TrackingOptions.cs",
      "sha256": "76b42450eeb28f2d73ad6fc86ec956bc6e278f17ee17f5e517e0689e8a247483",
      "language": "csharp",
      "size": 337,
      "content": "// üìÑ Features/CampaignTracking/Config/TrackingOptions.cs\nnamespace xbytechat.api.Features.CampaignTracking.Config\n{\n    public class TrackingOptions\n    {\n        public string BaseUrl { get; set; } = \"\";\n        public string Secret { get; set; } = \"\";\n        public TimeSpan TokenTtl { get; set; } = TimeSpan.FromDays(30);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Controllers/CampaignAnalyticsController.cs",
      "sha256": "c6f14bfb29e6c2dc73c26a9437b96ce67a2c3dbb075563f486c2f346ce037296",
      "language": "csharp",
      "size": 776,
      "content": "using Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.CampaignTracking.Services;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.CampaignTracking.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize]\n    public class CampaignAnalyticsController : BusinessControllerBase\n    {\n        private readonly ICampaignAnalyticsService _campaignAnalyticsService;\n        public CampaignAnalyticsController(ICampaignAnalyticsService svc) => _campaignAnalyticsService = svc;\n\n        [HttpGet(\"top-campaigns\")]\n        public async Task<IActionResult> GetTopCampaigns([FromQuery] int count = 5)\n            => Ok(await _campaignAnalyticsService.GetTopCampaignsAsync(BusinessId, count));\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Controllers/CampaignRetryController.cs",
      "sha256": "7fb4bd32c18410353886a39bebaf5c0c6e24ea48ce01a75d6bb0c553613438f8",
      "language": "csharp",
      "size": 1241,
      "content": "using Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CampaignTracking.Services;\n\nnamespace xbytechat.api.Features.CampaignTracking.Controllers\n{\n    [ApiController]\n    [Authorize] // ‚úÖ add this\n    [Route(\"api/campaign-retry\")]\n    public class CampaignRetryController : ControllerBase\n    {\n        private readonly ICampaignTrackingRetryService _retryService;\n\n        public CampaignRetryController(ICampaignTrackingRetryService retryService)\n        {\n            _retryService = retryService;\n        }\n\n        [HttpPost(\"{logId}/retry\")]\n        public async Task<IActionResult> RetrySingle(Guid logId)\n        {\n            var success = await _retryService.RetrySingleAsync(logId);\n            if (!success) return BadRequest(new { message = \"Retry failed or not allowed for this log.\" });\n            return Ok(new { success = true, message = \"Retry completed.\" });\n        }\n\n        [HttpPost(\"campaign/{campaignId}/retry-all\")]\n        public async Task<IActionResult> RetryAllInCampaign(Guid campaignId)\n            => Ok(new { success = true, retriedCount = await _retryService.RetryFailedInCampaignAsync(campaignId) });\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Controllers/CampaignSendLogController.cs",
      "sha256": "8e86a051f236cdefd07529124bac8ed29328bce6a37d105f8d1d3657c9fbc589",
      "language": "csharp",
      "size": 5396,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CampaignTracking.DTOs;\nusing xbytechat.api.Features.CampaignTracking.Services;\n\nnamespace xbytechat.api.Features.CampaignTracking.Controllers\n{\n    [ApiController]\n    [Route(\"api/campaign-logs\")]\n    public class CampaignSendLogController : ControllerBase\n    {\n        private readonly ICampaignSendLogService _logService;\n        private readonly ICampaignTrackingRetryService _retryService;\n\n        public CampaignSendLogController(\n            ICampaignSendLogService logService,\n            ICampaignTrackingRetryService retryService)\n        {\n            _logService = logService;\n            _retryService = retryService;\n        }\n\n        [HttpGet(\"campaign/{campaignId}\")]\n        public async Task<IActionResult> GetLogsByCampaign(\n            Guid campaignId,\n            [FromQuery] string? status,\n            [FromQuery] string? search,\n            [FromQuery] int page = 1,\n            [FromQuery] int pageSize = 10)\n        {\n            var result = await _logService.GetLogsByCampaignIdAsync(campaignId, status, search, page, pageSize);\n            return Ok(result);\n        }\n\n        [HttpGet(\"campaign/{campaignId}/contact/{contactId}\")]\n        public async Task<IActionResult> GetLogsForContact(Guid campaignId, Guid contactId)\n        {\n            var logs = await _logService.GetLogsForContactAsync(campaignId, contactId);\n            return Ok(logs);\n        }\n\n        [HttpPost]\n        public async Task<IActionResult> AddSendLog([FromBody] CampaignSendLogDto dto)\n        {\n            var ipAddress = HttpContext.Connection.RemoteIpAddress?.ToString() ?? \"unknown\";\n            var userAgent = Request.Headers[\"User-Agent\"].ToString() ?? \"unknown\";\n\n            var result = await _logService.AddSendLogAsync(dto, ipAddress, userAgent);\n            if (!result)\n                return BadRequest(new { message = \"Failed to add send log\" });\n\n            return Ok(new { success = true });\n        }\n\n        [HttpPut(\"{logId}/status\")]\n        public async Task<IActionResult> UpdateDeliveryStatus(Guid logId, [FromBody] DeliveryStatusUpdateDto dto)\n        {\n            var result = await _logService.UpdateDeliveryStatusAsync(logId, dto.Status, dto.DeliveredAt, dto.ReadAt);\n            if (!result)\n                return NotFound(new { message = \"Log not found\" });\n\n            return Ok(new { success = true });\n        }\n\n        [HttpPut(\"{logId}/track-click\")]\n        public async Task<IActionResult> TrackClick(Guid logId, [FromBody] ClickTrackDto dto)\n        {\n            var result = await _logService.TrackClickAsync(logId, dto.ClickType);\n            if (!result)\n                return NotFound(new { message = \"Log not found\" });\n\n            return Ok(new { success = true });\n        }\n\n        [HttpPost(\"{logId}/retry\")]\n        public async Task<IActionResult> RetrySingle(Guid logId)\n        {\n            var result = await _retryService.RetrySingleAsync(logId);\n            if (!result)\n                return BadRequest(new { message = \"Retry failed\" });\n\n            return Ok(new { success = true });\n        }\n\n        [HttpPost(\"campaign/{campaignId}/retry-all\")]\n        public async Task<IActionResult> RetryAll(Guid campaignId)\n        {\n            var result = await _retryService.RetryFailedInCampaignAsync(campaignId);\n            return Ok(new { success = true, retried = result });\n        }\n\n        [HttpGet(\"campaign/{campaignId}/summary\")]\n        public async Task<IActionResult> GetCampaignSummary(\n            Guid campaignId,\n            [FromQuery] DateTime? fromUtc,\n            [FromQuery] DateTime? toUtc,\n            [FromQuery] int repliedWindowDays = 7,\n            [FromQuery] Guid? runId = null)\n        {\n            if (repliedWindowDays < 0) repliedWindowDays = 0;\n            if (repliedWindowDays > 90) repliedWindowDays = 90;\n\n            var summary = await _logService.GetCampaignSummaryAsync(\n                campaignId: campaignId,\n                fromUtc: fromUtc,\n                toUtc: toUtc,\n                repliedWindowDays: repliedWindowDays,\n                runId: runId);\n\n            return Ok(summary);\n        }\n\n        [HttpGet(\"campaign/{campaignId}/contacts\")]\n        public async Task<IActionResult> GetContactsByBucket(\n            Guid campaignId,\n            [FromQuery] string bucket = \"sent\",\n            [FromQuery] DateTime? fromUtc = null,\n            [FromQuery] DateTime? toUtc = null,\n            [FromQuery] int repliedWindowDays = 7,\n            [FromQuery] Guid? runId = null,\n            [FromQuery] string? search = null,\n            [FromQuery] int page = 1,\n            [FromQuery] int pageSize = 10)\n        {\n            var result = await _logService.GetContactsByStatBucketAsync(\n                campaignId,\n                bucket,\n                fromUtc,\n                toUtc,\n                repliedWindowDays,\n                runId,\n                search,\n                page,\n                pageSize);\n\n            return Ok(result);\n        }\n    }\n\n    public class DeliveryStatusUpdateDto\n    {\n        public string Status { get; set; }\n        public DateTime? DeliveredAt { get; set; }\n        public DateTime? ReadAt { get; set; }\n    }\n\n    public class ClickTrackDto\n    {\n        public string ClickType { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Controllers/CampaignTrackingController.cs",
      "sha256": "d07d10ed133e7f754d27b41d15102c751e788fe0d932751e24e784b7f108980d",
      "language": "csharp",
      "size": 12354,
      "content": "// üìÑ Features/CampaignTracking/Controllers/CampaignTrackingController.cs\nusing System.Text.Encodings.Web;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api;\nusing xbytechat.api.Features.CampaignTracking.Services;\nusing xbytechat.api.Features.CampaignTracking.Worker;\n\nnamespace xbytechat.api.Features.CampaignTracking.Controllers\n{\n    [ApiController]\n    [Route(\"r\")] // /r/{token}\n    public class CampaignTrackingController : ControllerBase\n    {\n        private static readonly HtmlEncoder HtmlEnc = HtmlEncoder.Default;\n\n        private readonly ILogger<CampaignTrackingController> _log;\n        private readonly IClickTokenService _token;\n        private readonly IClickEventQueue _queue;\n        private readonly AppDbContext _db;\n\n        public CampaignTrackingController(\n            ILogger<CampaignTrackingController> log,\n            IClickTokenService token,\n            IClickEventQueue queue,\n            AppDbContext db)\n        {\n            _log = log;\n            _token = token;\n            _queue = queue;\n            _db = db;\n        }\n\n        [HttpGet(\"{token}\")]\n        [AllowAnonymous]\n        public async Task<IActionResult> RedirectByToken([FromRoute] string token, CancellationToken ct)\n        {\n            // 1) Validate token\n            if (!_token.TryValidate(token, out var p, out var reason))\n            {\n                _log.LogWarning(\"Tracking token rejected. reason={Reason}\", reason);\n                return BadRequest(\"Invalid token.\");\n            }\n\n            // 2) Normalize + classify destination\n            if (!TryNormalizeAllowedDestination(p!.to, out var safeDest, out var scheme))\n            {\n                _log.LogWarning(\"Rejected destination for cid {Cid}: {Dest}\", p.cid, p.to);\n                return BadRequest(\"Invalid destination.\");\n            }\n\n            // 3) Capture client info\n            var ip = HttpContext.Connection.RemoteIpAddress?.ToString() ?? \"0.0.0.0\";\n            var ua = Request.Headers.UserAgent.ToString();\n            var now = DateTime.UtcNow;\n\n            // 4) Determine click type (web | call | whatsapp)\n            var clickType = ClassifyClickType(safeDest, scheme);\n\n            // 4.1) Fetch related ids from the send log (ContactId, CampaignId, RunId)\n            Guid? contactId = null;\n            Guid? campaignId = null; // keep nullable locally\n            Guid? runId = null;\n\n            try\n            {\n                var sendLog = await _db.CampaignSendLogs\n                    .AsNoTracking()\n                    .Where(x => x.Id == p.cid)\n                    .Select(x => new { x.ContactId, x.CampaignId, x.RunId })\n                    .FirstOrDefaultAsync(ct);\n\n                if (sendLog is not null)\n                {\n                    contactId = sendLog.ContactId;\n                    campaignId = sendLog.CampaignId;\n                    runId = sendLog.RunId;\n                }\n                else\n                {\n                    _log.LogWarning(\"SendLog not found for click cid={Cid}\", p.cid);\n                }\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"Failed to fetch ContactId/CampaignId/RunId for cid={Cid}\", p.cid);\n            }\n\n            // 5) Write-through (best-effort, but executed inline)\n            try\n            {\n                await _db.CampaignClickLogs.AddAsync(new CampaignClickLog\n                {\n                    Id = Guid.NewGuid(),\n                    CampaignSendLogId = p.cid,\n\n                    // NOTE:\n                    // If CampaignClickLog.CampaignId is NON-nullable in your DB/model, we must store Guid.Empty when unknown.\n                    // If you later make it nullable, change this line to: CampaignId = campaignId\n                    CampaignId = campaignId ?? Guid.Empty,\n\n                    ContactId = contactId,\n                    ButtonIndex = p.bi,\n                    ButtonTitle = p.bt,\n                    Destination = safeDest,\n                    ClickedAt = now,\n                    Ip = ip,\n                    UserAgent = ua,\n                    ClickType = clickType,\n                    RunId = runId\n                }, ct);\n\n                await _db.SaveChangesAsync(ct);\n\n                _log.LogInformation(\n                    \"CLICK WRITE-THROUGH cid={Cid} idx={Idx} type={Type} dest={Dest}\",\n                    p.cid, p.bi, clickType, safeDest);\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"Write-through insert failed. cid={Cid}\", p.cid);\n            }\n\n            // 6) Enqueue for async worker (best effort)\n            try\n            {\n                var enq = _queue.TryWrite(new ClickEvent(\n                    CampaignSendLogId: p.cid,\n                    ButtonIndex: p.bi,\n                    ButtonTitle: p.bt,\n                    Destination: safeDest,\n                    ClickedAtUtc: now,\n                    Ip: ip,\n                    UserAgent: ua,\n                    ClickType: clickType\n                ));\n\n                _log.LogInformation(\"CLICK ENQUEUE cid={Cid} idx={Idx} enqueued={Enqueued}\", p.cid, p.bi, enq);\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"Queue write threw. cid={Cid}\", p.cid);\n            }\n\n            // 7) First-click fast path (also stores ClickType) ‚Äî best effort\n            try\n            {\n                await _db.Database.ExecuteSqlRawAsync(\n                    @\"update \"\"CampaignSendLogs\"\"\n                         set \"\"IsClicked\"\" = TRUE,\n                             \"\"ClickedAt\"\" = NOW() at time zone 'utc',\n                             \"\"ClickType\"\" = {1}\n                       where \"\"Id\"\" = {0}\n                         and \"\"IsClicked\"\" = FALSE;\",\n                    parameters: new object[] { p.cid, clickType },\n                    cancellationToken: ct);\n            }\n            catch (Exception ex)\n            {\n                _log.LogDebug(ex, \"First-click update skipped.\");\n            }\n\n            // 8) Redirect handling\n            if (clickType is \"call\" or \"whatsapp\")\n            {\n                // Deep link ‚Üí return an HTML/JS shim to trigger immediately, with a safe fallback link.\n                var destHtml = HtmlEnc.Encode(safeDest);\n                var destJs = JsEscape(safeDest);\n\n                var html = $@\"<!doctype html>\n<html lang=\"\"en\"\">\n<head>\n  <meta charset=\"\"utf-8\"\">\n  <meta http-equiv=\"\"x-ua-compatible\"\" content=\"\"ie=edge\"\">\n  <meta name=\"\"viewport\"\" content=\"\"width=device-width, initial-scale=1\"\">\n  <meta http-equiv=\"\"refresh\"\" content=\"\"0;url={destHtml}\"\">\n  <title>Redirecting‚Ä¶</title>\n  <style>\n    body{{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;padding:24px;}}\n    a{{color:#2563eb;text-decoration:underline;}}\n  </style>\n  <script>\n    window.addEventListener('load', function() {{\n      try {{ window.location.replace('{destJs}'); }} catch (e) {{}}\n      setTimeout(function() {{\n        var f = document.getElementById('fallback');\n        if (f) f.style.display = 'inline';\n      }}, 1200);\n    }});\n  </script>\n</head>\n<body>\n  <p>Redirecting‚Ä¶ If you are not redirected automatically, <a id=\"\"fallback\"\" style=\"\"display:none\"\" href=\"\"{destHtml}\"\">tap here</a>.</p>\n</body>\n</html>\";\n\n                Response.Headers[\"Cache-Control\"] = \"no-store, max-age=0\";\n                Response.Headers[\"Pragma\"] = \"no-cache\";\n                Response.Headers[\"X-Content-Type-Options\"] = \"nosniff\";\n                Response.Headers[\"Referrer-Policy\"] = \"no-referrer\";\n                Response.Headers[\"X-Frame-Options\"] = \"DENY\";\n                Response.Headers[\"Permissions-Policy\"] = \"geolocation=(), microphone=(), camera=()\";\n                Response.Headers[\"Content-Security-Policy\"] =\n                    \"default-src 'none'; script-src 'unsafe-inline'; style-src 'unsafe-inline'; base-uri 'none'; frame-ancestors 'none'\";\n\n                return new ContentResult\n                {\n                    Content = html,\n                    ContentType = \"text/html; charset=utf-8\",\n                    StatusCode = 200\n                };\n            }\n\n            // Regular web links ‚Üí normal 302\n\n            Response.Headers[\"Cache-Control\"] = \"no-store, max-age=0\";\n            Response.Headers[\"Pragma\"] = \"no-cache\";\n            Response.Headers[\"X-Content-Type-Options\"] = \"nosniff\";\n            Response.Headers[\"Referrer-Policy\"] = \"no-referrer\";\n            Response.Headers[\"X-Frame-Options\"] = \"DENY\";\n            Response.Headers[\"Permissions-Policy\"] = \"geolocation=(), microphone=(), camera=()\";\n            return Redirect(safeDest);\n        }\n\n        // --- helpers ---\n\n        private static string ClassifyClickType(string normalizedDest, string scheme)\n        {\n            // scheme is pre-normalized by TryNormalizeAllowedDestination\n            if (string.Equals(scheme, \"tel\", StringComparison.OrdinalIgnoreCase)) return \"call\";\n            if (string.Equals(scheme, \"wa\", StringComparison.OrdinalIgnoreCase)) return \"whatsapp\";\n            if (string.Equals(scheme, \"whatsapp\", StringComparison.OrdinalIgnoreCase)) return \"whatsapp\";\n\n            // http/https ‚Üí still treat WhatsApp hosts as whatsapp\n            if (normalizedDest.StartsWith(\"https://wa.me/\", StringComparison.OrdinalIgnoreCase)) return \"whatsapp\";\n            if (normalizedDest.StartsWith(\"https://api.whatsapp.com/\", StringComparison.OrdinalIgnoreCase)) return \"whatsapp\";\n\n            return \"web\";\n        }\n\n        private static string JsEscape(string s) =>\n            s.Replace(\"\\\\\", \"\\\\\\\\\").Replace(\"'\", \"\\\\'\").Replace(\"\\r\", \"\").Replace(\"\\n\", \"\");\n\n        /// <summary>\n        /// Accepts: http/https/tel/wa/whatsapp, plus shorthand wa.me/... and api.whatsapp.com/...\n        /// Returns normalized absolute string and a normalized scheme hint (\"http\",\"https\",\"tel\",\"wa\",\"whatsapp\").\n        /// </summary>\n        private static bool TryNormalizeAllowedDestination(string? input, out string normalized, out string scheme)\n        {\n            normalized = string.Empty;\n            scheme = string.Empty;\n            if (string.IsNullOrWhiteSpace(input)) return false;\n\n            var cleaned = new string(input.Trim().Where(c => !char.IsControl(c)).ToArray());\n\n            // Shorthand WhatsApp hosts without scheme ‚Üí prefix https://\n            if (!cleaned.Contains(\"://\", StringComparison.Ordinal))\n            {\n                if (cleaned.StartsWith(\"wa.me/\", StringComparison.OrdinalIgnoreCase) ||\n                    cleaned.StartsWith(\"api.whatsapp.com/\", StringComparison.OrdinalIgnoreCase))\n                {\n                    var guess = \"https://\" + cleaned;\n                    if (Uri.TryCreate(guess, UriKind.Absolute, out var waAbs))\n                    {\n                        normalized = waAbs.AbsoluteUri;\n                        scheme = \"https\";\n                        return true;\n                    }\n                }\n            }\n\n            // WhatsApp custom schemes (wa:, whatsapp:)\n            if (cleaned.StartsWith(\"wa:\", StringComparison.OrdinalIgnoreCase))\n            {\n                normalized = cleaned; scheme = \"wa\"; return true;\n            }\n            if (cleaned.StartsWith(\"whatsapp:\", StringComparison.OrdinalIgnoreCase))\n            {\n                normalized = cleaned; scheme = \"whatsapp\"; return true;\n            }\n\n            // Absolute URIs\n            if (Uri.TryCreate(cleaned, UriKind.Absolute, out var uri))\n            {\n                // tel:\n                if (uri.Scheme.Equals(\"tel\", StringComparison.OrdinalIgnoreCase))\n                {\n                    normalized = uri.ToString(); scheme = \"tel\"; return true;\n                }\n\n                // http/https (including WhatsApp hosts)\n                if (uri.Scheme.Equals(Uri.UriSchemeHttp, StringComparison.OrdinalIgnoreCase) ||\n                    uri.Scheme.Equals(Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n                {\n                    normalized = uri.AbsoluteUri;\n                    scheme = uri.Scheme; // \"http\" or \"https\"\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    }\n}\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/DTOs/CampaignContactListItemDto.cs",
      "sha256": "9a3667ed9dbbde0d46cb9911f4733be56dc30128461e899e9f091a4fcbf49289",
      "language": "csharp",
      "size": 1184,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CampaignTracking.DTOs\n{\n    public class CampaignContactListItemDto\n    {\n        // ‚úÖ Needed for Phase-2 actions (retry/delete/redirect selected)\n        public Guid SendLogId { get; set; }\n\n        // ‚úÖ Useful for drill-down / audits / inbox links\n        public Guid? MessageLogId { get; set; }\n        public Guid? RecipientId { get; set; }\n\n        public Guid? ContactId { get; set; }\n        public string ContactName { get; set; } = \"N/A\";\n        public string ContactPhone { get; set; } = \"-\";\n        public string? RecipientNumber { get; set; }\n\n        public string? SendStatus { get; set; }\n        public string? ErrorMessage { get; set; }\n\n        public bool IsClicked { get; set; }\n        public string? ClickType { get; set; }\n        public DateTime? ClickedAt { get; set; }\n\n        public DateTime? SentAt { get; set; }\n        public DateTime? DeliveredAt { get; set; }\n        public DateTime? ReadAt { get; set; }\n\n        // For replied bucket\n        public DateTime? LastInboundAt { get; set; }\n\n        // ‚úÖ One ordering timestamp for UI\n        public DateTime? LastUpdatedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/DTOs/CampaignLogSummaryDto.cs",
      "sha256": "bd3cac78ed5b703d34fde2e9459dff5ed4e1bb703729c876ffaada72c4d6a99e",
      "language": "csharp",
      "size": 586,
      "content": "namespace xbytechat.api.Features.CampaignTracking.DTOs\n{\n    public class CampaignLogSummaryDto\n    {\n        public int TotalSent { get; set; }\n        public int FailedCount { get; set; }\n        public int ClickedCount { get; set; }\n        public DateTime? LastSentAt { get; set; }\n\n        public int Delivered { get; set; }\n        public int Read { get; set; }\n        public int Sent { get; set; }\n\n        public int RepliedUniqueContacts { get; set; }\n\n        // ‚úÖ NEW: so frontend can label ‚ÄúReplied (X days)‚Äù\n        public int ReplyWindowDays { get; set; }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/DTOs/CampaignSendLogDto.cs",
      "sha256": "e4401d635c37b8b9990e5b0b8137ffe065550330c45ccf4638e336b803e6c5cf",
      "language": "csharp",
      "size": 1730,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CampaignTracking.DTOs\n{\n    public class CampaignSendLogDto\n    {\n        public Guid Id { get; set; }\n\n        // üîó Relationships\n        public Guid CampaignId { get; set; }\n        public Guid? ContactId { get; set; }\n        public string ContactName { get; set; }\n        public string ContactPhone { get; set; }\n\n        public string? RecipientNumber { get; set; }\n        // üì§ Message Info\n        public Guid RecipientId { get; set; }\n        public string MessageBody { get; set; }\n        public string? TemplateId { get; set; }\n        public string? SendStatus { get; set; }\n        public string? ErrorMessage { get; set; }\n\n        // üïí Timestamps\n        public DateTime CreatedAt { get; set; }\n        public DateTime? SentAt { get; set; }\n        public DateTime? DeliveredAt { get; set; }\n        public DateTime? ReadAt { get; set; }\n\n        // üåê Metadata\n        public string? SourceChannel { get; set; }\n        public string? IpAddress { get; set; }\n        public string? DeviceInfo { get; set; }\n        public string? MacAddress { get; set; }\n\n        // ‚úÖ Enriched metadata\n        public string? DeviceType { get; set; }\n        public string? Browser { get; set; }\n        public string? Country { get; set; }\n        public string? City { get; set; }\n\n        // üìà Click Tracking\n        public bool IsClicked { get; set; }\n        public DateTime? ClickedAt { get; set; }\n        public string? ClickType { get; set; }\n\n        // üîÅ Retry Info\n        public string? RetryStatus { get; set; }     // Pending, Retried, Skipped\n        public int RetryCount { get; set; }\n        public DateTime? LastRetryAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/DTOs/CampaignStatusDashboardDto.cs",
      "sha256": "21979b3b1de98ab2567e6485c9c0e4684b848735d36743226caaca66504e9b7b",
      "language": "csharp",
      "size": 1038,
      "content": "namespace xbytechat.api.Features.CampaignTracking.DTOs\n{\n    public class CampaignStatusDashboardDto\n    {\n        public Guid CampaignId { get; set; }\n\n        // üìä Overall Stats\n        public int TotalRecipients { get; set; }\n        public int SentCount { get; set; }\n        public int DeliveredCount { get; set; }\n        public int ReadCount { get; set; }\n        public int FailedCount { get; set; }\n\n        // üïí Delivery Timing (optional but insightful)\n        public DateTime? FirstSentAt { get; set; }\n        public DateTime? LastSentAt { get; set; }\n        public DateTime? FirstReadAt { get; set; }\n        public DateTime? LastReadAt { get; set; }\n\n        // üìâ Delivery Rates\n        public double DeliveryRate => TotalRecipients == 0 ? 0 : (double)DeliveredCount / TotalRecipients * 100;\n        public double ReadRate => TotalRecipients == 0 ? 0 : (double)ReadCount / TotalRecipients * 100;\n        public double FailureRate => TotalRecipients == 0 ? 0 : (double)FailedCount / TotalRecipients * 100;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/DTOs/TopCampaignDto.cs",
      "sha256": "deebf224725de4a79f8363405623b0761fed9b776ec86cc8d6a9b05c5f79940e",
      "language": "csharp",
      "size": 295,
      "content": "namespace xbytechat.api.Features.CampaignTracking.DTOs\n{\n    public class TopCampaignDto\n    {\n        public Guid CampaignId { get; set; }\n        public string CampaignName { get; set; }\n        public double ReadRate { get; set; }\n        public double ClickThroughRate { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/EntityTypeConfigs/CampaignSendLogConfig.cs",
      "sha256": "cf880a46e9114af3187c8c4cd1f11e526a5b0c83fc9894ebc8dc39075e937247",
      "language": "csharp",
      "size": 1967,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Microsoft.EntityFrameworkCore.Metadata.Builders;\nusing xbytechat.api.Features.CampaignTracking.Models;\n\nnamespace xbytechat.api.Features.CampaignTracking.EntityTypeConfigs\n{\n    public class CampaignSendLogConfig : IEntityTypeConfiguration<CampaignSendLog>\n    {\n        public void Configure(EntityTypeBuilder<CampaignSendLog> e)\n        {\n            e.ToTable(\"CampaignSendLogs\"); // your table name\n            e.HasKey(x => x.Id);\n\n            // common lengths to keep COPY happy (adjust if you already have constraints)\n            e.Property(x => x.MessageId).HasMaxLength(128);\n            e.Property(x => x.TemplateId).HasMaxLength(128);\n            e.Property(x => x.SendStatus).HasMaxLength(32);\n            e.Property(x => x.ErrorMessage).HasMaxLength(1024);\n            e.Property(x => x.CreatedBy).HasMaxLength(128);\n            e.Property(x => x.IpAddress).HasMaxLength(64);\n            e.Property(x => x.DeviceInfo).HasMaxLength(256);\n            e.Property(x => x.MacAddress).HasMaxLength(64);\n            e.Property(x => x.SourceChannel).HasMaxLength(64);\n            e.Property(x => x.DeviceType).HasMaxLength(64);\n            e.Property(x => x.Browser).HasMaxLength(64);\n            e.Property(x => x.Country).HasMaxLength(64);\n            e.Property(x => x.City).HasMaxLength(64);\n            e.Property(x => x.ClickType).HasMaxLength(64);\n            e.Property(x => x.LastRetryStatus).HasMaxLength(32);\n\n            // CreatedAt default (UTC) if not set by code\n            e.Property(x => x.CreatedAt).HasDefaultValueSql(\"timezone('utc', now())\");\n\n            // helpful indexes\n            e.HasIndex(x => new { x.BusinessId, x.CampaignId, x.CreatedAt });\n            e.HasIndex(x => new { x.CampaignId, x.SendStatus, x.CreatedAt });\n            e.HasIndex(x => new { x.RecipientId, x.CreatedAt });\n            e.HasIndex(x => x.MessageId);\n            e.HasIndex(x => x.RunId);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Logging/CampaignLogFlushWorker.cs",
      "sha256": "b00af09909773fe5a42fec957467b0749da9ef01e66ee094928dde050277ac59",
      "language": "csharp",
      "size": 1106,
      "content": "using Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\n\nnamespace xbytechat.api.Features.CampaignTracking.Logging\n{\n    public class CampaignLogFlushWorker : BackgroundService\n    {\n        private readonly ICampaignLogSink _sink;\n        private readonly ILogger<CampaignLogFlushWorker> _log;\n        private readonly IOptionsMonitor<BatchingOptions> _opts;\n\n        public CampaignLogFlushWorker(ICampaignLogSink sink, ILogger<CampaignLogFlushWorker> log, IOptionsMonitor<BatchingOptions> opts)\n        {\n            _sink = sink; _log = log; _opts = opts;\n        }\n\n        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n        {\n            while (!stoppingToken.IsCancellationRequested)\n            {\n                try { await _sink.FlushAsync(stoppingToken); }\n                catch (Exception ex) { _log.LogError(ex, \"[CampaignLogFlushWorker] flush error\"); }\n                await Task.Delay(TimeSpan.FromMilliseconds(_opts.CurrentValue.CampaignLog.FlushEveryMs), stoppingToken);\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Logging/CampaignLogRecord.cs",
      "sha256": "777772c74a122cabcaf3c59ae1aac8fd43c7b97b6d562d5c239921ed24c47be5",
      "language": "csharp",
      "size": 1067,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CampaignTracking.Logging\n{\n    public record CampaignLogRecord(\n        Guid Id,\n        Guid? RunId,\n        string? MessageId,\n        Guid CampaignId,\n        Guid? ContactId,\n        Guid RecipientId,\n        string MessageBody,\n        string? TemplateId,\n        string? SendStatus,\n        string? ErrorMessage,\n        DateTime CreatedAt,\n        string? CreatedBy,\n        DateTime? SentAt,\n        DateTime? DeliveredAt,\n        DateTime? ReadAt,\n        string? IpAddress,\n        string? DeviceInfo,\n        string? MacAddress,\n        string? SourceChannel,\n        string? DeviceType,\n        string? Browser,\n        string? Country,\n        string? City,\n        bool IsClicked,\n        DateTime? ClickedAt,\n        string? ClickType,\n        int RetryCount,\n        DateTime? LastRetryAt,\n        string? LastRetryStatus,\n        bool AllowRetry,\n        Guid? MessageLogId,\n        Guid BusinessId,\n        Guid? CTAFlowConfigId,\n        Guid? CTAFlowStepId,\n        string? ButtonBundleJson\n    );\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Logging/CampaignLogSink.cs",
      "sha256": "1cb036d202b67bf8fdaa1e5f217c0c8c728b1ec98ec090f4bfbcfd40e46f3bc7",
      "language": "csharp",
      "size": 12526,
      "content": "using System.Collections.Concurrent;\nusing Microsoft.EntityFrameworkCore;\nusing System.Linq;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing Npgsql;\nusing NpgsqlTypes;\nusing xbytechat.api.Features.CampaignTracking.Models; // CampaignSendLog\nusing xbytechat.api.AuthModule.Models;               // AppDbContext\n\nnamespace xbytechat.api.Features.CampaignTracking.Logging\n{\n    public class CampaignLogSink : ICampaignLogSink\n    {\n        private readonly ConcurrentQueue<CampaignLogRecord> _queue = new();\n        private readonly ConcurrentDictionary<Guid, int> _attempts = new();\n        private readonly ILogger<CampaignLogSink> _log;\n        private readonly IServiceProvider _sp;\n        private readonly IOptionsMonitor<BatchingOptions> _opts;\n\n        private const int MaxAttempts = 3;\n\n        public CampaignLogSink(ILogger<CampaignLogSink> log, IServiceProvider sp, IOptionsMonitor<BatchingOptions> opts)\n        {\n            _log = log; _sp = sp; _opts = opts;\n        }\n\n        public void Enqueue(CampaignLogRecord rec) => _queue.Enqueue(rec);\n        public int PendingCount => _queue.Count;\n\n        public async Task FlushAsync(CancellationToken ct = default)\n        {\n            var max = _opts.CurrentValue.CampaignLog.MaxBatchSize;\n            var list = new List<CampaignLogRecord>(Math.Min(_queue.Count, max));\n            while (list.Count < max && _queue.TryDequeue(out var r)) list.Add(r);\n            if (list.Count == 0) return;\n\n            try\n            {\n                // Ensure all referenced MessageLogs exist before inserting send logs\n                var messageLogIds = list\n                    .Select(x => x.MessageLogId)\n                    .Where(id => id.HasValue && id.Value != Guid.Empty)\n                    .Select(id => id!.Value)\n                    .Distinct()\n                    .ToList();\n\n                _log.LogInformation(\n                    \"[CampaignLogSink] Batch size = {BatchCount}, messageLogIds = {IdCount}\",\n                    list.Count, messageLogIds.Count);\n\n                if (messageLogIds.Count > 0)\n                {\n                    using var scope = _sp.CreateScope();\n                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n                    var existingIds = await db.MessageLogs\n                        .AsNoTracking()\n                        .Where(m => messageLogIds.Contains(m.Id))\n                        .Select(m => m.Id)\n                        .ToListAsync(ct);\n\n                    var missing = messageLogIds.Except(existingIds).ToList();\n                    if (missing.Count > 0)\n                    {\n                        // Use first record Id as batch key\n                        var batchKey = list[0].Id;\n                        var attempt = _attempts.AddOrUpdate(batchKey, 1, (_, prev) => prev + 1);\n\n                        if (attempt <= MaxAttempts)\n                        {\n                            _log.LogWarning(\n                                \"[CampaignLogSink] Deferring batch (attempt {Attempt}/{Max}) ‚Äì messageLogIds={Ids} missingCount={MissingCount}\",\n                                attempt, MaxAttempts, string.Join(\",\", messageLogIds), missing.Count);\n                            foreach (var item in list) _queue.Enqueue(item);\n                            return;\n                        }\n\n                        _log.LogError(\n                            \"[CampaignLogSink] Dropping batch after {MaxAttempts} attempts ‚Äì still missing messageLogIds={Ids}\",\n                            MaxAttempts, string.Join(\",\", messageLogIds));\n                        _attempts.TryRemove(batchKey, out _);\n                        return; // drop to avoid FK violations / infinite loop\n                    }\n\n                    // All required MessageLogs exist; clear attempts for this batch key\n                    _attempts.TryRemove(list[0].Id, out _);\n                }\n\n                if (_opts.CurrentValue.CampaignLog.UseCopy)\n                    await CopyInsertAsync(list, ct);\n                else\n                    await EfInsertAsync(list, ct);\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"[CampaignLogSink] COPY failed; falling back to EF\");\n                try { await EfInsertAsync(list, ct); }\n                catch (Exception ex2)\n                {\n                    _log.LogError(ex2, \"[CampaignLogSink] EF fallback failed; requeueing {Count}\", list.Count);\n                    foreach (var rr in list) _queue.Enqueue(rr);\n                }\n            }\n        }\n\n        private static void WriteNullable<T>(NpgsqlBinaryImporter w, T? value, NpgsqlDbType type) where T : struct\n        {\n            if (value.HasValue) w.Write(value.Value, type);\n            else w.WriteNull();\n        }\n\n        private static void WriteNullableText(NpgsqlBinaryImporter w, string? value)\n        {\n            if (string.IsNullOrWhiteSpace(value)) w.WriteNull();\n            else w.Write(value, NpgsqlDbType.Text);\n        }\n\n        private static void WriteNullableVarchar(NpgsqlBinaryImporter w, string? value)\n        {\n            if (string.IsNullOrWhiteSpace(value)) w.WriteNull();\n            else w.Write(value, NpgsqlDbType.Varchar);\n        }\n\n        private static void WriteNullableUuid(NpgsqlBinaryImporter w, Guid? value)\n        {\n            if (value.HasValue && value.Value != Guid.Empty) w.Write(value.Value, NpgsqlDbType.Uuid);\n            else w.WriteNull();\n        }\n\n        private async Task CopyInsertAsync(List<CampaignLogRecord> batch, CancellationToken ct)\n        {\n            using var scope = _sp.CreateScope();\n            var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n            var connString = db.Database.GetDbConnection().ConnectionString;\n\n            await using var conn = new NpgsqlConnection(connString);\n            await conn.OpenAsync(ct);\n\n            const string sql = @\"\nCOPY \"\"CampaignSendLogs\"\" (\n    \"\"Id\"\",\n    \"\"RunId\"\",\n    \"\"MessageId\"\",\n    \"\"CampaignId\"\",\n    \"\"ContactId\"\",\n    \"\"RecipientId\"\",\n    \"\"MessageBody\"\",\n    \"\"TemplateId\"\",\n    \"\"SendStatus\"\",\n    \"\"ErrorMessage\"\",\n    \"\"CreatedAt\"\",\n    \"\"CreatedBy\"\",\n    \"\"SentAt\"\",\n    \"\"DeliveredAt\"\",\n    \"\"ReadAt\"\",\n    \"\"IpAddress\"\",\n    \"\"DeviceInfo\"\",\n    \"\"MacAddress\"\",\n    \"\"SourceChannel\"\",\n    \"\"DeviceType\"\",\n    \"\"Browser\"\",\n    \"\"Country\"\",\n    \"\"City\"\",\n    \"\"IsClicked\"\",\n    \"\"ClickedAt\"\",\n    \"\"ClickType\"\",\n    \"\"RetryCount\"\",\n    \"\"LastRetryAt\"\",\n    \"\"LastRetryStatus\"\",\n    \"\"AllowRetry\"\",\n    \"\"MessageLogId\"\",\n    \"\"BusinessId\"\",\n    \"\"CTAFlowConfigId\"\",\n    \"\"CTAFlowStepId\"\",\n    \"\"ButtonBundleJson\"\"\n) FROM STDIN (FORMAT BINARY);\";\n\n            try\n            {\n                await using var writer = await conn.BeginBinaryImportAsync(sql, ct);\n\n                foreach (var r in batch)\n                {\n                    await writer.StartRowAsync(ct);\n\n                    // Required IDs\n                    writer.Write(r.Id, NpgsqlDbType.Uuid);\n                    writer.Write(r.RunId, NpgsqlDbType.Uuid);\n\n                    // Strings / nullable fields\n                    WriteNullableVarchar(writer, r.MessageId);\n                    writer.Write(r.CampaignId, NpgsqlDbType.Uuid);\n                    WriteNullableUuid(writer, r.ContactId);\n                    WriteNullableUuid(writer, r.RecipientId);\n\n                    WriteNullableText(writer, r.MessageBody);\n                    WriteNullableVarchar(writer, r.TemplateId);\n                    WriteNullableVarchar(writer, r.SendStatus);\n                    WriteNullableVarchar(writer, r.ErrorMessage);\n\n                    // Timestamps\n                    writer.Write(r.CreatedAt, NpgsqlDbType.TimestampTz);\n                    WriteNullableVarchar(writer, r.CreatedBy);\n                    WriteNullable(writer, r.SentAt, NpgsqlDbType.TimestampTz);\n                    WriteNullable(writer, r.DeliveredAt, NpgsqlDbType.TimestampTz);\n                    WriteNullable(writer, r.ReadAt, NpgsqlDbType.TimestampTz);\n\n                    // Device / network\n                    WriteNullableVarchar(writer, r.IpAddress);\n                    WriteNullableVarchar(writer, r.DeviceInfo);\n                    WriteNullableVarchar(writer, r.MacAddress);\n                    WriteNullableVarchar(writer, r.SourceChannel);\n                    WriteNullableVarchar(writer, r.DeviceType);\n                    WriteNullableVarchar(writer, r.Browser);\n                    WriteNullableVarchar(writer, r.Country);\n                    WriteNullableVarchar(writer, r.City);\n\n                    // Click info\n                    writer.Write(r.IsClicked, NpgsqlDbType.Boolean);\n                    WriteNullable(writer, r.ClickedAt, NpgsqlDbType.TimestampTz);\n                    WriteNullableVarchar(writer, r.ClickType);\n\n                    // Retry info ‚Äî RetryCount is non-nullable int in your model\n                    writer.Write(r.RetryCount, NpgsqlDbType.Integer);\n                    WriteNullable(writer, r.LastRetryAt, NpgsqlDbType.TimestampTz);\n                    WriteNullableVarchar(writer, r.LastRetryStatus);\n                    writer.Write(r.AllowRetry, NpgsqlDbType.Boolean);\n\n                    // FK to MessageLogs may be null initially\n                    WriteNullableUuid(writer, r.MessageLogId);\n\n                    // Remaining Ids\n                    writer.Write(r.BusinessId, NpgsqlDbType.Uuid);\n                    WriteNullableUuid(writer, r.CTAFlowConfigId);\n                    WriteNullableUuid(writer, r.CTAFlowStepId);\n\n                    // Bundle (text/json)\n                    WriteNullableText(writer, r.ButtonBundleJson);\n                }\n\n                await writer.CompleteAsync(ct);\n                _log.LogDebug(\"[CampaignLogSink] COPY inserted {Count} rows\", batch.Count);\n            }\n            catch\n            {\n                throw; // let FlushAsync() handle fallback/requeue\n            }\n        }\n\n        private async Task EfInsertAsync(List<CampaignLogRecord> batch, CancellationToken ct)\n        {\n            using var scope = _sp.CreateScope();\n            var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n\n            var entities = batch.Select(r => new CampaignSendLog\n            {\n                Id = r.Id,\n                RunId = r.RunId,\n                MessageId = r.MessageId,\n                CampaignId = r.CampaignId,\n                ContactId = r.ContactId,\n                RecipientId = r.RecipientId,\n                MessageBody = r.MessageBody,\n                TemplateId = r.TemplateId,\n                SendStatus = r.SendStatus,\n                ErrorMessage = r.ErrorMessage,\n                CreatedAt = r.CreatedAt,\n                CreatedBy = r.CreatedBy,\n                SentAt = r.SentAt,\n                DeliveredAt = r.DeliveredAt,\n                ReadAt = r.ReadAt,\n                IpAddress = r.IpAddress,\n                DeviceInfo = r.DeviceInfo,\n                MacAddress = r.MacAddress,\n                SourceChannel = r.SourceChannel,\n                DeviceType = r.DeviceType,\n                Browser = r.Browser,\n                Country = r.Country,\n                City = r.City,\n                IsClicked = r.IsClicked,\n                ClickedAt = r.ClickedAt,\n                ClickType = r.ClickType,\n                RetryCount = r.RetryCount,\n                LastRetryAt = r.LastRetryAt,\n                LastRetryStatus = r.LastRetryStatus,\n                AllowRetry = r.AllowRetry,\n                MessageLogId = r.MessageLogId,\n                BusinessId = r.BusinessId,\n                CTAFlowConfigId = r.CTAFlowConfigId,\n                CTAFlowStepId = r.CTAFlowStepId,\n                ButtonBundleJson = r.ButtonBundleJson\n            }).ToList();\n\n            var prev = db.ChangeTracker.AutoDetectChangesEnabled;\n            db.ChangeTracker.AutoDetectChangesEnabled = false;\n            await db.CampaignSendLogs.AddRangeAsync(entities, ct);\n            await db.SaveChangesAsync(ct);\n            db.ChangeTracker.AutoDetectChangesEnabled = prev;\n        }\n    }\n\n    public class BatchingOptions\n    {\n        public CampaignLogOptions CampaignLog { get; set; } = new();\n        public class CampaignLogOptions\n        {\n            public int FlushEveryMs { get; set; } = 500;\n            public int MaxBatchSize { get; set; } = 500;\n            public bool UseCopy { get; set; } = true;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Logging/ICampaignLogSink.cs",
      "sha256": "2bb93f46e441543c54cae578d67d0768ae0a459d621727f54c8eb390ec2cdf38",
      "language": "csharp",
      "size": 303,
      "content": "using System.Threading;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.CampaignTracking.Logging\n{\n    public interface ICampaignLogSink\n    {\n        void Enqueue(CampaignLogRecord rec);\n        int PendingCount { get; }\n        Task FlushAsync(CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Models/CampaignClickDailyAgg.cs",
      "sha256": "f73f8e07824860d62b98ba1112933870fd6c223a3a75ca759bccf5899d9e9ffd",
      "language": "csharp",
      "size": 571,
      "content": "// üìÑ Features/CampaignTracking/Models/CampaignClickDailyAgg.cs\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace xbytechat.api.Features.CampaignTracking.Worker\n{\n    [Table(\"CampaignClickDailyAgg\")]\n    public class CampaignClickDailyAgg\n    {\n        [Key] public Guid Id { get; set; }\n        public Guid CampaignId { get; set; }\n        public DateTime Day { get; set; } // date-only (store as date in migration)\n        public int ButtonIndex { get; set; }\n        public long Clicks { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Models/CampaignClickLog.cs",
      "sha256": "c955c29fed1ef4d960a247c80426a21493ab53a3b657a4a21083d2f617d309cb",
      "language": "csharp",
      "size": 1205,
      "content": "// üìÑ Features/CampaignTracking/Models/CampaignClickLog.cs\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace xbytechat.api.Features.CampaignTracking.Worker\n{\n    [Table(\"CampaignClickLogs\")]\n    public class CampaignClickLog\n    {\n        [Key] public Guid Id { get; set; }\n\n        public Guid? RunId { get; set; }\n        // FK through CampaignSendLog to CampaignId & ContactId\n        public Guid CampaignSendLogId { get; set; }\n\n        public Guid CampaignId { get; set; }      // denormalized for fast filtering\n        public Guid? ContactId { get; set; }      // denormalized if available\n\n        public int ButtonIndex { get; set; }\n\n        [MaxLength(120)]\n        public string ButtonTitle { get; set; } = \"\";\n\n        // NEW: \"web\" | \"call\" | \"whatsapp\" (lowercase)\n        [MaxLength(16)]\n        public string ClickType { get; set; } = \"web\";\n\n        [MaxLength(2048)]\n        public string Destination { get; set; } = \"\";\n\n        [MaxLength(64)]\n        public string Ip { get; set; } = \"\";\n\n        [MaxLength(512)]\n        public string UserAgent { get; set; } = \"\";\n\n        public DateTime ClickedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Models/CampaignSendLog.cs",
      "sha256": "9dbb49fb807aab2988868a2469e54f7563ce603881667f3d6227659b312f8ba6",
      "language": "csharp",
      "size": 2955,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\nusing xbytechat.api.Features.CampaignModule.Models;\nusing xbytechat.api.Features.CRM.Models;\n\nnamespace xbytechat.api.Features.CampaignTracking.Models\n{\n    public class CampaignSendLog\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        public Guid? RunId { get; set; }\n        public string? MessageId { get; set; } // Unique WAMID from WhatsApp\n        // üîó Foreign Keys\n    \n        public Guid CampaignId { get; set; }\n        public Campaign? Campaign { get; set; }\n\n \n        public Guid? ContactId { get; set; }\n\n        [Required]\n        public Guid RecipientId { get; set; }\n\n        // üì© Message Info\n        [Required]\n        public string MessageBody { get; set; } = \"\";\n\n        public string? TemplateId { get; set; }\n        public string? SendStatus { get; set; }\n        public string? ErrorMessage { get; set; }\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n        public string? CreatedBy { get; set; }\n\n        public DateTime? SentAt { get; set; }\n        public DateTime? DeliveredAt { get; set; }\n        public DateTime? ReadAt { get; set; }\n\n        // üåê Metadata\n        public string? IpAddress { get; set; }\n        public string? DeviceInfo { get; set; }\n        public string? MacAddress { get; set; }\n        public string? SourceChannel { get; set; }\n\n        // ‚úÖ UX-Derived\n        public string? DeviceType { get; set; }\n        public string? Browser { get; set; }\n        public string? Country { get; set; }\n        public string? City { get; set; }\n\n        // üìä Click Tracking\n        public bool IsClicked { get; set; } = false;\n        public DateTime? ClickedAt { get; set; }\n        public string? ClickType { get; set; }\n\n        // üîÅ Retry Tracking (üí° New)\n        public int RetryCount { get; set; } = 0;                 // Number of retry attempts\n        public DateTime? LastRetryAt { get; set; }               // When retry last happened\n        public string? LastRetryStatus { get; set; }             // Success / Failed\n        public bool AllowRetry { get; set; } = true;             // Flag to enable/disable retry\n\n        // üëÅ Navigation\n      \n        public Contact? Contact { get; set; }\n        public CampaignRecipient? Recipient { get; set; }\n\n\n        // üîó MessageLog reference (optional)\n        public Guid? MessageLogId { get; set; }\n        public MessageLog? MessageLog { get; set; }\n        [Required]\n        public Guid BusinessId { get; set; }\n\n        // üÜï Flow context snapshot for deterministic click resolution\n        public Guid? CTAFlowConfigId { get; set; }   // which flow this send belongs to (optional)\n        public Guid? CTAFlowStepId { get; set; }     // the entry step id (optional)\n\n        [Column(TypeName = \"text\")]\n        public string? ButtonBundleJson { get; set; }\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Services/CampaignAnalyticsService.cs",
      "sha256": "ee9163439146987bfeebca642b380b914f7a0d5dae6fc4b2468b798b06840b3e",
      "language": "csharp",
      "size": 5226,
      "content": "using Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.CampaignTracking.DTOs;\nusing xbytechat.api.Features.CampaignTracking.Models;\n\nnamespace xbytechat.api.Features.CampaignTracking.Services\n{\n\n\n    public class CampaignAnalyticsService : ICampaignAnalyticsService\n    {\n        private readonly AppDbContext _context;\n\n        public CampaignAnalyticsService(AppDbContext context)\n        {\n            _context = context;\n            //_context = context;\n        }\n\n        public async Task<CampaignStatusDashboardDto?> GetCampaignStatsAsync(Guid campaignId)\n        {\n            var logs = await _context.CampaignSendLogs\n                .Where(l => l.CampaignId == campaignId)\n                .ToListAsync();\n\n            if (!logs.Any()) return null;\n\n            return new CampaignStatusDashboardDto\n            {\n                CampaignId = campaignId,\n                TotalRecipients = logs.Count,\n                SentCount = logs.Count(l => l.SendStatus == \"Sent\"),\n                DeliveredCount = logs.Count(l => l.SendStatus == \"Delivered\"),\n                ReadCount = logs.Count(l => l.SendStatus == \"Read\"),\n                FailedCount = logs.Count(l => l.SendStatus == \"Failed\"),\n                FirstSentAt = logs.Min(l => l.SentAt),\n                LastSentAt = logs.Max(l => l.SentAt),\n                FirstReadAt = logs.Min(l => l.ReadAt),\n                LastReadAt = logs.Max(l => l.ReadAt)\n            };\n        }\n\n        //public async Task<IEnumerable<TopCampaignDto>> GetTopCampaignsAsync(Guid businessId, int count = 5)\n        //{\n        //    var campaignStats = await _context.CampaignSendLogs\n        //        .Where(log => log.BusinessId == businessId)\n        //        .GroupBy(log => log.CampaignId)\n        //        .Select(group => new\n        //        {\n        //            CampaignId = group.Key,\n        //            TotalSent = group.Count(),\n        //            TotalRead = group.Count(l => l.ReadAt != null),\n        //            TotalClicked = group.Count(l => l.ClickedAt != null)\n        //        })\n        //        .Where(s => s.TotalSent > 0)\n        //        .OrderByDescending(s => (double)s.TotalClicked / s.TotalSent)\n        //        .Take(count)\n        //        .ToListAsync();\n\n        //    if (!campaignStats.Any())\n        //    {\n        //        return new List<TopCampaignDto>();\n        //    }\n\n        //    var campaignIds = campaignStats.Select(s => s.CampaignId).ToList();\n        //    var campaigns = await _context.Campaigns\n        //        .Where(c => campaignIds.Contains(c.Id))\n        //        .ToDictionaryAsync(c => c.Id, c => c.Name);\n\n        //    return campaignStats.Select(s => new TopCampaignDto\n        //    {\n        //        CampaignId = s.CampaignId,\n        //        CampaignName = campaigns.GetValueOrDefault(s.CampaignId, \"Unnamed Campaign\"),\n        //        ReadRate = s.TotalSent > 0 ? Math.Round(((double)s.TotalRead / s.TotalSent) * 100, 2) : 0,\n        //        ClickThroughRate = s.TotalSent > 0 ? Math.Round(((double)s.TotalClicked / s.TotalSent) * 100, 2) : 0\n        //    });\n        //}\n\n\n\n        public async Task<IEnumerable<TopCampaignDto>> GetTopCampaignsAsync(Guid businessId, int count = 5)\n        {\n            if (count <= 0) count = 5;\n\n            // If you suspect legacy rows with Guid.Empty, keep the extra filter; otherwise you can drop it.\n            var campaignStats = await _context.CampaignSendLogs\n                .AsNoTracking()\n                .Where(log => log.BusinessId == businessId /* && log.CampaignId != Guid.Empty */)\n                .GroupBy(log => log.CampaignId) // CampaignId is non-nullable Guid\n                .Select(group => new\n                {\n                    CampaignId = group.Key,\n                    TotalSent = group.Count(),\n                    TotalRead = group.Count(l => l.ReadAt != null),\n                    TotalClicked = group.Count(l => l.ClickedAt != null)\n                })\n                .Where(s => s.TotalSent > 0)\n                .OrderByDescending(s => (double)s.TotalClicked / s.TotalSent) // CTR first\n                .ThenByDescending(s => s.TotalSent)                           // tie-breaker: volume\n                .Take(count)\n                .ToListAsync();\n\n            if (campaignStats.Count == 0)\n                return Array.Empty<TopCampaignDto>();\n\n            var ids = campaignStats.Select(s => s.CampaignId).ToList();\n\n            var names = await _context.Campaigns\n                .AsNoTracking()\n                .Where(c => ids.Contains(c.Id))\n                .ToDictionaryAsync(c => c.Id, c => c.Name);\n\n            var result = campaignStats.Select(s => new TopCampaignDto\n            {\n                CampaignId = s.CampaignId,\n                CampaignName = names.TryGetValue(s.CampaignId, out var n) && !string.IsNullOrWhiteSpace(n)\n                                        ? n\n                                        : \"Unnamed Campaign\",\n                ReadRate = Math.Round((double)s.TotalRead / s.TotalSent * 100, 2),\n                ClickThroughRate = Math.Round((double)s.TotalClicked / s.TotalSent * 100, 2)\n            });\n\n            return result;\n        }\n\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Services/CampaignSendLogEnricher.cs",
      "sha256": "6d1155127869663e221b9c1a80e5dce49dd32c3d57d218d8157691ed3bc8edeb",
      "language": "csharp",
      "size": 872,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.CampaignTracking.Models;\nusing System;\n\nnamespace xbytechat.api.Features.CampaignTracking.Services\n{\n    public class CampaignSendLogEnricher : ICampaignSendLogEnricher\n    {\n        public async Task EnrichAsync(CampaignSendLog log, string userAgent, string ipAddress)\n        {\n            // üß† Device Detection (simplified for now)\n            log.DeviceInfo = userAgent;\n\n            // üåç IP Lookup - Mocked for now\n            if (!string.IsNullOrWhiteSpace(ipAddress))\n            {\n                log.IpAddress = ipAddress;\n                log.SourceChannel = \"API\"; // Example: mark origin\n                // Future: Use IPinfo or GeoLite2 for full location enrichment\n            }\n\n            // ‚åõ Simulate async task for compatibility\n            await Task.CompletedTask;\n        }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Services/CampaignSendLogService.cs",
      "sha256": "e7eedc36eb37b334a590d3e10a0605bf978738093bebd3cec998efa1df4c32b2",
      "language": "csharp",
      "size": 27995,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Data;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Npgsql;\nusing xbytechat.api;\nusing xbytechat.api.Features.CampaignTracking.DTOs;\nusing xbytechat.api.Features.CampaignTracking.Models;\nusing xbytechat.api.Features.CRM.Dtos;\n\nnamespace xbytechat.api.Features.CampaignTracking.Services\n{\n    public class CampaignSendLogService : ICampaignSendLogService\n    {\n        private readonly AppDbContext _context;\n        private readonly ICampaignSendLogEnricher _enricher;\n\n        public CampaignSendLogService(AppDbContext context, ICampaignSendLogEnricher enricher)\n        {\n            _context = context;\n            _enricher = enricher;\n        }\n\n        public async Task<PagedResult<CampaignSendLogDto>> GetLogsByCampaignIdAsync(\n            Guid campaignId, string? status, string? search, int page, int pageSize)\n        {\n            if (page <= 0) page = 1;\n            if (pageSize <= 0) pageSize = 10;\n\n            var q =\n                from log in _context.CampaignSendLogs.AsNoTracking()\n                where log.CampaignId == campaignId\n                join ml in _context.MessageLogs.AsNoTracking()\n                    on log.MessageLogId equals ml.Id into g\n                from ml in g.DefaultIfEmpty()\n                select new { log, ml };\n\n            if (!string.IsNullOrWhiteSpace(status))\n                q = q.Where(x => x.log.SendStatus == status);\n\n            if (!string.IsNullOrWhiteSpace(search))\n            {\n                var kw = search.Trim();\n                var kwLike = $\"%{kw}%\";\n\n                q = q.Where(x =>\n                    (x.log.Contact != null &&\n                        (EF.Functions.ILike(x.log.Contact.Name!, kwLike) ||\n                         x.log.Contact.PhoneNumber!.Contains(kw)))\n                    ||\n                    (x.ml != null && x.ml.RecipientNumber != null && x.ml.RecipientNumber.Contains(kw))\n                );\n            }\n\n            var total = await q.CountAsync();\n\n            var items = await q\n                .OrderByDescending(x => x.log.CreatedAt)\n                .Skip((page - 1) * pageSize)\n                .Take(pageSize)\n                .Select(x => new CampaignSendLogDto\n                {\n                    Id = x.log.Id,\n                    CampaignId = x.log.CampaignId,\n                    ContactId = x.log.ContactId,\n                    ContactName = x.log.Contact != null ? x.log.Contact.Name : \"N/A\",\n                    ContactPhone = x.log.Contact != null ? x.log.Contact.PhoneNumber : \"-\",\n                    RecipientNumber = x.ml != null ? x.ml.RecipientNumber : null,\n\n                    RecipientId = x.log.RecipientId,\n                    MessageBody = x.log.MessageBody,\n                    TemplateId = x.log.TemplateId,\n                    SendStatus = x.log.SendStatus,\n                    ErrorMessage = x.log.ErrorMessage,\n\n                    CreatedAt = x.log.CreatedAt,\n                    SentAt = x.log.SentAt,\n                    DeliveredAt = x.log.DeliveredAt,\n                    ReadAt = x.log.ReadAt,\n\n                    SourceChannel = x.log.SourceChannel,\n\n                    IsClicked = x.log.IsClicked,\n                    ClickedAt = x.log.ClickedAt,\n                    ClickType = x.log.ClickType,\n\n                    // ‚úÖ Retry mapping (DTO uses RetryStatus, model uses LastRetryStatus)\n                    RetryStatus = x.log.LastRetryStatus,\n                    RetryCount = x.log.RetryCount,\n                    LastRetryAt = x.log.LastRetryAt,\n\n                    IpAddress = x.log.IpAddress,\n                    DeviceInfo = x.log.DeviceInfo,\n                    MacAddress = x.log.MacAddress,\n\n                    DeviceType = x.log.DeviceType,\n                    Browser = x.log.Browser,\n                    Country = x.log.Country,\n                    City = x.log.City\n                })\n                .ToListAsync();\n\n            return new PagedResult<CampaignSendLogDto>\n            {\n                Items = items,\n                TotalCount = total,\n                Page = page,\n                PageSize = pageSize\n            };\n        }\n\n        public async Task<List<CampaignSendLogDto>> GetLogsForContactAsync(Guid campaignId, Guid contactId)\n        {\n            return await _context.CampaignSendLogs\n                .AsNoTracking()\n                .Where(log => log.CampaignId == campaignId && log.ContactId == contactId)\n                .OrderByDescending(log => log.CreatedAt)\n                .Select(log => new CampaignSendLogDto\n                {\n                    Id = log.Id,\n                    CampaignId = log.CampaignId,\n                    ContactId = log.ContactId,\n\n                    RecipientId = log.RecipientId,\n                    MessageBody = log.MessageBody,\n                    TemplateId = log.TemplateId,\n                    SendStatus = log.SendStatus,\n                    ErrorMessage = log.ErrorMessage,\n\n                    CreatedAt = log.CreatedAt,\n                    SentAt = log.SentAt,\n                    DeliveredAt = log.DeliveredAt,\n                    ReadAt = log.ReadAt,\n\n                    IpAddress = log.IpAddress,\n                    DeviceInfo = log.DeviceInfo,\n                    MacAddress = log.MacAddress,\n\n                    SourceChannel = log.SourceChannel,\n\n                    IsClicked = log.IsClicked,\n                    ClickedAt = log.ClickedAt,\n                    ClickType = log.ClickType,\n\n                    // ‚úÖ Retry mapping\n                    RetryStatus = log.LastRetryStatus,\n                    RetryCount = log.RetryCount,\n                    LastRetryAt = log.LastRetryAt\n                })\n                .ToListAsync();\n        }\n\n        // ‚úÖ IMPORTANT: DTO does not carry BusinessId.\n        // Derive BusinessId from Campaign for tenant-safe reporting.\n        public async Task<bool> AddSendLogAsync(CampaignSendLogDto dto, string ipAddress, string userAgent)\n        {\n            var businessId = await _context.Campaigns\n                .Where(c => c.Id == dto.CampaignId)\n                .Select(c => c.BusinessId)\n                .FirstOrDefaultAsync();\n\n            if (businessId == Guid.Empty)\n                return false;\n\n            var log = new CampaignSendLog\n            {\n                Id = Guid.NewGuid(),\n                BusinessId = businessId,\n\n                CampaignId = dto.CampaignId,\n                ContactId = dto.ContactId,\n\n                RecipientId = dto.RecipientId,\n                MessageBody = dto.MessageBody,\n                TemplateId = dto.TemplateId,\n\n                SendStatus = dto.SendStatus,\n                ErrorMessage = dto.ErrorMessage,\n\n                CreatedAt = DateTime.UtcNow,\n                SentAt = dto.SentAt,\n                DeliveredAt = dto.DeliveredAt,\n                ReadAt = dto.ReadAt,\n\n                SourceChannel = dto.SourceChannel,\n\n                IsClicked = dto.IsClicked,\n                ClickedAt = dto.ClickedAt,\n                ClickType = dto.ClickType,\n\n                // ‚úÖ Retry mapping\n                RetryCount = dto.RetryCount,\n                LastRetryAt = dto.LastRetryAt,\n                LastRetryStatus = dto.RetryStatus\n            };\n\n            await _enricher.EnrichAsync(log, userAgent, ipAddress);\n\n            _context.CampaignSendLogs.Add(log);\n            await _context.SaveChangesAsync();\n            return true;\n        }\n\n        public async Task<bool> UpdateDeliveryStatusAsync(Guid logId, string status, DateTime? deliveredAt, DateTime? readAt)\n        {\n            var log = await _context.CampaignSendLogs.FirstOrDefaultAsync(l => l.Id == logId);\n            if (log == null) return false;\n\n            log.SendStatus = status;\n            log.DeliveredAt = deliveredAt ?? log.DeliveredAt;\n            log.ReadAt = readAt ?? log.ReadAt;\n\n            await _context.SaveChangesAsync();\n            return true;\n        }\n\n        public async Task<bool> TrackClickAsync(Guid logId, string clickType)\n        {\n            var log = await _context.CampaignSendLogs.FirstOrDefaultAsync(l => l.Id == logId);\n            if (log == null) return false;\n\n            log.IsClicked = true;\n            log.ClickedAt = DateTime.UtcNow;\n            log.ClickType = clickType;\n\n            await _context.SaveChangesAsync();\n            return true;\n        }\n\n        public async Task<CampaignLogSummaryDto> GetCampaignSummaryAsync(\n            Guid campaignId,\n            DateTime? fromUtc,\n            DateTime? toUtc,\n            int repliedWindowDays,\n            Guid? runId)\n        {\n            if (repliedWindowDays < 0) repliedWindowDays = 0;\n            if (repliedWindowDays > 90) repliedWindowDays = 90;\n\n            var logs = _context.CampaignSendLogs\n                .AsNoTracking()\n                .Where(l => l.CampaignId == campaignId);\n\n            if (runId.HasValue)\n                logs = logs.Where(l => l.RunId == runId.Value);\n\n            if (fromUtc.HasValue)\n                logs = logs.Where(l =>\n                    (l.SentAt != null && l.SentAt >= fromUtc.Value) ||\n                    (l.SentAt == null && l.CreatedAt >= fromUtc.Value));\n\n            if (toUtc.HasValue)\n                logs = logs.Where(l =>\n                    (l.SentAt != null && l.SentAt <= toUtc.Value) ||\n                    (l.SentAt == null && l.CreatedAt <= toUtc.Value));\n\n            var baseSummary = await logs\n                .GroupBy(_ => 1)\n                .Select(g => new\n                {\n                    TotalRecipients = g.Count(),\n                    SentCount = g.Count(l => l.SendStatus != \"Failed\"),\n                    FailedCount = g.Count(l => l.SendStatus == \"Failed\"),\n                    ClickedCount = g.Count(l => l.IsClicked),\n                    DeliveredCount = g.Count(l => l.DeliveredAt != null),\n                    ReadCount = g.Count(l => l.ReadAt != null),\n                    LastSentAt = g.Max(l => l.SentAt)\n                })\n                .FirstOrDefaultAsync();\n\n            if (baseSummary == null)\n            {\n                return new CampaignLogSummaryDto\n                {\n                    ReplyWindowDays = repliedWindowDays,\n                    RepliedUniqueContacts = 0,\n                    TotalSent = 0,\n                    Sent = 0,\n                    Delivered = 0,\n                    Read = 0,\n                    FailedCount = 0,\n                    ClickedCount = 0,\n                    LastSentAt = null\n                };\n            }\n\n            // ‚úÖ Business-safe replied metric\n            var repliedUnique = await (\n                from l in logs\n                where l.ContactId != null\n                let anchor = (l.SentAt ?? l.CreatedAt)\n                join ml in _context.MessageLogs.AsNoTracking()\n                    on l.ContactId equals ml.ContactId\n                where ml.IsIncoming == true\n                      && ml.BusinessId == l.BusinessId\n                      && ml.CreatedAt >= anchor\n                      && ml.CreatedAt <= anchor.AddDays(repliedWindowDays)\n                select l.ContactId.Value\n            ).Distinct().CountAsync();\n\n            return new CampaignLogSummaryDto\n            {\n                TotalSent = baseSummary.TotalRecipients,\n                Sent = baseSummary.SentCount,\n                FailedCount = baseSummary.FailedCount,\n                ClickedCount = baseSummary.ClickedCount,\n                Delivered = baseSummary.DeliveredCount,\n                Read = baseSummary.ReadCount,\n                LastSentAt = baseSummary.LastSentAt,\n\n                RepliedUniqueContacts = repliedUnique,\n                ReplyWindowDays = repliedWindowDays\n            };\n        }\n\n        private async Task<long> ExecuteScalarLongAsync(string sql, CancellationToken ct, params NpgsqlParameter[] parameters)\n        {\n            var connString = _context.Database.GetDbConnection().ConnectionString;\n\n            await using var conn = new NpgsqlConnection(connString);\n            await conn.OpenAsync(ct);\n\n            await using var cmd = new NpgsqlCommand(sql, conn);\n            cmd.Parameters.AddRange(parameters);\n\n            var result = await cmd.ExecuteScalarAsync(ct);\n            return result == null || result == DBNull.Value ? 0 : Convert.ToInt64(result);\n        }\n\n        public async Task<PagedResult<CampaignContactListItemDto>> GetContactsByStatBucketAsync(\n            Guid campaignId,\n            string bucket,\n            DateTime? fromUtc,\n            DateTime? toUtc,\n            int repliedWindowDays,\n            Guid? runId,\n            string? search,\n            int page,\n            int pageSize)\n        {\n            if (page <= 0) page = 1;\n            if (pageSize <= 0) pageSize = 10;\n\n            bucket = (bucket ?? \"\").Trim().ToLowerInvariant();\n            if (repliedWindowDays < 0) repliedWindowDays = 0;\n            if (repliedWindowDays > 90) repliedWindowDays = 90;\n\n            var kw = string.IsNullOrWhiteSpace(search) ? null : search.Trim();\n            var kwLike = kw == null ? null : $\"%{kw}%\";\n            var offset = (page - 1) * pageSize;\n\n            string bucketWhere = bucket switch\n            {\n                \"sent\" => @\"AND l.\"\"SendStatus\"\" <> 'Failed'\",\n                \"failed\" => @\"AND l.\"\"SendStatus\"\" = 'Failed'\",\n                \"delivered\" => @\"AND l.\"\"DeliveredAt\"\" IS NOT NULL\",\n                \"read\" => @\"AND l.\"\"ReadAt\"\" IS NOT NULL\",\n                \"clicked\" => @\"AND l.\"\"IsClicked\"\" = TRUE\",\n                \"replied\" => @\"\",\n                _ => @\"\"\n            };\n\n            const string commonBaseFilters = @\"\nWHERE l.\"\"CampaignId\"\" = @campaignId\n  AND (@runId IS NULL OR l.\"\"RunId\"\" = @runId)\n  AND (\n        @fromUtc IS NULL OR\n        ((l.\"\"SentAt\"\" IS NOT NULL AND l.\"\"SentAt\"\" >= @fromUtc) OR (l.\"\"SentAt\"\" IS NULL AND l.\"\"CreatedAt\"\" >= @fromUtc))\n      )\n  AND (\n        @toUtc IS NULL OR\n        ((l.\"\"SentAt\"\" IS NOT NULL AND l.\"\"SentAt\"\" <= @toUtc) OR (l.\"\"SentAt\"\" IS NULL AND l.\"\"CreatedAt\"\" <= @toUtc))\n      )\n\";\n\n            const string searchFilter = @\"\n  AND (\n        @kw IS NULL OR\n        (c.\"\"Name\"\" IS NOT NULL AND c.\"\"Name\"\" ILIKE @kwLike) OR\n        (c.\"\"PhoneNumber\"\" IS NOT NULL AND c.\"\"PhoneNumber\"\" LIKE '%' || @kw || '%') OR\n        (ml.\"\"RecipientNumber\"\" IS NOT NULL AND ml.\"\"RecipientNumber\"\" LIKE '%' || @kw || '%')\n      )\n\";\n\n            if (bucket == \"replied\")\n            {\n                var countSql = $@\"\nWITH base AS (\n    SELECT\n        l.\"\"Id\"\"                           AS \"\"SendLogId\"\",\n        l.\"\"MessageLogId\"\"                 AS \"\"MessageLogId\"\",\n        l.\"\"RecipientId\"\"                  AS \"\"RecipientId\"\",\n        l.\"\"BusinessId\"\"                   AS \"\"BusinessId\"\",\n        l.\"\"ContactId\"\"                    AS \"\"ContactId\"\",\n        COALESCE(c.\"\"Name\"\", 'N/A')        AS \"\"ContactName\"\",\n        COALESCE(c.\"\"PhoneNumber\"\", '-')   AS \"\"ContactPhone\"\",\n        ml.\"\"RecipientNumber\"\"             AS \"\"RecipientNumber\"\",\n        l.\"\"SendStatus\"\"                   AS \"\"SendStatus\"\",\n        l.\"\"ErrorMessage\"\"                 AS \"\"ErrorMessage\"\",\n        l.\"\"IsClicked\"\"                    AS \"\"IsClicked\"\",\n        l.\"\"ClickType\"\"                    AS \"\"ClickType\"\",\n        l.\"\"ClickedAt\"\"                    AS \"\"ClickedAt\"\",\n        l.\"\"SentAt\"\"                       AS \"\"SentAt\"\",\n        l.\"\"DeliveredAt\"\"                  AS \"\"DeliveredAt\"\",\n        l.\"\"ReadAt\"\"                       AS \"\"ReadAt\"\",\n        COALESCE(l.\"\"SentAt\"\", l.\"\"CreatedAt\"\") AS \"\"Anchor\"\",\n        COALESCE(l.\"\"ReadAt\"\", l.\"\"DeliveredAt\"\", l.\"\"SentAt\"\", l.\"\"ClickedAt\"\", l.\"\"CreatedAt\"\") AS \"\"LastUpdatedAt\"\"\n    FROM \"\"CampaignSendLogs\"\" l\n    LEFT JOIN \"\"MessageLogs\"\" ml ON ml.\"\"Id\"\" = l.\"\"MessageLogId\"\"\n    LEFT JOIN \"\"Contacts\"\" c     ON c.\"\"Id\"\"  = l.\"\"ContactId\"\"\n    {commonBaseFilters}\n    AND l.\"\"ContactId\"\" IS NOT NULL\n    {searchFilter}\n),\ndedup AS (\n    SELECT DISTINCT ON (\"\"ContactId\"\")\n        *\n    FROM base\n    ORDER BY \"\"ContactId\"\", \"\"LastUpdatedAt\"\" DESC\n),\nreplied AS (\n    SELECT\n        d.*,\n        inbound.\"\"LastInboundAt\"\" AS \"\"LastInboundAt\"\"\n    FROM dedup d\n    JOIN LATERAL (\n        SELECT MAX(m.\"\"CreatedAt\"\") AS \"\"LastInboundAt\"\"\n        FROM \"\"MessageLogs\"\" m\n        WHERE m.\"\"BusinessId\"\" = d.\"\"BusinessId\"\"\n          AND m.\"\"ContactId\"\"  = d.\"\"ContactId\"\"\n          AND m.\"\"IsIncoming\"\" = TRUE\n          AND m.\"\"CreatedAt\"\" >= d.\"\"Anchor\"\"\n          AND m.\"\"CreatedAt\"\" <= d.\"\"Anchor\"\" + make_interval(days => @repliedWindowDays)\n    ) inbound ON inbound.\"\"LastInboundAt\"\" IS NOT NULL\n)\nSELECT COUNT(*)\nFROM replied;\n\";\n\n                var itemsSql = $@\"\nWITH base AS (\n    SELECT\n        l.\"\"Id\"\"                           AS \"\"SendLogId\"\",\n        l.\"\"MessageLogId\"\"                 AS \"\"MessageLogId\"\",\n        l.\"\"RecipientId\"\"                  AS \"\"RecipientId\"\",\n        l.\"\"BusinessId\"\"                   AS \"\"BusinessId\"\",\n        l.\"\"ContactId\"\"                    AS \"\"ContactId\"\",\n        COALESCE(c.\"\"Name\"\", 'N/A')        AS \"\"ContactName\"\",\n        COALESCE(c.\"\"PhoneNumber\"\", '-')   AS \"\"ContactPhone\"\",\n        ml.\"\"RecipientNumber\"\"             AS \"\"RecipientNumber\"\",\n        l.\"\"SendStatus\"\"                   AS \"\"SendStatus\"\",\n        l.\"\"ErrorMessage\"\"                 AS \"\"ErrorMessage\"\",\n        l.\"\"IsClicked\"\"                    AS \"\"IsClicked\"\",\n        l.\"\"ClickType\"\"                    AS \"\"ClickType\"\",\n        l.\"\"ClickedAt\"\"                    AS \"\"ClickedAt\"\",\n        l.\"\"SentAt\"\"                       AS \"\"SentAt\"\",\n        l.\"\"DeliveredAt\"\"                  AS \"\"DeliveredAt\"\",\n        l.\"\"ReadAt\"\"                       AS \"\"ReadAt\"\",\n        COALESCE(l.\"\"SentAt\"\", l.\"\"CreatedAt\"\") AS \"\"Anchor\"\",\n        COALESCE(l.\"\"ReadAt\"\", l.\"\"DeliveredAt\"\", l.\"\"SentAt\"\", l.\"\"ClickedAt\"\", l.\"\"CreatedAt\"\") AS \"\"LastUpdatedAt\"\"\n    FROM \"\"CampaignSendLogs\"\" l\n    LEFT JOIN \"\"MessageLogs\"\" ml ON ml.\"\"Id\"\" = l.\"\"MessageLogId\"\"\n    LEFT JOIN \"\"Contacts\"\" c     ON c.\"\"Id\"\"  = l.\"\"ContactId\"\"\n    {commonBaseFilters}\n    AND l.\"\"ContactId\"\" IS NOT NULL\n    {searchFilter}\n),\ndedup AS (\n    SELECT DISTINCT ON (\"\"ContactId\"\")\n        *\n    FROM base\n    ORDER BY \"\"ContactId\"\", \"\"LastUpdatedAt\"\" DESC\n),\nreplied AS (\n    SELECT\n        d.*,\n        inbound.\"\"LastInboundAt\"\" AS \"\"LastInboundAt\"\"\n    FROM dedup d\n    JOIN LATERAL (\n        SELECT MAX(m.\"\"CreatedAt\"\") AS \"\"LastInboundAt\"\"\n        FROM \"\"MessageLogs\"\" m\n        WHERE m.\"\"BusinessId\"\" = d.\"\"BusinessId\"\"\n          AND m.\"\"ContactId\"\"  = d.\"\"ContactId\"\"\n          AND m.\"\"IsIncoming\"\" = TRUE\n          AND m.\"\"CreatedAt\"\" >= d.\"\"Anchor\"\"\n          AND m.\"\"CreatedAt\"\" <= d.\"\"Anchor\"\" + make_interval(days => @repliedWindowDays)\n    ) inbound ON inbound.\"\"LastInboundAt\"\" IS NOT NULL\n)\nSELECT\n    \"\"SendLogId\"\"        AS \"\"SendLogId\"\",\n    \"\"MessageLogId\"\"     AS \"\"MessageLogId\"\",\n    \"\"RecipientId\"\"      AS \"\"RecipientId\"\",\n    \"\"ContactId\"\"        AS \"\"ContactId\"\",\n    \"\"ContactName\"\"      AS \"\"ContactName\"\",\n    \"\"ContactPhone\"\"     AS \"\"ContactPhone\"\",\n    \"\"RecipientNumber\"\"  AS \"\"RecipientNumber\"\",\n    \"\"SendStatus\"\"       AS \"\"SendStatus\"\",\n    \"\"ErrorMessage\"\"     AS \"\"ErrorMessage\"\",\n    \"\"IsClicked\"\"        AS \"\"IsClicked\"\",\n    \"\"ClickType\"\"        AS \"\"ClickType\"\",\n    \"\"ClickedAt\"\"        AS \"\"ClickedAt\"\",\n    \"\"SentAt\"\"           AS \"\"SentAt\"\",\n    \"\"DeliveredAt\"\"      AS \"\"DeliveredAt\"\",\n    \"\"ReadAt\"\"           AS \"\"ReadAt\"\",\n    \"\"LastInboundAt\"\"    AS \"\"LastInboundAt\"\",\n    \"\"LastUpdatedAt\"\"    AS \"\"LastUpdatedAt\"\"\nFROM replied\nORDER BY \"\"LastInboundAt\"\" DESC\nOFFSET @offset\nLIMIT @pageSize;\n\";\n\n                // ‚úÖ Use SqlQueryRaw + object[] => no ‚Äútakes 9 arguments‚Äù compile error.\n                var total = await _context.Database\n                    .SqlQueryRaw<long>(\n                        countSql,\n                        new object[]\n                        {\n                            new NpgsqlParameter(\"campaignId\", campaignId),\n                            new NpgsqlParameter(\"runId\", (object?)runId ?? DBNull.Value),\n                            new NpgsqlParameter(\"fromUtc\", (object?)fromUtc ?? DBNull.Value),\n                            new NpgsqlParameter(\"toUtc\", (object?)toUtc ?? DBNull.Value),\n                            new NpgsqlParameter(\"kw\", (object?)kw ?? DBNull.Value),\n                            new NpgsqlParameter(\"kwLike\", (object?)kwLike ?? DBNull.Value),\n                            new NpgsqlParameter(\"repliedWindowDays\", repliedWindowDays)\n                        })\n                    .SingleAsync();\n\n                var items = await _context.Database\n                    .SqlQueryRaw<CampaignContactListItemDto>(\n                        itemsSql,\n                        new object[]\n                        {\n                            new NpgsqlParameter(\"campaignId\", campaignId),\n                            new NpgsqlParameter(\"runId\", (object?)runId ?? DBNull.Value),\n                            new NpgsqlParameter(\"fromUtc\", (object?)fromUtc ?? DBNull.Value),\n                            new NpgsqlParameter(\"toUtc\", (object?)toUtc ?? DBNull.Value),\n                            new NpgsqlParameter(\"kw\", (object?)kw ?? DBNull.Value),\n                            new NpgsqlParameter(\"kwLike\", (object?)kwLike ?? DBNull.Value),\n                            new NpgsqlParameter(\"repliedWindowDays\", repliedWindowDays),\n                            new NpgsqlParameter(\"offset\", offset),\n                            new NpgsqlParameter(\"pageSize\", pageSize)\n                        })\n                    .ToListAsync();\n\n                return new PagedResult<CampaignContactListItemDto>\n                {\n                    Items = items,\n                    TotalCount = (int)total,\n                    Page = page,\n                    PageSize = pageSize\n                };\n            }\n            else\n            {\n                var countSql = $@\"\nWITH base AS (\n    SELECT\n        l.\"\"Id\"\"                           AS \"\"SendLogId\"\",\n        l.\"\"MessageLogId\"\"                 AS \"\"MessageLogId\"\",\n        l.\"\"RecipientId\"\"                  AS \"\"RecipientId\"\",\n        l.\"\"ContactId\"\"                    AS \"\"ContactId\"\",\n        COALESCE(c.\"\"Name\"\", 'N/A')        AS \"\"ContactName\"\",\n        COALESCE(c.\"\"PhoneNumber\"\", '-')   AS \"\"ContactPhone\"\",\n        ml.\"\"RecipientNumber\"\"             AS \"\"RecipientNumber\"\",\n        l.\"\"SendStatus\"\"                   AS \"\"SendStatus\"\",\n        l.\"\"ErrorMessage\"\"                 AS \"\"ErrorMessage\"\",\n        l.\"\"IsClicked\"\"                    AS \"\"IsClicked\"\",\n        l.\"\"ClickType\"\"                    AS \"\"ClickType\"\",\n        l.\"\"ClickedAt\"\"                    AS \"\"ClickedAt\"\",\n        l.\"\"SentAt\"\"                       AS \"\"SentAt\"\",\n        l.\"\"DeliveredAt\"\"                  AS \"\"DeliveredAt\"\",\n        l.\"\"ReadAt\"\"                       AS \"\"ReadAt\"\",\n        COALESCE(l.\"\"ReadAt\"\", l.\"\"DeliveredAt\"\", l.\"\"SentAt\"\", l.\"\"ClickedAt\"\", l.\"\"CreatedAt\"\") AS \"\"LastUpdatedAt\"\",\n        COALESCE(l.\"\"ContactId\"\"::text, ml.\"\"RecipientNumber\"\") AS \"\"GroupKey\"\"\n    FROM \"\"CampaignSendLogs\"\" l\n    LEFT JOIN \"\"MessageLogs\"\" ml ON ml.\"\"Id\"\" = l.\"\"MessageLogId\"\"\n    LEFT JOIN \"\"Contacts\"\" c     ON c.\"\"Id\"\"  = l.\"\"ContactId\"\"\n    {commonBaseFilters}\n    {bucketWhere}\n    {searchFilter}\n),\ndedup AS (\n    SELECT DISTINCT ON (\"\"GroupKey\"\")\n        *\n    FROM base\n    ORDER BY \"\"GroupKey\"\", \"\"LastUpdatedAt\"\" DESC\n)\nSELECT COUNT(*) FROM dedup;\n\";\n\n                var itemsSql = $@\"\nWITH base AS (\n    SELECT\n        l.\"\"Id\"\"                           AS \"\"SendLogId\"\",\n        l.\"\"MessageLogId\"\"                 AS \"\"MessageLogId\"\",\n        l.\"\"RecipientId\"\"                  AS \"\"RecipientId\"\",\n        l.\"\"ContactId\"\"                    AS \"\"ContactId\"\",\n        COALESCE(c.\"\"Name\"\", 'N/A')        AS \"\"ContactName\"\",\n        COALESCE(c.\"\"PhoneNumber\"\", '-')   AS \"\"ContactPhone\"\",\n        ml.\"\"RecipientNumber\"\"             AS \"\"RecipientNumber\"\",\n        l.\"\"SendStatus\"\"                   AS \"\"SendStatus\"\",\n        l.\"\"ErrorMessage\"\"                 AS \"\"ErrorMessage\"\",\n        l.\"\"IsClicked\"\"                    AS \"\"IsClicked\"\",\n        l.\"\"ClickType\"\"                    AS \"\"ClickType\"\",\n        l.\"\"ClickedAt\"\"                    AS \"\"ClickedAt\"\",\n        l.\"\"SentAt\"\"                       AS \"\"SentAt\"\",\n        l.\"\"DeliveredAt\"\"                  AS \"\"DeliveredAt\"\",\n        l.\"\"ReadAt\"\"                       AS \"\"ReadAt\"\",\n        COALESCE(l.\"\"ReadAt\"\", l.\"\"DeliveredAt\"\", l.\"\"SentAt\"\", l.\"\"ClickedAt\"\", l.\"\"CreatedAt\"\") AS \"\"LastUpdatedAt\"\",\n        COALESCE(l.\"\"ContactId\"\"::text, ml.\"\"RecipientNumber\"\") AS \"\"GroupKey\"\"\n    FROM \"\"CampaignSendLogs\"\" l\n    LEFT JOIN \"\"MessageLogs\"\" ml ON ml.\"\"Id\"\" = l.\"\"MessageLogId\"\"\n    LEFT JOIN \"\"Contacts\"\" c     ON c.\"\"Id\"\"  = l.\"\"ContactId\"\"\n    {commonBaseFilters}\n    {bucketWhere}\n    {searchFilter}\n),\ndedup AS (\n    SELECT DISTINCT ON (\"\"GroupKey\"\")\n        *\n    FROM base\n    ORDER BY \"\"GroupKey\"\", \"\"LastUpdatedAt\"\" DESC\n)\nSELECT\n    \"\"SendLogId\"\"        AS \"\"SendLogId\"\",\n    \"\"MessageLogId\"\"     AS \"\"MessageLogId\"\",\n    \"\"RecipientId\"\"      AS \"\"RecipientId\"\",\n    \"\"ContactId\"\"        AS \"\"ContactId\"\",\n    \"\"ContactName\"\"      AS \"\"ContactName\"\",\n    \"\"ContactPhone\"\"     AS \"\"ContactPhone\"\",\n    \"\"RecipientNumber\"\"  AS \"\"RecipientNumber\"\",\n    \"\"SendStatus\"\"       AS \"\"SendStatus\"\",\n    \"\"ErrorMessage\"\"     AS \"\"ErrorMessage\"\",\n    \"\"IsClicked\"\"        AS \"\"IsClicked\"\",\n    \"\"ClickType\"\"        AS \"\"ClickType\"\",\n    \"\"ClickedAt\"\"        AS \"\"ClickedAt\"\",\n    \"\"SentAt\"\"           AS \"\"SentAt\"\",\n    \"\"DeliveredAt\"\"      AS \"\"DeliveredAt\"\",\n    \"\"ReadAt\"\"           AS \"\"ReadAt\"\",\n    NULL::timestamptz    AS \"\"LastInboundAt\"\",\n    \"\"LastUpdatedAt\"\"    AS \"\"LastUpdatedAt\"\"\nFROM dedup\nORDER BY \"\"LastUpdatedAt\"\" DESC\nOFFSET @offset\nLIMIT @pageSize;\n\";\n\n                var total = await _context.Database\n                    .SqlQueryRaw<long>(\n                        countSql,\n                        new object[]\n                        {\n                            new NpgsqlParameter(\"campaignId\", campaignId),\n                            new NpgsqlParameter(\"runId\", (object?)runId ?? DBNull.Value),\n                            new NpgsqlParameter(\"fromUtc\", (object?)fromUtc ?? DBNull.Value),\n                            new NpgsqlParameter(\"toUtc\", (object?)toUtc ?? DBNull.Value),\n                            new NpgsqlParameter(\"kw\", (object?)kw ?? DBNull.Value),\n                            new NpgsqlParameter(\"kwLike\", (object?)kwLike ?? DBNull.Value)\n                        })\n                    .SingleAsync();\n\n                var items = await _context.Database\n                    .SqlQueryRaw<CampaignContactListItemDto>(\n                        itemsSql,\n                        new object[]\n                        {\n                            new NpgsqlParameter(\"campaignId\", campaignId),\n                            new NpgsqlParameter(\"runId\", (object?)runId ?? DBNull.Value),\n                            new NpgsqlParameter(\"fromUtc\", (object?)fromUtc ?? DBNull.Value),\n                            new NpgsqlParameter(\"toUtc\", (object?)toUtc ?? DBNull.Value),\n                            new NpgsqlParameter(\"kw\", (object?)kw ?? DBNull.Value),\n                            new NpgsqlParameter(\"kwLike\", (object?)kwLike ?? DBNull.Value),\n                            new NpgsqlParameter(\"offset\", offset),\n                            new NpgsqlParameter(\"pageSize\", pageSize)\n                        })\n                    .ToListAsync();\n\n                return new PagedResult<CampaignContactListItemDto>\n                {\n                    Items = items,\n                    TotalCount = (int)total,\n                    Page = page,\n                    PageSize = pageSize\n                };\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Services/CampaignTrackingRetryService.cs",
      "sha256": "7b60dddd6aceae08b86da9813190186180881e6fc9efd8dc1190e497b51f9af1",
      "language": "csharp",
      "size": 2935,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api;\nusing xbytechat.api.Features.CampaignTracking.Models;\n\nnamespace xbytechat.api.Features.CampaignTracking.Services\n{\n    public class CampaignTrackingRetryService : ICampaignTrackingRetryService\n    {\n        private readonly AppDbContext _context;\n\n        public CampaignTrackingRetryService(AppDbContext context)\n        {\n            _context = context;\n        }\n\n        // ‚úÖ Public method: Retry a single failed log\n        public async Task<bool> RetrySingleAsync(Guid logId)\n        {\n            return await RetrySendLogAsync(logId);\n        }\n\n        // ‚úÖ Public method: Retry all failed logs in a campaign\n        public async Task<int> RetryFailedInCampaignAsync(Guid campaignId)\n        {\n            return await RetryAllFailedInCampaignAsync(campaignId);\n        }\n\n        // üîÅ Private: Retry a specific log\n        private async Task<bool> RetrySendLogAsync(Guid logId)\n        {\n            var log = await _context.CampaignSendLogs.FirstOrDefaultAsync(x => x.Id == logId);\n\n            if (log == null || log.SendStatus != \"Failed\" || !log.AllowRetry)\n                return false;\n\n            // üîÑ Simulate re-send (replace with actual IMessageService.SendAsync later)\n            bool sent = SimulateSendMessage(log);\n\n            log.RetryCount += 1;\n            log.LastRetryAt = DateTime.UtcNow;\n            log.LastRetryStatus = sent ? \"Sent\" : \"Failed\";\n            log.SendStatus = sent ? \"Sent\" : \"Failed\";\n            log.ErrorMessage = sent ? null : \"Mock failure on retry\";\n\n            await _context.SaveChangesAsync();\n            return sent;\n        }\n\n        // üîÅ Private: Retry all failed logs in a given campaign\n        private async Task<int> RetryAllFailedInCampaignAsync(Guid campaignId)\n        {\n            var failedLogs = await _context.CampaignSendLogs\n                .Where(log => log.CampaignId == campaignId && log.SendStatus == \"Failed\" && log.AllowRetry)\n                .ToListAsync();\n\n            int successCount = 0;\n\n            foreach (var log in failedLogs)\n            {\n                bool sent = SimulateSendMessage(log);\n\n                log.RetryCount += 1;\n                log.LastRetryAt = DateTime.UtcNow;\n                log.LastRetryStatus = sent ? \"Sent\" : \"Failed\";\n                log.SendStatus = sent ? \"Sent\" : \"Failed\";\n                log.ErrorMessage = sent ? null : \"Mock failure on retry\";\n\n                if (sent) successCount++;\n            }\n\n            await _context.SaveChangesAsync();\n            return successCount;\n        }\n\n        // üîß Simulated send (replace with actual WhatsApp message logic)\n        private bool SimulateSendMessage(CampaignSendLog log)\n        {\n            return new Random().NextDouble() < 0.9; // 90% success rate\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Services/ClickTokenService.cs",
      "sha256": "b80c48d547509139d45775d1f8447eceeec7d399e27cd9a55c20dc1aecb854fb",
      "language": "csharp",
      "size": 3152,
      "content": "// üìÑ Features/CampaignTracking/Services/ClickTokenService.cs\nusing System.Security.Cryptography;\nusing System.Text;\nusing System.Text.Json;\nusing Microsoft.AspNetCore.WebUtilities;\nusing Microsoft.Extensions.Options;\nusing xbytechat.api.Features.CampaignTracking.Config;\n\nnamespace xbytechat.api.Features.CampaignTracking.Services\n{\n    public record ClickTokenPayload(\n        Guid cid,            // CampaignSendLogId\n        int bi,              // button index\n        string bt,           // button title (optional)\n        string to,           // destination absolute URL\n        long iat,            // issued at (unix seconds)\n        long exp             // expiry (unix seconds)\n    );\n\n    public interface IClickTokenService\n    {\n        string Create(ClickTokenPayload payload);\n        bool TryValidate(string token, out ClickTokenPayload? payload, out string? error);\n    }\n\n    public class ClickTokenService : IClickTokenService\n    {\n        private readonly byte[] _key;\n\n        public ClickTokenService(IOptions<TrackingOptions> opt)\n        {\n            _key = Encoding.UTF8.GetBytes(opt.Value.Secret ?? throw new ArgumentNullException(nameof(opt.Value.Secret)));\n        }\n\n        public string Create(ClickTokenPayload payload)\n        {\n            var json = JsonSerializer.Serialize(payload);\n            var data = Encoding.UTF8.GetBytes(json);\n            var body = WebEncoders.Base64UrlEncode(data);\n\n            var sig = ComputeHmac(body);\n            return $\"{body}.{sig}\";\n        }\n\n        public bool TryValidate(string token, out ClickTokenPayload? payload, out string? error)\n        {\n            payload = null;\n            error = null;\n\n            var parts = token.Split('.');\n            if (parts.Length != 2) { error = \"format\"; return false; }\n\n            var body = parts[0];\n            var sig = parts[1];\n\n            var expected = ComputeHmac(body);\n            // timing-safe compare\n            if (!CryptographicOperations.FixedTimeEquals(Encoding.UTF8.GetBytes(sig), Encoding.UTF8.GetBytes(expected)))\n            { error = \"bad-signature\"; return false; }\n\n            try\n            {\n                var bytes = WebEncoders.Base64UrlDecode(body);\n                var obj = JsonSerializer.Deserialize<ClickTokenPayload>(bytes);\n                if (obj is null) { error = \"decode\"; return false; }\n\n                var now = DateTimeOffset.UtcNow.ToUnixTimeSeconds();\n                if (now > obj.exp) { error = \"expired\"; return false; }\n\n                // minimal URL sanity check\n                if (!Uri.TryCreate(obj.to, UriKind.Absolute, out var _)) { error = \"bad-destination\"; return false; }\n\n                payload = obj;\n                return true;\n            }\n            catch (Exception ex)\n            {\n                error = \"exception:\" + ex.GetType().Name;\n                return false;\n            }\n        }\n\n        private string ComputeHmac(string body)\n        {\n            using var h = new HMACSHA256(_key);\n            var sig = h.ComputeHash(Encoding.UTF8.GetBytes(body));\n            return WebEncoders.Base64UrlEncode(sig);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Services/ICampaignAnalyticsService.cs",
      "sha256": "c4c188f0eba3b537c076a7fc42ef62094de1ced491abcaecb619097e40debb8b",
      "language": "csharp",
      "size": 437,
      "content": "using xbytechat.api.Features.CampaignTracking.DTOs;\n\nnamespace xbytechat.api.Features.CampaignTracking.Services\n{\n    public interface ICampaignAnalyticsService\n    {\n       // Task<CampaignStatusDashboardDto> GetStatusDashboardAsync(Guid businessId);\n        Task<IEnumerable<TopCampaignDto>> GetTopCampaignsAsync(Guid businessId, int count = 5);\n        Task<CampaignStatusDashboardDto?> GetCampaignStatsAsync(Guid campaignId);\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Services/ICampaignSendLogEnricher.cs",
      "sha256": "9204a2182522e06e53fe6beb21100820231943995d044f01feb200bdcaa521de",
      "language": "csharp",
      "size": 290,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.CampaignTracking.Models;\n\nnamespace xbytechat.api.Features.CampaignTracking.Services\n{\n    public interface ICampaignSendLogEnricher\n    {\n        Task EnrichAsync(CampaignSendLog log, string userAgent, string ipAddress);\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Services/ICampaignSendLogService.cs",
      "sha256": "ee8aaaf915449983c605cb494fc80598171d66653b38178c210b08e1ee4adcbb",
      "language": "csharp",
      "size": 1374,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CampaignTracking.DTOs;\nusing xbytechat.api.Features.CRM.Dtos;\n\nnamespace xbytechat.api.Features.CampaignTracking.Services\n{\n    public interface ICampaignSendLogService\n    {\n        Task<PagedResult<CampaignSendLogDto>> GetLogsByCampaignIdAsync(\n            Guid campaignId, string? status, string? search, int page, int pageSize);\n\n        Task<List<CampaignSendLogDto>> GetLogsForContactAsync(Guid campaignId, Guid contactId);\n\n        Task<bool> AddSendLogAsync(CampaignSendLogDto dto, string ipAddress, string userAgent);\n\n        Task<bool> UpdateDeliveryStatusAsync(Guid logId, string status, DateTime? deliveredAt, DateTime? readAt);\n\n        Task<bool> TrackClickAsync(Guid logId, string clickType);\n\n        Task<CampaignLogSummaryDto> GetCampaignSummaryAsync(\n            Guid campaignId,\n            DateTime? fromUtc,\n            DateTime? toUtc,\n            int repliedWindowDays,\n            Guid? runId);\n\n        Task<PagedResult<CampaignContactListItemDto>> GetContactsByStatBucketAsync(\n            Guid campaignId,\n            string bucket,\n            DateTime? fromUtc,\n            DateTime? toUtc,\n            int repliedWindowDays,\n            Guid? runId,\n            string? search,\n            int page,\n            int pageSize);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Services/ICampaignTrackingRetryService.cs",
      "sha256": "0ea3dd070b8b87ab800873972e6200421e942c4e4536a316a8623bd7108e72ec",
      "language": "csharp",
      "size": 554,
      "content": "using System;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.CampaignTracking.Services\n{\n    public interface ICampaignTrackingRetryService\n    {\n\n        // Retry a single failed message log by its ID.\n        // will be used when user clicks \"Retry Now\" on a log row.\n        Task<bool> RetrySingleAsync(Guid logId);\n\n\n        // Retry all failed messages in a campaign where retry is allowed.\n        // will support \"Retry All Failed\" button from Campaign logs.\n        Task<int> RetryFailedInCampaignAsync(Guid campaignId);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Worker/ClickEvent.cs",
      "sha256": "feba0a8efef3e111690aeca876198178018024d5c39d3415d1cb3db163a8e52e",
      "language": "csharp",
      "size": 380,
      "content": "// Features/CampaignTracking/Worker/ClickEvent.cs\nnamespace xbytechat.api.Features.CampaignTracking.Worker\n{\n    public sealed record ClickEvent(\n        Guid CampaignSendLogId,\n        int ButtonIndex,\n        string ButtonTitle,\n        string Destination,\n        DateTime ClickedAtUtc,\n        string Ip,\n        string UserAgent,\n         string ClickType\n         \n    );\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Worker/ClickLogWorker.cs",
      "sha256": "6c5f66aa812a1532420b44d66e9a0d9b72234af71077dbb32151c78d78d30a97",
      "language": "csharp",
      "size": 8009,
      "content": "using Microsoft.EntityFrameworkCore;\nusing xbytechat.api;\n\nnamespace xbytechat.api.Features.CampaignTracking.Worker\n{\n    public sealed class ClickLogWorker : BackgroundService\n    {\n        private readonly ILogger<ClickLogWorker> _log;\n        private readonly IClickEventQueue _queue;\n        private readonly IServiceScopeFactory _scopeFactory;\n\n        public ClickLogWorker(\n            ILogger<ClickLogWorker> log,\n            IClickEventQueue queue,\n            IServiceScopeFactory scopeFactory)\n        {\n            _log = log;\n            _queue = queue;\n            _scopeFactory = scopeFactory;\n        }\n\n        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n        {\n            _log.LogInformation(\"ClickLogWorker started\");\n\n            while (!stoppingToken.IsCancellationRequested)\n            {\n                List<ClickEvent> batch;\n                try\n                {\n                    batch = await _queue.ReadBatchAsync(200, TimeSpan.FromSeconds(1), stoppingToken);\n                    if (batch.Count == 0) continue;\n\n                    // quick visibility: confirm we are ingesting call/whatsapp/web events\n                    var byType = batch.GroupBy(e => e.ClickType ?? \"web\")\n                                      .Select(g => $\"{g.Key}:{g.Count()}\")\n                                      .ToArray();\n                    _log.LogInformation(\"WORKER processing {Count} events [{Kinds}]\",\n                        batch.Count, string.Join(\", \", byType));\n                }\n                catch (OperationCanceledException)\n                {\n                    break;\n                }\n                catch (Exception ex)\n                {\n                    _log.LogError(ex, \"Queue read failed; retrying\");\n                    try { await Task.Delay(500, stoppingToken); } catch { /* ignore */ }\n                    continue;\n                }\n\n                // nothing to do\n                if (batch.Count == 0) continue;\n\n                try\n                {\n                    using var scope = _scopeFactory.CreateScope();\n                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n\n                    // Prefetch CampaignId for this batch (we only need CampaignId for the aggregates)\n                    var sendIds = batch.Select(b => b.CampaignSendLogId).Distinct().ToList();\n                    if (sendIds.Count == 0) continue;\n\n                    var sendMap = await db.CampaignSendLogs\n                        .Where(s => sendIds.Contains(s.Id))\n                        .Select(s => new { s.Id, s.CampaignId })\n                        .ToDictionaryAsync(s => s.Id, s => s.CampaignId, stoppingToken);\n\n                    // Prepare aggregate groups: (CampaignId, Day, ButtonIndex) -> count\n                    var groups = batch\n                        .Select(e =>\n                        {\n                            sendMap.TryGetValue(e.CampaignSendLogId, out var campaignId);\n                            return new { CampaignId = campaignId, Day = e.ClickedAtUtc.Date, e.ButtonIndex };\n                        })\n                        .Where(x => x.CampaignId != Guid.Empty)\n                        .GroupBy(x => new { x.CampaignId, x.Day, x.ButtonIndex })\n                        .Select(g => new { g.Key.CampaignId, g.Key.Day, g.Key.ButtonIndex, Count = g.Count() })\n                        .ToList();\n\n                    if (groups.Count == 0) continue;\n\n                    foreach (var g in groups)\n                    {\n                        await db.Database.ExecuteSqlRawAsync(@\"\n                    insert into \"\"CampaignClickDailyAgg\"\" (\"\"CampaignId\"\", \"\"Day\"\", \"\"ButtonIndex\"\", \"\"Clicks\"\")\n                    values ({0}, {1}, {2}, {3})\n                    on conflict (\"\"CampaignId\"\", \"\"Day\"\", \"\"ButtonIndex\"\")\n                    do update set \"\"Clicks\"\" = \"\"CampaignClickDailyAgg\"\".\"\"Clicks\"\" + {3};\",\n                            g.CampaignId, g.Day, g.ButtonIndex, g.Count);\n                    }\n                }\n                catch (Exception ex)\n                {\n                    _log.LogError(ex, \"Aggregate update failed; skipped this batch.\");\n                }\n            }\n\n            _log.LogInformation(\"ClickLogWorker stopped\");\n        }\n    }\n}\n\n\n//using Microsoft.EntityFrameworkCore;\n//using xbytechat.api;\n\n//namespace xbytechat.api.Features.CampaignTracking.Worker\n//{\n//    public sealed class ClickLogWorker : BackgroundService\n//    {\n//        private readonly ILogger<ClickLogWorker> _log;\n//        private readonly IClickEventQueue _queue;\n//        private readonly IServiceScopeFactory _scopeFactory;\n\n//        public ClickLogWorker(\n//            ILogger<ClickLogWorker> log,\n//            IClickEventQueue queue,\n//            IServiceScopeFactory scopeFactory)\n//        {\n//            _log = log;\n//            _queue = queue;\n//            _scopeFactory = scopeFactory;\n//        }\n\n//        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n//        {\n//            _log.LogInformation(\"ClickLogWorker started\");\n\n//            while (!stoppingToken.IsCancellationRequested)\n//            {\n//                List<ClickEvent> batch;\n//                try\n//                {\n//                    batch = await _queue.ReadBatchAsync(200, TimeSpan.FromSeconds(1), stoppingToken);\n//                    if (batch.Count == 0) continue;\n//                    _log.LogInformation(\"WORKER processing {Count} events (aggregates only)\", batch.Count);\n//                }\n//                catch (OperationCanceledException) { break; }\n//                catch (Exception ex)\n//                {\n//                    _log.LogError(ex, \"Queue read failed; retrying\");\n//                    try { await Task.Delay(500, stoppingToken); } catch { }\n//                    continue;\n//                }\n\n//                try\n//                {\n//                    using var scope = _scopeFactory.CreateScope();\n//                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n\n//                    // Prefetch CampaignId for this batch\n//                    var sendIds = batch.Select(b => b.CampaignSendLogId).Distinct().ToList();\n//                    var sendMap = await db.CampaignSendLogs\n//                        .Where(s => sendIds.Contains(s.Id))\n//                        .Select(s => new { s.Id, s.CampaignId })\n//                        .ToDictionaryAsync(s => s.Id, s => s.CampaignId, stoppingToken);\n\n//                    // Build aggregate groups\n//                    var groups = batch\n//                        .Select(e =>\n//                        {\n//                            sendMap.TryGetValue(e.CampaignSendLogId, out var campaignId);\n//                            return new { CampaignId = campaignId, Day = e.ClickedAtUtc.Date, e.ButtonIndex };\n//                        })\n//                        .Where(x => x.CampaignId != Guid.Empty)\n//                        .GroupBy(x => new { x.CampaignId, x.Day, x.ButtonIndex })\n//                        .Select(g => new { g.Key.CampaignId, g.Key.Day, g.Key.ButtonIndex, Count = g.Count() })\n//                        .ToList();\n\n//                    foreach (var g in groups)\n//                    {\n//                        await db.Database.ExecuteSqlRawAsync(@\"\n//insert into \"\"CampaignClickDailyAgg\"\" (\"\"CampaignId\"\", \"\"Day\"\", \"\"ButtonIndex\"\", \"\"Clicks\"\")\n//values ({0}, {1}, {2}, {3})\n//on conflict (\"\"CampaignId\"\", \"\"Day\"\", \"\"ButtonIndex\"\")\n//do update set \"\"Clicks\"\" = \"\"CampaignClickDailyAgg\"\".\"\"Clicks\"\" + {3};\",\n//                            g.CampaignId, g.Day, g.ButtonIndex, g.Count);\n//                    }\n//                }\n//                catch (Exception ex)\n//                {\n//                    _log.LogError(ex, \"Aggregate update failed; skipped.\");\n//                }\n//            }\n\n//            _log.LogInformation(\"ClickLogWorker stopped\");\n//        }\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Worker/IClickEventQueue.cs",
      "sha256": "a0e8a3bbb51c949024de93f0d4794c3ed494cc047e0b7dafdabe4cf696dad89c",
      "language": "csharp",
      "size": 304,
      "content": "// Features/CampaignTracking/Worker/IClickEventQueue.cs\nnamespace xbytechat.api.Features.CampaignTracking.Worker\n{\n    public interface IClickEventQueue\n    {\n        bool TryWrite(ClickEvent evt);\n        Task<List<ClickEvent>> ReadBatchAsync(int maxItems, TimeSpan wait, CancellationToken ct);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Worker/InProcessClickEventQueue.cs",
      "sha256": "8344c869f22df147598c7b1db117ba72d4c518901138838f7fed724201392009",
      "language": "csharp",
      "size": 1254,
      "content": "using System.Threading.Channels;\n\nnamespace xbytechat.api.Features.CampaignTracking.Worker\n{\n    public sealed class InProcessClickEventQueue : IClickEventQueue\n    {\n        private readonly Channel<ClickEvent> _ch;\n\n        public InProcessClickEventQueue(int capacity = 20_000)\n        {\n            _ch = Channel.CreateBounded<ClickEvent>(new BoundedChannelOptions(capacity)\n            {\n                // keep newest; never block redirect\n                FullMode = BoundedChannelFullMode.DropOldest,\n                SingleReader = true,\n                SingleWriter = false\n            });\n        }\n\n        public bool TryWrite(ClickEvent evt) => _ch.Writer.TryWrite(evt);\n\n        public async Task<List<ClickEvent>> ReadBatchAsync(int maxItems, TimeSpan wait, CancellationToken ct)\n        {\n            var list = new List<ClickEvent>(maxItems);\n            using var cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\n            cts.CancelAfter(wait);\n\n            while (list.Count < maxItems && await _ch.Reader.WaitToReadAsync(cts.Token))\n            {\n                while (list.Count < maxItems && _ch.Reader.TryRead(out var item))\n                    list.Add(item);\n            }\n            return list;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Controllers/CatalogDashboardController.cs",
      "sha256": "f9186d5de3a12145a3d7a2411736c6510ca02a7b70409ebdcaaa0de5172c0370",
      "language": "csharp",
      "size": 1708,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.Catalog.DTOs;\nusing xbytechat.api.Features.Catalog.Services;\nusing System;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Catalog.Controllers\n{\n    [ApiController]\n    [Route(\"api/catalog-dashboard\")]\n    public class CatalogDashboardController : ControllerBase\n    {\n        private readonly ICatalogDashboardService _dashboardService;\n\n        public CatalogDashboardController(ICatalogDashboardService dashboardService)\n        {\n            _dashboardService = dashboardService;\n        }\n\n        [HttpGet(\"summary\")]\n        public async Task<ActionResult<CatalogDashboardSummaryDto>> GetSummary([FromQuery] Guid businessId)\n        {\n            var summary = await _dashboardService.GetDashboardSummaryAsync(businessId);\n            return Ok(summary);\n        }\n\n        [HttpGet(\"top-products\")]\n        public async Task<IActionResult> GetTopClickedProducts([FromQuery] Guid businessId, [FromQuery] int topN = 5)\n        {\n            var topProducts = await _dashboardService.GetTopClickedProductsAsync(businessId, topN);\n            return Ok(topProducts);\n        }\n        [HttpGet(\"cta-summary\")]\n        public async Task<IActionResult> GetCtaJourneySummary([FromQuery] Guid businessId)\n        {\n            var stats = await _dashboardService.GetCtaJourneyStatsAsync(businessId);\n            return Ok(stats);\n        }\n        [HttpGet(\"product-cta-breakdown\")]\n        public async Task<IActionResult> GetProductCtaBreakdown([FromQuery] Guid businessId)\n        {\n            var breakdown = await _dashboardService.GetProductCtaBreakdownAsync(businessId);\n            return Ok(breakdown);\n        }\n\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Controllers/CatalogTrackingController.cs",
      "sha256": "85581ce69ed9dbbad069ca060c3e8a2c356ec348d74d860ed2ed1905c46f9514",
      "language": "csharp",
      "size": 1696,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Catalog.DTOs;\nusing xbytechat.api.Features.Catalog.Services;\nusing xbytechat.api.Helpers;\nusing Microsoft.Extensions.Logging;\n\nnamespace xbytechat.api.Features.Catalog.Controllers\n{\n    [ApiController]\n    [Route(\"api/catalog-tracking\")]\n    public class CatalogTrackingController : ControllerBase\n    {\n        private readonly ICatalogTrackingService _trackingService;\n        private readonly ILogger<CatalogTrackingController> _logger;\n\n        public CatalogTrackingController(\n            ICatalogTrackingService trackingService,\n            ILogger<CatalogTrackingController> logger)\n        {\n            _trackingService = trackingService;\n            _logger = logger;\n        }\n\n        [HttpPost(\"log-click\")]\n        public async Task<IActionResult> LogClick([FromBody] CatalogClickLogDto dto)\n        {\n            var result = await _trackingService.LogClickAsync(dto);\n\n            if (!result.Success)\n            {\n                _logger.LogWarning(\"‚ùå Catalog click log failed: {Msg}\", result.Message);\n                return BadRequest(result);\n            }\n\n            return StatusCode(201, result);\n        }\n\n        [HttpGet(\"recent\")]\n        public async Task<IActionResult> GetRecentLogs([FromQuery] int limit = 5)\n        {\n            var result = await _trackingService.GetRecentLogsAsync(limit);\n\n            if (!result.Success)\n            {\n                _logger.LogError(\"‚ùå Failed to fetch recent logs: {Error}\", result.ErrorMessage);\n                return StatusCode(500, result);\n            }\n\n            return Ok(result);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Controllers/ProductController.cs",
      "sha256": "96a44de270bbb3d5a3b88cc161908c14045b78ca5adab88fb776640f55de1a1b",
      "language": "csharp",
      "size": 3021,
      "content": "// üìÑ File: Features/Catalog/Controllers/ProductController.cs\n\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.Catalog.DTOs;\nusing xbytechat.api.Features.Catalog.Services;\nusing xbytechat.api.Helpers;\nusing System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api.Middleware.Attributes;\n\nnamespace xbytechat.api.Features.Catalog.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class ProductController : ControllerBase\n    {\n        private readonly IProductService _productService;\n\n        public ProductController(IProductService productService)\n        {\n            _productService = productService;\n        }\n\n        // ‚úÖ GET /api/product?businessId=...\n        [HttpGet]\n        [RequirePermission(\"ViewCatalog\")]\n        public async Task<IActionResult> GetAll([FromQuery] Guid businessId)\n        {\n            if (businessId == Guid.Empty)\n                return BadRequest(ResponseResult.ErrorInfo(\"BusinessId is required.\"));\n\n            var result = await _productService.GetProductsByBusinessIdAsync(businessId);\n            return Ok(result);\n        }\n\n        // ‚úÖ POST /api/product\n        [HttpPost]\n        [RequirePermission(\"ManageCatalog\")]\n        public async Task<IActionResult> Create([FromBody] CreateProductDto dto)\n        {\n            if (!ModelState.IsValid)\n            {\n                var errors = ModelState.Values\n                    .SelectMany(v => v.Errors)\n                    .Select(e => e.ErrorMessage)\n                    .ToList();\n\n                var errorString = string.Join(\"; \", errors);\n                return BadRequest(ResponseResult.ErrorInfo(\"Invalid product data.\", errorString));\n            }\n\n            var result = await _productService.AddProductAsync(dto);\n            if (!result.Success)\n                return BadRequest(result);\n\n            return StatusCode(201, result);\n        }\n\n        // ‚úÖ DELETE /api/product/{id}?businessId=...\n        [HttpDelete(\"{id}\")]\n        [RequirePermission(\"ManageCatalog\")]\n        public async Task<IActionResult> Delete(Guid id, [FromQuery] Guid businessId)\n        {\n            if (businessId == Guid.Empty)\n                return BadRequest(ResponseResult.ErrorInfo(\"BusinessId is required.\"));\n\n            var result = await _productService.RemoveProductAsync(id, businessId);\n            if (!result.Success)\n                return BadRequest(result);\n\n            return Ok(result);\n        }\n\n        // ‚úÖ PUT /api/product/{id}\n        [HttpPut(\"{id}\")]\n        [RequirePermission(\"ManageCatalog\")]\n        public async Task<IActionResult> Update(Guid id, [FromBody] UpdateProductDto dto)\n        {\n            if (id != dto.Id)\n                return BadRequest(ResponseResult.ErrorInfo(\"ID mismatch between route and body.\"));\n\n            var result = await _productService.UpdateProductAsync(dto);\n            if (!result.Success)\n                return BadRequest(result);\n\n            return Ok(result);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/DTOs/CatalogClickLogDto.cs",
      "sha256": "901cea612e459695f97b806841df45393d04066624affedbfd85cc9d7d3899ce",
      "language": "csharp",
      "size": 979,
      "content": "namespace xbytechat.api.Features.Catalog.DTOs\n{\n    public class CatalogClickLogDto\n    {\n        public Guid BusinessId { get; set; }\n        public Guid? ContactId { get; set; }  // ‚úÖ Add this\n        public Guid? ProductId { get; set; }\n\n        public string? UserId { get; set; }\n        public string? UserName { get; set; }\n        public string? UserPhone { get; set; }\n\n        public string? BotId { get; set; }\n        public string? CategoryBrowsed { get; set; }\n        public string? ProductBrowsed { get; set; }\n        public string? CTAJourney { get; set; }\n        public Guid? MessageLogId { get; set; }      // ‚úÖ ADD THIS FIELD\n        public string? RefMessageId { get; set; }\n\n        public string TemplateId { get; set; }\n        public string ButtonText { get; set; }\n\n        // üß† Optional: Used for A/B tracking and analytics\n        public string? PlanSnapshot { get; set; }\n\n        public string? Source { get; set; } // ‚úÖ Add this\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/DTOs/CatalogDashboardSummaryDto.cs",
      "sha256": "31e171cf2d8c5bc006b770f4be2a968db3300aaad51072555faecd119e0e0e07",
      "language": "csharp",
      "size": 698,
      "content": "namespace xbytechat.api.Features.Catalog.DTOs\n{\n    public class CatalogDashboardSummaryDto\n    {\n        // Engagement Metrics\n        public int TotalMessagesSent { get; set; }\n        public int? UniqueCustomersMessaged { get; set; }\n        public int? ProductClicks { get; set; }\n\n        // Catalog Overview\n        public int? ActiveProducts { get; set; }\n        public int? ProductsSharedViaWhatsApp { get; set; }\n\n        // Lead Intelligence\n        public int? RepeatClickers { get; set; }\n        public int? NewClickersToday { get; set; }\n\n        // Timestamps\n        public DateTime? LastCatalogClickAt { get; set; }\n        public DateTime? LastMessageSentAt { get; set; }\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/Catalog/DTOs/CreateProductDto.cs",
      "sha256": "8605a9900a0537d7cec14264a91a4a4432debcdaafb06cff99b177460bd47233",
      "language": "csharp",
      "size": 472,
      "content": "// File: Features/Catalog/DTOs/CreateProductDto.cs\n\nnamespace xbytechat.api.Features.Catalog.DTOs\n{\n    public class CreateProductDto\n    {\n        public Guid BusinessId { get; set; }\n        public string Name { get; set; } = string.Empty;\n        public string Description { get; set; } = string.Empty;\n        public decimal Price { get; set; }\n        public string Currency { get; set; } = \"INR\";\n        public string ImageUrl { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/DTOs/CtaJourneyStatsDto.cs",
      "sha256": "ca4efb6e222da04add4d8f9892be95a16ae180b34e53eec32d300c471ea503bd",
      "language": "csharp",
      "size": 188,
      "content": "namespace xbytechat.api.Features.Catalog.DTOs\n{\n    public class CtaJourneyStatsDto\n    {\n        public string CTAJourney { get; set; }\n        public int ClickCount { get; set; }\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/Catalog/DTOs/ProductCtaBreakdownDto.cs",
      "sha256": "a94adfe171430503ede80ebb733fc9983f3fe1eae04b4a5a4ed6eb14d354bc10",
      "language": "csharp",
      "size": 284,
      "content": "namespace xbytechat.api.Features.Catalog.DTOs\n{\n    public class ProductCtaBreakdownDto\n    {\n        public Guid ProductId { get; set; }\n        public string ProductName { get; set; }\n        public string CTAJourney { get; set; }\n        public int ClickCount { get; set; }\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/Catalog/DTOs/ProductDto.cs",
      "sha256": "9351e6b36ce1f707bd46bb92652331f1751b150a9d062ecfd31572a0998d59b7",
      "language": "csharp",
      "size": 549,
      "content": "// File: Features/Catalog/DTOs/ProductDto.cs\n\nnamespace xbytechat.api.Features.Catalog.DTOs\n{\n    public class ProductDto\n    {\n        public Guid Id { get; set; }\n\n        public Guid BusinessId { get; set; }\n        public string Name { get; set; } = string.Empty;\n        public string Description { get; set; } = string.Empty;\n        public decimal Price { get; set; }\n        public string Currency { get; set; } = \"INR\";\n        public string ImageUrl { get; set; } = string.Empty;\n        public bool IsActive { get; set; } = true;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/DTOs/TopProductDto.cs",
      "sha256": "464918c2b2d66c5710042f7d26d7b64fc8f4fb0380f12e7c756a0d248e613684",
      "language": "csharp",
      "size": 228,
      "content": "namespace xbytechat.api.Features.Catalog.DTOs\n{\n    public class TopProductDto\n    {\n        public Guid ProductId { get; set; }\n        public string ProductName { get; set; }\n        public int ClickCount { get; set; }\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/Catalog/DTOs/UpdateProductDto.cs",
      "sha256": "3d2fa63b4ce50da54504b1efa60375305ee53bd12498eb5c359bec2f13aeb11c",
      "language": "csharp",
      "size": 511,
      "content": "// File: Features/Catalog/DTOs/UpdateProductDto.cs\n\nnamespace xbytechat.api.Features.Catalog.DTOs\n{\n    public class UpdateProductDto\n    {\n        public Guid Id { get; set; }\n        public Guid BusinessId { get; set; }\n\n        public string Name { get; set; } = string.Empty;\n        public string Description { get; set; } = string.Empty;\n        public decimal Price { get; set; }\n        public string Currency { get; set; } = \"INR\";\n        public string ImageUrl { get; set; } = string.Empty;\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Models/CatalogClickLog.cs",
      "sha256": "04b5faf86ec274241aa075f5ba6309899ae07f9c0074d1a34285b4f7c96b437d",
      "language": "csharp",
      "size": 1636,
      "content": "namespace xbytechat.api.Features.Catalog.Models\n{\n    public class CatalogClickLog\n    {\n        public Guid Id { get; set; }\n\n        // üîó Business & Product Info\n        public Guid BusinessId { get; set; }\n        public Guid? ProductId { get; set; }\n\n        // üë§ Customer Info\n        public string? UserId { get; set; }\n        public string? UserName { get; set; }\n        public string? UserPhone { get; set; }\n\n        // ü§ñ Bot / Messaging Context\n        public string? BotId { get; set; }\n\n        // üõçÔ∏è Browsing Context\n        public string? CategoryBrowsed { get; set; }\n        public string? ProductBrowsed { get; set; }\n\n        // üîò CTA Clicked\n        public string? CTAJourney { get; set; }\n        public string TemplateId { get; set; }\n        public string RefMessageId { get; set; }\n        public string ButtonText { get; set; }\n\n        // üïí Meta\n        public DateTime? ClickedAt { get; set; } = DateTime.UtcNow;\n\n        // ‚úÖ CRM / Campaign / Analytics\n        public Guid? CampaignSendLogId { get; set; }\n        public Guid? ContactId { get; set; }\n        public bool FollowUpSent { get; set; } = false;\n        public string? LastInteractionType { get; set; }\n        public Guid? MessageLogId { get; set; }\n        public string? PlanSnapshot { get; set; }\n\n        // üÜï [New Additions for CTA Campaign Tracking]\n        public Guid? CtaId { get; set; }             // Link to CTA definition\n        public Guid? CampaignId { get; set; }        // Link to campaign (if any)\n        public string Source { get; set; } = \"catalog\"; // \"catalog\", \"campaign\", \"auto-reply\"\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Models/Product.cs",
      "sha256": "428554206c02d4602a873704a1e49c995a274f4633e0f32d8c0991c4eea72a31",
      "language": "csharp",
      "size": 1062,
      "content": "// File: Features/Catalog/Models/Product.cs\n\nusing System;\n\nnamespace xbytechat.api.Features.Catalog.Models\n{\n    public class Product\n    {\n        public Guid Id { get; set; }\n\n        // üîó Foreign Key - Business/Owner\n        public Guid BusinessId { get; set; }\n\n        // üì¶ Core Product Info\n        public string Name { get; set; } = string.Empty;\n        public string Description { get; set; } = string.Empty;\n        public decimal Price { get; set; }\n        public string Currency { get; set; } = \"INR\";\n        public string ImageUrl { get; set; } = string.Empty;\n\n        // ‚úÖ Visibility & State\n        public bool IsActive { get; set; } = true;\n\n        // üìÖ Metadata\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n        public int TotalClicks { get; set; } = 0; // Total CTA clicks tracked\n        public DateTime? LastClickedAt { get; set; } // Last time a user clicked CTA for this product\n        public string? MostClickedCTA { get; set; } // Button text with highest click count (e.g., \"Buy Now\")\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Services/CatalogDashboardService.cs",
      "sha256": "3303616ebf70e99e2e646759834c707405060cc1b22ceb5f743dfa1d8af50198",
      "language": "csharp",
      "size": 6538,
      "content": "using System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Hosting.Server;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Catalog.DTOs;\nusing static System.Runtime.InteropServices.JavaScript.JSType;\n\nnamespace xbytechat.api.Features.Catalog.Services\n{\n    public class CatalogDashboardService : ICatalogDashboardService\n    {\n        private readonly AppDbContext _context;\n\n        public CatalogDashboardService(AppDbContext context)\n        {\n            _context = context;\n        }\n\n       \n        public async Task<CatalogDashboardSummaryDto> GetDashboardSummaryAsync(Guid businessId)\n        {\n            var today = DateTime.UtcNow.Date;\n\n            var totalMessagesSent = await _context.MessageLogs\n                .CountAsync(m => m.BusinessId == businessId);\n\n            var uniqueCustomersMessaged = await _context.MessageLogs\n                .Where(m => m.BusinessId == businessId)\n                .Select(m => m.RecipientNumber)\n                .Distinct()\n                .CountAsync();\n\n            var productClicks = await _context.CatalogClickLogs\n                .CountAsync(c => c.BusinessId == businessId && c.ProductId != null);\n\n            var activeProducts = await _context.Products\n                .CountAsync(p => p.BusinessId == businessId);\n\n            var productsSharedViaWhatsapp = await _context.CatalogClickLogs\n                .Where(c => c.BusinessId == businessId && c.ProductId != null)\n                .Select(c => c.ProductId)\n                .Distinct()\n                .CountAsync();\n\n            var repeatClickers = await _context.CatalogClickLogs\n                .Where(c => c.BusinessId == businessId)\n                .GroupBy(c => c.UserPhone)\n                .CountAsync(g => g.Count() > 1);\n\n            var newClickersToday = await _context.CatalogClickLogs\n                .Where(c => c.BusinessId == businessId && c.ClickedAt.Value.Date == today)\n                .Select(c => c.UserPhone)\n                .Distinct()\n                .CountAsync();\n            //        var newClickersToday = _context.CatalogClickLogs\n            //.Where(c => c.BusinessId == businessId)\n            //.ToList() // now it's LINQ to Objects\n            //        .Where(c => c.ClickedAt?.Date == today)\n            //        .Select(c => c.UserPhone)\n            //        .Distinct()\n            //.Count();\n            //        But if your data is large, the first(server-side filtering) is the better choice.\n\n            var lastCatalogClickAt = await _context.CatalogClickLogs\n    .Where(c => c.BusinessId == businessId)\n    .MaxAsync(c => (DateTime?)c.ClickedAt);\n\n            var lastMessageSentAt = await _context.MessageLogs\n                .Where(m => m.BusinessId == businessId)\n                .MaxAsync(m => (DateTime?)m.SentAt);\n\n            return new CatalogDashboardSummaryDto\n            {\n                TotalMessagesSent = totalMessagesSent,\n                UniqueCustomersMessaged = uniqueCustomersMessaged,\n                ProductClicks = productClicks,\n                ActiveProducts = activeProducts,\n                ProductsSharedViaWhatsApp = productsSharedViaWhatsapp,\n                RepeatClickers = repeatClickers,\n                NewClickersToday = newClickersToday,\n                LastCatalogClickAt = lastCatalogClickAt,\n                LastMessageSentAt = lastMessageSentAt\n            };\n        }\n\n        public async Task<List<TopProductDto>> GetTopClickedProductsAsync(Guid businessId, int topN = 5)\n        {\n            var topProducts = await _context.CatalogClickLogs\n                .Where(c => c.BusinessId == businessId && c.ProductId != null)\n                .GroupBy(c => c.ProductId)\n                .Select(g => new\n                {\n                    ProductId = g.Key,\n                    ClickCount = g.Count()\n                })\n                .OrderByDescending(x => x.ClickCount)\n                .Take(topN)\n                .ToListAsync();\n\n            // Now fetch product names to join with clicks\n            var productIds = topProducts.Select(x => x.ProductId).ToList();\n\n            var products = await _context.Products\n                .Where(p => productIds.Contains(p.Id))\n                .ToDictionaryAsync(p => p.Id, p => p.Name);\n\n            return topProducts.Select(x => new TopProductDto\n            {\n                ProductId = x.ProductId.Value,\n                ProductName = products.ContainsKey(x.ProductId.Value) ? products[x.ProductId.Value] : \"Unknown\",\n                ClickCount = x.ClickCount\n            }).ToList();\n        }\n        public async Task<List<CtaJourneyStatsDto>> GetCtaJourneyStatsAsync(Guid businessId)\n        {\n            var stats = await _context.CatalogClickLogs\n                .Where(c => c.BusinessId == businessId && !string.IsNullOrEmpty(c.CTAJourney))\n                .GroupBy(c => c.CTAJourney)\n                .Select(g => new CtaJourneyStatsDto\n                {\n                    CTAJourney = g.Key,\n                    ClickCount = g.Count()\n                })\n                .OrderByDescending(x => x.ClickCount)\n                .ToListAsync();\n\n            return stats;\n        }\n        public async Task<List<ProductCtaBreakdownDto>> GetProductCtaBreakdownAsync(Guid businessId)\n        {\n            var groupedClicks = await _context.CatalogClickLogs\n                .Where(c => c.BusinessId == businessId && c.ProductId != null && !string.IsNullOrEmpty(c.CTAJourney))\n                .GroupBy(c => new { c.ProductId, c.CTAJourney })\n                .Select(g => new\n                {\n                    ProductId = g.Key.ProductId.Value,\n                    CTAJourney = g.Key.CTAJourney,\n                    ClickCount = g.Count()\n                })\n                .ToListAsync();\n\n            // Fetch product names for all involved productIds\n            var productIds = groupedClicks.Select(g => g.ProductId).Distinct().ToList();\n\n            var productNames = await _context.Products\n                .Where(p => productIds.Contains(p.Id))\n                .ToDictionaryAsync(p => p.Id, p => p.Name);\n\n            var result = groupedClicks.Select(g => new ProductCtaBreakdownDto\n            {\n                ProductId = g.ProductId,\n                ProductName = productNames.ContainsKey(g.ProductId) ? productNames[g.ProductId] : \"Unknown\",\n                CTAJourney = g.CTAJourney,\n                ClickCount = g.ClickCount\n            }).ToList();\n\n            return result;\n        }\n\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Services/CatalogTrackingService.cs",
      "sha256": "466e53210d232226ec62ffaed236063b75a748eff0f420e423d8f482ff3a4fdf",
      "language": "csharp",
      "size": 6371,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CRM.Models;\nusing xbytechat.api.Features.Catalog.DTOs;\nusing xbytechat.api.Features.Catalog.Models;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Models;\nusing xbytechat.api.Services.Messages.Interfaces;\nusing xbytechat.api.Features.PlanManagement.Models;\nusing xbytechat.api.Features.CRM.Timelines.Services;\n\nnamespace xbytechat.api.Features.Catalog.Services\n{\n    public class CatalogTrackingService : ICatalogTrackingService\n    {\n        private readonly AppDbContext _context;\n        private readonly IMessageService _messageService;\n        private readonly ILeadTimelineService _leadTimelineService;\n\n        public CatalogTrackingService(\n            AppDbContext context,\n            IMessageService messageService,\n            ILeadTimelineService leadTimelineService)\n        {\n            _context = context;\n            _messageService = messageService;\n            _leadTimelineService = leadTimelineService;\n        }\n\n        public async Task<ResponseResult> LogClickAsync(CatalogClickLogDto dto)\n        {\n            if (dto == null || dto.BusinessId == Guid.Empty || string.IsNullOrWhiteSpace(dto.UserPhone))\n            {\n                Log.Warning(\"‚ùå Invalid catalog click log attempt: missing businessId or userPhone.\");\n                return ResponseResult.ErrorInfo(\"Required fields are missing (businessId, userPhone).\");\n            }\n\n            try\n            {\n                Guid? campaignSendLogId = null;\n                Guid? contactId = null;\n                bool followUpSent = false;\n\n                // STEP 1: Link campaign log via RefMessageId if available\n                if (!string.IsNullOrWhiteSpace(dto.RefMessageId))\n                {\n                    var sendLog = await _context.CampaignSendLogs\n                        .FirstOrDefaultAsync(x => x.MessageId == dto.RefMessageId);\n\n                    if (sendLog != null)\n                    {\n                        sendLog.IsClicked = true;\n                        sendLog.ClickedAt = DateTime.UtcNow;\n                        sendLog.ClickType = dto.CTAJourney ?? dto.ButtonText;\n                        campaignSendLogId = sendLog.Id;\n                    }\n                }\n\n                // STEP 2: Link or Create CRM Contact\n                if (!string.IsNullOrWhiteSpace(dto.UserPhone))\n                {\n                    var contact = await _context.Contacts\n                        .FirstOrDefaultAsync(c => c.PhoneNumber == dto.UserPhone && c.BusinessId == dto.BusinessId);\n\n                    if (contact == null)\n                    {\n                        contact = new Contact\n                        {\n                            Id = Guid.NewGuid(),\n                            Name = dto.UserName ?? \"Lead\",\n                            PhoneNumber = dto.UserPhone,\n                            BusinessId = dto.BusinessId,\n                            CreatedAt = DateTime.UtcNow\n                        };\n                        _context.Contacts.Add(contact);\n                        await _context.SaveChangesAsync();\n                    }\n\n                    contactId = contact.Id;\n\n                    // STEP 3: Auto follow-up if plan allows\n                    var business = await _context.Businesses\n                        .AsNoTracking()\n                        .FirstOrDefaultAsync(b => b.Id == dto.BusinessId);\n\n                    if (business?.BusinessPlanInfo?.Plan == PlanType.Advanced)\n                    {\n                        var message = $\"Hi {contact.Name ?? \"there\"}, how can I help you?\";\n                        await _messageService.SendFollowUpAsync(contact.PhoneNumber, message);\n                        followUpSent = true;\n                    }\n                }\n\n                // STEP 4: Save the click with all linked data\n                var log = new CatalogClickLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = dto.BusinessId,\n                    ProductId = dto.ProductId,\n                    UserId = dto.UserId,\n                    UserName = dto.UserName,\n                    UserPhone = dto.UserPhone,\n                    BotId = dto.BotId,\n                    CategoryBrowsed = dto.CategoryBrowsed,\n                    ProductBrowsed = dto.ProductBrowsed,\n                    CTAJourney = dto.CTAJourney,\n                    TemplateId = dto.TemplateId,\n                    ButtonText = dto.ButtonText,\n                    RefMessageId = dto.RefMessageId,\n                    ClickedAt = DateTime.UtcNow,\n                    CampaignSendLogId = campaignSendLogId,\n                    ContactId = contactId,\n                    FollowUpSent = followUpSent,\n                    LastInteractionType = \"Clicked\",\n                    PlanSnapshot = dto.PlanSnapshot\n                };\n\n                _context.CatalogClickLogs.Add(log);\n                await _context.SaveChangesAsync();\n\n                // STEP 5: Save into LeadTimeline (no await error)\n                await _leadTimelineService.AddFromCatalogClickAsync(log);\n\n                Log.Information(\"üìä Catalog click tracked: {BusinessId}, {UserPhone}, {CTA}\", dto.BusinessId, dto.UserPhone, dto.CTAJourney);\n                return ResponseResult.SuccessInfo(\"‚úÖ Click tracked successfully.\", log.Id);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed to log catalog click\");\n                return ResponseResult.ErrorInfo(\"‚ùå Error while tracking catalog click.\", ex.Message);\n            }\n        }\n\n        public async Task<ResponseResult> GetRecentLogsAsync(int limit)\n        {\n            try\n            {\n                var logs = await _context.CatalogClickLogs\n                    .OrderByDescending(x => x.ClickedAt)\n                    .Take(limit)\n                    .ToListAsync();\n\n                return ResponseResult.SuccessInfo(\"Recent logs fetched.\", logs);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed to fetch recent catalog click logs\");\n                return ResponseResult.ErrorInfo(\"Failed to fetch logs.\", ex.Message);\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Services/ICatalogDashboardService.cs",
      "sha256": "9cac16574ec18c7343c13d49a28395b9ab04bf296e8d7b910b05d1cc88378a7d",
      "language": "csharp",
      "size": 546,
      "content": "using System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Catalog.DTOs;\nnamespace xbytechat.api.Features.Catalog.Services\n{\n    public interface ICatalogDashboardService\n    {\n        Task<CatalogDashboardSummaryDto> GetDashboardSummaryAsync(Guid businessId);\n        Task<List<TopProductDto>> GetTopClickedProductsAsync(Guid businessId, int topN = 5);\n        Task<List<CtaJourneyStatsDto>> GetCtaJourneyStatsAsync(Guid businessId);\n        Task<List<ProductCtaBreakdownDto>> GetProductCtaBreakdownAsync(Guid businessId);\n\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Services/ICatalogTrackingService.cs",
      "sha256": "b9ea119f807697f7e52cbea8b7c3aa4320c2ffe23326d076d1d1f0f9a2f12310",
      "language": "csharp",
      "size": 342,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.Catalog.DTOs;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.Catalog.Services\n{\n    public interface ICatalogTrackingService\n    {\n        Task<ResponseResult> LogClickAsync(CatalogClickLogDto dto);\n        Task<ResponseResult> GetRecentLogsAsync(int limit);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Services/IProductService.cs",
      "sha256": "23245f8c5da029c4146e515732f03b3e815636c1fddfec0f38a3a26355bdc1b1",
      "language": "csharp",
      "size": 510,
      "content": "using System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Catalog.DTOs;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.Catalog.Services\n{\n    public interface IProductService\n    {\n        Task<ResponseResult> AddProductAsync(CreateProductDto dto);\n        Task<ResponseResult> RemoveProductAsync(Guid id, Guid businessId);\n        Task<ResponseResult> UpdateProductAsync(UpdateProductDto dto);\n        Task<ResponseResult> GetProductsByBusinessIdAsync(Guid businessId);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Services/ProductService.cs",
      "sha256": "b42253a9398257b4f84555e31c4423127d843bd60b73560f7730b71433d17fd0",
      "language": "csharp",
      "size": 5527,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Catalog.DTOs;\nusing xbytechat.api.Features.Catalog.Models;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.Catalog.Services\n{\n    public class ProductService : IProductService\n    {\n        private readonly AppDbContext _context;\n\n        public ProductService(AppDbContext context)\n        {\n            _context = context;\n        }\n\n        public async Task<ResponseResult> AddProductAsync(CreateProductDto dto)\n        {\n            try\n            {\n                var exists = await _context.Products\n                    .AnyAsync(p => p.BusinessId == dto.BusinessId && p.Name == dto.Name);\n\n                if (exists)\n                {\n                    Log.Warning(\"‚ùå Duplicate product add attempt: {ProductName} for BusinessId: {BusinessId}\", dto.Name, dto.BusinessId);\n                    return ResponseResult.ErrorInfo(\"Product with this name already exists.\");\n                }\n\n                var newProduct = new Product\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = dto.BusinessId,\n                    Name = dto.Name,\n                    Description = dto.Description,\n                    Price = dto.Price,\n                    Currency = dto.Currency,\n                    ImageUrl = dto.ImageUrl,\n                    IsActive = true,\n                    CreatedAt = DateTime.UtcNow\n                };\n\n                await _context.Products.AddAsync(newProduct);\n                await _context.SaveChangesAsync();\n\n                Log.Information(\"‚úÖ Product created: {ProductName} ({ProductId})\", dto.Name, newProduct.Id);\n                return ResponseResult.SuccessInfo(\"‚úÖ Product added successfully.\", newProduct.Id);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed to add product: {ProductName}\", dto.Name);\n                return ResponseResult.ErrorInfo(\"Failed to add product.\", ex.Message);\n            }\n        }\n\n        public async Task<ResponseResult> RemoveProductAsync(Guid id, Guid businessId)\n        {\n            try\n            {\n                var product = await _context.Products\n                    .FirstOrDefaultAsync(p => p.Id == id && p.BusinessId == businessId);\n\n                if (product == null)\n                {\n                    Log.Warning(\"‚ùå Attempted to delete non-existent product: {ProductId}\", id);\n                    return ResponseResult.ErrorInfo(\"Product not found.\");\n                }\n\n                _context.Products.Remove(product);\n                await _context.SaveChangesAsync();\n\n                Log.Information(\"üóëÔ∏è Product deleted: {ProductId}\", id);\n                return ResponseResult.SuccessInfo(\"üóëÔ∏è Product deleted.\");\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed to delete product: {ProductId}\", id);\n                return ResponseResult.ErrorInfo(\"Failed to delete product.\", ex.Message);\n            }\n        }\n\n        public async Task<ResponseResult> UpdateProductAsync(UpdateProductDto dto)\n        {\n            try\n            {\n                var product = await _context.Products\n                    .FirstOrDefaultAsync(p => p.Id == dto.Id && p.BusinessId == dto.BusinessId);\n\n                if (product == null)\n                {\n                    Log.Warning(\"‚ùå Attempted to update non-existent product: {ProductId}\", dto.Id);\n                    return ResponseResult.ErrorInfo(\"Product not found.\");\n                }\n\n                product.Name = dto.Name;\n                product.Description = dto.Description;\n                product.Price = dto.Price;\n                product.Currency = dto.Currency;\n                product.ImageUrl = dto.ImageUrl;\n\n                await _context.SaveChangesAsync();\n\n                Log.Information(\"‚úÖ Product updated: {ProductId}\", dto.Id);\n                return ResponseResult.SuccessInfo(\"‚úÖ Product updated.\");\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed to update product: {ProductId}\", dto.Id);\n                return ResponseResult.ErrorInfo(\"Failed to update product.\", ex.Message);\n            }\n        }\n\n        public async Task<ResponseResult> GetProductsByBusinessIdAsync(Guid businessId)\n        {\n            try\n            {\n                var products = await _context.Products\n                    .Where(p => p.BusinessId == businessId && p.IsActive)\n                    .Select(p => new ProductDto\n                    {\n                        Id = p.Id,\n                        BusinessId = p.BusinessId,\n                        Name = p.Name,\n                        Description = p.Description,\n                        Price = p.Price,\n                        Currency = p.Currency,\n                        ImageUrl = p.ImageUrl,\n                        IsActive = p.IsActive\n                    })\n                    .ToListAsync();\n\n                return ResponseResult.SuccessInfo(\"Products fetched.\", products);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed to fetch products for BusinessId: {BusinessId}\", businessId);\n                return ResponseResult.ErrorInfo(\"Failed to fetch products.\", ex.Message);\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/Controllers/ChatInboxController.cs",
      "sha256": "8bfc29e38e01fd26cfe273ace7ba08ea169d1f222800889f8b122cd771f84789",
      "language": "csharp",
      "size": 30906,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/Controllers/ChatInboxController.cs\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Security.Claims;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.ChatInbox.DTOs;\nusing xbytechat.api.Features.ChatInbox.Models;\nusing xbytechat.api.Features.ChatInbox.Services;\nusing xbytechat.api.Models;\n\nnamespace xbytechat.api.Features.ChatInbox.Controllers\n{\n    [ApiController]\n    [Route(\"api/chat-inbox\")]\n    [Authorize]\n    public sealed class ChatInboxController : ControllerBase\n    {\n        private readonly IChatInboxQueryService _queryService;\n        private readonly IChatInboxCommandService _commandService;\n        private readonly IChatInboxAssignmentService _assignmentService;\n        private readonly IChatInboxMediaUploadService _mediaUploadService;\n        private readonly IChatInboxMediaContentService _mediaContentService;\n        private readonly AppDbContext _db;\n        private readonly ILogger<ChatInboxController> _logger;\n\n        public ChatInboxController(\n            IChatInboxQueryService queryService,\n            IChatInboxCommandService commandService,\n            IChatInboxAssignmentService assignmentService,\n            IChatInboxMediaUploadService mediaUploadService,\n            IChatInboxMediaContentService mediaContentService,\n            AppDbContext db,\n            ILogger<ChatInboxController> logger)\n        {\n            _queryService = queryService ?? throw new ArgumentNullException(nameof(queryService));\n            _commandService = commandService ?? throw new ArgumentNullException(nameof(commandService));\n            _assignmentService = assignmentService ?? throw new ArgumentNullException(nameof(assignmentService));\n            _mediaUploadService = mediaUploadService ?? throw new ArgumentNullException(nameof(mediaUploadService));\n            _mediaContentService = mediaContentService ?? throw new ArgumentNullException(nameof(mediaContentService));\n            _db = db ?? throw new ArgumentNullException(nameof(db));\n            _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n        }\n\n        private const long MaxUploadBytes = 10 * 1024 * 1024; // 10MB\n        private const string InboxAssignPermissionCode = \"INBOX.CHAT.ASSIGN\";\n\n        private static readonly HashSet<string> AllowedContentTypes = new HashSet<string>(StringComparer.OrdinalIgnoreCase)\n        {\n            \"image/jpeg\",\n            \"image/png\",\n            \"image/webp\",\n            \"application/pdf\",\n            \"video/mp4\",\n            \"video/3gpp\",\n            \"audio/mpeg\",\n            \"audio/mp4\",\n            \"audio/aac\",\n            \"audio/ogg\"\n        };\n\n        [HttpPost(\"media/upload\")]\n        [Consumes(\"multipart/form-data\")]\n        [ProducesResponseType(typeof(ChatInboxMediaUploadResponseDto), 200)]\n        public async Task<ActionResult<ChatInboxMediaUploadResponseDto>> UploadMedia(\n            [FromForm] ChatInboxMediaUploadRequestDto form,\n            CancellationToken ct = default)\n        {\n            var tokenBiz = GetBusinessId();\n            if (!tokenBiz.HasValue) return Unauthorized(\"businessId missing in token.\");\n\n            var file = form?.File;\n            if (file == null) return BadRequest(\"file is required.\");\n            if (file.Length <= 0) return BadRequest(\"file is empty.\");\n            if (file.Length > MaxUploadBytes) return BadRequest($\"file is too large. Max allowed is {MaxUploadBytes / (1024 * 1024)}MB.\");\n\n            // Some browsers append parameters like \"audio/ogg; codecs=opus\"\n            var mimeRaw = (file.ContentType ?? string.Empty).Trim();\n            var mime = mimeRaw.Split(';', 2)[0].Trim();\n            if (string.IsNullOrWhiteSpace(mime) || !AllowedContentTypes.Contains(mime))\n                return BadRequest(\"Unsupported file type. Allowed: image/jpeg, image/png, image/webp, application/pdf, video/mp4, audio/mpeg, audio/mp4, audio/aac, audio/ogg.\");\n\n            var mediaType = string.Equals(mime, \"application/pdf\", StringComparison.OrdinalIgnoreCase)\n                ? \"document\"\n                : mime.StartsWith(\"video/\", StringComparison.OrdinalIgnoreCase)\n                    ? \"video\"\n                    : mime.StartsWith(\"audio/\", StringComparison.OrdinalIgnoreCase)\n                        ? \"audio\"\n                        : \"image\";\n\n            var safeName = Path.GetFileName(file.FileName ?? \"upload.bin\");\n\n            try\n            {\n                var mediaId = await _mediaUploadService.UploadToWhatsAppAsync(\n                    tokenBiz.Value,\n                    phoneNumberId: null,\n                    file,\n                    ct).ConfigureAwait(false);\n\n                return Ok(new ChatInboxMediaUploadResponseDto\n                {\n                    MediaId = mediaId,\n                    MediaType = mediaType,\n                    FileName = safeName,\n                    MimeType = mime,\n                    SizeBytes = file.Length\n                });\n            }\n            catch (InvalidOperationException ex)\n            {\n                return BadRequest(new { message = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"ChatInbox media upload failed. BusinessId={BusinessId}\", tokenBiz.Value);\n                return BadRequest(new { message = \"Media upload failed. Please try again.\" });\n            }\n        }\n\n        [HttpGet(\"media/{mediaId}/content\")]\n        public async Task<IActionResult> GetMediaContent(\n            [FromRoute] string mediaId,\n            CancellationToken ct = default)\n        {\n            var tokenBiz = GetBusinessId();\n            if (!tokenBiz.HasValue) return Unauthorized(\"businessId missing in token.\");\n\n            var tokenUserId = GetUserId();\n            if (!tokenUserId.HasValue) return Unauthorized(\"userId missing in token.\");\n\n            var mid = (mediaId ?? string.Empty).Trim();\n            if (string.IsNullOrWhiteSpace(mid)) return BadRequest(\"mediaId is required.\");\n\n            var row = await _db.MessageLogs\n                .AsNoTracking()\n                .Where(m =>\n                    m.BusinessId == tokenBiz.Value &&\n                    m.MediaId != null &&\n                    m.MediaId == mid &&\n                    m.ContactId != null)\n                .OrderByDescending(m => m.SentAt ?? m.CreatedAt)\n                .ThenByDescending(m => m.Id)\n                .Select(m => new\n                {\n                    ContactId = m.ContactId!.Value,\n                    m.FileName,\n                    m.MimeType,\n                    m.MediaType\n                })\n                .FirstOrDefaultAsync(ct)\n                .ConfigureAwait(false);\n\n            if (row == null) return NotFound(new { message = \"Media not found.\" });\n\n            try\n            {\n                await EnsureCanAccessContactAsync(tokenBiz.Value, tokenUserId.Value, row.ContactId, ct)\n                    .ConfigureAwait(false);\n            }\n            catch (UnauthorizedAccessException ex)\n            {\n                return StatusCode(StatusCodes.Status403Forbidden, new { message = ex.Message });\n            }\n\n            try\n            {\n                var (stream, contentType) = await _mediaContentService\n                    .DownloadFromWhatsAppAsync(tokenBiz.Value, mid, ct)\n                    .ConfigureAwait(false);\n\n                var finalType = !string.IsNullOrWhiteSpace(row.MimeType)\n                    ? row.MimeType!\n                    : (contentType ?? \"application/octet-stream\");\n\n                var fallbackName = string.Equals(row.MediaType, \"document\", StringComparison.OrdinalIgnoreCase)\n                    ? \"document.pdf\"\n                    : string.Equals(row.MediaType, \"video\", StringComparison.OrdinalIgnoreCase)\n                        ? \"video.mp4\"\n                        : string.Equals(row.MediaType, \"audio\", StringComparison.OrdinalIgnoreCase)\n                            ? \"audio\"\n                            : \"image\";\n\n                var safeName = Path.GetFileName(row.FileName ?? fallbackName);\n                Response.Headers[\"Cache-Control\"] = \"no-store\";\n                Response.Headers[\"Content-Disposition\"] = $\"inline; filename=\\\"{safeName}\\\"\";\n\n                return File(stream, finalType);\n            }\n            catch (InvalidOperationException ex)\n            {\n                return BadRequest(new { message = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"ChatInbox media proxy failed. BusinessId={BusinessId} MediaId={MediaId}\", tokenBiz.Value, mid);\n                return BadRequest(new { message = \"Failed to load media. Please try again.\" });\n            }\n        }\n\n        [HttpGet(\"conversations\")]\n        [ProducesResponseType(typeof(IReadOnlyList<ChatInboxConversationDto>), 200)]\n        public async Task<IActionResult> GetConversations(\n            [FromQuery] Guid businessId,\n            [FromQuery] Guid? currentUserId, // kept for backward compatibility; ignored (token wins)\n            [FromQuery] string? tab,\n            [FromQuery] string? numberId,\n            [FromQuery] string? search,\n            [FromQuery] int? limit,\n            [FromQuery] bool paged = false,\n            [FromQuery] string? cursor = null,\n            CancellationToken cancellationToken = default)\n        {\n            if (businessId == Guid.Empty) return BadRequest(\"businessId is required.\");\n\n            var tokenBiz = GetBusinessId();\n            if (!tokenBiz.HasValue) return Unauthorized(\"businessId missing in token.\");\n            if (tokenBiz.Value != businessId) return Forbid(\"businessId does not match your tenant.\");\n\n            var tokenUserId = GetUserId();\n            if (!tokenUserId.HasValue) return Unauthorized(\"userId missing in token.\");\n\n            var filter = new ChatInboxFilterDto\n            {\n                BusinessId = businessId,\n                CurrentUserId = tokenUserId.Value, // ‚úÖ token wins\n                Tab = tab,\n                NumberId = string.IsNullOrWhiteSpace(numberId) ? null : numberId,\n                SearchTerm = string.IsNullOrWhiteSpace(search) ? null : search,\n                Limit = limit.GetValueOrDefault(50),\n                Cursor = cursor\n            };\n\n            if (!paged)\n            {\n                var result = await _queryService.GetConversationsAsync(filter, cancellationToken);\n                return Ok(result);\n            }\n\n            var page = await _queryService.GetConversationsPageAsync(filter, cancellationToken);\n            return Ok(page);\n        }\n\n        [HttpGet(\"agents\")]\n        [ProducesResponseType(typeof(List<AgentDto>), 200)]\n        public async Task<IActionResult> GetAgents(\n            [FromQuery] Guid businessId,\n            CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty) return BadRequest(\"businessId is required.\");\n\n            var tokenBiz = GetBusinessId();\n            if (!tokenBiz.HasValue) return Unauthorized(\"businessId missing in token.\");\n            if (tokenBiz.Value != businessId) return Forbid(\"businessId does not match your tenant.\");\n\n            try\n            {\n                var rows = await _assignmentService.GetAgentsAsync(businessId, ct);\n                return Ok(rows);\n            }\n            catch (Exception ex)\n            {\n                return BadRequest(ex.Message);\n            }\n        }\n\n        [HttpGet(\"messages\")]\n        [ProducesResponseType(typeof(IReadOnlyList<ChatInboxMessageDto>), 200)]\n        public async Task<IActionResult> GetMessages(\n            [FromQuery] Guid businessId,\n            [FromQuery] Guid? contactId,\n            [FromQuery] string? contactPhone,\n            [FromQuery] int limit = 50,\n            [FromQuery] bool paged = false,\n            [FromQuery] string? cursor = null,\n            CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty) return BadRequest(\"businessId is required.\");\n\n            var tokenBiz = GetBusinessId();\n            if (!tokenBiz.HasValue) return Unauthorized(\"businessId missing in token.\");\n            if (tokenBiz.Value != businessId) return Forbid(\"businessId does not match your tenant.\");\n\n            var tokenUserId = GetUserId();\n            if (!tokenUserId.HasValue) return Unauthorized(\"userId missing in token.\");\n\n            var uid = tokenUserId.Value;\n\n            // ‚úÖ Prefer ContactId path\n            if (contactId.HasValue && contactId.Value != Guid.Empty)\n            {\n                if (!paged)\n                {\n                    // ‚úÖ SECURED overload (enforces AssignedOnly visibility)\n                    var messages = await _queryService.GetMessagesForConversationByContactIdAsync(\n                        businessId, contactId.Value, limit, uid, ct);\n\n                    return Ok(messages);\n                }\n\n                // ‚úÖ SECURED overload (enforces AssignedOnly visibility)\n                var page = await _queryService.GetMessagesPageForConversationByContactIdAsync(\n                    businessId, contactId.Value, limit, cursor, uid, ct);\n\n                return Ok(page);\n            }\n\n            // Fallback: by phone\n            if (string.IsNullOrWhiteSpace(contactPhone))\n                return BadRequest(\"Provide either contactId or contactPhone.\");\n\n            if (!paged)\n            {\n                // ‚úÖ SECURED overload (enforces AssignedOnly visibility)\n                var byPhone = await _queryService.GetMessagesForConversationAsync(\n                    businessId, contactPhone, limit, uid, ct);\n\n                return Ok(byPhone);\n            }\n\n            // ‚úÖ SECURED overload (enforces AssignedOnly visibility)\n            var byPhonePage = await _queryService.GetMessagesPageForConversationByPhoneAsync(\n                businessId, contactPhone, limit, cursor, uid, ct);\n\n            return Ok(byPhonePage);\n        }\n\n        [HttpPost(\"send-message\")]\n        [ProducesResponseType(typeof(ChatInboxMessageDto), 200)]\n        public async Task<ActionResult<ChatInboxMessageDto>> SendMessage(\n            [FromBody] ChatInboxSendMessageRequestDto request,\n            CancellationToken ct = default)\n        {\n            if (request == null) return BadRequest(\"Request body is required.\");\n\n            var tokenBiz = GetBusinessId();\n            if (!tokenBiz.HasValue) return Unauthorized(\"businessId missing in token.\");\n\n            // Multi-tenant safety: never trust BusinessId from client; token wins.\n            request.BusinessId = tokenBiz.Value;\n\n            var tokenUserId = GetUserId();\n            if (!tokenUserId.HasValue) return Unauthorized(\"userId missing in token.\");\n\n            // ‚úÖ Critical: server-side actor identity\n            request.ActorUserId = tokenUserId.Value;\n\n            try\n            {\n                var result = await _commandService.SendAgentMessageAsync(request, ct);\n                return Ok(result);\n            }\n            catch (UnauthorizedAccessException ex)\n            {\n                _logger.LogWarning(\n                    ex,\n                    \"Forbidden chat-inbox send-message. BusinessId={BusinessId} ActorUserId={ActorUserId} ConversationId={ConversationId} ContactId={ContactId}\",\n                    request.BusinessId,\n                    tokenUserId.Value,\n                    request.ConversationId,\n                    request.ContactId);\n                return StatusCode(StatusCodes.Status403Forbidden, new { message = ex.Message });\n            }\n            catch (ArgumentException ex)\n            {\n                return BadRequest(ex.Message);\n            }\n            catch (InvalidOperationException ex)\n            {\n                return BadRequest(ex.Message);\n            }\n        }\n\n        //[HttpPost(\"mark-read\")]\n        //[ProducesResponseType(204)]\n        //public async Task<IActionResult> MarkRead(\n        //    [FromBody] ChatInboxMarkReadRequestDto request,\n        //    CancellationToken ct = default)\n        //{\n        //    if (request == null) return BadRequest(\"Request body is required.\");\n        //    if (request.BusinessId == Guid.Empty || request.ContactId == Guid.Empty)\n        //        return BadRequest(\"BusinessId and ContactId are required.\");\n\n        //    // ‚úÖ BusinessId MUST match token (security boundary)\n        //    var tokenBiz = GetBusinessId();\n        //    if (!tokenBiz.HasValue) return Unauthorized(\"businessId missing in token.\");\n        //    if (tokenBiz.Value != request.BusinessId) return Forbid(\"businessId does not match your tenant.\");\n\n        //    // ‚úÖ UserId MUST come from token (never trust client)\n        //    var tokenUserId = GetUserId();\n        //    if (!tokenUserId.HasValue) return Unauthorized(\"userId missing in token.\");\n\n        //    // Backward compatible: if client sent UserId, we ignore it and force token user.\n        //    request.UserId = tokenUserId.Value;\n\n        //    try\n        //    {\n        //        await _commandService.MarkConversationAsReadAsync(request, ct);\n        //        return NoContent();\n        //    }\n        //    catch (UnauthorizedAccessException ex)\n        //    {\n        //        _logger.LogWarning(\n        //            ex,\n        //            \"Forbidden chat-inbox mark-read. BusinessId={BusinessId} ActorUserId={ActorUserId} ContactId={ContactId}\",\n        //            request.BusinessId,\n        //            tokenUserId.Value,\n        //            request.ContactId);\n\n        //        return StatusCode(StatusCodes.Status403Forbidden, new { message = ex.Message });\n        //    }\n        //    catch (ArgumentException ex)\n        //    {\n        //        return BadRequest(ex.Message);\n        //    }\n        //    catch (InvalidOperationException ex)\n        //    {\n        //        return BadRequest(ex.Message);\n        //    }\n        //}\n        [HttpPost(\"mark-read\")]\n        [ProducesResponseType(204)]\n        public async Task<IActionResult> MarkRead(\n    [FromBody] ChatInboxMarkReadRequestDto request,\n    CancellationToken ct = default)\n        {\n            if (request == null) return BadRequest(\"Request body is required.\");\n            if (request.BusinessId == Guid.Empty || request.ContactId == Guid.Empty)\n                return BadRequest(\"BusinessId and ContactId are required.\");\n\n            var tokenBiz = GetBusinessId();\n            if (!tokenBiz.HasValue) return Unauthorized(\"businessId missing in token.\");\n            if (tokenBiz.Value != request.BusinessId) return Forbid(\"businessId does not match your tenant.\");\n\n            var tokenUserId = GetUserId();\n            if (!tokenUserId.HasValue) return Unauthorized(\"userId missing in token.\");\n\n            await _commandService.MarkConversationAsReadAsync(\n                request.BusinessId,\n                request.ContactId,\n                tokenUserId.Value,          // ‚úÖ token wins\n                request.LastReadAtUtc,\n                ct);\n\n            return NoContent();\n        }\n\n\n\n        [HttpPost(\"assign\")]\n        [ProducesResponseType(200)]\n        public async Task<IActionResult> Assign(\n            [FromBody] AssignConversationDto request,\n            CancellationToken ct = default)\n        {\n            if (request == null) return BadRequest(\"Request body is required.\");\n\n            if (request.BusinessId == Guid.Empty ||\n                request.ContactId == Guid.Empty ||\n                request.UserId == Guid.Empty)\n            {\n                return BadRequest(\"BusinessId, ContactId and UserId are required.\");\n            }\n\n            var tokenBiz = GetBusinessId();\n            if (!tokenBiz.HasValue) return Unauthorized(\"businessId missing in token.\");\n            if (tokenBiz.Value != request.BusinessId) return Forbid(\"businessId does not match your tenant.\");\n\n            var actorUserId = GetUserId();\n            if (!actorUserId.HasValue) return Unauthorized(\"userId missing in token.\");\n\n            try\n            {\n                await _assignmentService.AssignAsync(\n                    request.BusinessId,\n                    request.ContactId,\n                    request.UserId,\n                    actorUserId.Value,\n                    ct);\n\n                var updated = await TryGetConversationAsync(\n                    request.BusinessId,\n                    request.ContactId,\n                    actorUserId.Value,\n                    ct);\n\n                return Ok(new { success = true, conversation = updated });\n            }\n            catch (UnauthorizedAccessException ex)\n            {\n                _logger.LogWarning(\n                    ex,\n                    \"Forbidden chat-inbox assign. BusinessId={BusinessId} ActorUserId={ActorUserId} ContactId={ContactId} AssigneeUserId={AssigneeUserId}\",\n                    request.BusinessId,\n                    actorUserId.Value,\n                    request.ContactId,\n                    request.UserId);\n                return StatusCode(StatusCodes.Status403Forbidden, new { message = ex.Message });\n            }\n            catch (InvalidOperationException ex)\n            {\n                return NotFound(ex.Message);\n            }\n            catch (ArgumentException ex)\n            {\n                return BadRequest(ex.Message);\n            }\n        }\n\n        [HttpPost(\"unassign\")]\n        [ProducesResponseType(200)]\n        public async Task<IActionResult> Unassign(\n            [FromBody] UnassignConversationDto request,\n            CancellationToken ct = default)\n        {\n            if (request == null) return BadRequest(\"Request body is required.\");\n\n            if (request.BusinessId == Guid.Empty || request.ContactId == Guid.Empty)\n                return BadRequest(\"BusinessId and ContactId are required.\");\n\n            var tokenBiz = GetBusinessId();\n            if (!tokenBiz.HasValue) return Unauthorized(\"businessId missing in token.\");\n            if (tokenBiz.Value != request.BusinessId) return Forbid(\"businessId does not match your tenant.\");\n\n            var actorUserId = GetUserId();\n            if (!actorUserId.HasValue) return Unauthorized(\"userId missing in token.\");\n\n            try\n            {\n                await _assignmentService.UnassignAsync(\n                    request.BusinessId,\n                    request.ContactId,\n                    actorUserId.Value,\n                    ct);\n\n                var updated = await TryGetConversationAsync(\n                    request.BusinessId,\n                    request.ContactId,\n                    actorUserId.Value,\n                    ct);\n\n                return Ok(new { success = true, conversation = updated });\n            }\n            catch (UnauthorizedAccessException ex)\n            {\n                _logger.LogWarning(\n                    ex,\n                    \"Forbidden chat-inbox unassign. BusinessId={BusinessId} ActorUserId={ActorUserId} ContactId={ContactId}\",\n                    request.BusinessId,\n                    actorUserId.Value,\n                    request.ContactId);\n                return StatusCode(StatusCodes.Status403Forbidden, new { message = ex.Message });\n            }\n            catch (InvalidOperationException ex)\n            {\n                return NotFound(ex.Message);\n            }\n            catch (ArgumentException ex)\n            {\n                return BadRequest(ex.Message);\n            }\n        }\n\n        [HttpPost(\"set-status\")]\n        [ProducesResponseType(200)]\n        public async Task<IActionResult> SetStatus(\n            [FromBody] SetConversationStatusDto request,\n            CancellationToken ct = default)\n        {\n            if (request == null) return BadRequest(\"Request body is required.\");\n\n            if (request.BusinessId == Guid.Empty || request.ContactId == Guid.Empty)\n                return BadRequest(\"BusinessId and ContactId are required.\");\n\n            var tokenBiz = GetBusinessId();\n            if (!tokenBiz.HasValue) return Unauthorized(\"businessId missing in token.\");\n            if (tokenBiz.Value != request.BusinessId) return Forbid(\"businessId does not match your tenant.\");\n\n            var actorUserId = GetUserId();\n            if (!actorUserId.HasValue) return Unauthorized(\"userId missing in token.\");\n\n            try\n            {\n                await _assignmentService.SetStatusAsync(\n                    request.BusinessId,\n                    request.ContactId,\n                    request.Status,\n                    actorUserId.Value,\n                    ct);\n\n                var updated = await TryGetConversationAsync(\n                    request.BusinessId,\n                    request.ContactId,\n                    actorUserId.Value,\n                    ct);\n\n                return Ok(new { success = true, conversation = updated });\n            }\n            catch (UnauthorizedAccessException ex)\n            {\n                _logger.LogWarning(\n                    ex,\n                    \"Forbidden chat-inbox set-status. BusinessId={BusinessId} ActorUserId={ActorUserId} ContactId={ContactId} Status={Status}\",\n                    request.BusinessId,\n                    actorUserId.Value,\n                    request.ContactId,\n                    request.Status);\n                return StatusCode(StatusCodes.Status403Forbidden, new { message = ex.Message });\n            }\n            catch (InvalidOperationException ex)\n            {\n                return NotFound(ex.Message);\n            }\n            catch (ArgumentException ex)\n            {\n                return BadRequest(ex.Message);\n            }\n        }\n\n        private Guid? GetBusinessId()\n        {\n            var raw = User.FindFirstValue(\"businessId\") ?? User.FindFirstValue(\"BusinessId\");\n            return Guid.TryParse(raw, out var id) ? id : null;\n        }\n\n        private Guid? GetUserId()\n        {\n            var raw = User.FindFirstValue(ClaimTypes.NameIdentifier) ?? User.FindFirstValue(\"id\");\n            return Guid.TryParse(raw, out var id) ? id : null;\n        }\n\n        private async Task EnsureCanAccessContactAsync(\n            Guid businessId,\n            Guid userId,\n            Guid contactId,\n            CancellationToken ct)\n        {\n            var visibility = await _db.Businesses\n                .AsNoTracking()\n                .Where(b => b.Id == businessId)\n                .Select(b => (InboxVisibilityMode?)b.InboxVisibilityMode)\n                .FirstOrDefaultAsync(ct)\n                .ConfigureAwait(false) ?? InboxVisibilityMode.SharedInInbox;\n\n            if (visibility != InboxVisibilityMode.AssignedOnly) return;\n\n            var canSeeAll = await CanSeeAllInRestrictedModeAsync(businessId, userId, ct).ConfigureAwait(false);\n            if (canSeeAll) return;\n\n            var allowed = await _db.Contacts\n                .AsNoTracking()\n                .AnyAsync(c =>\n                    c.BusinessId == businessId &&\n                    c.Id == contactId &&\n                    c.AssignedAgentId == userId, ct)\n                .ConfigureAwait(false);\n\n            if (!allowed)\n                throw new UnauthorizedAccessException(\"Restricted inbox: you are not assigned to this conversation.\");\n        }\n\n        private static bool IsPrivilegedRoleName(string? roleName)\n        {\n            var role = (roleName ?? string.Empty).Trim().ToLowerInvariant();\n            return role is \"admin\" or \"business\" or \"superadmin\" or \"partner\";\n        }\n\n        private async Task<bool> CanSeeAllInRestrictedModeAsync(Guid businessId, Guid userId, CancellationToken ct)\n        {\n            var userRow = await _db.Users\n                .AsNoTracking()\n                .Where(u => u.Id == userId && u.BusinessId == businessId && !u.IsDeleted && u.Status == \"Active\")\n                .Select(u => new\n                {\n                    u.RoleId,\n                    RoleName = u.Role != null ? u.Role.Name : null\n                })\n                .FirstOrDefaultAsync(ct)\n                .ConfigureAwait(false);\n\n            if (userRow == null) return false;\n\n            if (IsPrivilegedRoleName(userRow.RoleName))\n                return true;\n\n            return await HasPermissionAsync(userId, InboxAssignPermissionCode, ct).ConfigureAwait(false);\n        }\n\n        private async Task<bool> HasPermissionAsync(Guid userId, string permissionCode, CancellationToken ct)\n        {\n            var code = (permissionCode ?? string.Empty).Trim().ToUpperInvariant();\n            if (code.Length == 0) return false;\n\n            var permissionId = await _db.Permissions\n                .AsNoTracking()\n                .Where(p => p.Code != null && p.Code.ToUpper() == code)\n                .Select(p => (Guid?)p.Id)\n                .FirstOrDefaultAsync(ct)\n                .ConfigureAwait(false);\n\n            if (!permissionId.HasValue) return false;\n\n            var direct = await _db.UserPermissions\n                .AsNoTracking()\n                .AnyAsync(up =>\n                    up.UserId == userId &&\n                    up.PermissionId == permissionId.Value &&\n                    up.IsGranted &&\n                    !up.IsRevoked, ct)\n                .ConfigureAwait(false);\n\n            if (direct) return true;\n\n            var roleId = await _db.Users\n                .AsNoTracking()\n                .Where(u => u.Id == userId)\n                .Select(u => u.RoleId)\n                .FirstOrDefaultAsync(ct)\n                .ConfigureAwait(false);\n\n            if (!roleId.HasValue) return false;\n\n            return await _db.RolePermissions\n                .AsNoTracking()\n                .AnyAsync(rp =>\n                    rp.RoleId == roleId.Value &&\n                    rp.PermissionId == permissionId.Value &&\n                    rp.IsActive &&\n                    !rp.IsRevoked, ct)\n                .ConfigureAwait(false);\n        }\n\n        private async Task<ChatInboxConversationDto?> TryGetConversationAsync(\n            Guid businessId,\n            Guid contactId,\n            Guid currentUserId,\n            CancellationToken ct)\n        {\n            var rows = await _queryService.GetConversationsAsync(\n                    new ChatInboxFilterDto\n                    {\n                        BusinessId = businessId,\n                        CurrentUserId = currentUserId,\n                        ContactId = contactId,\n                        Limit = 1\n                    },\n                    ct)\n                .ConfigureAwait(false);\n\n            return rows.FirstOrDefault();\n        }\n    }\n}\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/AgentDto.cs",
      "sha256": "39fd6eeec1233fec19f32ed1469ce217e586a955f1ea169451717c0773ef8c0f",
      "language": "csharp",
      "size": 311,
      "content": "using System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    public sealed class AgentDto\n    {\n        public Guid Id { get; set; }\n        public string Name { get; set; } = string.Empty;\n        public string Email { get; set; } = string.Empty;\n        public string? RoleName { get; set; }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/AssignConversationDto.cs",
      "sha256": "b2ef282b759c81018f7a8c7d3cba0dbe28e69910dec66d2a49f34d5045a5484f",
      "language": "csharp",
      "size": 256,
      "content": "using System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    public sealed class AssignConversationDto\n    {\n        public Guid BusinessId { get; set; }\n        public Guid ContactId { get; set; }\n        public Guid UserId { get; set; }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ChatInboxAssignRequestDto.cs",
      "sha256": "1070b71e595443da5bb86c5ae223123d517333fd06193925c55359d7d2e869ae",
      "language": "csharp",
      "size": 1156,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/DTOs/ChatInboxAssignRequestDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    /// <summary>\n    /// Request payload for assigning a conversation (contact) to a specific user.\n    /// </summary>\n    public sealed class ChatInboxAssignRequestDto\n    {\n        /// <summary>\n        /// Tenant/business id.\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// Contact id representing the conversation.\n        /// </summary>\n        public Guid ContactId { get; set; }\n\n        /// <summary>\n        /// Agent/user who will own this conversation.\n        /// </summary>\n        public Guid UserId { get; set; }\n    }\n\n    /// <summary>\n    /// Request payload for unassigning a conversation.\n    /// </summary>\n    public sealed class ChatInboxUnassignRequestDto\n    {\n        /// <summary>\n        /// Tenant/business id.\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// Contact id representing the conversation.\n        /// </summary>\n        public Guid ContactId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ChatInboxChangeStatusRequestDto.cs",
      "sha256": "caa15f4feb193863671beebe56a0421fababa24609b3249d3e63742645710a2e",
      "language": "csharp",
      "size": 1063,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/DTOs/ChatInboxChangeStatusRequestDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    /// <summary>\n    /// Command payload for changing the status of an Inbox conversation.\n    /// Internally this maps to Contact.IsArchived / IsActive.\n    /// </summary>\n    public sealed class ChatInboxChangeStatusRequestDto\n    {\n        /// <summary>\n        /// Tenant / business id (required).\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// Contact whose conversation we want to change (required).\n        /// </summary>\n        public Guid ContactId { get; set; }\n\n        /// <summary>\n        /// Target status: \"Open\" | \"Closed\" (case-insensitive).\n        /// We also accept \"New\"/\"Pending\" but treat them as Open internally.\n        /// </summary>\n        public string? TargetStatus { get; set; }\n\n        // Compatibility alias for newer clients posting { status: \"Open\"|\"Pending\"|\"Closed\" }\n        public string? Status { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ChatInboxConversationDto.cs",
      "sha256": "83d1e01c8c7b6c57f0bfc96714d5ef38287e0d3e7858149adb32b9ed12636678",
      "language": "csharp",
      "size": 2559,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/DTOs/ChatInboxConversationDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    /// <summary>\n    /// Lightweight conversation summary for the Chat Inbox UI.\n    /// Mirrors the front-end ConversationSummary model.\n    /// </summary>\n    public sealed class ChatInboxConversationDto\n    {\n        /// <summary>\n        /// Conversation identifier for the UI.\n        /// For v1 this can be derived from (ContactId + NumberId).\n        /// In the future, if you create an InboxConversation table,\n        /// use its primary key here.\n        /// </summary>\n        public string Id { get; set; } = default!;\n\n        public Guid ContactId { get; set; }\n        public string ContactName { get; set; } = string.Empty;\n        public string ContactPhone { get; set; } = string.Empty;\n\n        public string LastMessagePreview { get; set; } = string.Empty;\n        public DateTime LastMessageAt { get; set; }\n\n        public int UnreadCount { get; set; }\n\n        /// <summary>\n        /// \"New\" | \"Open\" | \"Pending\" | \"Closed\"\n        /// </summary>\n        public string Status { get; set; } = \"Open\";\n\n        /// <summary>\n        /// WhatsApp number id (e.g. wa-num-1).\n        /// Later you may map this to WhatsAppPhoneNumber.Id.\n        /// </summary>\n        public string NumberId { get; set; } = string.Empty;\n\n        public string NumberLabel { get; set; } = string.Empty;\n\n        /// <summary>\n        /// True if within 24h messaging window (WhatsApp session).\n        /// </summary>\n        public bool Within24h { get; set; }\n\n        public string? AssignedToUserId { get; set; }\n        public string? AssignedToUserName { get; set; }\n        public bool IsAssignedToMe { get; set; }\n\n        /// <summary>\n        /// \"automation\" | \"agent\"\n        /// </summary>\n        public string Mode { get; set; } = \"automation\";\n\n        /// <summary>\n        /// \"AutoReply\" | \"Campaign\" | \"Manual\" | \"Unknown\"\n        /// </summary>\n        public string SourceType { get; set; } = \"Unknown\";\n\n        /// <summary>\n        /// Campaign name / AutoReply flow name / other source label.\n        /// </summary>\n        public string? SourceName { get; set; }\n\n        public DateTime? FirstSeenAt { get; set; }\n        public DateTime? LastInboundAt { get; set; }\n        public DateTime? LastOutboundAt { get; set; }\n        public int TotalMessages { get; set; }\n\n        public DateTime? LastAgentReplyAt { get; set; }\n        public DateTime? LastAutomationAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ChatInboxCursorPageDto.cs",
      "sha256": "5b9d3ba892a383e22762a110b1cbfd2038d445929c9ab4b03b9d0c339b840123",
      "language": "csharp",
      "size": 520,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/DTOs/ChatInboxCursorPageDto.cs\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    /// <summary>\n    /// Cursor-based page response (stable for chat inbox).\n    /// </summary>\n    public sealed class ChatInboxCursorPageDto<T>\n    {\n        public IReadOnlyList<T> Items { get; init; } = new List<T>();\n        public string? NextCursor { get; init; }\n        public bool HasMore { get; init; }\n        public int Limit { get; init; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ChatInboxFilterDto.cs",
      "sha256": "b99a5373eb144c852da882a680e3fb479d1a5b649af882f3465e9e30715968a0",
      "language": "csharp",
      "size": 1916,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/DTOs/ChatInboxFilterDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    /// <summary>\n    /// Filters used by the Chat Inbox conversation list endpoint.\n    /// This matches the UI needs: tab, number, search, \"my\" vs \"unassigned\".\n    /// </summary>\n    public sealed class ChatInboxFilterDto\n    {\n        /// <summary>\n        /// Business Id (tenant). Mandatory for multi-tenant isolation.\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        public string? Cursor { get; set; }\n        /// <summary>\n        /// Currently logged-in user id (for \"my\" filter).\n        /// Optional: if null, \"my\" filter is ignored.\n        /// </summary>\n        public Guid? CurrentUserId { get; set; }\n\n        /// <summary>\n        /// \"live\" | \"older\" | \"unassigned\" | \"my\" | \"closed\"\n        /// </summary>\n        public string? Tab { get; set; }\n\n        /// <summary>\n        /// Optional: fetch a single conversation by contact id.\n        /// </summary>\n        public Guid? ContactId { get; set; }\n\n        /// <summary>\n        /// WhatsApp number id, e.g. \"wa-num-1\". If null or \"all\", no filter.\n        /// </summary>\n        public string? NumberId { get; set; }\n\n        /// <summary>\n        /// Free text search over name, phone, and last message preview.\n        /// </summary>\n        public string? SearchTerm { get; set; }\n\n        /// <summary>\n        /// Max number of conversations to return. Hard-capped to 200.\n        /// </summary>\n        public int Limit { get; set; } = 50;\n\n        /// <summary>\n        /// If true: only conversations without AssignedToUserId.\n        /// </summary>\n        public bool OnlyUnassigned { get; set; }\n\n        /// <summary>\n        /// If true: only conversations assigned to CurrentUserId.\n        /// </summary>\n        public bool OnlyAssignedToMe { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ChatInboxMarkReadRequestDto.cs",
      "sha256": "a149e08b11d6e43c54066ace777250ca1a630fbe15ef812f7fdc73b6fa67d3d0",
      "language": "csharp",
      "size": 864,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/DTOs/ChatInboxMarkReadRequestDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    /// <summary>\n    /// Request payload for marking a conversation as \"read\"\n    /// in the Chat Inbox.\n    /// </summary>\n    public sealed class ChatInboxMarkReadRequestDto\n    {\n        /// <summary>\n        /// Tenant/business id (required for multi-tenant isolation).\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// CRM Contact id whose messages are being marked as read.\n        /// </summary>\n        public Guid ContactId { get; set; }\n\n        /// <summary>\n        /// Optional timestamp for \"last read\". If not supplied,\n        /// the server will use DateTime.UtcNow.\n        /// </summary>\n        public DateTime? LastReadAtUtc { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ChatInboxMediaUploadRequestDto.cs",
      "sha256": "6374d18d1fa2a5ae289a17972f84c6693d0631ce10d312053e64f62c425b8415",
      "language": "csharp",
      "size": 274,
      "content": "using System.ComponentModel.DataAnnotations;\nusing Microsoft.AspNetCore.Http;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    public sealed class ChatInboxMediaUploadRequestDto\n    {\n        [Required]\n        public IFormFile File { get; set; } = default!;\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ChatInboxMediaUploadResponseDto.cs",
      "sha256": "ae80a0e2830c284d7c7a52d12f86a10e59a9e6959951252d9e532b9c4a6d6bb6",
      "language": "csharp",
      "size": 489,
      "content": "namespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    public sealed class ChatInboxMediaUploadResponseDto\n    {\n        public string MediaId { get; set; } = string.Empty;\n\n        /// <summary>\n        /// \"image\" | \"document\"\n        /// </summary>\n        public string MediaType { get; set; } = string.Empty;\n\n        public string FileName { get; set; } = string.Empty;\n        public string MimeType { get; set; } = string.Empty;\n        public long SizeBytes { get; set; }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ChatInboxMessageDto.cs",
      "sha256": "f8f922c594dd6eab46fd6a23854879e9656d87965e61b0a7376d101d1e1b06e3",
      "language": "csharp",
      "size": 2484,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/DTOs/ChatInboxMessageDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    /// <summary>\n    /// Single message in a Chat Inbox conversation.\n    /// Kept intentionally simple and stable so the React UI\n    /// can bind to it without worrying about provider details.\n    /// </summary>\n    public sealed class ChatInboxMessageDto\n    {\n        public Guid Id { get; set; }\n\n        /// <summary>\n        /// \"in\"  = message came from customer to us.\n        /// \"out\" = message we sent to customer.\n        /// For now we only have reliable data for \"out\"; we keep\n        /// the string type so we can extend it later without schema changes.\n        /// </summary>\n        public string Direction { get; set; } = \"out\";\n\n        /// <summary>\n        /// Channel identifier (e.g. \"whatsapp\") ‚Äì future-proofing.\n        /// </summary>\n        public string Channel { get; set; } = \"whatsapp\";\n\n        /// <summary>\n        /// Rendered text content for the bubble.\n        /// For templates we'll store the final rendered body.\n        /// </summary>\n        public string Text { get; set; } = string.Empty;\n\n        /// <summary>\n        /// WhatsApp media_id (if this is a media message).\n        /// </summary>\n        public string? MediaId { get; set; }\n\n        /// <summary>\n        /// \"image\" | \"document\" | \"video\" | \"audio\" | \"location\"\n        /// </summary>\n        public string? MediaType { get; set; }\n\n        public string? FileName { get; set; }\n        public string? MimeType { get; set; }\n\n        // Location message fields (when MediaType == \"location\")\n        public double? LocationLatitude { get; set; }\n        public double? LocationLongitude { get; set; }\n        public string? LocationName { get; set; }\n        public string? LocationAddress { get; set; }\n\n        /// <summary>\n        /// When we created/sent the message (UTC).\n        /// If SentAt is missing, falls back to CreatedAt.\n        /// </summary>\n        public DateTime SentAtUtc { get; set; }\n\n        /// <summary>\n        /// Provider / delivery status (‚ÄúSent‚Äù, ‚ÄúDelivered‚Äù, ‚ÄúRead‚Äù, ‚ÄúFailed‚Äù, etc.),\n        /// mapped from MessageLog.Status.\n        /// </summary>\n        public string? Status { get; set; }\n\n        /// <summary>\n        /// For failed messages, a short error string from MessageLog.ErrorMessage.\n        /// </summary>\n        public string? ErrorMessage { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ChatInboxSendMessageRequestDto.cs",
      "sha256": "0a72e0104e08707d417ff580ebf77e10e625d9b19e431c9bca6d8efad72ef923",
      "language": "csharp",
      "size": 2198,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/DTOs/ChatInboxSendMessageRequestDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    /// <summary>\n    /// Request payload for sending an agent reply from the Chat Inbox.\n    /// NOTE: ActorUserId is ALWAYS set by the server from JWT claims.\n    /// The client should NOT send it (and we ignore it if they do).\n    /// </summary>\n    public sealed class ChatInboxSendMessageRequestDto\n    {\n        public Guid BusinessId { get; set; }\n\n        public string? ConversationId { get; set; }\n\n        public Guid? ContactId { get; set; }\n\n        public string To { get; set; } = string.Empty;\n\n        public string? NumberId { get; set; }\n\n        /// <summary>\n        /// Optional for media messages. Required when sending plain text.\n        /// For media, this becomes the optional caption.\n        /// </summary>\n        public string? Text { get; set; }\n\n        /// <summary>\n        /// WhatsApp Cloud API media id returned by /{phone_number_id}/media upload.\n        /// </summary>\n        public string? MediaId { get; set; }\n\n        /// <summary>\n        /// \"image\" | \"document\" | \"video\" | \"audio\"\n        /// For location messages, send coordinates and set MediaType to \"location\" (MediaId must be null).\n        /// </summary>\n        public string? MediaType { get; set; }\n\n        /// <summary>\n        /// Original filename for UI display (optional).\n        /// </summary>\n        public string? FileName { get; set; }\n\n        /// <summary>\n        /// Client-supplied mime type for display/logging (optional).\n        /// </summary>\n        public string? MimeType { get; set; }\n\n        /// <summary>\n        /// Optional: WhatsApp \"location\" message fields.\n        /// When provided, MediaId must be null.\n        /// </summary>\n        public double? LocationLatitude { get; set; }\n        public double? LocationLongitude { get; set; }\n        public string? LocationName { get; set; }\n        public string? LocationAddress { get; set; }\n\n        /// <summary>\n        /// Server-side only (claims). Controller will overwrite it.\n        /// </summary>\n        public Guid ActorUserId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ConversationSummaryDto.cs",
      "sha256": "8d4800233670cbca833d145eba5da1a64e0b2a520e5f5bfc65ea5a36c2c9ce86",
      "language": "csharp",
      "size": 2421,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    /// <summary>\n    /// Read model used by the Chat Inbox to show the left-hand conversation list.\n    /// Mirrors the shape used in ChatInbox.jsx (INITIAL_CONVERSATIONS).\n    /// </summary>\n    public class ConversationSummaryDto\n    {\n        public Guid ContactId { get; set; }\n\n        /// <summary>\n        /// Primary display name (CRM contact name).\n        /// </summary>\n        public string? Name { get; set; }\n\n        /// <summary>\n        /// WhatsApp phone number (normalized).\n        /// </summary>\n        public string PhoneNumber { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Latest WhatsApp profile.name we saw.\n        /// </summary>\n        public string? ProfileName { get; set; }\n\n        /// <summary>\n        /// Short preview of the last message in this conversation.\n        /// </summary>\n        public string? LastMessagePreview { get; set; }\n\n        /// <summary>\n        /// When the last message was seen/sent.\n        /// </summary>\n        public DateTime? LastMessageAt { get; set; }\n\n        /// <summary>\n        /// Count of unread inbound messages for this contact.\n        /// </summary>\n        public int UnreadCount { get; set; }\n\n        /// <summary>\n        /// Priority like \"Hot\", \"Warm\", \"Cold\" (CRM-driven, optional).\n        /// </summary>\n        public string? Priority { get; set; }\n\n        /// <summary>\n        /// True if this contact is treated as VIP or important.\n        /// </summary>\n        public bool IsVip { get; set; }\n\n        /// <summary>\n        /// Conversation mode: \"automation\" or \"agent\".\n        /// </summary>\n        public string Mode { get; set; } = \"automation\";\n\n        /// <summary>\n        /// Name of the assigned agent (if any).\n        /// </summary>\n        public string? AssignedAgentName { get; set; }\n\n        /// <summary>\n        /// CRM tags as chips for quick context (e.g. VIP, Lead, Follow-up).\n        /// </summary>\n        public List<string> Tags { get; set; } = new();\n\n        /// <summary>\n        /// Text like \"3 notes ‚Ä¢ 1 reminder today\".\n        /// </summary>\n        public string? LastActivitySummary { get; set; }\n\n        /// <summary>\n        /// Text like \"Next follow-up tomorrow at 11:30 AM\".\n        /// </summary>\n        public string? TaskSummary { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/PagedResultDto.cs",
      "sha256": "256698ff426847411942435cade73faa92f50fc27f5e7dbc7c0f762636295a9c",
      "language": "csharp",
      "size": 300,
      "content": "using System.Collections.Generic;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    public sealed class PagedResultDto<T>\n    {\n        public IReadOnlyList<T> Items { get; set; } = new List<T>();\n        public string? NextCursor { get; set; }\n        public bool HasMore { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/SetConversationStatusDto.cs",
      "sha256": "5686e967c1ba7e485a8d5f69b4da51b3a69d36cc023b4ad5fbd04d7cba000ec0",
      "language": "csharp",
      "size": 277,
      "content": "using System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    public sealed class SetConversationStatusDto\n    {\n        public Guid BusinessId { get; set; }\n        public Guid ContactId { get; set; }\n        public string Status { get; set; } = string.Empty;\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/UnassignConversationDto.cs",
      "sha256": "0b4e055e968dada296fa15e5e67504d866f3fa7f6eaef725a22ff4461a7a47cf",
      "language": "csharp",
      "size": 217,
      "content": "using System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    public sealed class UnassignConversationDto\n    {\n        public Guid BusinessId { get; set; }\n        public Guid ContactId { get; set; }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/Models/InboxVisibilityMode.cs",
      "sha256": "bc601a083f20bb953e8ea9e5ea77287d22bbe2fc6998ab7b0e6ace4658896154",
      "language": "csharp",
      "size": 154,
      "content": "namespace xbytechat.api.Features.ChatInbox.Models\n{\n    public enum InboxVisibilityMode\n    {\n        SharedInInbox = 0,\n        AssignedOnly = 1\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/Services/ChatInboxAssignmentService.cs",
      "sha256": "2f77b7126a586ad3ce50d7958c4b37735d813513c50850985f314c6247f46bdd",
      "language": "csharp",
      "size": 14600,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.SignalR;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.AuthModule.Models;\nusing xbytechat.api.Features.AccessControl.Models;\nusing xbytechat.api.Features.ChatInbox.DTOs;\nusing xbytechat.api.Features.CRM.Models;\nusing xbytechat.api.Features.Inbox.Hubs;\n\nnamespace xbytechat.api.Features.ChatInbox.Services\n{\n    public sealed class ChatInboxAssignmentService : IChatInboxAssignmentService\n    {\n        private const string InboxAssignPermissionCode = \"INBOX.CHAT.ASSIGN\";\n\n        private readonly AppDbContext _db;\n        private readonly ILogger<ChatInboxAssignmentService> _logger;\n        private readonly IHubContext<InboxHub> _hub;\n\n        public ChatInboxAssignmentService(\n            AppDbContext db,\n            ILogger<ChatInboxAssignmentService> logger,\n            IHubContext<InboxHub> hub)\n        {\n            _db = db ?? throw new ArgumentNullException(nameof(db));\n            _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n            _hub = hub ?? throw new ArgumentNullException(nameof(hub));\n        }\n\n        public async Task<List<AgentDto>> GetAgentsAsync(Guid businessId, CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty)\n                throw new ArgumentException(\"BusinessId is required.\", nameof(businessId));\n\n            var agents = await _db.Users\n                .AsNoTracking()\n                .Where(u => u.BusinessId == businessId && !u.IsDeleted && u.Status == \"Active\")\n                .Include(u => u.Role)\n                .OrderBy(u => u.Name)\n                .Select(u => new AgentDto\n                {\n                    Id = u.Id,\n                    Name = u.Name ?? u.Email,\n                    Email = u.Email,\n                    RoleName = u.Role != null ? u.Role.Name : null\n                })\n                .ToListAsync(ct)\n                .ConfigureAwait(false);\n\n            return agents;\n        }\n\n        public async Task AssignAsync(\n            Guid businessId,\n            Guid contactId,\n            Guid userId,\n            Guid actorUserId,\n            CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty) throw new ArgumentException(\"BusinessId is required.\", nameof(businessId));\n            if (contactId == Guid.Empty) throw new ArgumentException(\"ContactId is required.\", nameof(contactId));\n            if (userId == Guid.Empty) throw new ArgumentException(\"UserId is required.\", nameof(userId));\n            if (actorUserId == Guid.Empty) throw new ArgumentException(\"ActorUserId is required.\", nameof(actorUserId));\n\n            var actor = await LoadActiveBusinessUserAsync(businessId, actorUserId, ct).ConfigureAwait(false);\n            _ = await LoadActiveBusinessUserAsync(businessId, userId, ct).ConfigureAwait(false); // validate target exists + active\n\n            var isSelfAssign = actorUserId == userId;\n            var canAssignOthers = await CanAssignOthersAsync(actor, ct).ConfigureAwait(false);\n\n            // ? If assigning someone else, permission required\n            if (!isSelfAssign && !canAssignOthers)\n                throw new UnauthorizedAccessException(\"Not allowed to assign conversations to other agents.\");\n\n            // ? Atomic rules:\n            // - Privileged/assign-perm can assign/reassign freely.\n            // - Self-assign without privilege is allowed ONLY when currently unassigned (prevents stealing).\n            var q = _db.Contacts.Where(c => c.BusinessId == businessId && c.Id == contactId);\n\n            if (isSelfAssign && !canAssignOthers)\n                q = q.Where(c => c.AssignedAgentId == null);\n\n            var updated = await q\n                .ExecuteUpdateAsync(\n                    setters => setters.SetProperty(c => c.AssignedAgentId, userId),\n                    ct)\n                .ConfigureAwait(false);\n\n            if (updated == 0)\n            {\n                if (isSelfAssign && !canAssignOthers)\n                    throw new UnauthorizedAccessException(\"Not allowed to self-assign. This chat is already assigned to another agent.\");\n\n                throw new InvalidOperationException(\"Contact not found for assignment.\");\n            }\n\n            _logger.LogInformation(\n                \"ChatInbox assigned. BusinessId={BusinessId} ContactId={ContactId} AssignedToUserId={AssignedToUserId} ActorUserId={ActorUserId}\",\n                businessId, contactId, userId, actorUserId);\n\n            await BroadcastRefreshAsync(businessId).ConfigureAwait(false);\n        }\n\n\n\n        public async Task UnassignAsync(Guid businessId, Guid contactId, Guid actorUserId, CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty) throw new ArgumentException(\"BusinessId is required.\", nameof(businessId));\n            if (contactId == Guid.Empty) throw new ArgumentException(\"ContactId is required.\", nameof(contactId));\n            if (actorUserId == Guid.Empty) throw new ArgumentException(\"ActorUserId is required.\", nameof(actorUserId));\n\n            var actor = await LoadActiveBusinessUserAsync(businessId, actorUserId, ct).ConfigureAwait(false);\n            var canAssignOthers = await CanAssignOthersAsync(actor, ct).ConfigureAwait(false);\n\n            // ? Atomic rules:\n            // - Privileged/assign-perm can unassign freely.\n            // - Non-privileged can unassign ONLY if currently assigned to them (or already unassigned).\n            var q = _db.Contacts.Where(c => c.BusinessId == businessId && c.Id == contactId);\n\n            if (!canAssignOthers)\n                q = q.Where(c => c.AssignedAgentId == null || c.AssignedAgentId == actorUserId);\n\n            var updated = await q\n                .ExecuteUpdateAsync(setters => setters.SetProperty(c => c.AssignedAgentId, (Guid?)null), ct)\n                .ConfigureAwait(false);\n\n            if (updated == 0)\n            {\n                // ? Perfect distinction: not found vs not allowed\n                var exists = await _db.Contacts\n                    .AsNoTracking()\n                    .AnyAsync(c => c.BusinessId == businessId && c.Id == contactId, ct)\n                    .ConfigureAwait(false);\n\n                if (!exists)\n                    throw new InvalidOperationException(\"Contact not found.\");\n\n                throw new UnauthorizedAccessException(\"Not allowed to unassign conversations owned by another agent.\");\n            }\n\n            _logger.LogInformation(\n                \"ChatInbox unassigned. BusinessId={BusinessId} ContactId={ContactId} ActorUserId={ActorUserId}\",\n                businessId, contactId, actorUserId);\n\n            await BroadcastRefreshAsync(businessId).ConfigureAwait(false);\n        }\n\n\n        public async Task SetStatusAsync(\n            Guid businessId,\n            Guid contactId,\n            string status,\n            Guid actorUserId,\n            CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty) throw new ArgumentException(\"BusinessId is required.\", nameof(businessId));\n            if (contactId == Guid.Empty) throw new ArgumentException(\"ContactId is required.\", nameof(contactId));\n            if (actorUserId == Guid.Empty) throw new ArgumentException(\"ActorUserId is required.\", nameof(actorUserId));\n\n            var normalized = NormalizeStatus(status);\n            if (normalized == null)\n                throw new ArgumentException(\"Status must be one of: Open, Pending, Closed.\", nameof(status));\n\n            var actor = await LoadActiveBusinessUserAsync(businessId, actorUserId, ct).ConfigureAwait(false);\n            var contact = await LoadBusinessContactAsync(businessId, contactId, ct).ConfigureAwait(false);\n\n            var canUpdate =\n                IsPrivilegedRole(actor) ||\n                (contact.AssignedAgentId.HasValue && contact.AssignedAgentId.Value == actorUserId);\n\n            if (!canUpdate)\n                throw new UnauthorizedAccessException(\"Not allowed to update this conversation status.\");\n\n            contact.InboxStatus = normalized;\n\n            // Back-compat for older query logic\n            if (normalized == \"Closed\")\n            {\n                contact.IsArchived = true;\n                contact.IsActive = false;\n            }\n            else\n            {\n                contact.IsArchived = false;\n                contact.IsActive = true;\n            }\n\n            _logger.LogInformation(\n                \"ChatInbox status updated. BusinessId={BusinessId} ContactId={ContactId} Status={Status} ActorUserId={ActorUserId}\",\n                businessId, contactId, normalized, actorUserId);\n\n            await _db.SaveChangesAsync(ct).ConfigureAwait(false);\n            await BroadcastRefreshAsync(businessId).ConfigureAwait(false);\n        }\n\n        private static string? NormalizeStatus(string? status)\n        {\n            var raw = (status ?? string.Empty).Trim();\n            if (raw.Length == 0) return null;\n\n            var lower = raw.ToLowerInvariant();\n            return lower switch\n            {\n                \"open\" => \"Open\",\n                \"pending\" => \"Pending\",\n                \"closed\" => \"Closed\",\n                _ => null\n            };\n        }\n\n        private async Task<Contact> LoadBusinessContactAsync(Guid businessId, Guid contactId, CancellationToken ct)\n        {\n            var contact = await _db.Contacts\n                .FirstOrDefaultAsync(c => c.BusinessId == businessId && c.Id == contactId, ct)\n                .ConfigureAwait(false);\n\n            if (contact == null)\n                throw new InvalidOperationException(\"Contact not found.\");\n\n            return contact;\n        }\n\n        private async Task<User> LoadActiveBusinessUserAsync(Guid businessId, Guid userId, CancellationToken ct)\n        {\n            var user = await _db.Users\n                .Include(u => u.Role)\n                .FirstOrDefaultAsync(u => u.Id == userId && !u.IsDeleted, ct)\n                .ConfigureAwait(false);\n\n            if (user == null)\n                throw new InvalidOperationException(\"User not found.\");\n\n            if (user.BusinessId != businessId)\n                throw new UnauthorizedAccessException(\"User does not belong to this business.\");\n\n            if (!string.Equals(user.Status, \"Active\", StringComparison.OrdinalIgnoreCase))\n                throw new UnauthorizedAccessException(\"User is not active.\");\n\n            return user;\n        }\n\n        private static bool IsPrivilegedRole(User actor)\n        {\n            var role = (actor.Role?.Name ?? string.Empty).Trim().ToLowerInvariant();\n            return role is \"admin\" or \"business\" or \"superadmin\" or \"partner\";\n        }\n\n        private async Task<bool> CanAssignOthersAsync(User actor, CancellationToken ct)\n        {\n            if (IsPrivilegedRole(actor)) return true;\n            return await HasPermissionAsync(actor.Id, InboxAssignPermissionCode, ct).ConfigureAwait(false);\n        }\n\n        private async Task<bool> HasPermissionAsync(Guid userId, string permissionCode, CancellationToken ct)\n        {\n            // Permission sources checked:\n            // 1) UserPermissions (direct user overrides)\n            // 2) RolePermissions (business role mapping)\n            var rawCode = (permissionCode ?? string.Empty).Trim();\n            var code = rawCode.ToUpperInvariant();\n            if (code.Length == 0) return false;\n\n            var permissionId = await _db.Permissions\n                .AsNoTracking()\n                .Where(p => p.Code != null && p.Code.ToUpper() == code)\n                .Select(p => (Guid?)p.Id)\n                .FirstOrDefaultAsync(ct)\n                .ConfigureAwait(false);\n\n            if (!permissionId.HasValue) return false;\n\n            var direct = await _db.UserPermissions\n                .AsNoTracking()\n                .AnyAsync(\n                    up => up.UserId == userId\n                          && up.PermissionId == permissionId.Value\n                          && up.IsGranted\n                          && !up.IsRevoked,\n                    ct)\n                .ConfigureAwait(false);\n\n            if (direct)\n            {\n                _logger.LogDebug(\n                    \"Permission granted via UserPermissions override. UserId={UserId} PermissionCode={PermissionCode}\",\n                    userId,\n                    rawCode);\n                return true;\n            }\n\n            var roleId = await _db.Users\n                .AsNoTracking()\n                .Where(u => u.Id == userId)\n                .Select(u => u.RoleId)\n                .FirstOrDefaultAsync(ct)\n                .ConfigureAwait(false);\n\n            if (!roleId.HasValue)\n            {\n                _logger.LogDebug(\n                    \"Permission denied (no role). UserId={UserId} PermissionCode={PermissionCode}\",\n                    userId,\n                    rawCode);\n                return false;\n            }\n\n            var byRole = await _db.RolePermissions\n                .AsNoTracking()\n                .AnyAsync(\n                    rp => rp.RoleId == roleId.Value\n                          && rp.PermissionId == permissionId.Value\n                          && rp.IsActive\n                          && !rp.IsRevoked,\n                    ct)\n                .ConfigureAwait(false);\n\n            if (byRole)\n            {\n                _logger.LogDebug(\n                    \"Permission granted via RolePermissions mapping. UserId={UserId} RoleId={RoleId} PermissionCode={PermissionCode}\",\n                    userId,\n                    roleId.Value,\n                    rawCode);\n                return true;\n            }\n\n            _logger.LogDebug(\n                \"Permission denied (no direct or role grant). UserId={UserId} RoleId={RoleId} PermissionCode={PermissionCode}\",\n                userId,\n                roleId.Value,\n                rawCode);\n\n            return byRole;\n        }\n\n        private async Task BroadcastRefreshAsync(Guid businessId)\n        {\n            try\n            {\n                await _hub.Clients\n                    .Group($\"business_{businessId}\")\n                    .SendAsync(\"UnreadCountChanged\", new { refresh = true })\n                    .ConfigureAwait(false);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"Failed to broadcast inbox refresh. BusinessId={BusinessId}\", businessId);\n            }\n        }\n    }\n}\n"
    }
  ]
}
