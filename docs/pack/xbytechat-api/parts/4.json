{
  "name": "xbytechat-api",
  "part": 4,
  "of": 33,
  "generatedAt": "2026-02-11 19:15:17 +00:00",
  "files": [
    {
      "path": "xbytechat-api/Features/ChatInbox/Services/ChatInboxCommandService.cs",
      "sha256": "1903a47a21202dae04970f7ef082e3f9a12f5566d569d4aeaf661371d04a9fcb",
      "language": "csharp",
      "size": 20979,
      "content": "// ðŸ“„ xbytechat-api/Features/ChatInbox/Services/ChatInboxCommandService.cs\nusing System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.AuthModule.Models;                 // User\nusing xbytechat.api.Features.AccessControl.Models;     // Permissions, RolePermissions, UserPermissions\nusing xbytechat.api.Features.ChatInbox.DTOs;\nusing xbytechat.api.Features.CRM.Models;               // Contact\nusing xbytechat.api.Features.Inbox.Models;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Models;                            // AppDbContext, MessageLog\n\nnamespace xbytechat.api.Features.ChatInbox.Services\n{\n    /// <summary>\n    /// SharedInInbox visibility + Assigned-only reply (enterprise).\n    ///\n    /// Rules (Shared visibility):\n    /// 1) Anyone can SEE chats (SharedInInbox) â€” enforced on query layer/UI.\n    /// 2) Reply allowed ONLY when:\n    ///    - chat is assigned to actor, OR\n    ///    - actor is Business/Platform privileged, OR\n    ///    - actor has INBOX.CHAT.ASSIGN (manager-style override)\n    /// 3) Unassigned chats:\n    ///    - âœ… Any ACTIVE agent can \"claim on reply\" (auto self-assign) and reply.\n    /// </summary>\n    public sealed class ChatInboxCommandService : IChatInboxCommandService\n    {\n        private const string InboxAssignPermissionCode = \"INBOX.CHAT.ASSIGN\";\n\n        private readonly AppDbContext _db;\n        private readonly IMessageEngineService _messageEngine;\n\n        public ChatInboxCommandService(AppDbContext db, IMessageEngineService messageEngine)\n        {\n            _db = db ?? throw new ArgumentNullException(nameof(db));\n            _messageEngine = messageEngine ?? throw new ArgumentNullException(nameof(messageEngine));\n        }\n\n        public async Task<ChatInboxMessageDto> SendAgentMessageAsync(\n            ChatInboxSendMessageRequestDto request,\n            CancellationToken ct = default)\n        {\n            if (request == null) throw new ArgumentNullException(nameof(request));\n\n            if (request.BusinessId == Guid.Empty)\n                throw new ArgumentException(\"BusinessId is required.\", nameof(request));\n\n            // NOTE: ActorUserId must be set server-side from token (do NOT trust UI).\n            if (request.ActorUserId == Guid.Empty)\n                throw new ArgumentException(\"ActorUserId is required (server-side).\", nameof(request));\n\n            if (string.IsNullOrWhiteSpace(request.To))\n                throw new ArgumentException(\"Target phone (To) is required.\", nameof(request));\n\n            var text = string.IsNullOrWhiteSpace(request.Text) ? null : request.Text.Trim();\n            var mediaId = string.IsNullOrWhiteSpace(request.MediaId) ? null : request.MediaId.Trim();\n            var mediaType = string.IsNullOrWhiteSpace(request.MediaType) ? null : request.MediaType.Trim().ToLowerInvariant();\n            var hasLocation = request.LocationLatitude.HasValue && request.LocationLongitude.HasValue;\n\n            var hasText = !string.IsNullOrWhiteSpace(text);\n            var hasMedia = !string.IsNullOrWhiteSpace(mediaId);\n\n            if (!hasText && !hasMedia && !hasLocation)\n                throw new ArgumentException(\"Either Text, MediaId, or Location is required.\", nameof(request));\n\n            if (hasMedia && mediaType is not (\"image\" or \"document\" or \"video\" or \"audio\"))\n                throw new ArgumentException(\"MediaType must be 'image', 'document', 'video', or 'audio'.\", nameof(request));\n\n            if (hasMedia && mediaType == \"audio\" && hasText)\n                throw new ArgumentException(\"Audio messages do not support captions. Please remove Text.\", nameof(request));\n\n            if (hasLocation && (hasMedia || hasText))\n                throw new ArgumentException(\"Location messages cannot include Text or MediaId.\", nameof(request));\n\n            if (hasLocation)\n            {\n                var lat = request.LocationLatitude!.Value;\n                var lon = request.LocationLongitude!.Value;\n                if (lat < -90 || lat > 90) throw new ArgumentException(\"LocationLatitude must be between -90 and 90.\", nameof(request));\n                if (lon < -180 || lon > 180) throw new ArgumentException(\"LocationLongitude must be between -180 and 180.\", nameof(request));\n            }\n\n            var businessId = request.BusinessId;\n            var actorUserId = request.ActorUserId;\n            var phone = request.To.Trim();\n\n            // âœ… Load actor (must be active and belong to business)\n            var actor = await LoadActiveBusinessUserAsync(businessId, actorUserId, ct).ConfigureAwait(false);\n\n            // âœ… Resolve & load contact (tracked)\n            var contact = await LoadTrackedContactAsync(businessId, request.ContactId, phone, ct).ConfigureAwait(false);\n\n            // âœ… Closed / archived / inactive => block\n            EnsureConversationIsReplyable(contact);\n\n            // âœ… Enforce reply rules (includes claim-on-reply for ANY agent)\n            await EnforceAssignedOnlyReplyAsync(actor, contact, ct).ConfigureAwait(false);\n\n            // ðŸ“¨ Send via MessagesEngine\n            var result =\n                hasMedia\n                    ? await SendMediaAsync(businessId, phone, contact.Id, request, mediaId!, mediaType!, text).ConfigureAwait(false)\n                    : hasLocation\n                        ? await SendLocationAsync(businessId, phone, contact.Id, request).ConfigureAwait(false)\n                        : await _messageEngine.SendTextDirectAsync(new TextMessageSendDto\n                        {\n                            BusinessId = businessId,\n                            RecipientNumber = phone,\n                            TextContent = text!,\n                            ContactId = contact.Id,\n                            PhoneNumberId = string.IsNullOrWhiteSpace(request.NumberId) ? null : request.NumberId.Trim(),\n                            Provider = null,\n                            Source = \"agent\"\n                        }).ConfigureAwait(false);\n\n            // Load log for richer bubble\n            MessageLog? log = null;\n            if (result.LogId.HasValue)\n            {\n                log = await _db.MessageLogs\n                    .AsNoTracking()\n                    .FirstOrDefaultAsync(m => m.Id == result.LogId.Value, ct)\n                    .ConfigureAwait(false);\n            }\n\n            // Update conversation meta (outbound)\n            var nowUtc = DateTime.UtcNow;\n            contact.LastOutboundAt = nowUtc;\n            await _db.SaveChangesAsync(ct).ConfigureAwait(false);\n\n            var bubbleId = log?.Id ?? Guid.NewGuid();\n            var bubbleText = log?.MessageContent ?? (text ?? string.Empty);\n\n            var ts = log?.SentAt ?? log?.CreatedAt ?? nowUtc;\n            var sentAtUtc = ts.Kind == DateTimeKind.Utc ? ts : ts.ToUniversalTime();\n\n            var status = log?.Status ?? (result.Success ? \"Sent\" : \"Failed\");\n            var err = log?.ErrorMessage ?? (result.Success ? null : result.Message);\n\n            return new ChatInboxMessageDto\n            {\n                Id = bubbleId,\n                Direction = \"out\",\n                Channel = \"whatsapp\",\n                Text = bubbleText,\n                MediaId = log?.MediaId,\n                MediaType = log?.MediaType,\n                FileName = log?.FileName,\n                MimeType = log?.MimeType,\n                LocationLatitude = log?.LocationLatitude,\n                LocationLongitude = log?.LocationLongitude,\n                LocationName = log?.LocationName,\n                LocationAddress = log?.LocationAddress,\n                SentAtUtc = sentAtUtc,\n                Status = status,\n                ErrorMessage = err\n            };\n        }\n\n        private async Task<ResponseResult> SendMediaAsync(\n            Guid businessId,\n            string to,\n            Guid contactId,\n            ChatInboxSendMessageRequestDto request,\n            string mediaId,\n            string mediaType,\n            string? caption)\n        {\n            var dto = new MediaMessageSendDto\n            {\n                BusinessId = businessId,\n                RecipientNumber = to,\n                MediaId = mediaId,\n                Caption = caption,\n                FileName = string.IsNullOrWhiteSpace(request.FileName) ? null : request.FileName.Trim(),\n                MimeType = string.IsNullOrWhiteSpace(request.MimeType) ? null : request.MimeType.Trim(),\n                ContactId = contactId,\n                PhoneNumberId = string.IsNullOrWhiteSpace(request.NumberId) ? null : request.NumberId.Trim(),\n                Provider = null,\n                Source = \"agent\"\n            };\n\n            return mediaType switch\n            {\n                \"image\" => await _messageEngine.SendImageDirectAsync(dto).ConfigureAwait(false),\n                \"document\" => await _messageEngine.SendDocumentDirectAsync(dto).ConfigureAwait(false),\n                \"video\" => await _messageEngine.SendVideoDirectAsync(dto).ConfigureAwait(false),\n                \"audio\" => await _messageEngine.SendAudioDirectAsync(dto).ConfigureAwait(false),\n                _ => throw new ArgumentException(\"Unsupported MediaType.\", nameof(mediaType))\n            };\n        }\n\n        private Task<ResponseResult> SendLocationAsync(\n            Guid businessId,\n            string to,\n            Guid contactId,\n            ChatInboxSendMessageRequestDto request)\n        {\n            var dto = new LocationMessageSendDto\n            {\n                BusinessId = businessId,\n                RecipientNumber = to,\n                ContactId = contactId,\n                PhoneNumberId = string.IsNullOrWhiteSpace(request.NumberId) ? null : request.NumberId.Trim(),\n                Provider = null,\n                Source = \"agent\",\n                Latitude = request.LocationLatitude!.Value,\n                Longitude = request.LocationLongitude!.Value,\n                Name = string.IsNullOrWhiteSpace(request.LocationName) ? null : request.LocationName.Trim(),\n                Address = string.IsNullOrWhiteSpace(request.LocationAddress) ? null : request.LocationAddress.Trim()\n            };\n\n            return _messageEngine.SendLocationDirectAsync(dto);\n        }\n\n        //public async Task MarkConversationAsReadAsync(ChatInboxMarkReadRequestDto request, CancellationToken ct = default)\n        //{\n        //    if (request == null) throw new ArgumentNullException(nameof(request));\n        //    if (request.BusinessId == Guid.Empty) throw new ArgumentException(\"BusinessId is required.\", nameof(request));\n        //    if (request.ContactId == Guid.Empty) throw new ArgumentException(\"ContactId is required.\", nameof(request));\n        //    if (request.UserId == Guid.Empty) throw new ArgumentException(\"UserId is required.\", nameof(request));\n\n        //    var businessId = request.BusinessId;\n        //    var contactId = request.ContactId;\n        //    var userId = request.UserId;\n        //    var nowUtc = DateTime.UtcNow;\n\n        //    var lastReadAt = request.LastReadAtUtc.HasValue\n        //        ? (request.LastReadAtUtc.Value.Kind == DateTimeKind.Utc\n        //            ? request.LastReadAtUtc.Value\n        //            : request.LastReadAtUtc.Value.ToUniversalTime())\n        //        : nowUtc;\n\n        //    var existing = await _db.ContactReads\n        //        .FirstOrDefaultAsync(\n        //            r => r.BusinessId == businessId && r.ContactId == contactId && r.UserId == userId,\n        //            ct)\n        //        .ConfigureAwait(false);\n\n        //    if (existing == null)\n        //    {\n        //        await _db.ContactReads.AddAsync(new ContactRead\n        //        {\n        //            Id = Guid.NewGuid(),\n        //            BusinessId = businessId,\n        //            ContactId = contactId,\n        //            UserId = userId,\n        //            LastReadAt = lastReadAt\n        //        }, ct).ConfigureAwait(false);\n        //    }\n        //    else\n        //    {\n        //        // Only move forward in time; never go backwards.\n        //        if (existing.LastReadAt < lastReadAt)\n        //        {\n        //            existing.LastReadAt = lastReadAt;\n        //            _db.ContactReads.Update(existing);\n        //        }\n        //    }\n\n        //    await _db.SaveChangesAsync(ct).ConfigureAwait(false);\n        //}\n        public async Task MarkConversationAsReadAsync(\n      Guid businessId,\n      Guid contactId,\n      Guid userId,\n      DateTime? lastReadAtUtc,\n      CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty) throw new ArgumentException(\"BusinessId is required.\", nameof(businessId));\n            if (contactId == Guid.Empty) throw new ArgumentException(\"ContactId is required.\", nameof(contactId));\n            if (userId == Guid.Empty) throw new ArgumentException(\"UserId is required.\", nameof(userId));\n\n            var nowUtc = DateTime.UtcNow;\n\n            var lastReadAt = lastReadAtUtc.HasValue\n                ? (lastReadAtUtc.Value.Kind == DateTimeKind.Utc\n                    ? lastReadAtUtc.Value\n                    : lastReadAtUtc.Value.ToUniversalTime())\n                : nowUtc;\n\n            var existing = await _db.ContactReads\n                .FirstOrDefaultAsync(\n                    r => r.BusinessId == businessId && r.ContactId == contactId && r.UserId == userId,\n                    ct)\n                .ConfigureAwait(false);\n\n            if (existing == null)\n            {\n                await _db.ContactReads.AddAsync(new ContactRead\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    ContactId = contactId,\n                    UserId = userId,\n                    LastReadAt = lastReadAt\n                }, ct).ConfigureAwait(false);\n            }\n            else\n            {\n                // Only move forward in time; never go backwards.\n                if (existing.LastReadAt < lastReadAt)\n                {\n                    existing.LastReadAt = lastReadAt;\n                }\n            }\n\n            await _db.SaveChangesAsync(ct).ConfigureAwait(false);\n        }\n\n        // -------------------------\n        // Helpers\n        // -------------------------\n\n        private static void EnsureConversationIsReplyable(Contact contact)\n        {\n            var inboxStatus = (contact.InboxStatus ?? string.Empty).Trim();\n\n            if (string.Equals(inboxStatus, \"Closed\", StringComparison.OrdinalIgnoreCase) ||\n                contact.IsArchived ||\n                !contact.IsActive)\n            {\n                throw new InvalidOperationException(\"Conversation is closed.\");\n            }\n        }\n\n        private async Task<Contact> LoadTrackedContactAsync(Guid businessId, Guid? contactId, string phone, CancellationToken ct)\n        {\n            if (contactId.HasValue && contactId.Value != Guid.Empty)\n            {\n                var byId = await _db.Contacts\n                    .FirstOrDefaultAsync(c => c.BusinessId == businessId && c.Id == contactId.Value, ct)\n                    .ConfigureAwait(false);\n\n                if (byId != null) return byId;\n            }\n\n            var byPhone = await _db.Contacts\n                .FirstOrDefaultAsync(c => c.BusinessId == businessId && c.PhoneNumber == phone, ct)\n                .ConfigureAwait(false);\n\n            if (byPhone == null)\n                throw new InvalidOperationException(\"Contact not found for this conversation.\");\n\n            return byPhone;\n        }\n\n        private async Task<User> LoadActiveBusinessUserAsync(Guid businessId, Guid userId, CancellationToken ct)\n        {\n            var user = await _db.Users\n                .Include(u => u.Role)\n                .FirstOrDefaultAsync(u => u.Id == userId && !u.IsDeleted, ct)\n                .ConfigureAwait(false);\n\n            if (user == null) throw new InvalidOperationException(\"User not found.\");\n            if (user.BusinessId != businessId) throw new UnauthorizedAccessException(\"User does not belong to this business.\");\n            if (!string.Equals(user.Status, \"Active\", StringComparison.OrdinalIgnoreCase))\n                throw new UnauthorizedAccessException(\"User is not active.\");\n\n            return user;\n        }\n\n        private async Task EnforceAssignedOnlyReplyAsync(User actor, Contact contact, CancellationToken ct)\n        {\n            // âœ… If already assigned to actor -> OK\n            if (contact.AssignedAgentId.HasValue && contact.AssignedAgentId.Value == actor.Id)\n                return;\n\n            // âœ… Shared visibility rule: unassigned chat -> claim-on-first-reply (ANY active agent)\n            if (!contact.AssignedAgentId.HasValue)\n            {\n                // Atomic claim to avoid race: two agents reply at same time\n                var claimed = await _db.Contacts\n                    .Where(c => c.BusinessId == contact.BusinessId\n                                && c.Id == contact.Id\n                                && c.AssignedAgentId == null)\n                    .ExecuteUpdateAsync(setters => setters.SetProperty(c => c.AssignedAgentId, actor.Id), ct)\n                    .ConfigureAwait(false);\n\n                if (claimed > 0)\n                {\n                    // Keep in-memory entity consistent\n                    contact.AssignedAgentId = actor.Id;\n                    return;\n                }\n\n                // Someone else claimed between read and write â†’ reload for correct enforcement\n                var fresh = await _db.Contacts\n                    .AsNoTracking()\n                    .Where(c => c.BusinessId == contact.BusinessId && c.Id == contact.Id)\n                    .Select(c => c.AssignedAgentId)\n                    .FirstOrDefaultAsync(ct)\n                    .ConfigureAwait(false);\n\n                contact.AssignedAgentId = fresh;\n                // Now fall through to \"assigned to someone else\" logic below\n            }\n\n            // âœ… Assigned to someone else -> only Business owner OR INBOX.CHAT.ASSIGN can override\n            var isBusinessOwner = IsBusinessOwner(actor);\n            var canAssign = await HasPermissionAsync(actor.Id, InboxAssignPermissionCode, ct).ConfigureAwait(false);\n\n            if (isBusinessOwner || canAssign)\n                return;\n\n            throw new UnauthorizedAccessException(\"Not allowed to reply. This chat is assigned to another agent.\");\n        }\n\n        private static bool IsBusinessOwner(User actor)\n        {\n            var role = (actor.Role?.Name ?? string.Empty).Trim().ToLowerInvariant();\n            return role == \"business\";\n        }\n\n        /// <summary>\n        /// Privileged = Business owner or platform roles.\n        /// Manager is NOT privileged unless they have INBOX.CHAT.ASSIGN.\n        /// </summary>\n        private static bool IsBusinessOrPlatformPrivileged(User actor)\n        {\n            var role = (actor.Role?.Name ?? string.Empty).Trim().ToLowerInvariant();\n            return role is \"business\" or \"admin\" or \"superadmin\" or \"partner\";\n        }\n\n        private async Task<bool> HasPermissionAsync(Guid userId, string permissionCode, CancellationToken ct)\n        {\n            var code = (permissionCode ?? string.Empty).Trim().ToUpperInvariant();\n            if (code.Length == 0) return false;\n\n            var permissionId = await _db.Permissions\n                .AsNoTracking()\n                .Where(p => p.Code != null && p.Code.ToUpper() == code)\n                .Select(p => (Guid?)p.Id)\n                .FirstOrDefaultAsync(ct)\n                .ConfigureAwait(false);\n\n            if (!permissionId.HasValue) return false;\n\n            // Direct user permission\n            var direct = await _db.UserPermissions\n                .AsNoTracking()\n                .AnyAsync(up =>\n                    up.UserId == userId &&\n                    up.PermissionId == permissionId.Value &&\n                    up.IsGranted &&\n                    !up.IsRevoked, ct)\n                .ConfigureAwait(false);\n\n            if (direct) return true;\n\n            // Role permission\n            var roleId = await _db.Users\n                .AsNoTracking()\n                .Where(u => u.Id == userId)\n                .Select(u => u.RoleId)\n                .FirstOrDefaultAsync(ct)\n                .ConfigureAwait(false);\n\n            if (!roleId.HasValue) return false;\n\n            var byRole = await _db.RolePermissions\n                .AsNoTracking()\n                .AnyAsync(rp =>\n                    rp.RoleId == roleId.Value &&\n                    rp.PermissionId == permissionId.Value &&\n                    rp.IsActive &&\n                    !rp.IsRevoked, ct)\n                .ConfigureAwait(false);\n\n            return byRole;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/Services/ChatInboxMediaContentService.cs",
      "sha256": "f694d8f000e1492ad60c86a810580189eb190b2998dcecf7a390f7a5c5e4c430",
      "language": "csharp",
      "size": 9859,
      "content": "using System;\nusing System.IO;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.TemplateModule.Abstractions;\n\nnamespace xbytechat.api.Features.ChatInbox.Services\n{\n    /// <summary>\n    /// Streams WhatsApp media bytes from Meta Cloud API without persisting on our servers.\n    /// This exists to support secure agent-side previews (the browser cannot attach Bearer tokens to &lt;img src&gt;).\n    /// </summary>\n    public sealed class ChatInboxMediaContentService : IChatInboxMediaContentService\n    {\n        private const string DefaultGraphVersion = \"v22.0\";\n\n        private readonly IHttpClientFactory _httpFactory;\n        private readonly IMetaCredentialsResolver _metaCreds;\n        private readonly ILogger<ChatInboxMediaContentService> _logger;\n\n        public ChatInboxMediaContentService(\n            IHttpClientFactory httpFactory,\n            IMetaCredentialsResolver metaCreds,\n            ILogger<ChatInboxMediaContentService> logger)\n        {\n            _httpFactory = httpFactory ?? throw new ArgumentNullException(nameof(httpFactory));\n            _metaCreds = metaCreds ?? throw new ArgumentNullException(nameof(metaCreds));\n            _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n        }\n\n        public async Task<(Stream Stream, string ContentType)> DownloadFromWhatsAppAsync(\n            Guid businessId,\n            string mediaId,\n            CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty) throw new ArgumentException(\"BusinessId is required.\", nameof(businessId));\n            if (string.IsNullOrWhiteSpace(mediaId)) throw new ArgumentException(\"mediaId is required.\", nameof(mediaId));\n\n            var creds = await _metaCreds.ResolveAsync(businessId, ct).ConfigureAwait(false);\n            var graphBase = (creds.GraphBaseUrl ?? string.Empty).Trim().TrimEnd('/');\n            var graphVersion = string.IsNullOrWhiteSpace(creds.GraphVersion)\n                ? DefaultGraphVersion\n                : creds.GraphVersion!.Trim().Trim('/');\n\n            if (string.IsNullOrWhiteSpace(graphBase))\n                throw new InvalidOperationException(\"WhatsApp Graph API base URL is missing.\");\n\n            var token = (creds.AccessToken ?? string.Empty).Trim();\n            if (string.IsNullOrWhiteSpace(token))\n                throw new InvalidOperationException(\"WhatsApp access token is missing for this business.\");\n\n            // Step 1: resolve the temporary media URL from Meta (GET /{media-id})\n            var metaUrl = $\"{graphBase}/{graphVersion}/{mediaId.Trim()}\";\n\n            using var metaReq = new HttpRequestMessage(HttpMethod.Get, metaUrl);\n            metaReq.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(\"application/json\"));\n            metaReq.Headers.Authorization = new AuthenticationHeaderValue(\"Bearer\", token);\n\n            using var client = _httpFactory.CreateClient(\"wa:meta_cloud\");\n            using var metaResp = await client.SendAsync(metaReq, HttpCompletionOption.ResponseHeadersRead, ct).ConfigureAwait(false);\n            var metaBody = await metaResp.Content.ReadAsStringAsync(ct).ConfigureAwait(false);\n\n            if (!metaResp.IsSuccessStatusCode)\n            {\n                var clean = TryGetMetaErrorMessage(metaBody) ?? \"Failed to resolve WhatsApp media URL.\";\n                _logger.LogWarning(\n                    \"ChatInbox media resolve failed. BusinessId={BusinessId} MediaId={MediaId} Status={Status} MetaError={MetaError}\",\n                    businessId,\n                    mediaId,\n                    (int)metaResp.StatusCode,\n                    clean);\n                throw new InvalidOperationException(clean);\n            }\n\n            var downloadUrl = TryGetMetaMediaUrl(metaBody);\n            var mimeType = TryGetMetaMediaMimeType(metaBody) ?? \"application/octet-stream\";\n\n            if (string.IsNullOrWhiteSpace(downloadUrl))\n                throw new InvalidOperationException(\"Meta did not return a download URL for this media.\");\n\n            // Step 2: stream the media bytes from the resolved URL (Bearer token required)\n            var fileReq = new HttpRequestMessage(HttpMethod.Get, downloadUrl);\n            fileReq.Headers.Authorization = new AuthenticationHeaderValue(\"Bearer\", token);\n\n            var fileResp = await client.SendAsync(fileReq, HttpCompletionOption.ResponseHeadersRead, ct).ConfigureAwait(false);\n            if (!fileResp.IsSuccessStatusCode)\n            {\n                var body = await fileResp.Content.ReadAsStringAsync(ct).ConfigureAwait(false);\n                fileResp.Dispose();\n\n                var clean = TryGetMetaErrorMessage(body) ?? \"Failed to download WhatsApp media.\";\n                _logger.LogWarning(\n                    \"ChatInbox media download failed. BusinessId={BusinessId} MediaId={MediaId} Status={Status} MetaError={MetaError}\",\n                    businessId,\n                    mediaId,\n                    (int)fileResp.StatusCode,\n                    clean);\n                throw new InvalidOperationException(clean);\n            }\n\n            var contentType =\n                fileResp.Content.Headers.ContentType?.MediaType ??\n                mimeType ??\n                \"application/octet-stream\";\n\n            Stream stream;\n            try\n            {\n                stream = await fileResp.Content.ReadAsStreamAsync(ct).ConfigureAwait(false);\n            }\n            catch\n            {\n                fileResp.Dispose();\n                throw;\n            }\n\n            return (new ResponseDisposingStream(stream, fileResp), contentType);\n        }\n\n        private sealed class ResponseDisposingStream : Stream\n        {\n            private readonly Stream _inner;\n            private readonly HttpResponseMessage _resp;\n\n            public ResponseDisposingStream(Stream inner, HttpResponseMessage resp)\n            {\n                _inner = inner ?? throw new ArgumentNullException(nameof(inner));\n                _resp = resp ?? throw new ArgumentNullException(nameof(resp));\n            }\n\n            public override bool CanRead => _inner.CanRead;\n            public override bool CanSeek => _inner.CanSeek;\n            public override bool CanWrite => _inner.CanWrite;\n            public override long Length => _inner.Length;\n            public override long Position { get => _inner.Position; set => _inner.Position = value; }\n            public override void Flush() => _inner.Flush();\n            public override int Read(byte[] buffer, int offset, int count) => _inner.Read(buffer, offset, count);\n            public override long Seek(long offset, SeekOrigin origin) => _inner.Seek(offset, origin);\n            public override void SetLength(long value) => _inner.SetLength(value);\n            public override void Write(byte[] buffer, int offset, int count) => _inner.Write(buffer, offset, count);\n            public override Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken) =>\n                _inner.ReadAsync(buffer, offset, count, cancellationToken);\n            public override ValueTask<int> ReadAsync(Memory<byte> buffer, CancellationToken cancellationToken = default) =>\n                _inner.ReadAsync(buffer, cancellationToken);\n            public override Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken) =>\n                _inner.CopyToAsync(destination, bufferSize, cancellationToken);\n\n            protected override void Dispose(bool disposing)\n            {\n                if (disposing)\n                {\n                    try { _inner.Dispose(); } catch { /* ignore */ }\n                    try { _resp.Dispose(); } catch { /* ignore */ }\n                }\n                base.Dispose(disposing);\n            }\n\n            public override async ValueTask DisposeAsync()\n            {\n                try { await _inner.DisposeAsync().ConfigureAwait(false); } catch { /* ignore */ }\n                try { _resp.Dispose(); } catch { /* ignore */ }\n            }\n        }\n\n        private static string? TryGetMetaMediaUrl(string body)\n        {\n            try\n            {\n                using var doc = JsonDocument.Parse(body);\n                if (doc.RootElement.ValueKind != JsonValueKind.Object) return null;\n                if (doc.RootElement.TryGetProperty(\"url\", out var urlProp) && urlProp.ValueKind == JsonValueKind.String)\n                    return urlProp.GetString();\n            }\n            catch { /* ignore */ }\n\n            return null;\n        }\n\n        private static string? TryGetMetaMediaMimeType(string body)\n        {\n            try\n            {\n                using var doc = JsonDocument.Parse(body);\n                if (doc.RootElement.ValueKind != JsonValueKind.Object) return null;\n                if (doc.RootElement.TryGetProperty(\"mime_type\", out var mimeProp) && mimeProp.ValueKind == JsonValueKind.String)\n                    return mimeProp.GetString();\n            }\n            catch { /* ignore */ }\n\n            return null;\n        }\n\n        private static string? TryGetMetaErrorMessage(string body)\n        {\n            try\n            {\n                using var doc = JsonDocument.Parse(body);\n                if (doc.RootElement.ValueKind != JsonValueKind.Object) return null;\n\n                if (!doc.RootElement.TryGetProperty(\"error\", out var err) || err.ValueKind != JsonValueKind.Object)\n                    return null;\n\n                if (err.TryGetProperty(\"message\", out var msg) && msg.ValueKind == JsonValueKind.String)\n                    return msg.GetString();\n            }\n            catch { /* ignore */ }\n\n            return null;\n        }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/Services/ChatInboxMediaUploadService.cs",
      "sha256": "aa4d8e505de0f720cdc570b34f40e46376b281f3ece5beaf659d87034638ec74",
      "language": "csharp",
      "size": 6105,
      "content": "using System;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.TemplateModule.Abstractions;\n\nnamespace xbytechat.api.Features.ChatInbox.Services\n{\n    /// <summary>\n    /// Uploads Inbox attachments to WhatsApp Cloud API media storage and returns a media_id.\n    /// We intentionally do NOT store files on our server.\n    /// </summary>\n    public sealed class ChatInboxMediaUploadService : IChatInboxMediaUploadService\n    {\n        private const string DefaultGraphVersion = \"v22.0\";\n\n        private readonly IHttpClientFactory _httpFactory;\n        private readonly IMetaCredentialsResolver _metaCreds;\n        private readonly ILogger<ChatInboxMediaUploadService> _logger;\n\n        public ChatInboxMediaUploadService(\n            IHttpClientFactory httpFactory,\n            IMetaCredentialsResolver metaCreds,\n            ILogger<ChatInboxMediaUploadService> logger)\n        {\n            _httpFactory = httpFactory ?? throw new ArgumentNullException(nameof(httpFactory));\n            _metaCreds = metaCreds ?? throw new ArgumentNullException(nameof(metaCreds));\n            _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n        }\n\n        public async Task<string> UploadToWhatsAppAsync(\n            Guid businessId,\n            string? phoneNumberId,\n            IFormFile file,\n            CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty) throw new ArgumentException(\"BusinessId is required.\", nameof(businessId));\n            if (file == null) throw new ArgumentNullException(nameof(file));\n\n            var creds = await _metaCreds.ResolveAsync(businessId, ct).ConfigureAwait(false);\n            var graphBase = (creds.GraphBaseUrl ?? string.Empty).Trim().TrimEnd('/');\n            var graphVersion = string.IsNullOrWhiteSpace(creds.GraphVersion)\n                ? DefaultGraphVersion\n                : creds.GraphVersion!.Trim().Trim('/');\n\n            if (string.IsNullOrWhiteSpace(graphBase))\n                throw new InvalidOperationException(\"WhatsApp Graph API base URL is missing.\");\n\n            var pnid = string.IsNullOrWhiteSpace(phoneNumberId)\n                ? (creds.PhoneNumberId ?? string.Empty).Trim()\n                : phoneNumberId.Trim();\n\n            if (string.IsNullOrWhiteSpace(pnid))\n                throw new InvalidOperationException(\"WhatsApp phone_number_id is missing for this business.\");\n\n            var url = $\"{graphBase}/{graphVersion}/{pnid}/media\";\n\n            using var fileStream = file.OpenReadStream();\n            using var mp = new MultipartFormDataContent();\n\n            mp.Add(new StringContent(\"whatsapp\"), \"messaging_product\");\n            mp.Add(new StringContent(file.ContentType ?? \"application/octet-stream\"), \"type\");\n\n            var fileContent = new StreamContent(fileStream);\n            fileContent.Headers.ContentType = new MediaTypeHeaderValue(file.ContentType ?? \"application/octet-stream\");\n            mp.Add(fileContent, \"file\", file.FileName ?? \"upload.bin\");\n\n            using var req = new HttpRequestMessage(HttpMethod.Post, url) { Content = mp };\n            req.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(\"application/json\"));\n\n            var token = (creds.AccessToken ?? string.Empty).Trim();\n            if (string.IsNullOrWhiteSpace(token))\n                throw new InvalidOperationException(\"WhatsApp access token is missing for this business.\");\n\n            req.Headers.Authorization = new AuthenticationHeaderValue(\"Bearer\", token);\n\n            using var client = _httpFactory.CreateClient(\"wa:meta_cloud\");\n            using var resp = await client.SendAsync(req, HttpCompletionOption.ResponseHeadersRead, ct).ConfigureAwait(false);\n            var body = await resp.Content.ReadAsStringAsync(ct).ConfigureAwait(false);\n\n            if (!resp.IsSuccessStatusCode)\n            {\n                var clean = TryGetMetaErrorMessage(body) ?? \"WhatsApp media upload failed.\";\n                _logger.LogWarning(\n                    \"ChatInbox media upload failed. BusinessId={BusinessId} PhoneNumberId={PhoneNumberId} Status={Status} MetaError={MetaError}\",\n                    businessId,\n                    pnid,\n                    (int)resp.StatusCode,\n                    clean);\n                throw new InvalidOperationException(clean);\n            }\n\n            var mediaId = TryGetMediaId(body);\n            if (string.IsNullOrWhiteSpace(mediaId))\n            {\n                _logger.LogWarning(\n                    \"ChatInbox media upload succeeded but media id missing. BusinessId={BusinessId} PhoneNumberId={PhoneNumberId}\",\n                    businessId,\n                    pnid);\n                throw new InvalidOperationException(\"WhatsApp media upload succeeded but no media id was returned.\");\n            }\n\n            return mediaId;\n        }\n\n        private static string? TryGetMediaId(string body)\n        {\n            try\n            {\n                using var doc = JsonDocument.Parse(body);\n                if (doc.RootElement.ValueKind != JsonValueKind.Object) return null;\n                if (doc.RootElement.TryGetProperty(\"id\", out var idProp))\n                    return idProp.GetString();\n            }\n            catch { /* ignore */ }\n\n            return null;\n        }\n\n        private static string? TryGetMetaErrorMessage(string body)\n        {\n            try\n            {\n                using var doc = JsonDocument.Parse(body);\n                if (doc.RootElement.ValueKind != JsonValueKind.Object) return null;\n\n                if (!doc.RootElement.TryGetProperty(\"error\", out var err) || err.ValueKind != JsonValueKind.Object)\n                    return null;\n\n                if (err.TryGetProperty(\"message\", out var msg) && msg.ValueKind == JsonValueKind.String)\n                    return msg.GetString();\n            }\n            catch { /* ignore */ }\n\n            return null;\n        }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/Services/ChatInboxQueryService.cs",
      "sha256": "0b1498c852e77a9d8bb016781d9214116dcf87135c3d97d829c5b0b7a0bdb41c",
      "language": "csharp",
      "size": 31345,
      "content": "// ðŸ“„ xbytechat-api/Features/ChatInbox/Services/ChatInboxQueryService.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.ChatInbox.DTOs;\nusing xbytechat.api.Features.ChatInbox.Models;\nusing xbytechat.api.Features.ChatInbox.Utils;\nusing xbytechat.api.Models;\n\nnamespace xbytechat.api.Features.ChatInbox.Services\n{\n    public sealed class ChatInboxQueryService : IChatInboxQueryService\n    {\n        private const string InboxAssignPermissionCode = \"INBOX.CHAT.ASSIGN\";\n\n        private readonly AppDbContext _db;\n\n        private sealed class ConversationsCursor\n        {\n            public DateTime LastMessageAtUtc { get; set; }\n            public Guid ContactId { get; set; }\n        }\n\n        private sealed class MessagesCursor\n        {\n            public DateTime InstantUtc { get; set; }\n            public Guid MessageId { get; set; }\n        }\n\n        public ChatInboxQueryService(AppDbContext db)\n        {\n            _db = db ?? throw new ArgumentNullException(nameof(db));\n        }\n\n        // âœ… Backward compatible (old behavior)\n        public async Task<IReadOnlyList<ChatInboxConversationDto>> GetConversationsAsync(\n            ChatInboxFilterDto filter,\n            CancellationToken ct = default)\n        {\n            var page = await GetConversationsPageAsync(filter, ct).ConfigureAwait(false);\n            return page.Items;\n        }\n\n        // âœ… New: cursor page\n        public async Task<PagedResultDto<ChatInboxConversationDto>> GetConversationsPageAsync(\n            ChatInboxFilterDto filter,\n            CancellationToken ct = default)\n        {\n            if (filter == null) throw new ArgumentNullException(nameof(filter));\n            if (filter.BusinessId == Guid.Empty)\n                throw new ArgumentException(\"BusinessId is required.\", nameof(filter));\n\n            var limit = filter.Limit <= 0 ? 50 : filter.Limit;\n            if (limit > 200) limit = 200;\n\n            var businessId = filter.BusinessId;\n            var currentUserId = filter.CurrentUserId;\n\n            var cursorObj = CursorCodec.Decode<ConversationsCursor>(filter.Cursor);\n            var within24hCutoffUtc = DateTime.UtcNow.AddHours(-24);\n\n            var convoAgg =\n                from m in _db.MessageLogs.AsNoTracking()\n                where m.BusinessId == businessId && m.ContactId != null\n                group m by m.ContactId!.Value\n                into g\n                select new\n                {\n                    ContactId = g.Key,\n                    LastMessageAt = g.Max(x => x.SentAt ?? x.CreatedAt),\n                    FirstSeenAt = g.Min(x => x.SentAt ?? x.CreatedAt),\n                    TotalMessages = g.Count(),\n                    LastInboundAt = g.Where(x => x.IsIncoming)\n                        .Max(x => (DateTime?)(x.SentAt ?? x.CreatedAt)),\n                    LastOutboundAt = g.Where(x => !x.IsIncoming)\n                        .Max(x => (DateTime?)(x.SentAt ?? x.CreatedAt))\n                };\n\n            var q =\n                from a in convoAgg\n                join c in _db.Contacts.AsNoTracking()\n                    on a.ContactId equals c.Id\n                where c.BusinessId == businessId\n                select new\n                {\n                    a.ContactId,\n                    a.LastMessageAt,\n                    a.FirstSeenAt,\n                    a.TotalMessages,\n                    a.LastInboundAt,\n                    a.LastOutboundAt,\n                    Contact = c\n                };\n\n            // âœ… Visibility mode (Shared vs Restricted)\n            var visibility = await _db.Businesses\n                .AsNoTracking()\n                .Where(b => b.Id == businessId)\n                .Select(b => (InboxVisibilityMode?)b.InboxVisibilityMode)\n                .FirstOrDefaultAsync(ct)\n                .ConfigureAwait(false) ?? InboxVisibilityMode.SharedInInbox;\n\n            // âœ… Restricted mode: non-privileged agents only see chats assigned to them\n            if (visibility == InboxVisibilityMode.AssignedOnly)\n            {\n                if (!currentUserId.HasValue || currentUserId.Value == Guid.Empty)\n                {\n                    return new PagedResultDto<ChatInboxConversationDto>\n                    {\n                        Items = Array.Empty<ChatInboxConversationDto>(),\n                        HasMore = false,\n                        NextCursor = null\n                    };\n                }\n\n                var canSeeAll = await CanSeeAllInRestrictedModeAsync(businessId, currentUserId.Value, ct)\n                    .ConfigureAwait(false);\n\n                if (!canSeeAll)\n                {\n                    q = q.Where(x => x.Contact.AssignedAgentId == currentUserId.Value);\n                }\n            }\n\n            if (filter.OnlyUnassigned)\n                q = q.Where(x => x.Contact.AssignedAgentId == null);\n\n            if (filter.OnlyAssignedToMe && currentUserId.HasValue)\n                q = q.Where(x => x.Contact.AssignedAgentId == currentUserId.Value);\n\n            if (filter.ContactId.HasValue && filter.ContactId.Value != Guid.Empty)\n                q = q.Where(x => x.ContactId == filter.ContactId.Value);\n\n            var tab = (filter.Tab ?? string.Empty).Trim().ToLowerInvariant();\n            if (!string.IsNullOrWhiteSpace(tab))\n            {\n                if (tab == \"closed\")\n                {\n                    q = q.Where(x => x.Contact.InboxStatus == \"Closed\" || x.Contact.IsArchived || !x.Contact.IsActive);\n                }\n                else\n                {\n                    q = q.Where(x => x.Contact.InboxStatus != \"Closed\" && !x.Contact.IsArchived && x.Contact.IsActive);\n\n                    if (tab == \"live\")\n                    {\n                        q = q.Where(x => x.LastInboundAt.HasValue && x.LastInboundAt.Value >= within24hCutoffUtc);\n                    }\n                    else if (tab is \"older\" or \"history\")\n                    {\n                        q = q.Where(x => !x.LastInboundAt.HasValue || x.LastInboundAt.Value < within24hCutoffUtc);\n                    }\n                    else if (tab == \"unassigned\")\n                    {\n                        q = q.Where(x => x.Contact.AssignedAgentId == null);\n                    }\n                    else if (tab == \"my\")\n                    {\n                        if (currentUserId.HasValue)\n                            q = q.Where(x => x.Contact.AssignedAgentId == currentUserId.Value);\n                        else\n                            q = q.Where(x => false);\n                    }\n                }\n            }\n\n            if (!string.IsNullOrWhiteSpace(filter.SearchTerm))\n            {\n                var raw = filter.SearchTerm.Trim();\n                var term = raw.ToLowerInvariant();\n\n                q = q.Where(x =>\n                    (!string.IsNullOrEmpty(x.Contact.Name) && x.Contact.Name.ToLower().Contains(term)) ||\n                    (!string.IsNullOrEmpty(x.Contact.ProfileName) && x.Contact.ProfileName.ToLower().Contains(term)) ||\n                    (!string.IsNullOrEmpty(x.Contact.PhoneNumber) && x.Contact.PhoneNumber.Contains(raw)));\n            }\n\n            if (cursorObj != null && cursorObj.ContactId != Guid.Empty)\n            {\n                var lm = DateTime.SpecifyKind(cursorObj.LastMessageAtUtc, DateTimeKind.Utc);\n                var cid = cursorObj.ContactId;\n\n                q = q.Where(x =>\n                    x.LastMessageAt < lm ||\n                    (x.LastMessageAt == lm && x.ContactId.CompareTo(cid) < 0));\n            }\n\n            q = q.OrderByDescending(x => x.LastMessageAt)\n                 .ThenByDescending(x => x.ContactId);\n\n            var rows = await q.Take(limit + 1).ToListAsync(ct).ConfigureAwait(false);\n\n            var hasMore = rows.Count > limit;\n            var pageRows = rows.Take(limit).ToList();\n\n            if (pageRows.Count == 0)\n            {\n                return new PagedResultDto<ChatInboxConversationDto>\n                {\n                    Items = Array.Empty<ChatInboxConversationDto>(),\n                    HasMore = false,\n                    NextCursor = null\n                };\n            }\n\n            var contactIds = pageRows.Select(x => x.ContactId).ToList();\n\n            var lastMessages = await _db.MessageLogs\n                .AsNoTracking()\n                .Where(m => m.BusinessId == businessId\n                            && m.ContactId != null\n                            && contactIds.Contains(m.ContactId.Value))\n                .GroupBy(m => m.ContactId!.Value)\n                .Select(g => g\n                    .OrderByDescending(m => m.SentAt ?? m.CreatedAt)\n                    .ThenByDescending(m => m.Id)\n                    .FirstOrDefault())\n                .ToListAsync(ct)\n                .ConfigureAwait(false);\n\n            var lastMessageByContactId = lastMessages\n                .Where(m => m != null && m.ContactId != null)\n                .ToDictionary(m => m!.ContactId!.Value, m => m!);\n\n            var assignedUserIds = pageRows\n                .Select(x => x.Contact.AssignedAgentId)\n                .Where(x => x.HasValue)\n                .Select(x => x!.Value)\n                .Distinct()\n                .ToList();\n\n            var assignedUsersById = new Dictionary<Guid, string>();\n            if (assignedUserIds.Count > 0)\n            {\n                var users = await _db.Users\n                    .AsNoTracking()\n                    .Where(u => assignedUserIds.Contains(u.Id))\n                    .Select(u => new { u.Id, Name = (u.Name ?? u.Email) })\n                    .ToListAsync(ct)\n                    .ConfigureAwait(false);\n\n                assignedUsersById = users.ToDictionary(x => x.Id, x => x.Name ?? \"Unknown\");\n            }\n\n            var unreadCounts = new Dictionary<Guid, int>();\n            if (currentUserId.HasValue)\n            {\n                var uid = currentUserId.Value;\n\n                var readsQuery = _db.ContactReads\n                    .AsNoTracking()\n                    .Where(r => r.BusinessId == businessId && r.UserId == uid);\n\n                var unreadRows = await _db.MessageLogs\n                    .AsNoTracking()\n                    .Where(m => m.BusinessId == businessId\n                                && m.ContactId != null\n                                && contactIds.Contains(m.ContactId.Value)\n                                && m.IsIncoming)\n                    .GroupJoin(\n                        readsQuery,\n                        m => m.ContactId!.Value,\n                        r => r.ContactId,\n                        (m, reads) => new\n                        {\n                            ContactId = m.ContactId!.Value,\n                            Instant = (m.SentAt ?? m.CreatedAt),\n                            LastReadAt = reads.Select(x => (DateTime?)x.LastReadAt).FirstOrDefault()\n                        })\n                    .Where(x => !x.LastReadAt.HasValue || x.Instant > x.LastReadAt.Value)\n                    .GroupBy(x => x.ContactId)\n                    .Select(g => new { ContactId = g.Key, Count = g.Count() })\n                    .ToListAsync(ct)\n                    .ConfigureAwait(false);\n\n                unreadCounts = unreadRows.ToDictionary(x => x.ContactId, x => x.Count);\n            }\n\n            var sessionStates = await _db.ChatSessionStates\n                .AsNoTracking()\n                .Where(s => s.BusinessId == businessId && contactIds.Contains(s.ContactId))\n                .ToListAsync(ct)\n                .ConfigureAwait(false);\n\n            var sessionByContactId = sessionStates.ToDictionary(s => s.ContactId, s => s);\n\n            var items = new List<ChatInboxConversationDto>(pageRows.Count);\n\n            foreach (var row in pageRows)\n            {\n                var contact = row.Contact;\n\n                lastMessageByContactId.TryGetValue(row.ContactId, out var lastMsg);\n\n                var preview = lastMsg?.RenderedBody ?? lastMsg?.MessageContent ?? string.Empty;\n                if (string.IsNullOrWhiteSpace(preview) && lastMsg != null && !string.IsNullOrWhiteSpace(lastMsg.MediaType))\n                {\n                    var mt = lastMsg.MediaType.Trim().ToLowerInvariant();\n                    var name = lastMsg.FileName ?? string.Empty;\n\n                    if (mt == \"image\")\n                        preview = \"Photo\";\n                    else if (mt == \"document\")\n                        preview = string.IsNullOrWhiteSpace(name) ? \"PDF\" : name;\n                    else if (mt == \"video\")\n                        preview = string.IsNullOrWhiteSpace(name) ? \"Video\" : name;\n                    else if (mt == \"audio\")\n                        preview = string.IsNullOrWhiteSpace(name) ? \"Audio\" : name;\n                    else if (mt == \"location\")\n                        preview = string.IsNullOrWhiteSpace(lastMsg.LocationName) ? \"Location\" : lastMsg.LocationName!;\n                }\n                if (preview.Length > 140) preview = preview.Substring(0, 140) + \"â€¦\";\n\n                var unread = unreadCounts.TryGetValue(row.ContactId, out var uc) ? uc : 0;\n\n                var lastInboundAt = row.LastInboundAt ?? contact.LastInboundAt;\n                var lastOutboundAt = row.LastOutboundAt ?? contact.LastOutboundAt;\n\n                var within24h =\n                    lastInboundAt.HasValue && lastInboundAt.Value >= within24hCutoffUtc;\n\n                var statusRaw = (contact.InboxStatus ?? string.Empty).Trim();\n                var statusLower = statusRaw.ToLowerInvariant();\n                var status =\n                    statusLower switch\n                    {\n                        \"open\" => \"Open\",\n                        \"pending\" => \"Pending\",\n                        \"closed\" => \"Closed\",\n                        _ => (contact.IsArchived || !contact.IsActive) ? \"Closed\" : \"Open\"\n                    };\n\n                var assignedUserId = contact.AssignedAgentId;\n                var assignedUserIdString = assignedUserId?.ToString();\n\n                var isAssignedToMe =\n                    currentUserId.HasValue &&\n                    assignedUserId.HasValue &&\n                    assignedUserId.Value == currentUserId.Value;\n\n                string? assignedUserName = null;\n                if (assignedUserId.HasValue && assignedUsersById.TryGetValue(assignedUserId.Value, out var nm))\n                    assignedUserName = nm;\n\n                var mode = \"automation\";\n                if (sessionByContactId.TryGetValue(row.ContactId, out var session))\n                {\n                    mode = session.Mode?.ToString().ToLowerInvariant() ?? \"automation\";\n                }\n                else if (lastMsg != null)\n                {\n                    if (!lastMsg.IsIncoming &&\n                        string.Equals(lastMsg.Source, \"agent\", StringComparison.OrdinalIgnoreCase))\n                    {\n                        mode = \"agent\";\n                    }\n                }\n\n                items.Add(new ChatInboxConversationDto\n                {\n                    Id = row.ContactId.ToString(),\n                    ContactId = row.ContactId,\n                    ContactName = string.IsNullOrWhiteSpace(contact.Name)\n                        ? (contact.ProfileName ?? contact.PhoneNumber)\n                        : contact.Name,\n                    ContactPhone = contact.PhoneNumber,\n\n                    LastMessagePreview = preview,\n                    LastMessageAt = row.LastMessageAt,\n\n                    UnreadCount = unread,\n                    Status = status,\n\n                    NumberId = string.Empty,\n                    NumberLabel = string.Empty,\n\n                    Within24h = within24h,\n\n                    AssignedToUserId = assignedUserIdString,\n                    AssignedToUserName = assignedUserName,\n                    IsAssignedToMe = isAssignedToMe,\n\n                    Mode = mode,\n                    SourceType = \"Unknown\",\n                    SourceName = null,\n\n                    FirstSeenAt = row.FirstSeenAt,\n                    LastInboundAt = lastInboundAt,\n                    LastOutboundAt = lastOutboundAt,\n                    TotalMessages = row.TotalMessages,\n\n                    LastAgentReplyAt = null,\n                    LastAutomationAt = null\n                });\n            }\n\n            items.Sort((a, b) =>\n            {\n                var aUnread = a.UnreadCount > 0;\n                var bUnread = b.UnreadCount > 0;\n\n                if (aUnread && !bUnread) return -1;\n                if (!aUnread && bUnread) return 1;\n\n                return b.LastMessageAt.CompareTo(a.LastMessageAt);\n            });\n\n            string? nextCursor = null;\n            if (hasMore && items.Count > 0)\n            {\n                var last = pageRows.Last();\n                nextCursor = CursorCodec.Encode(new ConversationsCursor\n                {\n                    LastMessageAtUtc = DateTime.SpecifyKind(last.LastMessageAt, DateTimeKind.Utc),\n                    ContactId = last.ContactId\n                });\n            }\n\n            return new PagedResultDto<ChatInboxConversationDto>\n            {\n                Items = items,\n                HasMore = hasMore,\n                NextCursor = nextCursor\n            };\n        }\n\n        // =============================================================\n        // âœ… SECURED MESSAGE METHODS (use these from controllers)\n        // =============================================================\n\n        public async Task<IReadOnlyList<ChatInboxMessageDto>> GetMessagesForConversationAsync(\n            Guid businessId,\n            string contactPhone,\n            int limit,\n            Guid currentUserId,\n            CancellationToken ct = default)\n        {\n            var page = await GetMessagesPageForConversationByPhoneAsync(businessId, contactPhone, limit, null, currentUserId, ct)\n                .ConfigureAwait(false);\n\n            return page.Items;\n        }\n\n        public async Task<IReadOnlyList<ChatInboxMessageDto>> GetMessagesForConversationByContactIdAsync(\n            Guid businessId,\n            Guid contactId,\n            int limit,\n            Guid currentUserId,\n            CancellationToken ct = default)\n        {\n            var page = await GetMessagesPageForConversationByContactIdAsync(businessId, contactId, limit, null, currentUserId, ct)\n                .ConfigureAwait(false);\n\n            return page.Items;\n        }\n\n        public Task<PagedResultDto<ChatInboxMessageDto>> GetMessagesPageForConversationByPhoneAsync(\n            Guid businessId,\n            string contactPhone,\n            int limit,\n            string? cursor,\n            Guid currentUserId,\n            CancellationToken ct = default)\n        {\n            // Resolve contactId then delegate\n            return GetMessagesPageForConversationByPhoneInternalAsync(businessId, contactPhone, limit, cursor, currentUserId, ct);\n        }\n\n        public Task<PagedResultDto<ChatInboxMessageDto>> GetMessagesPageForConversationByContactIdAsync(\n            Guid businessId,\n            Guid contactId,\n            int limit,\n            string? cursor,\n            Guid currentUserId,\n            CancellationToken ct = default)\n        {\n            return GetMessagesPageForConversationByContactIdInternalAsync(businessId, contactId, limit, cursor, currentUserId, ct);\n        }\n\n        // =============================================================\n        // âš ï¸ LEGACY MESSAGE METHODS (keep for compatibility only)\n        // These DO NOT enforce restricted mode. Prefer secured overloads.\n        // =============================================================\n\n        public async Task<IReadOnlyList<ChatInboxMessageDto>> GetMessagesForConversationAsync(\n            Guid businessId,\n            string contactPhone,\n            int limit,\n            CancellationToken ct = default)\n        {\n            var page = await GetMessagesPageForConversationByPhoneAsync(businessId, contactPhone, limit, null, ct)\n                .ConfigureAwait(false);\n\n            return page.Items;\n        }\n\n        public async Task<IReadOnlyList<ChatInboxMessageDto>> GetMessagesForConversationByContactIdAsync(\n            Guid businessId,\n            Guid contactId,\n            int limit,\n            CancellationToken ct = default)\n        {\n            var page = await GetMessagesPageForConversationByContactIdAsync(businessId, contactId, limit, null, ct)\n                .ConfigureAwait(false);\n\n            return page.Items;\n        }\n\n        public Task<PagedResultDto<ChatInboxMessageDto>> GetMessagesPageForConversationByPhoneAsync(\n            Guid businessId,\n            string contactPhone,\n            int limit,\n            string? cursor,\n            CancellationToken ct = default)\n        {\n            // Legacy behavior: no visibility enforcement (Shared-like)\n            return GetMessagesPageForConversationByPhoneInternalAsync(businessId, contactPhone, limit, cursor, null, ct);\n        }\n\n        public Task<PagedResultDto<ChatInboxMessageDto>> GetMessagesPageForConversationByContactIdAsync(\n            Guid businessId,\n            Guid contactId,\n            int limit,\n            string? cursor,\n            CancellationToken ct = default)\n        {\n            // Legacy behavior: no visibility enforcement (Shared-like)\n            return GetMessagesPageForConversationByContactIdInternalAsync(businessId, contactId, limit, cursor, null, ct);\n        }\n\n        // =============================================================\n        // Internal implementations with optional enforcement\n        // =============================================================\n\n        private async Task<PagedResultDto<ChatInboxMessageDto>> GetMessagesPageForConversationByPhoneInternalAsync(\n            Guid businessId,\n            string contactPhone,\n            int limit,\n            string? cursor,\n            Guid? currentUserId,\n            CancellationToken ct)\n        {\n            if (businessId == Guid.Empty)\n                throw new ArgumentException(\"BusinessId must be a non-empty GUID.\", nameof(businessId));\n\n            if (string.IsNullOrWhiteSpace(contactPhone))\n                throw new ArgumentException(\"Contact phone is required.\", nameof(contactPhone));\n\n            var trimmedPhone = contactPhone.Trim();\n\n            var contactId = await _db.Contacts\n                .AsNoTracking()\n                .Where(c => c.BusinessId == businessId && c.PhoneNumber == trimmedPhone)\n                .Select(c => (Guid?)c.Id)\n                .FirstOrDefaultAsync(ct)\n                .ConfigureAwait(false);\n\n            if (!contactId.HasValue)\n            {\n                return new PagedResultDto<ChatInboxMessageDto>\n                {\n                    Items = Array.Empty<ChatInboxMessageDto>(),\n                    HasMore = false,\n                    NextCursor = null\n                };\n            }\n\n            return await GetMessagesPageForConversationByContactIdInternalAsync(\n                    businessId, contactId.Value, limit, cursor, currentUserId, ct)\n                .ConfigureAwait(false);\n        }\n\n        private async Task<PagedResultDto<ChatInboxMessageDto>> GetMessagesPageForConversationByContactIdInternalAsync(\n            Guid businessId,\n            Guid contactId,\n            int limit,\n            string? cursor,\n            Guid? currentUserId,\n            CancellationToken ct)\n        {\n            if (businessId == Guid.Empty)\n                throw new ArgumentException(\"BusinessId must be a non-empty GUID.\", nameof(businessId));\n\n            if (contactId == Guid.Empty)\n                throw new ArgumentException(\"ContactId must be a non-empty GUID.\", nameof(contactId));\n\n            if (limit <= 0) limit = 50;\n            if (limit > 200) limit = 200;\n\n            // âœ… Visibility enforcement for messages in Restricted mode\n            await EnsureCanViewConversationAsync(businessId, contactId, currentUserId, ct)\n                .ConfigureAwait(false);\n\n            var cursorObj = CursorCodec.Decode<MessagesCursor>(cursor);\n\n            var q = _db.MessageLogs\n                .AsNoTracking()\n                .Where(x => x.BusinessId == businessId && x.ContactId == contactId);\n\n            if (cursorObj != null && cursorObj.MessageId != Guid.Empty)\n            {\n                var inst = DateTime.SpecifyKind(cursorObj.InstantUtc, DateTimeKind.Utc);\n                var mid = cursorObj.MessageId;\n\n                q = q.Where(x =>\n                    (x.SentAt ?? x.CreatedAt) < inst ||\n                    ((x.SentAt ?? x.CreatedAt) == inst && x.Id.CompareTo(mid) < 0));\n            }\n\n            var rows = await q\n                .OrderByDescending(x => x.SentAt ?? x.CreatedAt)\n                .ThenByDescending(x => x.Id)\n                .Take(limit + 1)\n                .ToListAsync(ct)\n                .ConfigureAwait(false);\n\n            var hasMore = rows.Count > limit;\n            var pageRows = rows.Take(limit).ToList();\n\n            var items = pageRows.Select(x =>\n            {\n                var instant = x.SentAt ?? x.CreatedAt;\n                var utcInstant = instant.Kind == DateTimeKind.Utc ? instant : instant.ToUniversalTime();\n\n                return new ChatInboxMessageDto\n                {\n                    Id = x.Id,\n                    Direction = x.IsIncoming ? \"in\" : \"out\",\n                    Channel = \"whatsapp\",\n                    Text = x.RenderedBody ?? x.MessageContent ?? string.Empty,\n                    MediaId = x.MediaId,\n                    MediaType = x.MediaType,\n                    FileName = x.FileName,\n                    MimeType = x.MimeType,\n                    LocationLatitude = x.LocationLatitude,\n                    LocationLongitude = x.LocationLongitude,\n                    LocationName = x.LocationName,\n                    LocationAddress = x.LocationAddress,\n                    SentAtUtc = utcInstant,\n                    Status = x.Status,\n                    ErrorMessage = x.ErrorMessage\n                };\n            }).ToList();\n\n            string? nextCursor = null;\n            if (hasMore && pageRows.Count > 0)\n            {\n                var last = pageRows.Last();\n                var instant = last.SentAt ?? last.CreatedAt;\n                var utcInstant = instant.Kind == DateTimeKind.Utc ? instant : instant.ToUniversalTime();\n\n                nextCursor = CursorCodec.Encode(new MessagesCursor\n                {\n                    InstantUtc = utcInstant,\n                    MessageId = last.Id\n                });\n            }\n\n            return new PagedResultDto<ChatInboxMessageDto>\n            {\n                Items = items,\n                HasMore = hasMore,\n                NextCursor = nextCursor\n            };\n        }\n\n        private async Task EnsureCanViewConversationAsync(\n            Guid businessId,\n            Guid contactId,\n            Guid? currentUserId,\n            CancellationToken ct)\n        {\n            // Shared mode => everyone in business can view.\n            var visibility = await _db.Businesses\n                .AsNoTracking()\n                .Where(b => b.Id == businessId)\n                .Select(b => (InboxVisibilityMode?)b.InboxVisibilityMode)\n                .FirstOrDefaultAsync(ct)\n                .ConfigureAwait(false) ?? InboxVisibilityMode.SharedInInbox;\n\n            if (visibility != InboxVisibilityMode.AssignedOnly)\n                return;\n\n            if (!currentUserId.HasValue || currentUserId.Value == Guid.Empty)\n                throw new UnauthorizedAccessException(\"Restricted inbox: user context required.\");\n\n            var canSeeAll = await CanSeeAllInRestrictedModeAsync(businessId, currentUserId.Value, ct)\n                .ConfigureAwait(false);\n\n            if (canSeeAll)\n                return;\n\n            // âœ… Must be assigned to this user\n            var allowed = await _db.Contacts\n                .AsNoTracking()\n                .AnyAsync(c =>\n                    c.BusinessId == businessId &&\n                    c.Id == contactId &&\n                    c.AssignedAgentId == currentUserId.Value, ct)\n                .ConfigureAwait(false);\n\n            if (!allowed)\n                throw new UnauthorizedAccessException(\"Restricted inbox: you are not assigned to this conversation.\");\n        }\n\n        // ===========================\n        // Restricted-mode helpers\n        // ===========================\n\n        private static bool IsPrivilegedRoleName(string? roleName)\n        {\n            var role = (roleName ?? string.Empty).Trim().ToLowerInvariant();\n            return role is \"admin\" or \"business\" or \"superadmin\" or \"partner\";\n        }\n\n        private async Task<bool> CanSeeAllInRestrictedModeAsync(Guid businessId, Guid userId, CancellationToken ct)\n        {\n            var userRow = await _db.Users\n                .AsNoTracking()\n                .Where(u => u.Id == userId && u.BusinessId == businessId && !u.IsDeleted && u.Status == \"Active\")\n                .Select(u => new\n                {\n                    u.RoleId,\n                    RoleName = u.Role != null ? u.Role.Name : null\n                })\n                .FirstOrDefaultAsync(ct)\n                .ConfigureAwait(false);\n\n            if (userRow == null) return false;\n\n            if (IsPrivilegedRoleName(userRow.RoleName))\n                return true;\n\n            return await HasPermissionAsync(userId, InboxAssignPermissionCode, ct).ConfigureAwait(false);\n        }\n\n        private async Task<bool> HasPermissionAsync(Guid userId, string permissionCode, CancellationToken ct)\n        {\n            var code = (permissionCode ?? string.Empty).Trim().ToUpperInvariant();\n            if (code.Length == 0) return false;\n\n            var permissionId = await _db.Permissions\n                .AsNoTracking()\n                .Where(p => p.Code != null && p.Code.ToUpper() == code)\n                .Select(p => (Guid?)p.Id)\n                .FirstOrDefaultAsync(ct)\n                .ConfigureAwait(false);\n\n            if (!permissionId.HasValue) return false;\n\n            var direct = await _db.UserPermissions\n                .AsNoTracking()\n                .AnyAsync(up =>\n                    up.UserId == userId &&\n                    up.PermissionId == permissionId.Value &&\n                    up.IsGranted &&\n                    !up.IsRevoked, ct)\n                .ConfigureAwait(false);\n\n            if (direct) return true;\n\n            var roleId = await _db.Users\n                .AsNoTracking()\n                .Where(u => u.Id == userId)\n                .Select(u => u.RoleId)\n                .FirstOrDefaultAsync(ct)\n                .ConfigureAwait(false);\n\n            if (!roleId.HasValue) return false;\n\n            return await _db.RolePermissions\n                .AsNoTracking()\n                .AnyAsync(rp =>\n                    rp.RoleId == roleId.Value &&\n                    rp.PermissionId == permissionId.Value &&\n                    rp.IsActive &&\n                    !rp.IsRevoked, ct)\n                .ConfigureAwait(false);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/Services/IChatInboxAssignmentService.cs",
      "sha256": "6cd1d4ad791003816b2b886b52e41f5d4a892acb79ae0d5e6e06dd2674282c4e",
      "language": "csharp",
      "size": 721,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.ChatInbox.DTOs;\n\nnamespace xbytechat.api.Features.ChatInbox.Services\n{\n    public interface IChatInboxAssignmentService\n    {\n        Task<List<AgentDto>> GetAgentsAsync(Guid businessId, CancellationToken ct = default);\n\n        Task AssignAsync(Guid businessId, Guid contactId, Guid userId, Guid actorUserId, CancellationToken ct = default);\n        Task UnassignAsync(Guid businessId, Guid contactId, Guid actorUserId, CancellationToken ct = default);\n        Task SetStatusAsync(Guid businessId, Guid contactId, string status, Guid actorUserId, CancellationToken ct = default);\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/Services/IChatInboxCommandService.cs",
      "sha256": "fe1087d7e7140bbd2b8f4a8778c0ab0e53f70289ea02fb189749bc338476a848",
      "language": "csharp",
      "size": 2332,
      "content": "// ðŸ“„ xbytechat-api/Features/ChatInbox/Services/IChatInboxCommandService.cs\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.ChatInbox.DTOs;\n\nnamespace xbytechat.api.Features.ChatInbox.Services\n{\n    public interface IChatInboxCommandService\n    {\n        /// <summary>\n        /// Sends an agent-authored text message to a contact from the Chat Inbox\n        /// and returns the resulting message DTO for the UI bubble.\n        /// </summary>\n        Task<ChatInboxMessageDto> SendAgentMessageAsync(\n            ChatInboxSendMessageRequestDto request,\n            CancellationToken ct = default);\n\n        /// <summary>\n        /// Updates per-user read state (ContactReads) for a conversation.\n        /// </summary>\n        //Task MarkConversationAsReadAsync(\n        //    ChatInboxMarkReadRequestDto request,\n        //    CancellationToken ct = default);\n\n        Task MarkConversationAsReadAsync(\n           Guid businessId,\n           Guid contactId,\n           Guid userId,\n           DateTime? lastReadAtUtc,\n           CancellationToken ct = default);\n    }\n}\n\n\n//using xbytechat.api.Features.ChatInbox.DTOs;\n\n//namespace xbytechat.api.Features.ChatInbox.Services\n//{\n//    public interface IChatInboxCommandService\n//    {\n//        /// <summary>\n//        /// Sends an agent-authored text message to a contact from the Chat Inbox\n//        /// and returns the resulting message DTO for the UI bubble.\n//        /// </summary>\n//        Task<ChatInboxMessageDto> SendAgentMessageAsync(\n//            ChatInboxSendMessageRequestDto request,\n//            CancellationToken ct = default);\n//        Task MarkConversationAsReadAsync(\n//            ChatInboxMarkReadRequestDto request,\n//            CancellationToken ct = default);\n\n//        Task AssignConversationAsync(\n//           ChatInboxAssignRequestDto request,\n//           CancellationToken ct = default);\n\n//        /// <summary>\n//        /// Unassigns a conversation (sets AssignedAgentId to null).\n//        /// </summary>\n//        Task UnassignConversationAsync(\n//            ChatInboxUnassignRequestDto request,\n//            CancellationToken ct = default);\n\n//        Task ChangeConversationStatusAsync(\n//           ChatInboxChangeStatusRequestDto request,\n//           CancellationToken ct = default);\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/Services/IChatInboxMediaContentService.cs",
      "sha256": "6c4f907fe73fbfe8ae410bb04d5f4d22d1e182dc2e9f6c01e110e4212b945f9e",
      "language": "csharp",
      "size": 385,
      "content": "using System;\nusing System.IO;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.ChatInbox.Services\n{\n    public interface IChatInboxMediaContentService\n    {\n        Task<(Stream Stream, string ContentType)> DownloadFromWhatsAppAsync(\n            Guid businessId,\n            string mediaId,\n            CancellationToken ct = default);\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/Services/IChatInboxMediaUploadService.cs",
      "sha256": "cefe534d5e5f40e1b10cd805528e4d3fe5a24a071cac7764d47e3bfb9adc6872",
      "language": "csharp",
      "size": 402,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Http;\n\nnamespace xbytechat.api.Features.ChatInbox.Services\n{\n    public interface IChatInboxMediaUploadService\n    {\n        Task<string> UploadToWhatsAppAsync(\n            Guid businessId,\n            string? phoneNumberId,\n            IFormFile file,\n            CancellationToken ct = default);\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/Services/IChatInboxQueryService.cs",
      "sha256": "963dc750087f4539b0bfeafa54493cc630b55987bf2cdd43a94f50885653de22",
      "language": "csharp",
      "size": 3320,
      "content": "// ðŸ“„ xbytechat-api/Features/ChatInbox/Services/IChatInboxQueryService.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.ChatInbox.DTOs;\n\nnamespace xbytechat.api.Features.ChatInbox.Services\n{\n    public interface IChatInboxQueryService\n    {\n        // =========================\n        // Conversations\n        // =========================\n\n        // âœ… Existing (non-paged)\n        Task<IReadOnlyList<ChatInboxConversationDto>> GetConversationsAsync(\n            ChatInboxFilterDto filter,\n            CancellationToken ct = default);\n\n        // âœ… Cursor paging (used by controller when paged=true)\n        Task<PagedResultDto<ChatInboxConversationDto>> GetConversationsPageAsync(\n            ChatInboxFilterDto filter,\n            CancellationToken ct = default);\n\n        // =========================\n        // Messages (LEGACY)\n        // NOTE: These are backward compatible and DO NOT enforce restricted-mode visibility.\n        // Prefer the secured overloads below in controllers.\n        // =========================\n\n        Task<IReadOnlyList<ChatInboxMessageDto>> GetMessagesForConversationAsync(\n            Guid businessId,\n            string contactPhone,\n            int limit,\n            CancellationToken ct = default);\n\n        Task<IReadOnlyList<ChatInboxMessageDto>> GetMessagesForConversationByContactIdAsync(\n            Guid businessId,\n            Guid contactId,\n            int limit,\n            CancellationToken ct = default);\n\n        Task<PagedResultDto<ChatInboxMessageDto>> GetMessagesPageForConversationByContactIdAsync(\n            Guid businessId,\n            Guid contactId,\n            int limit,\n            string? cursor,\n            CancellationToken ct = default);\n\n        Task<PagedResultDto<ChatInboxMessageDto>> GetMessagesPageForConversationByPhoneAsync(\n            Guid businessId,\n            string contactPhone,\n            int limit,\n            string? cursor,\n            CancellationToken ct = default);\n\n        // =========================\n        // Messages (SECURED)\n        // âœ… These enforce AssignedOnly restrictions using currentUserId from token.\n        // =========================\n\n        Task<IReadOnlyList<ChatInboxMessageDto>> GetMessagesForConversationAsync(\n            Guid businessId,\n            string contactPhone,\n            int limit,\n            Guid currentUserId,\n            CancellationToken ct = default);\n\n        Task<IReadOnlyList<ChatInboxMessageDto>> GetMessagesForConversationByContactIdAsync(\n            Guid businessId,\n            Guid contactId,\n            int limit,\n            Guid currentUserId,\n            CancellationToken ct = default);\n\n        Task<PagedResultDto<ChatInboxMessageDto>> GetMessagesPageForConversationByContactIdAsync(\n            Guid businessId,\n            Guid contactId,\n            int limit,\n            string? cursor,\n            Guid currentUserId,\n            CancellationToken ct = default);\n\n        Task<PagedResultDto<ChatInboxMessageDto>> GetMessagesPageForConversationByPhoneAsync(\n            Guid businessId,\n            string contactPhone,\n            int limit,\n            string? cursor,\n            Guid currentUserId,\n            CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/Utils/CursorCodec.cs",
      "sha256": "21089bac9edefd1e4a8b178491f66857b944410812a7b0ee113eec56c08bd2c9",
      "language": "csharp",
      "size": 1531,
      "content": "using System;\nusing System.Text;\nusing System.Text.Json;\n\nnamespace xbytechat.api.Features.ChatInbox.Utils\n{\n    internal static class CursorCodec\n    {\n        private static readonly JsonSerializerOptions JsonOpts = new(JsonSerializerDefaults.Web);\n\n        public static string Encode<T>(T obj)\n        {\n            var json = JsonSerializer.Serialize(obj, JsonOpts);\n            var bytes = Encoding.UTF8.GetBytes(json);\n            return Base64UrlEncode(bytes);\n        }\n\n        public static T? Decode<T>(string? cursor)\n        {\n            if (string.IsNullOrWhiteSpace(cursor)) return default;\n\n            try\n            {\n                var bytes = Base64UrlDecode(cursor.Trim());\n                var json = Encoding.UTF8.GetString(bytes);\n                return JsonSerializer.Deserialize<T>(json, JsonOpts);\n            }\n            catch\n            {\n                return default;\n            }\n        }\n\n        private static string Base64UrlEncode(byte[] input)\n        {\n            return Convert.ToBase64String(input)\n                .TrimEnd('=')\n                .Replace('+', '-')\n                .Replace('/', '_');\n        }\n\n        private static byte[] Base64UrlDecode(string input)\n        {\n            var padded = input.Replace('-', '+').Replace('_', '/');\n            switch (padded.Length % 4)\n            {\n                case 2: padded += \"==\"; break;\n                case 3: padded += \"=\"; break;\n            }\n            return Convert.FromBase64String(padded);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Controllers/ContactsController.cs",
      "sha256": "51c470a6310eea101c785831c7904967a477ba77ddaa65392188e685d9eeda86",
      "language": "csharp",
      "size": 17051,
      "content": "// ðŸ“„ File: xbytechat-api/Features/CRM/Controllers/ContactsController.cs\n\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Hosting;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing xbytechat.api.Features.CRM.Models;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Shared;\nusing xbytechat.api.Features.CRM.Dtos;\nusing xbytechat.api.Features.CRM.Interfaces;\n\nnamespace xbytechat.api.Features.CRM.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize] // CRM should be authenticated\n    public class ContactsController : ControllerBase\n    {\n        private readonly IContactService _contactService;\n        private readonly IContactTagService _contactTagService;\n        private readonly AppDbContext _db;\n        private readonly IHostEnvironment _env;\n        private readonly ILogger<ContactsController> _logger;\n\n        public ContactsController(\n            IContactService contactService,\n            IContactTagService contactTagService,\n            AppDbContext db,\n            IHostEnvironment env,\n            ILogger<ContactsController> logger)\n        {\n            _contactService = contactService;\n            _contactTagService = contactTagService;\n            _db = db;\n            _env = env;\n            _logger = logger;\n        }\n\n        // POST: api/contacts/create\n        [HttpPost(\"create\")]\n        public async Task<IActionResult> AddContact([FromBody] ContactDto dto)\n        {\n            if (!ModelState.IsValid)\n                return BadRequest(ResponseResult.ErrorInfo(\"âŒ Invalid contact payload.\"));\n\n            try\n            {\n                var businessId = HttpContext.User.GetBusinessId();\n                var result = await _contactService.AddContactAsync(businessId, dto);\n\n                return result.Success\n                    ? Ok(result)\n                    : BadRequest(result);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"ðŸš¨ Unexpected error in AddContact\");\n                return StatusCode(500, ResponseResult.ErrorInfo(\"ðŸš¨ Server error while creating contact.\", ex.ToString()));\n            }\n        }\n\n        // GET: api/contacts/{id}\n        [HttpGet(\"{id:guid}\")]\n        public async Task<IActionResult> GetContactById(Guid id)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var contact = await _contactService.GetContactByIdAsync(businessId, id);\n\n            if (contact == null)\n                return NotFound(ResponseResult.ErrorInfo(\"Contact not found.\"));\n\n            return Ok(ResponseResult.SuccessInfo(\"Contact loaded.\", contact));\n        }\n\n        // PUT: api/contacts/{id}\n        [HttpPut(\"{id:guid}\")]\n        public async Task<IActionResult> UpdateContact(Guid id, [FromBody] ContactDto dto)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            dto.Id = id;\n\n            var success = await _contactService.UpdateContactAsync(businessId, dto);\n            if (!success)\n                return NotFound(ResponseResult.ErrorInfo(\"Contact not found.\"));\n\n            return Ok(ResponseResult.SuccessInfo(\"Contact updated.\"));\n        }\n\n        // DELETE: api/contacts/{id}\n        [HttpDelete(\"{id:guid}\")]\n        public async Task<IActionResult> DeleteContact(Guid id)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n\n            var success = await _contactService.DeleteContactAsync(businessId, id);\n            if (!success)\n                return NotFound(ResponseResult.ErrorInfo(\"Contact not found.\"));\n\n            return Ok(ResponseResult.SuccessInfo(\"Contact deleted.\"));\n        }\n\n        // POST: api/contacts/parse-csv  (hidden from swagger as you did)\n        [ApiExplorerSettings(IgnoreApi = true)]\n        [HttpPost(\"parse-csv\")]\n        [Consumes(\"multipart/form-data\")]\n        public async Task<IActionResult> ParseCsvToContactsAsync([FromForm] IFormFile file)\n        {\n            if (file == null || file.Length == 0)\n                return BadRequest(ResponseResult.ErrorInfo(\"CSV file is required.\"));\n\n            var businessId = HttpContext.User.GetBusinessId();\n\n            try\n            {\n                using var stream = file.OpenReadStream();\n                var parseResult = await _contactService.ParseCsvToContactsAsync(businessId, stream);\n                return Ok(ResponseResult.SuccessInfo(\"CSV parsed with detailed results.\", parseResult));\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"CSV parsing failed.\");\n                return BadRequest(ResponseResult.ErrorInfo(\"CSV parsing failed: \" + ex.Message));\n            }\n        }\n\n        // PATCH: /api/contacts/{id}/favorite\n        [HttpPatch(\"{id:guid}/favorite\")]\n        public async Task<IActionResult> ToggleFavorite(Guid id)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n\n            var success = await _contactService.ToggleFavoriteAsync(businessId, id);\n            if (!success)\n                return NotFound(ResponseResult.ErrorInfo(\"Contact not found.\"));\n\n            return Ok(ResponseResult.SuccessInfo(\"Favorite toggled.\"));\n        }\n\n        // PATCH: /api/contacts/{id}/archive\n        [HttpPatch(\"{id:guid}/archive\")]\n        public async Task<IActionResult> ToggleArchive(Guid id)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n\n            var success = await _contactService.ToggleArchiveAsync(businessId, id);\n            if (!success)\n                return NotFound(ResponseResult.ErrorInfo(\"Contact not found.\"));\n\n            return Ok(ResponseResult.SuccessInfo(\"Archive toggled.\"));\n        }\n\n        // POST: api/contacts/bulk-assign-tag\n        [HttpPost(\"bulk-assign-tag\")]\n        public async Task<IActionResult> AssignTagToContacts([FromBody] AssignTagToContactsDto dto)\n        {\n            if (dto.ContactIds == null || !dto.ContactIds.Any())\n                return BadRequest(ResponseResult.ErrorInfo(\"No contact IDs provided.\"));\n\n            var businessId = HttpContext.User.GetBusinessId();\n\n            await _contactService.AssignTagToContactsAsync(businessId, dto.ContactIds, dto.TagId);\n            return Ok(ResponseResult.SuccessInfo(\"Tag assigned to selected contacts.\"));\n        }\n\n        // DELETE: api/contacts/{contactId}/tags/{tagId}\n        // Used by Inbox â€œremove tagâ€ on one contact.\n        [HttpDelete(\"{contactId:guid}/tags/{tagId:guid}\")]\n        public async Task<IActionResult> RemoveTagFromContact(Guid contactId, Guid tagId)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n\n            var removed = await _contactTagService.RemoveTagFromContactAsync(businessId, contactId, tagId);\n            if (!removed)\n                return NotFound(ResponseResult.ErrorInfo(\"Tag link not found for this contact.\"));\n\n            return Ok(ResponseResult.SuccessInfo(\"Tag removed from contact.\"));\n        }\n\n        // POST: api/contacts/bulk-unassign-tag\n        // Avoid axios DELETE-body edge cases\n        [HttpPost(\"bulk-unassign-tag\")]\n        public async Task<IActionResult> BulkUnassignTag([FromBody] AssignTagToContactsDto dto)\n        {\n            if (dto.ContactIds == null || !dto.ContactIds.Any())\n                return BadRequest(ResponseResult.ErrorInfo(\"No contact IDs provided.\"));\n\n            var businessId = HttpContext.User.GetBusinessId();\n\n            var removedCount = 0;\n            foreach (var contactId in dto.ContactIds)\n            {\n                var removed = await _contactTagService.RemoveTagFromContactAsync(businessId, contactId, dto.TagId);\n                if (removed) removedCount++;\n            }\n\n            return Ok(ResponseResult.SuccessInfo($\"Tag unassigned from {removedCount} contact(s).\", new { removedCount }));\n        }\n\n        // OPTIONAL: keep DELETE too (prevents 405 surprises)\n        [HttpDelete(\"bulk-unassign-tag\")]\n        public Task<IActionResult> BulkUnassignTagDelete([FromBody] AssignTagToContactsDto dto)\n            => BulkUnassignTag(dto);\n\n        // GET: api/contacts?tab=all&search=...&page=1&pageSize=25\n        [HttpGet]\n        public async Task<IActionResult> GetAllContacts(\n            [FromQuery] string? tab = \"all\",\n            [FromQuery] string? search = null,\n            [FromQuery] int page = 1,\n            [FromQuery] int pageSize = 25)\n        {\n            if (page < 1) page = 1;\n            if (pageSize < 1) pageSize = 25;\n            if (pageSize > 200) pageSize = 200; // safety cap\n\n            var businessId = HttpContext.User.GetBusinessId();\n\n            var pagedResult = await _contactService.GetPagedContactsAsync(businessId, tab, page, pageSize, search);\n            return Ok(ResponseResult.SuccessInfo(\"Contacts loaded.\", pagedResult));\n        }\n\n        // GET: api/contacts/all  (flat list, used in dropdowns)\n        [HttpGet(\"all\")]\n        public async Task<IActionResult> GetAllContactsFlat()\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var allContacts = await _contactService.GetAllContactsAsync(businessId);\n\n            // Keep wrapper consistent (helps frontend)\n            return Ok(ResponseResult.SuccessInfo(\"Contacts loaded.\", allContacts));\n        }\n\n        // POST: api/contacts/filter-by-tags  (body = list of tagIds as strings)\n        [HttpPost(\"filter-by-tags\")]\n        public async Task<IActionResult> FilterContactsByTags([FromBody] List<string> tags)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n\n            var tagGuids = (tags ?? new List<string>())\n                .Where(x => Guid.TryParse(x, out _))\n                .Select(Guid.Parse)\n                .ToList();\n\n            var contacts = await _contactService.GetContactsByTagsAsync(businessId, tagGuids);\n\n            return Ok(ResponseResult.SuccessInfo(\"Contacts filtered successfully.\", contacts));\n        }\n\n        // POST: api/contacts/bulk-import\n        [HttpPost(\"bulk-import\")]\n        [Consumes(\"multipart/form-data\")]\n        public async Task<IActionResult> BulkImportContactsAsync( IFormFile file)\n        {\n            if (file == null || file.Length == 0)\n                return BadRequest(ResponseResult.ErrorInfo(\"CSV file is required.\"));\n\n            var businessId = HttpContext.User.GetBusinessId();\n\n            try\n            {\n                using var stream = file.OpenReadStream();\n                var result = await _contactService.BulkImportAsync(businessId, stream);\n                return Ok(ResponseResult.SuccessInfo(\"Contacts imported successfully.\", result));\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Bulk import failed.\");\n                return BadRequest(ResponseResult.ErrorInfo(\"Import failed: \" + ex.Message));\n            }\n        }\n\n        // GET: api/contacts/by-tags?tagIds=...&tagIds=...\n        [HttpGet(\"by-tags\")]\n        public async Task<IActionResult> GetContactsByTagIds([FromQuery] List<Guid> tagIds)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var contacts = await _contactService.GetContactsByTagsAsync(businessId, tagIds);\n\n            return Ok(ResponseResult.SuccessInfo(\"Contacts filtered successfully.\", contacts));\n        }\n\n        // GET: api/contacts/debug/opt-status?phone=9198...\n        [ApiExplorerSettings(IgnoreApi = true)]\n        [HttpGet(\"debug/opt-status\")]\n        public async Task<IActionResult> GetOptStatusDebug([FromQuery] string phone)\n        {\n            if (string.IsNullOrWhiteSpace(phone))\n                return BadRequest(ResponseResult.ErrorInfo(\"Phone is required.\"));\n\n            var businessId = HttpContext.User.GetBusinessId();\n            var candidates = BuildPhoneLookupCandidates(phone);\n            if (candidates.Count == 0)\n                return BadRequest(ResponseResult.ErrorInfo(\"Phone format is invalid.\"));\n\n            var contact = await _db.Contacts\n                .AsNoTracking()\n                .Where(c => c.BusinessId == businessId && candidates.Contains(c.PhoneNumber))\n                .OrderByDescending(c => c.OptStatus == ContactOptStatus.OptedOut)\n                .ThenByDescending(c => c.OptStatusUpdatedAt)\n                .FirstOrDefaultAsync();\n\n            if (contact == null)\n            {\n                return NotFound(ResponseResult.ErrorInfo(\"Contact not found for provided phone.\"));\n            }\n\n            return Ok(ResponseResult.SuccessInfo(\"Opt status resolved.\", new\n            {\n                contactId = contact.Id,\n                phoneNumber = contact.PhoneNumber,\n                optStatus = contact.OptStatus.ToString(),\n                channelStatus = contact.ChannelStatus.ToString(),\n                optOutReason = contact.OptOutReason,\n                optStatusUpdatedAt = contact.OptStatusUpdatedAt,\n                channelStatusUpdatedAt = contact.ChannelStatusUpdatedAt\n            }));\n        }\n\n        // POST: api/contacts/debug/force-opt-in?phone=9198...&resetChannel=true\n        [ApiExplorerSettings(IgnoreApi = true)]\n        [HttpPost(\"debug/force-opt-in\")]\n        public async Task<IActionResult> ForceOptInDebug([FromQuery] string phone, [FromQuery] bool resetChannel = false)\n        {\n            if (_env.IsProduction())\n                return StatusCode(403, ResponseResult.ErrorInfo(\"Debug endpoint is disabled in production.\"));\n\n            if (string.IsNullOrWhiteSpace(phone))\n                return BadRequest(ResponseResult.ErrorInfo(\"Phone is required.\"));\n\n            var businessId = HttpContext.User.GetBusinessId();\n            var candidates = BuildPhoneLookupCandidates(phone);\n            if (candidates.Count == 0)\n                return BadRequest(ResponseResult.ErrorInfo(\"Phone format is invalid.\"));\n\n            var contact = await _db.Contacts\n                .Where(c => c.BusinessId == businessId && candidates.Contains(c.PhoneNumber))\n                .OrderByDescending(c => c.OptStatus == ContactOptStatus.OptedOut)\n                .ThenByDescending(c => c.OptStatusUpdatedAt)\n                .FirstOrDefaultAsync();\n\n            if (contact == null)\n                return NotFound(ResponseResult.ErrorInfo(\"Contact not found for provided phone.\"));\n\n            var nowUtc = DateTime.UtcNow;\n            contact.OptStatus = ContactOptStatus.OptedIn;\n            contact.OptStatusUpdatedAt = nowUtc;\n            contact.OptOutReason = null;\n\n            if (resetChannel)\n            {\n                contact.ChannelStatus = ContactChannelStatus.Valid;\n                contact.ChannelStatusUpdatedAt = nowUtc;\n            }\n\n            await _db.SaveChangesAsync();\n\n            _logger.LogWarning(\n                \"Debug force-opt-in applied. businessId={BusinessId} contactId={ContactId} phone={Phone} resetChannel={ResetChannel}\",\n                businessId,\n                contact.Id,\n                contact.PhoneNumber,\n                resetChannel);\n\n            return Ok(ResponseResult.SuccessInfo(\"Contact force opt-in applied.\", new\n            {\n                contactId = contact.Id,\n                phoneNumber = contact.PhoneNumber,\n                optStatus = contact.OptStatus.ToString(),\n                channelStatus = contact.ChannelStatus.ToString(),\n                optOutReason = contact.OptOutReason,\n                optStatusUpdatedAt = contact.OptStatusUpdatedAt,\n                channelStatusUpdatedAt = contact.ChannelStatusUpdatedAt,\n                resetChannel\n            }));\n        }\n\n        private static List<string> BuildPhoneLookupCandidates(string? raw)\n        {\n            var value = (raw ?? string.Empty).Trim();\n            var list = new HashSet<string>(StringComparer.Ordinal);\n\n            var normalized = PhoneNumberNormalizer.NormalizeToE164Digits(value, \"IN\");\n            var digits = new string(value.Where(char.IsDigit).ToArray());\n\n            if (!string.IsNullOrWhiteSpace(normalized))\n            {\n                list.Add(normalized);\n                list.Add(\"+\" + normalized);\n\n                if (normalized.Length == 12 && normalized.StartsWith(\"91\", StringComparison.Ordinal))\n                    list.Add(normalized.Substring(2));\n            }\n\n            if (!string.IsNullOrWhiteSpace(digits))\n            {\n                list.Add(digits);\n                list.Add(\"+\" + digits);\n\n                if (digits.Length == 10)\n                {\n                    list.Add(\"91\" + digits);\n                    list.Add(\"+91\" + digits);\n                }\n                else if (digits.Length == 12 && digits.StartsWith(\"91\", StringComparison.Ordinal))\n                {\n                    list.Add(digits.Substring(2));\n                }\n            }\n\n            if (!string.IsNullOrWhiteSpace(value))\n                list.Add(value);\n\n            return list.Where(x => !string.IsNullOrWhiteSpace(x)).ToList();\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Controllers/CrmSummaryController.cs",
      "sha256": "49a9a81d7aeacd60428584f63e0e2315622b2a2a91ea8cff69145a7c452a67e0",
      "language": "csharp",
      "size": 2829,
      "content": "// ðŸ“„ xbytechat-api/Features/CRM/Summary/Controllers/CrmSummaryController.cs\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.CRM.Services;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.CRM.Controllers\n{\n    /// <summary>\n    /// Thin API surface for CRM summary endpoints used by Chat Inbox\n    /// and future dashboards.\n    /// </summary>\n    [ApiController]\n    [Route(\"api/crm-summary\")]\n    public sealed class CrmSummaryController : ControllerBase\n    {\n        private readonly IContactSummaryService _contactSummaryService;\n        private readonly ILogger<CrmSummaryController> _logger;\n\n        public CrmSummaryController(\n            IContactSummaryService contactSummaryService,\n            ILogger<CrmSummaryController> logger)\n        {\n            _contactSummaryService = contactSummaryService ?? throw new ArgumentNullException(nameof(contactSummaryService));\n            _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n        }\n\n        /// <summary>\n        /// Returns a compact CRM snapshot for a given contact:\n        /// Contact core fields, tags, recent notes, next reminder, recent timeline entries.\n        /// </summary>\n        [HttpGet(\"contact-summary/{contactId:guid}\")]              // âœ… new route: /api/crm-summary/contact-summary/{id}\n        [HttpGet(\"/api/crm/contact-summary/{contactId:guid}\")]     // âœ… backward-compatible route: /api/crm/contact-summary/{id}\n        public async Task<IActionResult> GetContactSummary(Guid contactId, CancellationToken ct)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            if (businessId == Guid.Empty)\n            {\n                return Unauthorized(ResponseResult.ErrorInfo(\"Missing BusinessId in user claims.\"));\n            }\n\n            try\n            {\n                var summary = await _contactSummaryService.GetContactSummaryAsync(businessId, contactId, ct);\n                if (summary == null)\n                {\n                    return NotFound(ResponseResult.ErrorInfo(\"Contact not found for this business.\"));\n                }\n\n                return Ok(ResponseResult.SuccessInfo(\"Contact summary loaded.\", summary));\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(\n                    ex,\n                    \"âŒ Failed to load contact summary. Business={BusinessId}, Contact={ContactId}\",\n                    businessId,\n                    contactId);\n\n                return StatusCode(\n                    500,\n                    ResponseResult.ErrorInfo(\"An error occurred while loading contact summary.\", ex.Message));\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Controllers/NotesController.cs",
      "sha256": "cb225e42566f276e2b69c4112c1a6afb8ea4bb176fabbb5e7a628df83604a799",
      "language": "csharp",
      "size": 3574,
      "content": "// ðŸ“„ xbytechat-api/Features/CRM/Controllers/NotesController.cs\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.CRM.Dtos;\nusing xbytechat.api.Features.CRM.Interfaces;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.CRM.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class NotesController : ControllerBase\n    {\n        private readonly INoteService _noteService;\n\n        public NotesController(INoteService noteService)\n        {\n            _noteService = noteService;\n        }\n\n        // âœ… Clean, REST-y POST: /api/notes\n        [HttpPost]\n        public async Task<IActionResult> AddNote([FromBody] NoteDto dto)\n        {\n            try\n            {\n                if (dto == null)\n                {\n                    return BadRequest(ResponseResult.ErrorInfo(\"Note payload is missing.\"));\n                }\n\n                var businessId = HttpContext.User.GetBusinessId();\n                var result = await _noteService.AddNoteAsync(businessId, dto);\n                return Ok(ResponseResult.SuccessInfo(\"Note created.\", result));\n            }\n            catch (Exception ex)\n            {\n                return StatusCode(\n                    500,\n                    ResponseResult.ErrorInfo(\"Error creating note\", ex.Message)\n                );\n            }\n        }\n\n        // GET /api/notes/contact/{contactId}\n        [HttpGet(\"contact/{contactId}\")]\n        public async Task<IActionResult> GetNotesByContact(Guid contactId)\n        {\n            try\n            {\n                var businessId = HttpContext.User.GetBusinessId();\n                var result = await _noteService.GetNotesByContactAsync(businessId, contactId);\n                return Ok(ResponseResult.SuccessInfo(\"Notes loaded.\", result));\n            }\n            catch (Exception ex)\n            {\n                return StatusCode(\n                    500,\n                    ResponseResult.ErrorInfo(\"Error fetching notes\", ex.Message)\n                );\n            }\n        }\n\n        // GET /api/notes/{id}\n        [HttpGet(\"{id}\")]\n        public async Task<IActionResult> GetNoteById(Guid id)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var result = await _noteService.GetNoteByIdAsync(businessId, id);\n\n            if (result == null)\n            {\n                return NotFound(ResponseResult.ErrorInfo(\"Note not found.\"));\n            }\n\n            return Ok(ResponseResult.SuccessInfo(\"Note loaded.\", result));\n        }\n\n        // PUT /api/notes/{id}\n        [HttpPut(\"{id}\")]\n        public async Task<IActionResult> UpdateNote(Guid id, [FromBody] NoteDto dto)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var success = await _noteService.UpdateNoteAsync(businessId, id, dto);\n\n            if (!success)\n            {\n                return NotFound(ResponseResult.ErrorInfo(\"Note not found.\"));\n            }\n\n            return Ok(ResponseResult.SuccessInfo(\"Note updated.\"));\n        }\n\n        // DELETE /api/notes/{id}\n        [HttpDelete(\"{id}\")]\n        public async Task<IActionResult> DeleteNote(Guid id)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var success = await _noteService.DeleteNoteAsync(businessId, id);\n\n            if (!success)\n            {\n                return NotFound(ResponseResult.ErrorInfo(\"Note not found.\"));\n            }\n\n            return Ok(ResponseResult.SuccessInfo(\"Note deleted.\"));\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Controllers/RemindersController.cs",
      "sha256": "94768043e5877270f9ca797c084d60b10d081df7b7973bed29466c4b07018405",
      "language": "csharp",
      "size": 3241,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.CRM.Models;\nusing xbytechat.api.Features.CRM.Dtos;\nusing xbytechat.api.Features.CRM.Interfaces;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.CRM.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class RemindersController : ControllerBase\n    {\n        private readonly IReminderService _reminderService;\n\n        public RemindersController(IReminderService reminderService)\n        {\n            _reminderService = reminderService;\n        }\n\n        [HttpPost]\n        public async Task<IActionResult> AddReminder(ReminderDto dto)\n        {\n            try\n            {\n                var businessId = HttpContext.User.GetBusinessId();\n                if (dto == null)\n                    return BadRequest(ResponseResult.ErrorInfo(\"Reminder data is missing.\"));\n\n                var result = await _reminderService.AddReminderAsync(businessId, dto);\n                return Ok(ResponseResult.SuccessInfo(\"Reminder created.\", result));\n            }\n            catch (Exception ex)\n            {\n                return StatusCode(500, ResponseResult.ErrorInfo(\"An error occurred while adding the reminder.\", ex.Message));\n            }\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> GetAllReminders()\n        {\n            try\n            {\n                var businessId = HttpContext.User.GetBusinessId();\n                var reminders = await _reminderService.GetAllRemindersAsync(businessId);\n                return Ok(ResponseResult.SuccessInfo(\"Reminders loaded.\", reminders));\n            }\n            catch (Exception ex)\n            {\n                return StatusCode(500, ResponseResult.ErrorInfo(\"An error occurred while fetching reminders.\", ex.Message));\n            }\n        }\n\n        [HttpGet(\"{id}\")]\n        public async Task<IActionResult> GetReminderById(Guid id)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var reminder = await _reminderService.GetReminderByIdAsync(businessId, id);\n            if (reminder == null)\n                return NotFound(ResponseResult.ErrorInfo(\"Reminder not found.\"));\n            return Ok(ResponseResult.SuccessInfo(\"Reminder loaded.\", reminder));\n        }\n\n        [HttpPut(\"{id}\")]\n        public async Task<IActionResult> UpdateReminder(Guid id, [FromBody] ReminderDto dto)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var success = await _reminderService.UpdateReminderAsync(businessId, id, dto);\n            if (!success)\n                return NotFound(ResponseResult.ErrorInfo(\"Reminder not found.\"));\n            return Ok(ResponseResult.SuccessInfo(\"Reminder updated.\"));\n        }\n\n        [HttpDelete(\"{id}\")]\n        public async Task<IActionResult> DeleteReminder(Guid id)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var success = await _reminderService.DeleteReminderAsync(businessId, id);\n            if (!success)\n                return NotFound(ResponseResult.ErrorInfo(\"Reminder not found.\"));\n            return Ok(ResponseResult.SuccessInfo(\"Reminder deleted.\"));\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Controllers/TagsController.cs",
      "sha256": "63ac6f2a529c4a2363dc42af6e6a6c17792b7aaf572935395352ebd5a8069124",
      "language": "csharp",
      "size": 2397,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.CRM.Dtos;\nusing xbytechat.api.Features.CRM.Interfaces;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.CRM.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class TagsController : ControllerBase\n    {\n        private readonly ITagService _tagService;\n\n        public TagsController(ITagService tagService)\n        {\n            _tagService = tagService;\n        }\n\n        [HttpPost]\n        public async Task<IActionResult> AddTag([FromBody] TagDto dto)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var result = await _tagService.AddTagAsync(businessId, dto);\n            return Ok(ResponseResult.SuccessInfo(\"Tag created.\", result));\n        }\n\n        [HttpPut(\"{id}\")]\n        public async Task<IActionResult> UpdateTag(Guid id, [FromBody] TagDto dto)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var success = await _tagService.UpdateTagAsync(businessId, id, dto);\n            if (!success)\n                return NotFound(ResponseResult.ErrorInfo(\"Tag not found.\"));\n            return Ok(ResponseResult.SuccessInfo(\"Tag updated.\"));\n        }\n\n        ////[HttpGet(\"get-tags\")]\n        [HttpGet(\"get-tags\")]\n        public async Task<IActionResult> GetAllTagsLegacy()\n        {\n            // Backward compatible alias for older clients\n            var businessId = HttpContext.User.GetBusinessId();\n            var tags = await _tagService.GetAllTagsAsync(businessId);\n            return Ok(ResponseResult.SuccessInfo(\"Tags loaded.\", tags));\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> GetAllTags()\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var tags = await _tagService.GetAllTagsAsync(businessId);\n            return Ok(ResponseResult.SuccessInfo(\"Tags loaded.\", tags));\n        }\n\n        [HttpDelete(\"{id}\")]\n        public async Task<IActionResult> DeleteTag(Guid id)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var success = await _tagService.DeleteTagAsync(businessId, id);\n            if (!success)\n                return NotFound(ResponseResult.ErrorInfo(\"Tag not found.\"));\n            return Ok(ResponseResult.SuccessInfo(\"Tag deleted.\"));\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Dtos/AssignTagToContactsDto.cs",
      "sha256": "905dc04f16dd3b6ee269a89e0ea202a6af3dea76b223c9013713e74bb418bb24",
      "language": "csharp",
      "size": 198,
      "content": "namespace xbytechat.api.Features.CRM.Dtos\n{\n    public class AssignTagToContactsDto\n    {\n        public List<Guid> ContactIds { get; set; } = new();\n        public Guid TagId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Dtos/BulkImportResultDto.cs",
      "sha256": "f552fe1e5d5f1e2a8275aae3baac3882b78b0cae422c4ac8d82db52d3c78bdba",
      "language": "csharp",
      "size": 1145,
      "content": "namespace xbytechat.api.Features.CRM.Dtos\n{\n    public class BulkImportResultDto\n    {\n        public int Imported { get; set; }          // brand-new rows inserted\n        public int Restored { get; set; }          // previously IsActive=false -> restored\n        public int SkippedExisting { get; set; }   // already active -> skipped\n        public int DuplicatesInFile { get; set; }  // same phone repeated in CSV -> ignored\n        public List<CsvImportError> Errors { get; set; } = new();\n    }\n\n    // Optional: remove this if unused (CsvImportError already exists elsewhere)\n    public class CsvImportErrorMsg\n    {\n        public int RowNumber { get; set; }\n        public string ErrorMessage { get; set; }\n    }\n}\n\n\n//namespace xbytechat.api.Features.CRM.Dtos\n//{\n//    public class BulkImportResultDto\n//    {\n//        public int Imported { get; set; }\n//        public int SkippedExisting { get; set; }\n//        public List<CsvImportError> Errors { get; set; } = new();\n//    }\n\n//    public class CsvImportErrorMsg\n//    {\n//        public int RowNumber { get; set; }\n//        public string ErrorMessage { get; set; }\n//    }\n//}"
    },
    {
      "path": "xbytechat-api/Features/CRM/Dtos/ContactDto.cs",
      "sha256": "83bef17a1c7bc4901f020261fb9a4d30c7bab7acab03e82fe3182e4eb4a24de3",
      "language": "csharp",
      "size": 1365,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.CRM.Dtos\n{\n    public class ContactDto\n    {\n        public Guid? Id { get; set; } // Nullable for Create (used in PUT)\n\n        public string Name { get; set; } // Contact full name\n\n        public string PhoneNumber { get; set; } // WhatsApp-compatible number\n\n        public string? Email { get; set; } // Optional email address\n\n        public string? LeadSource { get; set; } // e.g., \"WhatsApp\", \"Facebook\", \"Landing Page\"\n\n        public DateTime? LastContactedAt { get; set; } // Last WhatsApp or CRM interaction\n\n        public DateTime? NextFollowUpAt { get; set; } // For scheduling reminders\n\n        public string? Notes { get; set; } // Internal notes for the contact\n\n        public DateTime? CreatedAt { get; set; } // Read-only timestamp\n\n        // âœ… NEW: Structured Tags (replaces comma-separated strings)\n        // Example: [{ id: 1, name: \"VIP\" }, { id: 2, name: \"Follow-up\" }]\n        public List<ContactTagDto> Tags { get; set; } = new();\n\n        public bool IsFavorite { get; set; } = false;\n        public bool IsArchived { get; set; } = false;\n        public string? Group { get; set; }\n\n        public bool IsTemporary { get; set; } = false;\n        public Guid? SourceCampaignId { get; set; }\n        public DateTime? ExpiresAt { get; set; }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Dtos/ContactDtoCsvMap.cs",
      "sha256": "1e2f57eea6d6f012d91f094a8f62c352fe93ae763566730af8c530fe0fb271b7",
      "language": "csharp",
      "size": 1744,
      "content": "using CsvHelper.Configuration;\n\nnamespace xbytechat.api.Features.CRM.Dtos\n{\n    /// <summary>\n    /// CSV mapping for ContactDto import.\n    /// Keeps header matching flexible (multiple header aliases).\n    /// Header normalization is applied in CsvConfiguration (not here).\n    /// </summary>\n    public sealed class ContactDtoCsvMap : ClassMap<ContactDto>\n    {\n        public ContactDtoCsvMap()\n        {\n            // Required core columns\n            Map(m => m.Name).Name(\"name\", \"fullname\", \"contactname\", \"customername\");\n            Map(m => m.PhoneNumber).Name(\"phone\", \"phonenumber\", \"mobile\", \"mobilenumber\", \"whatsapp\", \"whatsappnumber\");\n\n            // Optional columns\n            Map(m => m.Email).Name(\"email\", \"emailid\").Optional();\n            Map(m => m.Notes).Name(\"notes\", \"note\", \"remark\", \"remarks\", \"comment\", \"comments\").Optional();\n\n            // Optional but useful for CRM analytics\n            Map(m => m.LeadSource).Name(\"leadsource\", \"lead source\", \"source\", \"lead\", \"leadorigin\").Optional();\n\n            // We are intentionally NOT importing Tags yet because Tags is a List<string>.\n            // If you want later: we can add a converter for a comma-separated \"Tags\" column.\n        }\n    }\n}\n\n\n//using CsvHelper.Configuration;\n\n//namespace xbytechat.api.Features.CRM.Dtos\n//{\n//    public class ContactDtoCsvMap : ClassMap<ContactDto>\n//    {\n//        public ContactDtoCsvMap()\n//        {\n//            Map(m => m.Name).Name(\"name\", \"Name\", \"full name\");\n//            Map(m => m.PhoneNumber).Name(\"phone\", \"Phone\", \"mobile\", \"mobile number\");\n//            Map(m => m.Email).Name(\"email\", \"Email\").Optional();\n//            Map(m => m.Notes).Name(\"notes\", \"Notes\").Optional();\n//        }\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Dtos/ContactSummaryResponseDto.cs",
      "sha256": "9e1ca2d18ba212e71090bdc4633e1e4cf955e8f8ba21663145f60c032f1031e1",
      "language": "csharp",
      "size": 1436,
      "content": "// ðŸ“„ xbytechat-api/Features/CRM/Summary/Dtos/ContactSummaryResponseDto.cs\nusing System;\nusing System.Collections.Generic;\nusing xbytechat.api.Features.CRM.Timelines.DTOs;\n\nnamespace xbytechat.api.Features.CRM.Dtos\n{\n    /// <summary>\n    /// Compact CRM snapshot for a contact:\n    /// - Core contact fields\n    /// - Tags\n    /// - Recent notes\n    /// - Next reminder\n    /// - Recent timeline events\n    /// </summary>\n    public sealed class ContactSummaryResponseDto\n    {\n        public Guid BusinessId { get; set; }\n        public Guid ContactId { get; set; }\n\n        // Core contact profile\n        public string Name { get; set; } = string.Empty;\n        public string PhoneNumber { get; set; } = string.Empty;\n        public string? Email { get; set; }\n        public string? LeadSource { get; set; }\n\n        public bool IsFavorite { get; set; }\n        public bool IsArchived { get; set; }\n        public string? Group { get; set; }\n\n        public DateTime? LastContactedAt { get; set; }\n        public DateTime? NextFollowUpAt { get; set; }\n\n        // Structured tags (from ContactDto.ContactTags â†’ ContactTagDto)\n        public List<ContactTagDto> Tags { get; set; } = new();\n\n        // Mini timeline section\n        public List<NoteDto> RecentNotes { get; set; } = new();\n\n        public ReminderDto? NextReminder { get; set; }\n\n        public List<LeadTimelineDto> RecentTimeline { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Dtos/ContactTagDto.cs",
      "sha256": "69e97156f1e9453485bbaa39803b7c132d5a991e27091eb6cb648b42a148fc7a",
      "language": "csharp",
      "size": 281,
      "content": "namespace xbytechat.api.Features.CRM.Dtos\n{\n    public class ContactTagDto\n    {\n        public Guid TagId { get; set; }\n        public string TagName { get; set; } = string.Empty;\n        public string? ColorHex { get; set; }\n        public string? Category { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Dtos/CrmContactSummaryDto.cs",
      "sha256": "320c7a1b0dd1223ea9e8a517b258e7235d2c12f71a798317c71483d95d2b0d26",
      "language": "csharp",
      "size": 2012,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.CRM.DTOs\n{\n    public sealed class CrmContactSummaryDto\n    {\n        public Guid ContactId { get; set; }\n        public Guid BusinessId { get; set; }\n\n        public string Name { get; set; } = string.Empty;\n        public string PhoneNumber { get; set; } = string.Empty;\n        public string? Email { get; set; }\n        public string? LeadSource { get; set; }\n        public DateTime? CreatedAt { get; set; }\n\n        // ðŸ‘‡ These names match ChatInbox.jsx usage\n        public List<CrmTagChipDto> Tags { get; set; } = new();\n        public List<CrmNoteSnippetDto> RecentNotes { get; set; } = new();\n        public CrmReminderSnippetDto? NextReminder { get; set; }\n        public List<CrmTimelineEventDto> RecentTimeline { get; set; } = new();\n    }\n\n    public sealed class CrmTagChipDto\n    {\n        public Guid Id { get; set; }\n        public string TagName { get; set; } = string.Empty;\n        public string? ColorHex { get; set; }\n    }\n\n    public sealed class CrmNoteSnippetDto\n    {\n        public Guid Id { get; set; }\n        public string Title { get; set; } = string.Empty;\n        public string Content { get; set; } = string.Empty;\n        public string? CreatedByName { get; set; }\n        public DateTime CreatedAt { get; set; }\n    }\n\n    public sealed class CrmReminderSnippetDto\n    {\n        public Guid Id { get; set; }\n        public string Title { get; set; } = string.Empty;\n        public string? Description { get; set; }\n        public string? Status { get; set; }\n        public DateTime DueAt { get; set; }\n        public int? Priority { get; set; }\n    }\n\n    public sealed class CrmTimelineEventDto\n    {\n        public int Id { get; set; }\n        public string Title { get; set; } = string.Empty;\n        public string? Source { get; set; }\n        public string? Category { get; set; }\n        public string? EventType { get; set; }\n        public DateTime CreatedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Dtos/CsvImportResult.cs",
      "sha256": "b960c95f03cdabf593c9264c4a26457bc30278af2e88d77efe9a54ae066dd3c7",
      "language": "csharp",
      "size": 373,
      "content": "namespace xbytechat.api.Features.CRM.Dtos\n{\n    public class CsvImportResult<T>\n    {\n        public List<T> SuccessRecords { get; set; } = new();\n        public List<CsvImportError> Errors { get; set; } = new();\n    }\n\n    public class CsvImportError\n    {\n        public int RowNumber { get; set; }\n        public string ErrorMessage { get; set; } = string.Empty;\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/CRM/Dtos/NoteDto.cs",
      "sha256": "c69bf4f1954478dea6d479494ee03486eaac09f14ac495b0cbde23f17f107568",
      "language": "csharp",
      "size": 525,
      "content": "namespace xbytechat.api.Features.CRM.Dtos\n{\n    public class NoteDto\n    {\n        public Guid Id { get; set; }\n        public Guid? ContactId { get; set; }\n        public string? Title { get; set; }\n        public string Content { get; set; }\n        public string Source { get; set; }\n        public string CreatedBy { get; set; }\n        public bool IsPinned { get; set; }\n        public bool IsInternal { get; set; }\n        public DateTime CreatedAt { get; set; }\n        public DateTime? EditedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Dtos/PagedResult.cs",
      "sha256": "fecb6fb29ec3bedc245dacd6fb2198d2f2c98335be5a5d93cd5a787d9248faa3",
      "language": "csharp",
      "size": 351,
      "content": "namespace xbytechat.api.Features.CRM.Dtos\n{\n    public class PagedResult<T>\n    {\n        public List<T> Items { get; set; } = new();\n        public int TotalCount { get; set; }\n\n        public int Page { get; set; }\n        public int PageSize { get; set; }\n        public int TotalPages => (int)Math.Ceiling(TotalCount / (double)PageSize);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Dtos/ReminderDto.cs",
      "sha256": "637c90565af9cbcfe158cca564388b9afdadb2c3cbcacad35242dfe85f9bd395",
      "language": "csharp",
      "size": 1003,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CRM.Dtos\n{\n    public class ReminderDto\n    {\n        public Guid? Id { get; set; }  // Null when creating, present when updating\n\n        public Guid? ContactId { get; set; }\n\n        public string Title { get; set; } = default!;\n\n        public string? Description { get; set; }\n\n        public DateTime DueAt { get; set; }\n\n        public string? Status { get; set; } = \"Pending\";\n\n        public string? ReminderType { get; set; }\n\n        public int? Priority { get; set; }\n\n        public bool IsRecurring { get; set; }\n\n        public string? RecurrencePattern { get; set; }\n\n        public bool SendWhatsappNotification { get; set; }\n\n        public string? LinkedCampaign { get; set; }\n\n        public bool IsActive { get; set; } = true;\n\n        public DateTime? CreatedAt { get; set; }\n\n        public DateTime? UpdatedAt { get; set; }\n\n        public DateTime? CompletedAt { get; set; }\n\n        public string? CreatedBy { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Dtos/TagDto.cs",
      "sha256": "cd0010264a2cc4567c59311afd6d637f23f2e070be2d4da68f6be0ab97e46ff4",
      "language": "csharp",
      "size": 521,
      "content": "namespace xbytechat.api.Features.CRM.Dtos\n{\n    public class TagDto\n    {\n        public Guid? Id { get; set; }\n\n        public string Name { get; set; } = default!;\n\n        public string? ColorHex { get; set; }\n\n        public string? Category { get; set; }\n\n        public string? Notes { get; set; }\n\n        public bool IsSystemTag { get; set; } = false;\n\n        public bool IsActive { get; set; } = true;\n\n        public DateTime? CreatedAt { get; set; }\n\n        public DateTime? LastUsedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Interfaces/IContactService.cs",
      "sha256": "b7ca4f37c5420dd9e44b8fd2d03c1c0fff462256304cae410fbd5a135aa261b9",
      "language": "csharp",
      "size": 1862,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CRM.Dtos;\nusing xbytechat.api.Features.CRM.Models;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.CRM.Interfaces\n{\n    /// <summary>\n    /// Defines the contract for all operations related to managing contacts.\n    /// </summary>\n    public interface IContactService\n    {\n\n        Task<ResponseResult> AddContactAsync(Guid businessId, ContactDto dto);\n        Task<ContactDto> GetContactByIdAsync(Guid businessId, Guid contactId);\n        Task<bool> UpdateContactAsync(Guid businessId, ContactDto dto);\n        Task<bool> DeleteContactAsync(Guid businessId, Guid contactId);\n        Task<CsvImportResult<ContactDto>> ParseCsvToContactsAsync(Guid businessId, Stream csvStream);\n        Task<Contact> FindOrCreateAsync(Guid businessId, string phoneNumber);\n        Task<bool> ToggleFavoriteAsync(Guid businessId, Guid contactId);\n        Task<bool> ToggleArchiveAsync(Guid businessId, Guid contactId);\n        Task<IEnumerable<ContactDto>> GetAllContactsAsync(Guid businessId, string? tab = \"all\");\n        Task AssignTagToContactsAsync(Guid businessId, List<Guid> contactIds, Guid tagId);\n        Task<PagedResult<ContactDto>> GetPagedContactsAsync(\n             Guid businessId,\n             string? tab = \"all\",\n             int page = 1,\n             int pageSize = 25,\n             string? searchTerm = null\n            );\n        // âœ… Tag-based filtering support\n        Task<IEnumerable<ContactDto>> GetContactsByTagsAsync(Guid businessId, List<Guid> tags);\n\n        Task<BulkImportResultDto> BulkImportAsync(Guid businessId, Stream csvStream);\n        // ðŸ“Œ New method to support flow node â†’ tag assignment\n        Task<bool> AssignTagsAsync(Guid businessId, string phoneNumber, List<string> tags);\n\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Interfaces/IContactTagService.cs",
      "sha256": "779257e42642346dc94fd82a0d7286bc5fc37e9c884338d039f4849cf222d5e2",
      "language": "csharp",
      "size": 195,
      "content": "namespace xbytechat.api.Features.CRM.Interfaces\n{\n    public interface IContactTagService\n    {\n        Task<bool> RemoveTagFromContactAsync(Guid businessId, Guid contactId, Guid tagId);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Interfaces/INoteService.cs",
      "sha256": "3a55224ed1bd77632f1df5c60e2b9e83f76c595578c5cb47c07bd3965bda4360",
      "language": "csharp",
      "size": 705,
      "content": "using xbytechat.api.Features.CRM.Dtos;\n\nnamespace xbytechat.api.Features.CRM.Interfaces\n{\n    public interface INoteService\n    {\n        // For creating new note\n        Task<NoteDto> AddNoteAsync(Guid businessId, NoteDto dto);\n\n        // List all notes for dashboard view\n        Task<IEnumerable<NoteDto>> GetNotesByContactAsync(Guid businessId, Guid contactId);\n\n        // For loading note in edit mode\n        Task<NoteDto?> GetNoteByIdAsync(Guid businessId, Guid noteId);\n        // Handles editing\n        Task<bool> UpdateNoteAsync(Guid businessId, Guid noteId, NoteDto dto);\n        // Soft delete â†’ IsActive = false\n        Task<bool> DeleteNoteAsync(Guid businessId, Guid noteId);\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Interfaces/IReminderService.cs",
      "sha256": "ee0bb73d2c3d212a59012abdf1d71ab3ef240b6f785d25dde255e5c7d30f3e16",
      "language": "csharp",
      "size": 824,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CRM.Dtos;\n\nnamespace xbytechat.api.Features.CRM.Interfaces\n{\n    public interface IReminderService\n    {\n        //For creating new reminder\n        Task<ReminderDto> AddReminderAsync(Guid businessId, ReminderDto dto);\n\n        //List all reminders for dashboard view\n        Task<IEnumerable<ReminderDto>> GetAllRemindersAsync(Guid businessId);\n\n        //For loading reminder in edit mode\n        Task<ReminderDto?> GetReminderByIdAsync(Guid businessId, Guid reminderId);\n\n        //Handles editing\n        Task<bool> UpdateReminderAsync(Guid businessId, Guid reminderId, ReminderDto dto);\n        //Soft delete â†’ IsActive = false\n        Task<bool> DeleteReminderAsync(Guid businessId, Guid reminderId);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Interfaces/ITagService.cs",
      "sha256": "3e9fdf4fa03f5eb4006b2b264f94a12f5fc20b7b8edc17f06e5ebcbe30d5c379",
      "language": "csharp",
      "size": 733,
      "content": "// ðŸ“„ File: xbytechat-api/Features/CRM/Interfaces/ITagService.cs\n\nusing System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CRM.Dtos;\n\nnamespace xbytechat.api.Features.CRM.Interfaces\n{\n    public interface ITagService\n    {\n        Task<TagDto> AddTagAsync(Guid businessId, TagDto dto);\n\n        Task<IEnumerable<TagDto>> GetAllTagsAsync(Guid businessId);\n\n        Task<bool> UpdateTagAsync(Guid businessId, Guid tagId, TagDto dto);\n\n        Task<bool> DeleteTagAsync(Guid businessId, Guid tagId);\n\n        // âœ… Return bool so callers can know if assignment actually happened\n        Task<bool> AssignTagsAsync(Guid businessId, string phoneNumber, List<string> tagNames);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Mappers/NoteMapper.cs",
      "sha256": "3f51d3d0012825818ae828ab208605ea27dce968d81fbe8c5f213714573d1694",
      "language": "csharp",
      "size": 2363,
      "content": "using xbytechat.api.Features.CRM.Dtos;\nusing xbytechat.api.Features.CRM.Models;\n\nnamespace xbytechat.api.Features.CRM.Mappers\n{\n    public static class NoteMapper\n    {\n        public static NoteDto MapToDto(Note note)\n        {\n            return new NoteDto\n            {\n                Id = note.Id,\n                ContactId = note.ContactId,\n                Title = note.Title ?? string.Empty,\n                Content = note.Content ?? string.Empty,\n                Source = note.Source ?? string.Empty,\n                CreatedBy = note.CreatedBy ?? string.Empty,\n                IsPinned = note.IsPinned,\n                IsInternal = note.IsInternal,\n                CreatedAt = note.CreatedAt,\n                EditedAt = note.EditedAt\n            };\n        }\n\n        public static Note MapToEntity(NoteDto dto, Guid businessId)\n        {\n            var content = (dto.Content ?? string.Empty).Trim();\n            var title = NormalizeTitle(dto.Title, content);\n\n            return new Note\n            {\n                Id = Guid.NewGuid(),\n                BusinessId = businessId,\n                ContactId = dto.ContactId,\n\n                // âœ… Title is optional, derived from content if missing\n                Title = title,\n\n                // âœ… Content is the real payload\n                Content = content,\n\n                // âœ… Defaults to keep DB safe even if frontend sends null/empty\n                Source = string.IsNullOrWhiteSpace(dto.Source) ? \"Manual\" : dto.Source.Trim(),\n                CreatedBy = string.IsNullOrWhiteSpace(dto.CreatedBy) ? \"System\" : dto.CreatedBy.Trim(),\n\n                IsPinned = dto.IsPinned,\n                IsInternal = dto.IsInternal,\n\n                CreatedAt = DateTime.SpecifyKind(DateTime.UtcNow, DateTimeKind.Utc),\n                EditedAt = null\n            };\n        }\n\n        private static string NormalizeTitle(string? title, string content)\n        {\n            var t = (title ?? string.Empty).Trim();\n            if (!string.IsNullOrWhiteSpace(t)) return t;\n\n            // derive title from content\n            var c = (content ?? string.Empty).Trim();\n            if (string.IsNullOrWhiteSpace(c)) return \"(Untitled)\"; // service already blocks empty content\n\n            const int max = 60;\n            return c.Length <= max ? c : (c.Substring(0, max) + \"â€¦\");\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Mappers/ReminderMapper.cs",
      "sha256": "ca8d8fdc52f0d1f3cd2c7bc1de28d88ed5193a5407283690f942f1cb9fe0fbeb",
      "language": "csharp",
      "size": 1009,
      "content": "using xbytechat.api.Features.CRM.Dtos;\nusing xbytechat.api.Features.CRM.Models;\n\nnamespace xbytechat.api.Features.CRM.Mappers\n{\n    public static class ReminderMapper\n    {\n        public static ReminderDto MapToDto(Reminder r)\n        {\n            return new ReminderDto\n            {\n                Id = r.Id,\n                ContactId = r.ContactId,\n                Title = r.Title,\n                Description = r.Description,\n                DueAt = r.DueAt,\n                Status = r.Status,\n                ReminderType = r.ReminderType,\n                Priority = r.Priority,\n                IsRecurring = r.IsRecurring,\n                RecurrencePattern = r.RecurrencePattern,\n                SendWhatsappNotification = r.SendWhatsappNotification,\n                LinkedCampaign = r.LinkedCampaign,\n                IsActive = r.IsActive,\n                CreatedAt = r.CreatedAt,\n                UpdatedAt = r.UpdatedAt,\n                CompletedAt = r.CompletedAt\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Models/Contact.cs",
      "sha256": "c937e665a05520a22229847b576b0db8d3668b905487f3e28f1adfc1e27c3649",
      "language": "csharp",
      "size": 3559,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.ComponentModel.DataAnnotations;\nusing xbytechat.api.Features.BusinessModule.Models;\n\nnamespace xbytechat.api.Features.CRM.Models\n{\n    public enum ContactOptStatus\n    {\n        Unspecified = 0,\n        OptedIn = 1,\n        OptedOut = 2\n    }\n\n    public enum ContactChannelStatus\n    {\n        Valid = 0,\n        BlockedByUser = 1,\n        InvalidNumber = 2\n    }\n\n    public class Contact\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        [Required]\n        public Guid BusinessId { get; set; }\n        public Business Business { get; set; } = null!;\n        // ðŸ”— FK to Business\n        [Required]\n        [MaxLength(100)]\n        public string Name { get; set; } = null!;\n\n        [Required]\n        [MaxLength(20)]\n        public string PhoneNumber { get; set; } = null!;\n\n        [MaxLength(100)]\n        public string? Email { get; set; }\n\n        [MaxLength(50)]\n        public string? LeadSource { get; set; }\n\n        [MaxLength(200)]\n        public string? Tags { get; set; } // Legacy, will be deprecated after ContactTag rollout\n\n        public DateTime? LastContactedAt { get; set; }\n        public DateTime? NextFollowUpAt { get; set; }\n\n        [MaxLength(500)]\n        public string? Notes { get; set; }\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n        // ðŸ§© NEW: Link to Tags\n        public ICollection<ContactTag> ContactTags { get; set; } = new List<ContactTag>();\n        // âœ… New: Navigation property for many-to-many tags\n        //public ICollection<ContactTag> TagsLink { get; set; } = new List<ContactTag>();\n\n        public DateTime? LastCTAInteraction { get; set; }\n        public string? LastCTAType { get; set; }\n        public Guid? LastClickedProductId { get; set; }\n\n        // ðŸš¦ If true, skip automation flows (manually or programmatically paused)\n        public bool IsAutomationPaused { get; set; } = false;\n\n        // ðŸ‘¤ If agent assigned, automation should pause (runtime check)\n        public Guid? AssignedAgentId { get; set; }\n\n        // --- Chat Inbox fields ---\n        [MaxLength(20)]\n        public string InboxStatus { get; set; } = \"Open\"; // Open / Pending / Closed\n\n        public DateTime? LastInboundAt { get; set; }   // UTC\n        public DateTime? LastOutboundAt { get; set; }  // UTC\n\n        // Hard consent state used to gate outbound sends.\n        public ContactOptStatus OptStatus { get; set; } = ContactOptStatus.Unspecified;\n\n        // Channel delivery health state for this contact number.\n        public ContactChannelStatus ChannelStatus { get; set; } = ContactChannelStatus.Valid;\n\n        // UTC timestamp for the last change to OptStatus.\n        public DateTime? OptStatusUpdatedAt { get; set; }\n\n        // UTC timestamp for the last change to ChannelStatus.\n        public DateTime? ChannelStatusUpdatedAt { get; set; }\n\n        // Human-readable reason when contact is opted out.\n        public string? OptOutReason { get; set; }\n\n        public bool IsFavorite { get; set; } = false;\n        public bool IsArchived { get; set; } = false;\n        public string? Group { get; set; }\n        public bool IsActive { get; set; } = true;\n\n\n        //public bool IsTemporary { get; set; } = false;\n        //public Guid? SourceCampaignId { get; set; }\n        //public DateTime? ExpiresAt { get; set; }\n\n        public string? ProfileName { get; set; }            // latest WA profile.name we saw inbound\n        public DateTime? ProfileNameUpdatedAt { get; set; }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Models/ContactTag.cs",
      "sha256": "de88c1bdb0a34e2703e0bb2d9c83c80f2d4af9f2c008e11782fa4949ae0dc782",
      "language": "csharp",
      "size": 510,
      "content": "using System.ComponentModel.DataAnnotations;\nusing xbytechat.api.Features.CRM.Models;\n\npublic class ContactTag\n{\n    [Key]\n    public Guid Id { get; set; }\n\n    [Required]\n    public Guid ContactId { get; set; }\n\n    public Contact Contact { get; set; }\n\n    [Required]\n    public Guid TagId { get; set; }\n\n    public Tag Tag { get; set; }\n\n    [Required]\n    public Guid BusinessId { get; set; }\n\n    public DateTime AssignedAt { get; set; } = DateTime.UtcNow;\n\n    public string? AssignedBy { get; set; }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Models/Note.cs",
      "sha256": "00b6b2dacb3efff3e8043beb4d763a5e8196378a60d699f59f0253b718c6d65d",
      "language": "csharp",
      "size": 923,
      "content": "namespace xbytechat.api.Features.CRM.Models\n{\n    public class Note\n    {\n        public Guid Id { get; set; }\n\n        // ðŸ”— Ownership & Association\n        public Guid? BusinessId { get; set; }\n        public Guid? ContactId { get; set; }\n\n        // ðŸ“ Core Content\n        public string Title { get; set; } // Optional short title (for pinning or preview)\n        public string Content { get; set; }\n\n        // ðŸ”– Contextual Intelligence\n        public string Source { get; set; } // e.g., \"Manual\", \"Call Log\", \"WhatsApp\", \"LeadForm\"\n        public string CreatedBy { get; set; } // Store agent/user name or userId\n\n        // ðŸ“Œ UX Flags\n        public bool IsPinned { get; set; } = false;\n        public bool IsInternal { get; set; } = false; // if true, only visible to team\n\n        // ðŸ•“ Timestamps\n        public DateTime CreatedAt { get; set; }\n        public DateTime? EditedAt { get; set; }\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/CRM/Models/Reminder.cs",
      "sha256": "fc98f9aad251b376a21b81c2984660a17369d962f22e44a6fdc4b404508542c1",
      "language": "csharp",
      "size": 1728,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CRM.Models\n{\n    public class Reminder\n    {\n        public Guid Id { get; set; }\n\n        public Guid BusinessId { get; set; }   // For multi-tenant isolation\n\n        public Guid ContactId { get; set; }    // Which contact this reminder is for\n\n        public string Title { get; set; } = default!; // Main reminder title (e.g., \"Call back about invoice\")\n\n        public string? Description { get; set; } // Longer notes, optional (for internal detail)\n\n        public DateTime DueAt { get; set; }    // When reminder should notify\n\n        public string Status { get; set; } = \"Pending\"; // \"Pending\", \"Done\", \"Overdue\"\n\n        public string? ReminderType { get; set; } // e.g., \"Call\", \"Email\", \"Follow-up\", \"Meeting\"\n\n        public int? Priority { get; set; } // e.g., 1 (High), 2 (Medium), 3 (Low)\n\n        public bool IsRecurring { get; set; } = false; // For future â†’ repeat reminder\n\n        public string? RecurrencePattern { get; set; } // e.g., \"Weekly\", \"Monthly\" (optional)\n\n        public bool SendWhatsappNotification { get; set; } = false; // Future: auto-WA message trigger\n\n        public string? LinkedCampaign { get; set; } // Optional: which campaign this reminder relates to\n\n        public bool IsActive { get; set; } = true;  // Soft delete support\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n        public DateTime? UpdatedAt { get; set; }\n\n        public DateTime? CompletedAt { get; set; } // Track when it was marked Done\n\n        public string? LastCTAType { get; set; } // e.g., Confirm, Reschedule\n        public DateTime? LastClickedAt { get; set; }\n        public bool FollowUpSent { get; set; } = false;\n\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Models/Tag.cs",
      "sha256": "387b3c7cd221661c2ced818b097b3a5cc250067db94531b997e4ed61f1e43e35",
      "language": "csharp",
      "size": 1117,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.CRM.Models\n{\n    public class Tag\n    {\n        public Guid Id { get; set; }\n\n        public Guid BusinessId { get; set; }             // Multi-tenant isolation\n\n        public string Name { get; set; } = default!;     // e.g., \"VIP\", \"Follow-up\"\n\n        public string? ColorHex { get; set; }            // For UI tag styling (e.g., #FF5733)\n\n        public string? Category { get; set; }            // e.g., \"Priority\", \"Campaign\", \"Stage\"\n\n        public string? Notes { get; set; }               // Admin/internal notes about this tag\n\n        public bool IsSystemTag { get; set; } = false;   // Reserved tags like \"New\", \"Subscribed\"\n\n        public bool IsActive { get; set; } = true;       // For soft-deactivation (future bulk ops)\n\n        public DateTime CreatedAt { get; set; }          // For analytics / sorting\n\n        public DateTime? LastUsedAt { get; set; }        // Useful for CRM insights later\n\n        public ICollection<ContactTag> ContactTags { get; set; } = new List<ContactTag>(); // Linked contacts\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Services/ContactProfileService.cs",
      "sha256": "a4dbe66bed0c345a7d9bca4860023d2ad35be6a378b62ba5affb4f28ee1493b5",
      "language": "csharp",
      "size": 3367,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Features.CRM.Models;\n\nnamespace xbytechat.api.Features.CRM.Services\n{\n    public sealed class ContactProfileService : IContactProfileService\n    {\n        private readonly AppDbContext _db;\n\n        public ContactProfileService(AppDbContext db) => _db = db;\n\n        public async Task UpsertProfileNameAsync(\n            Guid businessId,\n            string phoneE164,\n            string? profileName,\n            CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty || string.IsNullOrWhiteSpace(phoneE164) || string.IsNullOrWhiteSpace(profileName))\n                return;\n\n            var phoneDigits = PhoneNumberNormalizer.NormalizeToE164Digits(phoneE164, \"IN\");\n            if (string.IsNullOrWhiteSpace(phoneDigits))\n                return;\n\n            var newName = profileName.Trim();\n            var now = DateTime.UtcNow;\n\n            // Canonical lookup: digits-only E.164 (no '+')\n            var contact = await _db.Contacts.FirstOrDefaultAsync(\n                c => c.BusinessId == businessId &&\n                     c.PhoneNumber == phoneDigits,\n                ct);\n\n            if (contact == null)\n            {\n                // Concurrency-safe create\n                try\n                {\n                    _db.Contacts.Add(new Contact\n                    {\n                        Id = Guid.NewGuid(),\n                        BusinessId = businessId,\n                        PhoneNumber = phoneDigits,          // canonical = digits-only\n                        Name = newName,                     // display fallback\n                        ProfileName = newName,              // WA profile name\n                        ProfileNameUpdatedAt = now,\n                        CreatedAt = now,\n                        LastContactedAt = now\n                    });\n                    await _db.SaveChangesAsync(ct);\n                    return;\n                }\n                catch (DbUpdateException)\n                {\n                    // Someone else created it â€” refetch and continue as update\n                    contact = await _db.Contacts.FirstOrDefaultAsync(\n                        c => c.BusinessId == businessId && c.PhoneNumber == phoneDigits, ct);\n                    if (contact == null) return;\n                }\n            }\n\n            var anyChange = false;\n\n            if (!string.Equals(contact.ProfileName, newName, StringComparison.Ordinal))\n            {\n                contact.ProfileName = newName;\n                contact.ProfileNameUpdatedAt = now;\n                anyChange = true;\n            }\n\n            // Backfill Name if empty/placeholder/phone\n            if (string.IsNullOrWhiteSpace(contact.Name) ||\n                contact.Name == \"WhatsApp User\" ||\n                contact.Name == contact.PhoneNumber)\n            {\n                if (!string.Equals(contact.Name, newName, StringComparison.Ordinal))\n                {\n                    contact.Name = newName;\n                    anyChange = true;\n                }\n            }\n\n            if (anyChange)\n            {\n                contact.ProfileNameUpdatedAt = now;\n                await _db.SaveChangesAsync(ct);\n            }\n        }\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Services/ContactService.cs",
      "sha256": "b0dfcf05efc0ced296125b4695cc30a6e4bb9e6c559f4f4f3c52f933a33ed598",
      "language": "csharp",
      "size": 31340,
      "content": "// ðŸ“„ File: xbytechat-api/Features/CRM/Services/ContactService.cs\n\nusing System.ComponentModel.DataAnnotations;\nusing System.Globalization;\nusing CsvHelper;\nusing CsvHelper.Configuration;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.CRM.Dtos;\nusing xbytechat.api.Features.CRM.Interfaces;\nusing xbytechat.api.Features.CRM.Models;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.CRM.Services\n{\n    public class ContactService : IContactService\n    {\n        private readonly AppDbContext _db;\n        private readonly ILogger<ContactService> _logger;\n\n        public ContactService(AppDbContext db, ILogger<ContactService> logger)\n        {\n            _db = db;\n            _logger = logger;\n        }\n\n        public async Task<ResponseResult> AddContactAsync(Guid businessId, ContactDto dto)\n        {\n            _logger.LogInformation(\"ðŸ“© AddContactAsync called for businessId={BusinessId}, Name={Name}\", businessId, dto.Name);\n\n            try\n            {\n                var normalizedPhone = NormalizePhone(dto.PhoneNumber);\n\n                if (string.IsNullOrWhiteSpace(normalizedPhone))\n                    return ResponseResult.ErrorInfo(\"âŒ Phone number is invalid. Please enter a valid number.\");\n\n                var existingContact = await FindContactByPhoneAsync(businessId, normalizedPhone);\n\n                if (existingContact != null)\n                {\n                    _logger.LogWarning(\"âš ï¸ Duplicate contact attempt for phone {Phone}\", dto.PhoneNumber);\n                    return ResponseResult.ErrorInfo($\"âŒ A contact with the phone number '{dto.PhoneNumber}' already exists.\");\n                }\n\n                var contact = new Contact\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    Name = dto.Name,\n                    PhoneNumber = normalizedPhone, // âœ… canonical digits-only\n                    Email = dto.Email,\n                    LeadSource = dto.LeadSource,\n                    LastContactedAt = dto.LastContactedAt?.ToUniversalTime(),\n                    NextFollowUpAt = dto.NextFollowUpAt?.ToUniversalTime(),\n                    Notes = dto.Notes,\n                    CreatedAt = DateTime.UtcNow,\n                    IsFavorite = dto.IsFavorite,\n                    IsArchived = dto.IsArchived,\n                    Group = dto.Group\n                };\n\n                if (dto.Tags != null && dto.Tags.Any())\n                {\n                    contact.ContactTags = dto.Tags.Select(t => new ContactTag\n                    {\n                        Id = Guid.NewGuid(),\n                        ContactId = contact.Id,\n                        TagId = t.TagId,\n                        BusinessId = businessId,\n                        AssignedAt = DateTime.UtcNow,\n                        AssignedBy = \"system\"\n                    }).ToList();\n                }\n\n                _db.Contacts.Add(contact);\n                await _db.SaveChangesAsync();\n\n                _logger.LogInformation(\"âœ… Contact added successfully: {ContactId}\", contact.Id);\n\n                var resultDto = new ContactDto\n                {\n                    Id = contact.Id,\n                    Name = contact.Name,\n                    PhoneNumber = contact.PhoneNumber,\n                    Email = contact.Email,\n                    LeadSource = contact.LeadSource,\n                    CreatedAt = contact.CreatedAt,\n                    Tags = contact.ContactTags?.Select(ct => new ContactTagDto { TagId = ct.TagId }).ToList() ?? new List<ContactTagDto>()\n                };\n\n                return ResponseResult.SuccessInfo(\"âœ… Contact created successfully.\", resultDto);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"ðŸš¨ Unexpected error in AddContactAsync for business {BusinessId}\", businessId);\n                return ResponseResult.ErrorInfo(\"ðŸš¨ A server error occurred while creating the contact.\", ex.Message);\n            }\n        }\n\n        public async Task<ContactDto> GetContactByIdAsync(Guid businessId, Guid contactId)\n        {\n            _logger.LogInformation(\"GetContactByIdAsync: businessId={BusinessId}, contactId={ContactId}\", businessId, contactId);\n\n            var contact = await _db.Contacts\n                .Where(c => c.BusinessId == businessId && c.Id == contactId && c.IsActive)\n                .Include(c => c.ContactTags)\n                    .ThenInclude(ct => ct.Tag)\n                .FirstOrDefaultAsync();\n\n            if (contact == null)\n                return null;\n\n            return new ContactDto\n            {\n                Id = contact.Id,\n                Name = contact.Name,\n                PhoneNumber = contact.PhoneNumber,\n                Email = contact.Email,\n                LeadSource = contact.LeadSource,\n                LastContactedAt = contact.LastContactedAt,\n                NextFollowUpAt = contact.NextFollowUpAt,\n                Notes = contact.Notes,\n                CreatedAt = contact.CreatedAt,\n                Tags = contact.ContactTags?\n                    .Where(ct => ct.Tag != null)\n                    .Select(ct => new ContactTagDto\n                    {\n                        TagId = ct.TagId,\n                        TagName = ct.Tag.Name\n                    })\n                    .ToList() ?? new List<ContactTagDto>()\n            };\n        }\n\n        public async Task<bool> UpdateContactAsync(Guid businessId, ContactDto dto)\n        {\n            _logger.LogInformation(\"UpdateContactAsync: businessId={BusinessId}, contactId={ContactId}\", businessId, dto.Id);\n\n            var contact = await _db.Contacts\n                .Include(c => c.ContactTags)\n                .FirstOrDefaultAsync(c => c.BusinessId == businessId && c.Id == dto.Id);\n\n            if (contact == null)\n                return false;\n\n            contact.Name = dto.Name;\n\n            var normalizedPhone = NormalizePhone(dto.PhoneNumber);\n            if (string.IsNullOrWhiteSpace(normalizedPhone))\n                throw new ArgumentException(\"Invalid phone number. Use E.164 digits-only (country code + number).\");\n\n            var lookupCandidates = BuildPhoneLookupCandidates(normalizedPhone);\n            var phoneExists = lookupCandidates.Count > 0 && await _db.Contacts.AnyAsync(c =>\n                c.BusinessId == businessId &&\n                c.Id != dto.Id &&\n                lookupCandidates.Contains(c.PhoneNumber));\n\n            if (phoneExists)\n                throw new ArgumentException(\"A contact with this phone number already exists.\");\n\n            contact.PhoneNumber = normalizedPhone;\n            contact.Email = dto.Email;\n            contact.LeadSource = dto.LeadSource;\n            contact.LastContactedAt = dto.LastContactedAt?.ToUniversalTime();\n            contact.NextFollowUpAt = dto.NextFollowUpAt?.ToUniversalTime();\n            contact.Notes = dto.Notes;\n\n            await _db.SaveChangesAsync();\n            return true;\n        }\n\n        public async Task<bool> DeleteContactAsync(Guid businessId, Guid contactId)\n        {\n            var contact = await _db.Contacts\n                .FirstOrDefaultAsync(c => c.BusinessId == businessId && c.Id == contactId && c.IsActive);\n\n            if (contact == null)\n                return false;\n\n            contact.IsActive = false;\n            await _db.SaveChangesAsync();\n            return true;\n        }\n\n        public async Task<CsvImportResult<ContactDto>> ParseCsvToContactsAsync(Guid businessId, Stream csvStream)\n        {\n            _logger.LogInformation(\"ParseCsvToContactsAsync: businessId={BusinessId}\", businessId);\n\n            var result = new CsvImportResult<ContactDto>();\n\n            var config = new CsvConfiguration(CultureInfo.InvariantCulture)\n            {\n                HeaderValidated = null,\n                MissingFieldFound = null,\n                BadDataFound = null,\n                PrepareHeaderForMatch = args =>\n                    (args.Header ?? string.Empty)\n                        .Trim()\n                        .Replace(\" \", \"\")\n                        .Replace(\"_\", \"\")\n                        .ToLowerInvariant()\n            };\n\n            using var reader = new StreamReader(csvStream);\n            using var csv = new CsvReader(reader, config);\n\n            csv.Context.RegisterClassMap<ContactDtoCsvMap>();\n\n            int rowNumber = 1;\n\n            await csv.ReadAsync();\n            csv.ReadHeader();\n\n            while (await csv.ReadAsync())\n            {\n                rowNumber++;\n                try\n                {\n                    var record = csv.GetRecord<ContactDto>();\n\n                    // âœ… Normalize phone even during parse (so user sees what will be saved)\n                    var normalized = NormalizePhone(record.PhoneNumber);\n                    if (string.IsNullOrWhiteSpace(normalized))\n                    {\n                        result.Errors.Add(new CsvImportError\n                        {\n                            RowNumber = rowNumber,\n                            ErrorMessage = \"Invalid phone number (could not normalize to E.164 digits-only).\"\n                        });\n                        continue;\n                    }\n\n                    record.PhoneNumber = normalized;\n                    record.CreatedAt = DateTime.UtcNow;\n\n                    result.SuccessRecords.Add(record);\n                }\n                catch (Exception ex)\n                {\n                    result.Errors.Add(new CsvImportError\n                    {\n                        RowNumber = rowNumber,\n                        ErrorMessage = ex.Message\n                    });\n                }\n            }\n\n            return result;\n        }\n\n        private static string NormalizePhone(string phoneNumber)\n        {\n            var raw = (phoneNumber ?? string.Empty).Trim();\n            if (string.IsNullOrWhiteSpace(raw))\n                return string.Empty;\n\n            // First pass: normal parser behavior (local + international supported).\n            var normalized = PhoneNumberNormalizer.NormalizeToE164Digits(raw, \"IN\");\n            if (!string.IsNullOrWhiteSpace(normalized))\n                return normalized;\n\n            // Second pass: webhook and provider payloads often send E.164 digits without '+'.\n            var digits = new string(raw.Where(char.IsDigit).ToArray());\n            if (string.IsNullOrWhiteSpace(digits))\n                return string.Empty;\n\n            normalized = PhoneNumberNormalizer.NormalizeToE164Digits(\"+\" + digits, \"IN\");\n            if (!string.IsNullOrWhiteSpace(normalized))\n                return normalized;\n\n            // Do not store ambiguous values; force parseable canonical format.\n            return string.Empty;\n        }\n\n        private static List<string> BuildPhoneLookupCandidates(string phoneNumber)\n        {\n            var raw = (phoneNumber ?? string.Empty).Trim();\n            var candidates = new HashSet<string>(StringComparer.Ordinal);\n            var normalized = NormalizePhone(raw);\n            var digitsOnly = new string(raw.Where(char.IsDigit).ToArray());\n\n            if (!string.IsNullOrWhiteSpace(normalized))\n            {\n                candidates.Add(normalized);\n                candidates.Add(\"+\" + normalized);\n\n                // Legacy IN rows may have been stored as 10-digit local numbers.\n                if (normalized.Length == 12 && normalized.StartsWith(\"91\", StringComparison.Ordinal))\n                    candidates.Add(normalized.Substring(2));\n            }\n\n            if (!string.IsNullOrWhiteSpace(digitsOnly))\n            {\n                candidates.Add(digitsOnly);\n                candidates.Add(\"+\" + digitsOnly);\n\n                if (digitsOnly.Length == 10)\n                {\n                    candidates.Add(\"91\" + digitsOnly);\n                    candidates.Add(\"+91\" + digitsOnly);\n                }\n                else if (digitsOnly.Length == 12 && digitsOnly.StartsWith(\"91\", StringComparison.Ordinal))\n                {\n                    candidates.Add(digitsOnly.Substring(2));\n                }\n            }\n\n            if (!string.IsNullOrWhiteSpace(raw))\n                candidates.Add(raw);\n\n            return candidates.Where(x => !string.IsNullOrWhiteSpace(x)).ToList();\n        }\n\n        private async Task<Contact?> FindContactByPhoneAsync(Guid businessId, string phoneNumber)\n        {\n            var lookupCandidates = BuildPhoneLookupCandidates(phoneNumber);\n            if (lookupCandidates.Count == 0)\n                return null;\n\n            return await _db.Contacts\n                .Where(c => c.BusinessId == businessId && lookupCandidates.Contains(c.PhoneNumber))\n                .OrderByDescending(c => c.IsActive)\n                .ThenByDescending(c => c.CreatedAt)\n                .FirstOrDefaultAsync();\n        }\n\n        public async Task<Contact> FindOrCreateAsync(Guid businessId, string phoneNumber)\n        {\n            var normalized = NormalizePhone(phoneNumber);\n            if (string.IsNullOrWhiteSpace(normalized))\n                throw new ArgumentException(\"Invalid phone number format.\", nameof(phoneNumber));\n\n            var contact = await FindContactByPhoneAsync(businessId, normalized);\n\n            if (contact != null)\n            {\n                // Opportunistically backfill legacy rows to canonical digits-only storage.\n                if (!string.Equals(contact.PhoneNumber, normalized, StringComparison.Ordinal))\n                {\n                    var canonicalAlreadyExists = await _db.Contacts.AnyAsync(c =>\n                        c.BusinessId == businessId &&\n                        c.Id != contact.Id &&\n                        c.PhoneNumber == normalized);\n\n                    if (!canonicalAlreadyExists)\n                    {\n                        contact.PhoneNumber = normalized;\n                        await _db.SaveChangesAsync();\n                    }\n                }\n\n                return contact;\n            }\n\n            var newContact = new Contact\n            {\n                Id = Guid.NewGuid(),\n                BusinessId = businessId,\n                Name = \"WhatsApp User\",\n                PhoneNumber = normalized,\n                CreatedAt = DateTime.UtcNow\n            };\n\n            _db.Contacts.Add(newContact);\n            await _db.SaveChangesAsync();\n            return newContact;\n        }\n\n        public async Task<bool> ToggleFavoriteAsync(Guid businessId, Guid contactId)\n        {\n            var contact = await _db.Contacts.FirstOrDefaultAsync(c => c.BusinessId == businessId && c.Id == contactId);\n            if (contact == null) return false;\n\n            contact.IsFavorite = !contact.IsFavorite;\n            await _db.SaveChangesAsync();\n            return true;\n        }\n\n        public async Task AssignTagToContactsAsync(Guid businessId, List<Guid> contactIds, Guid tagId)\n        {\n            var contacts = await _db.Contacts\n                .Where(c => c.BusinessId == businessId && contactIds.Contains(c.Id))\n                .Include(c => c.ContactTags)\n                .ToListAsync();\n\n            foreach (var contact in contacts)\n            {\n                bool alreadyAssigned = contact.ContactTags.Any(link => link.TagId == tagId);\n                if (!alreadyAssigned)\n                {\n                    contact.ContactTags.Add(new ContactTag\n                    {\n                        ContactId = contact.Id,\n                        TagId = tagId\n                    });\n                }\n            }\n\n            await _db.SaveChangesAsync();\n        }\n\n        public async Task<bool> ToggleArchiveAsync(Guid businessId, Guid contactId)\n        {\n            var contact = await _db.Contacts.FirstOrDefaultAsync(c => c.BusinessId == businessId && c.Id == contactId);\n            if (contact == null) return false;\n\n            contact.IsArchived = !contact.IsArchived;\n            await _db.SaveChangesAsync();\n            return true;\n        }\n\n        public async Task<IEnumerable<ContactDto>> GetAllContactsAsync(Guid businessId, string? tab = \"all\")\n        {\n            var baseQuery = _db.Contacts\n                .Where(c => c.BusinessId == businessId && c.IsActive);\n\n            if (tab == \"favourites\")\n                baseQuery = baseQuery.Where(c => c.IsFavorite);\n            else if (tab == \"archived\")\n                baseQuery = baseQuery.Where(c => c.IsArchived);\n            else if (tab == \"groups\")\n                baseQuery = baseQuery.Where(c => !string.IsNullOrEmpty(c.Group));\n\n            var contacts = await baseQuery\n                .Include(c => c.ContactTags)\n                    .ThenInclude(ct => ct.Tag)\n                .ToListAsync();\n\n            return contacts.Select(c => new ContactDto\n            {\n                Id = c.Id,\n                Name = c.Name,\n                PhoneNumber = c.PhoneNumber,\n                Email = c.Email,\n                LeadSource = c.LeadSource,\n                LastContactedAt = c.LastContactedAt,\n                NextFollowUpAt = c.NextFollowUpAt,\n                Notes = c.Notes,\n                CreatedAt = c.CreatedAt,\n                IsFavorite = c.IsFavorite,\n                IsArchived = c.IsArchived,\n                Group = c.Group,\n                Tags = c.ContactTags?\n                    .Where(ct => ct.Tag != null)\n                    .Select(ct => new ContactTagDto\n                    {\n                        TagId = ct.TagId,\n                        TagName = ct.Tag.Name,\n                        ColorHex = ct.Tag.ColorHex,\n                        Category = ct.Tag.Category\n                    })\n                    .ToList() ?? new List<ContactTagDto>()\n            });\n        }\n\n        public async Task<PagedResult<ContactDto>> GetPagedContactsAsync(Guid businessId, string? tab, int page, int pageSize, string? searchTerm)\n        {\n            if (page < 1) page = 1;\n            if (pageSize < 1) pageSize = 25;\n            if (pageSize > 100) pageSize = 100;\n\n            var baseQuery = _db.Contacts\n                .Where(c => c.BusinessId == businessId && c.IsActive);\n\n            if (string.IsNullOrWhiteSpace(tab) || tab == \"all\")\n                baseQuery = baseQuery.Where(c => !c.IsArchived);\n\n            if (tab == \"favourites\")\n                baseQuery = baseQuery.Where(c => c.IsFavorite);\n            else if (tab == \"archived\")\n                baseQuery = baseQuery.Where(c => c.IsArchived);\n            else if (tab == \"groups\")\n                baseQuery = baseQuery.Where(c => !string.IsNullOrEmpty(c.Group));\n\n            if (!string.IsNullOrWhiteSpace(searchTerm))\n            {\n                var term = searchTerm.Trim();\n                baseQuery = baseQuery.Where(c =>\n                    (c.Name != null && EF.Functions.Like(c.Name, $\"%{term}%\")) ||\n                    (c.PhoneNumber != null && EF.Functions.Like(c.PhoneNumber, $\"%{term}%\")) ||\n                    (c.Email != null && EF.Functions.Like(c.Email, $\"%{term}%\"))\n                );\n            }\n\n            var totalCount = await baseQuery.CountAsync();\n\n            var contacts = await baseQuery\n                .Include(c => c.ContactTags)\n                    .ThenInclude(ct => ct.Tag)\n                .OrderBy(c => c.Name)\n                .Skip((page - 1) * pageSize)\n                .Take(pageSize)\n                .ToListAsync();\n\n            var items = contacts.Select(c => new ContactDto\n            {\n                Id = c.Id,\n                Name = c.Name,\n                PhoneNumber = c.PhoneNumber,\n                Email = c.Email,\n                LeadSource = c.LeadSource,\n                LastContactedAt = c.LastContactedAt,\n                NextFollowUpAt = c.NextFollowUpAt,\n                Notes = c.Notes,\n                CreatedAt = c.CreatedAt,\n                IsFavorite = c.IsFavorite,\n                IsArchived = c.IsArchived,\n                Group = c.Group,\n                Tags = c.ContactTags?\n                    .Where(ct => ct.Tag != null)\n                    .Select(ct => new ContactTagDto\n                    {\n                        TagId = ct.TagId,\n                        TagName = ct.Tag.Name,\n                        ColorHex = ct.Tag.ColorHex,\n                        Category = ct.Tag.Category\n                    })\n                    .ToList() ?? new List<ContactTagDto>()\n            }).ToList();\n\n            return new PagedResult<ContactDto>\n            {\n                Items = items,\n                TotalCount = totalCount,\n                Page = page,\n                PageSize = pageSize\n            };\n        }\n\n        public async Task<IEnumerable<ContactDto>> GetContactsByTagsAsync(Guid businessId, List<Guid> tagIds)\n        {\n            var baseQuery = _db.Contacts\n                .Where(c => c.BusinessId == businessId && !c.IsArchived);\n\n            if (tagIds?.Any() == true)\n            {\n                baseQuery = baseQuery.Where(c => c.ContactTags.Any(ct => tagIds.Contains(ct.TagId)));\n            }\n\n            var contacts = await baseQuery\n                .Include(c => c.ContactTags)\n                    .ThenInclude(ct => ct.Tag)\n                .ToListAsync();\n\n            return contacts.Select(c => new ContactDto\n            {\n                Id = c.Id,\n                Name = c.Name,\n                PhoneNumber = c.PhoneNumber,\n                Tags = c.ContactTags.Select(ct => new ContactTagDto\n                {\n                    TagId = ct.Tag.Id,\n                    TagName = ct.Tag.Name,\n                    ColorHex = ct.Tag.ColorHex,\n                    Category = ct.Tag.Category\n                }).ToList()\n            });\n        }\n\n        public async Task<bool> AssignTagsAsync(Guid businessId, string phoneNumber, List<string> tags)\n        {\n            var normalizedPhone = NormalizePhone(phoneNumber);\n            if (string.IsNullOrWhiteSpace(normalizedPhone)) return false;\n            phoneNumber = normalizedPhone;\n\n            if (tags == null || tags.Count == 0)\n                return false;\n\n            var lookupCandidates = BuildPhoneLookupCandidates(normalizedPhone);\n            if (lookupCandidates.Count == 0)\n                return false;\n\n            var contact = await _db.Contacts\n                .FirstOrDefaultAsync(c =>\n                    c.BusinessId == businessId &&\n                    !c.IsArchived &&\n                    lookupCandidates.Contains(c.PhoneNumber));\n\n            if (contact == null)\n                return false;\n\n            foreach (var tagName in tags)\n            {\n                if (string.IsNullOrWhiteSpace(tagName))\n                    continue;\n\n                var cleanName = tagName.Trim();\n\n                var tag = await _db.Tags\n                    .FirstOrDefaultAsync(t => t.BusinessId == businessId && t.Name == cleanName && t.IsActive);\n\n                if (tag == null)\n                {\n                    tag = new Tag\n                    {\n                        Id = Guid.NewGuid(),\n                        BusinessId = businessId,\n                        Name = cleanName,\n                        ColorHex = \"#8c8c8c\",\n                        IsActive = true,\n                        CreatedAt = DateTime.UtcNow\n                    };\n                    _db.Tags.Add(tag);\n                }\n\n                var alreadyTagged = await _db.ContactTags.AnyAsync(ct =>\n                    ct.ContactId == contact.Id && ct.TagId == tag.Id);\n\n                if (!alreadyTagged)\n                {\n                    _db.ContactTags.Add(new ContactTag\n                    {\n                        Id = Guid.NewGuid(),\n                        ContactId = contact.Id,\n                        TagId = tag.Id\n                    });\n                }\n            }\n\n            await _db.SaveChangesAsync();\n            return true;\n        }\n\n\n\n        public async Task<BulkImportResultDto> BulkImportAsync(Guid businessId, Stream csvStream)\n        {\n            _logger.LogInformation(\"Bulk import started for businessId={BusinessId}\", businessId);\n\n            var result = new BulkImportResultDto();\n\n            var config = new CsvConfiguration(System.Globalization.CultureInfo.InvariantCulture)\n            {\n                HeaderValidated = null,\n                MissingFieldFound = null,\n                BadDataFound = null,\n                PrepareHeaderForMatch = args =>\n                    (args.Header ?? string.Empty)\n                        .Trim()\n                        .Replace(\" \", \"\")\n                        .Replace(\"_\", \"\")\n                        .ToLowerInvariant()\n            };\n\n            using var reader = new StreamReader(csvStream);\n            using var csv = new CsvReader(reader, config);\n\n            csv.Context.RegisterClassMap<ContactDtoCsvMap>();\n\n            await csv.ReadAsync();\n            csv.ReadHeader();\n\n            // Collect rows first so we can query DB only for relevant phones\n            var parsedRows = new List<(int Row, string Phone, string Name, string? Email, string? LeadSource, string? Notes)>();\n            var seenInFile = new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n\n            int row = 1;\n\n            while (await csv.ReadAsync())\n            {\n                row++;\n                try\n                {\n                    var dto = csv.GetRecord<ContactDto>();\n\n                    var name = (dto.Name ?? string.Empty).Trim();\n                    if (string.IsNullOrWhiteSpace(name))\n                    {\n                        result.Errors.Add(new CsvImportError { RowNumber = row, ErrorMessage = \"Name is required.\" });\n                        continue;\n                    }\n\n                    // Canonical normalize: digits-only E.164 (no '+')\n                    var normalizedPhone = PhoneNumberNormalizer.NormalizeToE164Digits(dto.PhoneNumber, \"IN\");\n                    if (string.IsNullOrWhiteSpace(normalizedPhone))\n                    {\n                        result.Errors.Add(new CsvImportError { RowNumber = row, ErrorMessage = $\"Invalid phone number: '{dto.PhoneNumber}'\" });\n                        continue;\n                    }\n\n                    // Dedupe within the CSV\n                    if (!seenInFile.Add(normalizedPhone))\n                    {\n                        result.DuplicatesInFile++;\n                        continue;\n                    }\n\n                    var email = string.IsNullOrWhiteSpace(dto.Email) ? null : dto.Email.Trim();\n                    if (!string.IsNullOrWhiteSpace(email) && !IsValidEmail(email))\n                    {\n                        result.Errors.Add(new CsvImportError { RowNumber = row, ErrorMessage = $\"Invalid email: '{dto.Email}'\" });\n                        continue;\n                    }\n\n                    parsedRows.Add((\n                        Row: row,\n                        Phone: normalizedPhone,\n                        Name: name,\n                        Email: email,\n                        LeadSource: string.IsNullOrWhiteSpace(dto.LeadSource) ? null : dto.LeadSource.Trim(),\n                        Notes: string.IsNullOrWhiteSpace(dto.Notes) ? null : dto.Notes.Trim()\n                    ));\n                }\n                catch (Exception ex)\n                {\n                    _logger.LogWarning(ex, \"CSV parsing error at row {Row}\", row);\n                    result.Errors.Add(new CsvImportError { RowNumber = row, ErrorMessage = $\"Parse error: {ex.Message}\" });\n                }\n            }\n\n            if (parsedRows.Count == 0)\n            {\n                _logger.LogInformation(\"Bulk import done. businessId={BusinessId}, nothing to import.\", businessId);\n                return result;\n            }\n\n            var phones = parsedRows.Select(x => x.Phone).Distinct(StringComparer.OrdinalIgnoreCase).ToList();\n\n            // Fetch *all* matching contacts (including soft-deleted) for restore logic\n            var existingContacts = await _db.Contacts\n                .Where(c => c.BusinessId == businessId && phones.Contains(c.PhoneNumber))\n                .ToListAsync();\n\n            var existingByPhone = existingContacts\n                .GroupBy(c => c.PhoneNumber, StringComparer.OrdinalIgnoreCase)\n                .ToDictionary(\n                    g => g.Key,\n                    g => g.OrderByDescending(x => x.IsActive).ThenByDescending(x => x.CreatedAt).First(),\n                    StringComparer.OrdinalIgnoreCase\n                );\n\n            var toInsert = new List<Contact>();\n\n            foreach (var r in parsedRows)\n            {\n                if (existingByPhone.TryGetValue(r.Phone, out var existing))\n                {\n                    // Policy:\n                    // - Active -> skip\n                    // - Soft-deleted (IsActive=false) -> restore\n                    // - Archived -> skip (treat as existing)\n                    if (existing.IsArchived)\n                    {\n                        result.SkippedExisting++;\n                        continue;\n                    }\n\n                    if (existing.IsActive)\n                    {\n                        result.SkippedExisting++;\n                        continue;\n                    }\n\n                    // âœ… Restore soft-deleted\n                    existing.IsActive = true;\n                    existing.IsArchived = false;\n\n                    // Update fields (safe updates: only overwrite when CSV provides data)\n                    existing.Name = r.Name;\n                    if (!string.IsNullOrWhiteSpace(r.Email)) existing.Email = r.Email;\n                    if (!string.IsNullOrWhiteSpace(r.LeadSource)) existing.LeadSource = r.LeadSource;\n                    if (!string.IsNullOrWhiteSpace(r.Notes)) existing.Notes = r.Notes;\n\n                    result.Restored++;\n                    continue;\n                }\n\n                // Brand-new insert\n                toInsert.Add(new Contact\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    Name = r.Name,\n                    PhoneNumber = r.Phone,\n                    Email = r.Email,\n                    LeadSource = r.LeadSource,\n                    Notes = r.Notes,\n                    IsActive = true,\n                    IsArchived = false,\n                    CreatedAt = DateTime.UtcNow\n                });\n            }\n\n            if (toInsert.Count > 0)\n            {\n                _db.Contacts.AddRange(toInsert);\n            }\n\n            await _db.SaveChangesAsync();\n\n            result.Imported = toInsert.Count;\n\n            _logger.LogInformation(\n                \"Bulk import done. businessId={BusinessId}, imported={Imported}, restored={Restored}, skippedExisting={SkippedExisting}, dupInFile={DupInFile}, errors={Errors}\",\n                businessId, result.Imported, result.Restored, result.SkippedExisting, result.DuplicatesInFile, result.Errors.Count\n            );\n\n            return result;\n\n            static bool IsValidEmail(string email)\n            {\n                // EmailAddressAttribute is good enough for MVP validation\n                return new EmailAddressAttribute().IsValid(email);\n            }\n        }\n\n\n    }\n}\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Services/ContactSummaryService.cs",
      "sha256": "9e617711dc057302ba7f05b37bc2c6d11eb2fb1ce8370e2f1fa2ec40c48a9080",
      "language": "csharp",
      "size": 4320,
      "content": "// ðŸ“„ xbytechat-api/Features/CRM/Summary/Services/ContactSummaryService.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CRM.Dtos;\nusing xbytechat.api.Features.CRM.Interfaces;\nusing xbytechat.api.Features.CRM.Timelines.DTOs;\nusing xbytechat.api.Features.CRM.Timelines.Mappers;\nusing xbytechat.api.Features.CRM.Timelines.Services;\n\nnamespace xbytechat.api.Features.CRM.Services\n{\n    /// <summary>\n    /// Default implementation of IContactSummaryService.\n    /// Orchestrates calls into existing CRM services and returns\n    /// a single response model tailored for UI consumption.\n    /// </summary>\n    public sealed class ContactSummaryService : IContactSummaryService\n    {\n        private readonly IContactService _contactService;\n        private readonly INoteService _noteService;\n        private readonly IReminderService _reminderService;\n        private readonly ILeadTimelineService _leadTimelineService;\n\n        public ContactSummaryService(\n            IContactService contactService,\n            INoteService noteService,\n            IReminderService reminderService,\n            ILeadTimelineService leadTimelineService)\n        {\n            _contactService = contactService ?? throw new ArgumentNullException(nameof(contactService));\n            _noteService = noteService ?? throw new ArgumentNullException(nameof(noteService));\n            _reminderService = reminderService ?? throw new ArgumentNullException(nameof(reminderService));\n            _leadTimelineService = leadTimelineService ?? throw new ArgumentNullException(nameof(leadTimelineService));\n        }\n\n        public async Task<ContactSummaryResponseDto?> GetContactSummaryAsync(\n            Guid businessId,\n            Guid contactId,\n            CancellationToken ct = default)\n        {\n            // 1) Core contact (this already returns ContactDto with tags)\n            var contact = await _contactService.GetContactByIdAsync(businessId, contactId);\n            if (contact == null)\n            {\n                return null;\n            }\n\n            // 2) Notes â€“ latest 3 by CreatedAt\n            var notes = await _noteService.GetNotesByContactAsync(businessId, contactId);\n            var recentNotes = notes\n                .OrderByDescending(n => n.CreatedAt)\n                .Take(3)\n                .ToList();\n\n            // 3) Next upcoming reminder for this contact (in-memory filter from service)\n            var allReminders = await _reminderService.GetAllRemindersAsync(businessId);\n            var nowUtc = DateTime.UtcNow;\n\n            var nextReminder = allReminders\n                .Where(r =>\n                    r.ContactId == contactId &&\n                    r.IsActive &&\n                    string.Equals(r.Status, \"Pending\", StringComparison.OrdinalIgnoreCase) &&\n                    r.DueAt >= nowUtc)\n                .OrderBy(r => r.DueAt)\n                .FirstOrDefault();\n\n            // 4) Recent timeline entries (latest 5 by CreatedAt)\n            var timelineEntities = await _leadTimelineService.GetTimelineByContactIdAsync(contactId);\n\n            var recentTimeline = timelineEntities\n                .OrderByDescending(e => e.CreatedAt)\n                .Take(5)\n                .Select(LeadTimelineMapper.ToDto)\n                .Where(dto => dto != null)\n                .ToList()!; // mapper may return null, we filter just in case\n\n            // 5) Assemble response\n            return new ContactSummaryResponseDto\n            {\n                BusinessId = businessId,\n                ContactId = contactId,\n\n                Name = contact.Name,\n                PhoneNumber = contact.PhoneNumber,\n                Email = contact.Email,\n                LeadSource = contact.LeadSource,\n                LastContactedAt = contact.LastContactedAt,\n                NextFollowUpAt = contact.NextFollowUpAt,\n                IsFavorite = contact.IsFavorite,\n                IsArchived = contact.IsArchived,\n                Group = contact.Group,\n\n                Tags = contact.Tags ?? new List<ContactTagDto>(),\n\n                RecentNotes = recentNotes,\n                NextReminder = nextReminder,\n                RecentTimeline = recentTimeline\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Services/ContactTagService.cs",
      "sha256": "543a9a012a00f3ba3e43254aa3af8e48059f0aa7573ed59f8d7cdf20c4bc3684",
      "language": "csharp",
      "size": 2387,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.CRM.Interfaces;\nusing xbytechat.api.Features.CRM.Timelines.DTOs;\nusing xbytechat.api.Features.CRM.Timelines.Services;\n\nnamespace xbytechat.api.Features.CRM.Services\n{\n    public class ContactTagService : IContactTagService\n    {\n        private readonly AppDbContext _db;\n        private readonly ITimelineService _timelineService;\n        private readonly ILogger<ContactTagService> _logger;\n\n        public ContactTagService(AppDbContext db, ITimelineService timelineService, ILogger<ContactTagService> logger)\n        {\n            _db = db;\n            _timelineService = timelineService;\n            _logger = logger;\n        }\n\n        public async Task<bool> RemoveTagFromContactAsync(Guid businessId, Guid contactId, Guid tagId)\n        {\n            // âœ… Find the link row but confirm contact belongs to this business\n            var link = await _db.ContactTags\n                .Join(_db.Contacts,\n                    ct => ct.ContactId,\n                    c => c.Id,\n                    (ct, c) => new { ct, c })\n                .Where(x => x.c.BusinessId == businessId\n                            && x.c.IsActive\n                            && x.ct.ContactId == contactId\n                            && x.ct.TagId == tagId)\n                .Select(x => x.ct)\n                .FirstOrDefaultAsync();\n\n            if (link == null) return false;\n\n            _db.ContactTags.Remove(link);\n            await _db.SaveChangesAsync();\n\n            // âœ… Timeline log (safe, do not fail delete if timeline fails)\n            try\n            {\n                await _timelineService.LogTagRemovedAsync(new CRMTimelineLogDto\n                {\n                    ContactId = contactId,\n                    BusinessId = businessId,\n                    EventType = \"TagRemoved\",\n                    Description = $\"ðŸ·ï¸ Tag removed.\",\n                    ReferenceId = tagId,\n                    CreatedBy = \"system\",\n                    Timestamp = DateTime.UtcNow,\n                    Category = \"CRM\"\n                });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"Timeline log failed for TagRemoved. ContactId={ContactId}, TagId={TagId}\", contactId, tagId);\n            }\n\n            return true;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Services/IContactProfileService.cs",
      "sha256": "2238c717846876f685aeb1424a5812b4673fd589105f31cdfbe116672d1cfd61",
      "language": "csharp",
      "size": 492,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.CRM.Services\n{\n    public interface IContactProfileService\n    {\n        /// <summary>\n        /// Update contact's ProfileName if changed. Lookup by (BusinessId, E.164 phone).\n        /// No-op if contact not found or name is empty.\n        /// </summary>\n        Task UpsertProfileNameAsync(Guid businessId, string phoneE164, string? profileName, CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Services/IContactSummaryService.cs",
      "sha256": "eaee7641520cea5125234a96e58c4e6ee94f241e1a3098f43f36fe5cac76e56f",
      "language": "csharp",
      "size": 773,
      "content": "// ðŸ“„ xbytechat-api/Features/CRM/Summary/Interfaces/IContactSummaryService.cs\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CRM.Dtos;\n\nnamespace xbytechat.api.Features.CRM.Services\n{\n    /// <summary>\n    /// Aggregates data from CRM modules (Contacts, Notes, Reminders, Timeline)\n    /// into a single contact summary for the Chat Inbox / dashboards.\n    /// </summary>\n    public interface IContactSummaryService\n    {\n        /// <summary>\n        /// Returns a compact CRM snapshot for the given contact and business.\n        /// </summary>\n        Task<ContactSummaryResponseDto?> GetContactSummaryAsync(\n            Guid businessId,\n            Guid contactId,\n            CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Services/NoteService.cs",
      "sha256": "a25f2e5436a4deff6bd3860b2e339dfed6e41678d847ce1e61fc5af3d4da75c0",
      "language": "csharp",
      "size": 5573,
      "content": "using Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.CRM.Dtos;\nusing xbytechat.api.Features.CRM.Interfaces;\nusing xbytechat.api.Features.CRM.Mappers;\nusing xbytechat.api.Features.CRM.Timelines.DTOs;\nusing xbytechat.api.Features.CRM.Timelines.Services;\n\nnamespace xbytechat.api.Features.CRM.Services\n{\n    public class NoteService : INoteService\n    {\n        private readonly AppDbContext _db;\n        private readonly ITimelineService _timelineService;\n\n        public NoteService(AppDbContext db, ITimelineService timelineService)\n        {\n            _db = db;\n            _timelineService = timelineService;\n        }\n\n        // ðŸ“ Add a new Note + Log into LeadTimeline\n        public async Task<NoteDto> AddNoteAsync(Guid businessId, NoteDto dto)\n        {\n            if (dto == null) throw new ArgumentNullException(nameof(dto));\n\n            // âœ… Content is the real important field\n            dto.Content = (dto.Content ?? string.Empty).Trim();\n            if (string.IsNullOrWhiteSpace(dto.Content))\n                throw new ArgumentException(\"Note content is required.\");\n\n            // âœ… Title is optional â†’ derive from Content if missing\n            dto.Title = NormalizeTitle(dto.Title, dto.Content);\n\n            // 1ï¸âƒ£ Map incoming DTO to Note entity\n            var note = NoteMapper.MapToEntity(dto, businessId);\n\n            // 2ï¸âƒ£ Save the Note into database\n            _db.Notes.Add(note);\n            await _db.SaveChangesAsync();\n\n            // 3ï¸âƒ£ Log this Note creation into LeadTimeline (only if ContactId is present)\n            if (dto.ContactId.HasValue)\n            {\n                try\n                {\n                    await _timelineService.LogNoteAddedAsync(new CRMTimelineLogDto\n                    {\n                        ContactId = dto.ContactId.Value,\n                        BusinessId = businessId,\n                        EventType = \"NoteAdded\",\n                        Description = $\"ðŸ“ Note added: {dto.Title ?? \"(Untitled)\"}\",\n                        ReferenceId = note.Id,\n                        CreatedBy = dto.CreatedBy, // âš ï¸ ideally override from claims in controller\n                        Timestamp = DateTime.UtcNow\n                    });\n                }\n                catch (Exception ex)\n                {\n                    // ðŸ›¡ Timeline saving failure should not break note creation\n                    Console.WriteLine($\"âš ï¸ Timeline log failed for NoteId {note.Id}: {ex.Message}\");\n                }\n            }\n\n            // 4ï¸âƒ£ Return the saved note as DTO\n            return NoteMapper.MapToDto(note);\n        }\n\n        // ðŸ“‹ List all Notes by Contact\n        public async Task<IEnumerable<NoteDto>> GetNotesByContactAsync(Guid businessId, Guid contactId)\n        {\n            return await _db.Notes\n                .AsNoTracking()\n                .Where(n => n.BusinessId == businessId && n.ContactId == contactId)\n                .OrderByDescending(n => n.CreatedAt)\n                .Select(n => NoteMapper.MapToDto(n))\n                .ToListAsync();\n        }\n\n        // ðŸ“‹ Get a single Note by Id\n        public async Task<NoteDto?> GetNoteByIdAsync(Guid businessId, Guid noteId)\n        {\n            var note = await _db.Notes\n                .AsNoTracking()\n                .FirstOrDefaultAsync(n => n.Id == noteId && n.BusinessId == businessId);\n\n            return note == null ? null : NoteMapper.MapToDto(note);\n        }\n\n        // âœï¸ Update an existing Note\n        public async Task<bool> UpdateNoteAsync(Guid businessId, Guid noteId, NoteDto dto)\n        {\n            if (dto == null) throw new ArgumentNullException(nameof(dto));\n\n            var note = await _db.Notes.FirstOrDefaultAsync(n => n.Id == noteId && n.BusinessId == businessId);\n            if (note == null) return false;\n\n            // âœ… Content is required\n            dto.Content = (dto.Content ?? string.Empty).Trim();\n            if (string.IsNullOrWhiteSpace(dto.Content))\n                throw new ArgumentException(\"Note content is required.\");\n\n            // âœ… Title optional: only update if provided, else derive from Content\n            var normalizedTitle = NormalizeTitle(dto.Title, dto.Content);\n            note.Title = normalizedTitle;\n\n            note.Content = dto.Content;\n            note.IsPinned = dto.IsPinned;\n            note.IsInternal = dto.IsInternal;\n            note.EditedAt = DateTime.SpecifyKind(DateTime.UtcNow, DateTimeKind.Utc);\n\n            await _db.SaveChangesAsync();\n            return true;\n        }\n\n        // ðŸ—‘ï¸ HARD delete (actual remove) a Note\n        public async Task<bool> DeleteNoteAsync(Guid businessId, Guid noteId)\n        {\n            var note = await _db.Notes.FirstOrDefaultAsync(n => n.Id == noteId && n.BusinessId == businessId);\n            if (note == null) return false;\n\n            _db.Notes.Remove(note); // âœ… Hard delete\n            await _db.SaveChangesAsync();\n            return true;\n        }\n\n        // ----------------- helpers -----------------\n\n        private static string? NormalizeTitle(string? title, string content)\n        {\n            var t = (title ?? string.Empty).Trim();\n            if (!string.IsNullOrWhiteSpace(t))\n                return t;\n\n            // derive from content\n            var c = (content ?? string.Empty).Trim();\n            if (string.IsNullOrWhiteSpace(c))\n                return null;\n\n            const int max = 60;\n            return c.Length <= max ? c : (c.Substring(0, max) + \"â€¦\");\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Services/ReminderService.cs",
      "sha256": "0446270dbb8c52631513ddb887d88c0a3643e1c7f0f9c0821a0d6d74984f0df0",
      "language": "csharp",
      "size": 8345,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.CRM.Dtos;\nusing xbytechat.api.Features.CRM.Interfaces;\nusing xbytechat.api.Features.CRM.Mappers;\nusing xbytechat.api.Features.CRM.Models;\nusing xbytechat.api.Features.CRM.Timelines.DTOs;\nusing xbytechat.api.Features.CRM.Timelines.Services;\n\nnamespace xbytechat.api.Features.CRM.Services\n{\n    public class ReminderService : IReminderService\n    {\n        private readonly AppDbContext _db;\n        private readonly ITimelineService _timelineService;\n        private readonly ILogger<ReminderService> _logger;\n\n        public ReminderService(AppDbContext db, ITimelineService timelineService, ILogger<ReminderService> logger)\n        {\n            _db = db;\n            _timelineService = timelineService;\n            _logger = logger;\n        }\n\n        public async Task<ReminderDto> AddReminderAsync(Guid businessId, ReminderDto dto)\n        {\n            if (dto == null) throw new ArgumentNullException(nameof(dto));\n\n            var title = string.IsNullOrWhiteSpace(dto.Title) ? \"(No title)\" : dto.Title.Trim();\n            var status = string.IsNullOrWhiteSpace(dto.Status) ? \"Pending\" : dto.Status.Trim();\n\n            // âœ… Your DB model uses Guid (not nullable), so we must choose a value\n            var contactId = dto.ContactId ?? Guid.Empty;\n\n            var reminder = new Reminder\n            {\n                Id = Guid.NewGuid(),\n                BusinessId = businessId,\n                ContactId = contactId, // âœ… Guid value (Guid.Empty if none)\n                Title = title,\n                Description = dto.Description?.Trim(),\n                DueAt = EnsureUtc(dto.DueAt),\n                Status = status,\n                ReminderType = dto.ReminderType?.Trim(),\n                Priority = dto.Priority,\n                IsRecurring = dto.IsRecurring,\n                RecurrencePattern = dto.RecurrencePattern,\n                SendWhatsappNotification = dto.SendWhatsappNotification,\n                LinkedCampaign = dto.LinkedCampaign,\n                CreatedAt = DateTime.UtcNow, // âœ… correct\n                UpdatedAt = null,\n                CompletedAt = IsDoneStatus(status) ? DateTime.UtcNow : null,\n                IsActive = true\n            };\n\n            _db.Reminders.Add(reminder);\n            await _db.SaveChangesAsync();\n\n            // âœ… Timeline only if contactId is real\n            if (contactId != Guid.Empty)\n            {\n                try\n                {\n                    await _timelineService.LogReminderSetAsync(new CRMTimelineLogDto\n                    {\n                        ContactId = contactId,\n                        BusinessId = businessId,\n                        EventType = \"ReminderSet\",\n                        Description = $\"â° Reminder set: {reminder.Title} (Due: {reminder.DueAt:yyyy-MM-dd HH:mm} UTC)\",\n                        ReferenceId = reminder.Id,\n                        CreatedBy = dto.CreatedBy ?? \"system\",\n                        Timestamp = DateTime.UtcNow,\n                        Category = \"CRM\"\n                    });\n                }\n                catch (Exception ex)\n                {\n                    _logger.LogWarning(ex, \"Timeline log failed for ReminderId={ReminderId}\", reminder.Id);\n                }\n            }\n\n            return ReminderMapper.MapToDto(reminder);\n        }\n\n        public async Task<IEnumerable<ReminderDto>> GetAllRemindersAsync(Guid businessId)\n        {\n            return await _db.Reminders\n                .AsNoTracking()\n                .Where(r => r.BusinessId == businessId && r.IsActive)\n                .OrderBy(r => r.DueAt)\n                .Select(r => ReminderMapper.MapToDto(r))\n                .ToListAsync();\n        }\n\n        public async Task<ReminderDto?> GetReminderByIdAsync(Guid businessId, Guid reminderId)\n        {\n            var reminder = await _db.Reminders\n                .AsNoTracking()\n                .FirstOrDefaultAsync(r => r.BusinessId == businessId && r.Id == reminderId && r.IsActive);\n\n            return reminder == null ? null : ReminderMapper.MapToDto(reminder);\n        }\n\n        public async Task<bool> UpdateReminderAsync(Guid businessId, Guid reminderId, ReminderDto dto)\n        {\n            var reminder = await _db.Reminders\n                .FirstOrDefaultAsync(r => r.BusinessId == businessId && r.Id == reminderId && r.IsActive);\n\n            if (reminder == null) return false;\n\n            if (!string.IsNullOrWhiteSpace(dto.Title))\n                reminder.Title = dto.Title.Trim();\n\n            reminder.Description = dto.Description?.Trim();\n            reminder.DueAt = EnsureUtc(dto.DueAt);\n\n            if (!string.IsNullOrWhiteSpace(dto.Status))\n                reminder.Status = dto.Status.Trim();\n\n            reminder.ReminderType = dto.ReminderType?.Trim();\n            reminder.Priority = dto.Priority;\n            reminder.IsRecurring = dto.IsRecurring;\n            reminder.RecurrencePattern = dto.RecurrencePattern;\n            reminder.SendWhatsappNotification = dto.SendWhatsappNotification;\n            reminder.LinkedCampaign = dto.LinkedCampaign;\n            reminder.UpdatedAt = DateTime.UtcNow;\n\n            if (IsDoneStatus(reminder.Status))\n                reminder.CompletedAt = reminder.CompletedAt ?? DateTime.UtcNow;\n\n            await _db.SaveChangesAsync();\n\n            // (optional) timeline â€œupdatedâ€\n            if (reminder.ContactId != Guid.Empty)\n            {\n                try\n                {\n                    await _timelineService.LogReminderUpdatedAsync(new CRMTimelineLogDto\n                    {\n                        ContactId = reminder.ContactId,\n                        BusinessId = businessId,\n                        EventType = \"ReminderUpdated\",\n                        Description = $\"âœï¸ Reminder updated: {reminder.Title}\",\n                        ReferenceId = reminder.Id,\n                        CreatedBy = dto.CreatedBy ?? \"system\",\n                        Timestamp = DateTime.UtcNow,\n                        Category = \"CRM\"\n                    });\n                }\n                catch (Exception ex)\n                {\n                    _logger.LogWarning(ex, \"Timeline log failed for ReminderUpdated ReminderId={ReminderId}\", reminder.Id);\n                }\n            }\n\n            return true;\n        }\n\n        // âœ… HARD DELETE\n        public async Task<bool> DeleteReminderAsync(Guid businessId, Guid reminderId)\n        {\n            var reminder = await _db.Reminders\n                .FirstOrDefaultAsync(r => r.BusinessId == businessId && r.Id == reminderId && r.IsActive);\n\n            if (reminder == null) return false;\n\n            var contactId = reminder.ContactId;\n\n            _db.Reminders.Remove(reminder);\n            await _db.SaveChangesAsync();\n\n            if (contactId != Guid.Empty)\n            {\n                try\n                {\n                    await _timelineService.LogReminderDeletedAsync(new CRMTimelineLogDto\n                    {\n                        ContactId = contactId,\n                        BusinessId = businessId,\n                        EventType = \"ReminderDeleted\",\n                        Description = $\"ðŸ—‘ï¸ Reminder deleted: {reminder.Title}\",\n                        ReferenceId = reminder.Id,\n                        CreatedBy = \"system\",\n                        Timestamp = DateTime.UtcNow,\n                        Category = \"CRM\"\n                    });\n                }\n                catch (Exception ex)\n                {\n                    _logger.LogWarning(ex, \"Timeline log failed for ReminderDeleted ReminderId={ReminderId}\", reminder.Id);\n                }\n            }\n\n            return true;\n        }\n\n        private static DateTime EnsureUtc(DateTime value)\n        {\n            if (value.Kind == DateTimeKind.Utc) return value;\n            if (value.Kind == DateTimeKind.Local) return value.ToUniversalTime();\n            return DateTime.SpecifyKind(value, DateTimeKind.Utc);\n        }\n\n        private static bool IsDoneStatus(string? status)\n        {\n            if (string.IsNullOrWhiteSpace(status)) return false;\n            var s = status.Trim().ToLowerInvariant();\n            return s == \"done\" || s == \"completed\" || s == \"complete\";\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Services/TagService.cs",
      "sha256": "2e701fc3ab31d67208bdc3b4eeea07b3935f7129faac440942e15f3b6ee0a583",
      "language": "csharp",
      "size": 11636,
      "content": "// ðŸ“„ File: xbytechat-api/Features/CRM/Services/TagService.cs\n\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.CRM.Dtos;\nusing xbytechat.api.Features.CRM.Interfaces;\nusing xbytechat.api.Features.CRM.Models;\nusing xbytechat.api.Features.CRM.Timelines.DTOs;\nusing xbytechat.api.Features.CRM.Timelines.Services;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.CRM.Services\n{\n    public class TagService : ITagService\n    {\n        private readonly AppDbContext _db;\n        private readonly ITimelineService _timelineService;\n        private readonly ILogger<TagService> _logger;\n\n        public TagService(AppDbContext db, ITimelineService timelineService, ILogger<TagService> logger)\n        {\n            _db = db;\n            _timelineService = timelineService;\n            _logger = logger;\n        }\n\n        public async Task<TagDto> AddTagAsync(Guid businessId, TagDto dto)\n        {\n            var name = (dto.Name ?? string.Empty).Trim();\n            if (string.IsNullOrWhiteSpace(name))\n                throw new ArgumentException(\"Tag name is required.\", nameof(dto.Name));\n\n            // âœ… Avoid duplicates (case-insensitive) within a business\n            // NOTE: This is app-level protection; a DB unique index is still recommended later.\n            var nameLower = name.ToLowerInvariant();\n\n            var existing = await _db.Tags\n                .Where(t => t.BusinessId == businessId && t.IsActive)\n                .FirstOrDefaultAsync(t => (t.Name ?? \"\").ToLower() == nameLower);\n\n            if (existing != null)\n            {\n                return new TagDto\n                {\n                    Id = existing.Id,\n                    Name = existing.Name,\n                    ColorHex = existing.ColorHex,\n                    Category = existing.Category,\n                    Notes = existing.Notes,\n                    IsSystemTag = existing.IsSystemTag,\n                    IsActive = existing.IsActive,\n                    CreatedAt = existing.CreatedAt,\n                    LastUsedAt = existing.LastUsedAt\n                };\n            }\n\n            var tag = new Tag\n            {\n                Id = Guid.NewGuid(),\n                BusinessId = businessId,\n                Name = name,\n                ColorHex = string.IsNullOrWhiteSpace(dto.ColorHex) ? \"#8c8c8c\" : dto.ColorHex.Trim(),\n                Category = string.IsNullOrWhiteSpace(dto.Category) ? \"General\" : dto.Category.Trim(),\n                Notes = string.IsNullOrWhiteSpace(dto.Notes) ? null : dto.Notes.Trim(),\n                IsSystemTag = dto.IsSystemTag,\n\n                // âœ… IMPORTANT: do not trust dto.IsActive during create (missing bool => false)\n                IsActive = true,\n\n                CreatedAt = DateTime.UtcNow,\n                LastUsedAt = null\n            };\n\n            _db.Tags.Add(tag);\n            await _db.SaveChangesAsync();\n\n            // âœ… Non-blocking timeline log\n            try\n            {\n                await _timelineService.LogTagAppliedAsync(new CRMTimelineLogDto\n                {\n                    ContactId = Guid.Empty,\n                    BusinessId = businessId,\n                    EventType = \"TagCreated\",\n                    Description = $\"ðŸ·ï¸ New tag created: {tag.Name}\",\n                    ReferenceId = tag.Id,\n                    CreatedBy = \"System\",\n                    Timestamp = DateTime.UtcNow,\n                    Category = \"CRM\"\n                });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"âš ï¸ Timeline log failed for TagId {TagId}\", tag.Id);\n            }\n\n            return new TagDto\n            {\n                Id = tag.Id,\n                Name = tag.Name,\n                ColorHex = tag.ColorHex,\n                Category = tag.Category,\n                Notes = tag.Notes,\n                IsSystemTag = tag.IsSystemTag,\n                IsActive = tag.IsActive,\n                CreatedAt = tag.CreatedAt,\n                LastUsedAt = tag.LastUsedAt\n            };\n        }\n\n        public async Task<IEnumerable<TagDto>> GetAllTagsAsync(Guid businessId)\n        {\n            return await _db.Tags\n                .Where(t => t.BusinessId == businessId && t.IsActive)\n                .OrderByDescending(t => t.CreatedAt)\n                .Select(t => new TagDto\n                {\n                    Id = t.Id,\n                    Name = t.Name,\n                    ColorHex = t.ColorHex,\n                    Category = t.Category,\n                    Notes = t.Notes,\n                    IsSystemTag = t.IsSystemTag,\n                    IsActive = t.IsActive,\n                    CreatedAt = t.CreatedAt,\n                    LastUsedAt = t.LastUsedAt\n                })\n                .ToListAsync();\n        }\n\n        public async Task<bool> UpdateTagAsync(Guid businessId, Guid tagId, TagDto dto)\n        {\n            var tag = await _db.Tags.FirstOrDefaultAsync(t => t.Id == tagId && t.BusinessId == businessId);\n            if (tag == null) return false;\n\n            var name = (dto.Name ?? string.Empty).Trim();\n            if (string.IsNullOrWhiteSpace(name))\n                throw new ArgumentException(\"Tag name is required.\", nameof(dto.Name));\n\n            // âœ… Prevent rename collision (case-insensitive) inside business\n            var nameLower = name.ToLowerInvariant();\n\n            var collision = await _db.Tags\n                .Where(t => t.BusinessId == businessId && t.IsActive && t.Id != tagId)\n                .AnyAsync(t => (t.Name ?? \"\").ToLower() == nameLower);\n\n            if (collision)\n                throw new InvalidOperationException($\"A tag with name '{name}' already exists.\");\n\n            tag.Name = name;\n            tag.ColorHex = string.IsNullOrWhiteSpace(dto.ColorHex) ? tag.ColorHex : dto.ColorHex.Trim();\n            tag.Category = string.IsNullOrWhiteSpace(dto.Category) ? tag.Category : dto.Category.Trim();\n            tag.Notes = string.IsNullOrWhiteSpace(dto.Notes) ? null : dto.Notes.Trim();\n            tag.IsSystemTag = dto.IsSystemTag;\n\n            // âœ… Allow activate/deactivate via update\n            tag.IsActive = dto.IsActive;\n            tag.LastUsedAt = DateTime.UtcNow;\n\n            await _db.SaveChangesAsync();\n            return true;\n        }\n\n        public async Task<bool> DeleteTagAsync(Guid businessId, Guid tagId)\n        {\n            var tag = await _db.Tags.FirstOrDefaultAsync(t => t.Id == tagId && t.BusinessId == businessId);\n            if (tag == null) return false;\n\n            tag.IsActive = false; // âœ… soft delete\n            await _db.SaveChangesAsync();\n            return true;\n        }\n\n        /// <summary>\n        /// Assigns tags (by name) to a contact located via phone number.\n        /// Canonical phone storage: E.164 digits-only (no '+').\n        /// </summary>\n        public async Task<bool> AssignTagsAsync(Guid businessId, string phoneNumber, List<string> tagNames)\n        {\n            // âœ… Normalize phone first (digits-only)\n            var normalizedPhone = PhoneNumberNormalizer.NormalizeToE164Digits(phoneNumber, \"IN\");\n            if (string.IsNullOrWhiteSpace(normalizedPhone))\n            {\n                _logger.LogWarning(\"AssignTagsAsync: invalid phone. businessId={BusinessId}, rawPhone={Phone}\", businessId, phoneNumber);\n                return false;\n            }\n\n            if (tagNames == null || tagNames.Count == 0)\n                return false;\n\n            // âœ… Clean tag list (trim + remove empties + distinct, case-insensitive)\n            var cleanedTagNames = tagNames\n                .Where(t => !string.IsNullOrWhiteSpace(t))\n                .Select(t => t.Trim())\n                .Distinct(StringComparer.OrdinalIgnoreCase)\n                .ToList();\n\n            if (cleanedTagNames.Count == 0)\n                return false;\n\n            // âœ… Find contact safely (tenant + active + not archived)\n            var contact = await _db.Contacts\n                .Include(c => c.ContactTags)\n                .FirstOrDefaultAsync(c =>\n                    c.BusinessId == businessId &&\n                    c.IsActive &&\n                    !c.IsArchived &&\n                    c.PhoneNumber == normalizedPhone);\n\n            if (contact == null)\n            {\n                _logger.LogWarning(\"AssignTagsAsync: contact not found. businessId={BusinessId}, phone={Phone}\", businessId, normalizedPhone);\n                return false;\n            }\n\n            var existingTagIds = contact.ContactTags?.Select(ct => ct.TagId).ToHashSet() ?? new HashSet<Guid>();\n\n            // âœ… Fetch existing tags (active). Case-insensitive mapping in-memory (safe across DB collations).\n            var existingTags = await _db.Tags\n                .Where(t => t.BusinessId == businessId && t.IsActive)\n                .ToListAsync();\n\n            var existingByName = existingTags\n                .GroupBy(t => t.Name ?? \"\", StringComparer.OrdinalIgnoreCase)\n                .ToDictionary(g => g.Key, g => g.First(), StringComparer.OrdinalIgnoreCase);\n\n            var tagsToLink = new List<Tag>();\n\n            foreach (var name in cleanedTagNames)\n            {\n                if (existingByName.TryGetValue(name, out var tag))\n                {\n                    tagsToLink.Add(tag);\n                    continue;\n                }\n\n                // Create missing tag\n                var newTag = new Tag\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    Name = name,\n                    ColorHex = \"#8c8c8c\",\n                    Category = \"General\",\n                    IsActive = true,\n                    CreatedAt = DateTime.UtcNow,\n                    LastUsedAt = DateTime.UtcNow\n                };\n\n                _db.Tags.Add(newTag);\n                tagsToLink.Add(newTag);\n                existingByName[name] = newTag;\n            }\n\n            // Save new tags before linking\n            await _db.SaveChangesAsync();\n\n            contact.ContactTags ??= new List<ContactTag>();\n\n            var anyLinked = false;\n\n            foreach (var tag in tagsToLink)\n            {\n                if (existingTagIds.Contains(tag.Id))\n                    continue;\n\n                contact.ContactTags.Add(new ContactTag\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    ContactId = contact.Id,\n                    TagId = tag.Id,\n                    AssignedAt = DateTime.UtcNow,\n                    AssignedBy = \"automation\"\n                });\n\n                anyLinked = true;\n            }\n\n            if (!anyLinked)\n                return true;\n\n            await _db.SaveChangesAsync();\n\n            // âœ… Non-blocking timeline\n            try\n            {\n                await _timelineService.LogTagAppliedAsync(new CRMTimelineLogDto\n                {\n                    ContactId = contact.Id,\n                    BusinessId = businessId,\n                    EventType = \"TagsAssigned\",\n                    Description = $\"ðŸ·ï¸ Tags assigned: {string.Join(\", \", cleanedTagNames)}\",\n                    ReferenceId = contact.Id,\n                    CreatedBy = \"automation\",\n                    Timestamp = DateTime.UtcNow,\n                    Category = \"CRM\"\n                });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"âš ï¸ Timeline log failed for AssignTagsAsync. contactId={ContactId}\", contact.Id);\n            }\n\n            return true;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Timelines/Controllers/LeadTimelineController.cs",
      "sha256": "acbf1f3b85665c403e9ba8358653b9dbf039c8881b112af442083b59f7c6d1ee",
      "language": "csharp",
      "size": 2035,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing Serilog;\nusing xbytechat.api.Features.CRM.Timelines.DTOs;\nusing xbytechat.api.Features.CRM.Timelines.Services;\n\nnamespace xbytechat.api.Features.CRM.Timelines.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class LeadTimelineController : ControllerBase\n    {\n        private readonly ILeadTimelineService _timelineService;\n\n        public LeadTimelineController(ILeadTimelineService timelineService)\n        {\n            _timelineService = timelineService;\n        }\n\n        [HttpPost]\n        public async Task<IActionResult> AddTimelineEntry([FromBody] LeadTimelineDto dto)\n        {\n            try\n            {\n                if (!ModelState.IsValid)\n                    return BadRequest(ModelState);\n\n                var result = await _timelineService.AddTimelineEntryAsync(dto);\n\n                Log.Information(\"âœ… Timeline entry created for ContactId: {ContactId}\", dto.ContactId);\n\n                return Ok(result);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"âŒ Failed to add timeline entry for ContactId: {ContactId}\", dto.ContactId);\n                throw;\n            }\n        }\n\n        [HttpGet(\"contact/{contactId}\")]\n        public async Task<IActionResult> GetTimeline(Guid contactId)\n        {\n            try\n            {\n                var timeline = await _timelineService.GetTimelineByContactIdAsync(contactId);\n\n                Log.Information(\"ðŸ“„ Retrieved {Count} entries for ContactId: {ContactId}\", timeline.Count, contactId);\n\n                return Ok(timeline);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"âŒ Failed to get timeline for ContactId: {ContactId}\", contactId);\n                throw;\n            }\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> GetAll()\n        {\n            var timelines = await _timelineService.GetAllTimelinesAsync();\n            return Ok(timelines);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Timelines/DTOs/CampaignTimelineLogDto.cs",
      "sha256": "b279e39522b2d36effd77fe29c36653ca83b93c6cc9a1281d1ed6b3e596b96e3",
      "language": "csharp",
      "size": 361,
      "content": "public class CampaignTimelineLogDto\n{\n    public Guid ContactId { get; set; }\n    public Guid BusinessId { get; set; }   // âœ… Needed for timeline insertion\n    public Guid CampaignId { get; set; }\n    public string CampaignName { get; set; } = string.Empty; // âœ… Safe default to avoid null issues\n    public DateTime? Timestamp { get; set; } // optional\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Timelines/DTOs/CRMTimelineLogDto.cs",
      "sha256": "523614f609f53bf0e19c490cf47a69ceb3ccc7df61bba97b431fcbcf6c739bdf",
      "language": "csharp",
      "size": 695,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CRM.Timelines.DTOs\n{\n    public class CRMTimelineLogDto\n    {\n        public Guid ContactId { get; set; }\n        public Guid BusinessId { get; set; }\n        public string EventType { get; set; }  // ðŸ§© Example: \"NoteAdded\", \"ReminderSet\", \"TagApplied\"\n        public string Description { get; set; }\n        public Guid? ReferenceId { get; set; }  // ðŸ†” Related NoteId, ReminderId, TagId (optional)\n        public string CreatedBy { get; set; }\n        public string? Category { get; set; } = \"CRM\";  // ðŸ“‚ Default category: CRM\n        public DateTime? Timestamp { get; set; }  // â° Custom time if needed (else CreatedAt = now)\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Timelines/DTOs/LeadTimelineDto.cs",
      "sha256": "3b83f102ec5c0ddae6f265b6d33ddbd741f854e83baa0f696a1a05a7d9639104",
      "language": "csharp",
      "size": 687,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CRM.Timelines.DTOs\n{\n    public class LeadTimelineDto\n    {\n        public Guid ContactId { get; set; }\n        public string ContactName { get; set; }\n        public string ContactNumber { get; set; }\n        public string EventType { get; set; }\n        public string Description { get; set; }\n        public string? Data { get; set; }\n        public Guid? ReferenceId { get; set; }\n        public bool IsSystemGenerated { get; set; } = false;\n        public string CreatedBy { get; set; }\n        public string? Source { get; set; }\n        public string? Category { get; set; }\n        public DateTime CreatedAt { get; set; }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Timelines/Mappers/LeadTimelineMapper.cs",
      "sha256": "d3a2ed675f44c84af1ce0317d44c4407bf3fc23bf4bfdd91ebf0c52bf63a9296",
      "language": "csharp",
      "size": 1843,
      "content": "using xbytechat.api.Features.CRM.Timelines.DTOs;\nusing xbytechat.api.Features.CRM.Timelines.Models;\n\nnamespace xbytechat.api.Features.CRM.Timelines.Mappers\n{\n    public static class LeadTimelineMapper\n    {\n        public static LeadTimelineDto ToDto(Models.LeadTimeline entry)\n        {\n            if (entry == null) return null;\n\n            return new LeadTimelineDto\n            {\n                ContactId = entry.ContactId,\n                ContactName = entry.Contact?.Name,                // âœ… Enriched from navigation\n                ContactNumber = entry.Contact?.PhoneNumber,       // âœ… Enriched from navigation\n                EventType = entry.EventType,\n                Description = entry.Description,\n                Data = entry.Data,\n                ReferenceId = entry.ReferenceId,\n                IsSystemGenerated = entry.IsSystemGenerated,\n                CreatedBy = entry.CreatedBy,\n                Source = entry.Source,\n                Category = entry.Category,\n                // âœ… CreatedAt is intentionally excluded from DTO\n            };\n        }\n\n        // Optional for create/update, include only necessary fields\n        public static Models.LeadTimeline ToModel(LeadTimelineDto dto)\n        {\n            if (dto == null) return null;\n\n            return new Models.LeadTimeline\n            {\n                ContactId = dto.ContactId,\n                EventType = dto.EventType,\n                Description = dto.Description,\n                Data = dto.Data,\n                ReferenceId = dto.ReferenceId,\n                IsSystemGenerated = dto.IsSystemGenerated,\n                CreatedBy = dto.CreatedBy,\n                Source = dto.Source,\n                Category = dto.Category,\n                CreatedAt = DateTime.UtcNow // âœ… Always use UTC when creating\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Timelines/Models/LeadTimeline.cs",
      "sha256": "3f31e8a170176d76713be299c4d314a5d1aaf17514d4903adb3685d41ca42572",
      "language": "csharp",
      "size": 1206,
      "content": "using xbytechat.api.Features.BusinessModule.Models;\nusing xbytechat.api.Features.CRM.Models;\n\nnamespace xbytechat.api.Features.CRM.Timelines.Models\n{\n    public class LeadTimeline\n    {\n        public int Id { get; set; }\n        public Guid ContactId { get; set; }\n        public Guid BusinessId { get; set; }\n        public Business Business { get; set; }  // optional\n\n        public Contact Contact { get; set; } // ðŸ†• Navigation property\n\n        public string EventType { get; set; }\n\n        public string Description { get; set; }\n        public string? Data { get; set; }\n        public Guid? ReferenceId { get; set; }           // âœ… New\n        public bool IsSystemGenerated { get; set; } = false;  // âœ… New\n        public string CreatedBy { get; set; }\n        public string? Source { get; set; }\n        public string? Category { get; set; }\n        public DateTime CreatedAt { get; set; }\n\n        public string? CTAType { get; set; } // e.g., \"BuyNow\", \"PriceCheck\", \"ConfirmReminder\"\n        public string? CTASourceType { get; set; } // e.g., \"catalog\", \"campaign\", \"reminder\"\n        public Guid? CTASourceId { get; set; } // ID of the source object (productId, reminderId)\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Timelines/Services/ILeadTimelineService.cs",
      "sha256": "50629497a65281bae0ab515aa0b85e6a12eba14d8da57398c82e68cff749f58e",
      "language": "csharp",
      "size": 717,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Catalog.Models;\nusing xbytechat.api.Features.CRM.Timelines.DTOs;\nusing xbytechat.api.Features.CRM.Timelines.Models;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.CRM.Timelines.Services\n{\n    public interface ILeadTimelineService\n    {\n        Task<LeadTimeline> AddTimelineEntryAsync(LeadTimelineDto dto);\n        Task<List<LeadTimeline>> GetTimelineByContactIdAsync(Guid contactId);\n        Task<List<LeadTimelineDto>> GetAllTimelinesAsync();\n        Task AddFromCatalogClickAsync(CatalogClickLog log);\n        Task<ResponseResult> LogCampaignSendAsync(CampaignTimelineLogDto dto);\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Timelines/Services/ITimelineService.cs",
      "sha256": "f7018aae9a980787a0554c485915f6e623ed09c4e18b67b1843d17fa52b09b61",
      "language": "csharp",
      "size": 563,
      "content": "using xbytechat.api.Features.CRM.Timelines.DTOs;\n\nnamespace xbytechat.api.Features.CRM.Timelines.Services\n{\n    public interface ITimelineService\n    {\n        Task<bool> LogNoteAddedAsync(CRMTimelineLogDto dto);\n        Task<bool> LogReminderSetAsync(CRMTimelineLogDto dto);\n        Task<bool> LogTagAppliedAsync(CRMTimelineLogDto dto);\n\n        // âœ… NEW\n        Task<bool> LogReminderUpdatedAsync(CRMTimelineLogDto dto);\n        Task<bool> LogReminderDeletedAsync(CRMTimelineLogDto dto);\n\n        Task<bool> LogTagRemovedAsync(CRMTimelineLogDto dto);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Timelines/Services/LeadTimelineService.cs",
      "sha256": "509c3bc3cf8d36b9acac08b54bf211a5992bb367934df75327f233af36eb9333",
      "language": "csharp",
      "size": 7570,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing xbytechat.api.Features.Catalog.Models;\nusing static xbytechat.api.Features.BusinessModule.Models.Business;\nusing System.Text.Json;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Features.PlanManagement.Models;\nusing xbytechat.api.Features.CRM.Timelines.DTOs;\nusing xbytechat.api.Features.CRM.Timelines.Models;\n\n\nnamespace xbytechat.api.Features.CRM.Timelines.Services\n{\n    public class LeadTimelineService : ILeadTimelineService\n    {\n        private readonly AppDbContext _context;\n\n\n        public LeadTimelineService(AppDbContext context)\n        {\n            _context = context;\n\n        }\n\n        public async Task<LeadTimeline> AddTimelineEntryAsync(LeadTimelineDto dto)\n        {\n            try\n            {\n                var entry = new LeadTimeline\n                {\n                    ContactId = dto.ContactId,\n                    EventType = dto.EventType,\n                    Description = dto.Description,\n                    Data = dto.Data,\n                    ReferenceId = dto.ReferenceId,\n                    IsSystemGenerated = dto.IsSystemGenerated,\n                    CreatedBy = dto.CreatedBy,\n                    Source = dto.Source,\n                    Category = dto.Category,\n                    CreatedAt = DateTime.UtcNow\n                };\n\n                _context.LeadTimelines.Add(entry);\n                await _context.SaveChangesAsync();\n\n                Log.Information(\"âœ… Timeline entry added for ContactId: {ContactId}\", dto.ContactId);\n\n                return entry;\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"âŒ Error adding timeline entry for ContactId: {ContactId}\", dto.ContactId);\n                throw; // Let global middleware handle this\n            }\n        }\n\n        public async Task<List<LeadTimeline>> GetTimelineByContactIdAsync(Guid contactId)\n        {\n            try\n            {\n                var results = await _context.LeadTimelines\n                    .Where(x => x.ContactId == contactId)\n                    .OrderByDescending(x => x.CreatedAt)\n                    .ToListAsync();\n\n                Log.Information(\"ðŸ“„ Fetched {Count} timeline entries for ContactId: {ContactId}\", results.Count, contactId);\n\n                return results;\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"âŒ Failed to fetch timeline for ContactId: {ContactId}\", contactId);\n                throw;\n            }\n        }\n\n        public async Task<List<LeadTimelineDto>> GetAllTimelinesAsync()\n        {\n            try\n            {\n                var entries = await _context.LeadTimelines\n                    .Include(t => t.Contact) // for Contact Name/Phone\n                    .OrderByDescending(e => e.CreatedAt)\n                    .ToListAsync();\n\n                var dtoList = entries.Select(entry => new LeadTimelineDto\n                {\n                    ContactId = entry.ContactId,\n                    EventType = entry.EventType,\n                    Description = entry.Description,\n                    Data = entry.Data,\n                    ReferenceId = entry.ReferenceId,\n                    CreatedAt = entry.CreatedAt,\n                    CreatedBy = entry.CreatedBy,\n                    Source = entry.Source,\n                    Category = entry.Category,\n                    IsSystemGenerated = entry.IsSystemGenerated,\n                    ContactName = entry.Contact?.Name,\n                    ContactNumber = entry.Contact?.PhoneNumber\n                }).ToList();\n\n                Log.Information(\"ðŸ“„ Loaded {Count} total timeline entries\", dtoList.Count);\n                return dtoList;\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"âŒ Failed to fetch all timeline entries\");\n                throw;\n            }\n        }\n        public async Task AddFromCatalogClickAsync(CatalogClickLog log)\n        {\n            if (log == null)\n            {\n                Log.Warning(\"CatalogClickLog is null. Skipping timeline creation.\");\n                return;\n            }\n\n            try\n            {\n                var business = await _context.Businesses\n                    .AsNoTracking()\n                    .FirstOrDefaultAsync(b => b.Id == log.BusinessId);\n\n                if (business == null)\n                {\n                    Log.Warning(\"Business not found for ID: {BusinessId}. Skipping timeline creation.\", log.BusinessId);\n                    return;\n                }\n\n                // if (business.Plan == PlanType.Advanced)\n                if (business?.BusinessPlanInfo?.Plan == PlanType.Advanced)\n                {\n                    Log.Information(\"Timeline skipped for Basic Plan - BusinessId: {BusinessId}\", business.Id);\n                    return;\n                }\n\n\n                var description = $\"{log.ProductBrowsed} | {log.CTAJourney}\";\n\n                var timelineEntry = new LeadTimeline\n                {\n                    BusinessId = log.BusinessId,\n                    ContactId = log.ContactId ?? Guid.Empty,\n                    EventType = \"CatalogCTA\",\n                    Description = description,\n                    Data = JsonSerializer.Serialize(log),\n                    ReferenceId = null,\n                    CreatedBy = \"system\",\n                    IsSystemGenerated = true,\n                    Source = \"Catalog\",\n                    Category = log.CategoryBrowsed,\n                    CreatedAt = DateTime.UtcNow\n                };\n\n                _context.LeadTimelines.Add(timelineEntry);\n                await _context.SaveChangesAsync();\n\n                Log.Information(\"ðŸ“ˆ Timeline entry created from CatalogClick for UserId: {UserId}\", log.UserId);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"âŒ Error creating timeline entry from CatalogClick for UserId: {UserId}\", log.UserId);\n                // Safe swallow\n            }\n        }\n\n        public async Task<ResponseResult> LogCampaignSendAsync(CampaignTimelineLogDto dto)\n        {\n            try\n            {\n                var timeline = new LeadTimeline\n                {\n                    ContactId = dto.ContactId,\n                    BusinessId = dto.BusinessId,\n                    EventType = \"CampaignSend\",\n                    Description = $\"Campaign '{dto.CampaignName}' was sent.\", // âœ… Timeline me readable text\n                    ReferenceId = dto.CampaignId, // âœ… Linking to campaign record\n                    IsSystemGenerated = false,    // âœ… Default (campaign sending is manual action)\n                    CreatedBy = \"system\",         // âœ… Or actual user email if needed later\n                    Source = \"CampaignModule\",    // âœ… Source field for clarity\n                    Category = \"Messaging\",       // âœ… Logical grouping\n                    CreatedAt = dto.Timestamp ?? DateTime.UtcNow // âœ… Use given Timestamp or fallback to now\n                };\n\n                _context.LeadTimelines.Add(timeline);\n                await _context.SaveChangesAsync();\n\n                return ResponseResult.SuccessInfo(\"âœ… Campaign send event logged into timeline.\");\n            }\n            catch (Exception ex)\n            {\n                return ResponseResult.ErrorInfo(\"âŒ Failed to log campaign send event: \" + ex.Message);\n            }\n        }\n\n\n    }\n\n\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Timelines/Services/TimelineService.cs",
      "sha256": "5f40e44e792c09c3d4559a8a17a1f533efddc038381124a08cbbbd0a0e002ba6",
      "language": "csharp",
      "size": 3044,
      "content": "using xbytechat.api.Features.CRM.Timelines.DTOs;\nusing xbytechat.api.Features.CRM.Timelines.Models;\n\nnamespace xbytechat.api.Features.CRM.Timelines.Services\n{\n    public class TimelineService : ITimelineService\n    {\n        private readonly AppDbContext _context;\n\n        public TimelineService(AppDbContext context)\n        {\n            _context = context;\n        }\n\n        public async Task<bool> LogNoteAddedAsync(CRMTimelineLogDto dto)\n            => await InsertAsync(dto, \"NoteAdded\", dto.Description);\n\n        public async Task<bool> LogReminderSetAsync(CRMTimelineLogDto dto)\n            => await InsertAsync(dto, \"ReminderSet\", dto.Description);\n\n        public async Task<bool> LogTagAppliedAsync(CRMTimelineLogDto dto)\n            => await InsertAsync(dto, \"TagApplied\", dto.Description);\n\n        // âœ… NEW\n        public async Task<bool> LogReminderUpdatedAsync(CRMTimelineLogDto dto)\n            => await InsertAsync(dto, \"ReminderUpdated\", dto.Description);\n\n        // âœ… NEW\n        public async Task<bool> LogReminderDeletedAsync(CRMTimelineLogDto dto)\n            => await InsertAsync(dto, \"ReminderDeleted\", dto.Description);\n\n        private async Task<bool> InsertAsync(CRMTimelineLogDto dto, string eventType, string description)\n        {\n            try\n            {\n                var timeline = new LeadTimeline\n                {\n                    ContactId = dto.ContactId,\n                    BusinessId = dto.BusinessId,\n                    EventType = eventType,\n                    Description = description,\n                    ReferenceId = dto.ReferenceId,\n                    CreatedBy = dto.CreatedBy,\n                    Source = \"CRM\",\n                    Category = dto.Category ?? \"CRM\",\n                    CreatedAt = dto.Timestamp ?? DateTime.UtcNow,\n                    IsSystemGenerated = false\n                };\n\n                _context.LeadTimelines.Add(timeline);\n                await _context.SaveChangesAsync();\n                return true;\n            }\n            catch\n            {\n                return false;\n            }\n        }\n\n        public async Task<bool> LogTagRemovedAsync(CRMTimelineLogDto dto)\n        {\n            try\n            {\n                var timeline = new LeadTimeline\n                {\n                    ContactId = dto.ContactId,\n                    BusinessId = dto.BusinessId,\n                    EventType = \"TagRemoved\",\n                    Description = dto.Description,\n                    ReferenceId = dto.ReferenceId,\n                    CreatedBy = dto.CreatedBy,\n                    Source = \"CRM\",\n                    Category = dto.Category ?? \"CRM\",\n                    CreatedAt = dto.Timestamp ?? DateTime.UtcNow,\n                    IsSystemGenerated = false\n                };\n\n                _context.LeadTimelines.Add(timeline);\n                await _context.SaveChangesAsync();\n                return true;\n            }\n            catch\n            {\n                return false;\n            }\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CrmAnalytics/Controllers/CrmAnalyticsController.cs",
      "sha256": "9148ea0201bfa24665b2fc92339cec7f58019baa66443aba80189bc1a4c9c833",
      "language": "csharp",
      "size": 1948,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CrmAnalytics.Services;\nusing xbytechat.api.Shared;\nusing System.Security.Claims;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.CrmAnalytics.Controllers\n{\n    /// <summary>\n    /// Handles CRM analytics summary and trends.\n    /// </summary>\n    [ApiController]\n    [Route(\"api/crm\")]\n    public class CrmAnalyticsController : ControllerBase\n    {\n        private readonly ICrmAnalyticsService _crmAnalyticsService;\n\n        public CrmAnalyticsController(ICrmAnalyticsService crmAnalyticsService)\n        {\n            _crmAnalyticsService = crmAnalyticsService;\n        }\n\n        /// <summary>\n        /// Returns dashboard summary stats for the CRM.\n        /// </summary>\n        [HttpGet(\"summary\")]\n        public async Task<IActionResult> GetSummary()\n        {\n            var businessId = GetBusinessIdFromContext();\n            var result = await _crmAnalyticsService.GetSummaryAsync(businessId);\n            return Ok(ResponseResult.SuccessInfo(\"ðŸ“Š CRM analytics loaded successfully.\", result));\n        }\n\n        /// <summary>\n        /// Returns contacts-added-over-time trend for graph.\n        /// </summary>\n        [HttpGet(\"trends/contacts\")]\n        public async Task<IActionResult> GetContactTrends()\n        {\n            var businessId = GetBusinessIdFromContext();\n            var result = await _crmAnalyticsService.GetContactTrendsAsync(businessId);\n            return Ok(ResponseResult.SuccessInfo(\"ðŸ“ˆ Contact trends loaded successfully.\", result));\n        }\n\n        /// <summary>\n        /// Extracts the businessId (Guid) from current user claims.\n        /// </summary>\n        private Guid GetBusinessIdFromContext()\n        {\n            return Guid.TryParse(HttpContext.User.FindFirst(\"BusinessId\")?.Value, out var id)\n                ? id\n                : Guid.Empty;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CrmAnalytics/DTOs/ContactTrendsDto.cs",
      "sha256": "132d9271e14f9c3f2a65c9241917f67bc8129c91c7050c86a67df545c68419bc",
      "language": "csharp",
      "size": 362,
      "content": "namespace xbytechat.api.Features.CrmAnalytics.DTOs\n{\n    /// <summary>\n    /// Represents the number of contacts added on a specific date.\n    /// Used for trend charting on the CRM dashboard.\n    /// </summary>\n    public class ContactTrendsDto\n    {\n        public string Date { get; set; } // Format: yyyy-MM-dd\n        public int Count { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CrmAnalytics/DTOs/CrmAnalyticsSummaryDto.cs",
      "sha256": "73027ff6ddc0b680b03714267bbf642053cdc28f2d97c16b593a3321186ab9d9",
      "language": "csharp",
      "size": 619,
      "content": "namespace xbytechat.api.Features.CrmAnalytics.DTOs\n{\n    public class CrmAnalyticsSummaryDto\n    {\n        public int TotalContacts { get; set; }\n        public int TaggedContacts { get; set; }\n        public int ActiveReminders { get; set; }\n        public int CompletedReminders { get; set; }\n        public int TotalNotes { get; set; }\n        public int LeadsWithTimeline { get; set; }\n        public int NewContactsToday { get; set; }\n        public int NotesAddedToday { get; set; }\n        public DateTime? LastContactAddedAt { get; set; }\n        public DateTime? LastReminderCompletedAt { get; set; }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CrmAnalytics/Services/CrmAnalyticsService.cs",
      "sha256": "8fae1f725576dc5f6402559df557282ba8991f65bb324b614a65b4e9225167c5",
      "language": "csharp",
      "size": 4014,
      "content": "using System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.CrmAnalytics.DTOs;\nusing xbytechat.api.Features.CrmAnalytics.Services;\n\nnamespace xbytechat.api.Features.CrmAnalytics.Services\n{\n    /// <summary>\n    /// Provides implementation for CRM analytics calculations.\n    /// Gathers contact, tag, note, and reminder metrics for the dashboard.\n    /// </summary>\n    public class CrmAnalyticsService : ICrmAnalyticsService\n    {\n        private readonly AppDbContext _context;\n\n        public CrmAnalyticsService(AppDbContext context)\n        {\n            _context = context;\n        }\n\n        /// <summary>\n        /// Generates a summarized snapshot of CRM data for the given business.\n        /// </summary>\n        /// <param name=\"businessId\">The unique ID of the business</param>\n        /// <returns>CrmAnalyticsSummaryDto containing insights</returns>\n        public async Task<CrmAnalyticsSummaryDto> GetSummaryAsync(Guid businessId)\n        {\n            var today = DateTime.UtcNow.Date;\n\n            var totalContacts = await _context.Contacts\n                .CountAsync(c => c.BusinessId == businessId);\n\n            var taggedContacts = await _context.Contacts\n                .Where(c => c.BusinessId == businessId && c.Tags.Any())\n                .CountAsync();\n\n            var activeReminders = await _context.Reminders\n                .CountAsync(r => r.BusinessId == businessId && r.Status == \"Pending\");\n\n            var completedReminders = await _context.Reminders\n                .CountAsync(r => r.BusinessId == businessId && r.Status == \"Completed\");\n\n            var totalNotes = await _context.Notes\n                .CountAsync(n => n.BusinessId == businessId);\n\n            var leadsWithTimeline = await _context.LeadTimelines\n                .Where(t => t.BusinessId == businessId)\n                .Select(t => t.ContactId)\n                .Distinct()\n                .CountAsync();\n\n            var newContactsToday = await _context.Contacts\n                .CountAsync(c => c.BusinessId == businessId && c.CreatedAt.Date == today);\n\n            var notesAddedToday = await _context.Notes\n                .CountAsync(n => n.BusinessId == businessId && n.CreatedAt.Date == today);\n\n            var lastContactAddedAt = await _context.Contacts\n                .Where(c => c.BusinessId == businessId)\n                .OrderByDescending(c => c.CreatedAt)\n                .Select(c => (DateTime?)c.CreatedAt)\n                .FirstOrDefaultAsync();\n\n            var lastReminderCompletedAt = await _context.Reminders\n                .Where(r => r.BusinessId == businessId && r.Status == \"Completed\")\n                .OrderByDescending(r => r.CompletedAt)\n                .Select(r => (DateTime?)r.CompletedAt)\n                .FirstOrDefaultAsync();\n\n            return new CrmAnalyticsSummaryDto\n            {\n                TotalContacts = totalContacts,\n                TaggedContacts = taggedContacts,\n                ActiveReminders = activeReminders,\n                CompletedReminders = completedReminders,\n                TotalNotes = totalNotes,\n                LeadsWithTimeline = leadsWithTimeline,\n                NewContactsToday = newContactsToday,\n                NotesAddedToday = notesAddedToday,\n                LastContactAddedAt = lastContactAddedAt,\n                LastReminderCompletedAt = lastReminderCompletedAt\n            };\n        }\n        public async Task<List<ContactTrendsDto>> GetContactTrendsAsync(Guid businessId)\n        {\n            var trends = await _context.Contacts\n                .Where(c => c.BusinessId == businessId)\n                .GroupBy(c => c.CreatedAt.Date)\n                .OrderBy(g => g.Key)\n                .Select(g => new ContactTrendsDto\n                {\n                    Date = g.Key.ToString(\"yyyy-MM-dd\"),\n                    Count = g.Count()\n                })\n                .ToListAsync();\n\n            return trends;\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CrmAnalytics/Services/ICrmAnalyticsService.cs",
      "sha256": "24d70810ed26415792ab48592900090d8d1b7682d926e46f4bdc4595b24c5659",
      "language": "csharp",
      "size": 895,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.CrmAnalytics.DTOs;\n\nnamespace xbytechat.api.Features.CrmAnalytics.Services\n{\n    /// <summary>\n    /// Defines the contract for CRM Analytics services.\n    /// Handles lead-level analytics, summary metrics, and dashboard insights.\n    /// </summary>\n    public interface ICrmAnalyticsService\n    {\n        /// <summary>\n        /// Returns a summarized view of CRM statistics for a specific business.\n        /// This is used to power the CRM analytics dashboard.\n        /// </summary>\n        /// <param name=\"businessId\">The unique identifier of the business (tenant).</param>\n        /// <returns>A summary DTO containing contact, tag, note, and reminder insights.</returns>\n        Task<CrmAnalyticsSummaryDto> GetSummaryAsync(Guid businessId);\n        Task<List<ContactTrendsDto>> GetContactTrendsAsync(Guid businessId);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CsvModule/CsvBatchValidationController.cs",
      "sha256": "daf00037fbe7c0f74272fe6dd650de7918d6f2f9a1bf91e40b01039a0e04f9cc",
      "language": "csharp",
      "size": 7225,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.Json;\nusing System.Text.RegularExpressions;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api;\nusing xbytechat.api.Shared;\nusing xbytechat_api.WhatsAppSettings.Services; // User.GetBusinessId()\n\nnamespace xbytechat.api.Features.CsvModule.Controllers\n{\n    [ApiController]\n    [Route(\"api/csv/batch/{batchId:guid}/validate\")]\n    [Authorize]\n    public sealed class CsvBatchValidationController : ControllerBase\n    {\n        private readonly AppDbContext _db;\n        public CsvBatchValidationController(AppDbContext db) => _db = db;\n\n        public sealed class ValidateRequest\n        {\n            public string? PhoneHeader { get; set; }              // e.g. \"phone\"\n            public List<string>? RequiredHeaders { get; set; }    // e.g. [\"parameter1\",\"headerpara1\",\"buttonpara1\"]\n            public bool NormalizePhone { get; set; } = true;\n            public bool CheckDuplicates { get; set; } = true;\n            public int? Limit { get; set; }                       // optional sample cap\n        }\n\n        public sealed class ValidateResponse\n        {\n            public bool Success { get; set; } = true;\n            public List<string> Problems { get; set; } = new();\n            public object Stats { get; set; } = new { rows = 0, missingPhone = 0, invalidPhones = 0, duplicatePhones = 0 };\n            public List<string> Headers { get; set; } = new();    // discovered headers in the batch\n        }\n\n        [HttpPost]\n        public async Task<IActionResult> Validate(Guid batchId, [FromBody] ValidateRequest req, CancellationToken ct = default)\n        {\n            var businessId = User.GetBusinessId();\n            if (businessId == Guid.Empty) return Unauthorized();\n\n            // Load CSV rows for this batch (owned by business)\n            var rowsQ = _db.CsvRows\n                .AsNoTracking()\n                .Where(r => r.BusinessId == businessId && r.BatchId == batchId)\n                .OrderBy(r => r.RowIndex);\n\n            var total = await rowsQ.CountAsync(ct);\n            if (total == 0)\n                return Ok(new ValidateResponse\n                {\n                    Problems = new List<string> { \"CSV batch is empty.\" },\n                    Stats = new { rows = 0, missingPhone = 0, invalidPhones = 0, duplicatePhones = 0 },\n                    Headers = new List<string>()\n                });\n\n            var rows = req.Limit.HasValue && req.Limit.Value > 0\n                ? await rowsQ.Take(req.Limit.Value).ToListAsync(ct)\n                : await rowsQ.ToListAsync(ct);\n\n            // Discover header set by union of row keys (case-insensitive compare)\n            var headerSet = new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n            foreach (var r in rows)\n                foreach (var k in KeysOfJson(r.DataJson))\n                    headerSet.Add(k);\n\n            var headers = headerSet.OrderBy(x => x, StringComparer.OrdinalIgnoreCase).ToList();\n\n            var problems = new List<string>();\n\n            // Validate phone header presence\n            var phoneHeader = (req.PhoneHeader ?? \"\").Trim();\n            if (string.IsNullOrWhiteSpace(phoneHeader))\n            {\n                // Try helpful guesses\n                var guesses = new[] { \"phone\", \"mobile\", \"whatsapp\", \"number\", \"phonee164\", \"msisdn\", \"whatsapp_number\" };\n                var guess = guesses.FirstOrDefault(h => headerSet.Contains(h));\n                if (!string.IsNullOrEmpty(guess))\n                    phoneHeader = guess;\n            }\n\n            if (string.IsNullOrWhiteSpace(phoneHeader))\n            {\n                problems.Add(\"Phone column not specified and could not be guessed.\");\n            }\n            else if (!headerSet.Contains(phoneHeader))\n            {\n                problems.Add($\"Phone column â€œ{phoneHeader}â€ not found in CSV.\");\n            }\n\n            // Validate requiredHeaders presence (parameterN/headerparaN/buttonparaN)\n            var required = req.RequiredHeaders ?? new List<string>();\n            foreach (var h in required)\n            {\n                if (!headerSet.Contains(h))\n                    problems.Add($\"Required column â€œ{h}â€ is missing.\");\n            }\n\n            // Row-level checks\n            int missingPhone = 0, invalidPhones = 0, duplicatePhones = 0;\n            var seen = new HashSet<string>(StringComparer.Ordinal);\n\n            foreach (var r in rows)\n            {\n                var dict = JsonToDict(r.DataJson);\n\n                // phone\n                string? rawPhone = null;\n                if (!string.IsNullOrWhiteSpace(phoneHeader))\n                    dict.TryGetValue(phoneHeader, out rawPhone);\n\n                var normPhone = NormalizePhoneMaybe(rawPhone, req.NormalizePhone);\n                if (string.IsNullOrWhiteSpace(normPhone))\n                {\n                    missingPhone++;\n                    continue;\n                }\n\n                // naive validity check\n                if (!Regex.IsMatch(normPhone, @\"^\\d{10,15}$\"))\n                {\n                    invalidPhones++;\n                }\n\n                if (req.CheckDuplicates && !seen.Add(normPhone))\n                {\n                    duplicatePhones++;\n                }\n            }\n\n            var resp = new ValidateResponse\n            {\n                Problems = problems,\n                Stats = new { rows = total, missingPhone, invalidPhones, duplicatePhones },\n                Headers = headers\n            };\n\n            return Ok(resp);\n        }\n\n        // ---------- helpers ----------\n        private static IEnumerable<string> KeysOfJson(string? json)\n        {\n            if (string.IsNullOrWhiteSpace(json)) yield break;\n            using var doc = JsonDocument.Parse(json);\n            if (doc.RootElement.ValueKind != JsonValueKind.Object) yield break;\n            foreach (var p in doc.RootElement.EnumerateObject())\n                yield return p.Name;\n        }\n\n        private static Dictionary<string, string> JsonToDict(string? json)\n        {\n            var dict = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n            if (string.IsNullOrWhiteSpace(json)) return dict;\n            using var doc = JsonDocument.Parse(json);\n            if (doc.RootElement.ValueKind != JsonValueKind.Object) return dict;\n            foreach (var p in doc.RootElement.EnumerateObject())\n                dict[p.Name] = p.Value.ValueKind == JsonValueKind.Null ? \"\" : p.Value.ToString();\n            return dict;\n        }\n\n        private static string? NormalizePhoneMaybe(string? raw, bool normalize)\n        {\n            if (string.IsNullOrWhiteSpace(raw)) return null;\n            var trimmed = raw.Trim();\n            if (!normalize) return trimmed;\n\n            // simple E.164-ish cleanup\n            var digits = Regex.Replace(trimmed, \"[^0-9]\", \"\");\n            digits = digits.TrimStart('0');\n            if (digits.Length == 10) digits = \"91\" + digits; // heuristic India\n            return digits;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Controllers/CTAFlowController.cs",
      "sha256": "941d3a884c221e0a18355505ebd681462d87259abca4e801e091070410f16d21",
      "language": "csharp",
      "size": 9864,
      "content": "using Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Serilog;\nusing xbytechat.api.Features.CTAFlowBuilder.DTOs;\nusing xbytechat.api.Features.CTAFlowBuilder.Services;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Controllers\n{\n    [Authorize]\n    [ApiController]\n    [Route(\"api/cta-flow\")]\n    public class CTAFlowController : ControllerBase\n    {\n        private readonly ICTAFlowService _flowService;\n\n        public CTAFlowController(ICTAFlowService flowService)\n        {\n            _flowService = flowService;\n        }\n\n        // CREATE (draft-only)\n        [HttpPost(\"save-visual\")]\n        public async Task<IActionResult> SaveVisualFlow([FromBody] SaveVisualFlowDto dto)\n        {\n            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n            var createdBy = User.FindFirst(\"name\")?.Value ?? \"system\";\n            if (!Guid.TryParse(businessIdClaim, out var businessId))\n                return BadRequest(new { message = \"âŒ Invalid business ID\" });\n\n            Log.Information(\"ðŸ“¦ Saving CTA Flow: {FlowName} by {User}\", dto.FlowName, createdBy);\n\n            var result = await _flowService.SaveVisualFlowAsync(dto, businessId, createdBy);\n            if (!result.Success)\n            {\n                var m = (result.ErrorMessage ?? \"\").Trim();\n\n                // map common validation/conflict by message text (no result.Code available)\n                if (m.Contains(\"already exists\", StringComparison.OrdinalIgnoreCase))\n                    return Conflict(new { message = \"âŒ Duplicate flow name\", error = m });\n\n                if (m.Contains(\"required\", StringComparison.OrdinalIgnoreCase) ||\n                    m.Contains(\"empty flow\", StringComparison.OrdinalIgnoreCase) ||\n                    m.Contains(\"invalid\", StringComparison.OrdinalIgnoreCase))\n                    return BadRequest(new { message = \"âŒ Failed to save flow\", error = m });\n\n                return StatusCode(StatusCodes.Status500InternalServerError,\n                    new { message = \"âŒ Failed to save flow\", error = string.IsNullOrWhiteSpace(m) ? \"Unknown error\" : m });\n            }\n\n            Guid? flowId = null;\n            if (result.Data is not null)\n            {\n                try { dynamic d = result.Data; flowId = (Guid?)d.flowId; } catch { }\n            }\n\n            return Ok(new { message = \"âœ… Flow saved successfully\", flowId });\n        }\n\n        // UPDATE (save as draft by id)\n        [HttpPut(\"{id:guid}\")]\n        public async Task<IActionResult> Update(Guid id, [FromBody] SaveVisualFlowDto dto)\n        {\n            var biz = User.FindFirst(\"businessId\")?.Value;\n            var user = User.FindFirst(\"name\")?.Value ?? \"system\";\n            if (!Guid.TryParse(biz, out var businessId))\n                return BadRequest(new { message = \"âŒ Invalid business.\" });\n\n            var result = await _flowService.UpdateVisualFlowAsync(id, dto, businessId, user);\n\n            return result.Status switch\n            {\n                \"notFound\" => NotFound(new { message = result.Message ?? \"âŒ Flow not found.\" }),\n                \"requiresFork\" => Conflict(new { message = result.Message ?? \"âŒ Edit requires fork.\", campaigns = result.Campaigns }),\n                \"error\" => BadRequest(new { message = result.Message ?? \"âŒ Failed to update flow.\" }),\n                _ => Ok(new { message = result.Message ?? \"âœ… Flow updated (draft).\", needsRepublish = result.NeedsRepublish })\n            };\n        }\n\n        // FORK (create a new draft copy)\n        [HttpPost(\"{id:guid}/fork\")]\n        public async Task<IActionResult> Fork(Guid id)\n        {\n            var biz = User.FindFirst(\"businessId\")?.Value;\n            var user = User.FindFirst(\"name\")?.Value ?? \"system\";\n            if (!Guid.TryParse(biz, out var businessId))\n                return BadRequest(new { message = \"âŒ Invalid business.\" });\n\n            var forkId = await _flowService.ForkFlowAsync(id, businessId, user);\n            if (forkId == Guid.Empty) return NotFound(new { message = \"âŒ Flow not found.\" });\n\n            return Ok(new { flowId = forkId });\n        }\n\n        // PUBLISH (by id)\n        [HttpPost(\"{id:guid}/publish\")]\n        public async Task<IActionResult> Publish(Guid id)\n        {\n            var biz = User.FindFirst(\"businessId\")?.Value;\n            var user = User.FindFirst(\"name\")?.Value ?? \"system\";\n            if (!Guid.TryParse(biz, out var businessId))\n                return BadRequest(new { message = \"âŒ Invalid business.\" });\n\n            var result = await _flowService.PublishFlowAsync(id, businessId, user);\n\n            if (result.Success)\n                return Ok(new { message = result.Message ?? \"âœ… Flow published.\" });\n\n            var msg = (result.ErrorMessage ?? result.Message ?? \"âŒ Failed to publish.\").Trim();\n\n            if (result.Code == 404)\n                return NotFound(new { message = msg });\n\n            // Validation failures return 400 with details in payload (issue list)\n            if (result.Code == 400)\n                return BadRequest(new { message = msg, issues = result.Payload });\n\n            return BadRequest(new { message = msg });\n        }\n\n        // DELETE (only if not attached)\n        [HttpDelete(\"{id:guid}\")]\n        public async Task<IActionResult> Delete(Guid id)\n        {\n            var biz = User.FindFirst(\"businessId\")?.Value;\n            if (!Guid.TryParse(biz, out var businessId))\n                return BadRequest(new { message = \"âŒ Invalid business.\" });\n\n            var deletedBy = User.FindFirst(\"name\")?.Value\n                          ?? User.FindFirst(\"email\")?.Value\n                          ?? User.FindFirst(\"sub\")?.Value\n                          ?? \"system\";\n\n            var result = await _flowService.DeleteFlowAsync(id, businessId, deletedBy);\n\n            if (!result.Success)\n            {\n                var msg = (result.ErrorMessage ?? result.Message ?? string.Empty).Trim();\n\n                // If message says it's attached, return 409 and include campaigns for the modal\n                if (msg.Contains(\"attached\", StringComparison.OrdinalIgnoreCase) ||\n                    msg.Contains(\"Cannot delete\", StringComparison.OrdinalIgnoreCase))\n                {\n                    var campaigns = await _flowService.GetAttachedCampaignsAsync(id, businessId);\n                    return Conflict(new { message = msg, campaigns });\n                }\n\n                if (msg.Contains(\"not found\", StringComparison.OrdinalIgnoreCase))\n                    return NotFound(new { message = msg });\n\n                return BadRequest(new { message = string.IsNullOrWhiteSpace(msg) ? \"Delete failed.\" : msg });\n            }\n\n            return Ok(new { message = result.Message ?? \"âœ… Flow deleted.\" });\n        }\n\n        // LISTS\n        [HttpGet(\"all-published\")]\n        public async Task<IActionResult> GetPublishedFlows()\n        {\n            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n            if (!Guid.TryParse(businessIdClaim, out var businessId))\n                return BadRequest(new { message = \"âŒ Invalid business ID\" });\n\n            var flows = await _flowService.GetAllPublishedFlowsAsync(businessId);\n            return Ok(flows);\n        }\n\n        [HttpGet(\"all-draft\")]\n        public async Task<IActionResult> GetAllDraftFlows()\n        {\n            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n            if (!Guid.TryParse(businessIdClaim, out var businessId))\n                return BadRequest(new { message = \"âŒ Invalid business ID\" });\n\n            var flows = await _flowService.GetAllDraftFlowsAsync(businessId);\n            return Ok(flows);\n        }\n\n        // DETAIL\n        [HttpGet(\"by-id/{id:guid}\")]\n        public async Task<IActionResult> GetById(Guid id)\n        {\n            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n            if (!Guid.TryParse(businessIdClaim, out var businessId))\n                return BadRequest(new { message = \"âŒ Invalid business ID\" });\n\n            var dto = await _flowService.GetVisualFlowByIdAsync(id, businessId);\n            if (dto is null) return NotFound(new { message = \"âŒ Flow not found.\" });\n\n            return Ok(dto);\n        }\n\n        [HttpGet(\"visual/{id:guid}\")]\n        public async Task<IActionResult> GetVisualFlow(Guid id)\n        {\n            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n            if (!Guid.TryParse(businessIdClaim, out var businessId))\n                return BadRequest(new { message = \"âŒ Invalid business ID\" });\n\n            var result = await _flowService.GetVisualFlowAsync(id, businessId);\n            if (!result.Success)\n            {\n                var m = (result.ErrorMessage ?? string.Empty).Trim();\n                if (m.Contains(\"not found\", StringComparison.OrdinalIgnoreCase))\n                    return NotFound(new { message = \"âŒ Failed to load flow\", error = m });\n\n                return StatusCode(StatusCodes.Status500InternalServerError,\n                    new { message = \"âŒ Failed to load flow\", error = string.IsNullOrWhiteSpace(m) ? \"Unknown error\" : m });\n            }\n\n            return Ok(result.Data);\n        }\n\n        // USAGE (for delete guard)\n        [HttpGet(\"{id:guid}/usage\")]\n        public async Task<IActionResult> GetUsage(Guid id)\n        {\n            var biz = User.FindFirst(\"businessId\")?.Value;\n            if (!Guid.TryParse(biz, out var businessId))\n                return BadRequest(new { message = \"Invalid business.\" });\n\n            var campaigns = await _flowService.GetAttachedCampaignsAsync(id, businessId);\n            return Ok(new\n            {\n                canDelete = campaigns.Count == 0,\n                count = campaigns.Count,\n                campaigns\n            });\n        }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Controllers/FlowRedirectController.cs",
      "sha256": "8d5442a0a0fdb92dc7d69837cd74af882b22c6cf35ce999a7b87bfde5b27e7ca",
      "language": "csharp",
      "size": 2686,
      "content": "// ðŸ“„ Features/CTAFlowBuilder/Controllers/FlowRedirectController.cs\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Infrastructure.Flows;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\nusing xbytechat.api.Features.CTAFlowBuilder.Services;\nusing Microsoft.AspNetCore.Authorization;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Controllers\n{\n    [ApiController]\n    [Route(\"r/flow\")]\n    public class FlowRedirectController : ControllerBase\n    {\n        private readonly IFlowClickTokenService _tokens;\n        private readonly ICTAFlowService _flows;           // service to read flow steps/links\n        private readonly IFlowRuntimeService _runtime;     // service to execute next step\n\n        public FlowRedirectController(\n            IFlowClickTokenService tokens,\n            ICTAFlowService flows,\n            IFlowRuntimeService runtime)\n        {\n            _tokens = tokens;\n            _flows = flows;\n            _runtime = runtime;\n        }\n\n        [HttpGet(\"{token}\")]\n        [AllowAnonymous] // secure by token, tenant checks inside\n        public async Task<IActionResult> RedirectByToken(string token)\n        {\n            FlowClickPayload p;\n            try\n            {\n                p = _tokens.Validate(token);\n            }\n            catch (Exception ex)\n            {\n                return BadRequest($\"Invalid or expired token: {ex.Message}\");\n            }\n\n            // ðŸ”’ Tenant isolation: make sure the business in the token matches the current request context\n            // (if you have multi-tenant enforcement middleware, call it here)\n\n            // 1) Resolve the button link\n            var link = await _flows.GetLinkAsync(p.fid, p.sid, p.bi);\n            if (link is null)\n                return NotFound(\"Link not found for this flow step\");\n\n            var requestId = Guid.NewGuid(); // for idempotency\n            var exec = await _runtime.ExecuteNextAsync(new NextStepContext\n            {\n                BusinessId = p.biz,\n                FlowId = p.fid,\n                Version = p.ver,\n                SourceStepId = p.sid,\n                TargetStepId = link.NextStepId, // may be null â†’ terminal\n                ButtonIndex = p.bi,\n                MessageLogId = p.mlid,\n                ContactPhone = p.cp,\n                RequestId = requestId,\n\n                // ðŸ†• Pass the clicked button for runtime decision\n                ClickedButton = link\n            });\n\n\n            // 3) Redirect the user\n            // If button was a URL, use that; else go to a generic \"thank you\" page\n            var dest = exec.RedirectUrl ?? \"/thank-you\";\n            return Redirect(dest);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/AttachedCampaignDto.cs",
      "sha256": "0d3666aab91197bf746299620d01d22712744acbbcb28b0a787a8e399eaf123f",
      "language": "csharp",
      "size": 341,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public sealed record AttachedCampaignDto(\n        Guid Id,\n        string Name,\n        string Status,\n        DateTime? ScheduledAt,\n        DateTime CreatedAt,\n        string? CreatedBy,\n        DateTime? FirstSentAt   // earliest non-null SentAt from CampaignSendLogs\n    );\n\n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/CreateFlowDto.cs",
      "sha256": "c23400a06816a2adc8886fa8d20dd77f12b8b93f993b5a772d81cb12d6612a1f",
      "language": "csharp",
      "size": 897,
      "content": "// ðŸ“„ File: xbytechat.api/Features/CTAFlowBuilder/DTOs/CreateFlowDto.cs\nnamespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class CreateFlowDto\n    {\n        public string FlowName { get; set; } = string.Empty;\n        public List<FlowStepDto> Steps { get; set; } = new();\n        public bool IsPublished { get; set; } = false; // âœ… NEW: Draft vs Published\n    }\n\n    public class FlowStepDto\n    {\n        public string TriggerButtonText { get; set; } = string.Empty;\n        public string TriggerButtonType { get; set; } = string.Empty;\n        public string TemplateToSend { get; set; } = string.Empty;\n        public int StepOrder { get; set; }\n        public List<ButtonLinkDto> ButtonLinks { get; set; } = new();\n    }\n\n    public class ButtonLinkDto\n    {\n        public string ButtonText { get; set; } = string.Empty;\n        public Guid NextStepId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/CTAButtonClickDto.cs",
      "sha256": "da355d853887193eb1d2b3e3fafcf076e6df764f0220cbf10f5c050d42b91df6",
      "language": "csharp",
      "size": 432,
      "content": "using System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class CTAButtonClickDto\n    {\n        [Required]\n        public string ButtonText { get; set; } = string.Empty;\n\n        [Required]\n        public string ButtonType { get; set; } = \"cta\"; // e.g., \"quick_reply\", \"url\", etc.\n\n        [Required]\n        public string RecipientNumber { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/CTAFlowExecutionRequest.cs",
      "sha256": "43fc0e1c1674d188b1a5385539f1314176ff81449d4547ea6665df9909a223bb",
      "language": "csharp",
      "size": 297,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class CTAFlowExecutionRequest\n    {\n        public string ButtonText { get; set; } = string.Empty;\n        public string ButtonType { get; set; } = \"cta\";\n        public string RecipientNumber { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/CtaFlowRunResult.cs",
      "sha256": "2a042b3a78e66a762ca685c50cc13508c063fd3076e291597275bbc64620e6a1",
      "language": "csharp",
      "size": 433,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public sealed class CtaFlowRunResult\n    {\n        /// <summary>\n        /// True if the CTA flow was started/executed successfully.\n        /// </summary>\n        public bool Success { get; set; }\n\n        /// <summary>\n        /// Optional human-readable error message when Success = false.\n        /// </summary>\n        public string? ErrorMessage { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/FlowEdgeDto.cs",
      "sha256": "27e76e22a8aba502d5727d9959bec58ea011d2a1f0d4388a141bfa8108043eea",
      "language": "csharp",
      "size": 272,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class FlowEdgeDto\n    {\n        public string FromNodeId { get; set; } = string.Empty;\n        public string ToNodeId { get; set; } = string.Empty;\n        public string? SourceHandle { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/FlowNodeDto.cs",
      "sha256": "8f6c4dce253e5e1d8afba5c757038643eb14fc9e168c85cb2c9f5314d5b10834",
      "language": "csharp",
      "size": 1832,
      "content": "    namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class FlowNodeDto\n    {\n        public string Id { get; set; } = string.Empty;\n\n        public string TemplateName { get; set; } = string.Empty;\n        public string? TemplateType { get; set; } // âœ… e.g., \"image_template\", \"text_template\"\n\n        // For templates with a media header (image/video/document), this URL is required at runtime.\n        public string? HeaderMediaUrl { get; set; }\n\n        // Optional static values for BODY placeholders ({{1}},{{2}},...). Stored as a list where index 0 => {{1}}.\n        public List<string> BodyParams { get; set; } = new();\n\n        // Optional static values for dynamic URL button params. Index 0 => button index \"0\" (position 1).\n        // Only used when the template has URL buttons with ParameterValue like \"https://.../{{1}}\".\n        public List<string> UrlButtonParams { get; set; } = new();\n\n        public string MessageBody { get; set; } = string.Empty;\n        public string? TriggerButtonText { get; set; }\n        public string? TriggerButtonType { get; set; }\n        public float PositionX { get; set; }\n        public float PositionY { get; set; }\n\n        public string? RequiredTag { get; set; }         \n        public string? RequiredSource { get; set; }      \n        public List<LinkButtonDto> Buttons { get; set; } = new();\n        public bool UseProfileName { get; set; }\n        public int? ProfileNameSlot { get; set; }\n        //(for flow trigger mapping)\n        // âœ… NEW: ReactFlow expects this structure\n        public PositionDto Position => new PositionDto\n        {\n            x = PositionX,\n            y = PositionY\n        };\n        public class PositionDto\n        {\n            public float x { get; set; }\n            public float y { get; set; }\n        }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/FlowUpdateResult.cs",
      "sha256": "54f722166617e3353652e949aa4a89c87878d4a1d30d2e208a1fb816668d0dde",
      "language": "csharp",
      "size": 443,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public sealed class FlowUpdateResult\n    {\n        // ok | requiresFork | notFound | error\n        public string Status { get; set; } = \"ok\";\n        public string? Message { get; set; }\n        public bool NeedsRepublish { get; set; } // true when we flipped published->draft to allow editing\n        public object? Campaigns { get; set; }   // list for UI when requiresFork\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/LinkButtonDto.cs",
      "sha256": "e02e2c927a96e1e02c0537fb205fd7595289bdfaa9de15c0d7a55de64a90fbc5",
      "language": "csharp",
      "size": 522,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class LinkButtonDto\n    {\n        public string Text { get; set; } = string.Empty;\n        public int Index { get; set; } = -1;\n        public string? Type { get; set; } // ðŸ”¥ e.g., \"URL\", \"QUICK_REPLY\"\n        public string? SubType { get; set; } // ðŸ”¥ e.g., \"STATIC\", \"DYNAMIC\"\n        public string? Value { get; set; } // ðŸ”¥ the parameter or url or payload\n\n        public string? TargetNodeId { get; set; } // ðŸ”„ used for flow linking\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/SaveVisualFlowDto.cs",
      "sha256": "7de59d222a97efeaf9dc23dea2ef351d852087539cec12e7c946b02e11f1bd21",
      "language": "csharp",
      "size": 403,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class SaveVisualFlowDto\n    {\n        public string FlowName { get; set; } = string.Empty;\n        public bool IsPublished { get; set; }\n\n        public List<FlowNodeDto> Nodes { get; set; } = new();\n        public List<FlowEdgeDto> Edges { get; set; } = new();\n        public Guid? CampaignId { get; set; } // âœ… Add this line\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/VisualFlowLoadDto.cs",
      "sha256": "10bfe378ffd4c8fb74a0746f2abafec88897072e7a974d680396bde281aaf4af",
      "language": "csharp",
      "size": 289,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class VisualFlowLoadDto\n    {\n        public string FlowName { get; set; } = string.Empty;\n        public List<FlowNodeDto> Nodes { get; set; } = new();\n        public List<FlowEdgeDto> Edges { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/VisualFlowSummaryDto.cs",
      "sha256": "70dcedd3219a474a4b38927e0f0fd4ff3e21ba16632d409f146a9d0d60d685a5",
      "language": "csharp",
      "size": 300,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class VisualFlowSummaryDto\n    {\n        public Guid Id { get; set; }\n        public string FlowName { get; set; } = string.Empty;\n        public bool IsPublished { get; set; }\n        public DateTime CreatedAt { get; set; }\n    }\n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Models/CTAFlowClickLog.cs",
      "sha256": "ecbd408e613e8ef88e2bb39fdf60bc188163e209d8242317203dfb2bff8cebb8",
      "language": "csharp",
      "size": 104,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.Models\n{\n    public class CTAFlowClickLog\n    {\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Models/CTAFlowConfig.cs",
      "sha256": "a36019c3ace9f06dcc785152a4ea8e2acc280b169f9e831a28fd6efd2f9d2551",
      "language": "csharp",
      "size": 3404,
      "content": "// ðŸ“„ File: xbytechat.api/Features/CTAFlowBuilder/Models/CTAFlowConfig.cs\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\nusing System.Text.Json.Serialization;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Models\n{\n    /// <summary>\n    /// Represents a complete flow configuration for a business, such as \"Interested Journey\".\n    /// </summary>\n    public class CTAFlowConfig\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        [Required]\n        public Guid BusinessId { get; set; }\n\n        [Required]\n        [MaxLength(100)]\n        public string FlowName { get; set; } = string.Empty;\n\n        public bool IsActive { get; set; } = true;\n\n        public bool IsPublished { get; set; } = false; // âœ… NEW: Support draft/published\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n        public string? CreatedBy { get; set; }\n        public DateTime? UpdatedAt { get; set; }  // âœ… Add this line\n\n        // ðŸ” Navigation to steps\n        public ICollection<CTAFlowStep> Steps { get; set; } = new List<CTAFlowStep>();\n    }\n}\n\n// ðŸ“„ File: xbytechat.api/Features/CTAFlowBuilder/Models/CTAFlowConfig.cs\n//using System.ComponentModel.DataAnnotations;\n//using System.Text.Json.Serialization;\n//using Microsoft.EntityFrameworkCore;\n\n//namespace xbytechat.api.Features.CTAFlowBuilder.Models\n//{\n//    /// <summary>\n//    /// Represents a complete flow configuration for a business, such as \"Interested Journey\".\n//    /// </summary>\n//    [Index(nameof(BusinessId), nameof(IsActive), nameof(FlowName), Name = \"ix_ctaflowconfigs_biz_active_name\")]\n//    [Index(nameof(BusinessId), nameof(IsPublished), Name = \"ix_ctaflowconfigs_biz_published\")]\n//    public class CTAFlowConfig\n//    {\n//        [Key]\n//        public Guid Id { get; set; }\n\n//        [Required]\n//        public Guid BusinessId { get; set; }\n\n//        [Required, MaxLength(100)]\n//        public string FlowName { get; set; } = string.Empty;\n\n//        /// <summary>\n//        /// Soft â€œenabled/disabledâ€ flag for listing/selection. We still hard-delete unused flows on request.\n//        /// </summary>\n//        public bool IsActive { get; set; } = true;\n\n//        /// <summary>\n//        /// Draft vs published for the builder.\n//        /// </summary>\n//        public bool IsPublished { get; set; } = false;\n\n//        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n//        public string? CreatedBy { get; set; }\n\n//        /// <summary>\n//        /// Last modification timestamp (updated in service on edits).\n//        /// </summary>\n//        public DateTime? UpdatedAt { get; set; }\n\n//        /// <summary>\n//        /// Optimistic concurrency token to avoid race conditions (e.g., editing while someone tries to delete).\n//        /// </summary>\n//        [Timestamp]\n//        public byte[]? RowVersion { get; set; }\n\n//        // ðŸ” Navigation to steps\n//        // Cascade delete is configured in OnModelCreating:\n//        // modelBuilder.Entity<CTAFlowConfig>()\n//        //   .HasMany(f => f.Steps).WithOne(s => s.Flow)\n//        //   .HasForeignKey(s => s.FlowId)\n//        //   .OnDelete(DeleteBehavior.Cascade);\n//        [JsonIgnore] // prevent huge payloads if you serialize configs somewhere else\n//        public ICollection<CTAFlowStep> Steps { get; set; } = new List<CTAFlowStep>();\n//    }\n//}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Models/CTAFlowStep.cs",
      "sha256": "442a9f56bbf8fefda20cd184a79763eb9f0472ececa17136e35242cbeeef08b9",
      "language": "csharp",
      "size": 2700,
      "content": "// ðŸ“„ File: Features/CTAFlowBuilder/Models/CTAFlowStep.cs\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Models\n{\n    /// <summary>\n    /// Represents a single step in a CTA flow, triggered by a button.\n    /// </summary>\n    public class CTAFlowStep\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        [Required]\n        public Guid CTAFlowConfigId { get; set; }\n\n        [ForeignKey(nameof(CTAFlowConfigId))]\n        public CTAFlowConfig Flow { get; set; } = null!;\n\n        public string TriggerButtonText { get; set; } = string.Empty;\n\n        public string TriggerButtonType { get; set; } = \"cta\"; // e.g., \"quick_reply\"\n\n        public string TemplateToSend { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Optional media URL used when the selected WhatsApp template has a media header (image/video/document).\n        /// Stored per-step so click-triggered CTA sends can resolve media without relying on campaign context.\n        /// </summary>\n        public string? HeaderMediaUrl { get; set; }\n\n        /// <summary>\n        /// JSON array of body parameter values (1-based placeholders) for WhatsApp templates, e.g. [\"Alice\",\"123\"] for {{1}},{{2}}.\n        /// Stored per-step because click-triggered CTA sends don't have campaign-time personalization context.\n        /// </summary>\n        public string? BodyParamsJson { get; set; }\n\n        /// <summary>\n        /// JSON array of URL-button parameter values (max 3). Index 0 => button index \"0\" (position 1), etc.\n        /// Used only for templates with dynamic URL buttons (ParameterValue contains \"{{n}}\").\n        /// Stored per-step so CTA runtime can satisfy Meta's required button parameters on click-triggered sends.\n        /// </summary>\n        public string? UrlButtonParamsJson { get; set; }\n\n        public int StepOrder { get; set; }\n\n        public string? RequiredTag { get; set; }        // e.g., \"interested\"\n        public string? RequiredSource { get; set; }     // e.g., \"ads\", \"qr\", \"manual\"\n\n        // ðŸ”€ Multiple buttons linking to different steps\n        public List<FlowButtonLink> ButtonLinks { get; set; } = new();\n\n        public float? PositionX { get; set; }\n        public float? PositionY { get; set; }\n        public string? TemplateType { get; set; }\n\n        // âœ… Use WhatsApp Profile Name in this step's template?\n        public bool UseProfileName { get; set; } = false;\n\n        // âœ… 1-based placeholder index in the template body (e.g., {{1}})\n        public int? ProfileNameSlot { get; set; } = 1;\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Models/FlowButtonLink.cs",
      "sha256": "6b265bc48b8286ca84e5937f9f8f6fe99b8b6580ca59a43aedda8290fc685aaa",
      "language": "csharp",
      "size": 807,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.Models\n{\n    public class FlowButtonLink\n    {\n        public Guid Id { get; set; } = Guid.NewGuid();\n        public string ButtonText { get; set; } = string.Empty;\n        public Guid? NextStepId { get; set; }\n        // âœ… NEW FIELDS FOR FUTURE AUTOMATION\n        public string ButtonType { get; set; } = \"QUICK_REPLY\";    // e.g., URL, QUICK_REPLY, FLOW\n        public string ButtonSubType { get; set; } = \"\";            // Optional: e.g., \"Catalog\", \"PricingCTA\"\n        public string ButtonValue { get; set; } = \"\";              // e.g., URL or deep link\n\n        // Optional FK back to Step if needed\n        public Guid CTAFlowStepId { get; set; }\n        public CTAFlowStep? Step { get; set; }\n\n        public short ButtonIndex { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Models/FlowExecutionContext.cs",
      "sha256": "3b09934afbf7d4d7844c890fde23a96a3ba4d932fa506268da131b78ac6b5385",
      "language": "csharp",
      "size": 4023,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Models\n{\n    /// <summary>\n    /// Canonical context/payload for logging a single flow step execution.\n    /// This wraps all the information we want to write into FlowExecutionLogs.\n    /// </summary>\n    public sealed class FlowExecutionContext\n    {\n        /// <summary>\n        /// Tenant / business that owns this flow execution.\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// Optional contact this journey is associated with.\n        /// </summary>\n        public Guid? ContactId { get; set; }   // ðŸ‘ˆ ADD THIS\n\n        /// <summary>\n        /// Which engine started this journey (Campaign, AutoReply, etc.).\n        /// </summary>\n        public FlowExecutionOrigin Origin { get; set; } = FlowExecutionOrigin.Unknown;\n\n        /// <summary>\n        /// Logical flow definition. For CTA flows this is CTAFlowConfig.Id.\n        /// </summary>\n        public Guid? FlowId { get; set; }\n\n        /// <summary>\n        /// Step being executed.\n        /// </summary>\n        public Guid StepId { get; set; }\n\n        /// <summary>\n        /// Optional friendly name for the step.\n        /// </summary>\n        public string? StepName { get; set; }\n\n        /// <summary>\n        /// Optional correlation id for one \"run\" of a journey.\n        /// Multiple steps in the same journey can share RunId.\n        /// </summary>\n        public Guid? RunId { get; set; }\n\n        /// <summary>\n        /// Optional higher-level campaign this journey belongs to.\n        /// </summary>\n        public Guid? CampaignId { get; set; }\n\n        /// <summary>\n        /// Optional AutoReplyFlow id when journey started from keyword matching.\n        /// </summary>\n        public Guid? AutoReplyFlowId { get; set; }\n\n        /// <summary>\n        /// Optional specific send log (CampaignSendLog) if this was tied to a blast.\n        /// </summary>\n        public Guid? CampaignSendLogId { get; set; }\n\n        /// <summary>\n        /// Optional tracking log id (CTA click tracking, etc.).\n        /// </summary>\n        public Guid? TrackingLogId { get; set; }\n\n        /// <summary>\n        /// Optional link to underlying MessageLog row.\n        /// </summary>\n        public Guid? MessageLogId { get; set; }\n\n        /// <summary>\n        /// Phone number in E.164 form that this step is interacting with.\n        /// </summary>\n        public string? ContactPhone { get; set; }\n\n        /// <summary>\n        /// Human-readable label of the button that triggered the step, if any.\n        /// </summary>\n        public string? TriggeredByButton { get; set; }\n\n        /// <summary>\n        /// Index of the clicked button (0..2) where applicable.\n        /// </summary>\n        public short? ButtonIndex { get; set; }\n\n        /// <summary>\n        /// Template name that was used in this step (if any).\n        /// </summary>\n        public string? TemplateName { get; set; }\n\n        /// <summary>\n        /// Template type / category (e.g. \"image_template\", \"text_template\").\n        /// </summary>\n        public string? TemplateType { get; set; }\n\n        /// <summary>\n        /// Per-request correlation id (can come from message engine, HTTP request, etc.).\n        /// </summary>\n        public Guid? RequestId { get; set; }\n\n        /// <summary>\n        /// Whether the step action completed successfully.\n        /// </summary>\n        public bool Success { get; set; }\n\n        /// <summary>\n        /// Error message when the step failed.\n        /// </summary>\n        public string? ErrorMessage { get; set; }\n\n        /// <summary>\n        /// Raw provider response or internal payload for debugging.\n        /// </summary>\n        public string? RawResponse { get; set; }\n\n        /// <summary>\n        /// When the step was executed (UTC).\n        /// If null, the logger will default to DateTime.UtcNow.\n        /// </summary>\n        public DateTime? ExecutedAtUtc { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Models/FlowExecutionLog.cs",
      "sha256": "d859aa17be20179548d281edae56a6d0fb7b5321f5bd49144ada2ba82ad8e5a4",
      "language": "csharp",
      "size": 1635,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Models\n{\n    /// <summary>\n    /// Logs when a visual flow step is executed (useful for analytics, debugging, audit).\n    /// </summary>\n    public class FlowExecutionLog\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        public Guid? RunId { get; set; }\n        [Required]\n        public Guid BusinessId { get; set; }\n\n        [Required]\n        public Guid StepId { get; set; }\n        public string StepName { get; set; } = string.Empty;\n\n        public Guid? FlowId { get; set; }\n\n        public FlowExecutionOrigin Origin { get; set; } = FlowExecutionOrigin.Unknown; //new\n\n        public Guid? CampaignId { get; set; } // new \n        public Guid? AutoReplyFlowId { get; set; } // new\n\n        public Guid? CampaignSendLogId { get; set; }\n\n\n        public Guid? TrackingLogId { get; set; }\n\n        public string? ContactPhone { get; set; }\n\n        public string? TriggeredByButton { get; set; }\n\n        public string? TemplateName { get; set; }\n\n        public string? TemplateType { get; set; }\n\n        public bool Success { get; set; }\n\n        public string? ErrorMessage { get; set; }\n\n        public string? RawResponse { get; set; }\n\n        public DateTime ExecutedAt { get; set; } = DateTime.UtcNow;\n\n        public Guid? MessageLogId { get; set; }              // tie to originating message\n        public short? ButtonIndex { get; set; }              // which button was clicked (0..2)\n        public Guid? RequestId { get; set; }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Models/FlowExecutionOrigin.cs",
      "sha256": "34b36adc1c0b157360c81e219a5fc265c18612efb937a62fcbea1405a41280a7",
      "language": "csharp",
      "size": 1131,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Models\n{\n    /// <summary>\n    /// Describes where a flow execution was started from.\n    /// This is the key for analytics segmentation.\n    /// </summary>\n    public enum FlowExecutionOrigin\n    {\n        /// <summary>\n        /// Default / legacy rows before origin tracking was introduced.\n        /// </summary>\n        Unknown = 0,\n\n        /// <summary>\n        /// Flow started as part of a Campaign CTA (button click, deep link, etc.).\n        /// </summary>\n        Campaign = 1,\n\n        /// <summary>\n        /// Flow started from AutoReply word matching (keyword â†’ flow).\n        /// </summary>\n        AutoReply = 2,\n\n        /// <summary>\n        /// Flow started from a future â€œJourneyBotâ€ or similar orchestration engine.\n        /// </summary>\n        JourneyBot = 3,\n\n        /// <summary>\n        /// Flow started manually from Inbox or agent tools.\n        /// </summary>\n        Inbox = 4,\n\n        /// <summary>\n        /// System-driven or other internal triggers (backfill, test, etc.).\n        /// </summary>\n        System = 5\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Services/CtaFlowRuntimeService.cs",
      "sha256": "380d5227b25215b5baaf9496aa9410b6dbec2b75c883bf875ec25f707dd0b5d6",
      "language": "csharp",
      "size": 19163,
      "content": "// ðŸ“„ xbytechat-api/Features/CTAFlowBuilder/Services/CtaFlowRuntimeService.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api; // ðŸ‘ˆ Keep this if AppDbContext is in the root namespace\n// If AppDbContext lives under xbytechat.api.Data, then use:\n// using xbytechat.api.Data;\n\nusing xbytechat.api.Features.CTAFlowBuilder.DTOs;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.MessagesEngine.Enums;\nusing xbytechat.api.Features.MessagesEngine.Services;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Services\n{\n    /// <summary>\n    /// Minimal CTA flow runtime engine (v1).\n    ///\n    /// Responsibilities:\n    /// - Load CTAFlowConfig + steps from DB.\n    /// - Execute the first step (template send) using IMessageEngineService.\n    /// - Log the execution into FlowExecutionLogs via IFlowExecutionLogger.\n    ///\n    /// It uses FlowExecutionOrigin + AutoReplyFlowId / CampaignId so analytics\n    /// can later separate:\n    ///   - \"CTA flow started by AutoReply\"\n    ///   - \"CTA flow started by Campaign button\"\n    ///   - other origins (JourneyBot, Inbox, System).\n    /// </summary>\n    public sealed class CtaFlowRuntimeService : ICtaFlowRuntimeService\n    {\n        private readonly AppDbContext _db;\n        private readonly IMessageEngineService _messageEngine;\n        private readonly IFlowExecutionLogger _flowLogger;\n        private readonly ILogger<CtaFlowRuntimeService> _logger;\n\n        public CtaFlowRuntimeService(\n            AppDbContext db,\n            IMessageEngineService messageEngine,\n            IFlowExecutionLogger flowLogger,\n            ILogger<CtaFlowRuntimeService> logger)\n        {\n            _db = db ?? throw new ArgumentNullException(nameof(db));\n            _messageEngine = messageEngine ?? throw new ArgumentNullException(nameof(messageEngine));\n            _flowLogger = flowLogger ?? throw new ArgumentNullException(nameof(flowLogger));\n            _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n        }\n\n        public async Task<CtaFlowRunResult> StartFlowAsync(\n            Guid businessId,\n            Guid contactId,\n            string contactPhone,\n            Guid configId,\n            FlowExecutionOrigin origin,\n            Guid? autoReplyFlowId,\n            CancellationToken cancellationToken = default)\n        {\n            if (businessId == Guid.Empty)\n                throw new ArgumentException(\"businessId is required\", nameof(businessId));\n            if (configId == Guid.Empty)\n                throw new ArgumentException(\"configId is required\", nameof(configId));\n            if (string.IsNullOrWhiteSpace(contactPhone))\n                throw new ArgumentException(\"contactPhone is required\", nameof(contactPhone));\n\n            _logger.LogInformation(\n                \"ðŸš€ [CTAFlowRuntime] StartFlowAsync Biz={BusinessId}, Contact={ContactId}, Phone={Phone}, Config={ConfigId}, Origin={Origin}, AutoReplyFlowId={AutoReplyFlowId}\",\n                businessId,\n                contactId,\n                contactPhone,\n                configId,\n                origin,\n                autoReplyFlowId);\n\n            // 1ï¸âƒ£ Load the CTA flow (must be active + published) with its steps\n            var flow = await _db.CTAFlowConfigs\n                .AsNoTracking()\n                .Include(f => f.Steps)\n                .FirstOrDefaultAsync(\n                    f => f.Id == configId\n                         && f.BusinessId == businessId\n                         && f.IsActive\n                         && f.IsPublished,\n                    cancellationToken);\n\n            if (flow == null)\n            {\n                var message =\n                    $\"CTA flow {configId} for business {businessId} not found, inactive, or not published.\";\n\n                _logger.LogWarning(\"[CTAFlowRuntime] {Message}\", message);\n\n                // Log a failed \"meta-step\" so analytics can see the failure\n                var failCtx = new FlowExecutionContext\n                {\n                    BusinessId = businessId,\n                    FlowId = configId,\n                    AutoReplyFlowId = autoReplyFlowId,\n                    Origin = origin,\n\n                    // NEW: log which contact we tried to start for\n                    ContactId = contactId,\n                    ContactPhone = contactPhone,\n\n                    StepId = configId,          // no specific step; use flow id as placeholder\n                    StepName = \"FLOW_NOT_FOUND\",\n\n                    // No template here\n                    TemplateName = null,\n                    TemplateType = null,\n\n                    Success = false,\n                    ErrorMessage = message,\n                    ExecutedAtUtc = DateTime.UtcNow\n                };\n\n                await _flowLogger.LogStepAsync(failCtx, cancellationToken);\n\n                return new CtaFlowRunResult\n                {\n                    Success = false,\n                    ErrorMessage = message\n                };\n            }\n\n            // 2ï¸âƒ£ Pick the first step (v1 = simple linear flow)\n            var firstStep = flow.Steps\n                .OrderBy(s => s.StepOrder)\n                .FirstOrDefault();\n\n            if (firstStep == null)\n            {\n                var message =\n                    $\"CTA flow {flow.Id} ('{flow.FlowName}') has no steps configured.\";\n\n                _logger.LogWarning(\"[CTAFlowRuntime] {Message}\", message);\n\n                var failCtx = new FlowExecutionContext\n                {\n                    BusinessId = businessId,\n                    FlowId = flow.Id,\n                    AutoReplyFlowId = autoReplyFlowId,\n                    Origin = origin,\n\n                    // NEW: log contact context even on failure\n                    ContactId = contactId,\n                    ContactPhone = contactPhone,\n\n                    StepId = flow.Id,\n                    StepName = \"NO_STEPS\",\n\n                    TemplateName = null,\n                    TemplateType = null,\n\n                    Success = false,\n                    ErrorMessage = message,\n                    ExecutedAtUtc = DateTime.UtcNow\n                };\n\n                await _flowLogger.LogStepAsync(failCtx, cancellationToken);\n\n                return new CtaFlowRunResult\n                {\n                    Success = false,\n                    ErrorMessage = message\n                };\n            }\n\n            _logger.LogInformation(\n                \"[CTAFlowRuntime] Executing first step {StepId} ({Template}) of flow {FlowId} ('{FlowName}')\",\n                firstStep.Id,\n                firstStep.TemplateToSend,\n                flow.Id,\n                flow.FlowName);\n\n            // 3ï¸âƒ£ Build SimpleTemplateMessageDto with CTA tracking fields\n            var templateDto = new SimpleTemplateMessageDto\n            {\n                RecipientNumber = contactPhone,\n                TemplateName = firstStep.TemplateToSend,\n\n                // v1: no dynamic params here â€“ flows can be extended later\n                TemplateParameters = new List<string>(),\n\n                // v1: let MessageEngine choose routing / provider\n                HasStaticButtons = false,\n                Provider = string.Empty,\n                PhoneNumberId = null,\n\n                // ðŸ”— Link back to CTA flow config + step\n                CTAFlowConfigId = flow.Id,\n                CTAFlowStepId = firstStep.Id,\n\n                // Optional fields â€“ keep null for now\n                TemplateBody = null,\n                LanguageCode = null\n            };\n\n            // 4ï¸âƒ£ Send the message via MessageEngine (conversational â†’ Immediate)\n            var sendResult = await _messageEngine\n                .SendTemplateMessageSimpleAsync(\n                    businessId,\n                    templateDto,\n                    DeliveryMode.Immediate);\n\n            // 5ï¸âƒ£ Log the step into FlowExecutionLogs\n            var logCtx = new FlowExecutionContext\n            {\n                BusinessId = businessId,\n                FlowId = flow.Id,\n                AutoReplyFlowId = autoReplyFlowId,\n                Origin = origin,\n\n                // Contact context\n                ContactId = contactId,\n                ContactPhone = contactPhone,\n\n                // Step context\n                StepId = firstStep.Id,\n                StepName = firstStep.TemplateToSend,\n\n                // Template metadata for analytics\n                TemplateName = firstStep.TemplateToSend,\n                TemplateType = firstStep.TemplateType ?? \"CTA_FLOW_TEMPLATE\",\n\n                // Result\n                Success = sendResult.Success,\n                ErrorMessage = sendResult.Success ? null : sendResult.Message,\n                ExecutedAtUtc = DateTime.UtcNow\n\n                // MessageLogId, CatalogClickLogId, CampaignId, etc.\n                // can be wired later once message engine returns those ids.\n            };\n\n            await _flowLogger.LogStepAsync(logCtx, cancellationToken);\n\n            return new CtaFlowRunResult\n            {\n                Success = sendResult.Success,\n                ErrorMessage = sendResult.Success ? null : sendResult.Message\n            };\n        }\n    }\n}\n\n\n//// ðŸ“„ xbytechat-api/Features/CTAFlowBuilder/Services/CtaFlowRuntimeService.cs\n//using System;\n//using System.Collections.Generic;\n//using System.Linq;\n//using System.Threading;\n//using System.Threading.Tasks;\n//using Microsoft.EntityFrameworkCore;\n//using Microsoft.Extensions.Logging;\n//using xbytechat.api; // ðŸ‘ˆ Keep this if AppDbContext is in the root namespace\n//// If AppDbContext lives under xbytechat.api.Data, then use:\n//// using xbytechat.api.Data;\n\n//using xbytechat.api.Features.CTAFlowBuilder.DTOs;\n//using xbytechat.api.Features.CTAFlowBuilder.Models;\n//using xbytechat.api.Features.MessagesEngine.DTOs;\n//using xbytechat.api.Features.MessagesEngine.Services;\n\n//namespace xbytechat.api.Features.CTAFlowBuilder.Services\n//{\n//    /// <summary>\n//    /// Minimal CTA flow runtime engine (v1).\n//    ///\n//    /// Responsibilities:\n//    /// - Load CTAFlowConfig + steps from DB.\n//    /// - Execute the first step (template send) using IMessageEngineService.\n//    /// - Log the execution into FlowExecutionLogs via IFlowExecutionLogger.\n//    ///\n//    /// It uses FlowExecutionOrigin + AutoReplyFlowId / CampaignId so analytics\n//    /// can later separate:\n//    ///   - \"CTA flow started by AutoReply\"\n//    ///   - \"CTA flow started by Campaign button\"\n//    ///   - other origins (JourneyBot, Inbox, System).\n//    /// </summary>\n//    public sealed class CtaFlowRuntimeService : ICtaFlowRuntimeService\n//    {\n//        private readonly AppDbContext _db;\n//        private readonly IMessageEngineService _messageEngine;\n//        private readonly IFlowExecutionLogger _flowLogger;\n//        private readonly ILogger<CtaFlowRuntimeService> _logger;\n\n//        public CtaFlowRuntimeService(\n//            AppDbContext db,\n//            IMessageEngineService messageEngine,\n//            IFlowExecutionLogger flowLogger,\n//            ILogger<CtaFlowRuntimeService> logger)\n//        {\n//            _db = db ?? throw new ArgumentNullException(nameof(db));\n//            _messageEngine = messageEngine ?? throw new ArgumentNullException(nameof(messageEngine));\n//            _flowLogger = flowLogger ?? throw new ArgumentNullException(nameof(flowLogger));\n//            _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n//        }\n\n//        public async Task<CtaFlowRunResult> StartFlowAsync(\n//            Guid businessId,\n//            Guid contactId,\n//            string contactPhone,\n//            Guid configId,\n//            FlowExecutionOrigin origin,\n//            Guid? autoReplyFlowId,\n//            CancellationToken cancellationToken = default)\n//        {\n//            if (businessId == Guid.Empty)\n//                throw new ArgumentException(\"businessId is required\", nameof(businessId));\n//            if (configId == Guid.Empty)\n//                throw new ArgumentException(\"configId is required\", nameof(configId));\n//            if (string.IsNullOrWhiteSpace(contactPhone))\n//                throw new ArgumentException(\"contactPhone is required\", nameof(contactPhone));\n\n//            _logger.LogInformation(\n//                \"ðŸš€ [CTAFlowRuntime] StartFlowAsync Biz={BusinessId}, Contact={ContactId}, Phone={Phone}, Config={ConfigId}, Origin={Origin}, AutoReplyFlowId={AutoReplyFlowId}\",\n//                businessId,\n//                contactId,\n//                contactPhone,\n//                configId,\n//                origin,\n//                autoReplyFlowId);\n\n//            // 1ï¸âƒ£ Load the CTA flow (must be active + published) with its steps\n//            var flow = await _db.CTAFlowConfigs\n//                .AsNoTracking()\n//                .Include(f => f.Steps)\n//                .FirstOrDefaultAsync(\n//                    f => f.Id == configId\n//                         && f.BusinessId == businessId\n//                         && f.IsActive\n//                         && f.IsPublished,\n//                    cancellationToken);\n\n//            if (flow == null)\n//            {\n//                var message =\n//                    $\"CTA flow {configId} for business {businessId} not found, inactive, or not published.\";\n\n//                _logger.LogWarning(\"[CTAFlowRuntime] {Message}\", message);\n\n//                // Log a failed \"meta-step\" so analytics can see the failure\n//                var failCtx = new FlowExecutionContext\n//                {\n//                    BusinessId = businessId,\n//                    FlowId = configId,\n//                    AutoReplyFlowId = autoReplyFlowId,\n//                    Origin = origin,\n\n//                    // NEW: log which contact we tried to start for\n//                    ContactId = contactId,\n//                    ContactPhone = contactPhone,\n\n//                    StepId = configId,          // no specific step; use flow id as placeholder\n//                    StepName = \"FLOW_NOT_FOUND\",\n\n//                    // No template here\n//                    TemplateName = null,\n//                    TemplateType = null,\n\n//                    Success = false,\n//                    ErrorMessage = message,\n//                    ExecutedAtUtc = DateTime.UtcNow\n//                };\n\n//                await _flowLogger.LogStepAsync(failCtx, cancellationToken);\n\n//                return new CtaFlowRunResult\n//                {\n//                    Success = false,\n//                    ErrorMessage = message\n//                };\n//            }\n\n//            // 2ï¸âƒ£ Pick the first step (v1 = simple linear flow)\n//            var firstStep = flow.Steps\n//                .OrderBy(s => s.StepOrder)\n//                .FirstOrDefault();\n\n//            if (firstStep == null)\n//            {\n//                var message =\n//                    $\"CTA flow {flow.Id} ('{flow.FlowName}') has no steps configured.\";\n\n//                _logger.LogWarning(\"[CTAFlowRuntime] {Message}\", message);\n\n//                var failCtx = new FlowExecutionContext\n//                {\n//                    BusinessId = businessId,\n//                    FlowId = flow.Id,\n//                    AutoReplyFlowId = autoReplyFlowId,\n//                    Origin = origin,\n\n//                    // NEW: log contact context even on failure\n//                    ContactId = contactId,\n//                    ContactPhone = contactPhone,\n\n//                    StepId = flow.Id,\n//                    StepName = \"NO_STEPS\",\n\n//                    TemplateName = null,\n//                    TemplateType = null,\n\n//                    Success = false,\n//                    ErrorMessage = message,\n//                    ExecutedAtUtc = DateTime.UtcNow\n//                };\n\n//                await _flowLogger.LogStepAsync(failCtx, cancellationToken);\n\n//                return new CtaFlowRunResult\n//                {\n//                    Success = false,\n//                    ErrorMessage = message\n//                };\n//            }\n\n//            _logger.LogInformation(\n//                \"[CTAFlowRuntime] Executing first step {StepId} ({Template}) of flow {FlowId} ('{FlowName}')\",\n//                firstStep.Id,\n//                firstStep.TemplateToSend,\n//                flow.Id,\n//                flow.FlowName);\n\n//            // 3ï¸âƒ£ Build SimpleTemplateMessageDto with CTA tracking fields\n//            var templateDto = new SimpleTemplateMessageDto\n//            {\n//                RecipientNumber = contactPhone,\n//                TemplateName = firstStep.TemplateToSend,\n\n//                // v1: no dynamic params here â€“ flows can be extended later\n//                TemplateParameters = new List<string>(),\n\n//                // v1: let MessageEngine choose routing / provider\n//                HasStaticButtons = false,\n//                Provider = string.Empty,\n//                PhoneNumberId = null,\n\n//                // ðŸ”— Link back to CTA flow config + step\n//                CTAFlowConfigId = flow.Id,\n//                CTAFlowStepId = firstStep.Id,\n\n//                // Optional fields â€“ keep null for now\n//                TemplateBody = null,\n//                LanguageCode = null\n//            };\n\n//            // 4ï¸âƒ£ Send the message via MessageEngine\n//            var sendResult = await _messageEngine\n//                .SendTemplateMessageSimpleAsync(businessId, templateDto);\n\n//            // 5ï¸âƒ£ Log the step into FlowExecutionLogs\n//            var logCtx = new FlowExecutionContext\n//            {\n//                BusinessId = businessId,\n//                FlowId = flow.Id,\n//                AutoReplyFlowId = autoReplyFlowId,\n//                Origin = origin,\n\n//                // Contact context\n//                ContactId = contactId,\n//                ContactPhone = contactPhone,\n\n//                // Step context\n//                StepId = firstStep.Id,\n//                StepName = firstStep.TemplateToSend,\n\n//                // Template metadata for analytics\n//                TemplateName = firstStep.TemplateToSend,\n//                TemplateType = firstStep.TemplateType ?? \"CTA_FLOW_TEMPLATE\",\n\n//                // Result\n//                Success = sendResult.Success,\n//                ErrorMessage = sendResult.Success ? null : sendResult.Message,\n//                ExecutedAtUtc = DateTime.UtcNow\n\n//                // MessageLogId, CatalogClickLogId, CampaignId, etc.\n//                // can be wired later once message engine returns those ids.\n//            };\n\n//            await _flowLogger.LogStepAsync(logCtx, cancellationToken);\n\n//            return new CtaFlowRunResult\n//            {\n//                Success = sendResult.Success,\n//                ErrorMessage = sendResult.Success ? null : sendResult.Message\n//            };\n//        }\n//    }\n//}\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Services/CTAFlowService.cs",
      "sha256": "02e12f43b542244885559938ed0d53600df3c26ba2554eb1e09890d3eaa77934",
      "language": "csharp",
      "size": 128433,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing System.Text.RegularExpressions;\nusing System.Text.Json;\nusing xbytechat.api.Features.CTAFlowBuilder.DTOs;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.Features.Tracking.Models;\nusing xbytechat.api.Helpers;\nusing xbytechat_api.WhatsAppSettings.Services;\nusing xbytechat.api.WhatsAppSettings.DTOs;\nusing xbytechat.api.Features.CRM.Models;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Services\n{\n    public class CTAFlowService : ICTAFlowService\n    {\n        private readonly AppDbContext _context;\n        private readonly IMessageEngineService _messageEngineService;\n        private readonly IWhatsAppTemplateFetcherService _templateFetcherService;\n\n        public CTAFlowService(\n            AppDbContext context,\n            IMessageEngineService messageEngineService,\n            IWhatsAppTemplateFetcherService templateFetcherService)\n        {\n            _context = context;\n            _messageEngineService = messageEngineService;\n            _templateFetcherService = templateFetcherService;\n        }\n\n        // ---------------------------\n        // CREATE (draft-only, no edit)\n        // ---------------------------\n        public async Task<ResponseResult> SaveVisualFlowAsync(\n            SaveVisualFlowDto dto,\n            Guid businessId,\n            string createdBy)\n        {\n            try\n            {\n                Log.Information(\"ðŸ§  SaveVisualFlow (create-only) | FlowName: {FlowName} | Biz: {BusinessId}\",\n                    dto.FlowName, businessId);\n\n                // 0) Validate\n                if (dto.Nodes == null || !dto.Nodes.Any())\n                    return ResponseResult.ErrorInfo(\"âŒ Cannot save an empty flow. Please add at least one step.\");\n\n                var trimmedName = (dto.FlowName ?? \"\").Trim();\n                if (trimmedName.Length == 0)\n                    return ResponseResult.ErrorInfo(\"âŒ Flow name is required.\");\n\n                // 1) Enforce unique active name per business (create-only)\n                var nameExists = await _context.CTAFlowConfigs\n                    .AnyAsync(f => f.BusinessId == businessId && f.FlowName == trimmedName && f.IsActive);\n                if (nameExists)\n                {\n                    Log.Warning(\"âš ï¸ Duplicate flow name '{Name}' for business {Biz}.\", trimmedName, businessId);\n                    return ResponseResult.ErrorInfo(\"âŒ A flow with this name already exists.\");\n                }\n\n                await using var tx = await _context.Database.BeginTransactionAsync();\n\n                // 2) Insert FlowConfig AS DRAFT (force IsPublished=false)\n                var flow = new CTAFlowConfig\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    FlowName = trimmedName,\n                    CreatedBy = createdBy,\n                    CreatedAt = DateTime.UtcNow,\n                    UpdatedAt = DateTime.UtcNow,\n                    IsActive = true,\n                    IsPublished = false // << always draft on create\n                };\n                _context.CTAFlowConfigs.Add(flow);\n\n                // 3) Steps (map incoming node ids so we can wire links)\n                var stepMap = new Dictionary<string, CTAFlowStep>(StringComparer.OrdinalIgnoreCase);\n                var orderIndex = 0;\n\n                foreach (var node in dto.Nodes)\n                {\n                    if (string.IsNullOrWhiteSpace(node.Id)) continue;\n\n                    var step = new CTAFlowStep\n                    {\n                        Id = Guid.NewGuid(),\n                        CTAFlowConfigId = flow.Id,\n                        StepOrder = orderIndex++,\n                        TemplateToSend = node.TemplateName,\n                        TemplateType = node.TemplateType ?? \"UNKNOWN\",\n                        HeaderMediaUrl = string.IsNullOrWhiteSpace(node.HeaderMediaUrl) ? null : node.HeaderMediaUrl.Trim(),\n                        BodyParamsJson = SerializeBodyParams(node.BodyParams),\n                        UrlButtonParamsJson = SerializeUrlButtonParams(node.UrlButtonParams),\n                        TriggerButtonText = node.TriggerButtonText ?? \"\",\n                        TriggerButtonType = node.TriggerButtonType ?? \"cta\",\n                        PositionX = node.PositionX == 0 ? Random.Shared.Next(100, 600) : node.PositionX,\n                        PositionY = node.PositionY == 0 ? Random.Shared.Next(100, 400) : node.PositionY,\n                        UseProfileName = node.UseProfileName,\n                        ProfileNameSlot = node.ProfileNameSlot,\n                        ButtonLinks = new List<FlowButtonLink>()\n                    };\n\n                    // Only text templates may use profile name slot\n                    var isTextTemplate = string.Equals(step.TemplateType, \"text_template\", StringComparison.OrdinalIgnoreCase);\n                    if (!isTextTemplate)\n                    {\n                        step.UseProfileName = false;\n                        step.ProfileNameSlot = null;\n                    }\n                    else if (!step.UseProfileName)\n                    {\n                        step.ProfileNameSlot = null;\n                    }\n                    else if (!step.ProfileNameSlot.HasValue || step.ProfileNameSlot.Value < 1)\n                    {\n                        step.ProfileNameSlot = 1;\n                    }\n\n                    stepMap[node.Id] = step;\n                    _context.CTAFlowSteps.Add(step);\n                }\n\n                // 4) Wire links per node via edges (SourceHandle == button text)\n                var edges = dto.Edges ?? new List<FlowEdgeDto>();\n\n                foreach (var node in dto.Nodes)\n                {\n                    if (string.IsNullOrWhiteSpace(node.Id) || !stepMap.TryGetValue(node.Id, out var fromStep))\n                        continue;\n\n                    var outEdges = edges\n                        .Where(e => string.Equals(e.FromNodeId, node.Id, StringComparison.OrdinalIgnoreCase))\n                        .ToList();\n\n                    var seenTexts = new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n                    var orderedButtons = (node.Buttons ?? new List<LinkButtonDto>())\n                        .OrderBy(b => b.Index < 0 ? int.MaxValue : b.Index)\n                        .ThenBy(b => b.Text ?? string.Empty)\n                        .ToList();\n\n                    short nextIdx = 0;\n\n                    foreach (var btn in orderedButtons)\n                    {\n                        var text = (btn.Text ?? string.Empty).Trim();\n                        if (string.IsNullOrEmpty(text)) continue;\n                        if (!seenTexts.Add(text)) continue; // dedupe\n\n                        var edge = outEdges.FirstOrDefault(e =>\n                            string.Equals(e.SourceHandle ?? string.Empty, text, StringComparison.OrdinalIgnoreCase));\n                        if (edge == null) continue;\n\n                        if (!stepMap.TryGetValue(edge.ToNodeId, out var toStep)) continue;\n\n                        var finalIndex = btn.Index >= 0 ? btn.Index : nextIdx;\n                        nextIdx = (short)(finalIndex + 1);\n\n                        var link = new FlowButtonLink\n                        {\n                            Id = Guid.NewGuid(),\n                            CTAFlowStepId = fromStep.Id,\n                            NextStepId = toStep.Id,\n                            ButtonText = text,\n                            ButtonType = string.IsNullOrWhiteSpace(btn.Type) ? \"QUICK_REPLY\" : btn.Type,\n                            ButtonSubType = btn.SubType ?? string.Empty,\n                            ButtonValue = btn.Value ?? string.Empty,\n                            ButtonIndex = (short)finalIndex\n                        };\n\n                        _context.FlowButtonLinks.Add(link);\n                        fromStep.ButtonLinks.Add(link);\n\n                        // convenience: populate target's trigger info\n                        toStep.TriggerButtonText = text;\n                        toStep.TriggerButtonType = (btn.Type ?? \"QUICK_REPLY\").ToLowerInvariant();\n                    }\n                }\n\n                await _context.SaveChangesAsync();\n                await tx.CommitAsync();\n\n                Log.Information(\"âœ… Flow created '{Flow}' | Steps: {Steps} | Links: {Links}\",\n                    flow.FlowName, stepMap.Count, stepMap.Values.Sum(s => s.ButtonLinks.Count));\n\n                return ResponseResult.SuccessInfo(\"âœ… Flow created.\", new { flowId = flow.Id });\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"âŒ Exception while saving (create) flow\");\n                return ResponseResult.ErrorInfo(\"âŒ Internal error while saving flow.\");\n            }\n        }\n\n        // ---------------------------\n        // LISTS\n        // ---------------------------\n        public async Task<List<VisualFlowSummaryDto>> GetAllPublishedFlowsAsync(Guid businessId)\n        {\n            return await _context.CTAFlowConfigs\n                .Where(f => f.BusinessId == businessId && f.IsPublished)\n                .OrderByDescending(f => f.CreatedAt)\n                .Select(f => new VisualFlowSummaryDto\n                {\n                    Id = f.Id,\n                    FlowName = f.FlowName,\n                    IsPublished = f.IsPublished,\n                    CreatedAt = f.CreatedAt\n                })\n                .ToListAsync();\n        }\n\n        public async Task<List<VisualFlowSummaryDto>> GetAllDraftFlowsAsync(Guid businessId)\n        {\n            return await _context.CTAFlowConfigs\n                .Where(f => f.BusinessId == businessId && !f.IsPublished && f.IsActive)\n                .OrderByDescending(f => f.CreatedAt)\n                .Select(f => new VisualFlowSummaryDto\n                {\n                    Id = f.Id,\n                    FlowName = f.FlowName,\n                    CreatedAt = f.CreatedAt,\n                    IsPublished = f.IsPublished\n                })\n                .ToListAsync();\n        }\n\n        // ---------------------------\n        // DETAIL LOADERS\n        // ---------------------------\n        public async Task<SaveVisualFlowDto?> GetVisualFlowByIdAsync(Guid flowId, Guid businessId)\n        {\n            var flow = await _context.CTAFlowConfigs\n                .Include(c => c.Steps)\n                    .ThenInclude(s => s.ButtonLinks)\n                .FirstOrDefaultAsync(c => c.Id == flowId && c.BusinessId == businessId && c.IsActive);\n\n            if (flow == null) return null;\n\n            // Prefetch template metadata\n            var templateMap = new Dictionary<string, TemplateMetadataDto>(StringComparer.OrdinalIgnoreCase);\n            var uniqueNames = flow.Steps\n                .Select(s => s.TemplateToSend)\n                .Where(n => !string.IsNullOrWhiteSpace(n))\n                .Distinct(StringComparer.OrdinalIgnoreCase)\n                .ToList();\n\n            foreach (var name in uniqueNames)\n            {\n                try\n                {\n                    var tpl = await _templateFetcherService.GetTemplateByNameAsync(\n                        businessId, name!, includeButtons: true);\n                    if (tpl != null) templateMap[name!] = tpl;\n                }\n                catch (Exception ex)\n                {\n                    Log.Warning(ex, \"âš ï¸ Failed to fetch template metadata for {Template}\", name);\n                }\n            }\n\n                var nodes = flow.Steps.Select(step =>\n                {\n                    templateMap.TryGetValue(step.TemplateToSend ?? \"\", out var tpl);\n\n                var dbLinks = step.ButtonLinks ?? new List<FlowButtonLink>();\n                var linkByIndex = dbLinks.ToDictionary(l => (int)l.ButtonIndex, l => l);\n\n                // Canonical button list (max 3) in index order. This is important for dynamic URL button params,\n                // which are indexed by button position (\"0\",\"1\",\"2\") in Meta payloads.\n                // For linked buttons, preserve stored ButtonText so ReactFlow edges rehydrate (SourceHandle matches).\n                var buttons = (tpl?.ButtonParams ?? new List<ButtonMetadataDto>())\n                    .OrderBy(b => b.Index)\n                    .Take(3)\n                    .Select(btn =>\n                    {\n                        var idx = btn.Index;\n                        if (idx < 0 || idx > 2) return null;\n\n                        if (linkByIndex.TryGetValue(idx, out var link))\n                        {\n                            return new LinkButtonDto\n                            {\n                                Text = link.ButtonText,\n                                Type = link.ButtonType,\n                                SubType = link.ButtonSubType,\n                                Value = link.ButtonValue,\n                                Index = link.ButtonIndex,\n                                TargetNodeId = link.NextStepId?.ToString()\n                            };\n                        }\n\n                        return new LinkButtonDto\n                        {\n                            Text = btn.Text,\n                            Type = btn.Type,\n                            SubType = btn.SubType,\n                            Value = btn.ParameterValue,\n                            Index = idx,\n                            TargetNodeId = null\n                        };\n                    })\n                    .Where(x => x != null)\n                    .Select(x => x!)\n                    .ToList();\n\n                return new FlowNodeDto\n                {\n                    Id = step.Id.ToString(),\n                    TemplateName = step.TemplateToSend,\n                    TemplateType = step.TemplateType,\n                    HeaderMediaUrl = step.HeaderMediaUrl,\n                    BodyParams = TryParseBodyParams(step.BodyParamsJson),\n                    UrlButtonParams = TryParseUrlButtonParams(step.UrlButtonParamsJson),\n                    MessageBody = string.IsNullOrWhiteSpace(tpl?.Body) ? \"â€” no body found â€”\" : tpl!.Body,\n                    TriggerButtonText = step.TriggerButtonText,\n                    TriggerButtonType = step.TriggerButtonType,\n                    PositionX = step.PositionX ?? 100,\n                    PositionY = step.PositionY ?? 100,\n                    RequiredTag = step.RequiredTag,\n                    RequiredSource = step.RequiredSource,\n                    UseProfileName = step.UseProfileName,\n                    ProfileNameSlot = step.ProfileNameSlot,\n                    Buttons = buttons\n                };\n            }).ToList();\n\n            var edges = flow.Steps\n                .SelectMany(step =>\n                    (step.ButtonLinks ?? Enumerable.Empty<FlowButtonLink>())\n                    .Where(l => l.NextStepId.HasValue)\n                    .Select(l => new FlowEdgeDto\n                    {\n                        FromNodeId = step.Id.ToString(),\n                        ToNodeId = l.NextStepId!.Value.ToString(),\n                        SourceHandle = l.ButtonText\n                    }))\n                .ToList();\n\n            return new SaveVisualFlowDto\n            {\n                FlowName = flow.FlowName,\n                IsPublished = flow.IsPublished,\n                Nodes = nodes,\n                Edges = edges\n            };\n        }\n\n        public async Task<ResponseResult> GetVisualFlowAsync(Guid flowId, Guid businessId)\n        {\n            try\n            {\n                var flow = await _context.CTAFlowConfigs\n                    .AsNoTracking()\n                    .Where(f => f.IsActive && f.BusinessId == businessId && f.Id == flowId)\n                    .Select(f => new\n                    {\n                        f.Id,\n                        f.FlowName,\n                        f.IsPublished,\n                        Steps = _context.CTAFlowSteps\n                            .Where(s => s.CTAFlowConfigId == f.Id)\n                            .OrderBy(s => s.StepOrder)\n                            .Select(s => new\n                            {\n                                s.Id,\n                                s.StepOrder,\n                                s.TemplateToSend,\n                                s.TemplateType,\n                                s.HeaderMediaUrl,\n                                s.BodyParamsJson,\n                                s.UrlButtonParamsJson,\n                                s.TriggerButtonText,\n                                s.TriggerButtonType,\n                                s.PositionX,\n                                s.PositionY,\n                                s.UseProfileName,\n                                s.ProfileNameSlot,\n                                Buttons = _context.FlowButtonLinks\n                                    .Where(b => b.CTAFlowStepId == s.Id)\n                                    .OrderBy(b => b.ButtonIndex)\n                                    .Select(b => new\n                                    {\n                                        b.ButtonText,\n                                        b.ButtonType,\n                                        b.ButtonSubType,\n                                        b.ButtonValue,\n                                        b.ButtonIndex,\n                                        b.NextStepId\n                                    })\n                                    .ToList()\n                            })\n                            .ToList()\n                    })\n                    .FirstOrDefaultAsync();\n\n                if (flow == null)\n                    return ResponseResult.ErrorInfo(\"Flow not found.\");\n\n                var nodes = flow.Steps.Select(s => new\n                {\n                    id = s.Id.ToString(),\n                    positionX = s.PositionX ?? 0,\n                    positionY = s.PositionY ?? 0,\n                    templateName = s.TemplateToSend,\n                    templateType = s.TemplateType,\n                    headerMediaUrl = s.HeaderMediaUrl,\n                    bodyParams = TryParseBodyParams(s.BodyParamsJson),\n                    urlButtonParams = TryParseUrlButtonParams(s.UrlButtonParamsJson),\n                    triggerButtonText = s.TriggerButtonText ?? string.Empty,\n                    triggerButtonType = s.TriggerButtonType ?? \"cta\",\n                    requiredTag = string.Empty,\n                    requiredSource = string.Empty,\n                    useProfileName = s.UseProfileName,\n                    profileNameSlot = (s.ProfileNameSlot.HasValue && s.ProfileNameSlot.Value > 0) ? s.ProfileNameSlot.Value : 1,\n                    buttons = s.Buttons.Select(b => new\n                    {\n                        text = b.ButtonText,\n                        type = b.ButtonType,\n                        subType = b.ButtonSubType,\n                        value = b.ButtonValue,\n                        targetNodeId = b.NextStepId == Guid.Empty ? null : b.NextStepId.ToString(),\n                        index = (int)(b.ButtonIndex)\n                    })\n                });\n\n                var edges = flow.Steps\n                    .SelectMany(s => s.Buttons\n                        .Where(b => b.NextStepId != Guid.Empty)\n                        .Select(b => new\n                        {\n                            fromNodeId = s.Id.ToString(),\n                            toNodeId = b.NextStepId.ToString(),\n                            sourceHandle = b.ButtonText\n                        }));\n\n                var payload = new\n                {\n                    flowName = flow.FlowName,\n                    isPublished = flow.IsPublished,\n                    nodes,\n                    edges\n                };\n\n                return ResponseResult.SuccessInfo(\"Flow loaded.\", payload);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"âŒ Exception while loading visual flow {FlowId}\", flowId);\n                return ResponseResult.ErrorInfo(\"Internal error while loading flow.\");\n            }\n        }\n\n        private static string? SerializeBodyParams(List<string>? bodyParams)\n        {\n            if (bodyParams == null || bodyParams.Count == 0) return null;\n\n            // Persist trimmed values; keep empty strings (runtime/publish validation decides if that's allowed).\n            var cleaned = bodyParams.Select(x => (x ?? string.Empty).Trim()).ToList();\n            return JsonSerializer.Serialize(cleaned);\n        }\n\n        private static List<string> TryParseBodyParams(string? json)\n        {\n            if (string.IsNullOrWhiteSpace(json)) return new List<string>();\n            try\n            {\n                var list = JsonSerializer.Deserialize<List<string>>(json);\n                return list ?? new List<string>();\n            }\n            catch\n            {\n                // Keep flow load resilient even if older rows contain malformed data.\n                return new List<string>();\n            }\n        }\n\n        private static string? SerializeUrlButtonParams(List<string>? urlButtonParams)\n        {\n            if (urlButtonParams == null || urlButtonParams.Count == 0) return null;\n\n            // Meta supports up to 3 buttons. Persist trimmed values; keep empty strings (validation decides if that's allowed).\n            var cleaned = urlButtonParams\n                .Take(3)\n                .Select(x => (x ?? string.Empty).Trim())\n                .ToList();\n\n            return JsonSerializer.Serialize(cleaned);\n        }\n\n        private static List<string> TryParseUrlButtonParams(string? json)\n        {\n            if (string.IsNullOrWhiteSpace(json)) return new List<string>();\n            try\n            {\n                var list = JsonSerializer.Deserialize<List<string>>(json);\n                return list ?? new List<string>();\n            }\n            catch\n            {\n                return new List<string>();\n            }\n        }\n\n        // ---------------------------\n        // DELETE (only if not attached)\n        // ---------------------------\n        public async Task<ResponseResult> DeleteFlowAsync(Guid flowId, Guid businessId, string deletedBy)\n        {\n            var flow = await _context.CTAFlowConfigs\n                .Include(f => f.Steps)\n                    .ThenInclude(s => s.ButtonLinks)\n                .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId);\n\n            if (flow == null)\n                return ResponseResult.ErrorInfo(\"âŒ Flow not found or does not belong to you.\");\n\n            var inUseQuery = _context.Campaigns\n                .Where(c => c.BusinessId == businessId &&\n                            !c.IsDeleted &&\n                            c.CTAFlowConfigId == flowId);\n\n            var inUseCount = await inUseQuery.CountAsync();\n            if (inUseCount > 0)\n            {\n                Log.Warning(\"âŒ Delete flow blocked. Flow {FlowId} is used by {Count} campaigns.\", flowId, inUseCount);\n                // Keep message; controller will fetch campaigns for modal\n                return ResponseResult.ErrorInfo(\n                    $\"âŒ Cannot delete. This flow is attached to {inUseCount} campaign(s). Delete those campaigns first.\");\n            }\n\n            foreach (var step in flow.Steps)\n                _context.FlowButtonLinks.RemoveRange(step.ButtonLinks);\n\n            _context.CTAFlowSteps.RemoveRange(flow.Steps);\n            _context.CTAFlowConfigs.Remove(flow);\n\n            await _context.SaveChangesAsync();\n            return ResponseResult.SuccessInfo(\"âœ… Flow deleted.\");\n        }\n\n        public async Task<IReadOnlyList<AttachedCampaignDto>> GetAttachedCampaignsAsync(Guid flowId, Guid businessId)\n        {\n            var q = _context.Campaigns\n                .Where(c => c.BusinessId == businessId && !c.IsDeleted && c.CTAFlowConfigId == flowId);\n\n            var firstSends = await _context.CampaignSendLogs\n                .Where(s => s.BusinessId == businessId && s.CampaignId != Guid.Empty)\n                .GroupBy(s => s.CampaignId)\n                .Select(g => new { CampaignId = g.Key, FirstSentAt = (DateTime?)g.Min(s => s.CreatedAt) })\n                .ToListAsync();\n\n            var firstSendMap = firstSends.ToDictionary(x => x.CampaignId, x => x.FirstSentAt);\n\n            var list = await q\n                .OrderByDescending(c => c.CreatedAt)\n                .Select(c => new\n                {\n                    c.Id,\n                    c.Name,\n                    c.Status,\n                    c.ScheduledAt,\n                    c.CreatedAt,\n                    c.CreatedBy\n                })\n                .ToListAsync();\n\n            return list.Select(x => new AttachedCampaignDto(\n                x.Id,\n                x.Name,\n                x.Status,\n                x.ScheduledAt,\n                x.CreatedAt,\n                x.CreatedBy,\n                firstSendMap.TryGetValue(x.Id, out var ts) ? ts : null\n            )).ToList();\n        }\n\n        public async Task<bool> HardDeleteFlowIfUnusedAsync(Guid flowId, Guid businessId)\n        {\n            var flow = await _context.CTAFlowConfigs\n                .Include(f => f.Steps)\n                    .ThenInclude(s => s.ButtonLinks)\n                .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId);\n\n            if (flow is null) return false;\n\n            var attached = await _context.Campaigns\n                .Where(c => c.BusinessId == businessId && !c.IsDeleted && c.CTAFlowConfigId == flowId)\n                .AnyAsync();\n            if (attached) return false;\n\n            foreach (var step in flow.Steps)\n                _context.FlowButtonLinks.RemoveRange(step.ButtonLinks);\n            _context.CTAFlowSteps.RemoveRange(flow.Steps);\n            _context.CTAFlowConfigs.Remove(flow);\n\n            await _context.SaveChangesAsync();\n            return true;\n        }\n\n        // ---------------------------\n        // PUBLISH (by id, flip flag)\n        // ---------------------------\n        public async Task<ResponseResult> PublishFlowAsync(Guid flowId, Guid businessId, string user)\n        {\n            var flow = await _context.CTAFlowConfigs\n                .Include(f => f.Steps)\n                .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId && f.IsActive);\n\n            if (flow is null) return ResponseResult.NotFound(\"âŒ Flow not found.\");\n\n            // Server-side guardrails: publishing must be safe even if UI validation is bypassed.\n            // Validate required media header URL, body placeholder params, and dynamic URL button params.\n            var issues = await ValidateFlowForPublishAsync(flow, businessId);\n            if (issues.Count > 0)\n            {\n                Log.Warning(\n                    \"âŒ CTAFlow publish blocked: validation failed biz={Biz} flow={Flow} issues={Count} first='{First}'\",\n                    businessId, flowId, issues.Count, issues[0]);\n\n                return ResponseResult.BadRequest(\n                    \"âŒ Publish blocked: fix configuration issues in one or more steps.\",\n                    payload: issues);\n            }\n\n            flow.IsPublished = true;\n            flow.UpdatedAt = DateTime.UtcNow;\n            await _context.SaveChangesAsync();\n            return ResponseResult.Ok(\"âœ… Flow published.\");\n        }\n\n        // ----- Publish-time validation helpers (best-effort; must not throw) -----\n        private static readonly Regex PositionalToken =\n            new(@\"\\{\\{\\s*\\d+\\s*\\}\\}\", RegexOptions.Compiled); // {{1}}, {{ 2 }}, etc.\n\n        private static readonly Regex NamedToken =\n            new(@\"\\{\\{\\s*\\}\\}\", RegexOptions.Compiled);        // {{}} (NAMED format slot)\n\n        private static int CountBodyTokensFlexible(string? text)\n        {\n            if (string.IsNullOrEmpty(text)) return 0;\n            return PositionalToken.Matches(text).Count + NamedToken.Matches(text).Count;\n        }\n\n        private static bool IsValidHttpsUrl(string? input)\n        {\n            if (string.IsNullOrWhiteSpace(input)) return false;\n            if (!Uri.TryCreate(input.Trim(), UriKind.Absolute, out var u)) return false;\n            return string.Equals(u.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase);\n        }\n\n        private async Task<List<string>> ValidateFlowForPublishAsync(CTAFlowConfig flow, Guid businessId)\n        {\n            var issues = new List<string>();\n\n            try\n            {\n                var steps = (flow.Steps ?? new List<CTAFlowStep>())\n                    .OrderBy(s => s.StepOrder)\n                    .ToList();\n\n                if (steps.Count == 0)\n                {\n                    issues.Add(\"Flow has no steps.\");\n                    return issues;\n                }\n\n                var templateNames = steps\n                    .Select(s => (s.TemplateToSend ?? string.Empty).Trim())\n                    .Where(s => !string.IsNullOrWhiteSpace(s))\n                    .Distinct(StringComparer.OrdinalIgnoreCase)\n                    .ToList();\n\n                // Load template meta (buttons, header kind, body text) once per template.\n                var metaMap = new Dictionary<string, TemplateMetadataDto>(StringComparer.OrdinalIgnoreCase);\n                foreach (var name in templateNames)\n                {\n                    try\n                    {\n                        var meta = await _templateFetcherService.GetTemplateByNameAsync(\n                            businessId, name, includeButtons: true);\n                        if (meta != null) metaMap[name] = meta;\n                    }\n                    catch (Exception ex)\n                    {\n                        Log.Warning(ex, \"âš ï¸ CTAFlow publish validation: failed to fetch meta for {Template}\", name);\n                    }\n                }\n\n                // Canonical body var counts (buttons are separate). If missing, fall back to token counting.\n                var bodyCounts = await _context.WhatsAppTemplates\n                    .AsNoTracking()\n                    .Where(t => t.BusinessId == businessId && t.IsActive && templateNames.Contains(t.Name))\n                    .GroupBy(t => t.Name)\n                    .Select(g => new { Name = g.Key, BodyVarCount = g.Max(x => x.BodyVarCount) })\n                    .ToListAsync();\n\n                var bodyCountMap = bodyCounts.ToDictionary(x => x.Name, x => x.BodyVarCount, StringComparer.OrdinalIgnoreCase);\n\n                foreach (var step in steps)\n                {\n                    var stepLabel = $\"Step {step.StepOrder + 1}\";\n                    var templateName = (step.TemplateToSend ?? string.Empty).Trim();\n\n                    if (string.IsNullOrWhiteSpace(templateName))\n                    {\n                        issues.Add($\"{stepLabel}: missing template.\");\n                        continue;\n                    }\n\n                    if (!metaMap.TryGetValue(templateName, out var meta) || meta == null)\n                    {\n                        issues.Add($\"{stepLabel} ({templateName}): template not found/approved for this business.\");\n                        continue;\n                    }\n\n                    // Header media URL required for image/video/document templates\n                    var headerKind = (meta.HeaderKind ?? \"none\").Trim().ToLowerInvariant();\n                    var requiresMediaHeader = headerKind is \"image\" or \"video\" or \"document\";\n                    if (requiresMediaHeader && !IsValidHttpsUrl(step.HeaderMediaUrl))\n                    {\n                        issues.Add($\"{stepLabel} ({templateName}): header media URL required (https) for {headerKind} template.\");\n                    }\n\n                    // Body placeholder params\n                    var bodyVarCount = 0;\n                    if (bodyCountMap.TryGetValue(templateName, out var c) && c > 0) bodyVarCount = c;\n                    else bodyVarCount = CountBodyTokensFlexible(meta.Body);\n\n                    if (bodyVarCount > 0)\n                    {\n                        var args = TryParseBodyParams(step.BodyParamsJson);\n                        var slot = step.UseProfileName ? (step.ProfileNameSlot ?? 0) : 0;\n\n                        for (var i = 1; i <= bodyVarCount; i++)\n                        {\n                            if (slot == i) continue; // profile name slot is runtime-filled\n\n                            var v = (i - 1) < args.Count ? args[i - 1] : null;\n                            if (string.IsNullOrWhiteSpace(v))\n                            {\n                                issues.Add($\"{stepLabel} ({templateName}): missing body value for {{{{{i}}}}}.\");\n                                break;\n                            }\n                        }\n                    }\n\n                    // Dynamic URL button params\n                    if (meta.ButtonParams is { Count: > 0 })\n                    {\n                        var stored = TryParseUrlButtonParams(step.UrlButtonParamsJson);\n                        var buttons = meta.ButtonParams\n                            .OrderBy(b => b.Index)\n                            .Take(3)\n                            .ToList();\n\n                        foreach (var b in buttons)\n                        {\n                            var idx = b.Index;\n                            if (idx < 0 || idx > 2) continue;\n\n                            var isUrl =\n                                string.Equals(b.Type, \"URL\", StringComparison.OrdinalIgnoreCase) ||\n                                string.Equals(b.SubType, \"url\", StringComparison.OrdinalIgnoreCase);\n                            if (!isUrl) continue;\n\n                            var mask = (b.ParameterValue ?? string.Empty).Trim();\n                            var isDynamic = mask.Contains(\"{{\", StringComparison.Ordinal);\n                            if (!isDynamic) continue;\n\n                            var value = (idx < stored.Count ? stored[idx] : null) ?? string.Empty;\n                            if (string.IsNullOrWhiteSpace(value))\n                            {\n                                var bt = string.IsNullOrWhiteSpace(b.Text) ? $\"button {idx + 1}\" : $\"'{b.Text}'\";\n                                issues.Add($\"{stepLabel} ({templateName}): missing dynamic URL param for {bt}.\");\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            catch (Exception ex)\n            {\n                // Never block publish due to validation code crashing; instead, allow publish and log loudly.\n                // (Runtime still has hard checks + FlowExecutionLogs failures.)\n                Log.Error(ex, \"âŒ CTAFlow publish validation crashed; allowing publish as fallback biz={Biz} flow={Flow}\", businessId, flow.Id);\n                issues.Clear();\n            }\n\n            return issues;\n        }\n\n        // ---------------------------\n        // UPDATE (save as draft by id)\n        // ---------------------------\n        public async Task<FlowUpdateResult> UpdateVisualFlowAsync(\n            Guid flowId,\n            SaveVisualFlowDto dto,\n            Guid businessId,\n            string user)\n        {\n            try\n            {\n                if (dto.Nodes == null || !dto.Nodes.Any())\n                    return new FlowUpdateResult { Status = \"error\", Message = \"âŒ Cannot save an empty flow. Please add at least one step.\" };\n\n                var trimmedName = (dto.FlowName ?? string.Empty).Trim();\n                if (trimmedName.Length == 0)\n                    return new FlowUpdateResult { Status = \"error\", Message = \"âŒ Flow name is required.\" };\n\n                var flow = await _context.CTAFlowConfigs\n                    .Include(f => f.Steps)\n                        .ThenInclude(s => s.ButtonLinks)\n                    .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId && f.IsActive);\n\n                if (flow == null)\n                    return new FlowUpdateResult { Status = \"notFound\", Message = \"âŒ Flow not found.\" };\n\n                // If a live/published flow is attached, force fork to avoid changing active campaigns.\n                if (flow.IsPublished)\n                {\n                    var attachedCount = await _context.Campaigns\n                        .Where(c => c.BusinessId == businessId && !c.IsDeleted && c.CTAFlowConfigId == flowId)\n                        .CountAsync();\n\n                    if (attachedCount > 0)\n                    {\n                        var campaigns = await GetAttachedCampaignsAsync(flowId, businessId);\n                        return new FlowUpdateResult\n                        {\n                            Status = \"requiresFork\",\n                            Message = \"âŒ This published flow is attached to campaign(s). Create a new draft version to edit.\",\n                            Campaigns = campaigns\n                        };\n                    }\n                }\n\n                // Enforce unique active name per business (excluding current flow)\n                var nameExists = await _context.CTAFlowConfigs\n                    .AnyAsync(f => f.BusinessId == businessId &&\n                                   f.IsActive &&\n                                   f.FlowName == trimmedName &&\n                                   f.Id != flowId);\n\n                if (nameExists)\n                    return new FlowUpdateResult { Status = \"error\", Message = \"âŒ A flow with this name already exists.\" };\n\n                var needsRepublish = flow.IsPublished;\n\n                await using var tx = await _context.Database.BeginTransactionAsync();\n\n                // Update config and flip to draft on any edit\n                flow.FlowName = trimmedName;\n                flow.IsPublished = false;\n                flow.UpdatedAt = DateTime.UtcNow;\n\n                // Remove existing steps + links (we re-materialize from the visual payload)\n                foreach (var s in flow.Steps)\n                    _context.FlowButtonLinks.RemoveRange(s.ButtonLinks);\n\n                _context.CTAFlowSteps.RemoveRange(flow.Steps);\n                await _context.SaveChangesAsync();\n\n                // Recreate steps from nodes (preserve ids when possible)\n                var stepMap = new Dictionary<string, CTAFlowStep>(StringComparer.OrdinalIgnoreCase);\n                var orderIndex = 0;\n\n                foreach (var node in dto.Nodes)\n                {\n                    if (string.IsNullOrWhiteSpace(node.Id)) continue;\n\n                    var stepId = Guid.TryParse(node.Id, out var gid) ? gid : Guid.NewGuid();\n\n                    var step = new CTAFlowStep\n                    {\n                        Id = stepId,\n                        CTAFlowConfigId = flow.Id,\n                        StepOrder = orderIndex++,\n                        TemplateToSend = node.TemplateName,\n                        TemplateType = node.TemplateType ?? \"UNKNOWN\",\n                        HeaderMediaUrl = string.IsNullOrWhiteSpace(node.HeaderMediaUrl) ? null : node.HeaderMediaUrl.Trim(),\n                        BodyParamsJson = SerializeBodyParams(node.BodyParams),\n                        UrlButtonParamsJson = SerializeUrlButtonParams(node.UrlButtonParams),\n                        TriggerButtonText = node.TriggerButtonText ?? \"\",\n                        TriggerButtonType = node.TriggerButtonType ?? \"cta\",\n                        PositionX = node.PositionX == 0 ? Random.Shared.Next(100, 600) : node.PositionX,\n                        PositionY = node.PositionY == 0 ? Random.Shared.Next(100, 400) : node.PositionY,\n                        UseProfileName = node.UseProfileName,\n                        ProfileNameSlot = node.ProfileNameSlot,\n                        ButtonLinks = new List<FlowButtonLink>()\n                    };\n\n                    // Only text templates may use profile name slot\n                    var isTextTemplate = string.Equals(step.TemplateType, \"text_template\", StringComparison.OrdinalIgnoreCase);\n                    if (!isTextTemplate)\n                    {\n                        step.UseProfileName = false;\n                        step.ProfileNameSlot = null;\n                    }\n                    else if (!step.UseProfileName)\n                    {\n                        step.ProfileNameSlot = null;\n                    }\n                    else if (!step.ProfileNameSlot.HasValue || step.ProfileNameSlot.Value < 1)\n                    {\n                        step.ProfileNameSlot = 1;\n                    }\n\n                    stepMap[node.Id] = step;\n                    _context.CTAFlowSteps.Add(step);\n                }\n\n                // Wire links per node via edges (SourceHandle == button text)\n                var edges = dto.Edges ?? new List<FlowEdgeDto>();\n\n                foreach (var node in dto.Nodes)\n                {\n                    if (string.IsNullOrWhiteSpace(node.Id) || !stepMap.TryGetValue(node.Id, out var fromStep))\n                        continue;\n\n                    var outEdges = edges\n                        .Where(e => string.Equals(e.FromNodeId, node.Id, StringComparison.OrdinalIgnoreCase))\n                        .ToList();\n\n                    var seenTexts = new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n                    var orderedButtons = (node.Buttons ?? new List<LinkButtonDto>())\n                        .OrderBy(b => b.Index < 0 ? int.MaxValue : b.Index)\n                        .ThenBy(b => b.Text ?? string.Empty)\n                        .ToList();\n\n                    short nextIdx = 0;\n\n                    foreach (var btn in orderedButtons)\n                    {\n                        var text = (btn.Text ?? string.Empty).Trim();\n                        if (string.IsNullOrEmpty(text)) continue;\n                        if (!seenTexts.Add(text)) continue; // dedupe\n\n                        var edge = outEdges.FirstOrDefault(e =>\n                            string.Equals(e.SourceHandle ?? string.Empty, text, StringComparison.OrdinalIgnoreCase));\n                        if (edge == null) continue;\n\n                        if (!stepMap.TryGetValue(edge.ToNodeId, out var toStep)) continue;\n\n                        var finalIndex = btn.Index >= 0 ? btn.Index : nextIdx;\n                        nextIdx = (short)(finalIndex + 1);\n\n                        var link = new FlowButtonLink\n                        {\n                            Id = Guid.NewGuid(),\n                            CTAFlowStepId = fromStep.Id,\n                            NextStepId = toStep.Id,\n                            ButtonText = text,\n                            ButtonType = string.IsNullOrWhiteSpace(btn.Type) ? \"QUICK_REPLY\" : btn.Type,\n                            ButtonSubType = btn.SubType ?? string.Empty,\n                            ButtonValue = btn.Value ?? string.Empty,\n                            ButtonIndex = (short)finalIndex\n                        };\n\n                        _context.FlowButtonLinks.Add(link);\n                        fromStep.ButtonLinks.Add(link);\n\n                        // convenience: populate target's trigger info\n                        toStep.TriggerButtonText = text;\n                        toStep.TriggerButtonType = (btn.Type ?? \"QUICK_REPLY\").ToLowerInvariant();\n                    }\n                }\n\n                await _context.SaveChangesAsync();\n                await tx.CommitAsync();\n\n                return new FlowUpdateResult\n                {\n                    Status = \"ok\",\n                    NeedsRepublish = needsRepublish,\n                    Message = \"âœ… Flow updated (draft).\"\n                };\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"âŒ Exception while updating visual flow {FlowId}\", flowId);\n                return new FlowUpdateResult { Status = \"error\", Message = \"âŒ Internal error while updating flow.\" };\n            }\n        }\n\n        // ---------------------------\n        // FORK (create new draft copy)\n        // ---------------------------\n        public async Task<Guid> ForkFlowAsync(Guid flowId, Guid businessId, string user)\n        {\n            try\n            {\n                var src = await _context.CTAFlowConfigs\n                    .Include(f => f.Steps)\n                        .ThenInclude(s => s.ButtonLinks)\n                    .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId && f.IsActive);\n\n                if (src == null) return Guid.Empty;\n\n                // Ensure unique name (unique index on BusinessId+FlowName+IsActive)\n                var baseName = $\"{src.FlowName} (Copy)\";\n                var candidate = baseName;\n                var n = 2;\n                while (await _context.CTAFlowConfigs.AnyAsync(f =>\n                           f.BusinessId == businessId && f.IsActive && f.FlowName == candidate))\n                {\n                    candidate = $\"{baseName} {n++}\";\n                }\n\n                await using var tx = await _context.Database.BeginTransactionAsync();\n\n                var dst = new CTAFlowConfig\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    FlowName = candidate,\n                    CreatedBy = user,\n                    CreatedAt = DateTime.UtcNow,\n                    UpdatedAt = DateTime.UtcNow,\n                    IsActive = true,\n                    IsPublished = false\n                };\n                _context.CTAFlowConfigs.Add(dst);\n\n                var stepIdMap = new Dictionary<Guid, Guid>();\n                foreach (var s in src.Steps.OrderBy(x => x.StepOrder))\n                    stepIdMap[s.Id] = Guid.NewGuid();\n\n                var newSteps = src.Steps.OrderBy(x => x.StepOrder).Select(s => new CTAFlowStep\n                {\n                    Id = stepIdMap[s.Id],\n                    CTAFlowConfigId = dst.Id,\n                    StepOrder = s.StepOrder,\n                    TemplateToSend = s.TemplateToSend,\n                    TemplateType = s.TemplateType,\n                    HeaderMediaUrl = s.HeaderMediaUrl,\n                    BodyParamsJson = s.BodyParamsJson,\n                    UrlButtonParamsJson = s.UrlButtonParamsJson,\n                    TriggerButtonText = s.TriggerButtonText,\n                    TriggerButtonType = s.TriggerButtonType,\n                    RequiredTag = s.RequiredTag,\n                    RequiredSource = s.RequiredSource,\n                    PositionX = s.PositionX,\n                    PositionY = s.PositionY,\n                    UseProfileName = s.UseProfileName,\n                    ProfileNameSlot = s.ProfileNameSlot\n                }).ToList();\n\n                _context.CTAFlowSteps.AddRange(newSteps);\n\n                foreach (var srcStep in src.Steps)\n                {\n                    foreach (var b in srcStep.ButtonLinks)\n                    {\n                        var newLink = new FlowButtonLink\n                        {\n                            Id = Guid.NewGuid(),\n                            CTAFlowStepId = stepIdMap[srcStep.Id],\n                            NextStepId = (b.NextStepId.HasValue && stepIdMap.TryGetValue(b.NextStepId.Value, out var mapped))\n                                ? mapped\n                                : (Guid?)null,\n                            ButtonText = b.ButtonText,\n                            ButtonType = b.ButtonType,\n                            ButtonSubType = b.ButtonSubType,\n                            ButtonValue = b.ButtonValue,\n                            ButtonIndex = b.ButtonIndex\n                        };\n                        _context.FlowButtonLinks.Add(newLink);\n                    }\n                }\n\n                await _context.SaveChangesAsync();\n                await tx.CommitAsync();\n\n                return dst.Id;\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"âŒ Exception while forking flow {FlowId}\", flowId);\n                return Guid.Empty;\n            }\n        }\n\n        // ---------------------------\n        // RUNTIME / Matching / Execute\n        // ---------------------------\n        public async Task<CTAFlowStep?> MatchStepByButtonAsync(\n            Guid businessId,\n            string buttonText,\n            string buttonType,\n            string templateName,\n            Guid? campaignId = null)\n        {\n            var normalizedButtonText = buttonText?.Trim().ToLower() ?? \"\";\n            var normalizedButtonType = buttonType?.Trim().ToLower() ?? \"\";\n            var normalizedTemplateName = templateName?.Trim().ToLower() ?? \"\";\n\n            if (campaignId.HasValue)\n            {\n                var overrideStep = await _context.CampaignFlowOverrides\n                    .Where(o =>\n                        o.CampaignId == campaignId &&\n                        o.ButtonText.ToLower() == normalizedButtonText &&\n                        o.TemplateName.ToLower() == normalizedTemplateName)\n                    .FirstOrDefaultAsync();\n\n                if (overrideStep != null)\n                {\n                    var overrideTemplate = overrideStep.OverrideNextTemplate?.ToLower();\n                    var matched = await _context.CTAFlowSteps\n                        .Include(s => s.Flow)\n                        .FirstOrDefaultAsync(s => s.TemplateToSend.ToLower() == overrideTemplate);\n                    if (matched != null) return matched;\n                }\n            }\n\n            var fallbackStep = await _context.CTAFlowSteps\n                .Include(s => s.Flow)\n                .Where(s =>\n                    s.Flow.BusinessId == businessId &&\n                    s.Flow.IsActive &&\n                    s.Flow.IsPublished &&\n                    s.TriggerButtonText.ToLower() == normalizedButtonText &&\n                    s.TriggerButtonType.ToLower() == normalizedButtonType)\n                .FirstOrDefaultAsync();\n\n            return fallbackStep;\n        }\n\n        public async Task<ResponseResult> ExecuteVisualFlowAsync(Guid businessId, Guid startStepId, Guid trackingLogId, Guid? campaignSendLogId)\n        {\n            try\n            {\n                var log = await _context.TrackingLogs\n                    .Include(l => l.Contact)\n                        .ThenInclude(c => c.ContactTags)\n                            .ThenInclude(ct => ct.Tag)\n                    .FirstOrDefaultAsync(l => l.Id == trackingLogId);\n\n                if (log == null) return ResponseResult.ErrorInfo(\"Tracking log not found.\");\n\n                var step = await GetChainedStepAsync(businessId, startStepId, log, log?.Contact);\n                if (step == null) return ResponseResult.ErrorInfo(\"Step conditions not satisfied.\");\n\n                var args = new List<string>();\n                if (step.UseProfileName && step.ProfileNameSlot is int slot && slot >= 1)\n                {\n                    var contact = log.Contact ?? await _context.Contacts\n                        .AsNoTracking()\n                        .FirstOrDefaultAsync(c => c.BusinessId == businessId && c.PhoneNumber == (log.ContactPhone ?? \"\"));\n                    var greet = (contact?.ProfileName ?? contact?.Name)?.Trim();\n                    if (string.IsNullOrEmpty(greet)) greet = \"there\";\n                    while (args.Count < slot) args.Add(string.Empty);\n                    args[slot - 1] = greet;\n                }\n\n                ResponseResult sendResult;\n                switch (step.TemplateType?.ToLower())\n                {\n                    case \"image_template\":\n                        var imageDto = new ImageTemplateMessageDto\n                        {\n                            BusinessId = businessId,\n                            RecipientNumber = log.ContactPhone ?? \"\",\n                            TemplateName = step.TemplateToSend,\n                            LanguageCode = \"en_US\"\n                        };\n                        sendResult = await _messageEngineService.SendImageTemplateMessageAsync(imageDto, businessId);\n                        break;\n                    case \"text_template\":\n                    default:\n                        var textDto = new SimpleTemplateMessageDto\n                        {\n                            RecipientNumber = log.ContactPhone ?? \"\",\n                            TemplateName = step.TemplateToSend,\n                            TemplateParameters = args\n                        };\n                        sendResult = await _messageEngineService.SendTemplateMessageSimpleAsync(businessId, textDto);\n                        break;\n                }\n\n                var executionLog = new FlowExecutionLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    StepId = step.Id,\n                    FlowId = step.CTAFlowConfigId,\n                    Origin = FlowExecutionOrigin.Campaign, // added fro autoreply flow\n                    CampaignSendLogId = campaignSendLogId,\n                    TrackingLogId = trackingLogId,\n                    ContactPhone = log.ContactPhone,\n                    TriggeredByButton = step.TriggerButtonText,\n                    TemplateName = step.TemplateToSend,\n                    TemplateType = step.TemplateType,\n                    Success = sendResult.Success,\n                    ErrorMessage = sendResult.ErrorMessage,\n                    RawResponse = sendResult.RawResponse,\n                    ExecutedAt = DateTime.UtcNow\n                };\n\n                _context.FlowExecutionLogs.Add(executionLog);\n                await _context.SaveChangesAsync();\n\n                return ResponseResult.SuccessInfo($\"Flow step executed. Sent: {sendResult.Success}\", null, sendResult.RawResponse);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"âŒ Exception during ExecuteVisualFlowAsync()\");\n                return ResponseResult.ErrorInfo(\"Internal error during flow execution.\");\n            }\n        }\n\n        public Task<CTAFlowStep?> GetChainedStepAsync(Guid businessId, Guid? nextStepId)\n            => GetChainedStepAsync(businessId, nextStepId, null, null);\n\n        public async Task<CTAFlowStep?> GetChainedStepAsync(Guid businessId, Guid? nextStepId, TrackingLog? trackingLog, Contact? contact)\n        {\n            if (nextStepId == null) return null;\n\n            var flow = await _context.CTAFlowConfigs\n                .Include(f => f.Steps)\n                .FirstOrDefaultAsync(f =>\n                    f.BusinessId == businessId &&\n                    f.Steps.Any(s => s.Id == nextStepId));\n\n            var followUpStep = flow?.Steps.FirstOrDefault(s => s.Id == nextStepId);\n            if (followUpStep == null) return null;\n\n            if (trackingLog != null)\n            {\n                var isMatch = StepMatchingHelper.IsStepMatched(followUpStep, trackingLog, contact);\n                if (!isMatch) return null;\n            }\n\n            return followUpStep;\n        }\n\n        public async Task<CTAFlowStep?> GetChainedStepWithContextAsync(Guid businessId, Guid? nextStepId, Guid? trackingLogId)\n        {\n            var log = await _context.TrackingLogs\n                .Include(l => l.Contact)\n                    .ThenInclude(c => c.ContactTags)\n                        .ThenInclude(ct => ct.Tag)\n                .FirstOrDefaultAsync(l => l.Id == trackingLogId);\n\n            return await GetChainedStepAsync(businessId, nextStepId, log, log?.Contact);\n        }\n\n        // âœ… MISSING IMPLEMENTATION (to satisfy the interface)\n        public async Task<FlowButtonLink?> GetLinkAsync(Guid flowId, Guid sourceStepId, short buttonIndex)\n        {\n            return await _context.FlowButtonLinks\n                .Where(l => l.CTAFlowStepId == sourceStepId\n                            && l.NextStepId != null\n                            && l.Step.CTAFlowConfigId == flowId\n                            && l.ButtonIndex == buttonIndex)\n                .SingleOrDefaultAsync();\n        }\n    }\n}\n\n\n//using Microsoft.AspNetCore.Authorization;\n//using Microsoft.AspNetCore.Mvc;\n//using Microsoft.EntityFrameworkCore;\n//using Serilog;\n//using xbytechat.api.AuthModule.Models;\n//using xbytechat.api.CRM.Models;\n//using xbytechat.api.Features.CTAFlowBuilder.DTOs;\n//using xbytechat.api.Features.CTAFlowBuilder.Models;\n//using xbytechat.api.Features.MessagesEngine.DTOs;\n//using xbytechat.api.Features.MessagesEngine.Services;\n//using xbytechat.api.Features.Tracking.Models;\n//using xbytechat.api.Helpers;\n//using xbytechat.api.WhatsAppSettings.DTOs;\n//using xbytechat_api.WhatsAppSettings.Services;\n\n//namespace xbytechat.api.Features.CTAFlowBuilder.Services\n//{\n//    public class CTAFlowService : ICTAFlowService\n//    {\n//        private readonly AppDbContext _context;\n//        private readonly IMessageEngineService _messageEngineService;\n//        private readonly IWhatsAppTemplateFetcherService _templateFetcherService;\n\n//        public CTAFlowService(AppDbContext context, IMessageEngineService messageEngineService,\n//            IWhatsAppTemplateFetcherService templateFetcherService\n//            )\n//        {\n//            _context = context;\n//            _messageEngineService = messageEngineService;\n//            _templateFetcherService = templateFetcherService;\n//        }\n\n//        public async Task<Guid> CreateFlowWithStepsAsync(CreateFlowDto dto, Guid businessId, string createdBy)\n//        {\n//            var flow = new CTAFlowConfig\n//            {\n//                Id = Guid.NewGuid(),\n//                FlowName = dto.FlowName,\n//                BusinessId = businessId,\n//                CreatedAt = DateTime.UtcNow,\n//                CreatedBy = createdBy,\n//                IsPublished = dto.IsPublished\n//            };\n\n//            foreach (var stepDto in dto.Steps)\n//            {\n//                var step = new CTAFlowStep\n//                {\n//                    Id = Guid.NewGuid(),\n//                    CTAFlowConfigId = flow.Id,\n//                    TriggerButtonText = stepDto.TriggerButtonText,\n//                    TriggerButtonType = stepDto.TriggerButtonType,\n//                    TemplateToSend = stepDto.TemplateToSend,\n//                    StepOrder = stepDto.StepOrder,\n//                    ButtonLinks = stepDto.ButtonLinks?.Select(link => new FlowButtonLink\n//                    {\n//                        ButtonText = link.ButtonText,\n//                        NextStepId = link.NextStepId\n//                    }).ToList() ?? new List<FlowButtonLink>()\n//                };\n\n//                flow.Steps.Add(step);\n//            }\n\n//            _context.CTAFlowConfigs.Add(flow);\n//            await _context.SaveChangesAsync();\n\n//            return flow.Id;\n//        }\n\n//        public async Task<CTAFlowConfig?> GetFlowByBusinessAsync(Guid businessId)\n//        {\n//            return await _context.CTAFlowConfigs\n//                .Include(f => f.Steps.OrderBy(s => s.StepOrder))\n//                .Where(f => f.BusinessId == businessId && f.IsActive && f.IsPublished)\n//                .FirstOrDefaultAsync();\n//        }\n\n//        public async Task<CTAFlowConfig?> GetDraftFlowByBusinessAsync(Guid businessId)\n//        {\n//            return await _context.CTAFlowConfigs\n//                .Include(f => f.Steps)\n//                    .ThenInclude(s => s.ButtonLinks)\n//                .Where(f => f.BusinessId == businessId && f.IsPublished == false)\n//                .OrderByDescending(f => f.CreatedAt)\n//                .FirstOrDefaultAsync();\n//        }\n\n\n\n//        public async Task<List<CTAFlowStep>> GetStepsForFlowAsync(Guid flowId)\n//        {\n//            return await _context.CTAFlowSteps\n//                .Where(s => s.CTAFlowConfigId == flowId)\n//                .OrderBy(s => s.StepOrder)\n//                .ToListAsync();\n//        }\n\n//        public async Task<CTAFlowStep?> MatchStepByButtonAsync(\n//            Guid businessId,\n//            string buttonText,\n//            string buttonType,\n//            string TemplateName,\n//            Guid? campaignId = null)\n//        {\n//            var normalizedButtonText = buttonText?.Trim().ToLower() ?? \"\";\n//            var normalizedButtonType = buttonType?.Trim().ToLower() ?? \"\";\n//            var normalizedTemplateName = TemplateName?.Trim().ToLower() ?? \"\";\n\n//            // 1ï¸âƒ£ Try campaign-specific override\n//            if (campaignId.HasValue)\n//            {\n//                var overrideStep = await _context.CampaignFlowOverrides\n//                    .Where(o =>\n//                        o.CampaignId == campaignId &&\n//                        o.ButtonText.ToLower() == normalizedButtonText &&\n//                        o.TemplateName.ToLower() == normalizedTemplateName)\n//                    .FirstOrDefaultAsync();\n\n//                if (overrideStep != null)\n//                {\n//                    var overrideTemplate = overrideStep.OverrideNextTemplate?.ToLower();\n\n//                    var matched = await _context.CTAFlowSteps\n//                        .Include(s => s.Flow)\n//                        .FirstOrDefaultAsync(s => s.TemplateToSend.ToLower() == overrideTemplate);\n\n//                    if (matched != null)\n//                    {\n//                        Log.Information(\"ðŸ” Override matched: Template '{Template}' â†’ Step '{StepId}'\", overrideStep.OverrideNextTemplate, matched.Id);\n//                        return matched;\n//                    }\n\n//                    Log.Warning(\"âš ï¸ Override found for button '{Button}' but no matching step for template '{Template}'\", normalizedButtonText, overrideStep.OverrideNextTemplate);\n//                }\n\n//                else\n//                {\n//                    Log.Information(\"ðŸŸ¡ No campaign override found for button '{Button}' on template '{Template}'\", normalizedButtonText, normalizedTemplateName);\n//                }\n//            }\n\n//            // 2ï¸âƒ£ Fallback to standard flow logic\n//            var fallbackStep = await _context.CTAFlowSteps\n//                .Include(s => s.Flow)\n//                .Where(s =>\n//                    s.Flow.BusinessId == businessId &&\n//                    s.Flow.IsActive &&\n//                    s.Flow.IsPublished &&\n//                    s.TriggerButtonText.ToLower() == normalizedButtonText &&\n//                    s.TriggerButtonType.ToLower() == normalizedButtonType)\n//                .FirstOrDefaultAsync();\n\n//            if (fallbackStep != null)\n//            {\n//                Log.Information(\"âœ… Fallback flow step matched: StepId = {StepId}, Flow = {FlowName}\", fallbackStep.Id, fallbackStep.Flow?.FlowName);\n//            }\n//            else\n//            {\n//                Log.Warning(\"âŒ No fallback step matched for button '{ButtonText}' of type '{ButtonType}' in BusinessId: {BusinessId}\", normalizedButtonText, normalizedButtonType, businessId);\n//            }\n\n//            return fallbackStep;\n//        }\n\n\n//        public async Task<bool> PublishFlowAsync(Guid flowId, Guid businessId, string user)\n//        {\n//            var flow = await _context.CTAFlowConfigs\n//                .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId && f.IsActive);\n\n//            if (flow is null) return false;\n\n//            // Optional validation: ensure it has at least 1 step, etc.\n//            flow.IsPublished = true;\n//            flow.UpdatedAt = DateTime.UtcNow;\n//            await _context.SaveChangesAsync();\n//            return true;\n//        }\n\n//        //public async Task<ResponseResult> PublishFlowAsync(Guid businessId, List<FlowStepDto> steps, string createdBy)\n//        //{\n//        //    try\n//        //    {\n//        //        // ðŸ”¥ 1. Remove existing published flow for this business\n//        //        var existingFlows = await _context.CTAFlowConfigs\n//        //            .Where(f => f.BusinessId == businessId && f.IsPublished)\n//        //            .ToListAsync();\n\n//        //        if (existingFlows.Any())\n//        //        {\n//        //            _context.CTAFlowConfigs.RemoveRange(existingFlows);\n//        //        }\n\n//        //        // ðŸŒ± 2. Create new flow config\n//        //        var flowConfig = new CTAFlowConfig\n//        //        {\n//        //            Id = Guid.NewGuid(),\n//        //            BusinessId = businessId,\n//        //            FlowName = \"Published Flow - \" + DateTime.UtcNow.ToString(\"yyyyMMdd-HHmm\"),\n//        //            IsPublished = true,\n//        //            IsActive = true,\n//        //            CreatedBy = createdBy,\n//        //            CreatedAt = DateTime.UtcNow,\n//        //            Steps = new List<CTAFlowStep>()\n//        //        };\n\n//        //        // ðŸ” 3. Convert each step DTO to model\n//        //        foreach (var stepDto in steps)\n//        //        {\n//        //            var step = new CTAFlowStep\n//        //            {\n//        //                Id = Guid.NewGuid(),\n//        //                CTAFlowConfigId = flowConfig.Id,\n//        //                TriggerButtonText = stepDto.TriggerButtonText,\n//        //                TriggerButtonType = stepDto.TriggerButtonType,\n//        //                TemplateToSend = stepDto.TemplateToSend,\n//        //                StepOrder = stepDto.StepOrder,\n//        //                ButtonLinks = stepDto.ButtonLinks.Select(bl => new FlowButtonLink\n//        //                {\n//        //                    Id = Guid.NewGuid(),\n//        //                    ButtonText = bl.ButtonText,\n//        //                    NextStepId = bl.NextStepId,\n//        //                }).ToList()\n//        //            };\n\n//        //            flowConfig.Steps.Add(step);\n//        //        }\n\n//        //        // ðŸ’¾ 4. Save to DB\n//        //        await _context.CTAFlowConfigs.AddAsync(flowConfig);\n//        //        await _context.SaveChangesAsync();\n\n//        //        return ResponseResult.SuccessInfo(\"âœ… Flow published successfully.\");\n//        //    }\n//        //    catch (Exception ex)\n//        //    {\n//        //        Log.Error(ex, \"âŒ Error while publishing CTA flow.\");\n//        //        return ResponseResult.ErrorInfo(\"âŒ Could not publish flow.\");\n//        //    }\n//        //}\n\n\n//        private static int CountBodyPlaceholders(string? body)\n//        {\n//            if (string.IsNullOrWhiteSpace(body)) return 0;\n//            // counts {{1}}, {{2}}, ... ; ignores any non-numeric moustaches\n//            var m = System.Text.RegularExpressions.Regex.Matches(body, @\"\\{\\{\\s*\\d+\\s*\\}\\}\");\n//            return m.Count;\n//        }\n//        public async Task<ResponseResult> SaveVisualFlowAsync(\n//    SaveVisualFlowDto dto,\n//    Guid businessId,\n//    string createdBy)\n//        {\n//            try\n//            {\n//                Log.Information(\"ðŸ§  SaveVisualFlow (create-only) | FlowName: {FlowName} | Biz: {BusinessId}\",\n//                    dto.FlowName, businessId);\n\n//                // 0) Basic validation\n//                if (dto.Nodes == null || !dto.Nodes.Any())\n//                    return ResponseResult.ErrorInfo(\"âŒ Cannot save an empty flow. Please add at least one step.\");\n\n//                var trimmedName = (dto.FlowName ?? \"\").Trim();\n//                if (trimmedName.Length == 0)\n//                    return ResponseResult.ErrorInfo(\"âŒ Flow name is required.\");\n\n//                // 1) CREATE-ONLY: refuse duplicate name for this business\n//                var nameExists = await _context.CTAFlowConfigs\n//                    .AnyAsync(f => f.BusinessId == businessId && f.FlowName == trimmedName && f.IsActive);\n\n//                if (nameExists)\n//                {\n//                    // IMPORTANT: this method is only for *new* flows.\n//                    // If the user is editing an existing flow, the UI should call PUT /cta-flow/{id}.\n//                    Log.Warning(\"âš ï¸ Duplicate flow name '{Name}' for business {Biz}.\", trimmedName, businessId);\n//                    return ResponseResult.ErrorInfo(\n//                        \"âŒ A flow with this name already exists. Open that flow and edit it, or choose a different name.\");\n//                }\n\n//                await using var tx = await _context.Database.BeginTransactionAsync();\n\n//                // 2) Insert FlowConfig\n//                var flow = new CTAFlowConfig\n//                {\n//                    Id = Guid.NewGuid(),\n//                    BusinessId = businessId,\n//                    FlowName = trimmedName,\n//                    CreatedBy = createdBy,\n//                    CreatedAt = DateTime.UtcNow,\n//                    UpdatedAt = DateTime.UtcNow,\n//                    IsActive = true,\n//                    // You *can* allow creating as published, but most teams prefer create-as-draft:\n//                    IsPublished = dto.IsPublished\n//                };\n//                _context.CTAFlowConfigs.Add(flow);\n\n//                // 3) Build Steps\n//                var stepMap = new Dictionary<string, CTAFlowStep>(StringComparer.OrdinalIgnoreCase);\n//                var orderIndex = 0;\n\n//                foreach (var node in dto.Nodes)\n//                {\n//                    if (string.IsNullOrWhiteSpace(node.Id)) continue;\n\n//                    var step = new CTAFlowStep\n//                    {\n//                        Id = Guid.NewGuid(),\n//                        CTAFlowConfigId = flow.Id,\n//                        StepOrder = orderIndex++,\n//                        TemplateToSend = node.TemplateName,\n//                        TemplateType = node.TemplateType ?? \"UNKNOWN\",\n//                        TriggerButtonText = node.TriggerButtonText ?? \"\",\n//                        TriggerButtonType = node.TriggerButtonType ?? \"cta\",\n//                        PositionX = node.PositionX == 0 ? Random.Shared.Next(100, 600) : node.PositionX,\n//                        PositionY = node.PositionY == 0 ? Random.Shared.Next(100, 400) : node.PositionY,\n//                        UseProfileName = node.UseProfileName,\n//                        ProfileNameSlot = node.ProfileNameSlot,\n//                        ButtonLinks = new List<FlowButtonLink>()\n//                    };\n\n//                    // Harden profile-name config per template type\n//                    var isTextTemplate = string.Equals(step.TemplateType, \"text_template\", StringComparison.OrdinalIgnoreCase);\n//                    if (!isTextTemplate)\n//                    {\n//                        step.UseProfileName = false;\n//                        step.ProfileNameSlot = null;\n//                    }\n//                    else\n//                    {\n//                        if (!step.UseProfileName)\n//                        {\n//                            step.ProfileNameSlot = null;\n//                        }\n//                        else\n//                        {\n//                            if (!step.ProfileNameSlot.HasValue || step.ProfileNameSlot.Value < 1)\n//                                step.ProfileNameSlot = 1;\n//                        }\n//                    }\n\n//                    stepMap[node.Id] = step;\n//                    _context.CTAFlowSteps.Add(step);\n//                }\n\n//                // 4) Build Links (per-node buttons, matched by SourceHandle == button text)\n//                var edges = dto.Edges ?? new List<FlowEdgeDto>();\n\n//                foreach (var node in dto.Nodes)\n//                {\n//                    if (string.IsNullOrWhiteSpace(node.Id) || !stepMap.TryGetValue(node.Id, out var fromStep))\n//                        continue;\n\n//                    var outEdges = edges.Where(e => string.Equals(e.FromNodeId, node.Id, StringComparison.OrdinalIgnoreCase)).ToList();\n//                    var seenTexts = new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n\n//                    var orderedButtons = (node.Buttons ?? new List<LinkButtonDto>())\n//                        .OrderBy(b => b.Index < 0 ? int.MaxValue : b.Index)\n//                        .ThenBy(b => b.Text ?? string.Empty)\n//                        .ToList();\n\n//                    short nextIdx = 0;\n\n//                    foreach (var btn in orderedButtons)\n//                    {\n//                        var text = (btn.Text ?? string.Empty).Trim();\n//                        if (string.IsNullOrEmpty(text)) continue;\n\n//                        if (!seenTexts.Add(text))\n//                        {\n//                            Log.Warning(\"âš ï¸ Duplicate button text '{Text}' on node {NodeId}; first wins.\", text, node.Id);\n//                            continue;\n//                        }\n\n//                        var edge = outEdges.FirstOrDefault(e =>\n//                            string.Equals(e.SourceHandle ?? string.Empty, text, StringComparison.OrdinalIgnoreCase));\n//                        if (edge == null) continue;\n\n//                        if (!stepMap.TryGetValue(edge.ToNodeId, out var toStep)) continue;\n\n//                        var finalIndex = btn.Index >= 0 ? btn.Index : nextIdx;\n//                        nextIdx = (short)(finalIndex + 1);\n\n//                        var link = new FlowButtonLink\n//                        {\n//                            Id = Guid.NewGuid(),\n//                            CTAFlowStepId = fromStep.Id,\n//                            NextStepId = toStep.Id,\n//                            ButtonText = text,\n//                            ButtonType = string.IsNullOrWhiteSpace(btn.Type) ? \"QUICK_REPLY\" : btn.Type,\n//                            ButtonSubType = btn.SubType ?? string.Empty,\n//                            ButtonValue = btn.Value ?? string.Empty,\n//                            ButtonIndex = (short)finalIndex\n//                        };\n\n//                        _context.FlowButtonLinks.Add(link);\n//                        fromStep.ButtonLinks.Add(link);\n\n//                        // convenience: target step \"entry trigger\"\n//                        toStep.TriggerButtonText = text;\n//                        toStep.TriggerButtonType = (btn.Type ?? \"QUICK_REPLY\").ToLowerInvariant();\n//                    }\n//                }\n\n//                await _context.SaveChangesAsync();\n//                await tx.CommitAsync();\n\n//                Log.Information(\"âœ… Flow created '{Flow}' | Steps: {Steps} | Links: {Links}\",\n//                    flow.FlowName, stepMap.Count, stepMap.Values.Sum(s => s.ButtonLinks.Count));\n\n//                // Return new flowId so the FE can redirect/open it if desired\n//                return ResponseResult.SuccessInfo(\"âœ… Flow created.\", new { flowId = flow.Id });\n//            }\n//            catch (Exception ex)\n//            {\n//                Log.Error(ex, \"âŒ Exception while saving (create) flow\");\n//                return ResponseResult.ErrorInfo(\"âŒ Internal error while saving flow.\");\n//            }\n//        }\n\n//        //public async Task<ResponseResult> SaveVisualFlowAsync(SaveVisualFlowDto dto, Guid businessId, string createdBy)\n//        //{\n//        //    try\n//        //    {\n//        //        Log.Information(\"ðŸ§  SaveVisualFlow started | FlowName: {FlowName} | BusinessId: {BusinessId}\", dto.FlowName, businessId);\n\n//        //        if (dto.Nodes == null || !dto.Nodes.Any())\n//        //        {\n//        //            Log.Warning(\"âŒ No nodes found in flow. Aborting save.\");\n//        //            return ResponseResult.ErrorInfo(\"âŒ Cannot save an empty flow. Please add at least one step.\");\n//        //        }\n\n//        //        // 1) Upsert FlowConfig\n//        //        var flow = await _context.CTAFlowConfigs\n//        //            .FirstOrDefaultAsync(f => f.FlowName == dto.FlowName && f.BusinessId == businessId);\n\n//        //        if (flow == null)\n//        //        {\n//        //            flow = new CTAFlowConfig\n//        //            {\n//        //                Id = Guid.NewGuid(),\n//        //                BusinessId = businessId,\n//        //                FlowName = dto.FlowName,\n//        //                CreatedBy = createdBy,\n//        //                CreatedAt = DateTime.UtcNow,\n//        //                UpdatedAt = DateTime.UtcNow,\n//        //                IsActive = true,\n//        //                IsPublished = dto.IsPublished\n//        //            };\n//        //            _context.CTAFlowConfigs.Add(flow);\n//        //            Log.Information(\"âœ… New FlowConfig created with ID: {Id}\", flow.Id);\n//        //        }\n//        //        else\n//        //        {\n//        //            // wipe old steps+links for a clean replace\n//        //            var oldSteps = await _context.CTAFlowSteps\n//        //                .Where(s => s.CTAFlowConfigId == flow.Id)\n//        //                .Include(s => s.ButtonLinks)\n//        //                .ToListAsync();\n\n//        //            foreach (var step in oldSteps)\n//        //                _context.FlowButtonLinks.RemoveRange(step.ButtonLinks);\n\n//        //            _context.CTAFlowSteps.RemoveRange(oldSteps);\n\n//        //            flow.IsPublished = dto.IsPublished;\n//        //            flow.UpdatedAt = DateTime.UtcNow;\n//        //        }\n\n//        //        // 2) Build Steps (map by incoming node.Id string)\n//        //        var stepMap = new Dictionary<string, CTAFlowStep>(StringComparer.OrdinalIgnoreCase);\n\n//        //        foreach (var (node, index) in dto.Nodes.Select((n, i) => (n, i)))\n//        //        {\n//        //            if (string.IsNullOrWhiteSpace(node.Id))\n//        //                continue;\n\n//        //            var step = new CTAFlowStep\n//        //            {\n//        //                Id = Guid.NewGuid(),\n//        //                CTAFlowConfigId = flow.Id,\n//        //                StepOrder = index,\n//        //                TemplateToSend = node.TemplateName,\n//        //                TemplateType = node.TemplateType ?? \"UNKNOWN\",\n//        //                TriggerButtonText = node.TriggerButtonText ?? \"\",\n//        //                TriggerButtonType = node.TriggerButtonType ?? \"cta\",\n//        //                PositionX = node.PositionX == 0 ? Random.Shared.Next(100, 600) : node.PositionX,\n//        //                PositionY = node.PositionY == 0 ? Random.Shared.Next(100, 400) : node.PositionY,\n//        //                UseProfileName = node.UseProfileName,\n//        //                ProfileNameSlot = node.ProfileNameSlot,\n//        //                //ProfileNameSlot = node.ProfileNameSlot ?? 1,\n//        //                ButtonLinks = new List<FlowButtonLink>()\n//        //            };\n\n//        //            // âœ… Harden profile-name config per step\n//        //            var isTextTemplate = string.Equals(step.TemplateType, \"text_template\", StringComparison.OrdinalIgnoreCase);\n//        //            if (!isTextTemplate)\n//        //            {\n//        //                // Only text templates support body placeholders; disable on others\n//        //                step.UseProfileName = false;\n//        //                step.ProfileNameSlot = null;\n//        //            }\n//        //            //else if (step.UseProfileName)\n//        //            //{\n//        //            //    // Clamp to minimum valid slot\n//        //            //    if (!step.ProfileNameSlot.HasValue || step.ProfileNameSlot.Value < 1)\n//        //            //        step.ProfileNameSlot = 1;\n//        //            //}\n//        //            else\n//        //            {\n//        //                // Text template:\n//        //                if (!step.UseProfileName)\n//        //                {\n//        //                    // Toggle OFF â†’ always null the slot\n//        //                    step.ProfileNameSlot = null;\n//        //                }\n//        //                else\n//        //                {\n//        //                    // Toggle ON â†’ clamp to minimum valid\n//        //                    if (!step.ProfileNameSlot.HasValue || step.ProfileNameSlot.Value < 1)\n//        //                        step.ProfileNameSlot = 1;\n//        //                    // (Optional) upper clamp if you want: e.g., step.ProfileNameSlot = Math.Min(step.ProfileNameSlot.Value, 50);\n//        //                }\n//        //            }\n//        //            stepMap[node.Id] = step;\n//        //            _context.CTAFlowSteps.Add(step);\n//        //        }\n\n//        //        // 3) Build Links PER NODE using buttons order (with Index), not per-edge blindly\n//        //        foreach (var node in dto.Nodes)\n//        //        {\n//        //            if (string.IsNullOrWhiteSpace(node.Id) || !stepMap.TryGetValue(node.Id, out var fromStep))\n//        //                continue;\n\n//        //            // outgoing edges from this node\n//        //            var outEdges = dto.Edges?.Where(e => string.Equals(e.FromNodeId, node.Id, StringComparison.OrdinalIgnoreCase)).ToList()\n//        //                           ?? new List<FlowEdgeDto>();\n\n//        //            // dedupe by button text to avoid ambiguous routing\n//        //            var seenTexts = new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n\n//        //            // stable ordering: by provided Index (0..N), then by Text\n//        //            var orderedButtons = (node.Buttons ?? new List<LinkButtonDto>())\n//        //                .OrderBy(b => b.Index < 0 ? int.MaxValue : b.Index)\n//        //                .ThenBy(b => b.Text ?? string.Empty)\n//        //                .ToList();\n\n//        //            short nextIdx = 0;\n\n//        //            foreach (var btn in orderedButtons)\n//        //            {\n//        //                var text = (btn.Text ?? string.Empty).Trim();\n//        //                if (string.IsNullOrEmpty(text))\n//        //                    continue;\n\n//        //                if (!seenTexts.Add(text))\n//        //                {\n//        //                    Log.Warning(\"âš ï¸ Duplicate button text '{Text}' on node {NodeId}; keeping first, skipping duplicates.\", text, node.Id);\n//        //                    continue;\n//        //                }\n\n//        //                // match edge by SourceHandle == button text (how ReactFlow wires handles)\n//        //                var edge = outEdges.FirstOrDefault(e =>\n//        //                    string.Equals(e.SourceHandle ?? string.Empty, text, StringComparison.OrdinalIgnoreCase));\n//        //                if (edge == null)\n//        //                {\n//        //                    // no wire from this button â†’ skip link creation but keep button metadata in UI on reload\n//        //                    continue;\n//        //                }\n\n//        //                if (!stepMap.TryGetValue(edge.ToNodeId, out var toStep))\n//        //                    continue;\n\n//        //                // final index: prefer incoming payload Index; else fallback to a sequential counter\n//        //                var finalIndex = btn.Index >= 0 ? btn.Index : nextIdx;\n//        //                nextIdx = (short)(finalIndex + 1);\n\n//        //                var link = new FlowButtonLink\n//        //                {\n//        //                    Id = Guid.NewGuid(),\n//        //                    CTAFlowStepId = fromStep.Id,\n//        //                    NextStepId = toStep.Id,\n//        //                    ButtonText = text,\n//        //                    ButtonType = string.IsNullOrWhiteSpace(btn.Type) ? \"QUICK_REPLY\" : btn.Type,\n//        //                    ButtonSubType = btn.SubType ?? string.Empty,\n//        //                    ButtonValue = btn.Value ?? string.Empty,\n//        //                    ButtonIndex = (short)finalIndex // ðŸ”‘ persist the index\n//        //                };\n\n//        //                _context.FlowButtonLinks.Add(link);\n//        //                fromStep.ButtonLinks.Add(link);\n\n//        //                // propagate trigger info on the target step for convenience\n//        //                toStep.TriggerButtonText = text;\n//        //                toStep.TriggerButtonType = (btn.Type ?? \"QUICK_REPLY\").ToLowerInvariant();\n//        //            }\n//        //        }\n\n//        //        await _context.SaveChangesAsync();\n\n//        //        Log.Information(\"âœ… Flow '{Flow}' saved | Steps: {StepCount} | Links: {LinkCount}\",\n//        //            dto.FlowName, stepMap.Count, stepMap.Values.Sum(s => s.ButtonLinks.Count));\n\n//        //        return ResponseResult.SuccessInfo(\"âœ… Flow saved successfully.\");\n//        //    }\n//        //    catch (Exception ex)\n//        //    {\n//        //        Log.Error(ex, \"âŒ Exception while saving flow\");\n//        //        return ResponseResult.ErrorInfo(\"âŒ Internal error while saving flow.\");\n//        //    }\n//        //}\n\n\n//        //public async Task<SaveVisualFlowDto?> GetVisualFlowByIdAsync(Guid flowId, Guid businessId)\n//        //{\n//        //    var flow = await _context.CTAFlowConfigs\n//        //        .Include(c => c.Steps)\n//        //            .ThenInclude(s => s.ButtonLinks)\n//        //        .FirstOrDefaultAsync(c =>\n//        //            c.Id == flowId &&\n//        //            c.BusinessId == businessId &&   // ðŸ‘ˆ tenant scoping\n//        //            c.IsActive);\n\n//        //    if (flow == null) return null;\n\n//        //    // ---- Pre-fetch unique template names (defensive) ----\n//        //    var templateMap = new Dictionary<string, TemplateMetadataDto>(StringComparer.OrdinalIgnoreCase);\n//        //    foreach (var name in flow.Steps\n//        //                             .Select(s => s.TemplateToSend)\n//        //                             .Where(n => !string.IsNullOrWhiteSpace(n))\n//        //                             .Distinct(StringComparer.OrdinalIgnoreCase))\n//        //    {\n//        //        try\n//        //        {\n//        //            var tpl = await _templateFetcherService.GetTemplateByNameAsync(\n//        //                businessId, name!, includeButtons: true);\n//        //            if (tpl != null) templateMap[name!] = tpl;\n//        //        }\n//        //        catch (Exception ex)\n//        //        {\n//        //            Log.Warning(ex, \"âš ï¸ Failed to fetch template from Meta for {Template}\", name);\n//        //        }\n//        //    }\n\n//        //    // ---- Nodes ----\n//        //    var nodes = flow.Steps.Select(step =>\n//        //    {\n//        //        templateMap.TryGetValue(step.TemplateToSend ?? \"\", out var template);\n\n//        //        IEnumerable<FlowButtonLink> links =\n//        //            step.ButtonLinks ?? Enumerable.Empty<FlowButtonLink>();\n\n//        //        var dbButtons = links.Select(link => new LinkButtonDto\n//        //        {\n//        //            Text = link.ButtonText,\n//        //            Type = link.ButtonType,\n//        //            SubType = link.ButtonSubType,\n//        //            Value = link.ButtonValue,\n//        //            TargetNodeId = link.NextStepId?.ToString() // null-safe\n//        //        });\n\n//        //        var templateButtons = (template?.ButtonParams ?? new List<ButtonMetadataDto>())\n//        //            .Where(btn => !links.Any(bl =>\n//        //                        string.Equals(bl.ButtonText, btn.Text, StringComparison.OrdinalIgnoreCase)))\n//        //            .Select(btn => new LinkButtonDto\n//        //            {\n//        //                Text = btn.Text,\n//        //                TargetNodeId = null\n//        //            });\n\n//        //        return new FlowNodeDto\n//        //        {\n//        //            Id = step.Id.ToString(),\n//        //            TemplateName = step.TemplateToSend,\n//        //            TemplateType = step.TemplateType,\n//        //            MessageBody = template?.Body ?? \"Message body preview...\",\n//        //            TriggerButtonText = step.TriggerButtonText,\n//        //            TriggerButtonType = step.TriggerButtonType,\n//        //            PositionX = step.PositionX ?? 100,\n//        //            PositionY = step.PositionY ?? 100,\n\n//        //            // Conditional logic\n//        //            RequiredTag = step.RequiredTag,\n//        //            RequiredSource = step.RequiredSource,\n\n//        //            UseProfileName = step.UseProfileName,\n//        //            ProfileNameSlot = step.ProfileNameSlot,\n\n//        //            Buttons = dbButtons.Concat(templateButtons).ToList()\n//        //        };\n//        //    }).ToList();\n\n//        //    // ---- Edges (skip links without a target) ----\n//        //    var edges = flow.Steps\n//        //        .SelectMany(step =>\n//        //            (step.ButtonLinks ?? Enumerable.Empty<FlowButtonLink>())\n//        //            .Where(link => link.NextStepId.HasValue)\n//        //            .Select(link => new FlowEdgeDto\n//        //            {\n//        //                FromNodeId = step.Id.ToString(),\n//        //                ToNodeId = link.NextStepId!.Value.ToString(),\n//        //                SourceHandle = link.ButtonText\n//        //            }))\n//        //        .ToList();\n\n//        //    return new SaveVisualFlowDto\n//        //    {\n//        //        FlowName = flow.FlowName,\n//        //        IsPublished = flow.IsPublished,\n//        //        Nodes = nodes,\n//        //        Edges = edges\n//        //    };\n//        //}\n\n//        public async Task<SaveVisualFlowDto?> GetVisualFlowByIdAsync(Guid flowId, Guid businessId)\n//        {\n//            var flow = await _context.CTAFlowConfigs\n//                .Include(c => c.Steps)\n//                    .ThenInclude(s => s.ButtonLinks)\n//                .FirstOrDefaultAsync(c => c.Id == flowId && c.BusinessId == businessId && c.IsActive);\n\n//            if (flow == null) return null;\n\n//            // 1) Prefetch template metadata for all unique names (defensive, fast)\n//            var templateMap = new Dictionary<string, TemplateMetadataDto>(StringComparer.OrdinalIgnoreCase);\n//            var uniqueNames = flow.Steps\n//                .Select(s => s.TemplateToSend)\n//                .Where(n => !string.IsNullOrWhiteSpace(n))\n//                .Distinct(StringComparer.OrdinalIgnoreCase)\n//                .ToList();\n\n//            foreach (var name in uniqueNames)\n//            {\n//                try\n//                {\n//                    var tpl = await _templateFetcherService.GetTemplateByNameAsync(\n//                        businessId, name!, includeButtons: true);\n//                    if (tpl != null) templateMap[name!] = tpl;\n//                }\n//                catch (Exception ex)\n//                {\n//                    Log.Warning(ex, \"âš ï¸ Failed to fetch template from provider for {Template}\", name);\n//                }\n//            }\n\n//            // 2) Build nodes with real body + merged buttons (DB links first, then any unlinked template buttons)\n//            var nodes = flow.Steps.Select(step =>\n//            {\n//                templateMap.TryGetValue(step.TemplateToSend ?? \"\", out var tpl);\n\n//                var dbLinks = step.ButtonLinks ?? new List<FlowButtonLink>();\n\n//                var dbButtons = dbLinks\n//                    .OrderBy(b => b.ButtonIndex)\n//                    .Select(link => new LinkButtonDto\n//                    {\n//                        Text = link.ButtonText,\n//                        Type = link.ButtonType,\n//                        SubType = link.ButtonSubType,\n//                        Value = link.ButtonValue,\n//                        Index = link.ButtonIndex,\n//                        TargetNodeId = link.NextStepId?.ToString()\n//                    });\n\n//                var templateButtons = (tpl?.ButtonParams ?? new List<ButtonMetadataDto>())\n//                    .Where(btn => !dbLinks.Any(bl => string.Equals(bl.ButtonText, btn.Text, StringComparison.OrdinalIgnoreCase)))\n//                    .Select(btn => new LinkButtonDto\n//                    {\n//                        Text = btn.Text,\n//                        // no TargetNodeId: not wired\n//                    });\n\n//                return new FlowNodeDto\n//                {\n//                    Id = step.Id.ToString(),\n//                    TemplateName = step.TemplateToSend,\n//                    TemplateType = step.TemplateType,\n//                    MessageBody = string.IsNullOrWhiteSpace(tpl?.Body) ? \"â€” no body found â€”\" : tpl!.Body, // â† REAL BODY\n//                    TriggerButtonText = step.TriggerButtonText,\n//                    TriggerButtonType = step.TriggerButtonType,\n//                    PositionX = step.PositionX ?? 100,\n//                    PositionY = step.PositionY ?? 100,\n//                    RequiredTag = step.RequiredTag,\n//                    RequiredSource = step.RequiredSource,\n//                    UseProfileName = step.UseProfileName,\n//                    ProfileNameSlot = step.ProfileNameSlot,\n//                    Buttons = dbButtons.Concat(templateButtons).ToList()\n//                };\n//            }).ToList();\n\n//            // 3) Build edges\n//            var edges = flow.Steps\n//                .SelectMany(step => (step.ButtonLinks ?? Enumerable.Empty<FlowButtonLink>())\n//                    .Where(l => l.NextStepId.HasValue)\n//                    .Select(l => new FlowEdgeDto\n//                    {\n//                        FromNodeId = step.Id.ToString(),\n//                        ToNodeId = l.NextStepId!.Value.ToString(),\n//                        SourceHandle = l.ButtonText\n//                    }))\n//                .ToList();\n\n//            return new SaveVisualFlowDto\n//            {\n//                FlowName = flow.FlowName,\n//                IsPublished = flow.IsPublished,\n//                Nodes = nodes,\n//                Edges = edges\n//            };\n//        }\n\n//        public async Task<ResponseResult> DeleteFlowAsync(Guid flowId, Guid businessId, string deletedBy)\n//        {\n//            // Load flow with children so we can remove in the right order\n//            var flow = await _context.CTAFlowConfigs\n//                .Include(f => f.Steps)\n//                    .ThenInclude(s => s.ButtonLinks)\n//                .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId);\n\n//            if (flow == null)\n//                return ResponseResult.ErrorInfo(\"âŒ Flow not found or does not belong to you.\");\n\n//            // Is this flow used by any active campaign?\n//            var inUseQuery = _context.Campaigns\n//                .Where(c => c.BusinessId == businessId &&\n//                            !c.IsDeleted &&\n//                            c.CTAFlowConfigId == flowId);\n\n//            var inUseCount = await inUseQuery.CountAsync();\n//            if (inUseCount > 0)\n//            {\n//                // Optional: show a few campaign names in the error for the UI\n//                var sample = await inUseQuery\n//                    .OrderByDescending(c => c.CreatedAt)\n//                    .Select(c => new { c.Id, c.Name, c.Status })\n//                    .Take(5)\n//                    .ToListAsync();\n\n//                Log.Warning(\"âŒ Delete flow blocked. Flow {FlowId} is used by {Count} campaigns: {@Sample}\",\n//                    flowId, inUseCount, sample);\n\n//                return ResponseResult.ErrorInfo(\n//                    $\"âŒ Cannot delete. This flow is attached to {inUseCount} campaign(s). \" +\n//                    $\"Delete those campaigns first.\"\n//                );\n//            }\n\n//            // Safe to remove: delete children first, then the flow\n//            foreach (var step in flow.Steps)\n//                _context.FlowButtonLinks.RemoveRange(step.ButtonLinks);\n\n//            _context.CTAFlowSteps.RemoveRange(flow.Steps);\n//            _context.CTAFlowConfigs.Remove(flow);\n\n//            await _context.SaveChangesAsync();\n//            return ResponseResult.SuccessInfo(\"âœ… Flow deleted.\");\n//        }\n\n\n//        public async Task<List<VisualFlowSummaryDto>> GetAllPublishedFlowsAsync(Guid businessId)\n//        {\n//            return await _context.CTAFlowConfigs\n//                .Where(f => f.BusinessId == businessId && f.IsPublished)\n//                .OrderByDescending(f => f.CreatedAt)\n//                .Select(f => new VisualFlowSummaryDto\n//                {\n//                    Id = f.Id,\n//                    FlowName = f.FlowName,\n//                    IsPublished = f.IsPublished,\n//                    CreatedAt = f.CreatedAt\n//                })\n//                .ToListAsync();\n//        }\n\n//        public async Task<List<VisualFlowSummaryDto>> GetAllDraftFlowsAsync(Guid businessId)\n//        {\n//            return await _context.CTAFlowConfigs\n//                .Where(f => f.BusinessId == businessId && !f.IsPublished && f.IsActive)\n//                .OrderByDescending(f => f.CreatedAt)\n//                .Select(f => new VisualFlowSummaryDto\n//                {\n//                    Id = f.Id,\n//                    FlowName = f.FlowName,\n//                    CreatedAt = f.CreatedAt,\n//                    IsPublished = f.IsPublished\n//                })\n//                .ToListAsync();\n//        }\n\n//        public async Task<ResponseResult> ExecuteFollowUpStepAsync(Guid businessId, CTAFlowStep? currentStep, string recipientNumber)\n//        {\n//            // Log.Information(\"ðŸš€ Executing follow-up for BusinessId: {BusinessId}, CurrentStepId: {StepId}\", businessId);\n//            if (currentStep == null)\n//            {\n//                Log.Warning(\"âš ï¸ Cannot execute follow-up. Current step is null.\");\n//                return ResponseResult.ErrorInfo(\"Current step not found.\");\n//            }\n\n//            // ðŸ§  Step: Look through all button links for a valid NextStepId\n//            var nextLink = currentStep.ButtonLinks.FirstOrDefault(link => link.NextStepId != null);\n\n//            if (nextLink == null)\n//            {\n//                Log.Information(\"â„¹ï¸ No NextStepId defined in any ButtonLinks for StepId: {StepId}\", currentStep.Id);\n//                return ResponseResult.SuccessInfo(\"No follow-up step to execute.\");\n//            }\n\n//            // ðŸ” Fetch the next step using new logic (via CTAFlowConfig + Steps)\n//            // 1ï¸âƒ£ Try to resolve with smart condition check\n//            var followUpStep = await GetChainedStepAsync(businessId, nextLink.NextStepId, null, null);\n\n//            if (followUpStep == null)\n//            {\n//                Log.Warning(\"âŒ Follow-up step skipped due to condition mismatch â†’ StepId: {StepId}\", nextLink.NextStepId);\n\n//                // 2ï¸âƒ£ Optional fallback: Try same flow â†’ Any step without conditions\n//                var flow = await _context.CTAFlowConfigs\n//                    .Include(f => f.Steps)\n//                    .FirstOrDefaultAsync(f => f.BusinessId == businessId && f.IsPublished);\n\n//                followUpStep = flow?.Steps\n//                    .Where(s => string.IsNullOrEmpty(s.RequiredTag) && string.IsNullOrEmpty(s.RequiredSource))\n//                    .OrderBy(s => s.StepOrder)\n//                    .FirstOrDefault();\n\n//                if (followUpStep != null)\n//                {\n//                    Log.Information(\"ðŸ” Fallback step selected â†’ StepId: {StepId}, Template: {Template}\",\n//                        followUpStep.Id, followUpStep.TemplateToSend);\n//                }\n//                else\n//                {\n//                    Log.Warning(\"ðŸš« No suitable fallback found in flow. Skipping follow-up.\");\n//                    return ResponseResult.SuccessInfo(\"No matching follow-up step based on user context.\");\n//                }\n//            }\n\n\n//            // ðŸ“¨ Send the follow-up message using the TemplateToSend field\n//            try\n//            {\n//                var template = followUpStep.TemplateToSend;\n\n//                Log.Information(\"ðŸ“¤ Sending follow-up message â†’ Template: {Template}, To: {Recipient}\", template, recipientNumber);\n\n//                // ðŸ§ª Replace this with actual message engine call\n//                var sendDto = new SimpleTemplateMessageDto\n//                {\n//                    RecipientNumber = recipientNumber,\n//                    TemplateName = template,\n//                    TemplateParameters = new List<string>() // Add dynamic params later if needed\n//                };\n\n//                var sendResult = await _messageEngineService\n//     .SendTemplateMessageSimpleAsync(businessId, sendDto);\n\n//                if (!sendResult.Success)\n//                {\n//                    Log.Warning(\"âŒ Follow-up message send failed â†’ {Template}\", template);\n//                    return ResponseResult.ErrorInfo(\"Follow-up send failed.\", sendResult.ErrorMessage);\n//                }\n\n\n//                return ResponseResult.SuccessInfo($\"Follow-up message sent using template: {template}\", null, sendResult.RawResponse);\n\n//            }\n//            catch (Exception ex)\n//            {\n//                Log.Error(ex, \"âŒ Error sending follow-up message for StepId: {StepId}\", followUpStep.Id);\n//                return ResponseResult.ErrorInfo(\"Failed to send follow-up.\");\n//            }\n//        }\n//        public Task<CTAFlowStep?> GetChainedStepAsync(Guid businessId, Guid? nextStepId)\n//        {\n//            return GetChainedStepAsync(businessId, nextStepId, null, null); // Forward to full logic\n//        }\n\n//        // âœ… Extended logic with condition check (Tag + Source)\n//        public async Task<CTAFlowStep?> GetChainedStepAsync(\n//            Guid businessId,\n//            Guid? nextStepId,\n//            TrackingLog? trackingLog = null,\n//            Contact? contact = null)\n//        {\n//            if (nextStepId == null)\n//            {\n//                Log.Information(\"â„¹ï¸ No NextStepId provided â€” skipping follow-up.\");\n//                return null;\n//            }\n\n//            try\n//            {\n//                var flow = await _context.CTAFlowConfigs\n//                    .Include(f => f.Steps)\n//                    .FirstOrDefaultAsync(f =>\n//                        f.BusinessId == businessId &&\n//                        f.Steps.Any(s => s.Id == nextStepId));\n\n//                if (flow == null)\n//                {\n//                    Log.Warning(\"âš ï¸ No flow found containing NextStepId: {NextStepId} for business: {BusinessId}\", nextStepId, businessId);\n//                    return null;\n//                }\n\n//                var followUpStep = flow.Steps.FirstOrDefault(s => s.Id == nextStepId);\n\n//                if (followUpStep == null)\n//                {\n//                    Log.Warning(\"âŒ Step matched in flow but not found in step list: {NextStepId}\", nextStepId);\n//                    return null;\n//                }\n\n//                // âœ… Check RequiredTag / Source match\n//                if (trackingLog != null)\n//                {\n//                    var isMatch = StepMatchingHelper.IsStepMatched(followUpStep, trackingLog, contact);\n\n//                    if (!isMatch)\n//                    {\n//                        Log.Information(\"ðŸš« Step {StepId} skipped due to condition mismatch [Tag: {Tag}, Source: {Source}]\",\n//                            followUpStep.Id, followUpStep.RequiredTag, followUpStep.RequiredSource);\n//                        return null;\n//                    }\n//                }\n\n//                Log.Information(\"âœ… Follow-up step found and matched â†’ StepId: {StepId}, Template: {Template}\",\n//                    followUpStep.Id, followUpStep.TemplateToSend);\n\n//                return followUpStep;\n//            }\n//            catch (Exception ex)\n//            {\n//                Log.Error(ex, \"âŒ Exception while fetching chained step for NextStepId: {NextStepId}\", nextStepId);\n//                throw;\n//            }\n//        }\n\n//        // âœ… Optional helper for resolving from TrackingLogId\n//        public async Task<CTAFlowStep?> GetChainedStepWithContextAsync(\n//            Guid businessId,\n//            Guid? nextStepId,\n//            Guid? trackingLogId)\n//        {\n//            var log = await _context.TrackingLogs\n//                .Include(l => l.Contact)\n//                    .ThenInclude(c => c.ContactTags)\n//                        .ThenInclude(ct => ct.Tag)\n//                .FirstOrDefaultAsync(l => l.Id == trackingLogId);\n\n//            return await GetChainedStepAsync(businessId, nextStepId, log, log?.Contact);\n//        }\n\n\n//        public async Task<ResponseResult> ExecuteVisualFlowAsync(Guid businessId, Guid startStepId, Guid trackingLogId, Guid? campaignSendLogId)\n//        {\n//            try\n//            {\n//                Log.Information(\"ðŸš¦ Executing Visual Flow â†’ StepId: {StepId} | TrackingLogId: {TrackingLogId}\", startStepId, trackingLogId);\n\n//                // â”€â”€ local helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n//                static string ResolveGreeting(string? profileName, string? contactName)\n//                {\n//                    var s = (profileName ?? contactName)?.Trim();\n//                    return string.IsNullOrEmpty(s) ? \"there\" : s;\n//                }\n//                static void EnsureArgsLength(List<string> args, int slot1Based)\n//                {\n//                    while (args.Count < slot1Based) args.Add(string.Empty);\n//                }\n//                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n//                var log = await _context.TrackingLogs\n//                    .Include(l => l.Contact)\n//                        .ThenInclude(c => c.ContactTags)\n//                            .ThenInclude(ct => ct.Tag)\n//                    .FirstOrDefaultAsync(l => l.Id == trackingLogId);\n\n//                if (log == null)\n//                {\n//                    Log.Warning(\"âŒ TrackingLog not found for ID: {TrackingLogId}\", trackingLogId);\n//                    return ResponseResult.ErrorInfo(\"Tracking log not found.\");\n//                }\n\n//                var step = await GetChainedStepAsync(businessId, startStepId, log, log?.Contact);\n\n//                if (step == null)\n//                {\n//                    Log.Warning(\"âŒ No flow step matched or conditions failed â†’ StepId: {StepId}\", startStepId);\n//                    return ResponseResult.ErrorInfo(\"Step conditions not satisfied.\");\n//                }\n\n//                // âœ… Build profile-aware args for this step (used for text templates)\n//                var args = new List<string>();\n//                if (step.UseProfileName && step.ProfileNameSlot is int slot && slot >= 1)\n//                {\n//                    // Prefer the already-loaded contact on the tracking log; fallback to DB lookup\n//                    var contact = log.Contact ?? await _context.Contacts\n//                        .AsNoTracking()\n//                        .FirstOrDefaultAsync(c => c.BusinessId == businessId && c.PhoneNumber == (log.ContactPhone ?? \"\"));\n\n//                    var greet = ResolveGreeting(contact?.ProfileName, contact?.Name);\n//                    EnsureArgsLength(args, slot);\n//                    args[slot - 1] = greet; // 1-based slot -> 0-based index\n//                }\n\n//                ResponseResult sendResult;\n\n//                // This switch block remains unchanged, except we pass args for text templates\n//                switch (step.TemplateType?.ToLower())\n//                {\n//                    case \"image_template\":\n//                        var imageDto = new ImageTemplateMessageDto\n//                        {\n//                            BusinessId = businessId,\n//                            RecipientNumber = log.ContactPhone ?? \"\",\n//                            TemplateName = step.TemplateToSend,\n//                            LanguageCode = \"en_US\"\n//                            // If your image templates support body params, you can also pass args here.\n//                        };\n//                        sendResult = await _messageEngineService.SendImageTemplateMessageAsync(imageDto, businessId);\n//                        break;\n\n//                    case \"text_template\":\n//                    default:\n//                        var textDto = new SimpleTemplateMessageDto\n//                        {\n//                            RecipientNumber = log.ContactPhone ?? \"\",\n//                            TemplateName = step.TemplateToSend,\n//                            TemplateParameters = args // âœ… inject ProfileName here when configured\n//                        };\n//                        sendResult = await _messageEngineService.SendTemplateMessageSimpleAsync(businessId, textDto);\n//                        break;\n//                }\n\n//                // âœ… 2. SAVE the new ID to the log\n//                var executionLog = new FlowExecutionLog\n//                {\n//                    Id = Guid.NewGuid(),\n//                    BusinessId = businessId,\n//                    StepId = step.Id,\n//                    FlowId = step.CTAFlowConfigId,\n//                    CampaignSendLogId = campaignSendLogId, // <-- THE NEW VALUE IS SAVED HERE\n//                    TrackingLogId = trackingLogId,\n//                    ContactPhone = log.ContactPhone,\n//                    TriggeredByButton = step.TriggerButtonText,\n//                    TemplateName = step.TemplateToSend,\n//                    TemplateType = step.TemplateType,\n//                    Success = sendResult.Success,\n//                    ErrorMessage = sendResult.ErrorMessage,\n//                    RawResponse = sendResult.RawResponse,\n//                    ExecutedAt = DateTime.UtcNow\n//                };\n\n//                _context.FlowExecutionLogs.Add(executionLog);\n//                await _context.SaveChangesAsync();\n\n//                if (sendResult.Success)\n//                {\n//                    Log.Information(\"âœ… Flow step executed â†’ Template: {Template} sent to {To}\", step.TemplateToSend, log.ContactPhone);\n//                }\n//                else\n//                {\n//                    Log.Warning(\"âŒ Failed to send template from flow â†’ {Reason}\", sendResult.ErrorMessage);\n//                }\n\n//                return ResponseResult.SuccessInfo($\"Flow step executed. Sent: {sendResult.Success}\", null, sendResult.RawResponse);\n//            }\n//            catch (Exception ex)\n//            {\n//                Log.Error(ex, \"âŒ Exception during ExecuteVisualFlowAsync()\");\n//                return ResponseResult.ErrorInfo(\"Internal error during flow execution.\");\n//            }\n//        }\n\n//        public async Task<FlowButtonLink?> GetLinkAsync(Guid flowId, Guid sourceStepId, short buttonIndex)\n//        {\n//            return await _context.FlowButtonLinks\n//                 .Where(l => l.CTAFlowStepId == sourceStepId\n//              && l.NextStepId != null\n//              && l.Step.CTAFlowConfigId == flowId\n//              && l.ButtonIndex == buttonIndex)\n//                .SingleOrDefaultAsync();\n\n//        }\n//        //public async Task<IReadOnlyList<AttachedCampaignDto>> GetAttachedCampaignsAsync(Guid flowId, Guid businessId)\n//        //{\n//        //    return await _context.Campaigns\n//        //        .Where(c => c.BusinessId == businessId\n//        //                    && !c.IsDeleted\n//        //                    && c.CTAFlowConfigId == flowId)\n//        //        .OrderByDescending(c => c.CreatedAt)\n//        //        .Select(c => new AttachedCampaignDto(c.Id, c.Name, c.Status, c.ScheduledAt))\n//        //        .ToListAsync();\n//        //}\n\n//        public async Task<ResponseResult> GetVisualFlowAsync(Guid flowId, Guid businessId)\n//        {\n//            try\n//            {\n//                // Load the flow + steps + button links (no tracking for view)\n//                var flow = await _context.CTAFlowConfigs\n//                    .AsNoTracking()\n//                    .Where(f => f.IsActive && f.BusinessId == businessId && f.Id == flowId)\n//                    .Select(f => new\n//                    {\n//                        f.Id,\n//                        f.FlowName,\n//                        f.IsPublished,\n//                        Steps = _context.CTAFlowSteps\n//                            .Where(s => s.CTAFlowConfigId == f.Id)\n//                            .OrderBy(s => s.StepOrder)\n//                            .Select(s => new\n//                            {\n//                                s.Id,\n//                                s.StepOrder,\n//                                s.TemplateToSend,\n//                                s.TemplateType,\n//                                s.TriggerButtonText,\n//                                s.TriggerButtonType,\n//                                s.PositionX,\n//                                s.PositionY,\n//                                s.UseProfileName,\n//                                s.ProfileNameSlot,\n//                                Buttons = _context.FlowButtonLinks\n//                                    .Where(b => b.CTAFlowStepId == s.Id)\n//                                    .OrderBy(b => b.ButtonIndex)\n//                                    .Select(b => new\n//                                    {\n//                                        b.ButtonText,\n//                                        b.ButtonType,\n//                                        b.ButtonSubType,\n//                                        b.ButtonValue,\n//                                        b.ButtonIndex,\n//                                        b.NextStepId\n//                                    })\n//                                    .ToList()\n//                            })\n//                            .ToList()\n//                    })\n//                    .FirstOrDefaultAsync();\n\n//                if (flow == null)\n//                {\n//                    return ResponseResult.ErrorInfo(\"Flow not found.\");\n//                }\n\n//                // Map to FE shape\n//                var nodes = flow.Steps.Select(s => new\n//                {\n//                    id = s.Id.ToString(), // node id = step id\n//                    positionX = s.PositionX ?? 0,\n//                    positionY = s.PositionY ?? 0,\n//                    templateName = s.TemplateToSend,\n//                    templateType = s.TemplateType,\n//                    triggerButtonText = s.TriggerButtonText ?? string.Empty,\n//                    triggerButtonType = s.TriggerButtonType ?? \"cta\",\n//                    requiredTag = string.Empty,       // not used in your model; keep empty\n//                    requiredSource = string.Empty,    // not used; keep empty\n//                    useProfileName = s.UseProfileName,\n//                    profileNameSlot = (s.ProfileNameSlot.HasValue && s.ProfileNameSlot.Value > 0) ? s.ProfileNameSlot.Value : 1,\n//                    buttons = s.Buttons.Select(b => new\n//                    {\n//                        text = b.ButtonText,\n//                        type = b.ButtonType,\n//                        subType = b.ButtonSubType,\n//                        value = b.ButtonValue,\n//                        targetNodeId = b.NextStepId == Guid.Empty ? null : b.NextStepId.ToString(),\n//                        index = (int)(b.ButtonIndex)\n//                    })\n//                });\n\n//                // Build edges from button links\n//                var edges = flow.Steps\n//                    .SelectMany(s => s.Buttons\n//                        .Where(b => b.NextStepId != Guid.Empty)\n//                        .Select(b => new\n//                        {\n//                            fromNodeId = s.Id.ToString(),\n//                            toNodeId = b.NextStepId.ToString(),\n//                            sourceHandle = b.ButtonText // label/handle = button text\n//                        }));\n\n//                var payload = new\n//                {\n//                    flowName = flow.FlowName,\n//                    isPublished = flow.IsPublished,\n//                    nodes,\n//                    edges\n//                };\n\n//                return ResponseResult.SuccessInfo(\"Flow loaded.\", payload);\n//            }\n//            catch (Exception ex)\n//            {\n//                Log.Error(ex, \"âŒ Exception while loading visual flow {FlowId}\", flowId);\n//                return ResponseResult.ErrorInfo(\"Internal error while loading flow.\");\n//            }\n//        }\n//        public async Task<IReadOnlyList<AttachedCampaignDto>> GetAttachedCampaignsAsync(Guid flowId, Guid businessId)\n//        {\n//            // base query: attached, non-deleted\n//            var q = _context.Campaigns\n//                .Where(c => c.BusinessId == businessId && !c.IsDeleted && c.CTAFlowConfigId == flowId);\n\n//            // earliest send per campaign\n//            var firstSends = await _context.CampaignSendLogs\n//                .Where(s => s.BusinessId == businessId && s.CampaignId != Guid.Empty)\n//                .GroupBy(s => s.CampaignId)\n//                .Select(g => new { CampaignId = g.Key, FirstSentAt = (DateTime?)g.Min(s => s.CreatedAt) })\n//                .ToListAsync();\n\n//            var firstSendMap = firstSends.ToDictionary(x => x.CampaignId, x => x.FirstSentAt);\n\n//            var list = await q\n//                .OrderByDescending(c => c.CreatedAt)\n//                .Select(c => new\n//                {\n//                    c.Id,\n//                    c.Name,\n//                    c.Status,\n//                    c.ScheduledAt,\n//                    c.CreatedAt,\n//                    c.CreatedBy\n//                })\n//                .ToListAsync();\n\n//            return list.Select(x => new AttachedCampaignDto(\n//                x.Id,\n//                x.Name,\n//                x.Status,\n//                x.ScheduledAt,\n//                x.CreatedAt,\n//                x.CreatedBy,\n//                firstSendMap.TryGetValue(x.Id, out var ts) ? ts : null\n//            )).ToList();\n//        }\n//        public async Task<bool> HardDeleteFlowIfUnusedAsync(Guid flowId, Guid businessId)\n//        {\n//            // Load flow + children\n//            var flow = await _context.CTAFlowConfigs\n//                .Include(f => f.Steps)\n//                    .ThenInclude(s => s.ButtonLinks)\n//                .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId);\n\n//            if (flow is null) return false;\n\n//            // Guard: any active campaign still attached?\n//            var attached = await _context.Campaigns\n//                .Where(c => c.BusinessId == businessId\n//                            && !c.IsDeleted\n//                            && c.CTAFlowConfigId == flowId)\n//                .Select(c => c.Id)\n//                .Take(1)\n//                .AnyAsync();\n\n//            if (attached) return false;\n\n//            // Hard delete (children first; FK-safe)\n//            foreach (var step in flow.Steps)\n//                _context.FlowButtonLinks.RemoveRange(step.ButtonLinks);\n\n//            _context.CTAFlowSteps.RemoveRange(flow.Steps);\n//            _context.CTAFlowConfigs.Remove(flow);\n\n//            await _context.SaveChangesAsync();\n//            return true;\n//        }\n\n//        //public async Task<FlowUpdateResult> UpdateVisualFlowAsync(Guid flowId, SaveVisualFlowDto dto, Guid businessId, string user)\n//        //{\n//        //    var flow = await _context.CTAFlowConfigs\n//        //        .Include(f => f.Steps)\n//        //            .ThenInclude(s => s.ButtonLinks)\n//        //        .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId);\n\n//        //    if (flow is null)\n//        //        return new FlowUpdateResult { Status = \"notFound\", Message = \"Flow not found.\" };\n\n//        //    var attached = await _context.Campaigns\n//        //        .Where(c => !c.IsDeleted && c.BusinessId == businessId && c.CTAFlowConfigId == flowId)\n//        //        .Select(c => new { c.Id, c.Name, c.Status, c.ScheduledAt, c.CreatedAt, c.CreatedBy })\n//        //        .ToListAsync();\n\n//        //    if (flow.IsPublished && attached.Count > 0)\n//        //    {\n//        //        return new FlowUpdateResult\n//        //        {\n//        //            Status = \"requiresFork\",\n//        //            Message = \"This flow is published and attached to campaign(s). Create a new draft version.\",\n//        //            Campaigns = attached\n//        //        };\n//        //    }\n\n//        //    var needsRepublish = flow.IsPublished && attached.Count == 0;\n//        //    if (needsRepublish) flow.IsPublished = false; // flip to draft during edit\n\n//        //    // wipe & rebuild steps (simplest and consistent with your builder payload)\n//        //    _context.FlowButtonLinks.RemoveRange(flow.Steps.SelectMany(s => s.ButtonLinks));\n//        //    _context.CTAFlowSteps.RemoveRange(flow.Steps);\n//        //    await _context.SaveChangesAsync();\n\n//        //    flow.FlowName = string.IsNullOrWhiteSpace(dto.FlowName) ? flow.FlowName : dto.FlowName.Trim();\n//        //    flow.UpdatedAt = DateTime.UtcNow;\n\n//        //    var newSteps = new List<CTAFlowStep>();\n//        //    var nodeIdToNewGuid = new Dictionary<string, Guid>();\n\n//        //    // 1) create steps with new IDs but keep mapping from incoming node.Id\n//        //    foreach (var n in dto.Nodes)\n//        //    {\n//        //        var stepId = Guid.TryParse(n.Id, out var parsed) ? parsed : Guid.NewGuid();\n//        //        nodeIdToNewGuid[n.Id] = stepId;\n\n//        //        var s = new CTAFlowStep\n//        //        {\n//        //            Id = stepId,\n//        //            CTAFlowConfigId = flow.Id,\n//        //            TemplateToSend = n.TemplateName ?? string.Empty,\n//        //            TemplateType = n.TemplateType,\n//        //            TriggerButtonText = n.TriggerButtonText ?? \"\",\n//        //            TriggerButtonType = n.TriggerButtonType ?? \"\",\n//        //            StepOrder = 0,\n//        //            RequiredTag = n.RequiredTag,\n//        //            RequiredSource = n.RequiredSource,\n//        //            PositionX = n.PositionX,\n//        //            PositionY = n.PositionY,\n//        //            UseProfileName = n.UseProfileName,\n//        //            ProfileNameSlot = n.ProfileNameSlot\n//        //        };\n\n//        //        s.ButtonLinks = (n.Buttons ?? new List<LinkButtonDto>())\n//        //            .Select((b, idx) => new FlowButtonLink\n//        //            {\n//        //                Id = Guid.NewGuid(),\n//        //                CTAFlowStepId = s.Id,\n//        //                Step = s,\n//        //                ButtonText = b.Text ?? \"\",\n//        //                ButtonType = b.Type ?? \"QUICK_REPLY\",\n//        //                ButtonSubType = b.SubType ?? \"\",\n//        //                ButtonValue = b.Value ?? \"\",\n//        //                ButtonIndex = (short)(b.Index >= 0 ? b.Index : idx),\n//        //                NextStepId = string.IsNullOrWhiteSpace(b.TargetNodeId) ? null :\n//        //                             (Guid.TryParse(b.TargetNodeId, out var t) ? t : null)\n//        //            }).ToList();\n\n//        //        newSteps.Add(s);\n//        //    }\n\n//        //    flow.Steps = newSteps;\n//        //    await _context.SaveChangesAsync();\n\n//        //    return new FlowUpdateResult { Status = \"ok\", NeedsRepublish = needsRepublish };\n//        //}\n\n//        //public async Task<bool> PublishFlowAsync(Guid flowId, Guid businessId, string user)\n//        //{\n//        //    var flow = await _context.CTAFlowConfigs\n//        //        .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId);\n\n//        //    if (flow is null) return false;\n\n//        //    // sanity: basic validation can be added here (has steps, etc.)\n//        //    flow.IsPublished = true;\n//        //    flow.UpdatedAt = DateTime.UtcNow;\n//        //    await _context.SaveChangesAsync();\n//        //    return true;\n//        //}\n\n//        // ---------- FORK (create draft copy) ----------\n//        //public async Task<Guid> ForkFlowAsync(Guid flowId, Guid businessId, string user)\n//        //{\n//        //    var src = await _context.CTAFlowConfigs\n//        //        .Include(f => f.Steps)\n//        //            .ThenInclude(s => s.ButtonLinks)\n//        //        .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId);\n\n//        //    if (src is null) return Guid.Empty;\n\n//        //    var dst = new CTAFlowConfig\n//        //    {\n//        //        Id = Guid.NewGuid(),\n//        //        BusinessId = src.BusinessId,\n//        //        FlowName = src.FlowName + \" (copy)\",\n//        //        IsActive = true,\n//        //        IsPublished = false, // new draft\n//        //        CreatedAt = DateTime.UtcNow,\n//        //        CreatedBy = user,\n//        //        UpdatedAt = DateTime.UtcNow\n//        //    };\n\n//        //    var oldToNew = new Dictionary<Guid, Guid>();\n\n//        //    // Clone steps first\n//        //    foreach (var s in src.Steps)\n//        //    {\n//        //        var nsId = Guid.NewGuid();\n//        //        oldToNew[s.Id] = nsId;\n\n//        //        var ns = new CTAFlowStep\n//        //        {\n//        //            Id = nsId,\n//        //            CTAFlowConfigId = dst.Id,\n//        //            TriggerButtonText = s.TriggerButtonText,\n//        //            TriggerButtonType = s.TriggerButtonType,\n//        //            TemplateToSend = s.TemplateToSend,\n//        //            TemplateType = s.TemplateType,\n//        //            StepOrder = s.StepOrder,\n//        //            RequiredTag = s.RequiredTag,\n//        //            RequiredSource = s.RequiredSource,\n//        //            PositionX = s.PositionX,\n//        //            PositionY = s.PositionY,\n//        //            UseProfileName = s.UseProfileName,\n//        //            ProfileNameSlot = s.ProfileNameSlot,\n//        //            ButtonLinks = new List<FlowButtonLink>()\n//        //        };\n\n//        //        dst.Steps.Add(ns);\n//        //    }\n\n//        //    // Clone links and rewire targets if possible\n//        //    foreach (var s in src.Steps)\n//        //    {\n//        //        var ns = dst.Steps.First(x => x.Id == oldToNew[s.Id]);\n//        //        foreach (var b in s.ButtonLinks.OrderBy(x => x.ButtonIndex))\n//        //        {\n//        //            ns.ButtonLinks.Add(new FlowButtonLink\n//        //            {\n//        //                Id = Guid.NewGuid(),\n//        //                CTAFlowStepId = ns.Id,\n//        //                Step = ns,\n//        //                ButtonText = b.ButtonText,\n//        //                ButtonType = b.ButtonType,\n//        //                ButtonSubType = b.ButtonSubType,\n//        //                ButtonValue = b.ButtonValue,\n//        //                ButtonIndex = b.ButtonIndex,\n//        //                NextStepId = b.NextStepId.HasValue && oldToNew.ContainsKey(b.NextStepId.Value)\n//        //                    ? oldToNew[b.NextStepId.Value]\n//        //                    : null\n//        //            });\n//        //        }\n//        //    }\n\n//        //    _context.CTAFlowConfigs.Add(dst);\n//        //    await _context.SaveChangesAsync();\n//        //    return dst.Id;\n//        //}\n\n\n//    }\n//}\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Services/ExtrackAllFiles.bat",
      "sha256": "3d14ccc013b9fd82ff0759820acc71da52821878e664cb4daa9418062278e799",
      "language": "bat",
      "size": 922,
      "content": "@echo off\nREM This script will find all files and output their name and content into one file.\nREM The output file will be named [FolderName]_AllFileDump.txt.\n\nREM Get the current folder's name and set it as the output file name with the custom suffix\nfor %%I in (\"%cd%\") do set \"outputFile=%%~nI_AllFileDump.txt\"\n\nREM Clear the output file to start fresh\n> \"%outputFile%\" (echo Folder and File Content Report)\necho. >> \"%outputFile%\"\n\nREM Loop through all files in the current directory and subdirectories\nfor /R . %%F in (*.*) do (\n    echo ====================================================== >> \"%outputFile%\"\n    echo FILE: %%F >> \"%outputFile%\"\n    echo ====================================================== >> \"%outputFile%\"\n    echo. >> \"%outputFile%\"\n    type \"%%F\" >> \"%outputFile%\" 2>nul\n    echo. >> \"%outputFile%\"\n    echo. >> \"%outputFile%\"\n)\n\necho Finished! All content has been extracted to %outputFile%"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Services/FlowExecutionLogger.cs",
      "sha256": "3b6ad9e86868b5c7f7f39fca399fb43a86693d088ae149f2ea9d14b7adb7a933",
      "language": "csharp",
      "size": 6046,
      "content": "// ðŸ“„ xbytechat-api/Features/CTAFlowBuilder/Services/FlowExecutionLogger.cs\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Serilog;\nusing xbytechat.api; // âœ… Needed so AppDbContext is in scope\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Services\n{\n    /// <summary>\n    /// Default implementation of IFlowExecutionLogger.\n    /// Writes origin-tagged rows into FlowExecutionLogs.\n    /// </summary>\n    public sealed class FlowExecutionLogger : IFlowExecutionLogger\n    {\n        private readonly AppDbContext _db;\n\n        public FlowExecutionLogger(AppDbContext db)\n        {\n            _db = db ?? throw new ArgumentNullException(nameof(db));\n        }\n\n        public async Task LogStepAsync(FlowExecutionContext context, CancellationToken cancellationToken = default)\n        {\n            if (context == null) throw new ArgumentNullException(nameof(context));\n\n            try\n            {\n                var entity = new FlowExecutionLog\n                {\n                    Id = Guid.NewGuid(),\n\n                    // core identifiers\n                    RunId = context.RunId,\n                    BusinessId = context.BusinessId,\n                    FlowId = context.FlowId,\n                    StepId = context.StepId,\n                    StepName = context.StepName ?? string.Empty,\n\n                    // origin + linkage\n                    Origin = context.Origin,\n                    CampaignId = context.CampaignId,\n                    AutoReplyFlowId = context.AutoReplyFlowId,\n                    CampaignSendLogId = context.CampaignSendLogId,\n                    TrackingLogId = context.TrackingLogId,\n                    MessageLogId = context.MessageLogId,\n\n                    // contact + button context\n                    ContactPhone = context.ContactPhone,\n                    TriggeredByButton = context.TriggeredByButton,\n                    ButtonIndex = context.ButtonIndex,\n\n                    // template / execution info\n                    TemplateName = context.TemplateName,\n                    TemplateType = context.TemplateType,\n                    Success = context.Success,\n                    ErrorMessage = context.ErrorMessage,\n                    RawResponse = context.RawResponse,\n\n                    // timestamps + tracing\n                    ExecutedAt = context.ExecutedAtUtc ?? DateTime.UtcNow,\n                    RequestId = context.RequestId\n                };\n\n                _db.FlowExecutionLogs.Add(entity);\n                await _db.SaveChangesAsync(cancellationToken);\n            }\n            catch (Exception ex)\n            {\n                // Never let logging failures break main flow execution.\n                Log.Error(\n                    ex,\n                    \"âŒ Failed to write FlowExecutionLog | Biz={BusinessId} Origin={Origin} Flow={FlowId} Step={StepId}\",\n                    context.BusinessId,\n                    context.Origin,\n                    context.FlowId,\n                    context.StepId\n                );\n            }\n        }\n    }\n}\n\n\n//using System;\n//using System.Threading;\n//using System.Threading.Tasks;\n//using Serilog;\n//using xbytechat.api.Features.AutoReplyBuilder.DTOs;\n//using xbytechat.api.Features.CTAFlowBuilder.Models;\n\n//namespace xbytechat.api.Features.CTAFlowBuilder.Services\n//{\n//    /// <summary>\n//    /// Default implementation of IFlowExecutionLogger.\n//    /// Writes origin-tagged rows into FlowExecutionLogs.\n//    /// </summary>\n//    public sealed class FlowExecutionLogger : IFlowExecutionLogger\n//    {\n//        private readonly AppDbContext _db;\n\n//        public FlowExecutionLogger(AppDbContext db)\n//        {\n//            _db = db ?? throw new ArgumentNullException(nameof(db));\n//        }\n\n//        public async Task LogStepAsync(FlowExecutionContext context, CancellationToken cancellationToken = default)\n//        {\n//            if (context == null) throw new ArgumentNullException(nameof(context));\n\n//            try\n//            {\n//                var entity = new FlowExecutionLog\n//                {\n//                    Id = Guid.NewGuid(),\n//                    RunId = context.RunId,\n//                    BusinessId = context.BusinessId,\n//                    StepId = context.StepId,\n//                    StepName = context.StepName ?? string.Empty,\n//                    FlowId = context.FlowId,\n//                    Origin = context.Origin,\n//                    CampaignId = context.CampaignId,\n//                    AutoReplyFlowId = context.AutoReplyFlowId,\n//                    CampaignSendLogId = context.CampaignSendLogId,\n//                    TrackingLogId = context.TrackingLogId,\n//                    ContactPhone = context.ContactPhone,\n//                    TriggeredByButton = context.TriggeredByButton,\n//                    TemplateName = context.TemplateName,\n//                    TemplateType = context.TemplateType,\n//                    Success = context.Success,\n//                    ErrorMessage = context.ErrorMessage,\n//                    RawResponse = context.RawResponse,\n//                    ExecutedAt = context.ExecutedAtUtc ?? DateTime.UtcNow,\n//                    MessageLogId = context.MessageLogId,\n//                    ButtonIndex = context.ButtonIndex,\n//                    RequestId = context.RequestId\n//                };\n\n//                _db.FlowExecutionLogs.Add(entity);\n//                await _db.SaveChangesAsync(cancellationToken);\n//            }\n//            catch (Exception ex)\n//            {\n//                // We never want logging failures to break the main flow.\n//                Log.Error(ex,\n//                    \"âŒ Failed to write FlowExecutionLog | Biz={BusinessId} Origin={Origin} Flow={FlowId} Step={StepId}\",\n//                    context.BusinessId,\n//                    context.Origin,\n//                    context.FlowId,\n//                    context.StepId);\n//            }\n//        }\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Services/FlowRuntimeService.cs",
      "sha256": "87e5773c5b57ae97fec595755c6c89b12b7c48122ec7925bf2a926dcfe591f57",
      "language": "csharp",
      "size": 50764,
      "content": "using Microsoft.EntityFrameworkCore;\nusing System.Text.Json;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.Features.Webhooks.Services.Processors;\nusing xbytechat.api.WhatsAppSettings.Services;\nusing xbytechat_api.WhatsAppSettings.Services;\nusing xbytechat.api.Features.CustomeApi.Services;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Services\n{\n    public class FlowRuntimeService : IFlowRuntimeService\n    {\n        private readonly AppDbContext _dbContext;\n        private readonly IMessageEngineService _messageEngineService;\n        private readonly IWhatsAppTemplateFetcherService _templateFetcherService;\n        private readonly ILogger<FlowRuntimeService> _logger;\n        private readonly ICtaJourneyPublisher _ctaPublisher;\n        private readonly IWhatsAppSettingsService _whatsAppSettingsService;\n        private readonly IWhatsAppSenderService _whatsAppSenderService;\n        public FlowRuntimeService(\n            AppDbContext dbContext,\n            IMessageEngineService messageEngineService,\n            IWhatsAppTemplateFetcherService templateFetcherService,\n            ILogger<FlowRuntimeService> logger,\n            ICtaJourneyPublisher ctaPublisher,\n            IWhatsAppSettingsService whatsAppSettingsService,\n            IWhatsAppSenderService whatsAppSenderService)\n        {\n            _dbContext = dbContext;\n            _messageEngineService = messageEngineService;\n            _templateFetcherService = templateFetcherService;\n            _logger = logger;\n            _ctaPublisher = ctaPublisher;\n            _whatsAppSettingsService = whatsAppSettingsService;\n            _whatsAppSenderService = whatsAppSenderService;\n        }\n\n        private static string ResolveGreeting(string? profileName, string? contactName)\n        {\n            var s = (profileName ?? contactName)?.Trim();\n            return string.IsNullOrEmpty(s) ? \"there\" : s;\n        }\n        private static void EnsureArgsLength(List<string> args, int slot1Based)\n        {\n            while (args.Count < slot1Based) args.Add(string.Empty);\n        }\n\n        // NOTE: Keep provider normalization consistent across settings/campaign/webhook/runtime paths.\n        // Also enforces \"META\" -> \"META_CLOUD\" canonical mapping.\n        private static string NormalizeProvider(string? raw)\n        {\n            if (string.IsNullOrWhiteSpace(raw)) return string.Empty;\n            var p = raw.Trim().Replace(\"-\", \"_\").Replace(\" \", \"_\").ToUpperInvariant();\n            return p == \"META\" ? \"META_CLOUD\" : p;\n        }\n\n\n        //public async Task<NextStepResult> ExecuteNextAsync(NextStepContext context)\n        //{\n        //    try\n        //    {\n        //        // â”€â”€ local helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n        //        string ResolveGreeting(string? profileName, string? contactName)\n        //        {\n        //            var s = (profileName ?? contactName)?.Trim();\n        //            return string.IsNullOrEmpty(s) ? \"there\" : s;\n        //        }\n        //        void EnsureArgsLength(List<string> args, int slot1Based)\n        //        {\n        //            while (args.Count < slot1Based) args.Add(string.Empty);\n        //        }\n        //        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n        //        // 1) URL-only buttons â†’ no WA send, just record and return redirect\n        //        if (context.ClickedButton != null &&\n        //            context.ClickedButton.ButtonType?.Equals(\"URL\", StringComparison.OrdinalIgnoreCase) == true)\n        //        {\n        //            _dbContext.FlowExecutionLogs.Add(new FlowExecutionLog\n        //            {\n        //                Id = Guid.NewGuid(),\n        //                BusinessId = context.BusinessId,\n        //                FlowId = context.FlowId,\n        //                StepId = context.SourceStepId,\n        //                StepName = \"URL_REDIRECT\",\n        //                MessageLogId = context.MessageLogId,\n        //                ButtonIndex = context.ButtonIndex,\n        //                ContactPhone = context.ContactPhone,\n        //                Success = true,\n        //                ExecutedAt = DateTime.UtcNow,\n        //                RequestId = context.RequestId\n        //            });\n        //            await _dbContext.SaveChangesAsync();\n\n        //            return new NextStepResult { Success = true, RedirectUrl = context.ClickedButton.ButtonValue };\n\n\n\n        //        }\n\n        //        // 2) Load next step in the same flow (no dedupe/loop guard â€” always proceed)\n        //        var targetStep = await _dbContext.CTAFlowSteps\n        //            .Include(s => s.ButtonLinks)\n        //            .FirstOrDefaultAsync(s => s.Id == context.TargetStepId &&\n        //                                      s.CTAFlowConfigId == context.FlowId);\n\n        //        if (targetStep == null)\n        //            return new NextStepResult { Success = false, Error = \"Target step not found.\" };\n\n        //        if (string.IsNullOrWhiteSpace(targetStep.TemplateToSend))\n        //            return new NextStepResult { Success = false, Error = \"Target step has no template assigned.\" };\n\n        //        var templateName = targetStep.TemplateToSend.Trim();\n\n        //        // 3) Preflight the template (resolve language and catch 132001 early)\n        //        var meta = await _templateFetcherService.GetTemplateByNameAsync(\n        //            context.BusinessId, templateName, includeButtons: true);\n\n        //        if (meta == null)\n        //        {\n        //            _dbContext.FlowExecutionLogs.Add(new FlowExecutionLog\n        //            {\n        //                Id = Guid.NewGuid(),\n        //                BusinessId = context.BusinessId,\n        //                FlowId = context.FlowId,\n        //                StepId = targetStep.Id,\n        //                StepName = templateName,\n        //                MessageLogId = null,\n        //                ButtonIndex = context.ButtonIndex,\n        //                ContactPhone = context.ContactPhone,\n        //                Success = false,\n        //                ErrorMessage = $\"Template '{templateName}' not found for this WABA.\",\n        //                RawResponse = null,\n        //                ExecutedAt = DateTime.UtcNow,\n        //                RequestId = context.RequestId\n        //            });\n        //            await _dbContext.SaveChangesAsync();\n\n        //            return new NextStepResult { Success = false, Error = $\"Template '{templateName}' not found or not approved.\" };\n        //        }\n\n        //        var languageCode = string.IsNullOrWhiteSpace(meta.Language) ? \"en_US\" : meta.Language;\n\n        //        // 3.1) ðŸ”¥ Determine sender with failsafes (NO early return for missing context)\n        //        var provider = (context.Provider ?? string.Empty).Trim().ToUpperInvariant();\n        //        var phoneNumberId = context.PhoneNumberId;\n\n        //        // If provider missing/invalid â†’ try active WhatsAppSettings (fast path)\n        //        if (provider != \"PINNACLE\" && provider != \"META_CLOUD\")\n        //        {\n        //            var w = await _dbContext.WhatsAppSettings\n        //                .AsNoTracking()\n        //                .Where(x => x.BusinessId == context.BusinessId && x.IsActive)\n        //                .OrderByDescending(x => x.UpdatedAt ?? x.CreatedAt)\n        //                .FirstOrDefaultAsync();\n\n        //            if (w != null)\n        //            {\n        //                provider = (w.Provider ?? \"\").Trim().ToUpperInvariant();\n        //                if (string.IsNullOrWhiteSpace(phoneNumberId))\n        //                    phoneNumberId = null; // legacy WhatsAppSettings.PhoneNumberId is intentionally not used (ESU split)\n        //            }\n        //        }\n\n        //        // If still missing provider â†’ hard resolve via numbers table\n        //        if (provider != \"PINNACLE\" && provider != \"META_CLOUD\")\n        //        {\n        //            var pn = await _dbContext.WhatsAppPhoneNumbers\n        //                .AsNoTracking()\n        //                .Where(n => n.BusinessId == context.BusinessId && n.IsActive)\n        //                .OrderByDescending(n => n.IsDefault)\n        //                .ThenBy(n => n.WhatsAppBusinessNumber)\n        //                .Select(n => new { n.Provider, n.PhoneNumberId })\n        //                .FirstOrDefaultAsync();\n\n        //            if (pn != null)\n        //            {\n        //                provider = (pn.Provider ?? \"\").Trim().ToUpperInvariant();\n        //                if (string.IsNullOrWhiteSpace(phoneNumberId))\n        //                    phoneNumberId = pn.PhoneNumberId;\n        //            }\n        //        }\n\n        //        if (provider != \"PINNACLE\" && provider != \"META_CLOUD\")\n        //            return new NextStepResult { Success = false, Error = \"No active WhatsApp sender configured (provider could not be resolved).\" };\n\n        //        // Ensure we have a sender id\n        //        if (string.IsNullOrWhiteSpace(phoneNumberId))\n        //        {\n        //            phoneNumberId = await _dbContext.WhatsAppPhoneNumbers\n        //                .AsNoTracking()\n        //                .Where(n => n.BusinessId == context.BusinessId\n        //                            && n.IsActive\n        //                            && n.Provider.ToUpper() == provider)\n        //                .OrderByDescending(n => n.IsDefault)\n        //                .ThenBy(n => n.WhatsAppBusinessNumber)\n        //                .Select(n => n.PhoneNumberId)\n        //                .FirstOrDefaultAsync();\n\n        //            if (string.IsNullOrWhiteSpace(phoneNumberId))\n        //                return new NextStepResult { Success = false, Error = \"Missing PhoneNumberId (no default sender configured for this provider).\" };\n        //        }\n\n        //        // â”€â”€ Profile-name injection into body params (optional) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n        //        var args = new List<string>();\n        //        if (targetStep.UseProfileName && targetStep.ProfileNameSlot is int slot && slot >= 1)\n        //        {\n        //            var contact = await _dbContext.Contacts\n        //                .AsNoTracking()\n        //                .FirstOrDefaultAsync(c => c.BusinessId == context.BusinessId\n        //                                          && c.PhoneNumber == context.ContactPhone);\n\n        //            var greet = ResolveGreeting(contact?.ProfileName, contact?.Name);\n        //            EnsureArgsLength(args, slot);\n        //            args[slot - 1] = greet;\n        //        }\n\n        //        var components = new List<object>();\n        //        if (args.Count > 0)\n        //        {\n        //            components.Add(new\n        //            {\n        //                type = \"body\",\n        //                parameters = args.Select(a => new { type = \"text\", text = a ?? string.Empty }).ToList()\n        //            });\n        //        }\n        //        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n        //        var payload = new\n        //        {\n        //            messaging_product = \"whatsapp\",\n        //            to = context.ContactPhone,\n        //            type = \"template\",\n        //            template = new\n        //            {\n        //                name = templateName,\n        //                language = new { code = languageCode },\n        //                components\n        //            }\n        //        };\n\n        //        // 4) SEND (explicit provider + sender) â€” always attempt the POST\n        //        _logger.LogInformation(\"âž¡ï¸ SEND-INTENT flow={Flow} step={Step} tmpl={T} to={To} provider={Prov}/{Pnid}\",\n        //            context.FlowId, targetStep.Id, templateName, context.ContactPhone, provider, phoneNumberId);\n\n        //        var sendResult = await _messageEngineService.SendPayloadAsync(\n        //            context.BusinessId,\n        //            provider,               // explicit\n        //            payload,\n        //            phoneNumberId           // explicit\n        //        );\n\n        //        // 5) Snapshot buttons for robust click mapping later\n        //        string? buttonBundleJson = null;\n        //        if (targetStep.ButtonLinks?.Count > 0)\n        //        {\n        //            var bundle = targetStep.ButtonLinks\n        //                .OrderBy(b => b.ButtonIndex)\n        //                .Select(b => new\n        //                {\n        //                    i = b.ButtonIndex,\n        //                    t = b.ButtonText ?? \"\",\n        //                    ty = b.ButtonType ?? \"QUICK_REPLY\",\n        //                    v = b.ButtonValue ?? \"\",\n        //                    ns = b.NextStepId\n        //                })\n        //                .ToList();\n\n        //            buttonBundleJson = JsonSerializer.Serialize(bundle);\n        //        }\n\n        //        // 6) Write MessageLog\n        //        var messageLog = new MessageLog\n        //        {\n        //            Id = Guid.NewGuid(),\n        //            BusinessId = context.BusinessId,\n        //            RecipientNumber = context.ContactPhone,\n        //            CTAFlowConfigId = context.FlowId,\n        //            CTAFlowStepId = targetStep.Id,\n        //            FlowVersion = context.Version,\n        //            Source = \"flow\",\n        //            RefMessageId = context.MessageLogId,\n        //            CreatedAt = DateTime.UtcNow,\n        //            Status = sendResult.Success ? \"Sent\" : \"Failed\",\n        //            MessageId = sendResult.MessageId,\n        //            ErrorMessage = sendResult.ErrorMessage,\n        //            RawResponse = sendResult.RawResponse,\n        //            ButtonBundleJson = buttonBundleJson,\n        //            MessageContent = templateName,\n        //            SentAt = sendResult.Success ? DateTime.UtcNow : (DateTime?)null\n        //        };\n\n        //        _dbContext.MessageLogs.Add(messageLog);\n\n        //        // 7) Flow execution audit row\n        //        _dbContext.FlowExecutionLogs.Add(new FlowExecutionLog\n        //        {\n        //            Id = Guid.NewGuid(),\n        //            BusinessId = context.BusinessId,\n        //            FlowId = context.FlowId,\n        //            StepId = targetStep.Id,\n        //            StepName = templateName,\n        //            MessageLogId = messageLog.Id,\n        //            ButtonIndex = context.ButtonIndex,\n        //            ContactPhone = context.ContactPhone,\n        //            Success = sendResult.Success,\n        //            ErrorMessage = sendResult.ErrorMessage,\n        //            RawResponse = sendResult.RawResponse,\n        //            ExecutedAt = DateTime.UtcNow,\n        //            RequestId = context.RequestId\n        //        });\n\n        //        await _dbContext.SaveChangesAsync();\n\n        //        return new NextStepResult\n        //        {\n        //            Success = sendResult.Success,\n        //            Error = sendResult.ErrorMessage,\n        //            RedirectUrl = null\n        //        };\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        return new NextStepResult { Success = false, Error = ex.Message };\n        //    }\n        //}\n        public async Task<NextStepResult> ExecuteNextAsync(NextStepContext context)\n        {\n            // Capture state for exception logging + failure persistence (updated as we resolve sender/template).\n            var providerForLog = NormalizeProvider(context.Provider);\n            string? phoneNumberIdForLog = string.IsNullOrWhiteSpace(context.PhoneNumberId) ? null : context.PhoneNumberId!.Trim();\n            string? templateNameForLog = null;\n            Guid? targetStepIdForLog = context.TargetStepId;\n\n            try\n            {\n                // â”€â”€ local helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n                string ResolveGreeting(string? profileName, string? contactName)\n                {\n                    var s = (profileName ?? contactName)?.Trim();\n                    return string.IsNullOrEmpty(s) ? \"there\" : s;\n                }\n                void EnsureArgsLength(List<string> args, int slot1Based)\n                {\n                    while (args.Count < slot1Based) args.Add(string.Empty);\n                }\n                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n                // 1) URL-only buttons â†’ no WA send, just record and return redirect\n                if (context.ClickedButton != null &&\n                    context.ClickedButton.ButtonType?.Equals(\"URL\", StringComparison.OrdinalIgnoreCase) == true)\n                {\n                    _dbContext.FlowExecutionLogs.Add(new FlowExecutionLog\n                    {\n                        Id = Guid.NewGuid(),\n                        BusinessId = context.BusinessId,\n                        FlowId = context.FlowId,\n                        StepId = context.SourceStepId,\n                        StepName = \"URL_REDIRECT\",\n                        MessageLogId = context.MessageLogId,\n                        ButtonIndex = context.ButtonIndex,\n                        ContactPhone = context.ContactPhone,\n                        Success = true,\n                        ExecutedAt = DateTime.UtcNow,\n                        RequestId = context.RequestId\n                    });\n                    await _dbContext.SaveChangesAsync();\n\n                    return new NextStepResult { Success = true, RedirectUrl = context.ClickedButton.ButtonValue };\n                }\n\n                // Helpful for webhook-click observability (may be null for non-click paths).\n                var clickedBtnText = context.ClickedButton?.ButtonText;\n\n                // 2) Load next step in the same flow\n                var targetStep = await _dbContext.CTAFlowSteps\n                    .Include(s => s.ButtonLinks)\n                    .FirstOrDefaultAsync(s => s.Id == context.TargetStepId &&\n                                              s.CTAFlowConfigId == context.FlowId);\n\n                if (targetStep == null)\n                {\n                    // NOTE: Added for ESU-era click-triggered flows so failures are observable (not silent).\n                    var err = \"Target step not found.\";\n                    _logger.LogWarning(\n                        \"CTAFlow ExecuteNextAsync failed: {Error} biz={Biz} flow={Flow} srcStep={Src} targetStep={Target} to={To} btnIdx={BtnIdx} btnText='{BtnText}' providerHint={Provider}/{PhoneNumberId}\",\n                        err, context.BusinessId, context.FlowId, context.SourceStepId, context.TargetStepId, context.ContactPhone, context.ButtonIndex, clickedBtnText, context.Provider, context.PhoneNumberId);\n\n                    await RecordFailureAsync(\n                        context,\n                        // TargetStepId is nullable; store failure against SourceStepId and include target in the error message/logs.\n                        stepId: context.SourceStepId,\n                        stepName: \"TARGET_STEP_NOT_FOUND\",\n                        error: err);\n\n                    return new NextStepResult { Success = false, Error = err };\n                }\n\n                if (string.IsNullOrWhiteSpace(targetStep.TemplateToSend))\n                {\n                    var err = \"Target step has no template assigned.\";\n                    _logger.LogWarning(\n                        \"CTAFlow ExecuteNextAsync failed: {Error} biz={Biz} flow={Flow} srcStep={Src} targetStep={Target} to={To} btnIdx={BtnIdx} btnText='{BtnText}' providerHint={Provider}/{PhoneNumberId}\",\n                        err, context.BusinessId, context.FlowId, context.SourceStepId, context.TargetStepId, context.ContactPhone, context.ButtonIndex, clickedBtnText, context.Provider, context.PhoneNumberId);\n\n                    await RecordFailureAsync(\n                        context,\n                        stepId: targetStep.Id,\n                        stepName: \"NO_TEMPLATE_ASSIGNED\",\n                        error: err);\n\n                    return new NextStepResult { Success = false, Error = err };\n                }\n\n                var templateName = targetStep.TemplateToSend.Trim();\n                templateNameForLog = templateName;\n                targetStepIdForLog = targetStep.Id;\n\n                // 3) Preflight the template (you can replace with a DB read later if desired)\n                var meta = await _templateFetcherService.GetTemplateByNameAsync(\n                    context.BusinessId, templateName, includeButtons: true);\n\n                if (meta == null)\n                {\n                    _dbContext.FlowExecutionLogs.Add(new FlowExecutionLog\n                    {\n                        Id = Guid.NewGuid(),\n                        BusinessId = context.BusinessId,\n                        FlowId = context.FlowId,\n                        StepId = targetStep.Id,\n                        StepName = templateName,\n                        MessageLogId = null,\n                        ButtonIndex = context.ButtonIndex,\n                        ContactPhone = context.ContactPhone,\n                        Success = false,\n                        ErrorMessage = $\"Template '{templateName}' not found for this WABA.\",\n                        RawResponse = null,\n                        ExecutedAt = DateTime.UtcNow,\n                        RequestId = context.RequestId\n                    });\n                    await _dbContext.SaveChangesAsync();\n\n                    return new NextStepResult { Success = false, Error = $\"Template '{templateName}' not found or not approved.\" };\n                }\n\n                var languageCode = string.IsNullOrWhiteSpace(meta.Language) ? \"en_US\" : meta.Language;\n\n                // 3.1) Sender resolution (single source of truth via DTO, with context overrides)\n                string provider = NormalizeProvider(context.Provider);\n                string? phoneNumberId = string.IsNullOrWhiteSpace(context.PhoneNumberId) ? null : context.PhoneNumberId!.Trim();\n                providerForLog = provider;\n                phoneNumberIdForLog = phoneNumberId;\n\n                if (provider != \"PINNACLE\" && provider != \"META_CLOUD\" || string.IsNullOrWhiteSpace(phoneNumberId))\n                {\n                    // Pull unified settings (provider + default phone for that provider)\n                    var wa = await _whatsAppSettingsService.GetSettingsByBusinessIdAsync(context.BusinessId);\n                    if (wa == null)\n                    {\n                        var err = \"No active WhatsApp settings found.\";\n                        _logger.LogWarning(\n                            \"CTAFlow ExecuteNextAsync failed: {Error} biz={Biz} flow={Flow} srcStep={Src} targetStep={Target} tmpl={T} to={To} btnIdx={BtnIdx} btnText='{BtnText}' providerHint={Provider}/{PhoneNumberId}\",\n                            err, context.BusinessId, context.FlowId, context.SourceStepId, context.TargetStepId, templateName, context.ContactPhone, context.ButtonIndex, clickedBtnText, context.Provider, context.PhoneNumberId);\n\n                        await RecordFailureAsync(context, stepId: targetStep.Id, stepName: templateName, error: err);\n                        return new NextStepResult { Success = false, Error = err };\n                    }\n\n                    // Context wins if valid, else fall back to DTO\n                    if (provider != \"PINNACLE\" && provider != \"META_CLOUD\")\n                    {\n                        var key = (wa.Provider ?? string.Empty).Trim().ToLowerInvariant();\n                        provider = key switch\n                        {\n                            \"meta\" => \"META_CLOUD\",\n                            \"meta_cloud\" => \"META_CLOUD\",\n                            \"meta-cloud\" => \"META_CLOUD\",\n                            \"meta cloud\" => \"META_CLOUD\",\n                            \"pinnacle\" => \"PINNACLE\",\n                            _ => NormalizeProvider(wa.Provider)\n                        };\n                        providerForLog = provider;\n                    }\n\n                    if (string.IsNullOrWhiteSpace(phoneNumberId))\n                    {\n                        // ESU constraint: PhoneNumberId must come ONLY from WhatsAppPhoneNumbers.\n                        // Never read WhatsAppSettings.PhoneNumberId (legacy column).\n                        var sender = await _whatsAppSenderService.ResolveDefaultSenderAsync(\n                            context.BusinessId,\n                            providerHint: provider,\n                            ct: default);\n\n                        if (!sender.Success)\n                        {\n                            var err = sender.Error ?? \"Failed to resolve WhatsApp sender.\";\n                            _logger.LogWarning(\n                                \"CTAFlow ExecuteNextAsync failed: {Error} biz={Biz} flow={Flow} srcStep={Src} targetStep={Target} tmpl={T} to={To} btnIdx={BtnIdx} btnText='{BtnText}' provider={Provider}\",\n                                err, context.BusinessId, context.FlowId, context.SourceStepId, context.TargetStepId, templateName, context.ContactPhone, context.ButtonIndex, clickedBtnText, provider);\n\n                            await RecordFailureAsync(context, stepId: targetStep.Id, stepName: templateName, error: err);\n                            return new NextStepResult { Success = false, Error = err };\n                        }\n\n                        // Keep provider stable if already known; if not known, align to the resolved sender provider.\n                        if (provider != \"PINNACLE\" && provider != \"META_CLOUD\" && !string.IsNullOrWhiteSpace(sender.Provider))\n                            provider = NormalizeProvider(sender.Provider);\n\n                        phoneNumberId = sender.PhoneNumberId;\n                        providerForLog = provider;\n                        phoneNumberIdForLog = phoneNumberId;\n                    }\n                }\n\n                if (provider != \"PINNACLE\" && provider != \"META_CLOUD\")\n                {\n                    var err = \"No active WhatsApp sender configured (provider could not be resolved).\";\n                    _logger.LogWarning(\n                        \"CTAFlow ExecuteNextAsync failed: {Error} biz={Biz} flow={Flow} srcStep={Src} targetStep={Target} tmpl={T} to={To} btnIdx={BtnIdx} btnText='{BtnText}' provider={Provider}/{PhoneNumberId}\",\n                        err, context.BusinessId, context.FlowId, context.SourceStepId, context.TargetStepId, templateName, context.ContactPhone, context.ButtonIndex, clickedBtnText, provider, phoneNumberId);\n\n                    await RecordFailureAsync(context, stepId: targetStep.Id, stepName: templateName, error: err);\n                    return new NextStepResult { Success = false, Error = err };\n                }\n\n                if (provider == \"META_CLOUD\" && string.IsNullOrWhiteSpace(phoneNumberId))\n                {\n                    // This should only happen if WhatsAppPhoneNumbers has no active sender; log + persist to avoid silent click failures.\n                    var err = \"Missing PhoneNumberId (no default Meta sender configured).\";\n                    _logger.LogWarning(\n                        \"CTAFlow ExecuteNextAsync failed: {Error} biz={Biz} flow={Flow} srcStep={Src} targetStep={Target} tmpl={T} to={To} btnIdx={BtnIdx} btnText='{BtnText}' provider={Provider}\",\n                        err, context.BusinessId, context.FlowId, context.SourceStepId, context.TargetStepId, templateName, context.ContactPhone, context.ButtonIndex, clickedBtnText, provider);\n\n                    await RecordFailureAsync(context, stepId: targetStep.Id, stepName: templateName, error: err);\n                    return new NextStepResult { Success = false, Error = err };\n                }\n\n                // â”€â”€ BODY placeholder resolution (static step params + optional profile-name injection) â”€â”€â”€â”€â”€â”€â”€â”€â”€\n                // CTA flows run from webhook clicks and do not have campaign-time personalization context, so\n                // we persist body parameter values per step (CTAFlowSteps.BodyParamsJson).\n                // NOTE: TemplateMetadataDto.PlaceholderCount includes button tokens too; use WhatsAppTemplates.BodyVarCount.\n                var bodyVarCount = await ResolveBodyVarCountAsync(context.BusinessId, templateName, meta);\n                var args = new List<string>(Math.Max(0, bodyVarCount));\n                if (bodyVarCount > 0)\n                {\n                    args.AddRange(Enumerable.Repeat(string.Empty, bodyVarCount));\n                    var stored = TryParseBodyParams(targetStep.BodyParamsJson);\n                    for (var i = 0; i < bodyVarCount && i < stored.Count; i++)\n                        args[i] = (stored[i] ?? string.Empty).Trim();\n                }\n\n                if (targetStep.UseProfileName && targetStep.ProfileNameSlot is int slot && slot >= 1)\n                {\n                    if (bodyVarCount <= 0)\n                    {\n                        _logger.LogWarning(\n                            \"CTAFlow profile-name slot configured but template has no body vars biz={Biz} flow={Flow} step={Step} tmpl={T} slot={Slot}\",\n                            context.BusinessId, context.FlowId, targetStep.Id, templateName, slot);\n                    }\n                    else if (slot <= bodyVarCount)\n                    {\n                        var contact = await _dbContext.Contacts\n                            .AsNoTracking()\n                            .FirstOrDefaultAsync(c => c.BusinessId == context.BusinessId\n                                                      && c.PhoneNumber == context.ContactPhone);\n\n                        var greet = ResolveGreeting(contact?.ProfileName, contact?.Name);\n                        args[slot - 1] = greet;\n                    }\n                }\n\n                if (bodyVarCount > 0 && args.Any(a => string.IsNullOrWhiteSpace(a)))\n                {\n                    var err = $\"Template '{templateName}' requires {bodyVarCount} body parameter(s), but one or more values are missing.\";\n                    _logger.LogWarning(\n                        \"CTAFlow ExecuteNextAsync failed: {Error} biz={Biz} flow={Flow} srcStep={Src} targetStep={Target} tmpl={T} to={To} btnIdx={BtnIdx} btnText='{BtnText}'\",\n                        err, context.BusinessId, context.FlowId, context.SourceStepId, targetStep.Id, templateName, context.ContactPhone, context.ButtonIndex, clickedBtnText);\n\n                    await RecordFailureAsync(context, stepId: targetStep.Id, stepName: templateName, error: err);\n                    return new NextStepResult { Success = false, Error = err };\n                }\n\n                var components = new List<object>();\n\n                // â”€â”€ Media header support (phase 1) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n                // CTA flow runtime previously sent only BODY components. For templates whose header kind is\n                // image/video/document, WhatsApp (Meta Cloud) requires a header component with a media link.\n                // Phase 2: HeaderMediaUrl is persisted per step (CTAFlowSteps.HeaderMediaUrl). We still accept an\n                // execution-context override (e.g., campaign/runtime) and keep a temporary fallback from clicked\n                // button value to avoid breaking older flows until the UI starts populating the step field.\n                var headerKind = (meta.HeaderKind ?? \"none\").Trim().ToLowerInvariant();\n                var requiresMediaHeader = headerKind is \"image\" or \"video\" or \"document\";\n                string? headerMediaUrl = string.IsNullOrWhiteSpace(context.HeaderMediaUrl) ? null : context.HeaderMediaUrl!.Trim();\n\n                if (requiresMediaHeader && string.IsNullOrWhiteSpace(headerMediaUrl))\n                {\n                    // Phase 2: Prefer persisted per-step configuration.\n                    headerMediaUrl = string.IsNullOrWhiteSpace(targetStep.HeaderMediaUrl) ? null : targetStep.HeaderMediaUrl!.Trim();\n                }\n\n                if (requiresMediaHeader && string.IsNullOrWhiteSpace(headerMediaUrl))\n                {\n                    // Temporary fallback: treat a clicked button value that looks like a URL as the media link.\n                    // This is best-effort for backward compatibility; UI should persist HeaderMediaUrl on the step.\n                    if (TryGetHttpUrl(context.ClickedButton?.ButtonValue, out var fallbackUrl))\n                    {\n                        headerMediaUrl = fallbackUrl;\n                        _logger.LogInformation(\n                            \"CTAFlow header media URL sourced from clicked button value biz={Biz} flow={Flow} srcStep={Src} targetStep={Target} tmpl={T} kind={Kind}\",\n                            context.BusinessId, context.FlowId, context.SourceStepId, targetStep.Id, templateName, headerKind);\n                    }\n                }\n\n                if (requiresMediaHeader)\n                {\n                    if (!string.Equals(provider, \"META_CLOUD\", StringComparison.OrdinalIgnoreCase))\n                    {\n                        var err = $\"CTAFlow media-header templates are not supported for provider '{provider}' yet.\";\n                        _logger.LogWarning(\n                            \"CTAFlow ExecuteNextAsync failed: {Error} biz={Biz} flow={Flow} srcStep={Src} targetStep={Target} tmpl={T} to={To} btnIdx={BtnIdx} btnText='{BtnText}' provider={Prov}\",\n                            err, context.BusinessId, context.FlowId, context.SourceStepId, targetStep.Id, templateName, context.ContactPhone, context.ButtonIndex, clickedBtnText, provider);\n\n                        await RecordFailureAsync(context, stepId: targetStep.Id, stepName: templateName, error: err);\n                        return new NextStepResult { Success = false, Error = err };\n                    }\n\n                    if (string.IsNullOrWhiteSpace(headerMediaUrl))\n                    {\n                        var err = $\"Template '{templateName}' requires a {headerKind} header, but no HeaderMediaUrl was provided.\";\n                        _logger.LogWarning(\n                            \"CTAFlow ExecuteNextAsync failed: {Error} biz={Biz} flow={Flow} srcStep={Src} targetStep={Target} tmpl={T} to={To} btnIdx={BtnIdx} btnText='{BtnText}' provider={Prov}/{Pnid}\",\n                            err, context.BusinessId, context.FlowId, context.SourceStepId, targetStep.Id, templateName, context.ContactPhone, context.ButtonIndex, clickedBtnText, provider, phoneNumberId);\n\n                        await RecordFailureAsync(context, stepId: targetStep.Id, stepName: templateName, error: err);\n                        return new NextStepResult { Success = false, Error = err };\n                    }\n\n                    object mediaParam = headerKind switch\n                    {\n                        \"image\" => new { type = \"image\", image = new { link = headerMediaUrl } },\n                        \"video\" => new { type = \"video\", video = new { link = headerMediaUrl } },\n                        \"document\" => new { type = \"document\", document = new { link = headerMediaUrl } },\n                        _ => new { type = \"text\", text = \"\" } // should not happen due to requiresMediaHeader guard\n                    };\n\n                    components.Add(new\n                    {\n                        type = \"header\",\n                        parameters = new object[] { mediaParam }\n                    });\n                }\n                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n                if (bodyVarCount > 0)\n                {\n                    components.Add(new\n                    {\n                        type = \"body\",\n                        parameters = args.Select(a => new { type = \"text\", text = a ?? string.Empty }).ToList()\n                    });\n                }\n                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n                // â”€â”€ Dynamic URL button parameters (Meta Cloud) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n                // WhatsApp Cloud requires \"button\" components when a template has dynamic URL buttons.\n                // We store per-step values in CTAFlowSteps.UrlButtonParamsJson (index 0 => button index \"0\").\n                if (string.Equals(provider, \"META_CLOUD\", StringComparison.OrdinalIgnoreCase) &&\n                    meta.ButtonParams is { Count: > 0 })\n                {\n                    var storedUrlParams = TryParseUrlButtonParams(targetStep.UrlButtonParamsJson);\n\n                    var buttons = meta.ButtonParams\n                        .OrderBy(b => b.Index)\n                        .Take(3)\n                        .ToList();\n\n                    foreach (var b in buttons)\n                    {\n                        var idx = b.Index;\n                        if (idx < 0 || idx > 2) continue;\n\n                        var isUrl =\n                            string.Equals(b.Type, \"URL\", StringComparison.OrdinalIgnoreCase) ||\n                            string.Equals(b.SubType, \"url\", StringComparison.OrdinalIgnoreCase);\n                        if (!isUrl) continue;\n\n                        var mask = (b.ParameterValue ?? string.Empty).Trim();\n                        var isDynamic = mask.Contains(\"{{\", StringComparison.Ordinal);\n                        if (!isDynamic) continue;\n\n                        var param = (idx < storedUrlParams.Count ? storedUrlParams[idx] : null) ?? string.Empty;\n                        param = param.Trim();\n\n                        if (string.IsNullOrWhiteSpace(param))\n                        {\n                            var err = $\"Template '{templateName}' requires a dynamic URL parameter for button {idx + 1} ('{b.Text}').\";\n                            _logger.LogWarning(\n                                \"CTAFlow ExecuteNextAsync failed: {Error} biz={Biz} flow={Flow} srcStep={Src} targetStep={Target} tmpl={T} to={To} btnIdx={BtnIdx} btnText='{BtnText}' provider={Prov}/{Pnid} urlBtnIdx={UrlIdx} urlBtnText='{UrlText}'\",\n                                err, context.BusinessId, context.FlowId, context.SourceStepId, targetStep.Id, templateName, context.ContactPhone, context.ButtonIndex, clickedBtnText, provider, phoneNumberId, idx, b.Text);\n\n                            await RecordFailureAsync(context, stepId: targetStep.Id, stepName: templateName, error: err);\n                            return new NextStepResult { Success = false, Error = err };\n                        }\n\n                        components.Add(new\n                        {\n                            type = \"button\",\n                            sub_type = \"url\",\n                            index = idx.ToString(),\n                            parameters = new object[]\n                            {\n                                new { type = \"text\", text = param }\n                            }\n                        });\n                    }\n                }\n\n\n                var payload = new\n                {\n                    messaging_product = \"whatsapp\",\n                    to = context.ContactPhone,\n                    type = \"template\",\n                    template = new\n                    {\n                        name = templateName,\n                        language = new { code = languageCode },\n                        components\n                    }\n                };\n\n                // 4) SEND (explicit provider + sender)\n                _logger.LogInformation(\"âž¡ï¸ SEND-INTENT flow={Flow} step={Step} tmpl={T} to={To} provider={Prov}/{Pnid}\",\n                    context.FlowId, targetStep.Id, templateName, context.ContactPhone, provider, phoneNumberId);\n\n                var sendResult = await _messageEngineService.SendPayloadAsync(\n                    context.BusinessId,\n                    provider,\n                    payload,\n                    phoneNumberId\n                );\n\n                if (!sendResult.Success)\n                {\n                    // NOTE: Added so webhook-driven flows can't fail silently; DB already captures Status=Failed below.\n                    _logger.LogWarning(\n                        \"CTAFlow send failed biz={Biz} flow={Flow} srcStep={Src} targetStep={Target} tmpl={T} to={To} btnIdx={BtnIdx} btnText='{BtnText}' provider={Prov}/{Pnid} err={Err}\",\n                        context.BusinessId, context.FlowId, context.SourceStepId, targetStep.Id, templateName, context.ContactPhone, context.ButtonIndex, clickedBtnText, provider, phoneNumberId, sendResult.ErrorMessage);\n                }\n\n                // 5) Snapshot buttons for click mapping\n                string? buttonBundleJson = null;\n                if (targetStep.ButtonLinks?.Count > 0)\n                {\n                    var bundle = targetStep.ButtonLinks\n                        .OrderBy(b => b.ButtonIndex)\n                        .Select(b => new\n                        {\n                            i = b.ButtonIndex,\n                            t = b.ButtonText ?? \"\",\n                            ty = b.ButtonType ?? \"QUICK_REPLY\",\n                            v = b.ButtonValue ?? \"\",\n                            ns = b.NextStepId\n                        })\n                        .ToList();\n\n                    buttonBundleJson = JsonSerializer.Serialize(bundle);\n                }\n\n                // 6) MessageLog\n                var messageLog = new MessageLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = context.BusinessId,\n                    RecipientNumber = context.ContactPhone,\n                    CTAFlowConfigId = context.FlowId,\n                    CTAFlowStepId = targetStep.Id,\n                    FlowVersion = context.Version,\n                    Source = \"flow\",\n                    RefMessageId = context.MessageLogId,\n                    CreatedAt = DateTime.UtcNow,\n                    Status = sendResult.Success ? \"Sent\" : \"Failed\",\n                    MessageId = sendResult.MessageId,\n                    ErrorMessage = sendResult.ErrorMessage,\n                    RawResponse = sendResult.RawResponse,\n                    ButtonBundleJson = buttonBundleJson,\n                    MessageContent = templateName,\n                    SentAt = sendResult.Success ? DateTime.UtcNow : (DateTime?)null\n                };\n\n                _dbContext.MessageLogs.Add(messageLog);\n\n                // 7) Flow execution audit\n                _dbContext.FlowExecutionLogs.Add(new FlowExecutionLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = context.BusinessId,\n                    FlowId = context.FlowId,\n                    StepId = targetStep.Id,\n                    StepName = templateName,\n                    MessageLogId = messageLog.Id,\n                    ButtonIndex = context.ButtonIndex,\n                    ContactPhone = context.ContactPhone,\n                    Success = sendResult.Success,\n                    ErrorMessage = sendResult.ErrorMessage,\n                    RawResponse = sendResult.RawResponse,\n                    ExecutedAt = DateTime.UtcNow,\n                    RequestId = context.RequestId\n                });\n\n                await _dbContext.SaveChangesAsync();\n\n                return new NextStepResult\n                {\n                    Success = sendResult.Success,\n                    Error = sendResult.ErrorMessage\n                };\n            }\n            catch (Exception ex)\n            {\n                var err = ex.Message;\n                _logger.LogError(ex,\n                    \"CTAFlow ExecuteNextAsync exception biz={Biz} flow={Flow} srcStep={Src} targetStep={Target} tmpl={T} to={To} btnIdx={BtnIdx} provider={Provider}/{PhoneNumberId}\",\n                    context.BusinessId, context.FlowId, context.SourceStepId, targetStepIdForLog, templateNameForLog, context.ContactPhone, context.ButtonIndex, providerForLog, phoneNumberIdForLog);\n\n                await RecordFailureAsync(\n                    context,\n                    stepId: targetStepIdForLog ?? context.SourceStepId,\n                    stepName: templateNameForLog ?? \"EXCEPTION\",\n                    error: err);\n\n                return new NextStepResult { Success = false, Error = err };\n            }\n        }\n\n        private static readonly System.Text.RegularExpressions.Regex PositionalToken =\n            new(@\"\\{\\{\\s*\\d+\\s*\\}\\}\", System.Text.RegularExpressions.RegexOptions.Compiled); // {{1}}, {{ 2 }}, etc.\n\n        private static readonly System.Text.RegularExpressions.Regex NamedToken =\n            new(@\"\\{\\{\\s*\\}\\}\", System.Text.RegularExpressions.RegexOptions.Compiled);        // {{}} (NAMED format slot)\n\n        private static int CountBodyTokensFlexible(string? text)\n        {\n            if (string.IsNullOrEmpty(text)) return 0;\n            return PositionalToken.Matches(text).Count + NamedToken.Matches(text).Count;\n        }\n\n        private static List<string> TryParseBodyParams(string? json)\n        {\n            if (string.IsNullOrWhiteSpace(json)) return new List<string>();\n            try\n            {\n                var list = JsonSerializer.Deserialize<List<string>>(json);\n                return list ?? new List<string>();\n            }\n            catch\n            {\n                return new List<string>();\n            }\n        }\n\n        private static List<string> TryParseUrlButtonParams(string? json)\n        {\n            if (string.IsNullOrWhiteSpace(json)) return new List<string>();\n            try\n            {\n                var list = JsonSerializer.Deserialize<List<string>>(json);\n                return list ?? new List<string>();\n            }\n            catch\n            {\n                return new List<string>();\n            }\n        }\n\n        private async Task<int> ResolveBodyVarCountAsync(Guid businessId, string templateName, xbytechat.api.WhatsAppSettings.DTOs.TemplateMetadataDto meta)\n        {\n            try\n            {\n                // WhatsAppTemplates.BodyVarCount is the canonical body placeholder count (buttons are separate).\n                var count = await _dbContext.WhatsAppTemplates\n                    .AsNoTracking()\n                    .Where(t => t.BusinessId == businessId && t.IsActive && t.Name == templateName)\n                    .OrderByDescending(t => t.UpdatedAt)\n                    .Select(t => t.BodyVarCount)\n                    .FirstOrDefaultAsync();\n\n                if (count > 0) return count;\n            }\n            catch (Exception ex)\n            {\n                // Best-effort; fall back to counting tokens in the template preview body.\n                _logger.LogWarning(ex,\n                    \"CTAFlow ResolveBodyVarCountAsync failed, falling back to token count biz={Biz} tmpl={T}\",\n                    businessId, templateName);\n            }\n\n            return CountBodyTokensFlexible(meta?.Body);\n        }\n\n        private static bool TryGetHttpUrl(string? maybeUrl, out string url)\n        {\n            url = string.Empty;\n            if (string.IsNullOrWhiteSpace(maybeUrl)) return false;\n            if (!Uri.TryCreate(maybeUrl.Trim(), UriKind.Absolute, out var u)) return false;\n            if (!string.Equals(u.Scheme, Uri.UriSchemeHttp, StringComparison.OrdinalIgnoreCase) &&\n                !string.Equals(u.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n                return false;\n            url = u.ToString();\n            return true;\n        }\n\n        private async Task RecordFailureAsync(NextStepContext context, Guid stepId, string stepName, string error)\n        {\n            try\n            {\n                _dbContext.FlowExecutionLogs.Add(new FlowExecutionLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = context.BusinessId,\n                    FlowId = context.FlowId,\n                    StepId = stepId,\n                    StepName = stepName,\n                    MessageLogId = context.MessageLogId == Guid.Empty ? null : context.MessageLogId,\n                    ButtonIndex = context.ButtonIndex,\n                    ContactPhone = context.ContactPhone,\n                    Success = false,\n                    ErrorMessage = error,\n                    ExecutedAt = DateTime.UtcNow,\n                    RequestId = context.RequestId\n                });\n\n                await _dbContext.SaveChangesAsync();\n            }\n            catch (Exception ex)\n            {\n                // NOTE: Do not throw from webhook runtime; log only (best-effort observability).\n                _logger.LogError(ex,\n                    \"CTAFlow RecordFailureAsync failed biz={Biz} flow={Flow} step={Step} to={To} error={Err}\",\n                    context.BusinessId, context.FlowId, stepId, context.ContactPhone, error);\n            }\n        }\n\n\n    }\n}\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Services/ICtaFlowRuntimeService.cs",
      "sha256": "ba7f6a253e9b5e3af197db5060f0879595cef09e7e8e7e796b9fae4028c0f284",
      "language": "csharp",
      "size": 1518,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CTAFlowBuilder.DTOs;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Services\n{\n    /// <summary>\n    /// Runtime engine for executing CTA flows (journey flows).\n    /// \n    /// This is the single entry point used by other modules:\n    /// - AutoReply (CTA_FLOW nodes)\n    /// - Campaigns (button-click journeys)\n    /// - Future JourneyBot / Inbox actions\n    /// </summary>\n    public interface ICtaFlowRuntimeService\n    {\n        /// <summary>\n        /// Starts a CTA flow journey for a given contact.\n        /// </summary>\n        /// <param name=\"businessId\">Tenant business id.</param>\n        /// <param name=\"contactId\">Contact id in CRM (if known).</param>\n        /// <param name=\"contactPhone\">Contact phone number (WhatsApp).</param>\n        /// <param name=\"configId\">CTA flow config id (visual flow definition).</param>\n        /// <param name=\"origin\">Where this journey was triggered from.</param>\n        /// <param name=\"autoReplyFlowId\">\n        /// Optional AutoReplyFlow id when origin = AutoReply; otherwise null.\n        /// </param>\n        Task<CtaFlowRunResult> StartFlowAsync(\n            Guid businessId,\n            Guid contactId,\n            string contactPhone,\n            Guid configId,\n            FlowExecutionOrigin origin,\n            Guid? autoReplyFlowId,\n            CancellationToken cancellationToken = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Services/ICTAFlowService.cs",
      "sha256": "ea564ff162310a68224cdc57a047aa45a900fc613e40a06e7d0a22780ef35ee2",
      "language": "csharp",
      "size": 5223,
      "content": "using xbytechat.api.Features.CTAFlowBuilder.DTOs;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Services\n{\n    public interface ICTAFlowService\n    {\n        // Create-only (draft)\n        Task<ResponseResult> SaveVisualFlowAsync(SaveVisualFlowDto dto, Guid businessId, string createdBy);\n\n        // Load flows (lists)\n        Task<List<VisualFlowSummaryDto>> GetAllPublishedFlowsAsync(Guid businessId);\n        Task<List<VisualFlowSummaryDto>> GetAllDraftFlowsAsync(Guid businessId);\n\n        // Load flow (detail)\n        Task<SaveVisualFlowDto?> GetVisualFlowByIdAsync(Guid flowId, Guid businessId);  // for editor/view\n        Task<ResponseResult> GetVisualFlowAsync(Guid flowId, Guid businessId);          // alt payload\n\n        // Runtime\n        Task<CTAFlowStep?> MatchStepByButtonAsync(Guid businessId, string buttonText, string buttonType, string currentTemplateName, Guid? campaignId = null);\n        Task<ResponseResult> ExecuteVisualFlowAsync(Guid businessId, Guid startStepId, Guid trackingLogId, Guid? campaignSendLogId);\n        Task<CTAFlowStep?> GetChainedStepAsync(Guid businessId, Guid? nextStepId);\n        Task<CTAFlowStep?> GetChainedStepWithContextAsync(Guid businessId, Guid? nextStepId, Guid? trackingLogId);\n        Task<FlowButtonLink?> GetLinkAsync(Guid flowId, Guid sourceStepId, short buttonIndex);\n\n        // Delete (only if not attached)\n        Task<ResponseResult> DeleteFlowAsync(Guid flowId, Guid businessId, string deletedBy);\n\n        // Publish\n        Task<ResponseResult> PublishFlowAsync(Guid flowId, Guid businessId, string user);\n\n        // Update (save as draft) + fork (create new draft copy)\n        Task<FlowUpdateResult> UpdateVisualFlowAsync(Guid flowId, SaveVisualFlowDto dto, Guid businessId, string user);\n        Task<Guid> ForkFlowAsync(Guid flowId, Guid businessId, string user);\n\n        // Attached campaigns (for usage checks / modal)\n        Task<IReadOnlyList<AttachedCampaignDto>> GetAttachedCampaignsAsync(Guid flowId, Guid businessId);\n\n        // (Optional utility)\n        Task<bool> HardDeleteFlowIfUnusedAsync(Guid flowId, Guid businessId);\n    }\n}\n\n\n//using xbytechat.api.Features.CTAFlowBuilder.DTOs;\n//using xbytechat.api.Features.CTAFlowBuilder.Models;\n//using xbytechat.api.Helpers;\n\n//namespace xbytechat.api.Features.CTAFlowBuilder.Services\n//{\n//    public interface ICTAFlowService\n//    {\n//        // âœ… Used for flow creation and saving\n//        Task<Guid> CreateFlowWithStepsAsync(CreateFlowDto dto, Guid businessId, string createdBy);\n//        Task<ResponseResult> SaveVisualFlowAsync(SaveVisualFlowDto dto, Guid businessId, string createdBy);\n\n//        // âœ… Load flows\n//        Task<CTAFlowConfig?> GetFlowByBusinessAsync(Guid businessId);\n//        Task<CTAFlowConfig?> GetDraftFlowByBusinessAsync(Guid businessId);\n//        Task<List<VisualFlowSummaryDto>> GetAllPublishedFlowsAsync(Guid businessId);\n//        Task<List<VisualFlowSummaryDto>> GetAllDraftFlowsAsync(Guid businessId);\n\n//        // âœ… Load and manage flow steps\n//        Task<List<CTAFlowStep>> GetStepsForFlowAsync(Guid flowId);\n\n\n//        Task<CTAFlowStep?> MatchStepByButtonAsync(Guid businessId, string buttonText,string buttonType,string currentTemplateName,Guid? campaignId = null);\n\n\n//        Task<CTAFlowStep?> GetChainedStepAsync(Guid businessId, Guid? nextStepId);\n//        Task<CTAFlowStep?> GetChainedStepWithContextAsync(Guid businessId, Guid? nextStepId, Guid? trackingLogId);\n//        // âœ… Runtime logic\n//        Task<ResponseResult> ExecuteFollowUpStepAsync(Guid businessId, CTAFlowStep? currentStep, string recipientNumber);\n\n//        // âœ… Flow management\n//        Task<ResponseResult> PublishFlowAsync(Guid businessId, List<FlowStepDto> steps, string createdBy);\n\n//        Task<ResponseResult> DeleteFlowAsync(Guid flowId, Guid businessId, string deletedBy);\n\n//        // âœ… Editor loading (visual builder)\n//       // Task<SaveVisualFlowDto?> GetVisualFlowByIdAsync(Guid id, Guid businessId);\n//        Task<SaveVisualFlowDto?> GetVisualFlowByIdAsync(Guid flowId, Guid businessId);\n//        Task<ResponseResult> GetVisualFlowAsync(Guid flowId, Guid businessId);\n//        Task<ResponseResult> ExecuteVisualFlowAsync(Guid businessId, Guid startStepId, Guid trackingLogId, Guid? campaignSendLogId);\n//        Task<FlowButtonLink?> GetLinkAsync(Guid flowId, Guid sourceStepId, short buttonIndex);\n\n//        public interface IFlowRuntimeService\n//        {\n//            Task<NextStepResult> ExecuteNextAsync(NextStepContext context);\n//        }\n//        Task<IReadOnlyList<AttachedCampaignDto>> GetAttachedCampaignsAsync(Guid flowId, Guid businessId);\n//        Task<bool> HardDeleteFlowIfUnusedAsync(Guid flowId, Guid businessId);\n//        //Task<FlowUpdateResult> UpdateVisualFlowAsync(Guid flowId, SaveVisualFlowDto dto, Guid businessId, string user);\n\n//        // Explicit publish after edits\n//        Task<bool> PublishFlowAsync(Guid flowId, Guid businessId, string user);\n\n//        // Create a new draft copy when live flow is attached\n//        Task<Guid> ForkFlowAsync(Guid flowId, Guid businessId, string user);\n//    }\n//}\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Services/IFlowExecutionLogger.cs",
      "sha256": "f55acecb74866f1c84445d8583541fd60f0436c02f1f1e87815fce4ce5acf9b9",
      "language": "csharp",
      "size": 717,
      "content": "using System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.AutoReplyBuilder.DTOs;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\n\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Services\n{\n    /// <summary>\n    /// Abstraction for writing origin-tagged FlowExecutionLog rows.\n    /// Different engines (Campaign, AutoReply, Inbox, JourneyBot)\n    /// will call this with a FlowExecutionContext.\n    /// </summary>\n    public interface IFlowExecutionLogger\n    {\n        /// <summary>\n        /// Persist a single step execution into FlowExecutionLogs.\n        /// </summary>\n        Task LogStepAsync(FlowExecutionContext context, CancellationToken cancellationToken = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Services/IFlowRuntimeService.cs",
      "sha256": "02883161ca81dc88c13dcc8d599794a62f59a3641643696423a75cca4c36b1e7",
      "language": "csharp",
      "size": 1573,
      "content": "using xbytechat.api.Features.CTAFlowBuilder.Models;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Services\n{\n    public interface IFlowRuntimeService\n    {\n        Task<NextStepResult> ExecuteNextAsync(NextStepContext context);\n\n    }\n    public record NextStepContext\n    {\n        public Guid BusinessId { get; set; }\n        public Guid FlowId { get; set; }\n        public int Version { get; set; }\n        public Guid SourceStepId { get; set; }\n        public Guid? TargetStepId { get; set; }\n        public short ButtonIndex { get; set; }\n        public Guid MessageLogId { get; set; }\n        public string ContactPhone { get; set; } = string.Empty;\n        public Guid RequestId { get; set; }\n        public FlowButtonLink? ClickedButton { get; set; }\n        public string? Provider { get; set; }          // \"META_CLOUD\" | \"PINNACLE\"\n        public string? PhoneNumberId { get; set; }\n            public bool AlwaysSend { get; set; } = true;\n\n        // CTA media-header support (step 1/phase 1):\n        // When a template requires a media header (image/video/document), WhatsApp requires a header component with a link.\n        // In phase 2/3 we will persist this per-step (CTAFlowStep.HeaderMediaUrl) via UI + DB.\n        // For now this is an optional override input so runtime can attach the header when available.\n        public string? HeaderMediaUrl { get; set; }\n    }\n\n    public record NextStepResult\n    {\n        public bool Success { get; set; }\n        public string? Error { get; set; }\n        public string? RedirectUrl { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Services/StepMatchingHelper.cs",
      "sha256": "4bd66fa2f33211a05e7a5a3c49de0886ae0859cbb081cacd2f4dd431be005182",
      "language": "csharp",
      "size": 1827,
      "content": "using Serilog;\nusing xbytechat.api.Features.CRM.Models;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\nusing xbytechat.api.Features.Tracking.Models;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Services\n{\n    public static class StepMatchingHelper\n    {\n        public static bool IsStepMatched(CTAFlowStep step, TrackingLog log, Contact? contact)\n        {\n            if (!string.IsNullOrWhiteSpace(step.RequiredSource) &&\n                !string.Equals(step.RequiredSource, log.SourceType, StringComparison.OrdinalIgnoreCase))\n            {\n                Log.Information(\"ðŸš« Step [{StepId}] skipped: RequiredSource '{Required}' â‰  ClickedSource '{Actual}'\",\n                    step.Id, step.RequiredSource, log.SourceType);\n                return false;\n            }\n\n            if (!string.IsNullOrWhiteSpace(step.RequiredTag))\n            {\n                if (contact == null || contact.ContactTags == null || !contact.ContactTags.Any())\n                {\n                    Log.Information(\"ðŸš« Step [{StepId}] skipped: Contact or Tags missing (RequiredTag: {RequiredTag})\",\n                        step.Id, step.RequiredTag);\n                    return false;\n                }\n\n                var hasTag = contact.ContactTags.Any(ct =>\n                    string.Equals(ct.Tag.Name, step.RequiredTag, StringComparison.OrdinalIgnoreCase));\n\n                if (!hasTag)\n                {\n                    var contactTags = string.Join(\", \", contact.ContactTags.Select(ct => ct.Tag.Name));\n                    Log.Information(\"ðŸš« Step [{StepId}] skipped: Contact tags [{Tags}] do not include RequiredTag '{Required}'\",\n                        step.Id, contactTags, step.RequiredTag);\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAManagement/Controllers/CTAManagementController.cs",
      "sha256": "3d06022ca06d6b4e214bf6e571b79d311da0902eeadebddc1f7d48c18a1ecb99",
      "language": "csharp",
      "size": 2535,
      "content": "using Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.CTAManagement.DTOs;\nusing xbytechat.api.Features.CTAManagement.Services;\n\nnamespace xbytechat.api.Features.CTAManagement.Controllers\n{\n    [ApiController]\n    [Route(\"api/ctamanagement\")]\n    [Authorize] // âœ… Ensures only authenticated users can access\n    public class CTAManagementController : ControllerBase\n    {\n        private readonly ICTAManagementService _ctaService;\n\n        public CTAManagementController(ICTAManagementService ctaService)\n        {\n            _ctaService = ctaService;\n        }\n\n        // âœ… GET: api/ctamanagement/get-all\n        [HttpGet(\"get-all\")]\n        public async Task<IActionResult> GetAll()\n        {\n            var data = await _ctaService.GetAllAsync();\n            return Ok(data);\n        }\n\n        // ðŸ“Œ GET: api/ctamanagement/get/{id}\n        [HttpGet(\"get/{id}\")]\n        public async Task<IActionResult> GetById(Guid id)\n        {\n            var result = await _ctaService.GetByIdAsync(id);\n            return result == null ? NotFound(\"CTA not found\") : Ok(result);\n        }\n\n        // âœ… POST: api/ctamanagement/create\n        [HttpPost(\"create\")]\n        public async Task<IActionResult> Create([FromBody] CTADefinitionDto dto)\n        {\n            if (!ModelState.IsValid)\n                return BadRequest(\"âŒ Invalid CTA payload.\");\n\n            var success = await _ctaService.AddAsync(dto);\n            return success\n                ? Ok(new { message = \"âœ… CTA created.\" })\n                : StatusCode(500, \"âŒ Failed to create CTA.\");\n        }\n\n        // âœï¸ PUT: api/ctamanagement/update/{id}\n        [HttpPut(\"update/{id}\")]\n        public async Task<IActionResult> Update(Guid id, [FromBody] CTADefinitionDto dto)\n        {\n            if (!ModelState.IsValid)\n                return BadRequest(\"âŒ Invalid CTA payload.\");\n\n            var success = await _ctaService.UpdateAsync(id, dto);\n            return success\n                ? Ok(new { message = \"âœ… CTA updated.\" })\n                : NotFound(\"CTA not found or update failed.\");\n        }\n\n        // ðŸ—‘ï¸ DELETE: api/ctamanagement/delete/{id}\n        [HttpDelete(\"delete/{id}\")]\n        public async Task<IActionResult> Delete(Guid id)\n        {\n            var success = await _ctaService.DeleteAsync(id);\n            return success\n                ? Ok(new { message = \"âœ… CTA deleted (soft).\" })\n                : NotFound(\"CTA not found or delete failed.\");\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAManagement/DTOs/CTADefinitionDto.cs",
      "sha256": "1472d3694a4cebf363c3a632675fe61b8646f610f7a96a2687286bfb47d8eacf",
      "language": "csharp",
      "size": 707,
      "content": "namespace xbytechat.api.Features.CTAManagement.DTOs\n{\n    public class CTADefinitionDto\n    {\n        public Guid Id { get; set; }\n\n        public string Title { get; set; } = string.Empty; // ðŸ·ï¸ CTA label (e.g., \"Buy Now\")\n\n        public string ButtonText { get; set; } = string.Empty; // ðŸ’¬ Visible button label (e.g., \"Buy Now\")\n\n        public string ButtonType { get; set; } = \"url\"; // ðŸ”˜ Expected values: \"url\", \"quick_reply\", etc.\n\n        public string TargetUrl { get; set; } = string.Empty; // ðŸŒ Redirect or action target\n\n        public string? Description { get; set; } // ðŸ“ Optional description (for context/tooltip)\n\n        public bool IsActive { get; set; } = true;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAManagement/Models/CTADefinition.cs",
      "sha256": "96216798bd31e2098b9a2ba43dac62e067f7062f5e5c36bb318a8dab2f74da38",
      "language": "csharp",
      "size": 913,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CTAManagement.Models\n{\n    public class CTADefinition\n    {\n        public Guid Id { get; set; }\n\n        public Guid BusinessId { get; set; } // ðŸ”— Business that owns this CTA\n\n        public string Title { get; set; } = string.Empty; // ðŸ·ï¸ CTA label/title, e.g., \"Buy Now\"\n\n        public string ButtonText { get; set; } = string.Empty; // ðŸ’¬ Visible button label\n\n        public string ButtonType { get; set; } = \"url\"; // ðŸ”˜ Options: \"url\", \"quick_reply\", etc.\n\n        public string TargetUrl { get; set; } = string.Empty; // ðŸŒ Action URL or value (depending on type)\n\n        public string Description { get; set; } = string.Empty; // ðŸ“ Optional additional context\n\n        public bool IsActive { get; set; } = true;\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n        public DateTime? UpdatedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAManagement/Services/CTAManagementService.cs",
      "sha256": "a9388986726208c45f05afa2bd4ed3c74b33d7d79eb0e5863b7256e061ba4081",
      "language": "csharp",
      "size": 4621,
      "content": "using Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.CTAManagement.DTOs;\nusing xbytechat.api.Features.CTAManagement.Models;\n\nnamespace xbytechat.api.Features.CTAManagement.Services\n{\n    public class CTAManagementService : ICTAManagementService\n    {\n        private readonly AppDbContext _dbContext;\n        private readonly IHttpContextAccessor _httpContextAccessor;\n\n        public CTAManagementService(AppDbContext dbContext, IHttpContextAccessor httpContextAccessor)\n        {\n            _dbContext = dbContext;\n            _httpContextAccessor = httpContextAccessor;\n        }\n\n        // ðŸ”„ Get all active CTAs for the current business\n        public async Task<List<CTADefinitionDto>> GetAllAsync()\n        {\n            var businessId = GetBusinessIdFromClaims();\n\n            return await _dbContext.CTADefinitions\n                .Where(c => c.IsActive && c.BusinessId == businessId)\n                .Select(c => new CTADefinitionDto\n                {\n                    Id = c.Id,\n                    Title = c.Title,\n                    ButtonText = c.ButtonText,\n                    ButtonType = c.ButtonType,\n                    TargetUrl = c.TargetUrl,\n                    Description = c.Description,\n                    IsActive = c.IsActive\n                }).ToListAsync();\n        }\n\n        // âœ… Add new CTA\n        public async Task<bool> AddAsync(CTADefinitionDto dto)\n        {\n            var businessId = GetBusinessIdFromClaims();\n\n            var cta = new CTADefinition\n            {\n                Id = Guid.NewGuid(),\n                BusinessId = businessId,\n                Title = dto.Title,\n                ButtonText = dto.ButtonText,\n                ButtonType = dto.ButtonType,\n                TargetUrl = dto.TargetUrl,\n                Description = dto.Description ?? \"\",\n                IsActive = true,\n                CreatedAt = DateTime.UtcNow\n            };\n\n            await _dbContext.CTADefinitions.AddAsync(cta);\n            await _dbContext.SaveChangesAsync();\n            return true;\n        }\n\n        // ðŸ“Œ Get CTA by ID\n        public async Task<CTADefinitionDto?> GetByIdAsync(Guid id)\n        {\n            var businessId = GetBusinessIdFromClaims();\n\n            var cta = await _dbContext.CTADefinitions\n                .FirstOrDefaultAsync(c => c.Id == id && c.IsActive && c.BusinessId == businessId);\n\n            if (cta == null) return null;\n\n            return new CTADefinitionDto\n            {\n                Id = cta.Id,\n                Title = cta.Title,\n                ButtonText = cta.ButtonText,\n                ButtonType = cta.ButtonType,\n                TargetUrl = cta.TargetUrl,\n                Description = cta.Description,\n                IsActive = cta.IsActive\n            };\n        }\n\n\n        // âœï¸ Update CTA\n        public async Task<bool> UpdateAsync(Guid id, CTADefinitionDto dto)\n        {\n            var cta = await _dbContext.CTADefinitions.FindAsync(id);\n            if (cta == null) return false;\n\n            var businessId = GetBusinessIdFromClaims();\n            if (cta.BusinessId != businessId) throw new UnauthorizedAccessException(\"Unauthorized to modify this CTA.\");\n\n            cta.Title = dto.Title;\n            cta.ButtonText = dto.ButtonText;\n            cta.ButtonType = dto.ButtonType;\n            cta.TargetUrl = dto.TargetUrl;\n            cta.Description = dto.Description ?? \"\";\n            cta.IsActive = dto.IsActive;\n            cta.UpdatedAt = DateTime.UtcNow;\n\n            await _dbContext.SaveChangesAsync();\n            return true;\n        }\n\n        // ðŸ—‘ï¸ Soft Delete CTA\n        public async Task<bool> DeleteAsync(Guid id)\n        {\n            var cta = await _dbContext.CTADefinitions.FindAsync(id);\n            if (cta == null) return false;\n\n            var businessId = GetBusinessIdFromClaims();\n            if (cta.BusinessId != businessId) throw new UnauthorizedAccessException(\"Unauthorized to delete this CTA.\");\n\n            cta.IsActive = false;\n            cta.UpdatedAt = DateTime.UtcNow;\n\n            await _dbContext.SaveChangesAsync();\n            return true;\n        }\n\n        // ðŸ” Reusable method to extract BusinessId\n        private Guid GetBusinessIdFromClaims()\n        {\n            var claim = _httpContextAccessor.HttpContext?.User?.FindFirst(\"businessId\");\n            if (claim == null || string.IsNullOrWhiteSpace(claim.Value) || !Guid.TryParse(claim.Value, out var businessId))\n                throw new UnauthorizedAccessException(\"âŒ Invalid or missing BusinessId claim.\");\n\n            return businessId;\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAManagement/Services/ICTAManagementService.cs",
      "sha256": "f05abf40bdd4a593e8c8f8980c288884dc5701a5c9ba29261588816002758bcd",
      "language": "csharp",
      "size": 814,
      "content": "using xbytechat.api.Features.CTAManagement.DTOs;\n\nnamespace xbytechat.api.Features.CTAManagement.Services\n{\n    public interface ICTAManagementService\n    {\n        /// <summary>Returns all active CTAs for the current business.</summary>\n        Task<List<CTADefinitionDto>> GetAllAsync();\n\n        /// <summary>Returns a single CTA by ID (if exists).</summary>\n        Task<CTADefinitionDto?> GetByIdAsync(Guid id);\n\n        /// <summary>Adds a new CTA for the logged-in business.</summary>\n        Task<bool> AddAsync(CTADefinitionDto dto);\n\n        /// <summary>Updates an existing CTA if it belongs to the business.</summary>\n        Task<bool> UpdateAsync(Guid id, CTADefinitionDto dto);\n\n        /// <summary>Soft deletes (deactivates) a CTA entry.</summary>\n        Task<bool> DeleteAsync(Guid id);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomeApi/Auth/StaticApiKeyOptions.cs",
      "sha256": "ecf8c607a6022271bcd7228448d61a6fc16c9422cd51362b665a875413409fb9",
      "language": "csharp",
      "size": 196,
      "content": "namespace xbytechat.api.Features.CustomeApi.Auth\n{\n    public sealed class StaticApiKeyOptions\n    {\n        public string? Key { get; set; }\n        public Guid? BusinessId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomeApi/Controllers/CustomApiController.cs",
      "sha256": "bfd039e2c624dbefbd14dbaef2d68318799fee81a833094d7bd401b6b1c8a995",
      "language": "csharp",
      "size": 2694,
      "content": "using System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Options;\nusing xbytechat.api.Features.CustomeApi.Auth;\nusing xbytechat.api.Features.CustomeApi.DTOs;\nusing xbytechat.api.Features.CustomeApi.Services;\n\nnamespace xbytechat.api.Features.CustomeApi.Controllers\n{\n    [ApiController]\n    [Route(\"api/custom\")]\n    public sealed class CustomApiController : ControllerBase\n    {\n        private readonly ICustomApiService _service;\n        private readonly StaticApiKeyOptions _api;\n        private readonly CtaJourneyPublisher _journeyPublisher;\n        public CustomApiController(ICustomApiService service, IOptions<StaticApiKeyOptions> api, CtaJourneyPublisher journeyPublisher)\n        {\n            _service = service;\n            _api = api.Value;\n            _journeyPublisher = journeyPublisher;\n        }\n\n        /// <summary>\n        /// Sends a WhatsApp template (optionally with VIDEO header) by phoneNumberId.\n        /// Body: { phoneNumberId, to, templateId, variables:{ \"1\":\"...\" }, videoUrl, flowConfigId }\n        /// </summary>\n        [HttpPost(\"sendflow\")]\n        [Consumes(\"application/json\")]\n        [Produces(\"application/json\")]\n        [ProducesResponseType(typeof(object), 200)]\n        [ProducesResponseType(typeof(object), 400)]\n        [ProducesResponseType(401)]\n        public async Task<IActionResult> SendTemplate([FromBody] DirectTemplateSendRequest req, CancellationToken ct = default)\n        {\n            if (!ModelState.IsValid)\n                return BadRequest(new { success = false, message = \"âŒ Invalid request body.\", errors = ModelState });\n\n            // Minimal shared-secret auth\n            var provided = Request.Headers[\"X-Auth-Key\"].FirstOrDefault()\n                           ?? Request.Headers[\"Authorization\"].FirstOrDefault();\n\n            if (string.IsNullOrWhiteSpace(_api.Key) ||\n                string.IsNullOrWhiteSpace(provided) ||\n                !string.Equals(provided, _api.Key, System.StringComparison.Ordinal))\n            {\n                return Unauthorized(new { success = false, message = \"ðŸ”’ Invalid or missing key.\" });\n            }\n\n            var result = await _service.SendTemplateAsync(req, ct);\n            return result.Success ? Ok(result) : BadRequest(result);\n        }\n        [HttpPost(\"test-webhook\")]\n        public async Task<IActionResult> TestWebhook([FromQuery] Guid businessId, CancellationToken ct)\n        {\n            var (ok, msg) = await _journeyPublisher.ValidateAndPingAsync(businessId, ct);\n            return ok ? Ok(new { ok, message = msg }) : BadRequest(new { ok, message = msg });\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomeApi/Controllers/DevCustomerWebhookConfigController.cs",
      "sha256": "91f4787045211df3c7a8dea1c7dce85901295b74050cad5ddf9c55c6b72f100e",
      "language": "csharp",
      "size": 674,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api;\n\n[ApiController]\n[Route(\"api/getflow\")]\npublic class DevCustomerWebhookConfigController : ControllerBase\n{\n    private readonly AppDbContext _db;\n    public DevCustomerWebhookConfigController(AppDbContext db) => _db = db;\n\n    [HttpGet(\"{businessId:guid}\")]\n    public async Task<IActionResult> Get(Guid businessId)\n    {\n        var cfg = await _db.CustomerWebhookConfigs\n            .AsNoTracking()\n            .FirstOrDefaultAsync(x => x.BusinessId == businessId && x.IsActive);\n        return Ok(cfg is null ? new { found = false } : new { found = true, url = cfg.Url });\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomeApi/DTOs/CtaJourneyEventDto.cs",
      "sha256": "460d6c60802762d203fe59b21a58b49a9cdc29cb9758edb878da461b5bf22f4c",
      "language": "csharp",
      "size": 964,
      "content": "using System.Text.Json.Serialization;\n\nnamespace xbytechat.api.Features.CustomeApi.Models\n{\n    public sealed class CtaJourneyEventDto\n    {\n        // Userâ€™s expected fields (nulls allowed when we donâ€™t have them)\n        public string? userId { get; set; }            // we donâ€™t have this â†’ null\n        public string? userName { get; set; }          // our Contact.ProfileName or Contact.Name\n        public string? userPhone { get; set; }         // digits only\n        public string? botId { get; set; }             // your WA PhoneNumberId or BusinessNumber (see 2.4)\n        public string? categoryBrowsed { get; set; }   // optional, keep null\n        public string? productBrowsed { get; set; }    // optional, keep null\n\n        // REQUIRED by partner: this is the key we must match\n        //public string CTAJourney { get; set; } = string.Empty;\n        [JsonPropertyName(\"CTAJourney\")]\n        public string? CTAJourney { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomeApi/DTOs/DirectTemplateSendRequest.cs",
      "sha256": "d6d17b04a27f1798034ac60813911ab6b34f19e39a5ee69b272d8c88da4f85f1",
      "language": "csharp",
      "size": 2015,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.CustomeApi.DTOs\n{\n    public sealed class DirectTemplateSendRequest\n    {\n        [Required] public string PhoneNumberId { get; set; } = string.Empty;\n        [Required] public string To { get; set; } = string.Empty;\n        [Required] public string TemplateId { get; set; } = string.Empty;\n\n        /// <summary>Body variable map for {{1}}, {{2}}, ...</summary>\n        public Dictionary<string, string>? Variables { get; set; }\n\n        /// <summary>Optional: provide a https .mp4 to attach a VIDEO header.</summary>\n        public string? VideoUrl { get; set; }\n\n        /// <summary>Optional CTA flow to link with this send (for clickâ†’next-step mapping and analytics).</summary>\n        public Guid? FlowConfigId { get; set; }\n    }\n}\n\n\n//using System; // <-- needed for Guid\n//using System.Collections.Generic;\n//using System.ComponentModel.DataAnnotations;\n\n//namespace xbytechat.api.Features.CustomeApi.DTOs\n//{\n//    public sealed class DirectTemplateSendRequest\n//    {\n//        [Required] public string PhoneNumberId { get; set; } = string.Empty;\n//        [Required] public string To { get; set; } = string.Empty;\n//        [Required] public string TemplateId { get; set; } = string.Empty;\n\n//        // Optional: start (link) a CTA flow on this send (we'll stamp CTAFlowConfigId/StepId on MessageLog)\n//        public Guid? FlowConfigId { get; set; }   // <---- add this\n\n//        // Body variables as WhatsApp {{1}}, {{2}}, ...\n//        public Dictionary<string, string>? Variables { get; set; }\n\n//        // Optional header media, validated based on template header type:\n//        public string? ImageUrl { get; set; } // IMAGE header\n//        public string? VideoUrl { get; set; } // VIDEO header\n//        public string? DocumentUrl { get; set; } // DOCUMENT/PDF header\n//        public string? DocumentFilename { get; set; } // optional nice filename\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomeApi/DTOs/DirectTemplateSendRequestValidator.cs",
      "sha256": "613a944117e95f84b8286c1d19d3945f5d54eb046324aba873d203a3893ec584",
      "language": "csharp",
      "size": 629,
      "content": "using FluentValidation;\n\nnamespace xbytechat.api.Features.CustomeApi.DTOs\n{\n    public sealed class DirectTemplateSendRequestValidator : AbstractValidator<DirectTemplateSendRequest>\n    {\n        public DirectTemplateSendRequestValidator()\n        {\n            RuleFor(x => x.PhoneNumberId).NotEmpty().WithMessage(\"phoneNumberId is required.\");\n            RuleFor(x => x.To).NotEmpty().WithMessage(\"'to' (recipient) is required.\");\n            RuleFor(x => x.TemplateId).NotEmpty().WithMessage(\"templateId is required.\");\n            // videoUrl required only if template header == VIDEO (checked in service)\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomeApi/Models/ContactJourneyState.cs",
      "sha256": "133720f1453770ad09bd2c9bd2551f343f20df6ce27a0b88a2a7234a20e3157c",
      "language": "csharp",
      "size": 1101,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing Microsoft.EntityFrameworkCore;\n\nnamespace xbytechat.api.Features.CustomeApi.Models\n{\n    // One row per (business, flow, contact). Enforce single row via unique index.\n    [Index(nameof(BusinessId), nameof(FlowId), nameof(ContactPhone), IsUnique = true)]\n    public class ContactJourneyState\n    {\n        [Key] public Guid Id { get; set; }\n\n        [Required] public Guid BusinessId { get; set; }\n\n        [Required] public Guid FlowId { get; set; }\n\n        // Store digits-only (same as your click processor does).\n        [Required, MaxLength(32)]\n        public string ContactPhone { get; set; } = default!;\n\n        // Running journey like: \"Yes/No/Bahut Achha\"\n        [Required] public string JourneyText { get; set; } = string.Empty;\n\n        public int ClickCount { get; set; } = 0;\n\n        [MaxLength(256)]\n        public string? LastButtonText { get; set; }\n\n        [Required] public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n        [Required] public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomeApi/Models/CustomerWebhookConfig.cs",
      "sha256": "c08fa705d23cd231999b48da0668ec8e9aef6db72aec24a10a7c583ee7db94e4",
      "language": "csharp",
      "size": 693,
      "content": "using System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.CustomeApi.Models\n{\n    public class CustomerWebhookConfig\n    {\n        [Key] public Guid Id { get; set; }\n\n        [Required] public Guid BusinessId { get; set; }\n\n        [Required, MaxLength(1024)]\n        public string Url { get; set; } = default!;  // customer API endpoint to receive CTAJourney\n\n        [MaxLength(2048)]\n        public string? BearerToken { get; set; }     // optional \"Authorization: Bearer <token>\"\n\n        public bool IsActive { get; set; } = true;\n\n        [Required] public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n        public DateTime? UpdatedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomeApi/Services/CtaJourneyMapper.cs",
      "sha256": "6a97ebadd1575997d1bd2a675cfde50b63361d45137b66242e90672084bc21b5",
      "language": "csharp",
      "size": 1719,
      "content": "using System.Text.RegularExpressions;\nusing xbytechat.api.Features.CRM.Models;\n\nnamespace xbytechat.api.Features.CustomeApi.Services\n{\n    public static class CtaJourneyMapper\n    {\n        private static string Digits(string? s) =>\n            string.IsNullOrWhiteSpace(s) ? \"\" : Regex.Replace(s, \"[^0-9]\", \"\");\n\n    \n        public static Models.CtaJourneyEventDto Build(\n            string journeyKey,          // REQUIRED -> \"product_view_to_interest\" (your must-match)\n            Contact? contact = null,\n            string? profileName = null,\n            string? userId = null,      // we donâ€™t have: pass null\n            string? phoneNumberId = null,   // Meta phone_number_id\n            string? businessDisplayPhone = null, // WhatsAppBusinessNumber\n            string? categoryBrowsed = null,\n            string? productBrowsed = null\n        )\n        {\n            // Choose botId priority: phoneNumberId (Meta) -> business WA number -> null\n            var botId = !string.IsNullOrWhiteSpace(phoneNumberId)\n                ? phoneNumberId!.Trim()\n                : (!string.IsNullOrWhiteSpace(businessDisplayPhone) ? Digits(businessDisplayPhone) : null);\n\n            return new Models.CtaJourneyEventDto\n            {\n                userId = userId, // normally null (we donâ€™t store)\n                userName = profileName ?? contact?.ProfileName ?? contact?.Name,\n                userPhone = Digits(contact?.PhoneNumber),\n                botId = botId,\n                categoryBrowsed = categoryBrowsed,   // keep null \n                productBrowsed = productBrowsed,     // keep null \n                CTAJourney = journeyKey               // e.g. \"Button Name\"\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomeApi/Services/CtaJourneyPublisher.cs",
      "sha256": "d6cc88d790dc147459324a25a78082d154f457abec1fd7011683edc9e77994b9",
      "language": "csharp",
      "size": 13867,
      "content": "using System;\nusing System.Linq;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Text;\nusing System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\n\nnamespace xbytechat.api.Features.CustomeApi.Services\n{\n    public class CtaJourneyPublisher : ICtaJourneyPublisher\n    {\n        private readonly AppDbContext _db;\n        private readonly IHttpClientFactory _httpFactory;\n        private readonly ILogger<CtaJourneyPublisher> _log;\n\n        private static readonly JsonSerializerOptions _json = new(JsonSerializerDefaults.Web);\n\n        public CtaJourneyPublisher(\n            AppDbContext db,\n            IHttpClientFactory httpFactory,\n            ILogger<CtaJourneyPublisher> log)\n        {\n            _db = db;\n            _httpFactory = httpFactory;\n            _log = log;\n        }\n\n        public async Task PublishAsync(Guid businessId, Models.CtaJourneyEventDto dto, CancellationToken ct = default)\n        {\n            // Load all active endpoints (only for this one customer right now)\n            var endpoints = await _db.CustomerWebhookConfigs\n                .AsNoTracking()\n                .Where(x => x.BusinessId == businessId && x.IsActive)\n                .ToListAsync(ct);\n\n            if (endpoints.Count == 0)\n            {\n                _log.LogInformation(\"CTA Journey: no active endpoints for business {Biz}\", businessId);\n                return;\n            }\n\n            var client = _httpFactory.CreateClient(\"customapi-webhooks\"); // registered in DI\n\n            foreach (var ep in endpoints)\n            {\n                // Serialize once per endpoint\n                var body = JsonSerializer.Serialize(dto, _json);\n\n                const int maxAttempts = 3;\n                for (int attempt = 1; attempt <= maxAttempts; attempt++)\n                {\n                    try\n                    {\n                        using var req = new HttpRequestMessage(HttpMethod.Post, ep.Url)\n                        {\n                            Content = new StringContent(body, Encoding.UTF8, \"application/json\")\n                        };\n\n                        if (!string.IsNullOrWhiteSpace(ep.BearerToken))\n                            req.Headers.Authorization = new AuthenticationHeaderValue(\"Bearer\", ep.BearerToken);\n\n                        var resp = await client.SendAsync(req, ct);\n                        var code = (int)resp.StatusCode;\n\n                        if (code >= 200 && code < 300)\n                        {\n                            _log.LogInformation(\"CTA Journey posted to {Url} | {Status}\", ep.Url, code);\n                            break; // success; stop retrying this endpoint\n                        }\n\n                        var errText = await resp.Content.ReadAsStringAsync(ct);\n                        _log.LogWarning(\"CTA Journey post failed ({Code}) to {Url}: {Body}\", code, ep.Url, errText);\n\n                        if (attempt == maxAttempts) break;\n                        await Task.Delay(TimeSpan.FromSeconds(2 * attempt), ct); // 2s, 4s backoff\n                    }\n                    catch (Exception ex)\n                    {\n                        _log.LogWarning(ex, \"CTA Journey post exception to {Url} (attempt {Attempt})\", ep.Url, attempt);\n                        if (attempt == maxAttempts) break;\n                        await Task.Delay(TimeSpan.FromSeconds(2 * attempt), ct);\n                    }\n                }\n            }\n        }\n\n        public async Task<(bool ok, string message)> ValidateAndPingAsync(Guid businessId, CancellationToken ct = default)\n        {\n            var ep = await _db.CustomerWebhookConfigs\n                .AsNoTracking()\n                .Where(x => x.BusinessId == businessId && x.IsActive)\n                .OrderByDescending(x => x.UpdatedAt ?? x.CreatedAt)\n                .FirstOrDefaultAsync(ct);\n\n            if (ep == null) return (false, \"No active CustomerWebhookConfig found for this business.\");\n            if (string.IsNullOrWhiteSpace(ep.Url)) return (false, \"Endpoint URL is empty.\");\n            if (!Uri.TryCreate(ep.Url, UriKind.Absolute, out var uri) || uri.Scheme != Uri.UriSchemeHttps)\n                return (false, \"Endpoint URL must be an absolute https URL.\");\n\n            var probe = new Models.CtaJourneyEventDto\n            {\n                userId = null,\n                userName = \"probe\",\n                userPhone = \"0000000000\",\n                botId = \"0000000000\",\n                categoryBrowsed = null,\n                productBrowsed = null,\n                CTAJourney = \"probe_to_probe\"\n            };\n\n            var client = _httpFactory.CreateClient(\"customapi-webhooks\");\n            var body = JsonSerializer.Serialize(probe, _json);\n\n            using var req = new HttpRequestMessage(HttpMethod.Post, ep.Url)\n            {\n                Content = new StringContent(body, Encoding.UTF8, \"application/json\")\n            };\n\n            req.Headers.TryAddWithoutValidation(\"X-XBS-Test\", \"1\");\n\n            if (!string.IsNullOrWhiteSpace(ep.BearerToken))\n                req.Headers.Authorization = new AuthenticationHeaderValue(\"Bearer\", ep.BearerToken);\n\n            try\n            {\n                var resp = await client.SendAsync(req, ct);\n                var code = (int)resp.StatusCode;\n\n                if (code >= 200 && code < 300) return (true, $\"OK ({code})\");\n\n                var text = await resp.Content.ReadAsStringAsync(ct);\n                return (false, $\"HTTP {code}: {text}\");\n            }\n            catch (Exception ex)\n            {\n                return (false, $\"Exception: {ex.Message}\");\n            }\n        }\n    }\n}\n\n\n//using System;\n//using System.Linq;\n//using System.Net.Http;\n//using System.Net.Http.Headers;\n//using System.Text;\n//using System.Text.Json;\n//using System.Threading;\n//using System.Threading.Tasks;\n//using Microsoft.EntityFrameworkCore;\n//using Microsoft.Extensions.Logging;\n\n//namespace xbytechat.api.Features.CustomeApi.Services\n//{\n//    public class CtaJourneyPublisher : ICtaJourneyPublisher\n//    {\n//        private readonly AppDbContext _db;\n//        private readonly IHttpClientFactory _httpFactory;\n//        private readonly ILogger<CtaJourneyPublisher> _log;\n\n//        private static readonly JsonSerializerOptions _json =\n//            new(JsonSerializerDefaults.Web);\n\n//        public CtaJourneyPublisher(AppDbContext db, IHttpClientFactory httpFactory, ILogger<CtaJourneyPublisher> log)\n//        {\n//            _db = db;\n//            _httpFactory = httpFactory;\n//            _log = log;\n//        }\n\n\n//        public async Task PublishAsync(Guid businessId, Models.CtaJourneyEventDto dto, CancellationToken ct = default)\n//        {\n//            // load all active endpoints (only for this one customer right now)\n//            var endpoints = await _db.CustomerWebhookConfigs\n//                .AsNoTracking()\n//                .Where(x => x.BusinessId == businessId && x.IsActive)\n//                .ToListAsync(ct);\n\n//            if (endpoints.Count == 0)\n//            {\n//                _log.LogInformation(\"CTA Journey: no active endpoints for business {Biz}\", businessId);\n//                return;\n//            }\n\n//            var client = _httpFactory.CreateClient(\"customapi-webhooks\"); // registered in DI\n//            var body = JsonSerializer.Serialize(dto, _json);\n//            using var content = new StringContent(body, Encoding.UTF8, \"application/json\");\n//            foreach (var ep in endpoints)\n//            {\n//                // simple retry (3 attempts, 2s/4s backoff)\n//                const int maxAttempts = 3;\n//                for (int attempt = 1; attempt <= maxAttempts; attempt++)\n//                {\n//                    try\n//                    {\n//                        using var req = new HttpRequestMessage(HttpMethod.Post, ep.Url)\n//                        {\n//                            Content = new StringContent(\n//                                JsonSerializer.Serialize(dto, _json),   // fresh content every send\n//                                Encoding.UTF8,\n//                                \"application/json\")\n//                        };\n\n//                        if (!string.IsNullOrWhiteSpace(ep.BearerToken))\n//                            req.Headers.Authorization = new AuthenticationHeaderValue(\"Bearer\", ep.BearerToken);\n\n//                        var resp = await client.SendAsync(req, ct);\n//                        if ((int)resp.StatusCode >= 200 && (int)resp.StatusCode < 300)\n//                        {\n//                            _log.LogInformation(\"CTA Journey posted to {Url} | {Status}\", ep.Url, (int)resp.StatusCode);\n//                            break;\n//                        }\n\n//                        var bodyText = await resp.Content.ReadAsStringAsync(ct);\n//                        _log.LogWarning(\"CTA Journey post failed ({Code}) to {Url}: {Body}\",\n//                            (int)resp.StatusCode, ep.Url, bodyText);\n\n//                        if (attempt == maxAttempts) break;\n//                        await Task.Delay(TimeSpan.FromSeconds(2 * attempt), ct);\n//                    }\n//                    catch (Exception ex)\n//                    {\n//                        _log.LogWarning(ex, \"CTA Journey post exception to {Url} (attempt {Attempt})\", ep.Url, attempt);\n//                        if (attempt == maxAttempts) break;\n//                        await Task.Delay(TimeSpan.FromSeconds(2 * attempt), ct);\n//                    }\n//                }\n//            }\n\n//            //foreach (var ep in endpoints)\n//            //{\n//            //    using var req = new HttpRequestMessage(HttpMethod.Post, ep.Url) { Content = content };\n\n//            //    // optional Bearer only (we're keeping it simple)\n//            //    if (!string.IsNullOrWhiteSpace(ep.BearerToken))\n//            //        req.Headers.Authorization = new AuthenticationHeaderValue(\"Bearer\", ep.BearerToken);\n\n//            //    // simple retry (3 attempts, 2s/4s backoff)\n//            //    const int maxAttempts = 3;\n//            //    for (int attempt = 1; attempt <= maxAttempts; attempt++)\n//            //    {\n//            //        try\n//            //        {\n//            //            var resp = await client.SendAsync(req, ct);\n//            //            if ((int)resp.StatusCode >= 200 && (int)resp.StatusCode < 300)\n//            //            {\n//            //                _log.LogInformation(\"CTA Journey posted to {Url} | {Status}\", ep.Url, (int)resp.StatusCode);\n//            //                break;\n//            //            }\n\n//            //            var bodyText = await resp.Content.ReadAsStringAsync(ct);\n//            //            _log.LogWarning(\"CTA Journey post failed ({Code}) to {Url}: {Body}\",\n//            //                (int)resp.StatusCode, ep.Url, bodyText);\n\n//            //            if (attempt == maxAttempts) break;\n//            //            await Task.Delay(TimeSpan.FromSeconds(2 * attempt), ct);\n//            //        }\n//            //        catch (Exception ex)\n//            //        {\n//            //            _log.LogWarning(ex, \"CTA Journey post exception to {Url} (attempt {Attempt})\", ep.Url, attempt);\n//            //            if (attempt == maxAttempts) break;\n//            //            await Task.Delay(TimeSpan.FromSeconds(2 * attempt), ct);\n//            //        }\n//            //    }\n//            //}\n//        }\n//        public async Task<(bool ok, string message)> ValidateAndPingAsync(Guid businessId, CancellationToken ct = default)\n//        {\n//            var ep = await _db.CustomerWebhookConfigs\n//                .AsNoTracking()\n//                .Where(x => x.BusinessId == businessId && x.IsActive)\n//                .OrderByDescending(x => x.UpdatedAt ?? x.CreatedAt)\n//                .FirstOrDefaultAsync(ct);\n\n//            if (ep == null) return (false, \"No active CustomerWebhookConfig found for this business.\");\n//            if (string.IsNullOrWhiteSpace(ep.Url)) return (false, \"Endpoint URL is empty.\");\n//            if (!Uri.TryCreate(ep.Url, UriKind.Absolute, out var uri) || uri.Scheme != Uri.UriSchemeHttps)\n//                return (false, \"Endpoint URL must be an absolute https URL.\");\n\n//            var probe = new Models.CtaJourneyEventDto\n//            {\n//                userId = null,\n//                userName = \"probe\",\n//                userPhone = \"0000000000\",\n//                botId = \"0000000000\",\n//                categoryBrowsed = null,\n//                productBrowsed = null,\n//                CTAJourney = \"probe_to_probe\"\n//            };\n\n//            var client = _httpFactory.CreateClient(\"customapi-webhooks\");\n//            var body = JsonSerializer.Serialize(probe, _json);\n\n//            using var req = new HttpRequestMessage(HttpMethod.Post, ep.Url)\n//            {\n//                Content = new StringContent(body, Encoding.UTF8, \"application/json\")\n//            };\n//            req.Headers.TryAddWithoutValidation(\"X-XBS-Test\", \"1\");\n\n//            if (!string.IsNullOrWhiteSpace(ep.BearerToken))\n//                req.Headers.Authorization = new AuthenticationHeaderValue(\"Bearer\", ep.BearerToken);\n\n//            try\n//            {\n//                var resp = await client.SendAsync(req, ct);\n//                var code = (int)resp.StatusCode;\n//                if (code >= 200 && code < 300) return (true, $\"OK ({code})\");\n//                var text = await resp.Content.ReadAsStringAsync(ct);\n//                return (false, $\"HTTP {code}: {text}\");\n//            }\n//            catch (Exception ex)\n//            {\n//                return (false, $\"Exception: {ex.Message}\");\n//            }\n//        }\n\n//    }\n//}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CustomeApi/Services/CustomApiService.cs",
      "sha256": "78a7353f5a8e6c720e2640c507df52730cd9b75e8803abe3590bf51c67a63259",
      "language": "csharp",
      "size": 27860,
      "content": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Newtonsoft.Json; \nusing xbytechat.api.Features.CustomeApi.DTOs;\nusing xbytechat.api.Features.MessagesEngine.Services;                       \nusing xbytechat_api.Features.Billing.Services;\nusing xbytechat_api.WhatsAppSettings.Services;\nusing xbytechat.api.Helpers;\nusing System.Text.RegularExpressions;      \n\nnamespace xbytechat.api.Features.CustomeApi.Services\n{\n    public sealed class CustomApiService : ICustomApiService\n    {\n        private readonly AppDbContext _context;\n        private readonly IWhatsAppTemplateFetcherService _templateFetcher;\n        private readonly IMessageEngineService _messageEngine;\n        private readonly IBillingIngestService _billingIngest;\n        private readonly ILogger<CustomApiService> _logger;\n\n        public CustomApiService(\n            AppDbContext context,\n            IWhatsAppTemplateFetcherService templateFetcher,\n            IMessageEngineService messageEngine,\n            IBillingIngestService billingIngest,\n            ILogger<CustomApiService> logger)\n        {\n            _context = context;\n            _templateFetcher = templateFetcher;\n            _messageEngine = messageEngine;\n            _billingIngest = billingIngest;\n            _logger = logger;\n        }\n\n        public async Task<ResponseResult> SendTemplateAsync(DirectTemplateSendRequest req, CancellationToken ct = default)\n        {\n            try\n            {\n                var toNormalized = NormalizePhone(req.To);\n                var reqId = Guid.NewGuid();\n\n                // 1) Resolve WhatsApp sender by phoneNumberId (across all businesses)\n                //var ws = await _context.WhatsAppPhoneNumbers.AsNoTracking()\n                //    .Where(s => s.IsActive && s.PhoneNumberId == req.PhoneNumberId)\n                //    .OrderByDescending(s => s.UpdatedAt ?? s.CreatedAt)\n                //    .FirstOrDefaultAsync(ct);\n\n                var ws = await _context.WhatsAppPhoneNumbers.AsNoTracking()\n                    .Where(s =>  s.IsActive && s.PhoneNumberId == req.PhoneNumberId)\n                    .OrderByDescending(s => s.UpdatedAt ?? s.CreatedAt)\n                   .FirstOrDefaultAsync(ct);\n\n\n\n                if (ws == null)\n                    return ResponseResult.ErrorInfo(\"âŒ Active WhatsApp sender (phoneNumberId) not found.\");\n\n                var businessId = ws.BusinessId;\n                var provider = (ws.Provider ?? \"\").Trim().ToUpperInvariant(); // \"META_CLOUD\" | \"PINNACLE\"\n                if (provider != \"META_CLOUD\" && provider != \"PINNACLE\")\n                    return ResponseResult.ErrorInfo($\"âŒ Unsupported provider: {provider}\");\n\n                _logger.LogInformation(\n                    \"[CustomAPI:{ReqId}] Begin send. biz={BusinessId} pnid={PhoneNumberId} to={MaskedTo} template={TemplateId}\",\n                    reqId, businessId, req.PhoneNumberId, Mask(toNormalized), req.TemplateId);\n\n                // 2) Fetch template meta (for language + buttons)\n                var meta = await _templateFetcher.GetTemplateByNameAsync(businessId, req.TemplateId, includeButtons: true);\n                if (meta == null)\n                    return ResponseResult.ErrorInfo(\"âŒ Template metadata not found for the given templateId.\");\n\n                var languageCode = (meta.Language ?? \"\").Trim();\n                if (string.IsNullOrWhiteSpace(languageCode))\n                    return ResponseResult.ErrorInfo(\"âŒ Template language not resolved from provider metadata.\");\n\n                // 3) Header decision\n                var isVideoHeader = !string.IsNullOrWhiteSpace(req.VideoUrl);\n                if (isVideoHeader && !IsHttpsMp4Url(req.VideoUrl, out var vErr))\n                    return ResponseResult.ErrorInfo(\"ðŸš« Invalid VideoUrl.\", vErr);\n\n                // 4) Build components\n                var (components, whyBuildFail) = BuildComponents(isVideoHeader, req.Variables, req.VideoUrl);\n                if (components == null)\n                {\n                    _logger.LogWarning(\"[CustomAPI:{ReqId}] Component build failed: {Err}\", reqId, whyBuildFail);\n                    return ResponseResult.ErrorInfo($\"ðŸš« Component build failed: {whyBuildFail}\");\n                }\n\n                // 5) Snapshot first 3 buttons (optional analytics)\n                string? buttonBundleJson = null;\n                try\n                {\n                    if (meta.ButtonParams is { Count: > 0 })\n                    {\n                        var bundle = meta.ButtonParams.Take(3)\n                            .Select((b, i) => new\n                            {\n                                i,\n                                position = i + 1,\n                                text = (b.Text ?? \"\").Trim(),\n                                type = b.Type,\n                                subType = b.SubType\n                            }).ToList();\n                        buttonBundleJson = JsonConvert.SerializeObject(bundle);\n                    }\n                }\n                catch { /* best-effort snapshot */ }\n\n                // 6) Entry step for linked flow (optional)\n                Guid? entryStepId = null;\n                if (req.FlowConfigId.HasValue)\n                {\n                    entryStepId = await _context.CTAFlowSteps\n                        .Where(s => s.CTAFlowConfigId == req.FlowConfigId.Value)\n                        .OrderBy(s => s.StepOrder)\n                        .Select(s => (Guid?)s.Id)\n                        .FirstOrDefaultAsync(ct);\n                }\n\n                // 7) Build provider payload\n                var languageField = new { policy = \"deterministic\", code = string.IsNullOrWhiteSpace(languageCode) ? \"en_US\" : languageCode };\n                var payload = new\n                {\n                    messaging_product = \"whatsapp\",\n                    to = toNormalized,\n                    type = \"template\",\n                    template = new\n                    {\n                        name = req.TemplateId,\n                        language = languageField,\n                        components\n                    }\n                };\n\n                _logger.LogInformation(\"[CustomAPI:{ReqId}] Sending {Template} to {To} via {Provider} (PNID={PNID}) video={Video}\",\n                    reqId, req.TemplateId, Mask(toNormalized), provider, req.PhoneNumberId, isVideoHeader);\n\n                // 8) Send\n                var result = await _messageEngine.SendPayloadAsync(\n                    businessId: businessId,\n                    provider: provider,\n                    payload: payload,\n                    phoneNumberId: req.PhoneNumberId\n                );\n\n                // 9) Log + billing\n                var now = DateTime.UtcNow;\n                var logId = Guid.NewGuid();\n\n                _context.MessageLogs.Add(new MessageLog\n                {\n                    Id = logId,\n                    BusinessId = businessId,\n                    CampaignId = null,\n                    RecipientNumber = toNormalized,\n                    MessageContent = req.TemplateId,\n                    MediaUrl = isVideoHeader ? req.VideoUrl : null,\n                    Status = result.Success ? \"Sent\" : \"Failed\",\n                    MessageId = result.MessageId,          // or just ProviderMessageId; keep one if you want to de-dup\n                    ProviderMessageId = result.MessageId,\n                    ErrorMessage = result.ErrorMessage,\n                    RawResponse = result.RawResponse,\n                    CreatedAt = now,\n                    SentAt = result.Success ? now : (DateTime?)null,\n                    Source = \"custom_api\",\n                    Provider = provider,\n                    CTAFlowConfigId = req.FlowConfigId,\n                    CTAFlowStepId = entryStepId,\n                    ButtonBundleJson = buttonBundleJson\n                });\n\n                await _context.SaveChangesAsync(ct);\n\n                await _billingIngest.IngestFromSendResponseAsync(\n                    businessId: businessId,\n                    messageLogId: logId,\n                    provider: provider,\n                    rawResponseJson: result.RawResponse ?? \"{}\"\n                );\n\n                _logger.LogInformation(\"[CustomAPI:{ReqId}] Done. success={Success} msgId={MessageId} flow={Flow} step={Step}\",\n                    reqId, result.Success, result.MessageId, req.FlowConfigId, entryStepId);\n\n                return result.Success\n                    ? ResponseResult.SuccessInfo(\"ðŸš€ Template sent.\",\n                        new\n                        {\n                            messageId = result.MessageId,\n                            to = toNormalized,\n                            templateId = req.TemplateId,\n                            flowConfigId = req.FlowConfigId,\n                            flowEntryStepId = entryStepId\n                        })\n                    : ResponseResult.ErrorInfo(\"âŒ Send failed.\", result.ErrorMessage);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"âŒ Exception in CustomApiService.SendTemplateAsync\");\n                return ResponseResult.ErrorInfo(\"ðŸš¨ Server error while sending template.\", ex.ToString());\n            }\n        }\n\n        // ===== helpers (unchanged) =====\n        private static string NormalizePhone(string raw) => raw.StartsWith(\"+\") ? raw[1..] : raw;\n        private static string Mask(string phone) => phone.Length <= 6 ? phone : $\"{new string('*', phone.Length - 4)}{phone[^4..]}\";\n        private static bool IsHttpsMp4Url(string? url, out string? err)\n        {\n            err = null;\n            if (string.IsNullOrWhiteSpace(url)) { err = \"VideoUrl is required when sending a VIDEO header.\"; return false; }\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var u)) { err = \"VideoUrl must be an absolute URL.\"; return false; }\n            if (u.Scheme != Uri.UriSchemeHttps) { err = \"VideoUrl must be HTTPS.\"; return false; }\n            if (!u.AbsolutePath.EndsWith(\".mp4\", StringComparison.OrdinalIgnoreCase)) { err = \"VideoUrl must point to an .mp4 file.\"; return false; }\n            return true;\n        }\n        //private static (List<object>? components, string? whyFail) BuildComponents(bool addVideoHeader, Dictionary<string, string>? variables, string? videoUrl)\n        //{\n        //    try\n        //    {\n        //        var components = new List<object>();\n        //        if (addVideoHeader)\n        //        {\n        //            components.Add(new\n        //            {\n        //                type = \"header\",\n        //                parameters = new object[] { new { type = \"video\", video = new { link = videoUrl } } }\n        //            });\n        //        }\n        //        if (variables is { Count: > 0 })\n        //        {\n        //            var bodyParams = variables\n        //                .Select(kv => (Index: int.TryParse(kv.Key, out var n) ? n : int.MaxValue, Text: kv.Value ?? string.Empty))\n        //                .OrderBy(x => x.Index)\n        //                .Select(x => new { type = \"text\", text = x.Text })\n        //                .ToArray();\n\n        //            if (bodyParams.Length > 0)\n        //                components.Add(new { type = \"body\", parameters = bodyParams });\n        //        }\n        //        return (components, null);\n        //    }\n        //    catch (Exception ex) { return (null, ex.Message); }\n        //}\n        private static (List<object>? components, string? whyFail) BuildComponents(\n         bool addVideoHeader,\n         Dictionary<string, string>? variables,\n         string? videoUrl)\n        {\n            try\n            {\n                var components = new List<object>();\n\n                // Header (optional video)\n                if (addVideoHeader)\n                {\n                    components.Add(new\n                    {\n                        type = \"header\",\n                        parameters = new object[]\n                        {\n                    new { type = \"video\", video = new { link = videoUrl } }\n                        }\n                    });\n                }\n\n                // Body params ({{1}}, {{2}}, ...) â€” tolerate keys like \"1\", \"2\", \"para1\", \"foo2\"\n                if (variables is { Count: > 0 })\n                {\n                    var list = variables.ToList(); // preserves insertion order for non-numbered keys\n\n                    var bodyParams = list\n                        .Select((kv, idx) =>\n                        {\n                            var m = Regex.Match(kv.Key ?? string.Empty, @\"\\d+\");\n\n                            int n = 0; // declare first so it's always definitely assigned\n                            bool hasNum = m.Success && int.TryParse(m.Value, out n) && n > 0;\n\n                            // Numbered keys come first ordered by n; others follow in insertion order\n                            int orderKey = hasNum ? n : int.MaxValue - (list.Count - idx);\n\n                            return new { Order = orderKey, Text = kv.Value ?? string.Empty };\n                        })\n                        .OrderBy(x => x.Order)\n                        .Select(x => new { type = \"text\", text = x.Text })\n                        .ToArray();\n\n                    if (bodyParams.Length > 0)\n                        components.Add(new { type = \"body\", parameters = bodyParams });\n                }\n\n\n                return (components, null);\n            }\n            catch (Exception ex)\n            {\n                return (null, ex.Message);\n            }\n        }\n\n\n    }\n}\n\n//using System;\n//using System.Linq;\n//using System.Collections.Generic;\n//using System.Security.Claims;\n//using System.Threading;\n//using System.Threading.Tasks;\n//using Microsoft.EntityFrameworkCore;\n//using Microsoft.Extensions.Logging;\n//using Microsoft.AspNetCore.Http;\n//using Newtonsoft.Json;\n//using xbytechat.api.Features.CustomeApi.DTOs;\n//using xbytechat.api.Features.MessagesEngine.Services; // IMessageEngineService\n//using xbytechat.api.Features.TemplateModule.Services; // IWhatsAppTemplateFetcherService\n//using xbytechat.api.Models;                         // MessageLog\n//using xbytechat.api.Shared;                         // ResponseResult\n//using xbytechat_api.Features.Billing.Services;\n//using xbytechat.api.Helpers;      // IBillingIngestService\n//using xbytechat.api.WhatsAppSettings;\n//using xbytechat_api.WhatsAppSettings.Services;\n//namespace xbytechat.api.Features.CustomeApi.Services\n//{\n//    public sealed class CustomApiService : ICustomApiService\n//    {\n//        private readonly AppDbContext _context;\n//        private readonly IHttpContextAccessor _http;\n//        private readonly IWhatsAppTemplateFetcherService _templateFetcher;\n//        private readonly IMessageEngineService _messageEngine;\n//        private readonly IBillingIngestService _billingIngest;\n//        private readonly ILogger<CustomApiService> _logger;\n\n//        public CustomApiService(\n//            AppDbContext context,\n//            IHttpContextAccessor http,\n//            IWhatsAppTemplateFetcherService templateFetcher,\n//            IMessageEngineService messageEngine,\n//            IBillingIngestService billingIngest,\n//            ILogger<CustomApiService> logger)\n//        {\n//            _context = context;\n//            _http = http;\n//            _templateFetcher = templateFetcher;\n//            _messageEngine = messageEngine;\n//            _billingIngest = billingIngest;\n//            _logger = logger;\n//        }\n\n//        public async Task<ResponseResult> SendTemplateAsync(DirectTemplateSendRequest req, CancellationToken ct = default)\n//        {\n//            try\n//            {\n//                // --- 0) Basic validation\n//                if (string.IsNullOrWhiteSpace(req.PhoneNumberId))\n//                    return ResponseResult.ErrorInfo(\"âŒ phoneNumberId is required.\");\n//                if (string.IsNullOrWhiteSpace(req.To))\n//                    return ResponseResult.ErrorInfo(\"âŒ 'to' (recipient) is required.\");\n//                if (string.IsNullOrWhiteSpace(req.TemplateId))\n//                    return ResponseResult.ErrorInfo(\"âŒ templateId is required.\");\n\n//                var businessId = GetBusinessIdOrThrow();\n//                var toNormalized = NormalizePhone(req.To);\n\n//                var reqId = Guid.NewGuid();\n//                _logger.LogInformation(\n//                    \"[CustomAPI:{ReqId}] Begin send. biz={BusinessId} pnid={PhoneNumberId} to={MaskedTo} template={TemplateId}\",\n//                    reqId, businessId, req.PhoneNumberId, Mask(toNormalized), req.TemplateId);\n\n//                // --- 1) Resolve provider by phoneNumberId for this Business\n//                var ws = await _context.WhatsAppSettings.AsNoTracking()\n//                    .Where(s => s.BusinessId == businessId && s.IsActive && s.PhoneNumberId == req.PhoneNumberId)\n//                    .OrderByDescending(s => s.UpdatedAt ?? s.CreatedAt)\n//                    .FirstOrDefaultAsync(ct);\n\n//                if (ws == null)\n//                    return ResponseResult.ErrorInfo(\"âŒ Active WhatsApp sender (phoneNumberId) not found for this Business.\");\n\n//                var provider = (ws.Provider ?? \"\").Trim().ToUpperInvariant(); // \"META_CLOUD\" | \"PINNACLE\"\n//                if (provider != \"META_CLOUD\" && provider != \"PINNACLE\")\n//                    return ResponseResult.ErrorInfo($\"âŒ Unsupported provider configured for this sender: {provider}\");\n\n//                // --- 2) Fetch template meta\n//                // NOTE: your metadata doesn't expose HeaderType; we just read language & buttons. \n//                var meta = await _templateFetcher.GetTemplateByNameAsync(businessId, req.TemplateId, includeButtons: true);\n//                if (meta == null)\n//                    return ResponseResult.ErrorInfo(\"âŒ Template metadata not found for the given templateId.\");\n\n//                var languageCode = (meta.Language ?? \"\").Trim();\n//                if (string.IsNullOrWhiteSpace(languageCode))\n//                    return ResponseResult.ErrorInfo(\"âŒ Template language not resolved from provider metadata.\");\n\n//                // Decide header by request: if VideoUrl present -> add VIDEO header; otherwise TEXT-only\n//                var isVideoHeader = !string.IsNullOrWhiteSpace(req.VideoUrl);\n//                if (isVideoHeader && !IsHttpsMp4Url(req.VideoUrl, out var vErr))\n//                    return ResponseResult.ErrorInfo(\"ðŸš« Invalid VideoUrl.\", vErr);\n\n//                // --- 3) Build components (TEXT or VIDEO)\n//                var (components, whyBuildFail) = BuildComponents(isVideoHeader, req.Variables, req.VideoUrl);\n//                if (components == null)\n//                {\n//                    _logger.LogWarning(\"[CustomAPI:{ReqId}] Component build failed: {Err}\", reqId, whyBuildFail);\n//                    return ResponseResult.ErrorInfo($\"ðŸš« Component build failed: {whyBuildFail}\");\n//                }\n\n//                // Snapshot first 3 buttons (if any) for analytics/click mapping (same as campaigns)\n//                string? buttonBundleJson = null;\n//                try\n//                {\n//                    if (meta.ButtonParams is { Count: > 0 })\n//                    {\n//                        var bundle = meta.ButtonParams.Take(3)\n//                            .Select((b, i) => new\n//                            {\n//                                i,\n//                                position = i + 1,\n//                                text = (b.Text ?? \"\").Trim(),\n//                                type = b.Type,\n//                                subType = b.SubType\n//                            }).ToList();\n//                        buttonBundleJson = JsonConvert.SerializeObject(bundle);\n//                    }\n//                }\n//                catch { /* best-effort snapshot */ }\n\n//                // Find entry step of the linked flow (if provided)\n//                Guid? entryStepId = null;\n//                if (req.FlowConfigId.HasValue)\n//                {\n//                    entryStepId = await _context.CTAFlowSteps\n//                        .Where(s => s.CTAFlowConfigId == req.FlowConfigId.Value)\n//                        .OrderBy(s => s.StepOrder)\n//                        .Select(s => (Guid?)s.Id)\n//                        .FirstOrDefaultAsync(ct);\n//                }\n\n\n//                // Always object. Meta accepts { code: \"en_US\" } and ignores policy if present.\n//                // Pinnacle REQUIRES an object.\n//                var languageField = new\n//                {\n//                    policy = \"deterministic\",\n//                    code = string.IsNullOrWhiteSpace(languageCode) ? \"en_US\" : languageCode\n//                };\n\n//                var payload = new\n//                {\n//                    messaging_product = \"whatsapp\",\n//                    to = toNormalized,\n//                    type = \"template\",\n//                    template = new\n//                    {\n//                        name = req.TemplateId,\n//                        language = languageField,\n//                        components\n//                    }\n//                };\n\n\n//                _logger.LogInformation(\"[CustomAPI:{ReqId}] Sending {Template} to {To} via {Provider} (PNID={PNID}) video={Video}\",\n//                    reqId, req.TemplateId, Mask(toNormalized), provider, req.PhoneNumberId, isVideoHeader);\n\n//                var result = await _messageEngine.SendPayloadAsync(\n//                    businessId: businessId,\n//                    provider: provider,\n//                    payload: payload,\n//                    phoneNumberId: req.PhoneNumberId   // âœ… correct parameter\n//                );\n\n//                // --- 5) Persist MessageLog (and flow linkage), then billing\n//                var now = DateTime.UtcNow;\n//                var logId = Guid.NewGuid();\n\n//                _context.MessageLogs.Add(new MessageLog\n//                {\n//                    Id = logId,\n//                    BusinessId = businessId,\n//                    CampaignId = null,                         // direct API path\n//                    RecipientNumber = toNormalized,\n//                    MessageContent = req.TemplateId,\n//                    MediaUrl = isVideoHeader ? req.VideoUrl : null,\n//                    Status = result.Success ? \"Sent\" : \"Failed\",\n//                    MessageId = result.MessageId,\n//                    ErrorMessage = result.ErrorMessage,\n//                    RawResponse = result.RawResponse,\n//                    CreatedAt = now,\n//                    SentAt = result.Success ? now : (DateTime?)null,\n//                    Source = \"custom_api\",\n//                    Provider = provider,\n//                    ProviderMessageId = result.MessageId,\n\n//                    // ðŸ”— Store flow linkage like campaigns do\n//                    CTAFlowConfigId = req.FlowConfigId,\n//                    CTAFlowStepId = entryStepId,\n//                    ButtonBundleJson = buttonBundleJson\n//                });\n\n//                await _context.SaveChangesAsync(ct);\n\n//                await _billingIngest.IngestFromSendResponseAsync(\n//                    businessId: businessId,\n//                    messageLogId: logId,\n//                    provider: provider,\n//                    rawResponseJson: result.RawResponse ?? \"{}\"\n//                );\n\n//                _logger.LogInformation(\"[CustomAPI:{ReqId}] Done. success={Success} msgId={MessageId} flow={Flow} step={Step}\",\n//                    reqId, result.Success, result.MessageId, req.FlowConfigId, entryStepId);\n\n//                return result.Success\n//                    ? ResponseResult.SuccessInfo(\"ðŸš€ Template sent.\",\n//                        new\n//                        {\n//                            messageId = result.MessageId,\n//                            to = toNormalized,\n//                            templateId = req.TemplateId,\n//                            flowConfigId = req.FlowConfigId,\n//                            flowEntryStepId = entryStepId\n//                        })\n//                    : ResponseResult.ErrorInfo(\"âŒ Send failed.\", result.ErrorMessage);\n//            }\n//            catch (Exception ex)\n//            {\n//                _logger.LogError(ex, \"âŒ Exception in CustomApiService.SendTemplateAsync\");\n//                return ResponseResult.ErrorInfo(\"ðŸš¨ Server error while sending template.\", ex.ToString());\n//            }\n//        }\n\n//        // ===== helpers =====\n\n//        private Guid GetBusinessIdOrThrow()\n//        {\n//            var user = _http.HttpContext?.User;\n//            if (user == null) throw new InvalidOperationException(\"Missing HttpContext/User.\");\n\n//            var bid = user.FindFirstValue(\"BusinessId\") ?? user.FindFirstValue(\"bid\") ?? user.FindFirstValue(\"business_id\");\n//            if (string.IsNullOrWhiteSpace(bid)) throw new InvalidOperationException(\"BusinessId claim is missing.\");\n//            return Guid.Parse(bid);\n//        }\n\n//        private static string NormalizePhone(string raw) => raw.StartsWith(\"+\") ? raw[1..] : raw;\n\n//        private static string Mask(string phone)\n//            => phone.Length <= 6 ? phone : $\"{new string('*', phone.Length - 4)}{phone[^4..]}\";\n\n//        private static bool IsHttpsMp4Url(string? url, out string? err)\n//        {\n//            err = null;\n//            if (string.IsNullOrWhiteSpace(url)) { err = \"VideoUrl is required when sending a VIDEO header.\"; return false; }\n//            if (!Uri.TryCreate(url, UriKind.Absolute, out var u)) { err = \"VideoUrl must be an absolute URL.\"; return false; }\n//            if (u.Scheme != Uri.UriSchemeHttps) { err = \"VideoUrl must be HTTPS.\"; return false; }\n//            if (!u.AbsolutePath.EndsWith(\".mp4\", StringComparison.OrdinalIgnoreCase)) { err = \"VideoUrl must point to an .mp4 file.\"; return false; }\n//            return true;\n//        }\n\n//        private static (List<object>? components, string? whyFail) BuildComponents(\n//            bool addVideoHeader,\n//            Dictionary<string, string>? variables,\n//            string? videoUrl)\n//        {\n//            try\n//            {\n//                var components = new List<object>();\n\n//                // Header (optional video)\n//                if (addVideoHeader)\n//                {\n//                    components.Add(new\n//                    {\n//                        type = \"header\",\n//                        parameters = new object[]\n//                        {\n//                            new { type = \"video\", video = new { link = videoUrl } }\n//                        }\n//                    });\n//                }\n\n//                // Body params ({{1}}, {{2}}, ...)\n//                if (variables is { Count: > 0 })\n//                {\n//                    var bodyParams = variables\n//                        .Select(kv => (Index: int.TryParse(kv.Key, out var n) ? n : int.MaxValue, Text: kv.Value ?? string.Empty))\n//                        .OrderBy(x => x.Index)\n//                        .Select(x => new { type = \"text\", text = x.Text })\n//                        .ToArray();\n\n//                    if (bodyParams.Length > 0)\n//                        components.Add(new { type = \"body\", parameters = bodyParams });\n//                }\n\n//                return (components, null);\n//            }\n//            catch (Exception ex)\n//            {\n//                return (null, ex.Message);\n//            }\n//        }\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomeApi/Services/ICtaJourneyPublisher.cs",
      "sha256": "179ba5f2372125cfe3c2aed455b5c8efa5b8f6de13ef2478d2e7e6df7890cd8e",
      "language": "csharp",
      "size": 443,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.CustomeApi.Services\n{\n    public interface ICtaJourneyPublisher\n    {\n        /// <summary>\n        /// Posts a CTAJourney event for the given business to all active endpoints in CustomerWebhookConfigs.\n        /// </summary>\n        Task PublishAsync(Guid businessId, Models.CtaJourneyEventDto dto, CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomeApi/Services/ICustomApiService.cs",
      "sha256": "76cd53ece80c088bec742c33974d8a8be781cd297d3d68e474150b19707e1f1e",
      "language": "csharp",
      "size": 377,
      "content": "using System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CustomeApi.DTOs;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.CustomeApi.Services\n{\n    public interface ICustomApiService\n    {\n        Task<ResponseResult> SendTemplateAsync(DirectTemplateSendRequest req, CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomFields/Controllers/CustomFieldsController.cs",
      "sha256": "ecf01929abd50cfb7140cfea5df6189af25ebc85d7cef8081b4cdbb33023abb5",
      "language": "csharp",
      "size": 6451,
      "content": "using System;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.AccessControl.PermissionAttributes;\nusing xbytechat.api.Features.AccessControl.Seeder;\nusing xbytechat.api.Features.CustomFields.Dtos;\nusing xbytechat.api.Features.CustomFields.Services;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.CustomFields.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize]\n    public sealed class CustomFieldsController : ControllerBase\n    {\n        private readonly ICustomFieldsService _service;\n\n        public CustomFieldsController(ICustomFieldsService service)\n        {\n            _service = service;\n        }\n\n        private Guid GetBusinessIdOrReject(out IActionResult? errorResult)\n        {\n            errorResult = null;\n\n            var businessId = HttpContext.User.GetBusinessId();\n            if (businessId == Guid.Empty)\n            {\n                errorResult = Unauthorized(ResponseResult.ErrorInfo(\"Missing BusinessId in user claims.\"));\n                return Guid.Empty;\n            }\n\n            return businessId;\n        }\n\n        // --------------------------------------------------------------------\n        // Definitions (READ = allow any authenticated user in the business)\n        // --------------------------------------------------------------------\n\n        /// <summary>\n        /// READ schema for the given entityType (e.g. CONTACT).\n        /// âœ… MVP: Allow any authenticated user (business-scoped). This matches the current CRM module behavior.\n        /// Later you can add a dedicated permission like: customfields.view\n        /// </summary>\n        [HttpGet(\"definitions\")]\n        public async Task<IActionResult> GetDefinitions(\n            [FromQuery] string entityType = \"CONTACT\",\n            [FromQuery] bool includeInactive = false)\n        {\n            var bizId = GetBusinessIdOrReject(out var err);\n            if (err != null) return err;\n\n            var rows = await _service.GetDefinitionsAsync(bizId, entityType, includeInactive);\n            return Ok(ResponseResult.SuccessInfo(\"âœ… Custom field definitions fetched.\", rows));\n        }\n\n        /// <summary>\n        /// Managing schema is an \"admin-ish\" action.\n        /// Reusing TagsEdit for now as the closest existing CRM admin permission.\n        /// (Later: introduce customfields.manage / customfields.edit)\n        /// </summary>\n        [HttpPost(\"definitions\")]\n        \n        public async Task<IActionResult> CreateDefinition([FromBody] CreateCustomFieldDefinitionDto dto)\n        {\n            var bizId = GetBusinessIdOrReject(out var err);\n            if (err != null) return err;\n\n            var created = await _service.CreateDefinitionAsync(bizId, dto);\n            return Ok(ResponseResult.SuccessInfo(\"âœ… Custom field definition created.\", created));\n        }\n\n        [HttpPut(\"definitions/{fieldId:guid}\")]\n        \n        public async Task<IActionResult> UpdateDefinition([FromRoute] Guid fieldId, [FromBody] UpdateCustomFieldDefinitionDto dto)\n        {\n            var bizId = GetBusinessIdOrReject(out var err);\n            if (err != null) return err;\n\n            var updated = await _service.UpdateDefinitionAsync(bizId, fieldId, dto);\n            return Ok(ResponseResult.SuccessInfo(\"âœ… Custom field definition updated.\", updated));\n        }\n\n        [HttpDelete(\"definitions/{fieldId:guid}\")]\n       \n        public async Task<IActionResult> DeactivateDefinition([FromRoute] Guid fieldId)\n        {\n            var bizId = GetBusinessIdOrReject(out var err);\n            if (err != null) return err;\n\n            var ok = await _service.DeactivateDefinitionAsync(bizId, fieldId);\n            return Ok(ResponseResult.SuccessInfo(ok ? \"âœ… Field deactivated.\" : \"â„¹ï¸ Field not found.\", ok));\n        }\n\n        // --------------------------------------------------------------------\n        // Values (READ = allow any authenticated user in the business)\n        // --------------------------------------------------------------------\n\n        /// <summary>\n        /// âœ… MVP: Allow reading values for any authenticated user (business-scoped).\n        /// Later you can gate with a dedicated permission like: customfields.values.view\n        /// </summary>\n        [HttpGet(\"values\")]\n        public async Task<IActionResult> GetValues([FromQuery] string entityType, [FromQuery] Guid entityId)\n        {\n            var bizId = GetBusinessIdOrReject(out var err);\n            if (err != null) return err;\n\n            if (entityId == Guid.Empty)\n                return BadRequest(ResponseResult.ErrorInfo(\"EntityId is required.\"));\n\n            var rows = await _service.GetValuesAsync(bizId, entityType, entityId);\n            return Ok(ResponseResult.SuccessInfo(\"âœ… Custom field values fetched.\", rows));\n        }\n\n        /// <summary>\n        /// Upserting values changes CRM data. Keep it strict for MVP.\n        /// Reusing TagsEdit for now as \"CRM admin/edit\" gate.\n        /// </summary>\n        [HttpPut(\"values\")]\n      \n        public async Task<IActionResult> UpsertValues([FromBody] UpsertCustomFieldValuesDto dto)\n        {\n            var bizId = GetBusinessIdOrReject(out var err);\n            if (err != null) return err;\n\n            await _service.UpsertValuesAsync(bizId, dto);\n            return Ok(ResponseResult.SuccessInfo(\"âœ… Custom field values saved.\", true));\n        }\n\n        /// <summary>\n        /// Convenience endpoint for UI: fetch active definitions + current values.\n        /// âœ… MVP: Allow any authenticated user (business-scoped) so the page can load.\n        /// </summary>\n        [HttpGet(\"schema-with-values\")]\n        public async Task<IActionResult> GetSchemaWithValues([FromQuery] string entityType, [FromQuery] Guid entityId)\n        {\n            var bizId = GetBusinessIdOrReject(out var err);\n            if (err != null) return err;\n\n            if (entityId == Guid.Empty)\n                return BadRequest(ResponseResult.ErrorInfo(\"EntityId is required.\"));\n\n            var data = await _service.GetSchemaWithValuesAsync(bizId, entityType, entityId);\n\n            return Ok(ResponseResult.SuccessInfo(\"âœ… Schema + values fetched.\", new\n            {\n                definitions = data.Definitions,\n                values = data.Values\n            }));\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomFields/Dtos/CreateCustomFieldDefinitionDto.cs",
      "sha256": "5c8d8fbec4a4956c22be7fbd07d8f9db34147173a9fdaa5df90ac021ab2be2ba",
      "language": "csharp",
      "size": 1119,
      "content": "using System.Text.Json;\n\nnamespace xbytechat.api.Features.CustomFields.Dtos\n{\n    /// <summary>\n    /// Request DTO to create a custom field definition.\n    /// </summary>\n    public sealed class CreateCustomFieldDefinitionDto\n    {\n        public string EntityType { get; set; } = \"Contact\";\n\n        /// <summary>\n        /// Stable internal key (snake_case recommended).\n        /// </summary>\n        public string Key { get; set; } = string.Empty;\n\n        /// <summary>\n        /// UI label.\n        /// </summary>\n        public string Label { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Data type as string:\n        /// \"Text\", \"Number\", \"Date\", \"Boolean\", \"SingleSelect\", \"MultiSelect\"\n        /// </summary>\n        public string DataType { get; set; } = \"Text\";\n\n        /// <summary>\n        /// For select types: options and any future metadata.\n        /// Example: {\"options\":[\"Retail\",\"Wholesale\"]}\n        /// </summary>\n        public JsonElement? Options { get; set; }\n\n        public bool IsRequired { get; set; } = false;\n\n        public int SortOrder { get; set; } = 0;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomFields/Dtos/CustomFieldDefinitionDto.cs",
      "sha256": "900fcaef78d5af086eeb456dce5c60463f20c8ae8623ba97d7426459f9b9111d",
      "language": "csharp",
      "size": 1322,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CustomFields.Dtos\n{\n    /// <summary>\n    /// Response DTO for a Custom Field Definition (schema).\n    /// </summary>\n    public sealed class CustomFieldDefinitionDto\n    {\n        public Guid Id { get; set; }\n\n        public string EntityType { get; set; } = \"Contact\";\n\n        /// <summary>\n        /// Stable internal key (snake_case recommended).\n        /// Example: gst_number\n        /// </summary>\n        public string Key { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Human label shown in UI.\n        /// Example: \"GST Number\"\n        /// </summary>\n        public string Label { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Data type as string to avoid enum-serialization surprises across clients.\n        /// Example: \"Text\", \"Number\", \"Date\", \"Boolean\", \"SingleSelect\", \"MultiSelect\"\n        /// </summary>\n        public string DataType { get; set; } = \"Text\";\n\n        /// <summary>\n        /// Options metadata stored as JSON (for select types).\n        /// Example: {\"options\":[\"A\",\"B\",\"C\"]}\n        /// </summary>\n        public string? OptionsJson { get; set; }\n\n        public bool IsRequired { get; set; }\n\n        public bool IsActive { get; set; } = true;\n\n        public int SortOrder { get; set; } = 0;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomFields/Dtos/CustomFieldValueDto.cs",
      "sha256": "bdec3fe529d4fa6e940e5e065fcd5c69913cde775c085ec0a13d70ce39009cf0",
      "language": "csharp",
      "size": 496,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CustomFields.Dtos\n{\n    /// <summary>\n    /// Represents a stored value for a field for a specific entity record.\n    /// Returned to the UI as raw JSON (ValueJson).\n    /// </summary>\n    public sealed class CustomFieldValueDto\n    {\n        public Guid FieldId { get; set; }\n\n        /// <summary>\n        /// Stored jsonb payload (we store as {\"value\": ...}).\n        /// </summary>\n        public string ValueJson { get; set; } = \"{}\";\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomFields/Dtos/UpdateCustomFieldDefinitionDto.cs",
      "sha256": "c9ce1b7b1191fb5ff90d5864a744ede5b399aa8e956a107abf8777de98f15694",
      "language": "csharp",
      "size": 793,
      "content": "using System.Text.Json;\n\nnamespace xbytechat.api.Features.CustomFields.Dtos\n{\n    /// <summary>\n    /// Request DTO to update a custom field definition.\n    /// We keep it flexible; service decides what fields are allowed to change.\n    /// </summary>\n    public sealed class UpdateCustomFieldDefinitionDto\n    {\n\n        public string? Label { get; set; }\n        /// <summary>\n        /// Optional: allow changing datatype later if you want,\n        /// but by default we typically keep datatype immutable.\n        /// </summary>\n        public string? DataType { get; set; }\n\n        public JsonElement? Options { get; set; }\n\n        public bool IsRequired { get; set; } = false;\n\n        public bool IsActive { get; set; } = true;\n\n        public int SortOrder { get; set; } = 0;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomFields/Dtos/UpsertCustomFieldValuesDto.cs",
      "sha256": "244c2783ce9d142c608569b620b83fe2d8470941dc4f76f116d5145398fefe4d",
      "language": "csharp",
      "size": 1019,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Text.Json;\n\nnamespace xbytechat.api.Features.CustomFields.Dtos\n{\n    /// <summary>\n    /// Bulk upsert values for one record (e.g., one Contact).\n    /// </summary>\n    public sealed class UpsertCustomFieldValuesDto\n    {\n        public string EntityType { get; set; } = \"CONTACT\";\n\n        /// <summary>\n        /// Record id (e.g., ContactId).\n        /// </summary>\n        public Guid EntityId { get; set; }\n\n        /// <summary>\n        /// Values to upsert.\n        /// Service will wrap each into {\"value\": <this>} for storage.\n        /// </summary>\n        public List<UpsertCustomFieldValueItemDto> Values { get; set; } = new();\n    }\n\n    public sealed class UpsertCustomFieldValueItemDto\n    {\n        public Guid FieldId { get; set; }\n\n        /// <summary>\n        /// Typed value as JSON.\n        /// Examples: \"abc\", 123, true, \"2025-12-14T00:00:00Z\", [\"A\",\"B\"]\n        /// </summary>\n        public JsonElement? Value { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomFields/Models/CustomFieldDataType.cs",
      "sha256": "c34fd6245abd51bdeb61eb68ccc716e4dac10e038ae2caac971a7119712a1765",
      "language": "csharp",
      "size": 397,
      "content": "namespace xbytechat.api.Features.CustomFields.Models\n{\n    /// <summary>\n    /// Supported field data types for Custom Fields.\n    /// Stored as string in DB for readability and forward compatibility.\n    /// </summary>\n    public enum CustomFieldDataType\n    {\n        Text = 1,\n        Number = 2,\n        Date = 3,\n        Boolean = 4,\n        SingleSelect = 5,\n        MultiSelect = 6\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomFields/Models/CustomFieldDefinition.cs",
      "sha256": "c77155600842690a22f247b27ed7e8abc865ace70e10d1dd55d5f5f6d09fb9be",
      "language": "csharp",
      "size": 1889,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CustomFields.Models\n{\n    /// <summary>\n    /// Defines a custom field (schema) for a Business and an EntityType (e.g., Contact).\n    /// Example:\n    ///  - EntityType = \"Contact\"\n    ///  - Key = \"gst_number\"\n    ///  - Label = \"GST Number\"\n    ///  - DataType = Text\n    /// </summary>\n    public sealed class CustomFieldDefinition\n    {\n        public Guid Id { get; set; }\n\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// Target entity type. Keep it flexible as string so we can reuse this module later:\n        /// \"Contact\", \"Conversation\", \"MessageLog\", etc.\n        /// </summary>\n        public string EntityType { get; set; } = \"Contact\";\n\n        /// <summary>\n        /// Stable key used internally (snake_case recommended).\n        /// Example: gst_number, preferred_language\n        /// </summary>\n        public string Key { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Human-friendly label shown in UI.\n        /// Example: \"GST Number\"\n        /// </summary>\n        public string Label { get; set; } = string.Empty;\n\n        public CustomFieldDataType DataType { get; set; } = CustomFieldDataType.Text;\n\n        /// <summary>\n        /// For select types: store options, UI metadata, validation rules etc.\n        /// Stored as jsonb.\n        /// Example: {\"options\":[\"A\",\"B\",\"C\"]}\n        /// </summary>\n        public string? OptionsJson { get; set; }\n\n        public bool IsRequired { get; set; } = false;\n\n        public bool IsActive { get; set; } = true;\n\n        public int SortOrder { get; set; } = 0;\n\n        public DateTime CreatedAtUtc { get; set; } = DateTime.UtcNow;\n\n        /// <summary>\n        /// Updated automatically by your UpdatedAtUtcInterceptor.\n        /// </summary>\n        public DateTime UpdatedAtUtc { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomFields/Models/CustomFieldValue.cs",
      "sha256": "b426921280a31a2ae1fa61ba8114eaa6060b51724f4c794ba261a46e00d06fa7",
      "language": "csharp",
      "size": 1590,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CustomFields.Models\n{\n    /// <summary>\n    /// Stores a field value for a specific entity record.\n    /// Example:\n    ///  - EntityType = \"Contact\"\n    ///  - EntityId = Contact.Id\n    ///  - FieldId = CustomFieldDefinition.Id\n    ///  - ValueJson = {\"value\":\"27ABCDE1234F1Z5\"} or {\"value\":true} etc.\n    /// </summary>\n    public sealed class CustomFieldValue\n    {\n        public Guid Id { get; set; }\n\n        public Guid BusinessId { get; set; }\n\n        public string EntityType { get; set; } = \"Contact\";\n\n        /// <summary>\n        /// The record id (e.g., ContactId) this value belongs to.\n        /// </summary>\n        public Guid EntityId { get; set; }\n\n        public Guid FieldId { get; set; }\n\n        /// <summary>\n        /// JSON payload holding the typed value.\n        /// For simplicity we always store jsonb. UI/service enforces shape.\n        /// Example:\n        ///  {\"value\":\"text\"}\n        ///  {\"value\":123}\n        ///  {\"value\":true}\n        ///  {\"value\":\"2025-12-14T00:00:00Z\"}\n        ///  {\"value\":[\"A\",\"B\"]}\n        /// </summary>\n        public string ValueJson { get; set; } = \"{}\";\n\n        public bool IsActive { get; set; } = true;\n\n        public DateTime CreatedAtUtc { get; set; } = DateTime.UtcNow;\n\n        /// <summary>\n        /// Updated automatically by your UpdatedAtUtcInterceptor.\n        /// </summary>\n        public DateTime UpdatedAtUtc { get; set; } = DateTime.UtcNow;\n\n        // Navigation (optional but helpful)\n        public CustomFieldDefinition? Field { get; set; }\n    }\n}\n"
    }
  ]
}
