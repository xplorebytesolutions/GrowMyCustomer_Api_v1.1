{
  "name": "xbytechat-api",
  "part": 5,
  "of": 33,
  "generatedAt": "2026-02-11 19:15:17 +00:00",
  "files": [
    {
      "path": "xbytechat-api/Features/CustomFields/Services/CustomFieldsService.cs",
      "sha256": "a737e85a6564984ca45fab12ff85378dfe5d642e8523f851c20e21be7f75cf1e",
      "language": "csharp",
      "size": 11843,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.Json;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.CustomFields.Dtos;\nusing xbytechat.api.Features.CustomFields.Models;\n\nnamespace xbytechat.api.Features.CustomFields.Services\n{\n    public sealed class CustomFieldsService : ICustomFieldsService\n    {\n        private readonly AppDbContext _db;\n\n        // key: snake_case recommended, enforce stable internal keys\n        private static readonly Regex KeyRegex = new(\"^[a-z][a-z0-9_]{0,119}$\", RegexOptions.Compiled);\n\n        public CustomFieldsService(AppDbContext db)\n        {\n            _db = db;\n        }\n\n        public async Task<List<CustomFieldDefinitionDto>> GetDefinitionsAsync(Guid businessId, string entityType, bool includeInactive)\n        {\n            var et = NormalizeEntityType(entityType);\n\n            var q = _db.CustomFieldDefinitions\n                .AsNoTracking()\n                .Where(x => x.BusinessId == businessId && x.EntityType == et);\n\n            if (!includeInactive)\n                q = q.Where(x => x.IsActive);\n\n            var rows = await q.OrderBy(x => x.SortOrder).ThenBy(x => x.Label).ToListAsync();\n\n            return rows.Select(MapDefinition).ToList();\n        }\n\n        public async Task<CustomFieldDefinitionDto> CreateDefinitionAsync(Guid businessId, CreateCustomFieldDefinitionDto dto)\n        {\n            var et = NormalizeEntityType(dto.EntityType);\n            var key = NormalizeKey(dto.Key);\n\n            ValidateDefinitionInputs(key, dto.Label);\n\n            // DB unique index exists, but we still do a friendly pre-check for better error messages.\n            var exists = await _db.CustomFieldDefinitions\n                .AnyAsync(x => x.BusinessId == businessId && x.EntityType == et && x.Key == key);\n\n            if (exists)\n                throw new InvalidOperationException($\"Custom field key '{key}' already exists for entity '{et}'.\");\n\n            var entity = new CustomFieldDefinition\n            {\n                Id = Guid.NewGuid(),\n                BusinessId = businessId,\n                EntityType = et,\n                Key = key,\n                Label = dto.Label.Trim(),\n                DataType = ParseDataType(dto.DataType),\n                OptionsJson = NormalizeOptions(dto.Options),\n                IsRequired = dto.IsRequired,\n                IsActive = true,\n                SortOrder = dto.SortOrder\n            };\n\n            _db.CustomFieldDefinitions.Add(entity);\n            await _db.SaveChangesAsync();\n\n            return MapDefinition(entity);\n        }\n\n        public async Task<CustomFieldDefinitionDto> UpdateDefinitionAsync(Guid businessId, Guid fieldId, UpdateCustomFieldDefinitionDto dto)\n        {\n            var entity = await _db.CustomFieldDefinitions\n                .FirstOrDefaultAsync(x => x.Id == fieldId && x.BusinessId == businessId);\n\n            if (entity == null)\n                throw new KeyNotFoundException(\"Custom field definition not found.\");\n\n            // Do NOT allow changing EntityType/Key in MVP (prevents breaking existing data + joins).\n            if (!string.IsNullOrWhiteSpace(dto.Label))\n                entity.Label = dto.Label.Trim();\n\n            if (!string.IsNullOrWhiteSpace(dto.DataType))\n                entity.DataType = ParseDataType(dto.DataType);\n\n            if (dto.Options != null)\n                entity.OptionsJson = NormalizeOptions(dto.Options);\n\n            entity.IsRequired = dto.IsRequired;\n            entity.IsActive = dto.IsActive;\n            entity.SortOrder = dto.SortOrder;\n\n            await _db.SaveChangesAsync();\n            return MapDefinition(entity);\n        }\n\n        public async Task<bool> DeactivateDefinitionAsync(Guid businessId, Guid fieldId)\n        {\n            var entity = await _db.CustomFieldDefinitions\n                .FirstOrDefaultAsync(x => x.Id == fieldId && x.BusinessId == businessId);\n\n            if (entity == null) return false;\n\n            entity.IsActive = false;\n            await _db.SaveChangesAsync();\n            return true;\n        }\n\n        public async Task<List<CustomFieldValueDto>> GetValuesAsync(Guid businessId, string entityType, Guid entityId)\n        {\n            var et = NormalizeEntityType(entityType);\n\n            var rows = await _db.CustomFieldValues\n                .AsNoTracking()\n                .Where(x => x.BusinessId == businessId && x.EntityType == et && x.EntityId == entityId)\n                .ToListAsync();\n\n            return rows.Select(x => new CustomFieldValueDto\n            {\n                FieldId = x.FieldId,\n                ValueJson = x.ValueJson ?? \"{}\"\n            }).ToList();\n        }\n\n        public async Task UpsertValuesAsync(Guid businessId, UpsertCustomFieldValuesDto dto)\n        {\n            var et = NormalizeEntityType(dto.EntityType);\n\n            if (dto.EntityId == Guid.Empty)\n                throw new ArgumentException(\"EntityId is required.\");\n\n            if (dto.Values == null || dto.Values.Count == 0)\n                return;\n\n            // Load definitions once, validate field ownership + types\n            var fieldIds = dto.Values.Select(v => v.FieldId).Distinct().ToList();\n\n            var defs = await _db.CustomFieldDefinitions\n                .AsNoTracking()\n                .Where(x => x.BusinessId == businessId && x.EntityType == et && fieldIds.Contains(x.Id) && x.IsActive)\n                .ToListAsync();\n\n            if (defs.Count != fieldIds.Count)\n                throw new InvalidOperationException(\"One or more fields are invalid/inactive for this business/entity.\");\n\n            var defMap = defs.ToDictionary(x => x.Id, x => x);\n\n            // Fetch existing values for this entity+fields\n            var existing = await _db.CustomFieldValues\n                .Where(x => x.BusinessId == businessId && x.EntityType == et && x.EntityId == dto.EntityId && fieldIds.Contains(x.FieldId))\n                .ToListAsync();\n\n            var existingMap = existing.ToDictionary(x => x.FieldId, x => x);\n\n            foreach (var item in dto.Values)\n            {\n                if (item.FieldId == Guid.Empty)\n                    throw new ArgumentException(\"FieldId is required.\");\n\n                var def = defMap[item.FieldId];\n                var wrapped = WrapAndValidateValue(def, item.Value);\n\n                if (existingMap.TryGetValue(item.FieldId, out var row))\n                {\n                    row.ValueJson = wrapped;\n                }\n                else\n                {\n                    _db.CustomFieldValues.Add(new CustomFieldValue\n                    {\n                        Id = Guid.NewGuid(),\n                        BusinessId = businessId,\n                        EntityType = et,\n                        EntityId = dto.EntityId,\n                        FieldId = item.FieldId,\n                        ValueJson = wrapped\n                    });\n                }\n            }\n\n            await _db.SaveChangesAsync();\n        }\n\n        public async Task<(List<CustomFieldDefinitionDto> Definitions, List<CustomFieldValueDto> Values)> GetSchemaWithValuesAsync(\n            Guid businessId, string entityType, Guid entityId)\n        {\n            var defs = await GetDefinitionsAsync(businessId, entityType, includeInactive: false);\n            var vals = await GetValuesAsync(businessId, entityType, entityId);\n            return (defs, vals);\n        }\n\n        // ---------------- helpers ----------------\n\n        private static string NormalizeEntityType(string entityType)\n        {\n            var et = (entityType ?? \"\").Trim();\n            if (string.IsNullOrWhiteSpace(et)) et = \"CONTACT\";\n            return et.ToUpperInvariant(); // canonical storage + comparisons\n        }\n\n        private static string NormalizeKey(string key)\n        {\n            var k = (key ?? \"\").Trim().ToLowerInvariant();\n            if (!KeyRegex.IsMatch(k))\n                throw new ArgumentException(\"Key must be snake_case (a-z, 0-9, underscore), max 120 chars.\");\n            return k;\n        }\n\n        private static void ValidateDefinitionInputs(string key, string label)\n        {\n            if (string.IsNullOrWhiteSpace(label))\n                throw new ArgumentException(\"Label is required.\");\n\n            if (label.Trim().Length > 200)\n                throw new ArgumentException(\"Label too long (max 200).\");\n\n            // key already validated by regex\n        }\n\n        private static CustomFieldDataType ParseDataType(string? dataType)\n        {\n            var raw = (dataType ?? \"Text\").Trim();\n\n            if (Enum.TryParse<CustomFieldDataType>(raw, ignoreCase: true, out var dt))\n                return dt;\n\n            throw new ArgumentException($\"Invalid DataType '{raw}'.\");\n        }\n\n        private static string? NormalizeOptions(JsonElement? options)\n        {\n            if (options == null) return null;\n\n            var kind = options.Value.ValueKind;\n            if (kind is JsonValueKind.Null or JsonValueKind.Undefined)\n                return null;\n\n            // (Recommended) options should be object/array, not a primitive\n            if (kind is not (JsonValueKind.Object or JsonValueKind.Array))\n                throw new ArgumentException(\"Options must be a JSON object or array.\");\n\n            // JsonElement is already validated JSON. Store normalized JSON text.\n            return options.Value.GetRawText();\n        }\n\n        private static string WrapAndValidateValue(CustomFieldDefinition def, JsonElement? value)\n        {\n            // Required check\n            if (def.IsRequired && (value == null || value.Value.ValueKind == JsonValueKind.Null))\n                throw new ArgumentException($\"Field '{def.Label}' is required.\");\n\n            // Minimal type checks (MVP). You can extend later.\n            if (value != null && value.Value.ValueKind != JsonValueKind.Null)\n            {\n                switch (def.DataType)\n                {\n                    case CustomFieldDataType.Number:\n                        if (value.Value.ValueKind != JsonValueKind.Number)\n                            throw new ArgumentException($\"Field '{def.Label}' must be a number.\");\n                        break;\n\n                    case CustomFieldDataType.Boolean:\n                        if (value.Value.ValueKind is not (JsonValueKind.True or JsonValueKind.False))\n                            throw new ArgumentException($\"Field '{def.Label}' must be boolean.\");\n                        break;\n\n                    case CustomFieldDataType.MultiSelect:\n                        if (value.Value.ValueKind != JsonValueKind.Array)\n                            throw new ArgumentException($\"Field '{def.Label}' must be an array.\");\n                        break;\n\n                    default:\n                        // Text/Date/SingleSelect/etc -> keep permissive for MVP\n                        break;\n                }\n            }\n\n            // Wrap into {\"value\": ...}\n            var wrapped = JsonSerializer.Serialize(new Dictionary<string, object?>\n            {\n                [\"value\"] = value?.Deserialize<object?>()\n            });\n\n            return wrapped;\n        }\n\n        private static CustomFieldDefinitionDto MapDefinition(CustomFieldDefinition x)\n        {\n            return new CustomFieldDefinitionDto\n            {\n                Id = x.Id,\n                EntityType = x.EntityType,\n                Key = x.Key,\n                Label = x.Label,\n                DataType = x.DataType.ToString(),\n                OptionsJson = x.OptionsJson,\n                IsRequired = x.IsRequired,\n                IsActive = x.IsActive,\n                SortOrder = x.SortOrder\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomFields/Services/ICustomFieldsService.cs",
      "sha256": "ef65bd10b54038c7ddd79b8a0ffe8acb8d0dbf49ebac02f3f6270f6341771c22",
      "language": "csharp",
      "size": 1190,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CustomFields.Dtos;\n\nnamespace xbytechat.api.Features.CustomFields.Services\n{\n    public interface ICustomFieldsService\n    {\n        Task<List<CustomFieldDefinitionDto>> GetDefinitionsAsync(Guid businessId, string entityType, bool includeInactive);\n        Task<CustomFieldDefinitionDto> CreateDefinitionAsync(Guid businessId, CreateCustomFieldDefinitionDto dto);\n        Task<CustomFieldDefinitionDto> UpdateDefinitionAsync(Guid businessId, Guid fieldId, UpdateCustomFieldDefinitionDto dto);\n        Task<bool> DeactivateDefinitionAsync(Guid businessId, Guid fieldId);\n\n        Task<List<CustomFieldValueDto>> GetValuesAsync(Guid businessId, string entityType, Guid entityId);\n        Task UpsertValuesAsync(Guid businessId, UpsertCustomFieldValuesDto dto);\n\n        /// <summary>\n        /// Convenience endpoint for UI: returns schema + current values for a record.\n        /// </summary>\n        Task<(List<CustomFieldDefinitionDto> Definitions, List<CustomFieldValueDto> Values)> GetSchemaWithValuesAsync(\n            Guid businessId, string entityType, Guid entityId);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Controllers/BusinessPermissionOverridesController.cs",
      "sha256": "35228864f3a058afa42ee724d48b3665982a89b904a064c2d4471dd985d6aa2d",
      "language": "csharp",
      "size": 1898,
      "content": "using System;\nusing System.Security.Claims;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.Entitlements.DTOs;\nusing xbytechat.api.Features.Entitlements.Services;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.Entitlements.Controllers\n{\n    [ApiController]\n    [Route(\"api/admin/businesses/{businessId:guid}/permission-overrides\")]\n    [Authorize(Roles = \"admin,partner,reseller\")]\n    public sealed class BusinessPermissionOverridesController : ControllerBase\n    {\n        private readonly IBusinessPermissionOverrideService _service;\n\n        public BusinessPermissionOverridesController(IBusinessPermissionOverrideService service)\n        {\n            _service = service;\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> Get(Guid businessId)\n        {\n            var rows = await _service.GetAsync(businessId);\n            return Ok(ResponseResult.SuccessInfo(\"‚úÖ Overrides fetched.\", rows));\n        }\n\n        [HttpPost]\n        public async Task<IActionResult> Upsert(Guid businessId, [FromBody] UpsertBusinessPermissionOverrideDto dto)\n        {\n            var actorUserId = GetUserId();\n            var res = await _service.UpsertAsync(businessId, actorUserId, dto);\n            return Ok(res);\n        }\n\n        [HttpDelete(\"{permissionCode}\")]\n        public async Task<IActionResult> Revoke(Guid businessId, string permissionCode)\n        {\n            var actorUserId = GetUserId();\n            var res = await _service.RevokeByPermissionCodeAsync(businessId, actorUserId, permissionCode);\n            return Ok(res);\n        }\n\n        private Guid GetUserId()\n        {\n            var raw = User.FindFirstValue(\"id\") ?? User.FindFirstValue(ClaimTypes.NameIdentifier);\n            return Guid.TryParse(raw, out var id) ? id : Guid.Empty;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Controllers/EntitlementsController.cs",
      "sha256": "0c435fe50cb96bd08c30f57eb23775a506bd85d7555798508742e38ecc668977",
      "language": "csharp",
      "size": 3151,
      "content": "#nullable enable\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.Entitlements.DTOs;\nusing xbytechat.api.Features.Entitlements.Services;\nusing xbytechat.api.Helpers; // ‚úÖ Use shared helpers for claims\n\nnamespace xbytechat.api.Features.Entitlements.Controllers\n{\n    [ApiController]\n    [Route(\"api/entitlements\")]\n    [Authorize]\n    public sealed class EntitlementsController : ControllerBase\n    {\n        private readonly IQuotaService _quota;\n\n        // Roles are stored lower-case in JWT (JwtTokenService),\n        // so we treat \"admin\" and \"superadmin\" as global admins.\n        private const string AdminRoleAdmin = \"admin\";\n        private const string AdminRoleSuperAdmin = \"superadmin\";\n\n        public EntitlementsController(IQuotaService quota)\n        {\n            _quota = quota;\n        }\n\n        // Helpers\n        private Guid? TryGetCallerBusinessId()\n        {\n            // Centralized logic: reads \"businessId\" claim.\n            var id = UserContextHelper.GetBusinessId(User);\n            return id == Guid.Empty ? (Guid?)null : id;\n        }\n\n        private bool IsAdmin()\n        {\n            return User.IsInRole(AdminRoleAdmin) || User.IsInRole(AdminRoleSuperAdmin);\n        }\n\n        private bool IsAuthorizedFor(Guid targetBusinessId)\n        {\n            if (IsAdmin()) return true;\n\n            var callerBiz = TryGetCallerBusinessId();\n            return callerBiz.HasValue && callerBiz.Value == targetBusinessId;\n        }\n\n        // GET /api/entitlements/{businessId}\n        [HttpGet(\"{businessId:guid}\")]\n        public async Task<ActionResult<EntitlementsSnapshotDto>> GetSnapshot(\n            Guid businessId,\n            CancellationToken ct)\n        {\n            if (!IsAuthorizedFor(businessId))\n                return Forbid();\n\n            var dto = await _quota.GetSnapshotAsync(businessId, ct);\n            return Ok(dto);\n        }\n\n        // POST /api/entitlements/{businessId}/check\n        [HttpPost(\"{businessId:guid}/check\")]\n        public async Task<ActionResult<EntitlementResultDto>> Check(\n            Guid businessId,\n            [FromBody] EntitlementCheckDto? req,\n            CancellationToken ct)\n        {\n            if (!IsAuthorizedFor(businessId))\n                return Forbid();\n\n            if (req is null)\n                return BadRequest(\"Request body is required.\");\n\n            if (string.IsNullOrWhiteSpace(req.QuotaKey))\n                return BadRequest(\"QuotaKey required.\");\n\n            var amount = Math.Max(1, req.Amount);\n\n            var result = req.ConsumeOnSuccess\n                ? await _quota.CheckAndConsumeAsync(businessId, req.QuotaKey, amount, ct)\n                : await _quota.CheckAsync(businessId, req.QuotaKey, amount, ct);\n\n            if (!result.Allowed)\n                // 429 payload shape is already what your axios interceptor expects:\n                // { allowed:false, quotaKey, limit, remaining, message }\n                return StatusCode(429, result);\n\n            return Ok(result);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Controllers/PlanQuotasAdminController.cs",
      "sha256": "615f8f0b670d3e8aef239a57b9a5125959a2a63e18f417e08a8b52d2b99da7c3",
      "language": "csharp",
      "size": 5876,
      "content": "// üìÑ Features/Entitlements/Controllers/PlanQuotasAdminController.cs\n#nullable enable\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Entitlements.DTOs;\nusing xbytechat.api.Features.Entitlements.Models;\n\nnamespace xbytechat.api.Features.Entitlements.Controllers\n{\n    /// <summary>\n    /// Admin endpoints to manage default quotas per plan.\n    /// These are the rows in PlanQuotas table.\n    /// </summary>\n    [ApiController]\n    [Route(\"api/admin/plans/{planId:guid}/quotas\")]\n    [Authorize(Roles = \"superadmin,partneradmin,admin\")]\n    public sealed class PlanQuotasAdminController : ControllerBase\n    {\n        private readonly AppDbContext _db;\n\n        public PlanQuotasAdminController(AppDbContext db)\n        {\n            _db = db;\n        }\n\n        // GET /admin/plans/{planId}/quotas\n        [HttpGet]\n        public async Task<ActionResult<List<PlanQuotaDto>>> GetForPlan(\n            Guid planId,\n            CancellationToken ct)\n        {\n            // Validate plan exists (defensive)\n            var planExists = await _db.Plans\n                .AsNoTracking()\n                .AnyAsync(p => p.Id == planId, ct);\n\n            if (!planExists)\n                return NotFound(new { message = \"Plan not found\" });\n\n            var quotas = await _db.PlanQuotas\n                .AsNoTracking()\n                .Where(q => q.PlanId == planId)\n                .OrderBy(q => q.QuotaKey)\n                .Select(q => new PlanQuotaDto\n                {\n                    Id = q.Id,\n                    PlanId = q.PlanId,\n                    QuotaKey = q.QuotaKey,\n                    Limit = q.Limit,\n                    Period = q.Period,\n                    DenialMessage = q.DenialMessage\n                })\n                .ToListAsync(ct);\n\n            return Ok(quotas);\n        }\n\n        // PUT /admin/plans/{planId}/quotas\n        //\n        // Simple \"upsert by QuotaKey\" semantics:\n        // - Existing PlanQuota with same PlanId + QuotaKey is updated\n        // - New QuotaKey rows are inserted\n        // - Quotas not present in payload are kept (no destructive delete here)\n        [HttpPut]\n        public async Task<IActionResult> UpsertForPlan(\n            Guid planId,\n            [FromBody] List<PlanQuotaDto> payload,\n            CancellationToken ct)\n        {\n            if (payload is null)\n                return BadRequest(new { message = \"Payload is required\" });\n\n            // Normalize keys to upper-case for comparisons (used only in-memory)\n            static string Normalize(string key) =>\n                (key ?? string.Empty).Trim().ToUpperInvariant();\n\n            // Ensure plan exists\n            var planExists = await _db.Plans\n                .AsNoTracking()\n                .AnyAsync(p => p.Id == planId, ct);\n\n            if (!planExists)\n                return NotFound(new { message = \"Plan not found\" });\n\n            var incoming = payload\n                .Where(p => !string.IsNullOrWhiteSpace(p.QuotaKey))\n                .Select(p => new\n                {\n                    Raw = p,\n                    NormalizedKey = Normalize(p.QuotaKey!)\n                })\n                .ToList();\n\n            if (!incoming.Any())\n                return BadRequest(new { message = \"At least one quota with a QuotaKey is required.\" });\n\n            var keys = incoming\n                .Select(i => i.NormalizedKey)\n                .Distinct()\n                .ToList();\n\n            // ‚úÖ IMPORTANT: bring data into memory first, then call Normalize\n            var existingAllForPlan = await _db.PlanQuotas\n                .Where(q => q.PlanId == planId)\n                .ToListAsync(ct);\n\n            // optional: only keep rows whose normalized key is in payload keys\n            var existing = existingAllForPlan\n                .Where(q => keys.Contains(Normalize(q.QuotaKey)))\n                .ToList();\n            // üëâ NEW: delete quotas that are no longer present in the payload\n            var toDelete = existingAllForPlan\n                .Where(q => !keys.Contains(Normalize(q.QuotaKey)))\n                .ToList();\n\n            if (toDelete.Count > 0)\n            {\n                _db.PlanQuotas.RemoveRange(toDelete);\n            }\n\n            foreach (var item in incoming)\n            {\n                var dto = item.Raw;\n                var normalizedKey = item.NormalizedKey;\n\n                var entity = existing\n                    .FirstOrDefault(q => Normalize(q.QuotaKey) == normalizedKey);\n\n                if (entity is null)\n                {\n                    // Insert new row\n                    entity = new PlanQuota\n                    {\n                        Id = Guid.NewGuid(),\n                        PlanId = planId,\n                        QuotaKey = normalizedKey,\n                        Limit = dto.Limit,\n                        Period = dto.Period,\n                        DenialMessage = dto.DenialMessage,\n                        CreatedAt = DateTime.UtcNow,\n                        UpdatedAt = DateTime.UtcNow\n                    };\n\n                    _db.PlanQuotas.Add(entity);\n                    existing.Add(entity); // keep in local list too\n                }\n                else\n                {\n                    // Update existing row\n                    entity.QuotaKey = normalizedKey;\n                    entity.Limit = dto.Limit;\n                    entity.Period = dto.Period;\n                    entity.DenialMessage = dto.DenialMessage;\n                    entity.UpdatedAt = DateTime.UtcNow;\n                }\n            }\n\n            await _db.SaveChangesAsync(ct);\n            return NoContent();\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/DTOs/BusinessPermissionOverrideDto.cs",
      "sha256": "4d6d1c3548668dc2d58ec10bdf14d99a0040aa00f17e5b9c221c804ef481dd6e",
      "language": "csharp",
      "size": 561,
      "content": "using System;\n\nnamespace xbytechat.api.Features.Entitlements.DTOs\n{\n    public sealed class BusinessPermissionOverrideDto\n    {\n        public Guid Id { get; set; }\n        public Guid BusinessId { get; set; }\n        public string PermissionCode { get; set; } = \"\";\n        public bool IsGranted { get; set; }\n        public bool IsRevoked { get; set; }\n        public string? Reason { get; set; }\n        public DateTime? ExpiresAtUtc { get; set; }\n        public DateTime CreatedAtUtc { get; set; }\n        public DateTime UpdatedAtUtc { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/DTOs/EntitlementCheckDto.cs",
      "sha256": "e3c6863b705bec9193d677f8cf0d408345f812e955b06ffd375f8ef38d9fcb4f",
      "language": "csharp",
      "size": 1422,
      "content": "using System.Collections.Generic;\n\nnamespace xbytechat.api.Features.Entitlements.DTOs\n{\n    public sealed class EntitlementCheckDto\n    {\n        public string QuotaKey { get; set; } = default!;\n        public long Amount { get; set; } = 1;\n        public bool ConsumeOnSuccess { get; set; } = true;\n    }\n\n    public sealed class EntitlementResultDto\n    {\n        public bool Allowed { get; set; }\n        public string QuotaKey { get; set; } = default!;\n        public long? Limit { get; set; }           // null if unlimited\n        public long? Remaining { get; set; }       // null if unlimited\n        public string? Message { get; set; }\n    }\n\n    public sealed class EntitlementsSnapshotDto\n    {\n        public IEnumerable<string> GrantedPermissions { get; set; } = new List<string>();\n        public IEnumerable<QuotaSnapshotItemDto> Quotas { get; set; } = new List<QuotaSnapshotItemDto>();\n    }\n\n    public sealed class QuotaSnapshotItemDto\n    {\n        public string QuotaKey { get; set; } = default!;\n        public string Period { get; set; } = default!; // \"Daily\"/\"Monthly\"/\"Lifetime\"\n        public long? Limit { get; set; }               // null => unlimited\n        public long Consumed { get; set; }\n        public long? Remaining { get; set; }           // null => unlimited\n        public string? DenialMessage { get; set; }\n        public string WindowStartUtc { get; set; } = default!;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/DTOs/PlanQuotaDto.cs",
      "sha256": "eb3560e2218f3b7d2750e2a68fdf6a3f140f99a35665bf31e9d34671ad1611e3",
      "language": "csharp",
      "size": 738,
      "content": "// üìÑ Features/Entitlements/DTOs/PlanQuotaDto.cs\nusing System;\nusing xbytechat.api.Features.Entitlements.Models;\n\nnamespace xbytechat.api.Features.Entitlements.DTOs\n{\n    /// <summary>\n    /// Admin-facing DTO for default quotas configured per plan.\n    /// </summary>\n    public sealed class PlanQuotaDto\n    {\n        public Guid Id { get; set; }\n\n        public Guid PlanId { get; set; }\n\n        // Canonical key, e.g. \"MESSAGES_PER_MONTH\"\n        public string QuotaKey { get; set; } = string.Empty;\n\n        // -1 => unlimited\n        public long Limit { get; set; }\n\n        public QuotaPeriod Period { get; set; }\n\n        // Optional UX text used when quota is denied\n        public string? DenialMessage { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/DTOs/UpsertBusinessPermissionOverrideDto.cs",
      "sha256": "47e05889e89c82df2a1179abc49c58d3bbbdf5bc41a8ea8b211c4ff7fd41045e",
      "language": "csharp",
      "size": 410,
      "content": "using System;\n\nnamespace xbytechat.api.Features.Entitlements.DTOs\n{\n    public sealed class UpsertBusinessPermissionOverrideDto\n    {\n        public string PermissionCode { get; set; } = \"\";\n        public bool IsGranted { get; set; }           // true = grant, false = deny\n        public string? Reason { get; set; }\n        public DateTime? ExpiresAtUtc { get; set; }   // optional temporary unlock\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Models/BusinessPermissionOverride.cs",
      "sha256": "907872c4ee9b0aa63e85ed3d353d11cee3d8ee71af448f037371e95381d071d4",
      "language": "csharp",
      "size": 2004,
      "content": "using System;\nusing xbytechat.api.Features.AccessControl.Models;\nusing xbytechat.api.Features.BusinessModule.Models;\nusing xbytechat.api.Models.BusinessModel;\n\nnamespace xbytechat.api.Features.Entitlements.Models\n{\n    /// <summary>\n    /// Business-level permission override.\n    /// Used ONLY by internal admins (SuperAdmin/Partner/Reseller) to grant/deny permissions\n    /// beyond plan defaults (VIP, pilots, temporary unlocks).\n    ///\n    /// NOTE:\n    /// - This overrides PLAN-level availability for a business.\n    /// - It still should NOT bypass ROLE limitations when computing \"effective permissions\"\n    ///   for a staff user (we will enforce that in the entitlement calculation step).\n    /// </summary>\n    public sealed class BusinessPermissionOverride\n    {\n        public Guid Id { get; set; } = Guid.NewGuid();\n\n        public Guid BusinessId { get; set; }\n        public Business? Business { get; set; }\n\n        public Guid PermissionId { get; set; }\n        public Permission? Permission { get; set; }\n\n        /// <summary>\n        /// true = grant, false = deny.\n        /// </summary>\n        public bool IsGranted { get; set; }\n\n        /// <summary>\n        /// Soft revoke / disable the override.\n        /// </summary>\n        public bool IsRevoked { get; set; }\n\n        /// <summary>\n        /// Optional reason for auditability (VIP deal, pilot, migration, support).\n        /// </summary>\n        public string? Reason { get; set; }\n\n        /// <summary>\n        /// Optional expiry for temporary unlocks.\n        /// If set and expired, override should be ignored by entitlement computation.\n        /// </summary>\n        public DateTime? ExpiresAtUtc { get; set; }\n\n        /// <summary>\n        /// Who applied this override (admin user id).\n        /// </summary>\n        public Guid? CreatedByUserId { get; set; }\n\n        public DateTime CreatedAtUtc { get; set; } = DateTime.UtcNow;\n        public DateTime UpdatedAtUtc { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Models/BusinessQuotaOverride.cs",
      "sha256": "b1f87eedb2763fc2bb19f50e1a992e2d4adb2e86477ab1f04f0b3bd6f9a17fb6",
      "language": "csharp",
      "size": 848,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace xbytechat.api.Features.Entitlements.Models\n{\n    [Table(\"BusinessQuotaOverrides\")]\n    public sealed class BusinessQuotaOverride\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        [Required]\n        public Guid BusinessId { get; set; }\n\n        [Required, MaxLength(128)]\n        public string QuotaKey { get; set; } = default!; // same key as PlanQuota\n\n        public long? Limit { get; set; }     // null => fallback to plan\n        public bool? IsUnlimited { get; set; } // true => unlimited regardless of plan\n\n        public DateTime? ExpiresAt { get; set; } // null => permanent\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n        public DateTime? UpdatedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Models/BusinessUsageCounter.cs",
      "sha256": "85f37a61b7bf3227782bc452a7088746e129334cf37722d55a788faac363a1fc",
      "language": "csharp",
      "size": 928,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\nusing xbytechat.api.Features.Entitlements.Models;\n\nnamespace xbytechat.api.Features.Entitlements.Models\n{\n    [Table(\"BusinessUsageCounters\")]\n    public sealed class BusinessUsageCounter\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        [Required]\n        public Guid BusinessId { get; set; }\n\n        [Required, MaxLength(128)]\n        public string QuotaKey { get; set; } = default!;\n\n        public QuotaPeriod Period { get; set; }\n\n        // To support resets, store the window start for this counter.\n        public DateTime WindowStartUtc { get; set; }\n\n        // Current consumed units within the window.\n        public long Consumed { get; set; }\n\n        public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Models/PlanQuota.cs",
      "sha256": "215c4b1b07bd49b5499c1f3f1435739fd47ce44cc493aca1925d91e20c441573",
      "language": "csharp",
      "size": 989,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\nusing xbytechat.api.Features.Entitlements.Models;\n\nnamespace xbytechat.api.Features.Entitlements.Models\n{\n    [Table(\"PlanQuotas\")]\n    public sealed class PlanQuota\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        [Required]\n        public Guid PlanId { get; set; } // FK to AccessControl Plan\n\n        // Case-insensitive programmatic key, e.g., \"MessagesPerMonth\"\n        [Required, MaxLength(128)]\n        public string QuotaKey { get; set; } = default!;\n\n        public long Limit { get; set; }            // -1 => unlimited\n        public QuotaPeriod Period { get; set; }    // Daily/Monthly/Lifetime\n\n        // Optional UX copy shown to user on denial\n        [MaxLength(256)]\n        public string? DenialMessage { get; set; }\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n        public DateTime? UpdatedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Models/QuotaPeriod.cs",
      "sha256": "375d8f9e16fc912410137ae6208999b6580602bb4635bd5180e67f40ca8a1da7",
      "language": "csharp",
      "size": 189,
      "content": "namespace xbytechat.api.Features.Entitlements.Models\n{\n    public enum QuotaPeriod\n    {\n        Lifetime = 0,  // never resets automatically\n        Daily = 1,\n        Monthly = 2\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/QuotaKeys.cs",
      "sha256": "14149e987392ec3d22e757e52540d860518860a40a594846459035ec0428eec6",
      "language": "csharp",
      "size": 591,
      "content": "// üìÑ Features/Entitlements/QuotaKeys.cs\nnamespace xbytechat.api.Features.Entitlements\n{\n\n    public static class QuotaKeys\n    {\n        // How many messages a business can send in a given period (usually Monthly)\n        public const string MessagesPerMonth = \"MESSAGES_PER_MONTH\";\n\n        public const string MessagesPerDay = \"MESSAGES_PER_DAY\";\n        // How many campaigns can be sent per day\n        public const string CampaignsPerDay = \"CAMPAIGNS_PER_DAY\";\n\n        // How many templates can exist in total\n        public const string TemplatesTotal = \"TEMPLATES_TOTAL\";\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Seed/EntitlementsSeeder.cs",
      "sha256": "39a6c25c6d3cda63542eea996b67df2e21973a2afb10a93da008b33613f626d5",
      "language": "csharp",
      "size": 1273,
      "content": "using System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Entitlements.Models;\nusing Microsoft.EntityFrameworkCore;\n\nnamespace xbytechat.api.Features.Entitlements.Seed\n{\n    public static class EntitlementsSeeder\n    {\n        public static async Task SeedAsync(AppDbContext db, Guid planId)\n        {\n            var defaults = new[]\n            {\n                new PlanQuota { Id = Guid.NewGuid(), PlanId = planId, QuotaKey = \"MESSAGES_PER_MONTH\", Limit = 10000, Period = QuotaPeriod.Monthly, DenialMessage = \"Monthly message limit reached.\" },\n                new PlanQuota { Id = Guid.NewGuid(), PlanId = planId, QuotaKey = \"CAMPAIGNS_PER_DAY\",   Limit = 10,    Period = QuotaPeriod.Daily,   DenialMessage = \"Daily campaign limit reached.\" },\n                new PlanQuota { Id = Guid.NewGuid(), PlanId = planId, QuotaKey = \"TEMPLATES_TOTAL\",     Limit = -1,    Period = QuotaPeriod.Lifetime } // unlimited\n            };\n\n            foreach (var q in defaults)\n            {\n                var exists = await db.PlanQuotas.AnyAsync(p => p.PlanId == planId && p.QuotaKey.ToUpper() == q.QuotaKey.ToUpper());\n                if (!exists) db.PlanQuotas.Add(q);\n            }\n            await db.SaveChangesAsync();\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Services/BusinessPermissionOverrideService.cs",
      "sha256": "f1476ef9f4df036296db1c58cc8dd4c56abf0bd53d73d89d4539f24a4a506984",
      "language": "csharp",
      "size": 4988,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.Entitlements.DTOs;\nusing xbytechat.api.Features.Entitlements.Models;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.Entitlements.Services\n{\n    public sealed class BusinessPermissionOverrideService : IBusinessPermissionOverrideService\n    {\n        private readonly AppDbContext _db;\n        private readonly ILogger<BusinessPermissionOverrideService> _logger;\n\n        public BusinessPermissionOverrideService(AppDbContext db, ILogger<BusinessPermissionOverrideService> logger)\n        {\n            _db = db;\n            _logger = logger;\n        }\n\n        public async Task<List<BusinessPermissionOverrideDto>> GetAsync(Guid businessId)\n        {\n            var now = DateTime.UtcNow;\n\n            return await _db.BusinessPermissionOverrides\n                .AsNoTracking()\n                .Where(x => x.BusinessId == businessId && !x.IsRevoked)\n                .OrderByDescending(x => x.UpdatedAtUtc)\n                .Select(x => new BusinessPermissionOverrideDto\n                {\n                    Id = x.Id,\n                    BusinessId = x.BusinessId,\n                    PermissionCode = x.Permission!.Code,\n                    IsGranted = x.IsGranted,\n                    IsRevoked = x.IsRevoked,\n                    Reason = x.Reason,\n                    ExpiresAtUtc = x.ExpiresAtUtc,\n                    CreatedAtUtc = x.CreatedAtUtc,\n                    UpdatedAtUtc = x.UpdatedAtUtc\n                })\n                .ToListAsync();\n        }\n\n        public async Task<ResponseResult> UpsertAsync(Guid businessId, Guid actorUserId, UpsertBusinessPermissionOverrideDto dto)\n        {\n            var code = (dto.PermissionCode ?? \"\").Trim();\n            if (string.IsNullOrWhiteSpace(code))\n                return ResponseResult.ErrorInfo(\"‚ùå PermissionCode is required.\");\n\n            var perm = await _db.Permissions.FirstOrDefaultAsync(p => p.IsActive && p.Code == code.ToUpper());\n            if (perm == null)\n                return ResponseResult.ErrorInfo(\"‚ùå Invalid permission code.\");\n\n            var row = await _db.BusinessPermissionOverrides\n                .FirstOrDefaultAsync(x => x.BusinessId == businessId && x.PermissionId == perm.Id);\n\n            if (row == null)\n            {\n                row = new BusinessPermissionOverride\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    PermissionId = perm.Id,\n                    IsGranted = dto.IsGranted,\n                    IsRevoked = false,\n                    Reason = dto.Reason?.Trim(),\n                    ExpiresAtUtc = dto.ExpiresAtUtc,\n                    CreatedByUserId = actorUserId,\n                    CreatedAtUtc = DateTime.UtcNow,\n                    UpdatedAtUtc = DateTime.UtcNow\n                };\n                _db.BusinessPermissionOverrides.Add(row);\n            }\n            else\n            {\n                row.IsGranted = dto.IsGranted;\n                row.IsRevoked = false;\n                row.Reason = dto.Reason?.Trim();\n                row.ExpiresAtUtc = dto.ExpiresAtUtc;\n                row.UpdatedAtUtc = DateTime.UtcNow;\n            }\n\n            await _db.SaveChangesAsync();\n\n            _logger.LogInformation(\"‚úÖ Business permission override upserted. BusinessId={BusinessId}, Permission={Permission}, Granted={Granted}, ActorUserId={ActorUserId}\",\n                businessId, perm.Code, dto.IsGranted, actorUserId);\n\n            return ResponseResult.SuccessInfo(\"‚úÖ Override saved.\");\n        }\n\n        public async Task<ResponseResult> RevokeByPermissionCodeAsync(Guid businessId, Guid actorUserId, string permissionCode)\n        {\n            var code = (permissionCode ?? \"\").Trim();\n            if (string.IsNullOrWhiteSpace(code))\n                return ResponseResult.ErrorInfo(\"‚ùå PermissionCode is required.\");\n\n            var perm = await _db.Permissions.FirstOrDefaultAsync(p => p.IsActive && p.Code == code.ToUpper());\n            if (perm == null)\n                return ResponseResult.ErrorInfo(\"‚ùå Invalid permission code.\");\n\n            var row = await _db.BusinessPermissionOverrides\n                .FirstOrDefaultAsync(x => x.BusinessId == businessId && x.PermissionId == perm.Id && !x.IsRevoked);\n\n            if (row == null)\n                return ResponseResult.ErrorInfo(\"‚ùå Override not found.\");\n\n            row.IsRevoked = true;\n            row.UpdatedAtUtc = DateTime.UtcNow;\n\n            await _db.SaveChangesAsync();\n\n            _logger.LogInformation(\"‚úÖ Business permission override revoked. BusinessId={BusinessId}, Permission={Permission}, ActorUserId={ActorUserId}\",\n                businessId, perm.Code, actorUserId);\n\n            return ResponseResult.SuccessInfo(\"‚úÖ Override revoked.\");\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Services/IBusinessPermissionOverrideService.cs",
      "sha256": "39241c7ba297699b2f42ead4ecbf93f50ac5e3c1de7a5301519a5e43b9753641",
      "language": "csharp",
      "size": 594,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Entitlements.DTOs;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.Entitlements.Services\n{\n    public interface IBusinessPermissionOverrideService\n    {\n        Task<List<BusinessPermissionOverrideDto>> GetAsync(Guid businessId);\n        Task<ResponseResult> UpsertAsync(Guid businessId, Guid actorUserId, UpsertBusinessPermissionOverrideDto dto);\n        Task<ResponseResult> RevokeByPermissionCodeAsync(Guid businessId, Guid actorUserId, string permissionCode);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Services/IQuotaService.cs",
      "sha256": "55c9229cb163efbc7ef1621a7f2fa061a1299f8b85046402a2e3708327f41648",
      "language": "csharp",
      "size": 784,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Entitlements.DTOs;\n\nnamespace xbytechat.api.Features.Entitlements.Services\n{\n    public interface IQuotaService\n    {\n        Task<EntitlementResultDto> CheckAsync(Guid businessId, string quotaKey, long amount, CancellationToken ct);\n        Task<EntitlementResultDto> CheckAndConsumeAsync(Guid businessId, string quotaKey, long amount, CancellationToken ct);\n\n        Task<EntitlementsSnapshotDto> GetSnapshotAsync(Guid businessId, CancellationToken ct);\n\n        // Utility to ensure counters are on the correct window (creates or rolls window if needed)\n        Task EnsureWindowAsync(Guid businessId, string quotaKey, CancellationToken ct);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Services/QuotaService.cs",
      "sha256": "40ae3242c46c1445b58726fcc9f0e2c46511b0ca1a783eb400f57767329879aa",
      "language": "csharp",
      "size": 15037,
      "content": "using System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Entitlements.DTOs;\nusing xbytechat.api.Features.Entitlements.Models;\nusing xbytechat.api.Features.Entitlements.Services;\nusing xbytechat.api.Features.AccessControl.Models; // your Plan/PlanPermission namespace as applicable\n\nnamespace xbytechat.api.Features.Entitlements.Services\n{\n    public sealed class QuotaService : IQuotaService\n    {\n        private readonly AppDbContext _db;\n\n        public QuotaService(AppDbContext db)\n        {\n            _db = db;\n        }\n\n        // Normalize keys to uppercase to keep lookups stable on non-CI collations\n        private static string NK(string key) => key.Trim().ToUpperInvariant();\n\n        private static DateTime CurrentWindowStartUtc(QuotaPeriod p, DateTime nowUtc)\n        {\n            return p switch\n            {\n                QuotaPeriod.Daily => new DateTime(nowUtc.Year, nowUtc.Month, nowUtc.Day, 0, 0, 0, DateTimeKind.Utc),\n                QuotaPeriod.Monthly => new DateTime(nowUtc.Year, nowUtc.Month, 1, 0, 0, 0, DateTimeKind.Utc),\n                _ => DateTime.UnixEpoch\n            };\n        }\n\n        private async Task<(QuotaPeriod Period, long? Limit, string? Denial)> ResolveEffectiveLimitAsync(Guid businessId, string quotaKey, CancellationToken ct)\n        {\n            quotaKey = NK(quotaKey);\n\n            // resolve business planId\n            var business = await _db.Businesses\n                .AsNoTracking()\n                .Where(b => b.Id == businessId)\n                .Select(b => new { b.Id, b.PlanId })\n                .FirstOrDefaultAsync(ct);\n\n            if (business is null)\n                return (QuotaPeriod.Lifetime, 0, \"Business not found.\");\n\n            // override first\n            var ovr = await _db.BusinessQuotaOverrides\n                .AsNoTracking()\n                .Where(o => o.BusinessId == businessId && o.QuotaKey.ToUpper() == quotaKey)\n                .FirstOrDefaultAsync(ct);\n\n            if (ovr is not null && (ovr.ExpiresAt == null || ovr.ExpiresAt > DateTime.UtcNow))\n            {\n                if (ovr.IsUnlimited == true)\n                    return (QuotaPeriod.Lifetime, null, null); // unlimited\n\n                if (ovr.Limit.HasValue)\n                {\n                    // Need period: fall back to plan period (must exist)\n                    var pq = await _db.PlanQuotas.AsNoTracking()\n                        .Where(p => p.PlanId == business.PlanId && p.QuotaKey.ToUpper() == quotaKey)\n                        .Select(p => new { p.Period, p.DenialMessage })\n                        .FirstOrDefaultAsync(ct);\n\n                    if (pq is null)\n                        return (QuotaPeriod.Lifetime, ovr.Limit!.Value, null); // custom limit without period -> treat as lifetime\n\n                    return (pq.Period, ovr.Limit!.Value, pq.DenialMessage);\n                }\n                // if override exists but no limit/isUnlimited set, fall back to plan\n            }\n\n            // plan default\n            var planQuota = await _db.PlanQuotas.AsNoTracking()\n                .Where(p => p.PlanId == business.PlanId && p.QuotaKey.ToUpper() == quotaKey)\n                .FirstOrDefaultAsync(ct);\n\n            if (planQuota is null)\n                return (QuotaPeriod.Lifetime, 0, \"Quota not defined for plan.\"); // deny by default\n\n            if (planQuota.Limit < 0)\n                return (planQuota.Period, null, planQuota.DenialMessage); // unlimited\n\n            return (planQuota.Period, planQuota.Limit, planQuota.DenialMessage);\n        }\n\n        private async Task<BusinessUsageCounter> GetOrCreateCounterAsync(Guid businessId, string quotaKey, QuotaPeriod period, CancellationToken ct)\n        {\n            quotaKey = NK(quotaKey);\n            var now = DateTime.UtcNow;\n            var winStart = CurrentWindowStartUtc(period, now);\n\n            var counter = await _db.BusinessUsageCounters.FirstOrDefaultAsync(\n                c => c.BusinessId == businessId && c.QuotaKey.ToUpper() == quotaKey &&\n                     c.Period == period && c.WindowStartUtc == winStart, ct);\n\n            if (counter is not null) return counter;\n\n            counter = new BusinessUsageCounter\n            {\n                Id = Guid.NewGuid(),\n                BusinessId = businessId,\n                QuotaKey = quotaKey,\n                Period = period,\n                WindowStartUtc = winStart,\n                Consumed = 0,\n                CreatedAt = now,\n                UpdatedAt = now\n            };\n            _db.BusinessUsageCounters.Add(counter);\n\n            try\n            {\n                await _db.SaveChangesAsync(ct);\n                return counter;\n            }\n            catch (DbUpdateException)\n            {\n                // Another thread created it; fetch the existing row\n                return await _db.BusinessUsageCounters.FirstAsync(\n                    c => c.BusinessId == businessId && c.QuotaKey.ToUpper() == quotaKey &&\n                         c.Period == period && c.WindowStartUtc == winStart, ct);\n            }\n        }\n\n        public async Task EnsureWindowAsync(Guid businessId, string quotaKey, CancellationToken ct)\n        {\n            var (period, _, _) = await ResolveEffectiveLimitAsync(businessId, quotaKey, ct);\n            await GetOrCreateCounterAsync(businessId, quotaKey, period, ct);\n        }\n\n        public async Task<EntitlementResultDto> CheckAsync(Guid businessId, string quotaKey, long amount, CancellationToken ct)\n        {\n            quotaKey = NK(quotaKey);\n            var (period, limit, denial) = await ResolveEffectiveLimitAsync(businessId, quotaKey, ct);\n\n            if (limit is null) // unlimited\n            {\n                return new EntitlementResultDto\n                {\n                    Allowed = true,\n                    QuotaKey = quotaKey,\n                    Limit = null,\n                    Remaining = null\n                };\n            }\n\n            var counter = await GetOrCreateCounterAsync(businessId, quotaKey, period, ct);\n\n            var remaining = limit.Value - counter.Consumed;\n            var allowed = remaining >= amount;\n\n            return new EntitlementResultDto\n            {\n                Allowed = allowed,\n                QuotaKey = quotaKey,\n                Limit = limit.Value,\n                Remaining = Math.Max(0, remaining),\n                Message = allowed ? null : (denial ?? \"Quota limit reached.\")\n            };\n        }\n\n        public async Task<EntitlementResultDto> CheckAndConsumeAsync(Guid businessId, string quotaKey, long amount, CancellationToken ct)\n        {\n            quotaKey = NK(quotaKey);\n            var (period, limit, denial) = await ResolveEffectiveLimitAsync(businessId, quotaKey, ct);\n\n            if (limit is null) // unlimited\n            {\n                // No increment needed; still return success\n                return new EntitlementResultDto { Allowed = true, QuotaKey = quotaKey, Limit = null, Remaining = null };\n            }\n\n            var now = DateTime.UtcNow;\n            var winStart = CurrentWindowStartUtc(period, now);\n\n            // Atomic consume in a single SQL statement\n            // UPDATE ... SET Consumed = Consumed + @amount WHERE ... AND Consumed + @amount <= @limit\n            var updated = await _db.BusinessUsageCounters\n                .Where(c =>\n                    c.BusinessId == businessId &&\n                    c.QuotaKey.ToUpper() == quotaKey &&\n                    c.Period == period &&\n                    c.WindowStartUtc == winStart &&\n                    c.Consumed + amount <= limit.Value)\n                .ExecuteUpdateAsync(up =>\n                    up.SetProperty(c => c.Consumed, c => c.Consumed + amount)\n                      .SetProperty(c => c.UpdatedAt, _ => now), ct);\n\n            if (updated == 0)\n            {\n                // Ensure the row exists; if missing, create and retry once\n                var existed = await _db.BusinessUsageCounters.AnyAsync(c =>\n                    c.BusinessId == businessId &&\n                    c.QuotaKey.ToUpper() == quotaKey &&\n                    c.Period == period &&\n                    c.WindowStartUtc == winStart, ct);\n\n                if (!existed)\n                {\n                    var counter = new BusinessUsageCounter\n                    {\n                        Id = Guid.NewGuid(),\n                        BusinessId = businessId,\n                        QuotaKey = quotaKey,\n                        Period = period,\n                        WindowStartUtc = winStart,\n                        Consumed = 0,\n                        CreatedAt = now,\n                        UpdatedAt = now\n                    };\n                    _db.BusinessUsageCounters.Add(counter);\n                    await _db.SaveChangesAsync(ct);\n\n                    // retry atomic consume\n                    updated = await _db.BusinessUsageCounters\n                        .Where(c =>\n                            c.BusinessId == businessId &&\n                            c.QuotaKey.ToUpper() == quotaKey &&\n                            c.Period == period &&\n                            c.WindowStartUtc == winStart &&\n                            c.Consumed + amount <= limit.Value)\n                        .ExecuteUpdateAsync(up =>\n                            up.SetProperty(c => c.Consumed, c => c.Consumed + amount)\n                              .SetProperty(c => c.UpdatedAt, _ => now), ct);\n                }\n            }\n\n            if (updated == 0)\n            {\n                // Denied\n                var current = await _db.BusinessUsageCounters.AsNoTracking()\n                    .Where(c =>\n                        c.BusinessId == businessId &&\n                        c.QuotaKey.ToUpper() == quotaKey &&\n                        c.Period == period &&\n                        c.WindowStartUtc == winStart)\n                    .Select(c => c.Consumed)\n                    .FirstOrDefaultAsync(ct);\n\n                var remaining = Math.Max(0, limit.Value - current);\n\n                return new EntitlementResultDto\n                {\n                    Allowed = false,\n                    QuotaKey = quotaKey,\n                    Limit = limit.Value,\n                    Remaining = remaining,\n                    Message = denial ?? \"Quota limit reached.\"\n                };\n            }\n\n            // Success path‚Äîfetch updated consumed to compute remaining\n            var consumed = await _db.BusinessUsageCounters.AsNoTracking()\n                .Where(c =>\n                    c.BusinessId == businessId &&\n                    c.QuotaKey.ToUpper() == quotaKey &&\n                    c.Period == period &&\n                    c.WindowStartUtc == winStart)\n                .Select(c => c.Consumed)\n                .FirstAsync(ct);\n\n            return new EntitlementResultDto\n            {\n                Allowed = true,\n                QuotaKey = quotaKey,\n                Limit = limit.Value,\n                Remaining = Math.Max(0, limit.Value - consumed)\n            };\n        }\n\n        public async Task<EntitlementsSnapshotDto> GetSnapshotAsync(Guid businessId, CancellationToken ct)\n        {\n            // Resolve plan once\n            var planId = await _db.Businesses.AsNoTracking()\n                .Where(b => b.Id == businessId)\n                .Select(b => b.PlanId)\n                .FirstAsync(ct);\n\n            var now = DateTime.UtcNow;\n\n            // ‚úÖ Permission codes for this plan (base)\n            var planPerms = await _db.PlanPermissions\n                .AsNoTracking()\n                .Where(pp => pp.PlanId == planId && pp.IsActive && pp.Permission.IsActive)\n                .Select(pp => pp.Permission.Code)\n                .ToListAsync(ct);\n\n            // ‚úÖ Make it mutable + deduped\n            var grantedSet = new HashSet<string>(planPerms, StringComparer.OrdinalIgnoreCase);\n\n            // ‚úÖ Apply BUSINESS permission overrides (grant adds, deny removes)\n            // Keeps /entitlements snapshot aligned with JWT minting logic in AuthService\n            var permOverrides = await _db.BusinessPermissionOverrides\n                .AsNoTracking()\n                .Where(o =>\n                    o.BusinessId == businessId &&\n                    !o.IsRevoked &&\n                    (o.ExpiresAtUtc == null || o.ExpiresAtUtc > now) &&\n                    o.Permission.IsActive)\n                .Select(o => new\n                {\n                    Code = o.Permission.Code,\n                    o.IsGranted\n                })\n                .ToListAsync(ct);\n\n            foreach (var o in permOverrides)\n            {\n                if (string.IsNullOrWhiteSpace(o.Code)) continue;\n\n                if (o.IsGranted)\n                    grantedSet.Add(o.Code);\n                else\n                    grantedSet.Remove(o.Code);\n            }\n\n            // Quotas ‚Äì sequential to avoid DbContext concurrency issues\n            var planQuotas = await _db.PlanQuotas.AsNoTracking()\n                .Where(pq => pq.PlanId == planId)\n                .ToListAsync(ct);\n\n            var overrides = await _db.BusinessQuotaOverrides.AsNoTracking()\n                .Where(o => o.BusinessId == businessId &&\n                            (o.ExpiresAt == null || o.ExpiresAt > now))\n                .ToListAsync(ct);\n\n            var items = new List<QuotaSnapshotItemDto>();\n\n            foreach (var pq in planQuotas)\n            {\n                var key = NK(pq.QuotaKey);\n\n                long? limit = overrides.FirstOrDefault(o => NK(o.QuotaKey) == key) is { } o\n                    ? (o.IsUnlimited == true ? null : o.Limit ?? (pq.Limit < 0 ? (long?)null : pq.Limit))\n                    : (pq.Limit < 0 ? (long?)null : pq.Limit);\n\n                var winStart = CurrentWindowStartUtc(pq.Period, now);\n\n                var consumed = await _db.BusinessUsageCounters.AsNoTracking()\n                    .Where(c => c.BusinessId == businessId &&\n                                c.QuotaKey.ToUpper() == key &&\n                                c.Period == pq.Period &&\n                                c.WindowStartUtc == winStart)\n                    .Select(c => c.Consumed)\n                    .FirstOrDefaultAsync(ct);\n\n                items.Add(new QuotaSnapshotItemDto\n                {\n                    QuotaKey = key,\n                    Period = pq.Period.ToString(),\n                    Limit = limit,\n                    Consumed = consumed,\n                    Remaining = limit is null ? null : Math.Max(0, limit.Value - consumed),\n                    DenialMessage = pq.DenialMessage,\n                    WindowStartUtc = winStart.ToString(\"u\")\n                });\n            }\n\n            return new EntitlementsSnapshotDto\n            {\n                GrantedPermissions = grantedSet.OrderBy(x => x).ToList(),\n                Quotas = items\n            };\n        }\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Abstractions/IEsuStatusService.cs",
      "sha256": "825a494d506b60064b1f3811f94cece207f3feb402079cf5371171bb0752d168",
      "language": "csharp",
      "size": 420,
      "content": "#nullable enable\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.ESU.Facebook.DTOs;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Abstractions\n{\n    public interface IEsuStatusService\n    {\n        Task<EsuStatusDto> GetStatusAsync(Guid businessId, CancellationToken ct = default);\n        Task DeauthorizeAsync(Guid businessId, CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Abstractions/IEsuTokenStore.cs",
      "sha256": "19575329bfc016c7842b626d8c6403ee75cb77797bf8caad98b983aa2eed6af2",
      "language": "csharp",
      "size": 517,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.ESU.Facebook.Models;\n\npublic interface IEsuTokenStore\n{\n    Task<EsuToken?> GetAsync(Guid businessId, string provider, CancellationToken ct);\n    Task UpsertAsync(Guid businessId, string provider, string token, DateTime? expiresAtUtc, CancellationToken ct);\n    Task RevokeAsync(Guid businessId, string provider, CancellationToken ct);\n\n    Task DeleteAsync(Guid biz, string provider, CancellationToken ct = default);\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Abstractions/IFacebookGraphClient.cs",
      "sha256": "448400005f2e87088712cdae60bb312c7a1474b18d8702fb89188c8bbf6cee4a",
      "language": "csharp",
      "size": 421,
      "content": "#nullable enable\nusing System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Abstractions\n{\n    public interface IFacebookGraphClient\n    {\n        Task<T> GetAsync<T>(\n            Guid businessId,\n            string path,\n            IDictionary<string, string?>? query = null,\n            CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Abstractions/IFacebookOauthClient.cs",
      "sha256": "aa56a723ee19e25ace745f273354e63ff103c42ebeb81e8d32fd05ad55db8301",
      "language": "csharp",
      "size": 737,
      "content": "#nullable enable\nusing System.Threading;\nusing System.Threading.Tasks;\nusing FbContracts = xbytechat.api.Features.ESU.Facebook.Contracts;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Abstractions\n{\n    /// <summary>Handles the OAuth \"code ‚Üí access_token\" exchanges with Facebook Graph API.</summary>\n    public interface IFacebookOauthClient\n    {\n        Task<FbContracts.FacebookTokenResponse> ExchangeCodeAsync(string code, CancellationToken ct = default);\n\n        /// <summary>Swap short-lived token for a ~60-day long-lived token.</summary>\n        Task<FbContracts.FacebookTokenResponse> ExchangeForLongLivedAsync(\n            FbContracts.FacebookTokenResponse shortToken,\n            CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Abstractions/IFacebookTokenService.cs",
      "sha256": "1f2bd9d86694df46bd6f415d4246e249ebca0ad878762d4ec30a27f251e4d270",
      "language": "csharp",
      "size": 1029,
      "content": "#nullable enable\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.ESU.Facebook.Contracts;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Abstractions\n{\n    /// <summary>Retrieves a Facebook access token for a business with expiry checks and caching.</summary>\n    public interface IFacebookTokenService\n    {\n        /// <summary>\n        /// Returns a stored token if it exists and is not near expiry. Returns null if missing/expired.\n        /// </summary>\n        Task<FacebookStoredToken?> TryGetValidAsync(Guid businessId, CancellationToken ct = default);\n\n        /// <summary>\n        /// Throws if missing/expired. Use when a valid token is required for an operation.\n        /// </summary>\n        Task<FacebookStoredToken> GetRequiredAsync(Guid businessId, CancellationToken ct = default);\n\n        Task<string?> GetAccessTokenAsync(Guid businessId, CancellationToken ct = default);\n        Task InvalidateAsync(Guid businessId, CancellationToken ct = default);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Clients/FacebookGraphClient.cs",
      "sha256": "c96cd6ce910b95deff6df835e53329da4603f69b2230d7e5f149a92aa2451ca9",
      "language": "csharp",
      "size": 3678,
      "content": "#nullable enable\nusing System;\nusing System.Collections.Generic;\nusing System.Net.Http;\nusing System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.WebUtilities;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing xbytechat.api.Features.ESU.Facebook.Abstractions;\nusing xbytechat.api.Features.ESU.Facebook.Contracts;\nusing xbytechat.api.Features.ESU.Facebook.Options;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Clients\n{\n    internal sealed class FacebookGraphClient : IFacebookGraphClient\n    {\n        private static readonly JsonSerializerOptions JsonOpts = new(JsonSerializerDefaults.Web)\n        { PropertyNameCaseInsensitive = true, WriteIndented = false };\n\n        private readonly HttpClient _http;\n        private readonly ILogger<FacebookGraphClient> _log;\n        private readonly FacebookOauthOptions _opt;\n        private readonly IFacebookTokenService _tokens;\n\n        public FacebookGraphClient(\n            HttpClient http,\n            IOptions<FacebookOauthOptions> opt,\n            IFacebookTokenService tokens,\n            ILogger<FacebookGraphClient> log)\n        {\n            _http = http;\n            _opt = opt.Value;\n            _tokens = tokens;\n            _log = log;\n        }\n\n        public async Task<T> GetAsync<T>(\n            Guid businessId,\n            string path,\n            IDictionary<string, string?>? query = null,\n            CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty) throw new ArgumentException(\"businessId is required\", nameof(businessId));\n            if (string.IsNullOrWhiteSpace(path)) throw new ArgumentException(\"path is required\", nameof(path));\n\n            // 1) Get (valid) token\n            var token = await _tokens.GetRequiredAsync(businessId, ct).ConfigureAwait(false);\n\n            // 2) Build URL\n            var baseUrl = _opt.GraphBaseUrl.TrimEnd('/');\n            var ver = _opt.GraphApiVersion.Trim('/');\n            var url = $\"{baseUrl}/{ver}/{path.TrimStart('/')}\";\n\n            var finalUrl = query is null ? url : QueryHelpers.AddQueryString(url, query);\n\n            using var req = new HttpRequestMessage(HttpMethod.Get, finalUrl);\n            req.Headers.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue(\"Bearer\", token.AccessToken);\n\n            using var res = await _http.SendAsync(req, HttpCompletionOption.ResponseHeadersRead, ct).ConfigureAwait(false);\n            var raw = await res.Content.ReadAsStringAsync(ct).ConfigureAwait(false);\n\n            if (!res.IsSuccessStatusCode)\n            {\n                FacebookErrorResponse? err = null;\n                try { err = JsonSerializer.Deserialize<FacebookErrorResponse>(raw, JsonOpts); } catch { /* ignore */ }\n\n                var msg = err?.Error?.Message ?? $\"Graph GET {path} failed with HTTP {(int)res.StatusCode}\";\n                _log.LogWarning(\"Graph error: {Msg}. Raw: {Raw}\", msg, Truncate(raw, 1000));\n\n                throw new FacebookGraphException(\n                    msg, err?.Error?.Type, err?.Error?.Code, err?.Error?.SubCode, err?.Error?.TraceId);\n            }\n\n            try\n            {\n                return JsonSerializer.Deserialize<T>(raw, JsonOpts)\n                       ?? throw new InvalidOperationException(\"Graph response was empty.\");\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"Failed to parse Graph response for {Path}. Raw: {Raw}\", path, Truncate(raw, 1200));\n                throw;\n            }\n        }\n\n        private static string Truncate(string s, int max) => s.Length <= max ? s : s[..max];\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Clients/FacebookOauthClient.cs",
      "sha256": "d1b8fc306fc457f35cb0045bda912fd55b330abf64ba8de608dd26551ac3292a",
      "language": "csharp",
      "size": 7536,
      "content": "#nullable enable\nusing System;\nusing System.Net.Http;\nusing System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing FbContracts = xbytechat.api.Features.ESU.Facebook.Contracts;\nusing xbytechat.api.Features.ESU.Facebook.Abstractions;\nusing xbytechat.api.Features.ESU.Facebook.Options;\nusing xbytechat.api.Features.ESU.Facebook.Contracts;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Clients\n{\n    internal sealed class FacebookOauthClient : IFacebookOauthClient\n    {\n        private static readonly JsonSerializerOptions JsonOpts = new(JsonSerializerDefaults.Web)\n        { PropertyNameCaseInsensitive = true, WriteIndented = false };\n\n        private readonly HttpClient _http;\n        private readonly ILogger<FacebookOauthClient> _log;\n        private readonly FacebookOauthOptions _opt;\n\n        public FacebookOauthClient(HttpClient http, IOptions<FacebookOauthOptions> opt, ILogger<FacebookOauthClient> log)\n        {\n            _http = http ?? throw new ArgumentNullException(nameof(http));\n            _log = log ?? throw new ArgumentNullException(nameof(log));\n            _opt = opt?.Value ?? throw new ArgumentNullException(nameof(opt));\n        }\n\n        public async Task<FbContracts.FacebookTokenResponse> ExchangeCodeAsync(string code, CancellationToken ct = default)\n        {\n            if (string.IsNullOrWhiteSpace(code))\n                throw new ArgumentException(\"Authorization code must be provided.\", nameof(code));\n\n            var baseUri = _opt.GraphBaseUrl.TrimEnd('/');\n            var version = _opt.GraphApiVersion.Trim('/');\n            var path = $\"{baseUri}/{version}/oauth/access_token\";\n\n            var uri = new UriBuilder(path)\n            {\n                Query =\n                    $\"client_id={Uri.EscapeDataString(_opt.AppId)}\" +\n                    $\"&redirect_uri={Uri.EscapeDataString(_opt.RedirectUri)}\" +\n                    $\"&client_secret={Uri.EscapeDataString(_opt.AppSecret)}\" +\n                    $\"&code={Uri.EscapeDataString(code)}\"\n            }.Uri;\n\n            _log.LogInformation(\"Exchanging Facebook OAuth code for token via {Uri}\", uri.GetLeftPart(UriPartial.Path));\n\n            using var req = new HttpRequestMessage(HttpMethod.Get, uri);\n            using var res = await _http.SendAsync(req, HttpCompletionOption.ResponseHeadersRead, ct).ConfigureAwait(false);\n            var raw = await res.Content.ReadAsStringAsync(ct).ConfigureAwait(false);\n\n            if (!res.IsSuccessStatusCode)\n            {\n                FbContracts.FacebookErrorResponse? fbErr = null;\n                try { fbErr = JsonSerializer.Deserialize<FbContracts.FacebookErrorResponse>(raw, JsonOpts); } catch { }\n\n                var message = fbErr?.Error?.Message ?? $\"Facebook token exchange failed with HTTP {(int)res.StatusCode}\";\n                _log.LogWarning(\"Facebook OAuth error: {Message}. Raw: {Raw}\", message, Truncate(raw, 1000));\n                throw new InvalidOperationException(\n                    $\"Facebook OAuth error: {message} (type={fbErr?.Error?.Type}, code={fbErr?.Error?.Code}, subcode={fbErr?.Error?.SubCode})\");\n            }\n\n            FbContracts.FacebookTokenResponse? token;\n            try { token = JsonSerializer.Deserialize<FbContracts.FacebookTokenResponse>(raw, JsonOpts); }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"Failed to parse Facebook token response. Raw: {Raw}\", Truncate(raw, 1000));\n                throw;\n            }\n\n            if (token is null || string.IsNullOrWhiteSpace(token.AccessToken))\n            {\n                _log.LogError(\"Facebook token response missing access_token. Raw: {Raw}\", Truncate(raw, 1000));\n                throw new InvalidOperationException(\"Facebook token response missing access_token.\");\n            }\n\n            // attach raw JSON for auditing\n            token = new FbContracts.FacebookTokenResponse\n            {\n                AccessToken = token.AccessToken,\n                TokenType = token.TokenType,\n                ExpiresInSeconds = token.ExpiresInSeconds,\n                RawJson = raw\n            };\n\n            _log.LogInformation(\"Facebook OAuth token exchange succeeded. ExpiresIn(s)={Expires}\", token.ExpiresInSeconds);\n            return token;\n        }\n        public async Task<FbContracts.FacebookTokenResponse> ExchangeForLongLivedAsync(\n      FbContracts.FacebookTokenResponse shortToken,\n      CancellationToken ct = default)\n        {\n            if (shortToken is null || string.IsNullOrWhiteSpace(shortToken.AccessToken))\n                throw new ArgumentException(\"Short-lived token is required.\", nameof(shortToken));\n\n            var baseUri = _opt.GraphBaseUrl.TrimEnd('/');\n            var version = _opt.GraphApiVersion.Trim('/'); // e.g., v20.0\n            var path = $\"{baseUri}/{version}/oauth/access_token\";\n\n            var uri = new UriBuilder(path)\n            {\n                Query =\n                    \"grant_type=fb_exchange_token\" +\n                    $\"&client_id={Uri.EscapeDataString(_opt.AppId)}\" +\n                    $\"&client_secret={Uri.EscapeDataString(_opt.AppSecret)}\" +\n                    $\"&fb_exchange_token={Uri.EscapeDataString(shortToken.AccessToken)}\"\n            }.Uri;\n\n            _log.LogInformation(\"Exchanging short-lived token for long-lived via {Uri}\", uri.GetLeftPart(UriPartial.Path));\n\n            using var req = new HttpRequestMessage(HttpMethod.Get, uri);\n            using var res = await _http.SendAsync(req, HttpCompletionOption.ResponseHeadersRead, ct).ConfigureAwait(false);\n            var raw = await res.Content.ReadAsStringAsync(ct).ConfigureAwait(false);\n\n            if (!res.IsSuccessStatusCode)\n            {\n                FbContracts.FacebookErrorResponse? fbErr = null;\n                try { fbErr = JsonSerializer.Deserialize<FbContracts.FacebookErrorResponse>(raw, JsonOpts); } catch { }\n\n                var message = fbErr?.Error?.Message ?? $\"Facebook long-lived exchange failed with HTTP {(int)res.StatusCode}\";\n                _log.LogWarning(\"Facebook OAuth long-lived error: {Message}. Raw: {Raw}\", message, Truncate(raw, 1000));\n                throw new InvalidOperationException(\n                    $\"Facebook OAuth error: {message} (type={fbErr?.Error?.Type}, code={fbErr?.Error?.Code}, subcode={fbErr?.Error?.SubCode})\");\n            }\n\n            FbContracts.FacebookTokenResponse? token;\n            try { token = JsonSerializer.Deserialize<FbContracts.FacebookTokenResponse>(raw, JsonOpts); }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"Failed to parse long-lived token response. Raw: {Raw}\", Truncate(raw, 1000));\n                throw;\n            }\n\n            if (token is null || string.IsNullOrWhiteSpace(token.AccessToken))\n            {\n                _log.LogError(\"Long-lived token response missing access_token. Raw: {Raw}\", Truncate(raw, 1000));\n                throw new InvalidOperationException(\"Invalid long-lived token response.\");\n            }\n\n            return new FbContracts.FacebookTokenResponse\n            {\n                AccessToken = token.AccessToken,\n                TokenType = token.TokenType,\n                ExpiresInSeconds = token.ExpiresInSeconds, // usually ~5,184,000 (60 days)\n                RawJson = raw\n            };\n        }\n\n\n        private static string Truncate(string input, int max) => input.Length <= max ? input : input[..max];\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Clients/IWabaSubscriptionClient.cs",
      "sha256": "80dc2ee9eec97b6012e5c11639cfe6a22593a514dd264a04a8b654a7fc18ddef",
      "language": "csharp",
      "size": 364,
      "content": "using System.Threading;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Clients\n{\n    public interface IWabaSubscriptionClient\n    {\n        Task SubscribeAsync(string wabaId, string accessToken, CancellationToken ct = default);\n        Task UnsubscribeAsync(string wabaId, string accessToken, CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Clients/WabaSubscriptionClient.cs",
      "sha256": "82b27b0686eb6c219a05a6be7c40c9ea493dd0a76bf2b9427a2ca5fc3dd0eabb",
      "language": "csharp",
      "size": 3613,
      "content": "using System;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing xbytechat.api.Features.ESU.Facebook.Options;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Clients\n{\n    internal sealed class WabaSubscriptionClient : IWabaSubscriptionClient\n    {\n        private readonly IHttpClientFactory _httpFactory;\n        private readonly FacebookOptions _fb;\n        private readonly ILogger<WabaSubscriptionClient> _log;\n\n        public WabaSubscriptionClient(\n            IHttpClientFactory httpFactory,\n            IOptions<FacebookOptions> fb,\n            ILogger<WabaSubscriptionClient> log)\n        {\n            _httpFactory = httpFactory;\n            _fb = fb.Value;\n            _log = log;\n        }\n\n        public async Task SubscribeAsync(string wabaId, string accessToken, CancellationToken ct = default)\n        {\n            if (string.IsNullOrWhiteSpace(wabaId)) throw new ArgumentException(\"wabaId is required\", nameof(wabaId));\n            if (string.IsNullOrWhiteSpace(accessToken)) throw new ArgumentException(\"accessToken is required\", nameof(accessToken));\n\n            var baseUrl = string.IsNullOrWhiteSpace(_fb.GraphBaseUrl) ? \"https://graph.facebook.com\" : _fb.GraphBaseUrl!;\n            var version = string.IsNullOrWhiteSpace(_fb.GraphApiVersion) ? \"v22.0\" : _fb.GraphApiVersion!;\n            var url = $\"{baseUrl.TrimEnd('/')}/{version}/{wabaId}/subscribed_apps\";\n\n            using var req = new HttpRequestMessage(HttpMethod.Post, url);\n            req.Headers.Authorization = new AuthenticationHeaderValue(\"Bearer\", accessToken);\n\n            var http = _httpFactory.CreateClient();\n            var res = await http.SendAsync(req, ct);\n\n            var body = await res.Content.ReadAsStringAsync(ct);\n            if (!res.IsSuccessStatusCode)\n            {\n                _log.LogWarning(\"‚ö†Ô∏è WABA subscribe failed. wabaId={WabaId}, status={Status}, body={Body}\", wabaId, (int)res.StatusCode, body);\n                res.EnsureSuccessStatusCode();\n            }\n\n            _log.LogInformation(\"‚úÖ WABA subscribed. wabaId={WabaId}\", wabaId);\n        }\n\n        public async Task UnsubscribeAsync(string wabaId, string accessToken, CancellationToken ct = default)\n        {\n            if (string.IsNullOrWhiteSpace(wabaId)) throw new ArgumentException(\"wabaId is required\", nameof(wabaId));\n            if (string.IsNullOrWhiteSpace(accessToken)) throw new ArgumentException(\"accessToken is required\", nameof(accessToken));\n\n            var baseUrl = string.IsNullOrWhiteSpace(_fb.GraphBaseUrl) ? \"https://graph.facebook.com\" : _fb.GraphBaseUrl!;\n            var version = string.IsNullOrWhiteSpace(_fb.GraphApiVersion) ? \"v22.0\" : _fb.GraphApiVersion!;\n            var url = $\"{baseUrl.TrimEnd('/')}/{version}/{wabaId}/subscribed_apps\";\n\n            using var req = new HttpRequestMessage(HttpMethod.Delete, url);\n            req.Headers.Authorization = new AuthenticationHeaderValue(\"Bearer\", accessToken);\n\n            var http = _httpFactory.CreateClient();\n            var res = await http.SendAsync(req, ct);\n\n            var body = await res.Content.ReadAsStringAsync(ct);\n            if (!res.IsSuccessStatusCode)\n            {\n                _log.LogWarning(\"‚ö†Ô∏è WABA unsubscribe failed. wabaId={WabaId}, status={Status}, body={Body}\", wabaId, (int)res.StatusCode, body);\n                res.EnsureSuccessStatusCode();\n            }\n\n            _log.LogInformation(\"‚úÖ WABA unsubscribed. wabaId={WabaId}\", wabaId);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Contracts/FacebookErrorResponse.cs",
      "sha256": "f926a14540f2cfeb9204abd7da5046f80824812f167638f1a935bd3c1fa249bd",
      "language": "csharp",
      "size": 715,
      "content": "#nullable enable\nusing System.Text.Json.Serialization;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Contracts\n{\n    public sealed class FacebookErrorResponse\n    {\n        [JsonPropertyName(\"error\")]\n        public FacebookError? Error { get; init; }\n\n        public sealed class FacebookError\n        {\n            [JsonPropertyName(\"message\")] public string? Message { get; init; }\n            [JsonPropertyName(\"type\")] public string? Type { get; init; }\n            [JsonPropertyName(\"code\")] public int? Code { get; init; }\n            [JsonPropertyName(\"error_subcode\")] public int? SubCode { get; init; }\n            [JsonPropertyName(\"fbtrace_id\")] public string? TraceId { get; init; }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Contracts/FacebookGraphException.cs",
      "sha256": "7f619349143ee1664ce94386c6fba760d79178fc8375d46b6c42b53c1642f95d",
      "language": "csharp",
      "size": 582,
      "content": "#nullable enable\nusing System;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Contracts\n{\n    public sealed class FacebookGraphException : Exception\n    {\n        public string? Type { get; }\n        public int? Code { get; }\n        public int? SubCode { get; }\n        public string? TraceId { get; }\n\n        public FacebookGraphException(string message, string? type, int? code, int? subCode, string? traceId)\n            : base(message)\n        {\n            Type = type;\n            Code = code;\n            SubCode = subCode;\n            TraceId = traceId;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Contracts/FacebookStoredToken.cs",
      "sha256": "031120808108409a860a5faca499217c7d28d4547972f394e95403f36e6f41d6",
      "language": "csharp",
      "size": 906,
      "content": "#nullable enable\nusing System;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Contracts\n{\n    public sealed class FacebookStoredToken\n    {\n        public string AccessToken { get; init; } = string.Empty;\n        public DateTime? ExpiresAtUtc { get; init; }      // null = unknown\n        public string? RawJson { get; init; }             // audit/debug snapshot\n\n        /// <summary>Consider token invalid if it expires within this window (default 5 minutes).</summary>\n        public bool WillExpireSoon(TimeSpan? skew = null)\n        {\n            if (ExpiresAtUtc is null) return false; // unknown -> assume fine, caller may decide stricter behavior\n            var s = skew ?? TimeSpan.FromMinutes(5);\n            return DateTime.UtcNow.Add(s) >= ExpiresAtUtc.Value;\n        }\n\n        public bool IsExpired()\n            => ExpiresAtUtc is not null && DateTime.UtcNow >= ExpiresAtUtc.Value;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Contracts/FacebookTokenResponse.cs",
      "sha256": "59dd8f7c04fcffa382ee1f0c0b0e9f8cbef52cb1c8b8331d41e7026504e78c02",
      "language": "csharp",
      "size": 634,
      "content": "#nullable enable\nusing System.Text.Json.Serialization;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Contracts\n{\n    public sealed class FacebookTokenResponse\n    {\n        [JsonPropertyName(\"access_token\")]\n        public string AccessToken { get; init; } = string.Empty;\n\n        [JsonPropertyName(\"token_type\")]\n        public string TokenType { get; init; } = \"bearer\";\n\n        [JsonPropertyName(\"expires_in\")]\n        public int ExpiresInSeconds { get; init; }\n\n        /// <summary>Raw JSON payload as returned by Facebook for auditing/debugging.</summary>\n        public string RawJson { get; init; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Controllers/FacebookEsuController.cs",
      "sha256": "8cc228b58a542b7f9b01307e5e5d192386eda26da5cb3349d13202816829f216",
      "language": "csharp",
      "size": 11309,
      "content": "#nullable enable\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.AspNetCore.RateLimiting;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.ESU.Facebook.Abstractions;\nusing xbytechat.api.Features.ESU.Facebook.DTOs;\nusing xbytechat.api.Features.ESU.Facebook.Services;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Controllers\n{\n    [ApiController]\n    [Route(\"api/esu/facebook\")]\n    [Authorize] // all endpoints below require authenticated workspace\n    public sealed class FacebookEsuController : ControllerBase\n    {\n        private readonly IFacebookEsuService _service;\n        private readonly IEsuStatusService _status;\n        private readonly ILogger<FacebookEsuController> _log;\n        private readonly string _uiBase;\n\n        public FacebookEsuController(\n            IFacebookEsuService service,\n            IEsuStatusService status,\n            ILogger<FacebookEsuController> log,\n            IConfiguration cfg)\n        {\n            _service = service;\n            _status = status;\n            _log = log;\n            _uiBase = (cfg[\"Ui:PublicBaseUrl\"] ?? cfg[\"App:PublicBaseUrl\"] ?? \"http://localhost:3000/\").TrimEnd('/');\n        }\n\n        private static string SanitizeReturnUrlOrDefault(string? returnUrl, string fallback)\n        {\n            if (string.IsNullOrWhiteSpace(returnUrl))\n                return fallback;\n\n            returnUrl = returnUrl.Trim();\n\n            if (!returnUrl.StartsWith(\"/\", StringComparison.Ordinal) ||\n                returnUrl.StartsWith(\"//\", StringComparison.Ordinal) ||\n                returnUrl.Contains(\"\\\\\", StringComparison.Ordinal))\n            {\n                return fallback;\n            }\n\n            return returnUrl;\n        }\n\n        private static string? TryExtractReturnUrlFromState(string state)\n        {\n            // state format: {bizId:N}|{unixTs}|{randomHex}|{returnUrl}\n            // keep backward compatible: if parsing fails, return null.\n            var parts = state.Split('|', 4, StringSplitOptions.None);\n            if (parts.Length < 4) return null;\n\n            var returnUrl = parts[3];\n            return string.IsNullOrWhiteSpace(returnUrl) ? null : returnUrl;\n        }\n\n        private static string AppendParams(string path, string paramPairs)\n        {\n            if (string.IsNullOrWhiteSpace(paramPairs)) return path;\n\n            var cleaned = paramPairs.Trim();\n            cleaned = cleaned.TrimStart('?', '&');\n            if (cleaned.Length == 0) return path;\n\n            var sep = path.Contains(\"?\", StringComparison.Ordinal) ? \"&\" : \"?\";\n            return $\"{path}{sep}{cleaned}\";\n        }\n\n        [HttpGet(\"health\")]\n        [AllowAnonymous]\n        public IActionResult Health()\n            => Ok(new { module = \"ESU\", provider = \"FACEBOOK\", status = \"OK\" });\n\n        // -------- START / RESTART ESU --------\n\n        [HttpPost(\"start\")]\n        [DisableRateLimiting] // ESU handshake must not be throttled\n        public async Task<IActionResult> Start(\n            [FromBody] FacebookEsuStartRequestDto? dto,\n            CancellationToken ct)\n        {\n            try\n            {\n                var businessId = User.GetBusinessId();\n                if (businessId == Guid.Empty)\n                    return Unauthorized(new { ok = false, message = \"Business context missing in token.\" });\n\n                var res = await _service.StartAsync(businessId, dto?.ReturnUrlAfterSuccess, ct);\n\n                _log.LogInformation(\n                    \"ESU start issued for business={BusinessId}, state={State}, expires={Expires}\",\n                    businessId, res.State, res.ExpiresAtUtc);\n\n                return Ok(new\n                {\n                    ok = true,\n                    data = new\n                    {\n                        authUrl = res.LaunchUrl,\n                        state = res.State,\n                        expiresAtUtc = res.ExpiresAtUtc\n                    }\n                });\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"ESU start failed.\");\n                return StatusCode(500, new { ok = false, message = \"Failed to start Meta Embedded Signup.\" });\n            }\n        }\n\n        // -------- OAUTH CALLBACK (PUBLIC) --------\n\n        //[HttpGet(\"callback\")]\n        //[AllowAnonymous]\n        //[DisableRateLimiting]\n        //public async Task<IActionResult> Callback(\n        //    [FromQuery] string? code,\n        //    [FromQuery] string? state,\n        //    CancellationToken ct)\n        //{\n        //    Response.Headers[\"Cache-Control\"] = \"no-store, no-cache, must-revalidate, max-age=0\";\n        //    Response.Headers[\"Pragma\"] = \"no-cache\";\n\n        //    string Target(string q) => $\"{_uiBase}/app/welcomepage{q}\";\n\n        //    if (string.IsNullOrWhiteSpace(code) || string.IsNullOrWhiteSpace(state))\n        //    {\n        //        _log.LogWarning(\"ESU callback missing parameters. codeNull={CodeNull} stateNull={StateNull}\",\n        //            string.IsNullOrWhiteSpace(code), string.IsNullOrWhiteSpace(state));\n        //        return Redirect(Target(\"?error=missing_code_or_state\"));\n        //    }\n\n        //    try\n        //    {\n        //        await _service.HandleCallbackAsync(code!, state!, ct);\n        //        _log.LogInformation(\"ESU callback success for state={State}\", state);\n        //        //return Redirect(Target(\"?connected=1\"));\n        //        return Redirect(Target(\"?esuStatus=success\"));\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        _log.LogError(ex, \"ESU callback failed for state={State}\", state);\n        //        // return Redirect(Target(\"?error=oauth_exchange_failed\"));\n        //        return Redirect(Target(\"?esuStatus=failed&error=oauth_exchange_failed\"));\n        //    }\n        //}\n        [HttpGet(\"callback\")]\n        [AllowAnonymous]\n        [DisableRateLimiting]\n        public async Task<IActionResult> Callback(\n    [FromQuery] string? code,\n    [FromQuery] string? state,\n    CancellationToken ct)\n        {\n            Response.Headers[\"Cache-Control\"] = \"no-store, no-cache, must-revalidate, max-age=0\";\n            Response.Headers[\"Pragma\"] = \"no-cache\";\n\n            var returnUrlFromState = !string.IsNullOrWhiteSpace(state)\n                ? TryExtractReturnUrlFromState(state)\n                : null;\n\n            var returnPath = SanitizeReturnUrlOrDefault(returnUrlFromState, \"/app/welcomepage\");\n\n            string Target(string paramPairs)\n                => $\"{_uiBase}{AppendParams(returnPath, paramPairs)}\";\n\n            if (string.IsNullOrWhiteSpace(code) || string.IsNullOrWhiteSpace(state))\n            {\n                _log.LogWarning(\n                    \"ESU callback missing parameters. codeNull={CodeNull} stateNull={StateNull}\",\n                    string.IsNullOrWhiteSpace(code),\n                    string.IsNullOrWhiteSpace(state));\n\n                return Redirect(Target(\"esuStatus=failed&error=missing_code_or_state\"));\n            }\n\n            try\n            {\n                await _service.HandleCallbackAsync(code!, state!, ct);\n                _log.LogInformation(\"ESU callback success for state={State}\", state);\n\n                return Redirect(Target(\"esuStatus=success\"));\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"ESU callback failed for state={State}\", state);\n                return Redirect(Target(\"esuStatus=failed&error=oauth_exchange_failed\"));\n            }\n        }\n        // -- Set two factor verification ---\n\n    //    [HttpPost(\"register-number\")]\n    //    public async Task<IActionResult> RegisterPhoneNumber(\n    //[FromBody] RegisterPhoneNumberDto dto,\n    //CancellationToken ct)\n    //    {\n    //        var businessId = User.GetBusinessId();\n    //        if (businessId == Guid.Empty)\n    //            return Unauthorized();\n\n    //        await _service.RegisterPhoneNumberAsync(\n    //            businessId,\n    //            dto.Pin,\n    //            ct);\n\n    //        return Ok(new { ok = true });\n    //    }\n        [HttpPost(\"register-number\")]\n        public async Task<IActionResult> RegisterPhoneNumber([FromBody] RegisterPhoneNumberDto dto, CancellationToken ct)\n        {\n            var businessId = User.GetBusinessId();\n            if (businessId == Guid.Empty) return Unauthorized();\n\n            await _service.RegisterPhoneNumberAsync(businessId, dto.Pin, ct);\n            return Ok(new { ok = true });\n        }\n\n        public sealed class RegisterPhoneNumberDto\n        {\n            public string Pin { get; set; } = default!; // 6 digits\n        }\n\n        // -------- DISCONNECT (FULL DEAUTHORIZE) --------\n\n        [HttpDelete(\"disconnect\")]\n        public async Task<IActionResult> Disconnect(CancellationToken ct)\n        {\n            try\n            {\n                var businessId = User.GetBusinessId();\n                if (businessId == Guid.Empty)\n                    return Unauthorized(new { ok = false, message = \"Business context missing in token.\" });\n\n                await _service.DisconnectAsync(businessId, ct);\n                return Ok(new { ok = true });\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"ESU disconnect failed.\");\n                return StatusCode(500, new\n                {\n                    ok = false,\n                    message = \"Failed to disconnect WhatsApp for this workspace.\"\n                });\n            }\n        }\n\n        // -------- STATUS --------\n\n        [HttpGet(\"status\")]\n        public async Task<IActionResult> GetStatus(CancellationToken ct)\n        {\n            var businessId = User.GetBusinessId();\n            if (businessId == Guid.Empty)\n                return Unauthorized(new { ok = false, message = \"Business context missing in token.\" });\n\n            var dto = await _status.GetStatusAsync(businessId, ct);\n\n            // FE already supports both plain DTO and { ok, data }\n            return Ok(new { ok = true, data = dto });\n        }\n\n        // inside FacebookEsuController\n\n        [HttpDelete(\"hard-delete-full-account\")]\n        public async Task<IActionResult> DeleteAccountAndData(CancellationToken ct)\n        {\n            try\n            {\n                var businessId = User.GetBusinessId();\n                if (businessId == Guid.Empty)\n                    return Unauthorized(new { ok = false, message = \"Business context missing in token.\" });\n\n                await _service.FullDeleteAsync(businessId, ct);\n\n                return Ok(new\n                {\n                    ok = true,\n                    message = \"WhatsApp Business API connection and related onboarding data have been deleted for this workspace.\"\n                });\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"ESU account/data delete failed.\");\n                return StatusCode(500, new\n                {\n                    ok = false,\n                    message = \"Failed to delete WhatsApp onboarding data for this workspace.\"\n                });\n            }\n        }\n\n    }\n}\n\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Controllers/FacebookEsuDebugController.cs",
      "sha256": "278b72c0ade6b0335b5f61adde7aeaaad008423cf574b477aa161d365adacad2",
      "language": "csharp",
      "size": 5179,
      "content": "#nullable enable\nusing System;\nusing System.Collections.Generic; // <-- needed for the /me call\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.ESU.Facebook.Abstractions;\nusing xbytechat.api.Features.ESU.Facebook.DTOs;\nusing xbytechat.api.Infrastructure;\nusing xbytechat.api.Shared; // AppDbContext\n\nnamespace xbytechat.api.Features.ESU.Facebook.Controllers\n{\n    [ApiController]\n    [Route(\"api/esu/facebook/debug\")]\n   // [Authorize(Roles = \"SuperAdmin\")] // ‚ö†Ô∏è TEMPORARY for verification; lock down/remove after testing\n    public sealed class FacebookEsuDebugController : ControllerBase\n    {\n        private readonly IFacebookTokenService _tokenService;\n        private readonly AppDbContext _db;\n        private readonly ILogger<FacebookEsuDebugController> _log;\n        private readonly IFacebookGraphClient _graph;\n        private readonly IEsuStatusService _status;\n        public FacebookEsuDebugController(\n            IFacebookTokenService tokenService,\n            AppDbContext db,\n            ILogger<FacebookEsuDebugController> log,\n            IFacebookGraphClient graph,\n            IEsuStatusService status)\n        {\n            _tokenService = tokenService;\n            _db = db;\n            _log = log;\n            _graph = graph;\n            _status = status;\n        }\n\n        // GET /api/esu/facebook/debug/token?businessId=...\n        [HttpGet(\"token\")]\n        public async Task<IActionResult> GetToken([FromQuery] Guid businessId, CancellationToken ct)\n        {\n            if (businessId == Guid.Empty) return BadRequest(\"businessId is required.\");\n\n            var t = await _tokenService.TryGetValidAsync(businessId, ct);\n            if (t is null)\n            {\n                return Ok(new\n                {\n                    ok = false,\n                    message = \"No valid token found (missing or expired). Re-run ESU.\"\n                });\n            }\n\n            return Ok(new\n            {\n                ok = true,\n                tokenPreview = Mask(t.AccessToken),\n                expiresAtUtc = t.ExpiresAtUtc,\n                willExpireSoon = t.WillExpireSoon(),  // default 5m skew\n                rawJsonLength = t.RawJson?.Length ?? 0\n            });\n        }\n\n        [HttpGet(\"status\")]\n        [Authorize]\n        public async Task<ActionResult<EsuStatusDto>> GetStatus(CancellationToken ct)\n        {\n            // Uses the \"businessId\" claim from JWT (lowercase)\n            var businessId = User.GetBusinessId();\n\n            var dto = await _status.GetStatusAsync(businessId, ct);\n\n            // Keep it simple; frontend already normalizes shape\n            return Ok(dto);\n        }\n\n\n        [HttpPost(\"deauthorize\")]\n        public async Task<IActionResult> Deauthorize([FromQuery] Guid businessId, CancellationToken ct)\n        {\n            if (businessId == Guid.Empty) return BadRequest(\"businessId is required.\");\n            await _status.DeauthorizeAsync(businessId, ct);\n            return Ok(new { ok = true });\n        }\n\n\n        // GET /api/esu/facebook/debug/flags?businessId=...\n        [HttpGet(\"flags\")]\n        public async Task<IActionResult> ListFlags([FromQuery] Guid businessId, CancellationToken ct)\n        {\n            if (businessId == Guid.Empty) return BadRequest(\"businessId is required.\");\n\n            // Your IntegrationFlags model is the single-row, column-style model\n            var row = await _db.IntegrationFlags\n                .AsNoTracking()\n                .SingleOrDefaultAsync(x => x.BusinessId == businessId, ct);\n\n            if (row is null)\n            {\n                return Ok(new { ok = true, count = 0, items = Array.Empty<object>() });\n            }\n\n            // Box each element as object so the array can be typed object[]\n            var items = new object[]\n            {\n                new { key = \"FACEBOOK_ESU_COMPLETED\",value = row.FacebookEsuCompleted ? \"true\" : \"false\" }\n    \n            };\n\n            return Ok(new { ok = true, count = items.Length, items });\n        }\n\n        private static string Mask(string? s)\n        {\n            if (string.IsNullOrEmpty(s)) return \"\";\n            if (s.Length <= 10) return new string('*', s.Length);\n            return $\"{s.Substring(0, 6)}‚Ä¶{s.Substring(s.Length - 4)}\";\n        }\n\n        private static string? Preview(string? s, int max)\n        {\n            if (string.IsNullOrEmpty(s)) return null;\n            return s.Length <= max ? s : s.Substring(0, max) + \"‚Ä¶\";\n        }\n\n        // GET /api/esu/facebook/debug/me?businessId=...\n        [HttpGet(\"me\")]\n        public async Task<IActionResult> GetMe([FromQuery] Guid businessId, CancellationToken ct)\n        {\n            if (businessId == Guid.Empty) return BadRequest(\"businessId is required.\");\n\n            var me = await _graph.GetAsync<dynamic>(businessId, \"me\", new Dictionary<string, string?>\n            {\n                [\"fields\"] = \"id,name\"\n            }, ct);\n\n            return Ok(me);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Controllers/FacebookWebhookController.cs",
      "sha256": "37c83b8128f59e8e6aeb523db8f7e1d1070e5e13c91fff4e0554f64150b95b16",
      "language": "csharp",
      "size": 1636,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Options;\nusing xbytechat.api.Features.ESU.Facebook.Options;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Controllers\n{\n    [ApiController]\n    [Route(\"api/esu/facebook/webhook\")]\n    public sealed class FacebookWebhookController : ControllerBase\n    {\n        private readonly string _verifyToken;\n\n        public FacebookWebhookController(IOptions<FacebookOptions> opts)\n        {\n            _verifyToken = opts.Value.VerifyToken ?? string.Empty;\n        }\n\n        // GET verify: echo hub.challenge if token matches\n        [HttpGet]\n        public IActionResult Verify([FromQuery(Name = \"hub.mode\")] string? mode,\n                                    [FromQuery(Name = \"hub.verify_token\")] string? token,\n                                    [FromQuery(Name = \"hub.challenge\")] string? challenge)\n        {\n            if (string.Equals(mode, \"subscribe\", StringComparison.OrdinalIgnoreCase) &&\n                !string.IsNullOrWhiteSpace(token) &&\n                token == _verifyToken &&\n                !string.IsNullOrWhiteSpace(challenge))\n            {\n                return Content(challenge!, \"text/plain\");\n            }\n            return Forbid();\n        }\n\n        // POST stub: logs or routes ESU-related events (optional for App Review)\n        [HttpPost]\n        public async Task<IActionResult> Receive()\n        {\n            using var reader = new StreamReader(Request.Body);\n            var body = await reader.ReadToEndAsync();\n            // TODO: route event to your logger/queue if needed\n            return Ok(new { ok = true });\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Controllers/MetaComplianceController.cs",
      "sha256": "179bb937008d85aeeb49895c0daad03b0e73b79b136c13d93cd3a1e9c5487183",
      "language": "csharp",
      "size": 4673,
      "content": "#nullable enable\nusing System;\nusing System.Security.Cryptography;\nusing System.Text;\nusing System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing xbytechat.api.Features.ESU.Facebook.Abstractions;\nusing xbytechat.api.Features.ESU.Facebook.Options;\nusing xbytechat.api.Features.ESU.Facebook.Services;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Controllers\n{\n    [ApiController]\n    [Route(\"meta\")]\n    public sealed class MetaComplianceController : ControllerBase\n    {\n        private readonly IFacebookEsuService _esuService;\n        private readonly IOptions<FacebookOauthOptions> _fbOpts;\n        private readonly ILogger<MetaComplianceController> _log;\n\n        public MetaComplianceController(\n            IFacebookEsuService esuService,\n            IOptions<FacebookOauthOptions> fbOpts,\n            ILogger<MetaComplianceController> log)\n        {\n            _esuService = esuService;\n            _fbOpts = fbOpts;\n            _log = log;\n        }\n\n        // Configure this URL in Meta's \"Data Deletion\" settings.\n        // Meta sends `signed_request` (base64url.header.payload, HMAC-SHA256 with AppSecret).\n        [HttpPost(\"data-deletion\")]\n        public async Task<IActionResult> HandleDataDeletion([FromForm] string signed_request, CancellationToken ct)\n        {\n            if (string.IsNullOrWhiteSpace(signed_request))\n                return BadRequest(new { status = \"error\", message = \"missing signed_request\" });\n\n            var (ok, payloadJson) = TryValidateSignedRequest(signed_request);\n            if (!ok)\n                return BadRequest(new { status = \"error\", message = \"invalid signed_request\" });\n\n            // Payload typically contains user_id or similar identifiers.\n            // You must map that to your BusinessId based on how you tied ESU sessions to businesses.\n            // For now we assume you store mapping elsewhere and resolve it here.\n            var businessId = ResolveBusinessIdFromPayload(payloadJson);\n            if (businessId == Guid.Empty)\n            {\n                _log.LogInformation(\"Meta data-deletion: no matching business for payload={Payload}\", payloadJson);\n                return Ok(new { status = \"ignored\" });\n            }\n\n            _log.LogInformation(\"Meta data-deletion: biz={BusinessId}\", businessId);\n\n            // Canonical cleanup: same as manual disconnect\n            await _esuService.DisconnectAsync(businessId, ct);\n\n            // Optional: enqueue deeper anonymization/purge if your policy requires.\n            return Ok(new\n            {\n                status = \"success\",\n                reference_id = businessId\n            });\n        }\n\n        private (bool ok, string payloadJson) TryValidateSignedRequest(string signedRequest)\n        {\n            var parts = signedRequest.Split('.', 2);\n            if (parts.Length != 2) return (false, \"\");\n\n            var providedSig = Base64UrlDecode(parts[0]);\n            var payloadBytes = Base64UrlDecode(parts[1]);\n\n            var appSecret = _fbOpts.Value.AppSecret;\n            if (string.IsNullOrWhiteSpace(appSecret))\n                return (false, \"\");\n\n            using var hmac = new HMACSHA256(Encoding.UTF8.GetBytes(appSecret));\n            var expectedSig = hmac.ComputeHash(Encoding.UTF8.GetBytes(parts[1]));\n\n            // Constant-time compare\n            if (!CryptographicOperations.FixedTimeEquals(providedSig, expectedSig))\n                return (false, \"\");\n\n            var payloadJson = Encoding.UTF8.GetString(payloadBytes);\n            return (true, payloadJson);\n        }\n\n        private static byte[] Base64UrlDecode(string input)\n        {\n            input = input.Replace('-', '+').Replace('_', '/');\n            switch (input.Length % 4)\n            {\n                case 2: input += \"==\"; break;\n                case 3: input += \"=\"; break;\n            }\n            return Convert.FromBase64String(input);\n        }\n\n        // TODO: implement this mapping based on your stored ESU context.\n        private Guid ResolveBusinessIdFromPayload(string payloadJson)\n        {\n            using var doc = JsonDocument.Parse(payloadJson);\n            var root = doc.RootElement;\n\n            // Example: if you store mapping from Meta user_id/page_id/WABA to BusinessId.\n            // This is intentionally left for your existing infra.\n            // Return Guid.Empty when no mapping found.\n\n            // var userId = root.GetProperty(\"user_id\").GetString();\n            // lookup Biz by userId...\n\n            return Guid.Empty;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/DTOs/EsuStatusDto.cs",
      "sha256": "500f10342a1b0e3da1a6a434d98299fcb52760d56f35b1743982de9ac7635ec6",
      "language": "csharp",
      "size": 669,
      "content": "#nullable enable\nusing System;\n\nnamespace xbytechat.api.Features.ESU.Facebook.DTOs\n{\n    public sealed class EsuStatusDto\n    {\n        public bool Connected { get; init; }             // true = ESU-complete + valid token\n        public bool HasEsuFlag { get; init; }            // IntegrationFlags row + FacebookEsuCompleted\n        public bool HasValidToken { get; init; }         // from TryGetValidAsync\n        public DateTime? TokenExpiresAtUtc { get; init; }\n        public bool WillExpireSoon { get; init; }\n        public bool HardDeleted { get; init; }\n\n        public DateTime UpdatedAtUtc { get; init; }\n        public string? Debug { get; init; }\n    }\n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/DTOs/FacebookEsuDtos.cs",
      "sha256": "de4844f0acab828a681671d348d4dd9d6be053b2b699fb06b83ac96b9b2c6462",
      "language": "csharp",
      "size": 872,
      "content": "using System;\n\nnamespace xbytechat.api.Features.ESU.Facebook.DTOs\n{\n    // Request from FE to start ESU. BusinessId now comes from header X-Business-Id.\n    public sealed class FacebookEsuStartRequestDto\n    {\n        public string? ReturnUrlAfterSuccess { get; set; }   // optional FE page to navigate to after success\n    }\n\n    // Service-layer response; controller will wrap this into the envelope.\n    public sealed class FacebookEsuStartResponseDto\n    {\n        public string LaunchUrl { get; set; } = string.Empty;\n        public string State { get; set; } = string.Empty;    // returned for debugging/telemetry if needed\n        public DateTime ExpiresAtUtc { get; set; }           // when the state will expire on server\n    }\n\n    public sealed class FacebookEsuCallbackResponseDto\n    {\n        public string RedirectTo { get; set; } = \"/esu/success\";\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Models/EsuToken.cs",
      "sha256": "0cf53a8e94d8023a166f4b195f7d061d6cb4427fc9bba788de58c8aba2ae5aef",
      "language": "csharp",
      "size": 849,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Models\n{\n    [Table(\"EsuTokens\")]\n    public sealed class EsuToken\n    {\n        [Key] public Guid Id { get; set; } = Guid.NewGuid();\n        [Required] public Guid BusinessId { get; set; }\n\n        [Required, MaxLength(50)]\n        public string Provider { get; set; } = \"META_CLOUD\"; // UPPERCASE canonical\n\n        [Required, MaxLength(4096)]\n        public string AccessToken { get; set; } = null!;\n\n        public DateTime? ExpiresAtUtc { get; set; }\n        [MaxLength(512)] public string? Scope { get; set; }\n        public bool IsRevoked { get; set; }\n\n        public DateTime CreatedAtUtc { get; set; } = DateTime.UtcNow;\n        public DateTime? UpdatedAtUtc { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Models/IntegrationFlags.cs",
      "sha256": "cf6cb21691fbbdd8355439ead561d4c93ab07f8caa3f8d434a2f80b86ba71fe2",
      "language": "csharp",
      "size": 1068,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Models\n{\n    /// <summary>\n    /// One row per Business capturing lightweight ‚Äúconnected‚Äù flags\n    /// and optional token metadata for ESU-style integrations.\n    /// </summary>\n    [Table(\"IntegrationFlags\")]\n    public sealed class IntegrationFlags\n    {   \n        [Key]\n        public Guid BusinessId { get; set; }\n\n        // --- Facebook ESU ---\n        public bool FacebookEsuCompleted { get; set; }\n\n        // Optional: store a short-lived user token value/expiry if you plan follow-up Graph calls.\n        // Keep nullable; app can run just with the completion flag.\n        //[MaxLength(2048)]\n        //public string? FacebookAccessToken { get; set; }\n\n        //public DateTime? FacebookTokenExpiresAtUtc { get; set; }\n\n        // housekeeping\n        public DateTime CreatedAtUtc { get; set; } = DateTime.UtcNow;\n        public DateTime UpdatedAtUtc { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Options/FacebookOauthOptions.cs",
      "sha256": "add7b7d980d29b73a36f0a74b24314435d9a01fc1c840cdec28c57b3afc5ff11",
      "language": "csharp",
      "size": 461,
      "content": "#nullable enable\n\nnamespace xbytechat.api.Features.ESU.Facebook.Options\n{\n    public sealed class FacebookOauthOptions\n    {\n        public string AppId { get; set; } = string.Empty;\n        public string AppSecret { get; set; } = string.Empty;\n        public string RedirectUri { get; set; } = string.Empty;\n        public string GraphBaseUrl { get; set; } = \"https://graph.facebook.com\";\n        public string GraphApiVersion { get; set; } = \"v22.0\";\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Options/FacebookOptions.cs",
      "sha256": "b89d5e57d74ac7192083b906ada684a584f86663a53303bfa970df7221033891",
      "language": "csharp",
      "size": 599,
      "content": "namespace xbytechat.api.Features.ESU.Facebook.Options\n{\n    public sealed class FacebookOptions\n    {\n        public string AppId { get; set; } = string.Empty;\n        public string AppSecret { get; set; } = string.Empty;\n        public string RedirectUri { get; set; } = string.Empty;\n\n        // add these if not present\n        public string? Scopes { get; set; }\n        public string? GraphBaseUrl { get; set; }\n        public string? GraphApiVersion { get; set; }\n        public int StateTtlMinutes { get; set; } = 20;\n\n        // NEW:\n        public string? VerifyToken { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Services/EsuStatusService.cs",
      "sha256": "a3923bbab4c09515748083cb6e3a29ea349fe1852ae993432a61150d6571b0c9",
      "language": "csharp",
      "size": 5012,
      "content": "#nullable enable\nusing System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.ESU.Facebook.Abstractions;\nusing xbytechat.api.Features.ESU.Facebook.DTOs;\nusing xbytechat.api.Infrastructure;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Services\n{\n    public sealed class EsuStatusService : IEsuStatusService\n    {\n        private const string Provider = \"META_CLOUD\";\n\n        private readonly AppDbContext _db;\n        private readonly IFacebookTokenService _tokenService;\n        private readonly IEsuTokenStore _tokens;\n        private readonly ILogger<EsuStatusService> _log;\n\n        public EsuStatusService(\n            AppDbContext db,\n            IFacebookTokenService tokenService,\n            IEsuTokenStore tokens,\n            ILogger<EsuStatusService> log)\n        {\n            _db = db;\n            _tokenService = tokenService;\n            _tokens = tokens;\n            _log = log;\n        }\n\n        public async Task<EsuStatusDto> GetStatusAsync(Guid businessId, CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty)\n                throw new ArgumentException(\"businessId is required.\", nameof(businessId));\n\n            var now = DateTime.UtcNow;\n\n            // 1) Read IntegrationFlags row (UX flag)\n            var row = await _db.IntegrationFlags\n                .AsNoTracking()\n                .SingleOrDefaultAsync(x => x.BusinessId == businessId, ct);\n\n            var hasEsuFlag = row?.FacebookEsuCompleted ?? false;\n\n            // 2) Pull latest token row (even if expiring/expired) to show expiry in UI\n            //    (TryGetValidAsync hides expiring tokens by design)\n            var latestToken = await _db.EsuTokens\n                .AsNoTracking()\n                .Where(x => x.BusinessId == businessId && x.Provider == Provider)\n                .OrderByDescending(x => x.UpdatedAtUtc ?? x.CreatedAtUtc)\n                .FirstOrDefaultAsync(ct);\n\n            DateTime? expiresAt = latestToken?.ExpiresAtUtc;\n\n            // 3) Determine \"valid token\" using canonical service logic\n            bool hasValidToken = false;\n            try\n            {\n                var valid = await _tokenService.TryGetValidAsync(businessId, ct);\n                hasValidToken = valid is not null;\n\n                // Prefer valid token expiry if token row doesn't have it for some reason\n                expiresAt ??= valid?.ExpiresAtUtc;\n            }\n            catch (Exception ex)\n            {\n                _log.LogDebug(ex, \"Status check token probe failed for {Biz}\", businessId);\n            }\n\n            // 4) HardDeleted detection (your intended terminal state)\n            var hasAnyToken = await _db.EsuTokens\n                .AsNoTracking()\n                .AnyAsync(x => x.BusinessId == businessId && x.Provider == Provider, ct);\n\n            var hasAnySetting = await _db.WhatsAppSettings\n                .AsNoTracking()\n                .AnyAsync(x => x.BusinessId == businessId && x.Provider == Provider, ct);\n\n            var hasAnyPhone = await _db.WhatsAppPhoneNumbers\n                .AsNoTracking()\n                .AnyAsync(x => x.BusinessId == businessId && x.Provider == Provider, ct);\n\n            // ‚úÖ Terminal state: no flags row + no tokens/settings/phones\n            var hardDeleted = (row is null) && !hasAnyToken && !hasAnySetting && !hasAnyPhone;\n\n            // 5) Expiring soon (UI signal)\n            var willExpireSoon =\n                expiresAt.HasValue &&\n                expiresAt.Value > now &&\n                expiresAt.Value <= now.AddMinutes(10);\n\n            var updatedAt = row?.UpdatedAtUtc ?? now;\n\n            return new EsuStatusDto\n            {\n                Connected = hasEsuFlag && hasValidToken,\n                HasEsuFlag = hasEsuFlag,\n                HasValidToken = hasValidToken,\n                TokenExpiresAtUtc = expiresAt,\n                WillExpireSoon = willExpireSoon,\n                HardDeleted = hardDeleted,\n                UpdatedAtUtc = updatedAt,\n                Debug = row is null ? \"no-row\" : null\n            };\n        }\n\n        public async Task DeauthorizeAsync(Guid businessId, CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty)\n                throw new ArgumentException(\"businessId is required.\", nameof(businessId));\n\n            // 1) Clear UX flag\n            var row = await _db.IntegrationFlags\n                .SingleOrDefaultAsync(x => x.BusinessId == businessId, ct);\n\n            if (row is not null)\n            {\n                row.FacebookEsuCompleted = false;\n                row.UpdatedAtUtc = DateTime.UtcNow;\n                await _db.SaveChangesAsync(ct);\n            }\n\n            // 2) Revoke token (EsuTokens) + 3) drop from cache\n            await _tokens.RevokeAsync(businessId, Provider, ct);\n            await _tokenService.InvalidateAsync(businessId, ct);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Services/EsuTokenStore.cs",
      "sha256": "a241632aaf4b68f5cf874f010a82bb73d3fe65d14c695d8fba2c29b06bb0cac5",
      "language": "csharp",
      "size": 2256,
      "content": "using Microsoft.EntityFrameworkCore;\nusing xbytechat.api;\nusing xbytechat.api.Features.ESU.Facebook.Models;\nusing xbytechat.api.Infrastructure;\n\npublic sealed class EsuTokenStore : IEsuTokenStore\n{\n    private readonly AppDbContext _db;\n    public EsuTokenStore(AppDbContext db) => _db = db;\n\n    public Task<EsuToken?> GetAsync(Guid biz, string provider, CancellationToken ct)\n        => _db.Set<EsuToken>().AsNoTracking()\n              .FirstOrDefaultAsync(x => x.BusinessId == biz && x.Provider == provider, ct);\n\n    public async Task UpsertAsync(Guid biz, string provider, string token, DateTime? exp, CancellationToken ct)\n    {\n        provider = provider.ToUpperInvariant();\n\n        var row = await _db.Set<EsuToken>()\n            .FirstOrDefaultAsync(x => x.BusinessId == biz && x.Provider == provider, ct);\n\n        if (row is null)\n        {\n            _db.Add(new EsuToken\n            {\n                BusinessId = biz,\n                Provider = provider,\n                AccessToken = token,\n                ExpiresAtUtc = exp,\n                IsRevoked = string.IsNullOrWhiteSpace(token) // treat empty as revoked\n            });\n        }\n        else\n        {\n            row.AccessToken = token;\n            row.ExpiresAtUtc = exp;\n            row.IsRevoked = string.IsNullOrWhiteSpace(token) ? true : false;\n            row.UpdatedAtUtc = DateTime.UtcNow;\n        }\n\n        await _db.SaveChangesAsync(ct);\n    }\n\n\n    public async Task RevokeAsync(Guid biz, string provider, CancellationToken ct)\n    {\n        var row = await _db.Set<EsuToken>().FirstOrDefaultAsync(x => x.BusinessId == biz && x.Provider == provider, ct);\n        if (row is null) return;\n        row.IsRevoked = true; row.UpdatedAtUtc = DateTime.UtcNow;\n        await _db.SaveChangesAsync(ct);\n    }\n\n    // FILE: Features/ESU/Facebook/Services/EsuTokenStore.cs\n\n    public async Task DeleteAsync(Guid biz, string provider, CancellationToken ct = default)\n    {\n        var set = _db.Set<EsuToken>();\n\n        var rows = await set\n            .Where(x => x.BusinessId == biz && x.Provider == provider)\n            .ToListAsync(ct);\n\n        if (rows.Count == 0)\n            return;\n\n        set.RemoveRange(rows);\n        await _db.SaveChangesAsync(ct);\n    }\n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Services/FacebookEsuService.cs",
      "sha256": "95c016707367965c261435e3c929f556ae1e676d755f88ec85b18a600baf2ab3",
      "language": "csharp",
      "size": 40455,
      "content": "using System;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Net.Http.Json;\nusing System.Security.Cryptography;\nusing System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.WebUtilities;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing xbytechat.api.Features.ESU.Facebook.Abstractions;\nusing xbytechat.api.Features.ESU.Facebook.Contracts;\nusing xbytechat.api.Features.ESU.Facebook.DTOs;\nusing xbytechat.api.Features.ESU.Facebook.Options;\nusing xbytechat.api.Features.ESU.Facebook.Clients;\nusing xbytechat.api.Features.ESU.Shared;\nusing xbytechat.api.Features.WhatsAppSettings.Services;\nusing xbytechat.api.WhatsAppSettings.DTOs;\nusing xbytechat_api.WhatsAppSettings.DTOs;\nusing xbytechat_api.WhatsAppSettings.Services;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Services\n{\n    internal sealed class FacebookEsuService : IFacebookEsuService\n    {\n        private const string Provider = \"META_CLOUD\";\n\n        private readonly IOptions<EsuOptions> _options;\n        private readonly IOptions<FacebookOauthOptions> _oauthOpts;\n        private readonly IEsuStateStore _stateStore;\n        private readonly IEsuFlagStore _flagStore;\n        private readonly IFacebookOauthClient _oauth;\n        private readonly IEsuTokenStore _tokens;\n        private readonly IFacebookTokenService _fbTokens;\n        private readonly IWhatsAppSettingsService _waSettings;\n        private readonly IWhatsAppPhoneNumberService _waPhones;\n        private readonly ILogger<FacebookEsuService> _log;\n        private readonly IEsuStatusService _esuStatus;\n        private readonly IWabaSubscriptionClient _wabaSubscription;\n\n        public FacebookEsuService(\n            IOptions<EsuOptions> options,\n            IEsuStateStore stateStore,\n            IEsuFlagStore flagStore,\n            IFacebookOauthClient oauth,\n            IEsuTokenStore tokens,\n            IFacebookTokenService fbTokens,\n            IWhatsAppSettingsService waSettings,\n            IWhatsAppPhoneNumberService waPhones,\n            IOptions<FacebookOauthOptions> oauthOpts,\n            ILogger<FacebookEsuService> log,\n            IEsuStatusService esuStatus,\n            IWabaSubscriptionClient wabaSubscription)\n        {\n            _options = options;\n            _stateStore = stateStore;\n            _flagStore = flagStore;\n            _oauth = oauth;\n            _tokens = tokens;\n            _fbTokens = fbTokens;\n            _waSettings = waSettings;\n            _waPhones = waPhones;\n            _oauthOpts = oauthOpts;\n            _log = log;\n            _esuStatus = esuStatus;\n            _wabaSubscription = wabaSubscription;\n        }\n\n        // =======================\n        // ESU START\n        // =======================\n        public async Task<FacebookEsuStartResponseDto> StartAsync(\n            Guid businessId,\n            string? returnUrl,\n            CancellationToken ct = default)\n        {\n            var cfg = _options.Value.Facebook;\n\n            if (string.IsNullOrWhiteSpace(cfg.AppId))\n                throw new InvalidOperationException(\"ESU.Facebook.AppId is not configured.\");\n            if (string.IsNullOrWhiteSpace(cfg.RedirectUri))\n                throw new InvalidOperationException(\"ESU.Facebook.RedirectUri is not configured.\");\n            if (string.IsNullOrWhiteSpace(cfg.ConfigId))\n                throw new InvalidOperationException(\"ESU.Facebook.ConfigId is not configured.\");\n\n            var state = CreateStateToken(businessId, returnUrl);\n            var ttl = TimeSpan.FromMinutes(Math.Max(1, cfg.StateTtlMinutes));\n\n            await _stateStore.StoreAsync(state, businessId, ttl);\n\n            var dialogVersion = _oauthOpts.Value.GraphApiVersion?.Trim('/') ?? \"v20.0\";\n            var dialogBase = $\"https://www.facebook.com/{dialogVersion}/dialog/oauth\";\n\n            var query = new System.Collections.Generic.Dictionary<string, string?>\n            {\n                [\"client_id\"] = cfg.AppId,\n                [\"redirect_uri\"] = cfg.RedirectUri,\n                [\"state\"] = state,\n                [\"response_type\"] = \"code\",\n                [\"config_id\"] = cfg.ConfigId,\n\n                // ‚úÖ IMPORTANT: Explicit scope improves reliability + App Review clarity\n                [\"scope\"] = !string.IsNullOrWhiteSpace(cfg.Scopes)\n                    ? cfg.Scopes.Trim()\n                    : null\n            };\n\n            var launchUrl = QueryHelpers.AddQueryString(dialogBase, query);\n\n            _log.LogInformation(\n                \"ESU Start: biz={BusinessId}, statePrefix={StatePrefix}, url={Url}\",\n                businessId,\n                state.Length > 16 ? state[..16] : state,\n                launchUrl);\n\n            return new FacebookEsuStartResponseDto\n            {\n                LaunchUrl = launchUrl,\n                State = state,\n                ExpiresAtUtc = DateTime.UtcNow.Add(ttl)\n            };\n        }\n\n        // =======================\n        // ESU CALLBACK\n        // =======================\n        public async Task<FacebookEsuCallbackResponseDto> HandleCallbackAsync(\n            string code,\n            string state,\n            CancellationToken ct = default)\n        {\n            if (string.IsNullOrWhiteSpace(code))\n                throw new InvalidOperationException(\"OAuth failed: missing 'code'.\");\n            if (string.IsNullOrWhiteSpace(state))\n                throw new InvalidOperationException(\"OAuth failed: missing 'state'.\");\n\n            var (found, businessId) = await _stateStore.TryConsumeAsync(state);\n            if (!found || businessId == Guid.Empty)\n                throw new InvalidOperationException(\"Invalid or expired state.\");\n\n            _log.LogInformation(\n                \"ESU Callback: biz={BusinessId}, statePrefix={StatePrefix}\",\n                businessId,\n                state.Length > 16 ? state[..16] : state);\n\n            // 1) Exchange short-lived ‚Üí long-lived token\n            var token = await _oauth.ExchangeCodeAsync(code, ct);\n            if (string.IsNullOrWhiteSpace(token?.AccessToken))\n                throw new InvalidOperationException(\"OAuth exchange did not return an access token.\");\n\n            token = await _oauth.ExchangeForLongLivedAsync(token, ct);\n\n            var accessToken = token.AccessToken;\n            DateTime? expiresAtUtc = (token.ExpiresInSeconds > 0)\n                ? DateTime.UtcNow.AddSeconds(token.ExpiresInSeconds)\n                : (DateTime?)null;\n\n            _log.LogInformation(\n                \"ESU Callback: received long-lived token for biz={BusinessId}, expiresAt={ExpiresAt}\",\n                businessId,\n                expiresAtUtc?.ToString(\"O\") ?? \"<none>\");\n\n            await _tokens.UpsertAsync(\n                businessId,\n                Provider,\n                accessToken,\n                expiresAtUtc,\n                ct);\n\n            await _fbTokens.InvalidateAsync(businessId, ct);\n\n            var graphBase = _oauthOpts.Value.GraphBaseUrl?.TrimEnd('/') ?? \"https://graph.facebook.com\";\n            var graphVer = _oauthOpts.Value.GraphApiVersion?.Trim('/') ?? \"v20.0\";\n            var apiBase = $\"{graphBase}/{graphVer}\";\n\n            // 2) WABA DISCOVERY\n            string? wabaId = null;\n\n            try\n            {\n                var oauthCfg = _oauthOpts.Value;\n\n                if (!string.IsNullOrWhiteSpace(oauthCfg.AppId) &&\n                    !string.IsNullOrWhiteSpace(oauthCfg.AppSecret))\n                {\n                    var viaDebug = await TryGetWabaFromDebugTokenAsync(\n                        graphBase,\n                        accessToken,\n                        oauthCfg.AppId,\n                        oauthCfg.AppSecret,\n                        ct);\n\n                    if (!string.IsNullOrWhiteSpace(viaDebug))\n                    {\n                        wabaId = viaDebug;\n                        _log.LogInformation(\n                            \"ESU Callback: WABA discovered via debug_token: {WabaId} (biz={BusinessId})\",\n                            wabaId,\n                            businessId);\n                    }\n                }\n                else\n                {\n                    _log.LogWarning(\n                        \"ESU Callback: AppId/AppSecret missing in FacebookOauthOptions; skipping debug_token WABA discovery (biz={BusinessId})\",\n                        businessId);\n                }\n\n                if (string.IsNullOrWhiteSpace(wabaId))\n                {\n                    wabaId = await TryGetWabaFromMeAccountsAsync(apiBase, accessToken, ct);\n                }\n\n                if (string.IsNullOrWhiteSpace(wabaId))\n                {\n                    wabaId = await TryGetWabaFromBusinessesAsync(apiBase, accessToken, ct);\n                }\n\n                if (string.IsNullOrWhiteSpace(wabaId))\n                {\n                    _log.LogWarning(\n                        \"ESU Callback: No WABA discovered for biz={BusinessId}. Token scopes or ESU config may be incomplete.\",\n                        businessId);\n                }\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"ESU Callback: Error during WABA discovery for biz={BusinessId}\", businessId);\n            }\n\n            // 3) SAVE GLOBAL SETTINGS\n            try\n            {\n                var dto = new SaveWhatsAppSettingDto\n                {\n                    BusinessId = businessId,\n                    Provider = Provider,\n                    ApiUrl = apiBase,\n                    ApiKey = accessToken,\n                    WabaId = string.IsNullOrWhiteSpace(wabaId) ? null : wabaId,\n                    SenderDisplayName = null,\n                    WebhookSecret = null,\n                    WebhookVerifyToken = null,\n                    WebhookCallbackUrl = null,\n                    IsActive = true\n                };\n\n                await _waSettings.SaveOrUpdateSettingAsync(dto);\n\n                _log.LogInformation(\n                    \"ESU Callback: WhatsApp settings saved for biz={BusinessId}, provider={Provider}, hasWaba={HasWaba}\",\n                    businessId,\n                    Provider,\n                    !string.IsNullOrWhiteSpace(wabaId));\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"ESU Callback: Failed to save WhatsApp settings for biz={BusinessId}\", businessId);\n            }\n\n            // ‚úÖ IMPORTANT: Load setting ONCE for steps 4 + subscription\n            WhatsAppSettingsDto? setting = null;\n            try\n            {\n                setting = await _waSettings.GetSettingsByBusinessIdAsync(businessId);\n            }\n            catch (Exception ex)\n            {\n                _log.LogWarning(ex, \"ESU Callback: Failed to reload WhatsApp settings for biz={BusinessId}\", businessId);\n            }\n\n            // 4) SYNC PHONE NUMBERS (best-effort, but logged)\n            try\n            {\n                if (setting is not null &&\n                    setting.Provider?.Equals(Provider, StringComparison.OrdinalIgnoreCase) == true &&\n                    !string.IsNullOrWhiteSpace(setting.WabaId) &&\n                    !string.IsNullOrWhiteSpace(setting.ApiKey))\n                {\n                    // ‚úÖ FIX: box tuple into object so \"?.ToString()\" compiles\n                    object syncResult = await _waPhones.SyncFromProviderAsync(businessId, setting, Provider, ct);\n\n                    if (TryExtractCounts(syncResult, out var added, out var updated, out var total))\n                    {\n                        _log.LogInformation(\n                            \"ESU Callback: Phone sync complete for biz={BusinessId}. Added={Added}, Updated={Updated}, Total={Total}\",\n                            businessId, added, updated, total);\n                    }\n                    else\n                    {\n                        _log.LogInformation(\n                            \"ESU Callback: Phone sync complete for biz={BusinessId}. Result={Result}\",\n                            businessId,\n                            syncResult?.ToString() ?? \"<null>\");\n                    }\n                }\n                else\n                {\n                    _log.LogWarning(\n                        \"ESU Callback: Skipping phone sync for biz={BusinessId} (provider={Provider}, WabaId={WabaId}, HasApiKey={HasKey})\",\n                        businessId,\n                        setting?.Provider,\n                        setting?.WabaId ?? \"<none>\",\n                        !string.IsNullOrWhiteSpace(setting?.ApiKey));\n                }\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"ESU Callback: Error during phone sync for biz={BusinessId}\", businessId);\n            }\n\n            // 4b) Subscribe WABA to app events\n            if (setting is not null && !string.IsNullOrWhiteSpace(setting.WabaId))\n            {\n                try\n                {\n                    await SubscribeWabaAsync(setting.WabaId!, accessToken, ct);\n\n                    _log.LogInformation(\n                        \"ESU Callback: WABA subscribed successfully. biz={BusinessId}, wabaId={WabaId}\",\n                        businessId, setting.WabaId);\n                }\n                catch (Exception ex)\n                {\n                    _log.LogWarning(ex,\n                        \"ESU Callback: WABA subscribe failed (non-blocking). businessId={BusinessId}, wabaId={WabaId}\",\n                        businessId, setting.WabaId);\n                }\n            }\n\n            // 5) FLAG AS COMPLETED\n            try\n            {\n                var payloadJson = JsonSerializer.Serialize(new\n                {\n                    completed = true,\n                    provider = Provider,\n                    expires_at_utc = expiresAtUtc\n                });\n\n                await _flagStore.UpsertAsync(\n                    businessId,\n                    key: \"facebook.esu\",\n                    value: \"completed\",\n                    jsonPayload: payloadJson,\n                    ct: ct);\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"ESU Callback: Failed to write ESU completion flag for biz={BusinessId}\", businessId);\n            }\n\n            // 6) AUTO-REGISTER (HYBRID FLOW: Try \"123456\", fallback to UI if mismatch)\n            // CHECK STATUS FIRST: If any number is already CONNECTED, skip registration.\n            var phones = await _waPhones.ListAsync(businessId, Provider, ct);\n            bool alreadyConnected = phones.Any(p => p.Status?.ToUpper() == \"CONNECTED\");\n\n            string finalStatus = \"success\";\n            if (!alreadyConnected) \n            {\n                try \n                {\n                   await RegisterPhoneNumberAsync(businessId, \"123456\", ct);\n                   _log.LogInformation(\"ESU Callback: Auto-registration with default PIN success for biz={BusinessId}\", businessId);\n                }\n                catch (Exception ex) \n                {\n                   // If it's a conflict or specific error, we need the user to enter their old PIN\n                   // 409 Conflict is typical for \"PIN mismatch\" or \"Already registered with different PIN\"\n                   _log.LogWarning(\"ESU Callback: Auto-registration failed (biz={BusinessId}). User must enter PIN manually. Error: {Error}\", businessId, ex.Message);\n                   finalStatus = \"needs_pin\";\n                }\n            }\n            else \n            {\n                _log.LogInformation(\"ESU Callback: Phone(s) already CONNECTED for biz={BusinessId}. Skipping auto-registration.\", businessId);\n            }\n\n            // 7) FINAL REDIRECT\n            var rawReturnUrl = TryGetReturnUrlFromState(state);\n            var redirectBase = SanitizeReturnUrlOrDefault(rawReturnUrl, \"/app/esu-processing\");\n\n            var redirect = redirectBase.Contains(\"?\")\n                ? $\"{redirectBase}&esuStatus={finalStatus}\"\n                : $\"{redirectBase}?esuStatus={finalStatus}\";\n\n            return new FacebookEsuCallbackResponseDto { RedirectTo = redirect };\n        }\n\n        // =======================\n        // DISCONNECT\n        // =======================\n        public async Task DisconnectAsync(Guid businessId, CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty)\n                throw new ArgumentException(\"BusinessId is required.\", nameof(businessId));\n\n            _log.LogInformation(\"ESU Disconnect: biz={BusinessId}\", businessId);\n\n            bool hadEsuOrToken = false;\n\n            object? statusObj = null;\n            try\n            {\n                statusObj = await _esuStatus.GetStatusAsync(businessId, ct);\n                if (statusObj is not null)\n                {\n                    hadEsuOrToken = ReadBool(statusObj, \"Connected\")\n                                    || ReadBool(statusObj, \"HasEsuFlag\")\n                                    || ReadBool(statusObj, \"HasValidToken\");\n                }\n            }\n            catch (Exception ex)\n            {\n                _log.LogWarning(ex, \"ESU Disconnect: failed to read status for biz={BusinessId}; continuing.\", businessId);\n            }\n\n            if (statusObj is not null && (ReadBool(statusObj, \"HardDeleted\") || ReadBool(statusObj, \"IsHardDeleted\")))\n            {\n                _log.LogInformation(\"ESU Disconnect: biz={BusinessId} is hard-deleted; skipping disconnect to avoid re-creating data.\", businessId);\n                return;\n            }\n\n            if (!hadEsuOrToken)\n            {\n                _log.LogInformation(\n                    \"ESU Disconnect: nothing to disconnect for biz={BusinessId} (no ESU flags/tokens/settings).\",\n                    businessId);\n                return;\n            }\n\n            // 1) Remote revoke (best-effort)\n            try\n            {\n                var t = await _tokens.GetAsync(businessId, Provider, ct);\n                if (t is not null && !string.IsNullOrWhiteSpace(t.AccessToken) && !t.IsRevoked)\n                {\n                    var graphBase = _oauthOpts.Value.GraphBaseUrl?.TrimEnd('/') ?? \"https://graph.facebook.com\";\n                    var graphVer = _oauthOpts.Value.GraphApiVersion?.Trim('/') ?? \"v20.0\";\n                    var apiBase = $\"{graphBase}/{graphVer}\";\n\n                    // 1a) Unsubscribe WABA from app (CRITICAL for clean re-signup)\n                    try \n                    {\n                        var setting = await _waSettings.GetSettingsByBusinessIdAsync(businessId);\n                        if (setting is not null && !string.IsNullOrWhiteSpace(setting.WabaId))\n                        {\n                            _log.LogInformation(\"ESU Disconnect: attempting Meta WABA unsubscribe for biz={BusinessId}, waba={WabaId}\", \n                                businessId, setting.WabaId);\n                            \n                            await _wabaSubscription.UnsubscribeAsync(setting.WabaId, t.AccessToken, ct);\n                        }\n                    }\n                    catch (Exception ex)\n                    {\n                        _log.LogWarning(ex, \"ESU Disconnect: Meta WABA unsubscribe failed (non-blocking) for biz={BusinessId}\", businessId);\n                    }\n\n                    // 1b) Revoke permissions\n                    using var http = new HttpClient();\n                    http.DefaultRequestHeaders.Authorization =\n                        new AuthenticationHeaderValue(\"Bearer\", t.AccessToken);\n\n                    var resp = await http.DeleteAsync($\"{apiBase}/me/permissions\", ct);\n                    if (!resp.IsSuccessStatusCode)\n                    {\n                        _log.LogWarning(\n                            \"ESU Disconnect: remote revoke returned {Status} for biz={BusinessId}\",\n                            resp.StatusCode, businessId);\n                    }\n                }\n            }\n            catch (Exception ex)\n            {\n                _log.LogWarning(ex, \"ESU Disconnect: error during remote revoke for biz={BusinessId}\", businessId);\n            }\n\n            // 2) Canonical local deauthorize\n            try\n            {\n                await _esuStatus.DeauthorizeAsync(businessId, ct);\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"ESU Disconnect: error during local deauthorize for biz={BusinessId}\", businessId);\n            }\n\n            // 3) Deactivate WhatsApp settings\n            try\n            {\n                var existing = await _waSettings.GetSettingsByBusinessIdAsync(businessId);\n                if (existing is not null)\n                {\n                    await _waSettings.SaveOrUpdateSettingAsync(new SaveWhatsAppSettingDto\n                    {\n                        BusinessId = businessId,\n                        Provider = Provider,\n                        ApiUrl = null,\n                        ApiKey = null,\n                        WabaId = null,\n                        SenderDisplayName = null,\n                        WebhookSecret = null,\n                        WebhookVerifyToken = null,\n                        WebhookCallbackUrl = null,\n                        IsActive = false\n                    });\n                }\n                else\n                {\n                    _log.LogInformation(\n                        \"ESU Disconnect: WhatsApp settings already absent for biz={BusinessId}; skipping deactivation to avoid recreating rows.\",\n                        businessId);\n                }\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"ESU Disconnect: error deactivating WhatsApp settings for biz={BusinessId}\", businessId);\n            }\n\n            // 4) UX flag\n            try\n            {\n                await _flagStore.UpsertAsync(\n                    businessId,\n                    key: \"facebook.esu\",\n                    value: \"disconnected\",\n                    jsonPayload: \"{\\\"completed\\\":false}\",\n                    ct: ct);\n            }\n            catch (Exception ex)\n            {\n                _log.LogWarning(ex, \"ESU Disconnect: failed to update ESU 'disconnected' flag for biz={BusinessId}\", businessId);\n            }\n        }\n\n        // =======================\n        // FULL DELETE (hard delete)\n        // =======================\n        public async Task FullDeleteAsync(Guid businessId, CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty)\n                throw new ArgumentException(\"BusinessId is required.\", nameof(businessId));\n\n            _log.LogInformation(\"ESU FullDelete: start for biz={BusinessId}\", businessId);\n\n            try\n            {\n                await DisconnectAsync(businessId, ct);\n            }\n            catch (Exception ex)\n            {\n                _log.LogWarning(ex,\n                    \"ESU FullDelete: DisconnectAsync failed or partial for biz={BusinessId}. Continuing with local cleanup.\",\n                    businessId);\n            }\n\n            try\n            {\n                await _tokens.DeleteAsync(businessId, Provider, ct);\n                _log.LogInformation(\"ESU FullDelete: EsuTokens deleted for biz={BusinessId}\", businessId);\n            }\n            catch (Exception ex)\n            {\n                _log.LogWarning(ex, \"ESU FullDelete: failed to delete EsuTokens for biz={BusinessId}\", businessId);\n            }\n\n            try\n            {\n                var deleted = await _waSettings.DeleteSettingsAsync(businessId, ct);\n                _log.LogInformation(\"ESU FullDelete: WhatsApp settings+phones delete={Deleted} for biz={BusinessId}\", deleted, businessId);\n            }\n            catch (Exception ex)\n            {\n                _log.LogWarning(ex, \"ESU FullDelete: failed to delete WhatsApp settings for biz={BusinessId}\", businessId);\n            }\n\n            try\n            {\n                await _flagStore.DeleteAsync(businessId, ct);\n                _log.LogInformation(\"ESU FullDelete: IntegrationFlags row deleted for biz={BusinessId}\", businessId);\n            }\n            catch (Exception ex)\n            {\n                _log.LogWarning(ex, \"ESU FullDelete: failed to delete IntegrationFlags for biz={BusinessId}\", businessId);\n            }\n\n            try\n            {\n                await _fbTokens.InvalidateAsync(businessId, ct);\n            }\n            catch (Exception ex)\n            {\n                _log.LogDebug(ex, \"ESU FullDelete: token cache invalidate failed for biz={BusinessId}\", businessId);\n            }\n\n            _log.LogInformation(\"ESU FullDelete: completed for biz={BusinessId}\", businessId);\n        }\n\n        // =======================\n        // REGISTER NUMBER\n        // =======================\n        public async Task RegisterPhoneNumberAsync(Guid businessId, string pin, CancellationToken ct)\n        {\n            if (businessId == Guid.Empty)\n                throw new ArgumentException(\"BusinessId is required.\", nameof(businessId));\n\n            pin = (pin ?? string.Empty).Trim();\n\n            if (pin.Length != 6 || !IsAllDigits(pin))\n                throw new InvalidOperationException(\"PIN must be exactly 6 digits.\");\n\n            var setting = await _waSettings.GetSettingsByBusinessIdAsync(businessId);\n            if (setting is null)\n                throw new InvalidOperationException(\"WhatsApp settings not found for this business. Please connect ESU first.\");\n\n            if (!string.Equals(setting.Provider, Provider, StringComparison.OrdinalIgnoreCase))\n                throw new InvalidOperationException($\"Invalid provider. Expected '{Provider}' but got '{setting.Provider}'.\");\n\n            if (string.IsNullOrWhiteSpace(setting.ApiUrl) || string.IsNullOrWhiteSpace(setting.ApiKey))\n                throw new InvalidOperationException(\"WhatsApp settings are missing ApiUrl/ApiKey. Please reconnect ESU.\");\n\n            var phones = await _waPhones.ListAsync(businessId, Provider, ct);\n            if (phones is null || phones.Count == 0)\n                throw new InvalidOperationException(\"No phone numbers found. Please complete ESU and phone sync first.\");\n\n            var phone = phones[0];\n            var phoneNumberId = GetPhoneNumberId(phone);\n\n            if (string.IsNullOrWhiteSpace(phoneNumberId))\n                throw new InvalidOperationException(\"PhoneNumberId is missing in stored phone record. Sync did not capture it.\");\n\n            var url = $\"{setting.ApiUrl.TrimEnd('/')}/{phoneNumberId}/register\";\n\n            var payload = new\n            {\n                messaging_product = \"whatsapp\",\n                pin = pin\n            };\n\n            _log.LogInformation(\n                \"ESU RegisterNumber: registering phone_number_id={PhoneNumberId} for biz={BusinessId}\",\n                phoneNumberId,\n                businessId);\n\n            using var http = new HttpClient();\n            http.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(\"Bearer\", setting.ApiKey);\n\n            using var req = new HttpRequestMessage(HttpMethod.Post, url)\n            {\n                Content = JsonContent.Create(payload)\n            };\n\n            using var res = await http.SendAsync(req, ct);\n            var body = await res.Content.ReadAsStringAsync(ct);\n\n            if (!res.IsSuccessStatusCode)\n            {\n                _log.LogWarning(\n                    \"ESU RegisterNumber failed: biz={BusinessId}, phone_number_id={PhoneNumberId}, status={Status}, body={Body}\",\n                    businessId,\n                    phoneNumberId,\n                    (int)res.StatusCode,\n                    Truncate(body));\n\n                throw new InvalidOperationException($\"Failed to register phone number. Meta returned {(int)res.StatusCode}.\");\n            }\n\n            _log.LogInformation(\n                \"ESU RegisterNumber success: biz={BusinessId}, phone_number_id={PhoneNumberId}, body={Body}\",\n                businessId,\n                phoneNumberId,\n                Truncate(body));\n\n            // Best-effort: resync after register\n            try\n            {\n                // ‚úÖ FIX: box tuple into object so \"?.ToString()\" compiles\n                object syncResult = await _waPhones.SyncFromProviderAsync(businessId, setting, Provider, ct);\n\n                if (TryExtractCounts(syncResult, out var added, out var updated, out var total))\n                {\n                    _log.LogInformation(\n                        \"ESU RegisterNumber: phone sync after register complete for biz={BusinessId}. Added={Added}, Updated={Updated}, Total={Total}\",\n                        businessId, added, updated, total);\n                }\n                else\n                {\n                    _log.LogInformation(\n                        \"ESU RegisterNumber: phone sync after register complete for biz={BusinessId}. Result={Result}\",\n                        businessId,\n                        syncResult?.ToString() ?? \"<null>\");\n                }\n            }\n            catch (Exception ex)\n            {\n                _log.LogWarning(ex,\n                    \"ESU RegisterNumber: sync-after-register failed for biz={BusinessId} (non-blocking).\",\n                    businessId);\n            }\n        }\n\n        // =======================\n        // HELPERS\n        // =======================\n        private static string CreateStateToken(Guid businessId, string? returnUrl)\n        {\n            Span<byte> random = stackalloc byte[16];\n            RandomNumberGenerator.Fill(random);\n            var payload =\n                $\"{businessId:N}|{DateTimeOffset.UtcNow.ToUnixTimeSeconds()}|{Convert.ToHexString(random)}|{(returnUrl ?? \"\")}\";\n            var bytes = System.Text.Encoding.UTF8.GetBytes(payload);\n            return WebEncoders.Base64UrlEncode(bytes);\n        }\n\n        private static string? TryGetReturnUrlFromState(string state)\n        {\n            try\n            {\n                var bytes = WebEncoders.Base64UrlDecode(state);\n                var payload = System.Text.Encoding.UTF8.GetString(bytes);\n                var parts = payload.Split('|', 4, StringSplitOptions.None);\n                if (parts.Length == 4)\n                {\n                    var url = parts[3];\n                    return string.IsNullOrWhiteSpace(url) ? null : url;\n                }\n            }\n            catch { }\n            return null;\n        }\n\n        private async Task SubscribeWabaAsync(string wabaId, string accessToken, CancellationToken ct)\n        {\n            var graphBase = _oauthOpts.Value.GraphBaseUrl?.TrimEnd('/') ?? \"https://graph.facebook.com\";\n            var graphVer = _oauthOpts.Value.GraphApiVersion?.Trim('/') ?? \"v20.0\";\n            var url = $\"{graphBase}/{graphVer}/{wabaId}/subscribed_apps\";\n\n            using var http = new HttpClient();\n            http.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(\"Bearer\", accessToken);\n\n            using var res = await http.PostAsync(url, content: null, ct);\n\n            if (!res.IsSuccessStatusCode)\n            {\n                var body = await res.Content.ReadAsStringAsync(ct);\n                throw new InvalidOperationException($\"WABA subscribe failed ({(int)res.StatusCode}). Body: {Truncate(body)}\");\n            }\n        }\n\n        private async Task<string?> TryGetWabaFromDebugTokenAsync(\n            string graphBase,\n            string inputToken,\n            string appId,\n            string appSecret,\n            CancellationToken ct)\n        {\n            try\n            {\n                var appToken = $\"{appId}|{appSecret}\";\n                var url = $\"{graphBase.TrimEnd('/')}/debug_token\" +\n                          $\"?input_token={Uri.EscapeDataString(inputToken)}\" +\n                          $\"&access_token={Uri.EscapeDataString(appToken)}\";\n\n                using var http = new HttpClient();\n                var json = await http.GetStringAsync(url, ct);\n\n                _log.LogDebug(\"ESU debug_token raw={Body}\", Truncate(json));\n\n                using var doc = JsonDocument.Parse(json);\n                var root = doc.RootElement;\n                if (!root.TryGetProperty(\"data\", out var data)) return null;\n\n                if (data.TryGetProperty(\"granular_scopes\", out var scopes) &&\n                    scopes.ValueKind == JsonValueKind.Array)\n                {\n                    foreach (var s in scopes.EnumerateArray())\n                    {\n                        var scope = s.TryGetProperty(\"scope\", out var se) ? se.GetString() : null;\n                        if (string.IsNullOrWhiteSpace(scope)) continue;\n\n                        if (scope.StartsWith(\"whatsapp_business_\", StringComparison.OrdinalIgnoreCase))\n                        {\n                            if (s.TryGetProperty(\"target_ids\", out var targets) &&\n                                targets.ValueKind == JsonValueKind.Array)\n                            {\n                                foreach (var t in targets.EnumerateArray())\n                                {\n                                    var id = t.GetString();\n                                    if (!string.IsNullOrWhiteSpace(id))\n                                        return id;\n                                }\n                            }\n                        }\n                    }\n                }\n\n                return null;\n            }\n            catch (Exception ex)\n            {\n                _log.LogWarning(ex, \"ESU debug_token WABA discovery failed.\");\n                return null;\n            }\n        }\n\n        private async Task<string?> TryGetWabaFromMeAccountsAsync(\n            string apiBase,\n            string accessToken,\n            CancellationToken ct)\n        {\n            var url = $\"{apiBase}/me/whatsapp_business_accounts?fields=id,name\";\n            using var http = new HttpClient();\n            http.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(\"Bearer\", accessToken);\n\n            var res = await http.GetAsync(url, ct);\n            var body = await res.Content.ReadAsStringAsync(ct);\n\n            _log.LogDebug(\"ESU me/whatsapp_business_accounts: {Status} {Body}\",\n                (int)res.StatusCode,\n                Truncate(body));\n\n            if (!res.IsSuccessStatusCode) return null;\n\n            using var doc = JsonDocument.Parse(body);\n            if (!doc.RootElement.TryGetProperty(\"data\", out var arr) || arr.ValueKind != JsonValueKind.Array)\n                return null;\n\n            foreach (var it in arr.EnumerateArray())\n            {\n                if (it.TryGetProperty(\"id\", out var idp))\n                {\n                    var id = idp.GetString();\n                    if (!string.IsNullOrWhiteSpace(id))\n                        return id;\n                }\n            }\n\n            return null;\n        }\n\n        private async Task<string?> TryGetWabaFromBusinessesAsync(\n            string apiBase,\n            string accessToken,\n            CancellationToken ct)\n        {\n            var url =\n                $\"{apiBase}/me/businesses?fields=owned_whatsapp_business_accounts{{id}},client_whatsapp_business_accounts{{id}}\";\n\n            using var http = new HttpClient();\n            http.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(\"Bearer\", accessToken);\n\n            var res = await http.GetAsync(url, ct);\n            var body = await res.Content.ReadAsStringAsync(ct);\n\n            _log.LogDebug(\"ESU me/businesses: {Status} {Body}\",\n                (int)res.StatusCode,\n                Truncate(body));\n\n            if (!res.IsSuccessStatusCode) return null;\n\n            using var doc = JsonDocument.Parse(body);\n            var root = doc.RootElement;\n\n            if (!root.TryGetProperty(\"data\", out var arr) || arr.ValueKind != JsonValueKind.Array)\n                return null;\n\n            foreach (var biz in arr.EnumerateArray())\n            {\n                if (TryPickWabaId(biz, \"owned_whatsapp_business_accounts\", out var ow) &&\n                    !string.IsNullOrWhiteSpace(ow))\n                    return ow;\n\n                if (TryPickWabaId(biz, \"client_whatsapp_business_accounts\", out var cl) &&\n                    !string.IsNullOrWhiteSpace(cl))\n                    return cl;\n            }\n\n            return null;\n        }\n\n        private static string Truncate(string? s, int max = 600)\n        {\n            if (string.IsNullOrWhiteSpace(s)) return string.Empty;\n            s = s.Replace(\"\\r\", \" \").Replace(\"\\n\", \" \");\n            return s.Length <= max ? s : s[..max] + \"...\";\n        }\n\n        private static bool TryPickWabaId(JsonElement biz, string prop, out string? wabaId)\n        {\n            wabaId = null;\n            if (!biz.TryGetProperty(prop, out var block)) return false;\n            if (!block.TryGetProperty(\"data\", out var arr) || arr.ValueKind != JsonValueKind.Array) return false;\n\n            foreach (var it in arr.EnumerateArray())\n            {\n                if (it.TryGetProperty(\"id\", out var idp))\n                {\n                    wabaId = idp.GetString();\n                    if (!string.IsNullOrWhiteSpace(wabaId))\n                        return true;\n                }\n            }\n\n            return false;\n        }\n\n        private static string SanitizeReturnUrlOrDefault(string? returnUrl, string fallback)\n        {\n            if (string.IsNullOrWhiteSpace(returnUrl))\n                return fallback;\n\n            returnUrl = returnUrl.Trim();\n\n            if (!returnUrl.StartsWith(\"/\", StringComparison.Ordinal) ||\n                returnUrl.StartsWith(\"//\", StringComparison.Ordinal) ||\n                returnUrl.Contains(\"\\\\\", StringComparison.Ordinal))\n            {\n                return fallback;\n            }\n\n            return returnUrl;\n        }\n\n        private static bool IsAllDigits(string value)\n        {\n            foreach (var c in value)\n            {\n                if (c < '0' || c > '9') return false;\n            }\n            return true;\n        }\n\n        private static string? GetPhoneNumberId(object phone)\n        {\n            var type = phone.GetType();\n\n            var prop =\n                type.GetProperty(\"ProviderPhoneNumberId\")\n                ?? type.GetProperty(\"PhoneNumberId\")\n                ?? type.GetProperty(\"MetaPhoneNumberId\")\n                ?? type.GetProperty(\"ProviderId\");\n\n            return prop?.GetValue(phone)?.ToString();\n        }\n\n        private static bool TryExtractCounts(object? result, out int added, out int updated, out int total)\n        {\n            added = updated = total = 0;\n            if (result is null) return false;\n\n            var t = result.GetType();\n\n            var pAdded = t.GetProperty(\"Added\");\n            var pUpdated = t.GetProperty(\"Updated\");\n            var pTotal = t.GetProperty(\"Total\");\n\n            if (pAdded is not null && pUpdated is not null && pTotal is not null)\n            {\n                try\n                {\n                    added = Convert.ToInt32(pAdded.GetValue(result));\n                    updated = Convert.ToInt32(pUpdated.GetValue(result));\n                    total = Convert.ToInt32(pTotal.GetValue(result));\n                    return true;\n                }\n                catch { }\n            }\n\n            var f1 = t.GetField(\"Item1\");\n            var f2 = t.GetField(\"Item2\");\n            var f3 = t.GetField(\"Item3\");\n\n            if (f1 is not null && f2 is not null && f3 is not null)\n            {\n                try\n                {\n                    added = Convert.ToInt32(f1.GetValue(result));\n                    updated = Convert.ToInt32(f2.GetValue(result));\n                    total = Convert.ToInt32(f3.GetValue(result));\n                    return true;\n                }\n                catch { }\n            }\n\n            return false;\n        }\n\n        private static bool ReadBool(object obj, string propName)\n        {\n            try\n            {\n                var p = obj.GetType().GetProperty(propName);\n                if (p is null) return false;\n                var val = p.GetValue(obj);\n                return val is bool b && b;\n            }\n            catch\n            {\n                return false;\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Services/FacebookTokenService.cs",
      "sha256": "5b18d40ad124b1d99c057272bfcbb9b6290b68e45fddc41db8b9ae2e80ac9871",
      "language": "csharp",
      "size": 4146,
      "content": "using System;\nusing System.Collections.Concurrent;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Caching.Memory;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.ESU.Facebook.Abstractions;\nusing xbytechat.api.Features.ESU.Facebook.Contracts;\nusing xbytechat.api.Infrastructure;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Services\n{\n    /// <summary>\n    /// Centralized reader for Facebook tokens stored in EsuTokens.\n    /// Includes in-memory caching and per-key locking to avoid stampedes.\n    /// </summary>\n    public sealed class FacebookTokenService : IFacebookTokenService\n    {\n        private const string Provider = \"META_CLOUD\";\n\n        private readonly AppDbContext _db;\n        private readonly IMemoryCache _cache;\n        private readonly ILogger<FacebookTokenService> _log;\n\n        private static readonly ConcurrentDictionary<string, SemaphoreSlim> _locks = new();\n\n        public FacebookTokenService(AppDbContext db, IMemoryCache cache, ILogger<FacebookTokenService> log)\n        {\n            _db = db;\n            _cache = cache;\n            _log = log;\n        }\n\n        private static string CacheKey(Guid biz) => $\"esu:fbtoken:{biz:N}\";\n        private static SemaphoreSlim GetLock(string key) => _locks.GetOrAdd(key, _ => new SemaphoreSlim(1, 1));\n\n        // --- existing methods (TryGetValidAsync, GetRequiredAsync, InvalidateAsync) stay as-is ---\n\n        public async Task<FacebookStoredToken?> TryGetValidAsync(Guid businessId, CancellationToken ct = default)\n        {\n            var key = CacheKey(businessId);\n\n            if (_cache.TryGetValue<FacebookStoredToken?>(key, out var cached) &&\n                cached is not null && !cached.IsExpired() && !cached.WillExpireSoon())\n                return cached;\n\n            var gate = GetLock(key);\n            await gate.WaitAsync(ct).ConfigureAwait(false);\n            try\n            {\n                if (_cache.TryGetValue<FacebookStoredToken?>(key, out cached) &&\n                    cached is not null && !cached.IsExpired() && !cached.WillExpireSoon())\n                    return cached;\n\n                var row = await _db.EsuTokens\n                    .AsNoTracking()\n                    .SingleOrDefaultAsync(x => x.BusinessId == businessId && x.Provider == Provider && !x.IsRevoked, ct)\n                    .ConfigureAwait(false);\n\n                if (row is null || string.IsNullOrWhiteSpace(row.AccessToken)) return null;\n\n                var token = new FacebookStoredToken { AccessToken = row.AccessToken!, ExpiresAtUtc = row.ExpiresAtUtc };\n                if (token.IsExpired() || token.WillExpireSoon()) return null;\n\n                var ttl = token.ExpiresAtUtc.HasValue\n                    ? TimeSpan.FromMinutes(Math.Min(5, Math.Max(1, (token.ExpiresAtUtc.Value - DateTime.UtcNow).TotalMinutes - 1)))\n                    : TimeSpan.FromMinutes(5);\n\n                _cache.Set(key, token, new MemoryCacheEntryOptions { AbsoluteExpirationRelativeToNow = ttl, Size = 1 });\n                return token;\n            }\n            finally { gate.Release(); }\n        }\n\n        public async Task<FacebookStoredToken> GetRequiredAsync(Guid businessId, CancellationToken ct = default)\n        {\n            var token = await TryGetValidAsync(businessId, ct).ConfigureAwait(false);\n            if (token is null) throw new InvalidOperationException(\"Facebook token missing or expired. Please reconnect ESU.\");\n            return token;\n        }\n\n        // ‚úÖ NEW: implement the interface member that the compiler is asking for\n        public async Task<string?> GetAccessTokenAsync(Guid businessId, CancellationToken ct = default)\n        {\n            var token = await TryGetValidAsync(businessId, ct).ConfigureAwait(false);\n            return token?.AccessToken;\n        }\n\n        // keep invalidate async so callers can await it consistently\n        public Task InvalidateAsync(Guid businessId, CancellationToken ct = default)\n        {\n            _cache.Remove(CacheKey(businessId));\n            return Task.CompletedTask;\n        }\n    }\n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Services/IFacebookEsuService.cs",
      "sha256": "807ca414bfe70422d6d131a2c3dffc2ddae4e46830600cf97c7082203efc653d",
      "language": "csharp",
      "size": 728,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.ESU.Facebook.DTOs;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Services\n{\n    public interface IFacebookEsuService\n    {\n        Task<FacebookEsuStartResponseDto> StartAsync(Guid businessId, string? returnUrl, CancellationToken ct = default);\n        Task<FacebookEsuCallbackResponseDto> HandleCallbackAsync(string code, string state, CancellationToken ct = default);\n        Task DisconnectAsync(Guid businessId, CancellationToken ct = default);\n        Task FullDeleteAsync(Guid businessId, CancellationToken ct = default);\n\n        Task RegisterPhoneNumberAsync(Guid businessId, string pin, CancellationToken ct);\n\n\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Shared/EsuFlagCacheOptions.cs",
      "sha256": "2837ccf8cd261897691aa7e4d329811449724b84e176977ed3393062c0394605",
      "language": "csharp",
      "size": 536,
      "content": "#nullable enable\nnamespace xbytechat.api.Features.ESU.Shared\n{\n    /// <summary>Cache knobs for ESU flag reads.</summary>\n    public sealed class EsuFlagCacheOptions\n    {\n        /// <summary>Default TTL for positive cache hits (seconds). Keep short; flags change rarely but we want quick propagation.</summary>\n        public int TtlSeconds { get; set; } = 30;\n\n        /// <summary>TTL for negative lookups (misses). Prevents hammering DB when a flag is absent.</summary>\n        public int MissTtlSeconds { get; set; } = 5;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Shared/EsuFlagStore.cs",
      "sha256": "7dfa5cdbfaf4138039fc02aad6f584c3715c9ddd4cc0c5ac6b9c6d3d593b0bf7",
      "language": "csharp",
      "size": 5072,
      "content": "#nullable enable\nusing System;\nusing System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Caching.Memory;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing xbytechat.api.Features.ESU.Facebook.Models; // IntegrationFlags (plural)\nusing xbytechat.api.Infrastructure;               // AppDbContext\n\nnamespace xbytechat.api.Features.ESU.Shared\n{\n\n    public sealed class EsuFlagStore : IEsuFlagStore\n    {\n        private readonly AppDbContext _db;\n        private readonly ILogger<EsuFlagStore> _log;\n        private readonly IMemoryCache _cache;\n        private readonly EsuFlagCacheOptions _cacheOpts;\n\n        public EsuFlagStore(\n            AppDbContext db,\n            ILogger<EsuFlagStore> log,\n            IMemoryCache cache,\n            IOptions<EsuFlagCacheOptions> cacheOpts)\n        {\n            _db = db;\n            _log = log;\n            _cache = cache;\n            _cacheOpts = cacheOpts.Value;\n        }\n\n        // ---- cache helpers ---------------------------------------------------\n        private static string CacheKey(Guid businessId) => $\"esu:intflags:{businessId:N}\";\n        private void Invalidate(Guid businessId) => _cache.Remove(CacheKey(businessId));\n\n        private async Task<IntegrationFlags?> GetRowAsync(Guid businessId, CancellationToken ct)\n        {\n            if (_cache.TryGetValue<IntegrationFlags?>(CacheKey(businessId), out var cached))\n                return cached;\n\n            var row = await _db.IntegrationFlags\n                .AsNoTracking()\n                .SingleOrDefaultAsync(x => x.BusinessId == businessId, ct)\n                .ConfigureAwait(false);\n\n            var ttl = row is null\n                ? TimeSpan.FromSeconds(_cacheOpts.MissTtlSeconds)\n                : TimeSpan.FromSeconds(_cacheOpts.TtlSeconds);\n\n            _cache.Set(CacheKey(businessId), row, ttl);\n            return row;\n        }\n\n        // ---- legacy-shaped APIs (kept for back-compat) ----------------------\n\n        public async Task<IntegrationFlags?> GetAsync(Guid businessId, string key, CancellationToken ct = default)\n            => await GetRowAsync(businessId, ct).ConfigureAwait(false);\n\n        public async Task<string?> GetValueAsync(Guid businessId, string key, CancellationToken ct = default)\n        {\n            var row = await GetRowAsync(businessId, ct).ConfigureAwait(false);\n            if (row is null) return null;\n\n            if (string.Equals(key, \"FACEBOOK_ESU_COMPLETED\", StringComparison.OrdinalIgnoreCase))\n                return row.FacebookEsuCompleted ? \"true\" : \"false\";\n\n            return null; // unknown legacy key in the explicit-column model\n        }\n\n\n        public async Task UpsertAsync(\n      Guid businessId,\n      string key,\n      string value,\n      string? jsonPayload = null,   // kept for API compatibility; ignored for flags\n      CancellationToken ct = default)\n        {\n            // Load/create the per-business row\n            var row = await _db.IntegrationFlags\n                .AsTracking()\n                .FirstOrDefaultAsync(x => x.BusinessId == businessId, ct);\n\n            if (row == null)\n            {\n                row = new IntegrationFlags\n                {\n                    BusinessId = businessId,\n                    CreatedAtUtc = DateTime.UtcNow\n                };\n                _db.IntegrationFlags.Add(row);\n            }\n\n            // üö´ No secret handling here. Tokens live in EsuTokens only.\n\n            // Mark ESU completed when we get the canonical key/value\n            // (do not flip it back to false if someone passes another value later)\n            if (string.Equals(key, \"facebook.esu\", StringComparison.OrdinalIgnoreCase) &&\n                string.Equals(value, \"completed\", StringComparison.OrdinalIgnoreCase))\n            {\n                row.FacebookEsuCompleted = true;\n            }\n\n            // Touch timestamp; interceptors may also update this\n            row.UpdatedAtUtc = DateTime.UtcNow;\n\n            await _db.SaveChangesAsync(ct).ConfigureAwait(false);\n\n            // Clear any in-process caches (IMemoryCache Remove is sync)\n            Invalidate(businessId);\n        }\n\n       \n\n        public async Task<bool> IsFacebookEsuCompletedAsync(Guid businessId, CancellationToken ct = default)\n        {\n            var row = await GetRowAsync(businessId, ct).ConfigureAwait(false);\n            return row?.FacebookEsuCompleted == true;\n        }\n\n        // FILE: Features/ESU/Facebook/Services/EsuFlagStore.cs\n\n        public async Task DeleteAsync(Guid businessId, CancellationToken ct = default)\n        {\n            var row = await _db.IntegrationFlags\n                .SingleOrDefaultAsync(x => x.BusinessId == businessId, ct)\n                .ConfigureAwait(false);\n\n            if (row is null)\n                return;\n\n            _db.IntegrationFlags.Remove(row);\n            await _db.SaveChangesAsync(ct).ConfigureAwait(false);\n\n            Invalidate(businessId);\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Shared/EsuOptions.cs",
      "sha256": "daad5788b2778e66de306a92ae3bfcbe0e9f88e2db36e65cf429b713d960678d",
      "language": "csharp",
      "size": 546,
      "content": "namespace xbytechat.api.Features.ESU.Shared\n{\n    public sealed class EsuOptions\n    {\n        public FacebookEsuOptions Facebook { get; set; } = new();\n    }\n\n    public sealed class FacebookEsuOptions\n    {\n        public string AppId { get; set; } = string.Empty;\n        public string RedirectUri { get; set; } = string.Empty;\n        public string Scopes { get; set; } = \"whatsapp_business_management,whatsapp_business_messaging\";\n        public int StateTtlMinutes { get; set; } = 20;\n\n        public string? ConfigId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Shared/IEsuFlagStore.cs",
      "sha256": "99df740f3203b19df93ebb5b4c4263b361e58edd8184a2c7b248798330f617b9",
      "language": "csharp",
      "size": 498,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.ESU.Shared\n{\n    public interface IEsuFlagStore\n    {\n     \n\n        Task<bool> IsFacebookEsuCompletedAsync(\n            Guid businessId,\n            CancellationToken ct = default);\n\n        Task UpsertAsync(Guid businessId, string key, string value, string? jsonPayload = null, CancellationToken ct = default);\n        Task DeleteAsync(Guid businessId, CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Shared/IEsuStateStore.cs",
      "sha256": "6bfa023f2023e81813d00ec67d788ee6a8ebd543a62de6b52eac954afbfc082b",
      "language": "csharp",
      "size": 286,
      "content": "using System;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.ESU.Shared\n{\n    public interface IEsuStateStore\n    {\n        Task StoreAsync(string state, Guid businessId, TimeSpan ttl);\n        Task<(bool Found, Guid BusinessId)> TryConsumeAsync(string state);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Shared/Infrastructure/UpdatedAtUtcInterceptor.cs",
      "sha256": "bdaaa5ba5896c90fa6e316bd63ac4d7fe00a6b0d2897f430fc0e250d91ebe2c3",
      "language": "csharp",
      "size": 1737,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Microsoft.EntityFrameworkCore.Diagnostics;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.ESU.Facebook.Models; // IntegrationFlags\n\nnamespace xbytechat.api.Features.ESU.Shared.Infrastructure\n{\n    public sealed class UpdatedAtUtcInterceptor : SaveChangesInterceptor\n    {\n        private static readonly Type[] _trackedTypes = new[]\n        {\n            typeof(IntegrationFlags),\n            // add other entities if you want auto-bump later\n        };\n\n        private static bool ShouldTrack(object entity)\n            => _trackedTypes.Contains(entity.GetType());\n\n        public override InterceptionResult<int> SavingChanges(\n            DbContextEventData eventData, InterceptionResult<int> result)\n        {\n            Touch(eventData.Context);\n            return base.SavingChanges(eventData, result);\n        }\n\n        public override ValueTask<InterceptionResult<int>> SavingChangesAsync(\n            DbContextEventData eventData, InterceptionResult<int> result, CancellationToken cancellationToken = default)\n        {\n            Touch(eventData.Context);\n            return base.SavingChangesAsync(eventData, result, cancellationToken);\n        }\n\n        private static void Touch(DbContext? ctx)\n        {\n            if (ctx == null) return;\n\n            var now = DateTime.UtcNow;\n\n            foreach (var entry in ctx.ChangeTracker.Entries())\n            {\n                if (entry.State == EntityState.Modified && ShouldTrack(entry.Entity))\n                {\n                    var prop = entry.Property(\"UpdatedAtUtc\");\n                    if (prop != null) prop.CurrentValue = now;\n                }\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Shared/MemoryEsuStateStore.cs",
      "sha256": "dde73ec812d607f3d5d5443041bfb0f703210131f014abae66678c931667f677",
      "language": "csharp",
      "size": 885,
      "content": "using System;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Caching.Memory;\n\nnamespace xbytechat.api.Features.ESU.Shared\n{\n    internal sealed class MemoryEsuStateStore : IEsuStateStore\n    {\n        private readonly IMemoryCache _cache;\n        public MemoryEsuStateStore(IMemoryCache cache) => _cache = cache;\n\n        public Task StoreAsync(string state, Guid businessId, TimeSpan ttl)\n        {\n            _cache.Set(state, businessId, ttl);\n            return Task.CompletedTask;\n        }\n\n        public Task<(bool Found, Guid BusinessId)> TryConsumeAsync(string state)\n        {\n            if (_cache.TryGetValue<Guid>(state, out var businessId))\n            {\n                _cache.Remove(state); // one-time use\n                return Task.FromResult((true, businessId));\n            }\n            return Task.FromResult((false, Guid.Empty));\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Shared/UiOptions.cs",
      "sha256": "e3c5bde4a1db7df8037e8ab7daf415886c4cd94c606ddc3a26fa58f4af6b0edb",
      "language": "csharp",
      "size": 162,
      "content": "#nullable enable\nnamespace xbytechat.api.Features.ESU.Shared\n{\n    public sealed class UiOptions\n    {\n        public string? PublicBaseUrl { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/FlowAnalytics/Controllers/FlowAnalyticsController.cs",
      "sha256": "18a260235767524c70c33a6a49f8929060e94415ee98ff743590d207242020e3",
      "language": "csharp",
      "size": 2196,
      "content": "using Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.FlowAnalytics.Services;\n\nnamespace xbytechat.api.Features.FlowAnalytics.Controllers\n{\n    [ApiController]\n    [Route(\"api/flow-analytics\")]\n    public class FlowAnalyticsController : ControllerBase\n    {\n        private readonly IFlowAnalyticsService _analyticsService;\n\n        public FlowAnalyticsController(IFlowAnalyticsService analyticsService)\n        {\n            _analyticsService = analyticsService;\n        }\n\n        // ‚úÖ GET /api/flow-analytics/summary\n        [HttpGet(\"summary\")]\n        [Authorize]\n        public async Task<IActionResult> GetSummary()\n        {\n            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n\n            if (!Guid.TryParse(businessIdClaim, out var businessId))\n                return BadRequest(\"‚ùå Invalid business ID\");\n\n            var result = await _analyticsService.GetAnalyticsSummaryAsync(businessId);\n            return Ok(result);\n        }\n\n        // ‚úÖ GET /api/flow-analytics/most-triggered-steps\n        [HttpGet(\"most-triggered-steps\")]\n        [Authorize]\n        public async Task<IActionResult> GetMostTriggeredSteps()\n        {\n            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n\n            if (!Guid.TryParse(businessIdClaim, out var businessId))\n                return BadRequest(\"‚ùå Invalid business ID\");\n\n            var data = await _analyticsService.GetMostTriggeredStepsAsync(businessId);\n            return Ok(data);\n        }\n\n        // ‚úÖ GET /api/flow-analytics/step-journey-breakdown?startDate=...&endDate=...\n        [HttpGet(\"step-journey-breakdown\")]\n        [Authorize]\n        public async Task<IActionResult> GetStepJourneyBreakdown([FromQuery] DateTime? startDate, [FromQuery] DateTime? endDate)\n        {\n            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n\n            if (!Guid.TryParse(businessIdClaim, out var businessId))\n                return BadRequest(\"‚ùå Invalid business ID\");\n\n            var data = await _analyticsService.GetStepJourneyBreakdownAsync(businessId, startDate, endDate);\n            return Ok(data);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/FlowAnalytics/DTOs/FlowAnalyticsStepJourneyDto.cs",
      "sha256": "25c17b6d295eb4faf667e982e2878b32a18af8a759791962286f17eec9163f6f",
      "language": "csharp",
      "size": 889,
      "content": "namespace xbytechat.api.Features.FlowAnalytics.DTOs\n{\n    public class FlowAnalyticsStepJourneyDto\n    {\n        public Guid StepId { get; set; }\n\n        public string TemplateName { get; set; } = string.Empty;\n\n        public int TotalReached { get; set; }\n\n        public int ClickedNext { get; set; }\n\n        public Guid? NextStepId { get; set; }\n\n        // ‚úÖ Auto-calculated: number of users who dropped off at this step\n        public int DropOff => TotalReached - ClickedNext;\n\n        // ‚úÖ Auto-calculated: percentage of users who clicked \"next\"\n        public double ConversionRate =>\n            TotalReached == 0 ? 0 : Math.Round((double)ClickedNext / TotalReached * 100, 2);\n\n        // ‚úÖ Optional: percentage of users who dropped off\n        public double DropOffRate =>\n            TotalReached == 0 ? 0 : Math.Round((double)DropOff / TotalReached * 100, 2);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/FlowAnalytics/DTOs/FlowAnalyticsSummaryDto.cs",
      "sha256": "5298f0c920ce53f68b8113de057d804750e1a3afd39d3a24e965ae120275118a",
      "language": "csharp",
      "size": 369,
      "content": "namespace xbytechat.api.Features.FlowAnalytics.DTOs\n{\n    public class FlowAnalyticsSummaryDto\n    {\n        public int TotalExecutions { get; set; }\n        public int UniqueContacts { get; set; }\n        public string TopStepTriggered { get; set; } = \"N/A\";\n        public int TopStepCount { get; set; }\n        public DateTime? LastExecutedAt { get; set; }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/FlowAnalytics/DTOs/FlowStepAnalyticsDto.cs",
      "sha256": "538b4b71cb5a0a82ee36ec0147c0014d4f6570b635eb2ce711cb7e8de3119a09",
      "language": "csharp",
      "size": 478,
      "content": "namespace xbytechat.api.Features.FlowAnalytics.DTOs\n{\n    public class FlowStepAnalyticsDto\n    {\n        public Guid StepId { get; set; }\n        public string TemplateName { get; set; } = string.Empty;\n        public int TotalReached { get; set; }\n        public int ClickedNext { get; set; }\n        public int DropOff => TotalReached - ClickedNext;\n        public Guid? NextStepId { get; set; }\n        public DateTime ExecutedAtUtc { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/FlowAnalytics/DTOs/MostTriggeredStepDto.cs",
      "sha256": "18dc2f8497fae7508358e8556503db073d057061d1892fed2882208fa6653588",
      "language": "csharp",
      "size": 310,
      "content": "namespace xbytechat.api.Features.FlowAnalytics.DTOs\n{\n    public class MostTriggeredStepDto\n    {\n        public Guid StepId { get; set; }\n        public string StepName { get; set; } = string.Empty;\n        public int TriggerCount { get; set; }\n        public DateTime? LastTriggeredAt { get; set; }\n    }\n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/FlowAnalytics/Services/FlowAnalyticsService.cs",
      "sha256": "b832767451b9f0161f931082a45a698407bf4cfaa6c5077edef8a2f6d30385cb",
      "language": "csharp",
      "size": 5128,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\nusing xbytechat.api.Features.FlowAnalytics.DTOs;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.FlowAnalytics.Services\n{\n    public class FlowAnalyticsService : IFlowAnalyticsService\n    {\n        private readonly AppDbContext _context;\n\n        public FlowAnalyticsService(AppDbContext context)\n        {\n            _context = context;\n        }\n\n        // ‚úÖ Summary cards (executions, unique contacts, top step)\n        public async Task<FlowAnalyticsSummaryDto> GetAnalyticsSummaryAsync(Guid businessId)\n        {\n            try\n            {\n                Log.Information(\"üìä Generating Flow Analytics Summary for BusinessId: {BusinessId}\", businessId);\n\n                var recentExecutions = await _context.FlowExecutionLogs\n                    .Where(e => e.BusinessId == businessId)\n                    .ToListAsync();\n\n                var totalExecutions = recentExecutions.Count;\n                var uniqueContacts = recentExecutions.Select(e => e.ContactPhone).Distinct().Count();\n                var mostTriggeredStep = recentExecutions\n                    .GroupBy(e => e.StepName)\n                    .OrderByDescending(g => g.Count())\n                    .Select(g => new { Step = g.Key, Count = g.Count() })\n                    .FirstOrDefault();\n\n                return new FlowAnalyticsSummaryDto\n                {\n                    TotalExecutions = totalExecutions,\n                    UniqueContacts = uniqueContacts,\n                    TopStepTriggered = mostTriggeredStep?.Step ?? \"N/A\",\n                    TopStepCount = mostTriggeredStep?.Count ?? 0,\n                    LastExecutedAt = recentExecutions\n                        .OrderByDescending(e => e.ExecutedAt)\n                        .FirstOrDefault()?.ExecutedAt\n                };\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed to generate flow analytics summary\");\n                return new FlowAnalyticsSummaryDto();\n            }\n        }\n\n        // ‚úÖ Top triggered steps leaderboard\n        public async Task<List<MostTriggeredStepDto>> GetMostTriggeredStepsAsync(Guid businessId)\n        {\n            return await _context.FlowExecutionLogs\n                .Where(e => e.BusinessId == businessId)\n                .GroupBy(e => new { e.StepId, e.StepName })\n                .Select(g => new MostTriggeredStepDto\n                {\n                    StepId = g.Key.StepId,\n                    StepName = g.Key.StepName,\n                    TriggerCount = g.Count(),\n                    LastTriggeredAt = g.Max(e => e.ExecutedAt)\n                })\n                .OrderByDescending(x => x.TriggerCount)\n                .Take(5)\n                .ToListAsync();\n        }\n\n        // ‚úÖ Step-by-step journey breakdown (with date filter)\n        public async Task<List<FlowAnalyticsStepJourneyDto>> GetStepJourneyBreakdownAsync(Guid businessId, DateTime? startDate, DateTime? endDate)\n        {\n            var query = _context.FlowExecutionLogs\n                .Where(e => e.BusinessId == businessId);\n\n            if (startDate.HasValue)\n                query = query.Where(e => e.ExecutedAt >= startDate.Value.Date);\n\n            if (endDate.HasValue)\n                query = query.Where(e => e.ExecutedAt <= endDate.Value.Date.AddDays(1).AddTicks(-1));\n\n            var logs = await query.ToListAsync();\n\n            // Group by StepId\n            var grouped = logs\n                .GroupBy(e => new { e.StepId, e.TemplateName, e.TriggeredByButton, e.FlowId })\n                .Select(g => new\n                {\n                    StepId = g.Key.StepId,\n                    TemplateName = g.Key.TemplateName,\n                    TotalReached = g.Count(),\n                    ClickedNext = logs.Count(x =>\n                        x.TriggeredByButton != null &&\n                        x.FlowId == g.Key.FlowId &&\n                        x.StepId != g.Key.StepId &&\n                        x.TriggeredByButton == g.Key.TriggeredByButton\n                    ),\n                    FlowId = g.Key.FlowId,\n                    TriggeredByButton = g.Key.TriggeredByButton\n                })\n                .ToList();\n\n            // Build final breakdown\n            var breakdown = grouped.Select(g => new FlowAnalyticsStepJourneyDto\n            {\n                StepId = g.StepId,\n                TemplateName = g.TemplateName,\n                TotalReached = g.TotalReached,\n                ClickedNext = g.ClickedNext,\n              //  DropOff = g.TotalReached - g.ClickedNext,\n                NextStepId = _context.FlowButtonLinks\n                    .Where(bl =>\n                        bl.CTAFlowStepId == g.StepId &&\n                        bl.ButtonText == g.TriggeredByButton)\n                    .Select(bl => bl.NextStepId)\n                    .FirstOrDefault()\n            }).ToList();\n\n            return breakdown;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/FlowAnalytics/Services/IFlowAnalyticsService.cs",
      "sha256": "65a623c78188e9581eee608e1e5e53404f8431fb317139d50a4caadd86b074ae",
      "language": "csharp",
      "size": 512,
      "content": "using System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.FlowAnalytics.DTOs;\n\nnamespace xbytechat.api.Features.FlowAnalytics.Services\n{\n    public interface IFlowAnalyticsService\n    {\n        Task<FlowAnalyticsSummaryDto> GetAnalyticsSummaryAsync(Guid businessId);\n        Task<List<MostTriggeredStepDto>> GetMostTriggeredStepsAsync(Guid businessId);\n        Task<List<FlowAnalyticsStepJourneyDto>> GetStepJourneyBreakdownAsync(Guid businessId, DateTime? startDate, DateTime? endDate);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Controllers/InboxController.cs",
      "sha256": "3d0e927289537b66319358696495d025ff3f9a5f6c17877f661a19cd1dec1f3e",
      "language": "csharp",
      "size": 9876,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Inbox.DTOs;\nusing xbytechat.api.Features.Inbox.Services;\nusing xbytechat.api.Helpers;\nusing Microsoft.AspNetCore.Authorization;\nusing xbytechat.api.Shared;\nusing Microsoft.AspNetCore.SignalR;\nusing xbytechat.api.Features.Inbox.Hubs;\n\nnamespace xbytechat.api.Features.Inbox.Controllers\n{\n    [ApiController]\n    [Route(\"api/inbox\")]\n    public class InboxController : ControllerBase\n    {\n        private readonly IInboxService _inboxService;\n        private readonly IHubContext<InboxHub> _hubContext; // ‚úÖ for SignalR push\n        private readonly IUnreadCountService _unreadCountService;\n\n        public InboxController(\n            IInboxService inboxService,\n            IHubContext<InboxHub> hubContext,\n            IUnreadCountService unreadCountService)\n        {\n            _inboxService = inboxService;\n            _hubContext = hubContext;\n            _unreadCountService = unreadCountService;\n        }\n\n        /// <summary>\n        /// Send a new message from UI or system.\n        /// </summary>\n        [HttpPost(\"send\")]\n        public async Task<IActionResult> SendMessage([FromBody] InboxMessageDto dto)\n        {\n            if (dto == null || string.IsNullOrWhiteSpace(dto.MessageBody))\n                return BadRequest(\"Message content is required.\");\n\n            var result = await _inboxService.SaveOutgoingMessageAsync(dto);\n            return Ok(result);\n        }\n\n        /// <summary>\n        /// Receive a message from external source (e.g., WhatsApp webhook).\n        /// </summary>\n        [HttpPost(\"receive\")]\n        public async Task<IActionResult> ReceiveMessage([FromBody] InboxMessageDto dto)\n        {\n            if (dto == null || string.IsNullOrWhiteSpace(dto.MessageBody))\n                return BadRequest(\"Incoming message content is required.\");\n\n            // ‚úÖ Ensure IDs are present\n            if (dto.BusinessId == Guid.Empty || dto.ContactId == Guid.Empty)\n                return BadRequest(\"BusinessId and ContactId are required.\");\n\n            // 1) Persist the inbound message\n            var result = await _inboxService.SaveIncomingMessageAsync(dto);\n\n            // 2) Push the real-time message to everyone in this business\n            var groupName = $\"business_{dto.BusinessId}\";\n            await _hubContext.Clients.Group(groupName).SendAsync(\"ReceiveInboxMessage\", new\n            {\n                contactId = dto.ContactId,\n                messageContent = dto.MessageBody,  // ‚úÖ aligned with frontend\n                from = dto.RecipientPhone,\n                status = \"Delivered\",\n                sentAt = DateTime.UtcNow,\n                isIncoming = true\n            });\n\n            // 3) Tell clients to refresh their own unread snapshot (per-user)\n            //    We cannot compute per-user unread here (no userId in webhook context),\n            //    so we emit a refresh signal that clients handle by calling GET /inbox/unread-counts.\n            await _hubContext.Clients.Group(groupName)\n                .SendAsync(\"UnreadCountChanged\", new { refresh = true });\n\n            return Ok(result);\n        }\n\n        /// <summary>\n        /// Fetch message history between agent and customer using business token + contactId.\n        /// </summary>\n        [HttpGet(\"messages\")]\n        public async Task<IActionResult> GetMessagesByContact([FromQuery] Guid contactId)\n        {\n            if (contactId == Guid.Empty)\n                return BadRequest(\"ContactId is required.\");\n\n            var businessId = User.GetBusinessId();\n            var messages = await _inboxService.GetMessagesByContactAsync(businessId, contactId);\n            return Ok(messages);\n        }\n\n        [HttpGet(\"conversation\")]\n        public async Task<IActionResult> GetConversation(\n            [FromQuery] Guid businessId,\n            [FromQuery] string userPhone,\n            [FromQuery] string contactPhone)\n        {\n            if (businessId == Guid.Empty || string.IsNullOrWhiteSpace(userPhone) || string.IsNullOrWhiteSpace(contactPhone))\n                return BadRequest(\"Invalid input.\");\n\n            var messages = await _inboxService.GetConversationAsync(businessId, userPhone, contactPhone);\n            return Ok(messages);\n        }\n\n        [HttpPost(\"mark-read\")]\n        public async Task<IActionResult> MarkMessagesAsRead([FromQuery] Guid contactId)\n        {\n            if (contactId == Guid.Empty)\n                return BadRequest(\"ContactId is required.\");\n\n            var businessId = User.GetBusinessId();\n            await _inboxService.MarkMessagesAsReadAsync(businessId, contactId);\n            return Ok();\n        }\n\n        [HttpGet(\"unread-counts\")]\n        public async Task<IActionResult> GetUnreadCounts()\n        {\n            var businessId = User.GetBusinessId();\n            var userId = User.GetUserId();\n\n            if (businessId == null || userId == null)\n                return Unauthorized();\n\n            var counts = await _unreadCountService.GetUnreadCountsAsync(businessId, userId);\n            return Ok(counts);\n        }\n    }\n}\n\n//using Microsoft.AspNetCore.Mvc;\n//using System;\n//using System.Threading.Tasks;\n//using xbytechat.api.Features.Inbox.DTOs;\n//using xbytechat.api.Features.Inbox.Services;\n//using xbytechat.api.Helpers;\n//using Microsoft.AspNetCore.Authorization;\n//using xbytechat.api.Shared;\n//using Microsoft.AspNetCore.SignalR;\n//using xbytechat.api.Features.Inbox.Hubs;\n//namespace xbytechat.api.Features.Inbox.Controllers\n//{\n//    [ApiController]\n//    [Route(\"api/inbox\")]\n//    public class InboxController : ControllerBase\n//    {\n//        private readonly IInboxService _inboxService;\n//        private readonly IHubContext<InboxHub> _hubContext; // ‚úÖ for SignalR push\n//        private readonly IUnreadCountService _unreadCountService;\n//        public InboxController(IInboxService inboxService, IHubContext<InboxHub> hubContext, IUnreadCountService unreadCountService)\n//        {\n//            _inboxService = inboxService;\n//            _hubContext = hubContext;\n//            _unreadCountService = unreadCountService;   \n//        }\n\n//        /// <summary>\n//        /// Send a new message from UI or system.\n//        /// </summary>\n//        [HttpPost(\"send\")]\n//        public async Task<IActionResult> SendMessage([FromBody] InboxMessageDto dto)\n//        {\n//            if (dto == null || string.IsNullOrWhiteSpace(dto.MessageBody))\n//                return BadRequest(\"Message content is required.\");\n\n//            var result = await _inboxService.SaveOutgoingMessageAsync(dto);\n//            return Ok(result);\n//        }\n\n//        /// <summary>\n//        /// Receive a message from external source (e.g., WhatsApp webhook).\n//        /// </summary>\n//        [HttpPost(\"receive\")]\n//        public async Task<IActionResult> ReceiveMessage([FromBody] InboxMessageDto dto)\n//        {\n//            if (dto == null || string.IsNullOrWhiteSpace(dto.MessageBody))\n//                return BadRequest(\"Incoming message content is required.\");\n\n//            var result = await _inboxService.SaveIncomingMessageAsync(dto);\n\n//            // ‚úÖ Also broadcast in real-time to clients in this business group\n//            var groupName = $\"business_{dto.BusinessId}\";\n//            await _hubContext.Clients.Group(groupName).SendAsync(\"ReceiveInboxMessage\", new\n//            {\n//                contactId = dto.ContactId,\n//                messageContent = dto.MessageBody,  // ‚úÖ aligned with frontend\n//                from = dto.RecipientPhone,\n//                status = \"Delivered\",\n//                sentAt = DateTime.UtcNow,\n//                isIncoming = true\n//            });\n\n//            return Ok(result);\n//        }\n\n//        /// <summary>\n//        /// Fetch message history between agent and customer using business token + contactId.\n//        /// </summary>\n//        [HttpGet(\"messages\")]\n//        public async Task<IActionResult> GetMessagesByContact([FromQuery] Guid contactId)\n//        {\n//            if (contactId == Guid.Empty)\n//                return BadRequest(\"ContactId is required.\");\n\n//            var businessId = User.GetBusinessId();\n//            var messages = await _inboxService.GetMessagesByContactAsync(businessId, contactId);\n//            return Ok(messages);\n//        }\n\n//        [HttpGet(\"conversation\")]\n//        public async Task<IActionResult> GetConversation(\n//            [FromQuery] Guid businessId,\n//            [FromQuery] string userPhone,\n//            [FromQuery] string contactPhone)\n//        {\n//            if (businessId == Guid.Empty || string.IsNullOrWhiteSpace(userPhone) || string.IsNullOrWhiteSpace(contactPhone))\n//                return BadRequest(\"Invalid input.\");\n\n//            var messages = await _inboxService.GetConversationAsync(businessId, userPhone, contactPhone);\n//            return Ok(messages);\n//        }\n\n//        [HttpPost(\"mark-read\")]\n//        public async Task<IActionResult> MarkMessagesAsRead([FromQuery] Guid contactId)\n//        {\n//            if (contactId == Guid.Empty)\n//                return BadRequest(\"ContactId is required.\");\n\n//            var businessId = User.GetBusinessId();\n//            await _inboxService.MarkMessagesAsReadAsync(businessId, contactId);\n//            return Ok();\n//        }\n\n\n//        [HttpGet(\"unread-counts\")]\n//        public async Task<IActionResult> GetUnreadCounts()\n//        {\n//            var businessId = User.GetBusinessId();\n//            var userId = User.GetUserId();\n\n//            if (businessId == null || userId == null)\n//                return Unauthorized();\n\n//            var counts = await _unreadCountService.GetUnreadCountsAsync(\n//                businessId, userId);\n\n//            return Ok(counts);\n//        }\n//    }\n//}\n\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Controllers/QuickRepliesController.cs",
      "sha256": "5033e3cdc140676bd4e47f6ea2fbf18d4cdcfd15e2d7b88c646fd6709a0bdc0d",
      "language": "csharp",
      "size": 7869,
      "content": "using Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Serilog;\nusing xbytechat.api.Features.Inbox.DTOs;\nusing xbytechat.api.Features.Inbox.Services;\nusing xbytechat.api.Helpers; // for User.GetBusinessId(), GetUserId()\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.Inbox.Controllers\n{\n    [Authorize]\n    [ApiController]\n    [Route(\"api/quick-replies\")]\n    public class QuickRepliesController : ControllerBase\n    {\n        private readonly IQuickReplyService _service;\n\n        public QuickRepliesController(IQuickReplyService service) => _service = service;\n\n        [HttpGet]\n        public async Task<IActionResult> GetAll([FromQuery] string? q = null,\n            [FromQuery] string scope = \"all\")\n        {\n            var businessId = User.GetBusinessId();\n            var userId = User.GetUserId();\n\n            // Guid is a value type, so null-checks are useless.\n            // Treat Guid.Empty as \"no id in claims\".\n            if (businessId == Guid.Empty || userId == Guid.Empty)\n                return Unauthorized();\n\n            bool includeBusiness = scope is \"all\" or \"business\";\n            bool includePersonal = scope is \"all\" or \"personal\";\n\n            var list = await _service.GetAllAsync(businessId, userId, q, includeBusiness, includePersonal);\n            return Ok(list);\n        }\n\n        [HttpPost]\n        public async Task<IActionResult> Create([FromBody] QuickReplyCreateDto dto)\n        {\n            var businessId = User.GetBusinessId();\n            var userId = User.GetUserId();\n\n            if (businessId == Guid.Empty || userId == Guid.Empty)\n                return Unauthorized();\n\n            var actor = User.Identity?.Name\n                        ?? (userId != Guid.Empty ? userId.ToString() : \"system\");\n\n            Log.Information(\"Create QuickReply requested by {@Actor}\", actor);\n            var result = await _service.CreateAsync(businessId, userId, actor, dto);\n            return Ok(result);\n        }\n\n        [HttpPut(\"{id:guid}\")]\n        public async Task<IActionResult> Update([FromRoute] Guid id, [FromBody] QuickReplyUpdateDto dto)\n        {\n            var businessId = User.GetBusinessId();\n            var userId = User.GetUserId();\n\n            if (businessId == Guid.Empty || userId == Guid.Empty)\n                return Unauthorized();\n\n            var actor = User.Identity?.Name\n                        ?? (userId != Guid.Empty ? userId.ToString() : \"system\");\n\n            Log.Information(\"Update QuickReply {@QuickReplyId} by {@Actor}\", id, actor);\n            var result = await _service.UpdateAsync(businessId, userId, actor, id, dto);\n            return Ok(result);\n        }\n\n        [HttpPatch(\"{id:guid}/toggle\")]\n        public async Task<IActionResult> Toggle([FromRoute] Guid id, [FromQuery] bool active = true)\n        {\n            var businessId = User.GetBusinessId();\n            var userId = User.GetUserId();\n\n            if (businessId == Guid.Empty || userId == Guid.Empty)\n                return Unauthorized();\n\n            var actor = User.Identity?.Name\n                        ?? (userId != Guid.Empty ? userId.ToString() : \"system\");\n\n            Log.Information(\"Toggle QuickReply {@QuickReplyId} -> {Active} by {@Actor}\", id, active, actor);\n            var result = await _service.ToggleActiveAsync(businessId, userId, actor, id, active);\n            return Ok(result);\n        }\n\n        [HttpDelete(\"{id:guid}\")]\n        public async Task<IActionResult> Delete([FromRoute] Guid id)\n        {\n            var businessId = User.GetBusinessId();\n            var userId = User.GetUserId();\n\n            if (businessId == Guid.Empty || userId == Guid.Empty)\n                return Unauthorized();\n\n            var actor = User.Identity?.Name\n                        ?? (userId != Guid.Empty ? userId.ToString() : \"system\");\n\n            Log.Information(\"Delete QuickReply {@QuickReplyId} by {@Actor}\", id, actor);\n            var result = await _service.DeleteAsync(businessId, userId, actor, id);\n            return Ok(result);\n        }\n    }\n}\n\n\n//using Microsoft.AspNetCore.Authorization;\n//using Microsoft.AspNetCore.Mvc;\n//using Serilog;\n//using xbytechat.api.Features.Inbox.DTOs;\n//using xbytechat.api.Features.Inbox.Services;\n//using xbytechat.api.Helpers; // for User.GetBusinessId(), GetUserId()\n//using xbytechat.api.Shared;\n\n//namespace xbytechat.api.Features.Inbox.Controllers\n//{\n//    [Authorize]\n//    [ApiController]\n//    [Route(\"api/quick-replies\")]\n//    public class QuickRepliesController : ControllerBase\n//    {\n//        private readonly IQuickReplyService _service;\n\n//        public QuickRepliesController(IQuickReplyService service) => _service = service;\n\n//        [HttpGet]\n//        public async Task<IActionResult> GetAll([FromQuery] string? q = null,\n//            [FromQuery] string scope = \"all\")\n//        {\n//            var businessId = User.GetBusinessId();\n//            var userId = User.GetUserId();\n\n//            if (businessId == null || userId == null) return Unauthorized();\n\n//            bool includeBusiness = scope is \"all\" or \"business\";\n//            bool includePersonal = scope is \"all\" or \"personal\";\n\n//            var list = await _service.GetAllAsync(businessId, userId, q, includeBusiness, includePersonal);\n//            return Ok(list);\n//        }\n\n//        [HttpPost]\n//        public async Task<IActionResult> Create([FromBody] QuickReplyCreateDto dto)\n//        {\n//            var businessId = User.GetBusinessId();\n//            var userId = User.GetUserId();\n//            var actor = User.Identity?.Name ?? userId.ToString() ?? \"system\";\n\n//            if (businessId == null || userId == null) return Unauthorized();\n\n//            Log.Information(\"Create QuickReply requested by {@Actor}\", actor);\n//            var result = await _service.CreateAsync(businessId, userId, actor, dto);\n//            return Ok(result);\n//        }\n\n//        [HttpPut(\"{id:guid}\")]\n//        public async Task<IActionResult> Update([FromRoute] Guid id, [FromBody] QuickReplyUpdateDto dto)\n//        {\n//            var businessId = User.GetBusinessId();\n//            var userId = User.GetUserId();\n//            var actor = User.Identity?.Name ?? userId.ToString() ?? \"system\";\n\n//            if (businessId == null || userId == null) return Unauthorized();\n\n//            Log.Information(\"Update QuickReply {@QuickReplyId} by {@Actor}\", id, actor);\n//            var result = await _service.UpdateAsync(businessId, userId, actor, id, dto);\n//            return Ok(result);\n//        }\n\n//        [HttpPatch(\"{id:guid}/toggle\")]\n//        public async Task<IActionResult> Toggle([FromRoute] Guid id, [FromQuery] bool active = true)\n//        {\n//            var businessId = User.GetBusinessId();\n//            var userId = User.GetUserId();\n//            var actor = User.Identity?.Name ?? userId.ToString() ?? \"system\";\n\n//            if (businessId == null || userId == null) return Unauthorized();\n\n//            Log.Information(\"Toggle QuickReply {@QuickReplyId} -> {Active} by {@Actor}\", id, active, actor);\n//            var result = await _service.ToggleActiveAsync(businessId, userId, actor, id, active);\n//            return Ok(result);\n//        }\n\n//        [HttpDelete(\"{id:guid}\")]\n//        public async Task<IActionResult> Delete([FromRoute] Guid id)\n//        {\n//            var businessId = User.GetBusinessId();\n//            var userId = User.GetUserId();\n//            var actor = User.Identity?.Name ?? userId.ToString() ?? \"system\";\n\n//            if (businessId == null || userId == null) return Unauthorized();\n\n//            Log.Information(\"Delete QuickReply {@QuickReplyId} by {@Actor}\", id, actor);\n//            var result = await _service.DeleteAsync(businessId, userId, actor, id);\n//            return Ok(result);\n//        }\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/DTOs/InboxMessageDto.cs",
      "sha256": "bbe5d988e9fd84c5d20f75ed4a389cc2a814c5c84434c9f4a297b84aba02ab7c",
      "language": "csharp",
      "size": 1832,
      "content": "// üìÑ File: Features/Inbox/DTOs/InboxMessageDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.Inbox.DTOs\n{\n    public class InboxMessageDto\n    {\n        public Guid BusinessId { get; set; }\n        public string RecipientPhone { get; set; }\n        public string MessageBody { get; set; }\n        public Guid? ContactId { get; set; }\n        public Guid? CTAFlowStepId { get; set; }\n        public Guid? CTAFlowConfigId { get; set; }\n        public Guid? CampaignId { get; set; }\n        public string? CampaignName { get; set; }       // üÜï To show in chat bubble\n        public string? RenderedBody { get; set; }\n\n        public bool IsIncoming { get; set; }            // üÜï Needed for bubble side\n        public string Status { get; set; }              // üÜï For message ticks\n        public DateTime SentAt { get; set; }            // üÜï For timestamp\n\n        // ‚úÖ NEW: Provider/WAMID idempotency key (Meta \"messages[0].id\")\n        public string? ProviderMessageId { get; set; }\n\n        // ‚úÖ NEW: WhatsApp native media (for inbound/outbound attachments)\n        // Stored as media_id (not public URL) to avoid hosting files ourselves.\n        public string? MediaId { get; set; }            // WhatsApp Cloud API media_id\n        public string? MediaType { get; set; }          // \"image\" | \"document\" | \"video\" | \"audio\" | \"location\"\n        public string? FileName { get; set; }           // original filename (if available)\n        public string? MimeType { get; set; }           // e.g. \"image/jpeg\", \"application/pdf\"\n\n        // ?? WhatsApp location message fields (no MediaId)\n        public double? LocationLatitude { get; set; }\n        public double? LocationLongitude { get; set; }\n        public string? LocationName { get; set; }\n        public string? LocationAddress { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/DTOs/QuickReplyDtos.cs",
      "sha256": "90ec17a9a8c369db09ac8c28b8296c766c31ea78badd34e53397522a8bc08e00",
      "language": "csharp",
      "size": 1460,
      "content": "using System.ComponentModel.DataAnnotations;\nusing xbytechat.api.Features.Inbox.Models;\n\nnamespace xbytechat.api.Features.Inbox.DTOs\n{\n    public sealed class QuickReplyDto\n    {\n        public Guid Id { get; set; }\n        public Guid BusinessId { get; set; }\n        public Guid? OwnerUserId { get; set; }\n        public QuickReplyScope Scope { get; set; }\n        public string Title { get; set; } = string.Empty;\n        public string Body { get; set; } = string.Empty;\n        public string? TagsCsv { get; set; }\n        public string? Language { get; set; }\n        public bool IsActive { get; set; }\n        public DateTime UpdatedAt { get; set; }\n    }\n\n    public sealed class QuickReplyCreateDto\n    {\n        [Required, MaxLength(120)] public string Title { get; set; } = string.Empty;\n        [Required] public string Body { get; set; } = string.Empty;\n        [MaxLength(240)] public string? TagsCsv { get; set; }\n        [MaxLength(8)] public string? Language { get; set; }\n        public QuickReplyScope Scope { get; set; } = QuickReplyScope.Personal;\n    }\n\n    public sealed class QuickReplyUpdateDto\n    {\n        [Required, MaxLength(120)] public string Title { get; set; } = string.Empty;\n        [Required] public string Body { get; set; } = string.Empty;\n        [MaxLength(240)] public string? TagsCsv { get; set; }\n        [MaxLength(8)] public string? Language { get; set; }\n        public bool IsActive { get; set; } = true;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/DTOs/SendInboxMessageDto.cs",
      "sha256": "1ad0e0e61748e9f9e1fab32e1fe533c57a6c8d586694e55aa5b531359804de90",
      "language": "csharp",
      "size": 462,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.Inbox.DTOs\n{\n    /// <summary>\n    /// DTO sent from frontend when a user sends a new message.\n    /// </summary>\n    public class SendInboxMessageDto\n    {\n        [Required]\n        public Guid ContactId { get; set; }\n\n        [Required]\n        public string MessageBody { get; set; }\n\n        public string? MediaUrl { get; set; } // Optional image or file\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/DTOs/SendMessageInputDto.cs",
      "sha256": "3c76bd2b5ce839064134b72aa2114c14c73a98109c680671f5e7c463867f221a",
      "language": "csharp",
      "size": 249,
      "content": "namespace xbytechat.api.Features.Inbox.DTOs\n{\n    public class SendMessageInputDto\n    {\n        public Guid ContactId { get; set; } // üîÅ REMOVE the \"?\" (nullable) unless needed\n        public string Message { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/DTOs/TextOnlyMessageSendDto.cs",
      "sha256": "2d322145a5e6410decb150b108c7d74a656201d9be027b99b02d1c261b4ed4fc",
      "language": "csharp",
      "size": 247,
      "content": "namespace xbytechat.api.Features.Inbox.DTOs\n{\n    public class TextOnlyMessageSendDto\n    {\n        public Guid BusinessId { get; set; }\n\n        public string RecipientNumber { get; set; }\n\n        public string TextContent { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Hubs/InboxHub.cs",
      "sha256": "dc50a81d23d6ff48b0dc5d21dc8631e25679ea931e3a2a1865b1746ebe9b80d4",
      "language": "csharp",
      "size": 9092,
      "content": "using Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.SignalR;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.Features.Inbox.Services;\nusing xbytechat.api.Models;\nusing xbytechat.api.Features.Inbox.Models;\nusing xbytechat.api.Shared;\nusing xbytechat.api.Features.Inbox.DTOs;\n\nnamespace xbytechat.api.Features.Inbox.Hubs\n{\n    [Authorize]\n    public sealed class InboxHub : Hub\n    {\n        private readonly AppDbContext _db;\n        private readonly IMessageEngineService _messageService;\n        private readonly IUnreadCountService _unreadCountService;\n        private readonly ILogger<InboxHub> _logger;\n\n        public InboxHub(\n            AppDbContext db,\n            IMessageEngineService messageService,\n            IUnreadCountService unreadCountService,\n            ILogger<InboxHub> logger)\n        {\n            _db = db;\n            _messageService = messageService;\n            _unreadCountService = unreadCountService;\n            _logger = logger;\n        }\n\n        public override async Task OnConnectedAsync()\n        {\n            //var businessId = Context.User.GetBusinessId();\n            var businessId = Context.User.ResolveBusinessId(Context.GetHttpContext()!);\n            if (businessId == Guid.Empty)\n            {\n                _logger.LogWarning(\"InboxHub connect: missing BusinessId claim. Conn={ConnId}\", Context.ConnectionId);\n                await base.OnConnectedAsync();\n                return;\n            }\n\n            var groupName = GetBusinessGroupName(businessId);\n\n            await Groups.AddToGroupAsync(Context.ConnectionId, groupName);\n            _logger.LogInformation(\"InboxHub connected. Group={Group} Conn={ConnId} UserIdentifier={UserId}\",\n                groupName, Context.ConnectionId, Context.UserIdentifier);\n\n            await base.OnConnectedAsync();\n        }\n\n        public override async Task OnDisconnectedAsync(Exception? exception)\n        {\n           // var businessId = Context.User.GetBusinessId();\n            var businessId = Context.User.ResolveBusinessId(Context.GetHttpContext()!);\n            if (businessId != Guid.Empty)\n            {\n                var groupName = GetBusinessGroupName(businessId);\n                try { await Groups.RemoveFromGroupAsync(Context.ConnectionId, groupName); } catch { /* ignore */ }\n\n                _logger.LogInformation(\"InboxHub disconnected. Group={Group} Conn={ConnId}\", groupName, Context.ConnectionId);\n            }\n\n            await base.OnDisconnectedAsync(exception);\n        }\n\n        // ‚úÖ Frontend should invoke: connection.invoke(\"SendMessageToContact\", { contactId, message })\n        public async Task SendMessageToContact(SendMessageInputDto dto)\n        {\n            if (dto == null)\n                return;\n\n            if (dto.ContactId == Guid.Empty || string.IsNullOrWhiteSpace(dto.Message))\n            {\n                _logger.LogWarning(\"SendMessageToContact invalid payload. ContactId={ContactId}\", dto.ContactId);\n                return;\n            }\n\n           // var businessId = Context.User.GetBusinessId();\n            var businessId = Context.User.ResolveBusinessId(Context.GetHttpContext()!);\n            var userId = Context.User.GetUserId();\n\n            if (businessId == Guid.Empty || userId == Guid.Empty)\n            {\n                _logger.LogWarning(\"SendMessageToContact missing BusinessId/UserId. Conn={ConnId}\", Context.ConnectionId);\n                return;\n            }\n\n            try\n            {\n                // ‚úÖ Lookup recipient phone number from Contacts\n                var contact = await _db.Contacts\n                    .Where(c => c.BusinessId == businessId && c.Id == dto.ContactId)\n                    .FirstOrDefaultAsync();\n\n                if (contact == null || string.IsNullOrWhiteSpace(contact.PhoneNumber))\n                {\n                    _logger.LogWarning(\"SendMessageToContact contact not found or missing phone. BusinessId={BusinessId} ContactId={ContactId}\",\n                        businessId, dto.ContactId);\n\n                    await Clients.Caller.SendAsync(\"ReceiveInboxMessage\", new\n                    {\n                        contactId = dto.ContactId,\n                        messageContent = dto.Message,\n                        from = userId,\n                        status = \"Failed\",\n                        error = \"Invalid contact\"\n                    });\n\n                    return;\n                }\n\n                var sendDto = new TextMessageSendDto\n                {\n                    BusinessId = businessId,\n                    ContactId = dto.ContactId,\n                    RecipientNumber = contact.PhoneNumber,\n                    TextContent = dto.Message\n                };\n\n                var result = await _messageService.SendTextDirectAsync(sendDto);\n\n                var inboxMessage = new\n                {\n                    contactId = dto.ContactId,\n                    messageContent = dto.Message,\n                    from = userId,\n                    status = result.Success ? \"Sent\" : \"Failed\",\n                    sentAt = DateTime.UtcNow,\n                    logId = result.LogId,\n                    senderId = userId,\n                    isIncoming = false\n                };\n\n                // Caller always gets it\n                await Clients.Caller.SendAsync(\"ReceiveInboxMessage\", inboxMessage);\n\n                // Others in the same business get it\n                var groupName = GetBusinessGroupName(businessId);\n                await Clients.GroupExcept(groupName, Context.ConnectionId)\n                    .SendAsync(\"ReceiveInboxMessage\", inboxMessage);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"SendMessageToContact failed. BusinessId={BusinessId} ContactId={ContactId}\",\n                    businessId, dto.ContactId);\n\n                await Clients.Caller.SendAsync(\"ReceiveInboxMessage\", new\n                {\n                    contactId = dto.ContactId,\n                    messageContent = dto.Message,\n                    from = userId,\n                    status = \"Failed\",\n                    error = \"Server error\"\n                });\n            }\n        }\n\n      \n        public async Task MarkAsRead(Guid contactId)\n        {\n            if (contactId == Guid.Empty)\n                return;\n\n            var userId = Context.User.GetUserId();\n           // var businessId = Context.User.GetBusinessId();\n            var businessId = Context.User.ResolveBusinessId(Context.GetHttpContext()!);\n            if (userId == Guid.Empty || businessId == Guid.Empty)\n                return;\n\n            try\n            {\n                var now = DateTime.UtcNow;\n\n                // ‚úÖ Upsert ContactRead\n                var readEntry = await _db.ContactReads\n                    .FirstOrDefaultAsync(r => r.BusinessId == businessId && r.ContactId == contactId && r.UserId == userId);\n\n                if (readEntry == null)\n                {\n                    _db.ContactReads.Add(new ContactRead\n                    {\n                        Id = Guid.NewGuid(),\n                        BusinessId = businessId,\n                        ContactId = contactId,\n                        UserId = userId,\n                        LastReadAt = now\n                    });\n                }\n                else\n                {\n                    readEntry.LastReadAt = now;\n                }\n\n                await _db.SaveChangesAsync();\n\n                // ‚úÖ CRITICAL FIX:\n                // UnreadCountService returns ONLY contacts with unread > 0.\n                // If this contact becomes 0, it will be missing from the dictionary,\n                // so the frontend would never clear the old badge.\n                // Force-send an explicit \"0\" for this contact to the caller.\n                await Clients.Caller.SendAsync(\"UnreadCountChanged\", new\n                {\n                    contactId = contactId,\n                    unreadCount = 0\n                });\n\n                // ‚úÖ Caller also gets their full unread map (for other chats)\n                var unreadCounts = await _unreadCountService.GetUnreadCountsAsync(businessId, userId);\n                await Clients.Caller.SendAsync(\"UnreadCountChanged\", unreadCounts);\n\n                // ‚úÖ Others get \"refresh your own\" signal\n                var groupName = GetBusinessGroupName(businessId);\n                await Clients.GroupExcept(groupName, Context.ConnectionId)\n                    .SendAsync(\"UnreadCountChanged\", new { refresh = true });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex,\n                    \"MarkAsRead failed. BusinessId={BusinessId} UserId={UserId} ContactId={ContactId}\",\n                    businessId, userId, contactId);\n            }\n        }\n\n        private static string GetBusinessGroupName(Guid businessId) => $\"business_{businessId}\";\n    }\n}\n\n\n\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Models/ChatSessionState.cs",
      "sha256": "fa6184f30e1715455ee5b84ae75264c5cc2d46ed4f1721014141ed9036dfda64",
      "language": "csharp",
      "size": 500,
      "content": "namespace xbytechat.api.Features.Inbox.Models\n{\n    public class ChatSessionState\n    {\n        public Guid Id { get; set; } = Guid.NewGuid();\n        public Guid BusinessId { get; set; }\n        public Guid ContactId { get; set; }\n\n        public string Mode { get; set; } = \"automation\"; // values: \"automation\" | \"agent\"\n        public DateTime LastUpdatedAt { get; set; } = DateTime.UtcNow;\n\n        // Optional: track who switched the mode\n        public string? UpdatedBy { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Models/ContactRead.cs",
      "sha256": "aa4dd9980bc6485cf1c4981bf7dfff84f32dcfbacc6c9dbc3be4ba0429c065c6",
      "language": "csharp",
      "size": 474,
      "content": "using System;\n\nnamespace xbytechat.api.Features.Inbox.Models\n{\n    public class ContactRead\n    {\n        public Guid Id { get; set; }\n\n        // üîó FK to Contact\n        public Guid ContactId { get; set; }\n\n        // üîó FK to User (Agent)\n        public Guid UserId { get; set; }\n\n        // üìÖ Last time this agent opened this contact's chat\n        public DateTime LastReadAt { get; set; } = DateTime.UtcNow;\n\n        public Guid BusinessId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Models/QuickReply.cs",
      "sha256": "8b5cba0c3d3af40a8abf6fd445648c0671b6fb294489fcae8c2d8b438291e285",
      "language": "csharp",
      "size": 1180,
      "content": "using System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace xbytechat.api.Features.Inbox.Models\n{\n    public enum QuickReplyScope { Personal = 0, Business = 2 }\n\n    [Table(\"QuickReplies\")]\n    public class QuickReply\n    {\n        [Key] public Guid Id { get; set; }\n        [Required] public Guid BusinessId { get; set; }\n        public Guid? OwnerUserId { get; set; }                // null for Business scope\n\n        [Required, MaxLength(120)] public string Title { get; set; } = string.Empty;\n        [Required] public string Body { get; set; } = string.Empty;\n\n        [MaxLength(240)] public string? TagsCsv { get; set; }\n        [MaxLength(8)] public string? Language { get; set; }   // e.g. \"en\", \"hi\"\n\n        public QuickReplyScope Scope { get; set; } = QuickReplyScope.Personal;\n        public bool IsActive { get; set; } = true;\n        public bool IsDeleted { get; set; } = false;\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n        public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;\n        public string? CreatedBy { get; set; }\n        public string? UpdatedBy { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Repositories/IInboxRepository.cs",
      "sha256": "dc286300119f9a71db85e3f3bae523d75fbf4b7887ccbeacb7aa08166b152045",
      "language": "csharp",
      "size": 1070,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Inbox.Repositories\n{\n    public interface IInboxRepository\n    {\n        Task<List<MessageLog>> GetConversationAsync(Guid businessId, string userPhone, string contactPhone, int limit = 50);\n        Task<MessageLog?> GetLastMessageAsync(Guid businessId, string userPhone, string contactPhone);\n\n        Task AddMessageAsync(MessageLog message);\n        Task SaveChangesAsync();\n\n        Task<List<MessageLog>> GetMessagesByContactIdAsync(Guid businessId, Guid contactId);\n\n        Task<Dictionary<Guid, int>> GetUnreadMessageCountsAsync(Guid businessId);\n        Task MarkMessagesAsReadAsync(Guid businessId, Guid contactId);\n\n        Task<Dictionary<Guid, int>> GetUnreadCountsForUserAsync(Guid businessId, Guid userId);\n\n        // ‚úÖ Step 3: Soft idempotency helper\n        // Used to prevent duplicate inbound inserts when webhook retries arrive.\n        Task<MessageLog?> FindByProviderMessageIdAsync(Guid businessId, string providerMessageId);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Repositories/InboxRepository.cs",
      "sha256": "b9fbbc9cfee67371f563d25176d036696839f4ce37465c843bfb4d13ee4bb90d",
      "language": "csharp",
      "size": 5051,
      "content": "using Microsoft.EntityFrameworkCore;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Inbox.Repositories\n{\n    public class InboxRepository : IInboxRepository\n    {\n        private readonly AppDbContext _context;\n\n        public InboxRepository(AppDbContext context)\n        {\n            _context = context;\n        }\n\n        public async Task<List<MessageLog>> GetConversationAsync(Guid businessId, string userPhone, string contactPhone, int limit = 50)\n        {\n            return await _context.MessageLogs\n                .Where(m => m.BusinessId == businessId &&\n                            ((m.RecipientNumber == contactPhone && m.IsIncoming == false) ||\n                             (m.RecipientNumber == userPhone && m.IsIncoming == true)))\n                .OrderByDescending(m => m.CreatedAt)\n                .Take(limit)\n                .ToListAsync();\n        }\n\n        public async Task<MessageLog?> GetLastMessageAsync(Guid businessId, string userPhone, string contactPhone)\n        {\n            return await _context.MessageLogs\n                .Where(m => m.BusinessId == businessId &&\n                            ((m.RecipientNumber == contactPhone && m.IsIncoming == false) ||\n                             (m.RecipientNumber == userPhone && m.IsIncoming == true)))\n                .OrderByDescending(m => m.CreatedAt)\n                .FirstOrDefaultAsync();\n        }\n\n        public async Task AddMessageAsync(MessageLog message)\n        {\n            await _context.MessageLogs.AddAsync(message);\n        }\n\n        public async Task SaveChangesAsync()\n        {\n            await _context.SaveChangesAsync();\n        }\n\n        public async Task<List<MessageLog>> GetMessagesByContactIdAsync(Guid businessId, Guid contactId)\n        {\n            return await _context.MessageLogs\n                .Include(m => m.SourceCampaign)\n                .Where(m => m.BusinessId == businessId && m.ContactId == contactId)\n                .OrderBy(m => m.CreatedAt)\n                .ToListAsync();\n        }\n\n        public async Task<Dictionary<Guid, int>> GetUnreadMessageCountsAsync(Guid businessId)\n        {\n            return await _context.MessageLogs\n                .Where(m => m.BusinessId == businessId &&\n                            m.IsIncoming &&\n                            m.Status != \"Read\" &&\n                            m.ContactId != null)\n                .GroupBy(m => m.ContactId!.Value)\n                .Select(g => new { ContactId = g.Key, Count = g.Count() })\n                .ToDictionaryAsync(x => x.ContactId, x => x.Count);\n        }\n\n        public async Task MarkMessagesAsReadAsync(Guid businessId, Guid contactId)\n        {\n            var unreadMessages = await _context.MessageLogs\n                .Where(m => m.BusinessId == businessId &&\n                            m.ContactId == contactId &&\n                            m.IsIncoming &&\n                            m.Status != \"Read\")\n                .ToListAsync();\n\n            foreach (var msg in unreadMessages)\n                msg.Status = \"Read\";\n\n            await _context.SaveChangesAsync();\n        }\n\n        public async Task<Dictionary<Guid, int>> GetUnreadCountsForUserAsync(Guid businessId, Guid userId)\n        {\n            var contactReads = await _context.ContactReads\n                .Where(r => r.UserId == userId)\n                .ToDictionaryAsync(r => r.ContactId, r => r.LastReadAt);\n\n            var allMessages = await _context.MessageLogs\n                .Where(m => m.BusinessId == businessId && m.IsIncoming && m.ContactId != null)\n                .ToListAsync();\n\n            var unreadCounts = allMessages\n                .GroupBy(m => m.ContactId!.Value)\n                .ToDictionary(\n                    g => g.Key,\n                    g => g.Count(m =>\n                        !contactReads.ContainsKey(g.Key) ||\n                        (m.SentAt ?? m.CreatedAt) > contactReads[g.Key])\n                );\n\n            return unreadCounts;\n        }\n\n        // ‚úÖ Step 4: Soft idempotency lookup (BusinessId + ProviderMessageId/WAMID)\n        // Used by InboxService to avoid inserting duplicate inbound rows when Meta retries webhooks.\n        public async Task<MessageLog?> FindByProviderMessageIdAsync(Guid businessId, string providerMessageId)\n        {\n            if (businessId == Guid.Empty) return null;\n            if (string.IsNullOrWhiteSpace(providerMessageId)) return null;\n\n            var wamid = providerMessageId.Trim();\n\n            // IMPORTANT:\n            // - Use ProviderMessageId only for webhook idempotency.\n            // - Do NOT match against MessageId here (prevents cross-path collisions).\n            return await _context.MessageLogs\n                .AsNoTracking()\n                .FirstOrDefaultAsync(m =>\n                    m.BusinessId == businessId &&\n                    m.ProviderMessageId != null &&\n                    m.ProviderMessageId == wamid\n                );\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Services/AgentAssignmentService.cs",
      "sha256": "de9062b213ba63cb8695f407ede5c9e8d52a589e0dc1c7a4c5c79fd243389e4e",
      "language": "csharp",
      "size": 1104,
      "content": "using System;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Logging;\n\nnamespace xbytechat.api.Features.Inbox.Services\n{\n    public class AgentAssignmentService : IAgentAssignmentService\n    {\n        private readonly ILogger<AgentAssignmentService> _logger;\n\n        public AgentAssignmentService(ILogger<AgentAssignmentService> logger)\n        {\n            _logger = logger;\n        }\n\n        public Task<bool> IsAgentAvailableAsync(Guid businessId)\n        {\n            // üîß TODO: Replace with real logic based on your agent pool\n            _logger.LogInformation(\"Checking if agent is available for business {BusinessId}\", businessId);\n            return Task.FromResult(true); // Assume always available for MVP\n        }\n\n        public Task AssignAgentToContactAsync(Guid businessId, Guid contactId)\n        {\n            // üîß TODO: Save agent-contact assignment to DB or notify a human agent\n            _logger.LogInformation(\"Assigning agent to contact {ContactId} for business {BusinessId}\", contactId, businessId);\n            return Task.CompletedTask;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Services/ChatSessionStateService.cs",
      "sha256": "5c6672bd07d87501ca9d46e38085cbec03455bae6cc943c8b8df505a7c73808e",
      "language": "csharp",
      "size": 2964,
      "content": "using Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.AutoReplyBuilder.Models;\nusing xbytechat.api.Features.Inbox.Models;\n\nnamespace xbytechat.api.Features.Inbox.Services\n{\n    public class ChatSessionStateService : IChatSessionStateService\n    {\n        private readonly AppDbContext _db;\n\n        public ChatSessionStateService(AppDbContext db)\n        {\n            _db = db;\n        }\n\n        // ‚úÖ Returns current chat mode: \"agent\" or \"auto\"\n        public async Task<string> GetChatModeAsync(Guid businessId, Guid contactId)\n        {\n            var session = await _db.ChatSessionStates\n                .FirstOrDefaultAsync(s => s.BusinessId == businessId && s.ContactId == contactId);\n\n            return session?.Mode ?? \"auto\"; // Default to auto\n        }\n\n        // ‚úÖ Switches to agent mode\n        public async Task SwitchToAgentModeAsync(Guid businessId, Guid contactId)\n        {\n            await UpsertChatModeAsync(businessId, contactId, \"agent\");\n        }\n\n        // ‚úÖ Switches to automation mode\n        public async Task SwitchToAutomationModeAsync(Guid businessId, Guid contactId)\n        {\n            await UpsertChatModeAsync(businessId, contactId, \"auto\");\n        }\n\n        // ‚úÖ Shared logic to insert or update session state\n        private async Task UpsertChatModeAsync(Guid businessId, Guid contactId, string mode)\n        {\n            var existing = await _db.ChatSessionStates\n                .FirstOrDefaultAsync(s => s.BusinessId == businessId && s.ContactId == contactId);\n\n            if (existing != null)\n            {\n                existing.Mode = mode;\n                existing.LastUpdatedAt = DateTime.UtcNow;\n            }\n            else\n            {\n                _db.ChatSessionStates.Add(new ChatSessionState\n                {\n                    BusinessId = businessId,\n                    ContactId = contactId,\n                    Mode = mode,\n                    LastUpdatedAt = DateTime.UtcNow\n                });\n            }\n\n            await _db.SaveChangesAsync();\n        }\n\n        public async Task SetChatModeAsync(Guid businessId, Guid contactId, string mode)\n        {\n            var state = await _db.ChatSessionStates\n                .FirstOrDefaultAsync(x => x.BusinessId == businessId && x.ContactId == contactId);\n\n            if (state == null)\n            {\n                // Insert new if not exists\n                state = new ChatSessionState\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    ContactId = contactId,\n                    Mode = mode,\n                    LastUpdatedAt = DateTime.UtcNow\n                };\n                _db.ChatSessionStates.Add(state);\n            }\n            else\n            {\n                state.Mode = mode;\n                state.LastUpdatedAt = DateTime.UtcNow;\n            }\n\n            await _db.SaveChangesAsync();\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Services/IAgentAssignmentService.cs",
      "sha256": "1eae6f670d61efc4cd6f430a93cf7188c26a6d521ae49cd50ab926aa5bc027ee",
      "language": "csharp",
      "size": 286,
      "content": "using System;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Inbox.Services\n{\n    public interface IAgentAssignmentService\n    {\n        Task<bool> IsAgentAvailableAsync(Guid businessId);\n        Task AssignAgentToContactAsync(Guid businessId, Guid contactId);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Services/IChatSessionStateService.cs",
      "sha256": "3ade6df9341ebca2e5a478331e57315273317bc803a529a4e068cccc323f1693",
      "language": "csharp",
      "size": 404,
      "content": "namespace xbytechat.api.Features.Inbox.Services\n{\n    public interface IChatSessionStateService\n    {\n        Task<string> GetChatModeAsync(Guid businessId, Guid contactId);\n        Task SwitchToAgentModeAsync(Guid businessId, Guid contactId);\n        Task SwitchToAutomationModeAsync(Guid businessId, Guid contactId);\n        Task SetChatModeAsync(Guid businessId, Guid contactId, string mode);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Services/IInboxService.cs",
      "sha256": "58b2b14fb055263d0f08348900a55c5cbd62c16609e1b4ba082beb34a84efc49",
      "language": "csharp",
      "size": 885,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Inbox.DTOs;\nusing xbytechat.api.Features.MessageManagement.DTOs;\n\nnamespace xbytechat.api.Features.Inbox.Services\n{\n    public interface IInboxService\n    {\n        Task<List<MessageLog>> GetConversationAsync(Guid businessId, string userPhone, string contactPhone, int limit = 50);\n        Task<MessageLog> SaveIncomingMessageAsync(InboxMessageDto dto);\n        Task<MessageLog> SaveOutgoingMessageAsync(InboxMessageDto dto);\n        Task<List<MessageLogDto>> GetMessagesByContactAsync(Guid businessId, Guid contactId);\n        Task<Dictionary<Guid, int>> GetUnreadMessageCountsAsync(Guid businessId);\n        Task MarkMessagesAsReadAsync(Guid businessId, Guid contactId);\n\n        Task<Dictionary<Guid, int>> GetUnreadCountsForUserAsync(Guid businessId, Guid userId);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Services/InboxService.cs",
      "sha256": "8f45defa7b8f6ffc93027a8d5cd7092e26d98b0a80c0956f5c457c043e52cea1",
      "language": "csharp",
      "size": 6707,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Inbox.DTOs;\nusing xbytechat.api.Features.Inbox.Repositories;\nusing xbytechat.api.Features.MessageManagement.DTOs;\n\nnamespace xbytechat.api.Features.Inbox.Services\n{\n    public class InboxService : IInboxService\n    {\n        private readonly IInboxRepository _repository;\n\n        public InboxService(IInboxRepository repository)\n        {\n            _repository = repository;\n        }\n\n        public async Task<List<MessageLog>> GetConversationAsync(Guid businessId, string userPhone, string contactPhone, int limit = 50)\n        {\n            return await _repository.GetConversationAsync(businessId, userPhone, contactPhone, limit);\n        }\n\n        public async Task<MessageLog> SaveIncomingMessageAsync(InboxMessageDto dto)\n        {\n            // ‚úÖ Soft idempotency on (BusinessId + ProviderMessageId) if available.\n            // Normalize ProviderMessageId to avoid \"space\" duplicates.\n            var providerMessageId = string.IsNullOrWhiteSpace(dto.ProviderMessageId)\n                ? null\n                : dto.ProviderMessageId.Trim();\n\n            if (!string.IsNullOrWhiteSpace(providerMessageId))\n            {\n                var existing = await _repository.FindByProviderMessageIdAsync(dto.BusinessId, providerMessageId);\n                if (existing != null)\n                    return existing;\n            }\n\n            // ‚úÖ SentAt: caller should pass provider timestamp when available; otherwise fall back to server time.\n            var sentAtUtc = dto.SentAt == default ? DateTime.UtcNow : dto.SentAt;\n\n            var message = new MessageLog\n            {\n                Id = Guid.NewGuid(),\n                BusinessId = dto.BusinessId,\n\n                RecipientNumber = dto.RecipientPhone,\n                MessageContent = dto.MessageBody,\n\n                MediaId = dto.MediaId,\n                MediaType = dto.MediaType,\n                FileName = dto.FileName,\n                MimeType = dto.MimeType,\n                LocationLatitude = dto.LocationLatitude,\n                LocationLongitude = dto.LocationLongitude,\n                LocationName = dto.LocationName,\n                LocationAddress = dto.LocationAddress,\n\n                IsIncoming = true,\n\n                // ‚úÖ Keep status consistent for UI (incoming should never be updated by delivery webhooks now)\n                Status = string.IsNullOrWhiteSpace(dto.Status) ? \"Received\" : dto.Status.Trim(),\n                SentAt = sentAtUtc,\n\n                // ‚úÖ CreatedAt = insert time (server truth)\n                CreatedAt = DateTime.UtcNow,\n\n                ProviderMessageId = providerMessageId,\n\n                ContactId = dto.ContactId,\n                CTAFlowStepId = dto.CTAFlowStepId,\n                CTAFlowConfigId = dto.CTAFlowConfigId,\n                CampaignId = dto.CampaignId,\n                RenderedBody = dto.RenderedBody\n            };\n\n            await _repository.AddMessageAsync(message);\n            await _repository.SaveChangesAsync();\n\n            return message;\n        }\n\n        public async Task<MessageLog> SaveOutgoingMessageAsync(InboxMessageDto dto)\n        {\n            // Outgoing WAMID may be unknown at creation time.\n            // If present (e.g., send returns WAMID and we call this after), add idempotency to avoid duplicates.\n            var providerMessageId = string.IsNullOrWhiteSpace(dto.ProviderMessageId)\n                ? null\n                : dto.ProviderMessageId.Trim();\n\n            if (!string.IsNullOrWhiteSpace(providerMessageId))\n            {\n                var existing = await _repository.FindByProviderMessageIdAsync(dto.BusinessId, providerMessageId);\n                if (existing != null)\n                    return existing;\n            }\n\n            var sentAtUtc = dto.SentAt == default ? DateTime.UtcNow : dto.SentAt;\n\n            var message = new MessageLog\n            {\n                Id = Guid.NewGuid(),\n                BusinessId = dto.BusinessId,\n\n                RecipientNumber = dto.RecipientPhone,\n                MessageContent = dto.MessageBody,\n\n                MediaId = dto.MediaId,\n                MediaType = dto.MediaType,\n                FileName = dto.FileName,\n                MimeType = dto.MimeType,\n                LocationLatitude = dto.LocationLatitude,\n                LocationLongitude = dto.LocationLongitude,\n                LocationName = dto.LocationName,\n                LocationAddress = dto.LocationAddress,\n\n                IsIncoming = false,\n\n                // ‚úÖ Default outgoing status\n                Status = string.IsNullOrWhiteSpace(dto.Status) ? \"Queued\" : dto.Status.Trim(),\n                SentAt = sentAtUtc,\n\n                CreatedAt = DateTime.UtcNow,\n\n                ProviderMessageId = providerMessageId,\n\n                ContactId = dto.ContactId,\n                CTAFlowStepId = dto.CTAFlowStepId,\n                CTAFlowConfigId = dto.CTAFlowConfigId,\n                CampaignId = dto.CampaignId,\n                RenderedBody = dto.RenderedBody\n            };\n\n            await _repository.AddMessageAsync(message);\n            await _repository.SaveChangesAsync();\n\n            return message;\n        }\n\n        public async Task<List<MessageLogDto>> GetMessagesByContactAsync(Guid businessId, Guid contactId)\n        {\n            var messages = await _repository.GetMessagesByContactIdAsync(businessId, contactId);\n\n            return messages.Select(m => new MessageLogDto\n            {\n                Id = m.Id,\n                ContactId = m.ContactId,\n                RecipientNumber = m.RecipientNumber,\n                MessageContent = m.MessageContent,\n                CreatedAt = m.CreatedAt,\n                IsIncoming = m.IsIncoming,\n                RenderedBody = m.RenderedBody,\n                CampaignId = m.CampaignId,\n                CampaignName = m.SourceCampaign?.Name,\n                CTAFlowConfigId = m.CTAFlowConfigId,\n                CTAFlowStepId = m.CTAFlowStepId\n            }).ToList();\n        }\n\n        public async Task<Dictionary<Guid, int>> GetUnreadMessageCountsAsync(Guid businessId)\n        {\n            return await _repository.GetUnreadMessageCountsAsync(businessId);\n        }\n\n        public async Task MarkMessagesAsReadAsync(Guid businessId, Guid contactId)\n        {\n            await _repository.MarkMessagesAsReadAsync(businessId, contactId);\n        }\n\n        public async Task<Dictionary<Guid, int>> GetUnreadCountsForUserAsync(Guid businessId, Guid userId)\n        {\n            return await _repository.GetUnreadCountsForUserAsync(businessId, userId);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Services/IQuickReplyService.cs",
      "sha256": "531cc91cab752357d88cfa2483ab059e7a9ffdcfe4507a3105595cc17e33c1c0",
      "language": "csharp",
      "size": 816,
      "content": "using xbytechat.api.Features.Inbox.DTOs;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.Inbox.Services\n{\n    public interface IQuickReplyService\n    {\n        Task<List<QuickReplyDto>> GetAllAsync(Guid businessId, Guid userId,\n            string? search = null, bool includeBusiness = true, bool includePersonal = true);\n\n        Task<ResponseResult> CreateAsync(Guid businessId, Guid userId, string actor, QuickReplyCreateDto dto);\n        Task<ResponseResult> UpdateAsync(Guid businessId, Guid userId, string actor, Guid id, QuickReplyUpdateDto dto);\n        Task<ResponseResult> ToggleActiveAsync(Guid businessId, Guid userId, string actor, Guid id, bool isActive);\n        Task<ResponseResult> DeleteAsync(Guid businessId, Guid userId, string actor, Guid id);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Services/IUnreadCountService.cs",
      "sha256": "a7e51e22be544e5387038cd46027d2a58f968fbe1db1a3d792cde75ac9bfd4de",
      "language": "csharp",
      "size": 272,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Inbox.Services\n{\n    public interface IUnreadCountService\n    {\n        Task<Dictionary<Guid, int>> GetUnreadCountsAsync(Guid businessId, Guid userId);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Services/QuickReplyService.cs",
      "sha256": "594274585168680028dd399dbf8b94c4efa5438224541ec8ee1140c4a2482253",
      "language": "csharp",
      "size": 8104,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing xbytechat.api.Features.Inbox.DTOs;\nusing xbytechat.api.Features.Inbox.Models;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.Inbox.Services\n{\n    public class QuickReplyService : IQuickReplyService\n    {\n        private readonly AppDbContext _db;\n\n        public QuickReplyService(AppDbContext db) => _db = db;\n\n        public async Task<List<QuickReplyDto>> GetAllAsync(Guid businessId, Guid userId,\n            string? search = null, bool includeBusiness = true, bool includePersonal = true)\n        {\n            var q = _db.Set<QuickReply>()\n                .AsNoTracking()\n                .Where(qr => qr.BusinessId == businessId && !qr.IsDeleted && qr.IsActive);\n\n            if (!includeBusiness) q = q.Where(x => x.Scope == QuickReplyScope.Personal);\n            if (!includePersonal) q = q.Where(x => x.Scope == QuickReplyScope.Business);\n            if (includePersonal && includeBusiness == false)\n                q = q.Where(x => x.OwnerUserId == userId || x.Scope == QuickReplyScope.Business);\n            else if (includePersonal)\n                q = q.Where(x => x.Scope == QuickReplyScope.Business || x.OwnerUserId == userId);\n\n            if (!string.IsNullOrWhiteSpace(search))\n            {\n                var s = search.Trim().ToLower();\n                q = q.Where(x =>\n                    x.Title.ToLower().Contains(s) ||\n                    x.Body.ToLower().Contains(s) ||\n                    (x.TagsCsv != null && x.TagsCsv.ToLower().Contains(s)));\n            }\n\n            return await q\n                .OrderByDescending(x => x.Scope)\n                .ThenBy(x => x.Title)\n                .Select(x => new QuickReplyDto\n                {\n                    Id = x.Id,\n                    BusinessId = x.BusinessId,\n                    OwnerUserId = x.OwnerUserId,\n                    Scope = x.Scope,\n                    Title = x.Title,\n                    Body = x.Body,\n                    TagsCsv = x.TagsCsv,\n                    Language = x.Language,\n                    IsActive = x.IsActive,\n                    UpdatedAt = x.UpdatedAt\n                }).ToListAsync();\n        }\n\n        public async Task<ResponseResult> CreateAsync(Guid businessId, Guid userId, string actor, QuickReplyCreateDto dto)\n        {\n            try\n            {\n                var entity = new QuickReply\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    OwnerUserId = dto.Scope == QuickReplyScope.Personal ? userId : null,\n                    Scope = dto.Scope,\n                    Title = dto.Title.Trim(),\n                    Body = dto.Body,\n                    TagsCsv = dto.TagsCsv,\n                    Language = dto.Language,\n                    IsActive = true,\n                    CreatedAt = DateTime.UtcNow,\n                    UpdatedAt = DateTime.UtcNow,\n                    CreatedBy = actor,\n                    UpdatedBy = actor\n                };\n\n                _db.Add(entity);\n                await _db.SaveChangesAsync();\n\n                Log.Information(\"QuickReply created {@QuickReplyId} for business {@BusinessId} by {@Actor}\",\n                    entity.Id, businessId, actor);\n\n                return ResponseResult.SuccessInfo(\"‚úÖ Quick reply created.\");\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"Error creating quick reply for business {BusinessId}\", businessId);\n                return ResponseResult.ErrorInfo(\"‚ùå Failed to create quick reply.\", ex.ToString()); // pattern like Campaign. :contentReference[oaicite:3]{index=3}\n            }\n        }\n\n        public async Task<ResponseResult> UpdateAsync(Guid businessId, Guid userId, string actor, Guid id, QuickReplyUpdateDto dto)\n        {\n            try\n            {\n                var entity = await _db.Set<QuickReply>()\n                    .FirstOrDefaultAsync(x => x.Id == id && x.BusinessId == businessId && !x.IsDeleted);\n\n                if (entity == null)\n                    return ResponseResult.ErrorInfo(\"‚ùå Quick reply not found.\");\n\n                // Only owner can edit personal; business-scope allowed for now\n                if (entity.Scope == QuickReplyScope.Personal && entity.OwnerUserId != userId)\n                    return ResponseResult.ErrorInfo(\"‚õî You cannot edit another user's personal quick reply.\");\n\n                entity.Title = dto.Title.Trim();\n                entity.Body = dto.Body;\n                entity.TagsCsv = dto.TagsCsv;\n                entity.Language = dto.Language;\n                entity.IsActive = dto.IsActive;\n                entity.UpdatedAt = DateTime.UtcNow;\n                entity.UpdatedBy = actor;\n\n                await _db.SaveChangesAsync();\n\n                Log.Information(\"QuickReply updated {@QuickReplyId} for business {@BusinessId} by {@Actor}\",\n                    id, businessId, actor);\n\n                return ResponseResult.SuccessInfo(\"‚úÖ Quick reply updated.\");\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"Error updating quick reply {@QuickReplyId} for business {BusinessId}\", id, businessId);\n                return ResponseResult.ErrorInfo(\"‚ùå Failed to update quick reply.\", ex.ToString()); // campaign-style. :contentReference[oaicite:4]{index=4}\n            }\n        }\n\n        public async Task<ResponseResult> ToggleActiveAsync(Guid businessId, Guid userId, string actor, Guid id, bool isActive)\n        {\n            try\n            {\n                var entity = await _db.Set<QuickReply>()\n                    .FirstOrDefaultAsync(x => x.Id == id && x.BusinessId == businessId && !x.IsDeleted);\n\n                if (entity == null)\n                    return ResponseResult.ErrorInfo(\"‚ùå Quick reply not found.\");\n\n                if (entity.Scope == QuickReplyScope.Personal && entity.OwnerUserId != userId)\n                    return ResponseResult.ErrorInfo(\"‚õî You cannot modify another user's personal quick reply.\");\n\n                entity.IsActive = isActive;\n                entity.UpdatedAt = DateTime.UtcNow;\n                entity.UpdatedBy = actor;\n                await _db.SaveChangesAsync();\n\n                Log.Information(\"QuickReply toggled {@QuickReplyId} -> {IsActive} by {@Actor}\",\n                    id, isActive, actor);\n\n                return ResponseResult.SuccessInfo(isActive ? \"‚úÖ Enabled.\" : \"‚úÖ Disabled.\");\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"Error toggling quick reply {@QuickReplyId}\", id);\n                return ResponseResult.ErrorInfo(\"‚ùå Failed to toggle quick reply.\", ex.ToString());\n            }\n        }\n\n        public async Task<ResponseResult> DeleteAsync(Guid businessId, Guid userId, string actor, Guid id)\n        {\n            try\n            {\n                var entity = await _db.Set<QuickReply>()\n                    .FirstOrDefaultAsync(x => x.Id == id && x.BusinessId == businessId && !x.IsDeleted);\n\n                if (entity == null)\n                    return ResponseResult.ErrorInfo(\"‚ùå Quick reply not found.\");\n\n                if (entity.Scope == QuickReplyScope.Personal && entity.OwnerUserId != userId)\n                    return ResponseResult.ErrorInfo(\"‚õî You cannot delete another user's personal quick reply.\");\n\n                entity.IsDeleted = true;\n                entity.IsActive = false;\n                entity.UpdatedAt = DateTime.UtcNow;\n                entity.UpdatedBy = actor;\n\n                await _db.SaveChangesAsync();\n\n                Log.Information(\"QuickReply soft-deleted {@QuickReplyId} by {@Actor}\", id, actor);\n                return ResponseResult.SuccessInfo(\"üóëÔ∏è Deleted.\");\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"Error deleting quick reply {@QuickReplyId}\", id);\n                return ResponseResult.ErrorInfo(\"‚ùå Failed to delete quick reply.\", ex.ToString());\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Services/UnreadCountService.cs",
      "sha256": "783deeff0e4866ddc454bb9d642e26f173a37a45b82a87ad3f75c6150fdecd74",
      "language": "csharp",
      "size": 1537,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.Inbox.Services\n{\n    public class UnreadCountService : IUnreadCountService\n    {\n        private readonly AppDbContext _db;\n\n        public UnreadCountService(AppDbContext db)\n        {\n            _db = db;\n        }\n\n        public async Task<Dictionary<Guid, int>> GetUnreadCountsAsync(Guid businessId, Guid userId)\n        {\n            if (businessId == Guid.Empty || userId == Guid.Empty)\n                return new Dictionary<Guid, int>();\n\n            var userReads = _db.ContactReads.AsNoTracking()\n                .Where(r => r.BusinessId == businessId && r.UserId == userId);\n\n            var query = _db.MessageLogs.AsNoTracking()\n                .Where(m => m.BusinessId == businessId && m.IsIncoming && m.ContactId != null)\n                .GroupJoin(\n                    userReads,\n                    m => m.ContactId,\n                    r => r.ContactId,\n                    (m, rj) => new { m, rj }\n                )\n                .SelectMany(x => x.rj.DefaultIfEmpty(), (x, r) => new { x.m, r })\n                .Where(x => x.r == null || (x.m.SentAt ?? x.m.CreatedAt) > x.r.LastReadAt)\n                .GroupBy(x => x.m.ContactId!.Value)\n                .Select(g => new { ContactId = g.Key, Count = g.Count() });\n\n            return await query.ToDictionaryAsync(x => x.ContactId, x => x.Count);\n        }\n    }\n}\n\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/SignalR/NameUserIdProvider.cs",
      "sha256": "a634119a30658c1936e6d36db5e2a6a0a715e39bb50651261139ca883a92262b",
      "language": "csharp",
      "size": 810,
      "content": "using Microsoft.AspNetCore.SignalR;\nusing System.Security.Claims;\n\nnamespace xbytechat.api.SignalR\n{\n    public sealed class NameUserIdProvider : IUserIdProvider\n    {\n        public string? GetUserId(HubConnectionContext connection)\n        {\n            var user = connection.User;\n            if (user == null) return null;\n\n            // Prefer NameIdentifier\n            var id = user.FindFirstValue(ClaimTypes.NameIdentifier);\n            if (!string.IsNullOrWhiteSpace(id)) return id;\n\n            // Fallbacks (depending on how JWT was created)\n            id = user.FindFirstValue(\"sub\");\n            if (!string.IsNullOrWhiteSpace(id)) return id;\n\n            id = user.FindFirstValue(\"userId\");\n            if (!string.IsNullOrWhiteSpace(id)) return id;\n\n            return null;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessageLogging/Services/IMessageLogSink.cs",
      "sha256": "280e1b16e5989b3a0f91f1bd6cc41fc9efce73fa0d89328db4cf1e0bd76926c4",
      "language": "csharp",
      "size": 205,
      "content": "namespace xbytechat.api.Features.MessageLogging.Services\n{\n    /// Fire-and-forget enqueue API for MessageLog rows.\n    public interface IMessageLogSink\n    {\n        void Enqueue(MessageLog row);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessageLogging/Services/MessageLogSink.cs",
      "sha256": "a6981361a8c0176c508a4e6d7a15cb7dd9d5feeac16393073ae13d0115802757",
      "language": "csharp",
      "size": 1911,
      "content": "using System.Threading.Channels;\nusing Microsoft.EntityFrameworkCore;\n\nnamespace xbytechat.api.Features.MessageLogging.Services \n{\n    /// Background batch writer for MessageLogs.\n    public sealed class MessageLogSink : BackgroundService, IMessageLogSink\n    {\n        private readonly Channel<MessageLog> _channel =\n            Channel.CreateBounded<MessageLog>(new BoundedChannelOptions(20_000)\n            {\n                SingleReader = false,\n                SingleWriter = false,\n                FullMode = BoundedChannelFullMode.DropOldest\n            });\n\n        private readonly IServiceProvider _sp;\n        private const int BatchSize = 1000;\n\n        public MessageLogSink(IServiceProvider sp) => _sp = sp;\n\n        public void Enqueue(MessageLog row) => _channel.Writer.TryWrite(row);\n\n        protected override async Task ExecuteAsync(CancellationToken ct)\n        {\n            var batch = new List<MessageLog>(BatchSize);\n\n            while (!ct.IsCancellationRequested)\n            {\n                try\n                {\n                    while (batch.Count < BatchSize && _channel.Reader.TryRead(out var x))\n                        batch.Add(x);\n\n                    if (batch.Count == 0)\n                    {\n                        var first = await _channel.Reader.ReadAsync(ct);\n                        batch.Add(first);\n                    }\n\n                    using var scope = _sp.CreateScope();\n                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n                    db.ChangeTracker.AutoDetectChangesEnabled = false;\n\n                    await db.MessageLogs.AddRangeAsync(batch, ct);\n                    await db.SaveChangesAsync(ct);\n                    batch.Clear();\n                }\n                catch (TaskCanceledException) { /* shutdown */ }\n                catch { await Task.Delay(200, ct); }\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessageLogging/Services/MessageLogSinkOptions.cs",
      "sha256": "cf616a6c8a74f14ef5d9d26196a18cc97784dc052238edf6129917208b04fc3b",
      "language": "csharp",
      "size": 344,
      "content": "namespace xbytechat.api.Features.MessageLogging.Services;\n\npublic sealed class MessageLogSinkOptions\n{\n    // rows per COPY\n    public int BatchSize { get; set; } = 1000;\n\n    // flush if idle for this long (ms)\n    public int FlushIntervalMs { get; set; } = 800;\n\n    // fallback to EF if false\n    public bool UseCopy { get; set; } = true;\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessageLogging/Services/PostgresCopyMessageLogSink.cs",
      "sha256": "ca5ff5777e78aba4785a0e62c731d7c4f4b29b8e8491e191372626e7ad92548b",
      "language": "csharp",
      "size": 12184,
      "content": "using System.Threading.Channels;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing Npgsql;\nusing NpgsqlTypes;\nusing xbytechat.api.Features.CampaignTracking.Models; // MessageLog\nusing xbytechat.api.AuthModule.Models;               // AppDbContext\n\nnamespace xbytechat.api.Features.MessageLogging.Services;\n\n/// <summary>\n/// Background sink that batches MessageLogs and writes with COPY BINARY into Postgres.\n/// Falls back to EF AddRange on error or when UseCopy=false.\n/// </summary>\npublic sealed class PostgresCopyMessageLogSink : BackgroundService, IMessageLogSink\n{\n    private readonly IServiceProvider _sp;\n    private readonly ILogger<PostgresCopyMessageLogSink> _log;\n    private readonly MessageLogSinkOptions _opt;\n    private readonly Channel<MessageLog> _ch;\n\n    public PostgresCopyMessageLogSink(\n        IServiceProvider sp,\n        ILogger<PostgresCopyMessageLogSink> log,\n        IOptions<MessageLogSinkOptions> opt)\n    {\n        _sp = sp;\n        _log = log;\n        _opt = opt?.Value ?? new MessageLogSinkOptions();\n\n        _ch = Channel.CreateBounded<MessageLog>(new BoundedChannelOptions(capacity: 50_000)\n        {\n            SingleReader = true,\n            SingleWriter = false,\n            FullMode = BoundedChannelFullMode.Wait\n        });\n\n        _log.LogInformation(\"MessageLog sink initialized (BatchSize={Batch}, FlushIntervalMs={Flush}, UseCopy={UseCopy})\",\n            _opt.BatchSize, _opt.FlushIntervalMs, _opt.UseCopy);\n    }\n\n    public void Enqueue(MessageLog row)\n    {\n        // Fast path: try non-blocking write.\n        if (!_ch.Writer.TryWrite(row))\n        {\n            // Channel is full or not ready: enqueue asynchronously without blocking the caller.\n            _ = _ch.Writer.WriteAsync(row);\n        }\n    }\n\n    protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n    {\n        var batch = new List<MessageLog>(_opt.BatchSize);\n        var flushDelay = TimeSpan.FromMilliseconds(Math.Max(100, _opt.FlushIntervalMs));\n\n        while (!stoppingToken.IsCancellationRequested)\n        {\n            try\n            {\n                // Wait for either new data or idle timeout to flush partial batches\n                var readTask = _ch.Reader.WaitToReadAsync(stoppingToken).AsTask();\n                var delayTask = Task.Delay(flushDelay, stoppingToken);\n                var winner = await Task.WhenAny(readTask, delayTask);\n\n                if (winner == readTask && await readTask)\n                {\n                    while (_ch.Reader.TryRead(out var row))\n                    {\n                        batch.Add(row);\n                        if (batch.Count >= _opt.BatchSize)\n                        {\n                            await FlushAsync(batch, stoppingToken);\n                            batch.Clear();\n                        }\n                    }\n                }\n\n                // Idle flush if timer fired and we have pending rows\n                if (winner == delayTask && batch.Count > 0)\n                {\n                    await FlushAsync(batch, stoppingToken);\n                    batch.Clear();\n                }\n            }\n            catch (OperationCanceledException) { /* shutdown */ }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"[MessageLogSink] loop error\");\n                await Task.Delay(500, stoppingToken);\n            }\n        }\n\n        // final drain\n        try\n        {\n            if (batch.Count > 0) await FlushAsync(batch, CancellationToken.None);\n        }\n        catch (Exception ex)\n        {\n            _log.LogError(ex, \"[MessageLogSink] final flush failed\");\n        }\n    }\n\n    private async Task FlushAsync(List<MessageLog> rows, CancellationToken ct)\n    {\n        if (rows.Count == 0) return;\n\n        using var scope = _sp.CreateScope();\n        var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n\n        _log.LogInformation(\n            \"[MessageLogSink] Flushing {Count} logs. FirstIds={Ids}\",\n            rows.Count,\n            string.Join(\",\", rows.Take(5).Select(x => x.Id)));\n\n        if (_opt.UseCopy && db.Database.IsNpgsql())\n        {\n            var connString = db.Database.GetDbConnection().ConnectionString;\n\n            await using var conn = new NpgsqlConnection(connString);\n            await conn.OpenAsync(ct);\n\n            // ‚úÖ Align with table: both IsChargeable and IsIncoming are present (in this order)\n            // ‚úÖ Added ContactId to COPY list (positional order matters)\n            // ‚úÖ Also keep it close to BusinessId/CampaignId for clarity\n            const string copySql = @\"\nCOPY \"\"MessageLogs\"\" (\n    \"\"Id\"\",\n    \"\"BusinessId\"\",\n    \"\"CampaignId\"\",\n    \"\"ContactId\"\",\n    \"\"RecipientNumber\"\",\n    \"\"MessageContent\"\",\n    \"\"MediaUrl\"\",\n    \"\"Status\"\",\n    \"\"MessageId\"\",\n    \"\"ErrorMessage\"\",\n    \"\"RawResponse\"\",\n    \"\"CreatedAt\"\",\n    \"\"SentAt\"\",\n    \"\"Source\"\",\n    \"\"RunId\"\",\n    \"\"Provider\"\",\n    \"\"ProviderMessageId\"\",\n    \"\"IsChargeable\"\",\n    \"\"IsIncoming\"\"\n) FROM STDIN (FORMAT BINARY);\";\n\n\n            try\n            {\n                await using var importer = await conn.BeginBinaryImportAsync(copySql, ct);\n\n                foreach (var r in rows)\n                {\n                    await importer.StartRowAsync(ct);\n\n                    //importer.Write(r.Id, NpgsqlDbType.Uuid);\n                    //importer.Write(r.BusinessId, NpgsqlDbType.Uuid);\n                    //importer.Write(r.CampaignId, NpgsqlDbType.Uuid);\n\n                    //if (string.IsNullOrWhiteSpace(r.RecipientNumber)) importer.WriteNull();\n                    //else importer.Write(r.RecipientNumber, NpgsqlDbType.Text);\n                    importer.Write(r.Id, NpgsqlDbType.Uuid);\n                    importer.Write(r.BusinessId, NpgsqlDbType.Uuid);\n\n                    // ‚úÖ CampaignId can be nullable in many systems; write safely\n                    if (r.CampaignId.HasValue) importer.Write(r.CampaignId.Value, NpgsqlDbType.Uuid);\n                    else importer.WriteNull();\n\n                    // ‚úÖ NEW: ContactId (nullable) ‚Äî must match COPY column order exactly\n                    if (r.ContactId.HasValue) importer.Write(r.ContactId.Value, NpgsqlDbType.Uuid);\n                    else importer.WriteNull();\n\n                    if (string.IsNullOrWhiteSpace(r.RecipientNumber)) importer.WriteNull();\n                    else importer.Write(r.RecipientNumber, NpgsqlDbType.Text);\n\n\n\n                    if (string.IsNullOrWhiteSpace(r.MessageContent)) importer.WriteNull();\n                    else importer.Write(r.MessageContent, NpgsqlDbType.Text);\n\n                    if (string.IsNullOrWhiteSpace(r.MediaUrl)) importer.WriteNull();\n                    else importer.Write(r.MediaUrl, NpgsqlDbType.Text);\n\n                    if (string.IsNullOrWhiteSpace(r.Status)) importer.WriteNull();\n                    else importer.Write(r.Status, NpgsqlDbType.Text);\n\n                    if (string.IsNullOrWhiteSpace(r.MessageId)) importer.WriteNull();\n                    else importer.Write(r.MessageId, NpgsqlDbType.Text);\n\n                    if (string.IsNullOrWhiteSpace(r.ErrorMessage)) importer.WriteNull();\n                    else importer.Write(r.ErrorMessage, NpgsqlDbType.Text);\n\n                    if (string.IsNullOrWhiteSpace(r.RawResponse)) importer.WriteNull();\n                    else importer.Write(r.RawResponse, NpgsqlDbType.Text);\n\n                    importer.Write(r.CreatedAt, NpgsqlDbType.TimestampTz);\n                    if (r.SentAt.HasValue) importer.Write(r.SentAt.Value, NpgsqlDbType.TimestampTz);\n                    else importer.WriteNull();\n\n                    if (string.IsNullOrWhiteSpace(r.Source)) importer.WriteNull();\n                    else importer.Write(r.Source, NpgsqlDbType.Text);\n\n                    importer.Write(r.RunId, NpgsqlDbType.Uuid);\n\n                    if (string.IsNullOrWhiteSpace(r.Provider)) importer.WriteNull();\n                    else importer.Write(r.Provider, NpgsqlDbType.Text);\n\n                    if (string.IsNullOrWhiteSpace(r.ProviderMessageId)) importer.WriteNull();\n                    else importer.Write(r.ProviderMessageId, NpgsqlDbType.Text);\n\n                    // ‚úÖ keep order in sync with COPY list\n                    importer.Write(r.IsChargeable, NpgsqlDbType.Boolean);\n                    importer.Write(r.IsIncoming, NpgsqlDbType.Boolean);\n                }\n\n                await importer.CompleteAsync(ct);\n                _log.LogDebug(\"[MessageLogSink] COPY inserted {Count} rows\", rows.Count);\n                return;\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex,\n                    \"[MessageLogSink] COPY failed, falling back to EF for {Count} rows. FirstIds={Ids}\",\n                    rows.Count,\n                    string.Join(\",\", rows.Take(5).Select(x => x.Id)));\n                // fall through to EF path\n            }\n        }\n\n        // Fallback EF insert\n        db.ChangeTracker.AutoDetectChangesEnabled = false;\n        try\n        {\n            var written = await db.BulkInsertMessageLogsAsync(rows, ct);\n            var ids = rows.Select(x => x.Id).ToList();\n\n            if (written != rows.Count)\n            {\n                _log.LogError(\n                    \"[MessageLogSink] EF insert wrote {Written}/{Count} rows. FirstIds={Ids}\",\n                    written, rows.Count, string.Join(\",\", ids.Take(5)));\n            }\n\n            // Verify all IDs are present; if not, try once more for missing rows\n            var existingIds = await db.MessageLogs\n                .AsNoTracking()\n                .Where(m => ids.Contains(m.Id))\n                .Select(m => m.Id)\n                .ToListAsync(ct);\n\n            var missing = ids.Except(existingIds).ToList();\n            if (missing.Count > 0)\n            {\n                _log.LogError(\n                    \"[MessageLogSink] EF verification missing {Missing} rows. MissingIds={Ids}\",\n                    missing.Count, string.Join(\",\", missing));\n\n                var missingRows = rows.Where(r => missing.Contains(r.Id)).ToList();\n                db.MessageLogs.AddRange(missingRows);\n                var retryWritten = await db.SaveChangesAsync(ct);\n\n                var retryExisting = await db.MessageLogs\n                    .AsNoTracking()\n                    .Where(m => ids.Contains(m.Id))\n                    .Select(m => m.Id)\n                    .ToListAsync(ct);\n\n                var stillMissing = ids.Except(retryExisting).ToList();\n                if (stillMissing.Count > 0)\n                {\n                    _log.LogError(\n                        \"[MessageLogSink] EF insert retry still missing {Missing} rows. MissingIds={Ids}\",\n                        stillMissing.Count, string.Join(\",\", stillMissing));\n                    throw new InvalidOperationException(\"MessageLogSink failed to persist MessageLogs: \" + string.Join(\",\", stillMissing));\n                }\n\n                _log.LogInformation(\n                    \"[MessageLogSink] EF retry inserted missing rows. Written={Written} RetryWritten={RetryWritten}\",\n                    written, retryWritten);\n            }\n            else\n            {\n                _log.LogInformation(\n                    \"[MessageLogSink] EF insert succeeded for {Count} rows. FirstIds={Ids}\",\n                    rows.Count, string.Join(\",\", ids.Take(5)));\n            }\n        }\n        catch (Exception ex)\n        {\n            _log.LogError(ex,\n                \"[MessageLogSink] EF insert failed for {Count} rows. FirstIds={Ids}\",\n                rows.Count,\n                string.Join(\",\", rows.Take(5).Select(x => x.Id)));\n            throw;\n        }\n    }\n\n}\n\n/// <summary>\n/// Small EF helper for fallback insert path (kept here for locality).\n/// </summary>\ninternal static class MessageLogEfFallback\n{\n    public static async Task<int> BulkInsertMessageLogsAsync(this AppDbContext db, IEnumerable<MessageLog> rows, CancellationToken ct)\n    {\n        db.MessageLogs.AddRange(rows);\n        return await db.SaveChangesAsync(ct);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessageManagement/Controllers/MessageStatusController.cs",
      "sha256": "7b3c0a7925b1f33437cf3ad3692763936a63560660f199ba962d0999bfee7963",
      "language": "csharp",
      "size": 3233,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.MessageManagement.DTOs;\nusing xbytechat.api.Features.MessageManagement.Services;\n\nnamespace xbytechat.api.Features.MessageManagement.Controllers\n{\n    [ApiController]\n    [Route(\"api/message-status\")]\n    public class MessageStatusController : ControllerBase\n    {\n        private readonly IMessageStatusService _service;\n        private readonly ILogger<MessageStatusController> _logger;\n        private readonly AppDbContext _context;\n        private readonly IConfiguration _config;\n        public MessageStatusController(\n    IMessageStatusService service,\n    ILogger<MessageStatusController> logger,\n    AppDbContext context,\n    IConfiguration config)\n        {\n            _service = service;\n            _logger = logger;\n            _context = context;\n            _config = config;\n        }\n\n        // ‚úÖ STEP 1: Webhook Verification (GET)\n        [HttpGet(\"webhook\")]\n        public IActionResult VerifyWebhook([FromQuery(Name = \"hub.mode\")] string mode,\n                                    [FromQuery(Name = \"hub.verify_token\")] string token,\n                                    [FromQuery(Name = \"hub.challenge\")] string challenge)\n        {\n            //var VERIFY_TOKEN = _config[\"WhatsApp:MetaToken\"]; // ‚úÖ pulled from config\n\n            if (mode == \"subscribe\" && token == \"xbytechat-secret-token\")\n            {\n                _logger.LogInformation(\"‚úÖ Webhook verified.\");\n                return Ok(challenge);\n            }\n\n            _logger.LogWarning(\"‚ùå Webhook verification failed.\");\n            return Forbid();\n        }\n\n\n        // ‚úÖ STEP 2: Webhook Payload (POST)\n        [HttpPost(\"webhook\")]\n        public async Task<IActionResult> ReceiveStatus([FromBody] WebhookStatusDto dto)\n        {\n            if (dto == null || dto.statuses == null || dto.statuses.Count == 0)\n            {\n                _logger.LogWarning(\"‚ö†Ô∏è Invalid webhook payload received.\");\n                return BadRequest(\"Invalid payload\");\n            }\n\n            await _service.LogWebhookStatusAsync(dto);\n            _logger.LogInformation(\"‚úÖ Webhook status processed successfully.\");\n\n            return Ok(new { success = true });\n        }\n\n        // ‚úÖ STEP 3: Frontend UI (GET Logs)\n        [HttpGet]\n        public async Task<IActionResult> GetStatusLogs([FromQuery] Guid businessId)\n        {\n            var logs = await _context.MessageStatusLogs// MessageStatusLogs\n                .Where(x => x.BusinessId == businessId)\n                .OrderByDescending(x => x.CreatedAt)\n                .Take(100)\n                .Select(x => new\n                {\n                    x.MessageId,\n                    x.RecipientNumber,\n                    x.Status,\n                    x.SentAt,\n                    x.DeliveredAt,\n                    x.ReadAt,\n                    x.ErrorMessage,\n                    x.TemplateCategory,\n                    x.MessageType\n                })\n                .ToListAsync();\n\n            return Ok(new { success = true, data = logs });\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessageManagement/DTOs/MessageLogDto.cs",
      "sha256": "c0f207826b70160db8814aaf2e5fcf92174c9b5b7d0904bf27f60163fb2ca516",
      "language": "csharp",
      "size": 643,
      "content": "using System;\n\nnamespace xbytechat.api.Features.MessageManagement.DTOs\n{\n    public class MessageLogDto\n    {\n        public Guid Id { get; set; }\n        public Guid? ContactId { get; set; }\n        public string RecipientNumber { get; set; }\n        public string MessageContent { get; set; }\n        public bool IsIncoming { get; set; }\n        public DateTime CreatedAt { get; set; }\n        public string? RenderedBody { get; set; }\n        public Guid? CampaignId { get; set; }\n        public string? CampaignName { get; set; }\n        public Guid? CTAFlowStepId { get; set; }\n        public Guid? CTAFlowConfigId { get; set; }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/MessageManagement/DTOs/WebhookStatusDto.cs",
      "sha256": "aeb1bd281f5cc025fcc6c5a2a924daf3078c9e774d3fad3860626f871caad053",
      "language": "csharp",
      "size": 1324,
      "content": "namespace xbytechat.api.Features.MessageManagement.DTOs\n{\n    public class WebhookStatusDto\n    {\n        public List<StatusObject> statuses { get; set; }\n    }\n\n    public class StatusObject\n    {\n        public string id { get; set; }                     // Message ID (WAMID)\n        public string status { get; set; }                 // sent, delivered, read, failed\n        public long timestamp { get; set; }                // UNIX timestamp\n        public string recipient_id { get; set; }           // Phone number\n        public ConversationInfo conversation { get; set; }\n        public PricingInfo pricing { get; set; }\n        public List<ErrorInfo>? errors { get; set; }\n    }\n\n    public class ConversationInfo\n    {\n        public string id { get; set; }\n        public Origin origin { get; set; }\n    }\n\n    public class Origin\n    {\n        public string type { get; set; }                   // marketing, utility, etc.\n    }\n\n    public class PricingInfo\n    {\n        public bool billable { get; set; }\n        public string pricing_model { get; set; }\n        public string category { get; set; }               // Template category\n    }\n\n    public class ErrorInfo\n    {\n        public int code { get; set; }\n        public string title { get; set; }\n        public string details { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessageManagement/Models/MessageStatusLog.cs",
      "sha256": "9cebe2bfe3d8ca39e43e1fc51c5435e8c2fc47c9d7c2ef51e03a8de164770c8f",
      "language": "csharp",
      "size": 1906,
      "content": "using System.ComponentModel.DataAnnotations.Schema;\nusing System.ComponentModel.DataAnnotations;\nusing xbytechat.api.AuthModule.Models;\nusing xbytechat.api.Features.CampaignModule.Models;\nusing xbytechat.api.Features.BusinessModule.Models;\n\n\nnamespace xbytechat.api.Features.MessageManagement.DTOs\n{\n    public class MessageStatusLog\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        // üîó Who is it for\n        public string RecipientNumber { get; set; }\n        public string? CustomerProfileName { get; set; }\n\n        // üì© WhatsApp Message Info\n       // [ForeignKey(nameof(Message))]\n        public string? MessageId { get; set; } // WAMID\n\n       // public MessageLog? Message { get; set; }\n        public string Status { get; set; }\n        public string MessageType { get; set; }\n\n        // üßæ Template Info\n        public string? TemplateName { get; set; }\n        public string? TemplateCategory { get; set; }\n\n        // üß† Analytics/Reporting\n        public string Channel { get; set; } = \"whatsapp\";\n        public bool IsSessionOpen { get; set; }\n        public long? MetaTimestamp { get; set; }\n\n        // üïí Timestamps\n        public DateTime? SentAt { get; set; }\n        public DateTime? DeliveredAt { get; set; }\n        public DateTime? ReadAt { get; set; }\n\n        // ‚ùå Error Tracking\n        public string? ErrorMessage { get; set; }\n        public int? ErrorCode { get; set; }\n\n        // üîç Raw Log (for audit/debug)\n        public string? RawPayload { get; set; }\n\n        // üîó Foreign Keys\n        public Guid? CampaignId { get; set; }\n        public Campaign? Campaign { get; set; }\n\n        public Guid? BusinessId { get; set; }\n        public Business? Business { get; set; }\n\n        public Guid? UserId { get; set; }\n        public User? User { get; set; }\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n  \n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessageManagement/Services/IMessageStatusService.cs",
      "sha256": "cca96e16b96ab978d9e4c344d9a12a8377da0c701b18ea3e5e1bb981d1d6578a",
      "language": "csharp",
      "size": 262,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.MessageManagement.DTOs;\n\nnamespace xbytechat.api.Features.MessageManagement.Services\n{\n    public interface IMessageStatusService\n    {\n        Task LogWebhookStatusAsync(WebhookStatusDto dto);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessageManagement/Services/MessageStatusService.cs",
      "sha256": "f68c41d4a80e28d1b1de9da188c8b43c756b495494588de6fd11c8275d59a544",
      "language": "csharp",
      "size": 2755,
      "content": "using System;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.MessageManagement.DTOs;\nusing xbytechat.api.Features.MessageManagement.Services;\nusing xbytechat.api.Features.CampaignModule.Models;\nusing xbytechat.api.Models.BusinessModel;\nusing xbytechat.api.AuthModule.Models;\nusing Microsoft.EntityFrameworkCore;\n\nnamespace xbytechat.api.Features.MessageManagement.Services\n{\n    public class MessageStatusService : IMessageStatusService\n    {\n        private readonly AppDbContext _context;\n        private readonly ILogger<MessageStatusService> _logger;\n\n        public MessageStatusService(AppDbContext context, ILogger<MessageStatusService> logger)\n        {\n            _context = context;\n            _logger = logger;\n        }\n\n        public async Task LogWebhookStatusAsync(WebhookStatusDto dto)\n        {\n            foreach (var status in dto.statuses)\n            {\n                var log = new MessageStatusLog\n                {\n                    Id = Guid.NewGuid(),\n                    MessageId = status.id,\n                    Status = status.status.ToLower(),\n                    RecipientNumber = status.recipient_id,\n                    MetaTimestamp = status.timestamp,\n                    TemplateCategory = status?.pricing?.category,\n                    MessageType = status?.conversation?.origin?.type ?? \"session\",\n                    Channel = \"whatsapp\",\n                    CreatedAt = DateTime.UtcNow,\n                    RawPayload = System.Text.Json.JsonSerializer.Serialize(status)\n                };\n\n                var statusTime = DateTimeOffset.FromUnixTimeSeconds(status.timestamp).UtcDateTime;\n\n                switch (status.status.ToLower())\n                {\n                    case \"sent\": log.SentAt = statusTime; break;\n                    case \"delivered\": log.DeliveredAt = statusTime; break;\n                    case \"read\": log.ReadAt = statusTime; break;\n                }\n\n                if (status.errors != null && status.errors.Count > 0)\n                {\n                    log.ErrorMessage = status.errors[0].details;\n                    log.ErrorCode = status.errors[0].code;\n                }\n\n                await _context.MessageStatusLogs.AddAsync(log);\n            }\n\n            // ‚õëÔ∏è Wrap in try-catch and log full inner exception\n            try\n            {\n                await _context.SaveChangesAsync();\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(\"‚ùå SaveChangesAsync failed: \" + ex.Message);\n                _logger.LogError(\"‚ùå Inner exception: \" + ex.InnerException?.Message);\n                throw;\n            }\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/Abstractions/IWhatsAppProvider.cs",
      "sha256": "25a1b1105d245abb3cf620574e2cca3c0da007884f8ba8a062c2cd4724b88022",
      "language": "csharp",
      "size": 1124,
      "content": "// üìÑ File: Features/MessagesEngine/Abstractions/IWhatsAppProvider.cs\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.MessagesEngine.Abstractions\n{\n   \n    public interface IWhatsAppProvider\n    {\n        Task<WaSendResult> SendTextAsync(string to, string body);\n        Task<WaSendResult> SendTemplateAsync(string to, string templateName, string languageCode, IEnumerable<object> components);\n        Task<WaSendResult> SendInteractiveAsync(object fullPayload); // prebuilt object (e.g., image + CTA)\n    }\n}\n\n\n\n//namespace xbytechat.api.Features.MessagesEngine.Abstractions\n//{\n//    public interface IWhatsAppProvider\n//    {\n//        string Provider { get; }\n\n//        Task<WaSendResult> SendTextAsync(string to, string body, CancellationToken ct = default);\n\n//        Task<WaSendResult> SendTemplateAsync(string to, string templateName, string language, object? components, CancellationToken ct = default);\n\n//        // Optional: interactive/image+CTA\n//        Task<WaSendResult> SendInteractiveAsync(object payload, CancellationToken ct = default);\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/Abstractions/WaSendResult.cs",
      "sha256": "cbdf2f4ea14dafdbfd281c92d4701d11b385c52c89785faa04d1848b6af5bd8f",
      "language": "csharp",
      "size": 320,
      "content": "using System.Net;\n\nnamespace xbytechat.api.Features.MessagesEngine.Abstractions\n{\n    public record WaSendResult(\n        bool Success,\n        string Provider,\n        string? ProviderMessageId = null,\n        HttpStatusCode? StatusCode = null,\n        string? RawResponse = null,\n        string? Error = null\n    );\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/Abstractions/WaSendTemplate.cs",
      "sha256": "ce04cfc0e5abaca6ef42cf5593159791a9ae093be9b7399eae4442252b2362bd",
      "language": "csharp",
      "size": 378,
      "content": "using System;\n\nnamespace xbytechat.api.Features.MessagesEngine.Abstractions\n{\n    public class WaSendTemplate\n    {\n        public Guid BusinessId { get; init; }\n        public string To { get; init; } = \"\";\n        public string TemplateName { get; init; } = \"\";\n        public string Language { get; init; } = \"en_US\";\n        public object? Components { get; init; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/Abstractions/WaSendText.cs",
      "sha256": "192ded7365dc037581055e12a8e00816487953e786e107447465183e8e0f83a7",
      "language": "csharp",
      "size": 260,
      "content": "using System;\n\nnamespace xbytechat.api.Features.MessagesEngine.Abstractions\n{\n    public class WaSendText\n    {\n        public Guid BusinessId { get; init; }\n        public string To { get; init; } = \"\";\n        public string Body { get; init; } = \"\";\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/Contracts/MessageEnvelope.cs",
      "sha256": "7d9a3c2180154a34b5c48dbcc92d2b9ce3affbcadaacba097bba0eae1af2925e",
      "language": "csharp",
      "size": 648,
      "content": "using System.Collections.Generic;\n\nnamespace xbytechat.api.Features.MessagesEngine.Contracts\n{\n    /// <summary>\n    /// Provider-agnostic message envelope. Maps to Meta/Pinbot under the hood.\n    /// </summary>\n    public sealed record MessageEnvelope(\n        string To,\n        string Kind,                       // \"text\" | \"template\" | \"interactive\"\n        string? TemplateName = null,\n        string LanguageCode = \"en_US\",\n        List<object>? Components = null,    // template components\n        object? Interactive = null,         // interactive payload (if any)\n        string? TextBody = null,\n        string? ImageUrl = null\n    );\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/Controllers/MessageEngineController.cs",
      "sha256": "dccc3a3007e5829ebb5161cc80da73208b3eec3a715695a0e4c467584bb87735",
      "language": "csharp",
      "size": 8267,
      "content": "\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing System.Security.Claims;\nusing System.Text.Json;\nusing xbytechat.api.DTOs.Messages;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.Features.ReportingModule.Services;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.MessagesEngine.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize]\n    public class MessageEngineController : ControllerBase\n    {\n        private readonly IMessageEngineService _messageEngineService;\n        private readonly IMessageAnalyticsService _messageAnalyticsServiceervice;\n\n\n        public MessageEngineController(IMessageEngineService messageService, IMessageAnalyticsService messageAnalyticsService)\n        {\n            _messageEngineService = messageService;\n            _messageAnalyticsServiceervice = messageAnalyticsService;\n        }\n        //[HttpPost(\"send-contentfree-text\")]\n        //public async Task<IActionResult> SendTextMessage([FromBody] TextMessageSendDto dto)\n        //{\n        //    if (!ModelState.IsValid)\n        //        return BadRequest(ResponseResult.ErrorInfo(\"‚ùå Invalid text message payload.\"));\n\n        //    try\n        //    {\n        //        var result = await _messageEngineService.SendTextDirectAsync(dto); // üëà New direct method\n\n        //        return result.Success\n        //            ? Ok(result)\n        //            : BadRequest(ResponseResult.ErrorInfo(result.Message, result.RawResponse));\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        Console.WriteLine($\"‚ùå Exception while sending text message: {ex.Message}\");\n        //        return StatusCode(500, ResponseResult.ErrorInfo(\"üö® Server error while sending text message.\", ex.ToString()));\n        //    }\n        //}\n        [HttpPost(\"send-contentfree-text\")]\n        public async Task<IActionResult> SendTextMessage([FromBody] TextMessageSendDto dto)\n        {\n            // 0) Null/body guard\n            if (dto is null)\n                return BadRequest(ResponseResult.ErrorInfo(\n                    \"‚ùå Invalid request body.\",\n                    \"Request JSON was null or malformed.\"));\n\n            // 1) Minimal required-field validation (provider is optional here)\n            var missing = new List<string>();\n            if (string.IsNullOrWhiteSpace(dto.RecipientNumber)) missing.Add(\"recipientNumber\");\n            if (string.IsNullOrWhiteSpace(dto.TextContent)) missing.Add(\"textContent\");\n\n            if (missing.Count > 0)\n            {\n                return BadRequest(ResponseResult.ErrorInfo(\n                    \"‚ùå Invalid text message payload.\",\n                    $\"Missing/empty: {string.Join(\", \", missing)}\"\n                ));\n            }\n\n            // 2) Diagnostics while debugging\n            Console.WriteLine($\"[SendTextMessage] Incoming: {JsonSerializer.Serialize(dto)}\");\n            Console.WriteLine($\"[SendTextMessage] provider(raw)='{dto.Provider}' phoneNumberId(raw)='{dto.PhoneNumberId}'\");\n\n            try\n            {\n                // 3) Delegate to service (service will resolve provider if missing)\n                var result = await _messageEngineService.SendTextDirectAsync(dto);\n\n                // 4) Return exactly what service produced\n                return result.Success ? Ok(result) : BadRequest(result);\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"‚ùå Exception while sending text message: {ex}\");\n                return StatusCode(500, ResponseResult.ErrorInfo(\n                    \"üö® Server error while sending text message.\", ex.ToString()));\n            }\n        }\n        [HttpPost(\"send-template-simple\")]\n        public async Task<IActionResult> SendTemplateMessageSimple([FromBody] SimpleTemplateMessageDto dto)\n        {\n            if (!ModelState.IsValid)\n                return BadRequest(ResponseResult.ErrorInfo(\"‚ùå Invalid template message request.\"));\n\n            try\n            {\n                var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n                if (!Guid.TryParse(businessIdClaim, out Guid businessId))\n                    return Unauthorized(ResponseResult.ErrorInfo(\"‚ùå Business ID not found in token.\"));\n\n                var result = await _messageEngineService.SendTemplateMessageSimpleAsync(businessId, dto);\n\n                return result.Success\n                    ? Ok(result)\n                    : BadRequest(ResponseResult.ErrorInfo(result.Message ?? \"‚ùå Failed to send template.\", result.RawResponse));\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"‚ùå Exception while sending template: {ex.Message}\");\n                return StatusCode(500, ResponseResult.ErrorInfo(\"üö® Server error while sending template.\", ex.ToString()));\n            }\n        }\n\n\n        [HttpPost(\"send-image-campaign/{campaignId}\")]\n        public async Task<IActionResult> SendImageCampaign(Guid campaignId)\n        {\n            try\n            {\n                var businessId = UserClaimHelper.GetBusinessId(User); // ‚úÖ from\n                                                                      // claims\n                var userName = UserClaimHelper.GetUserName(User);     // for logging (if needed)\n\n                var result = await _messageEngineService.SendImageCampaignAsync(campaignId, businessId, userName);\n\n                return result.Success\n                    ? Ok(result)\n                    : BadRequest(result);\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(\"‚ùå Error while sending image campaign: \" + ex.Message);\n                return StatusCode(500, ResponseResult.ErrorInfo(\"Server error while sending campaign.\", ex.ToString()));\n            }\n        }\n        public static class UserClaimHelper\n        {\n            public static Guid GetBusinessId(ClaimsPrincipal user)\n            {\n                var claim = user.Claims.FirstOrDefault(c => c.Type == \"businessId\");\n                return claim != null ? Guid.Parse(claim.Value) : Guid.Empty;\n            }\n\n            public static string GetUserName(ClaimsPrincipal user)\n            {\n                return user?.Identity?.Name ?? \"Unknown\";\n            }\n        }\n\n        [HttpPost(\"send-image-template\")]\n        public async Task<IActionResult> SendImageTemplateMessage([FromBody] ImageTemplateMessageDto dto)\n        {\n            Guid businessId;\n            try\n            {\n                businessId = User.GetBusinessId(); // Uses your extension method!\n            }\n            catch (UnauthorizedAccessException ex)\n            {\n                return Unauthorized(new { message = ex.Message });\n            }\n\n            var result = await _messageEngineService.SendImageTemplateMessageAsync(dto, businessId);\n\n            if (result.Success)\n                return Ok(new { message = result.Message, raw = result.RawResponse });\n\n            return BadRequest(new { message = result.Message, raw = result.RawResponse });\n        }\n\n\n        //[HttpPost(\"send-video-template\")]\n        //public async Task<IActionResult> SendVideoTemplateMessage([FromBody] VideoTemplateMessageDto dto)\n        //{\n        //    Guid businessId;\n        //    try { businessId = User.GetBusinessId(); }\n        //    catch (UnauthorizedAccessException ex) { return Unauthorized(new { message = ex.Message }); }\n\n        //    var result = await _messageEngineService.SendVideoTemplateMessageAsync(dto, businessId);\n        //    return result.Successin\n        //        ? Ok(new { message = result.Message, raw = result.RawResponse })\n        //        : BadRequest(new { message = result.Message, raw = result.RawResponse });\n        //}\n\n        [HttpGet(\"recent\")]\n        public async Task<IActionResult> GetRecentLogs([FromQuery] int limit = 20)\n        {\n            var businessId = User.GetBusinessId();\n            var logs = await _messageAnalyticsServiceervice.GetRecentLogsAsync(businessId, limit);\n            return Ok(new { success = true, data = logs });\n        }\n\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/DTOs/AutoSendTemplateMessageDto.cs",
      "sha256": "99519bdaed8df38337d3485148cfc53b4972c2616ebb386417321455ad582576",
      "language": "csharp",
      "size": 422,
      "content": "namespace xbytechat.api.Features.MessagesEngine.DTOs\n{\n    public class AutoSendTemplateMessageDto\n    {\n        public Guid BusinessId { get; set; }\n        public Guid ContactId { get; set; }\n        public string PhoneNumber { get; set; }\n        public Guid TemplateId { get; set; }\n        public string TemplateName { get; set; }\n        public Dictionary<string, string> Placeholders { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/DTOs/CtaButtonDto.cs",
      "sha256": "60ecf5aa33d787f635ef05f11c48b8f9f6a11d48b2d7322f7f2ef575b91f9657",
      "language": "csharp",
      "size": 307,
      "content": "namespace xbytechat.api.Features.MessagesEngine.DTOs\n{\n    public class CtaButtonDto\n    {\n        public string Title { get; set; } = string.Empty; // e.g., \"Buy Now\", \"View Details\"\n        public string Type { get; set; } = string.Empty;\n        public string Value { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/DTOs/DocumentTemplateDto.cs",
      "sha256": "bbda0a8069d8f5d2cd55009d1276b85f5ba6bd077a0c8c41cb055431dbed2507",
      "language": "csharp",
      "size": 161,
      "content": "namespace xbytechat.api.Features.MessagesEngine.DTOs\n{\n    public class DocumentTemplateDto\n    {\n        public string? HeaderDocumentUrl { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/DTOs/DocumentTemplateMessageDto.cs",
      "sha256": "d1661773f6bc14badc4979362169c3170319abbebf19ca7b004eecab4a377a1f",
      "language": "csharp",
      "size": 1813,
      "content": "using System;\nusing System.Collections.Generic;\nusing xbytechat.api.Features.CampaignModule.DTOs; // for CampaignButtonDto in this folder\n\nnamespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    /// <summary>\n    /// Payload for sending a template with a DOCUMENT header.\n    /// Aliases provided so code using Parameters/Buttons OR TemplateParameters/ButtonParameters compiles.\n    /// </summary>\n    public sealed class DocumentTemplateMessageDto\n    {\n        public Guid BusinessId { get; set; }\n\n        // Routing / provider\n        public string? Provider { get; set; }            // \"META\" | \"PINNACLE\"\n        public string? PhoneNumberId { get; set; }       // Meta WABA phone id (sender)\n\n        // Recipient & template identity\n        public string RecipientNumber { get; set; } = \"\"; // E.164\n        public string TemplateName { get; set; } = \"\";\n        public string LanguageCode { get; set; } = \"en_US\";\n\n        // Header\n        public string? HeaderDocumentUrl { get; set; }\n\n        // Body params (ordered {{1}}..)\n        public List<string> Parameters { get; set; } = new();\n        // Alias for older call sites\n        public List<string> TemplateParameters\n        {\n            get => Parameters;\n            set => Parameters = value ?? new List<string>();\n        }\n\n        // Buttons (we use your actual CampaignButtonDto: ButtonText, ButtonType, TargetUrl)\n        public List<CampaignButtonDto> Buttons { get; set; } = new();\n        // Alias for older call sites\n        public List<CampaignButtonDto> ButtonParameters\n        {\n            get => Buttons;\n            set => Buttons = value ?? new List<CampaignButtonDto>();\n        }\n\n        // Optional extras\n        public Guid? CTAFlowConfigId { get; set; }\n        public string? TemplateBody { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/DTOs/ImageTemplateMessageDto.cs",
      "sha256": "471132fb66303d77584686def7af22e2365d5b68d32a950f9582f245c966452c",
      "language": "csharp",
      "size": 861,
      "content": "using System.ComponentModel.DataAnnotations;\nusing xbytechat.api.Features.CampaignModule.DTOs;\n\npublic class ImageTemplateMessageDto\n{\n    public Guid BusinessId { get; set; }\n    public string RecipientNumber { get; set; }\n    public string TemplateName { get; set; }\n    public string LanguageCode { get; set; } = \"en_US\";\n    public string HeaderImageUrl { get; set; }\n    public List<string> TemplateParameters { get; set; } = new();\n    public List<CampaignButtonDto> ButtonParameters { get; set; } = new();\n\n    // ‚úÖ Add these two for flow tracking\n    public Guid? CTAFlowConfigId { get; set; }\n    public Guid? CTAFlowStepId { get; set; }\n    public string? TemplateBody { get; set; }\n\n\n   // [RegularExpression(\"^(PINNACLE|META_CLOUD)$\")]\n    public string Provider { get; set; } = string.Empty;\n    public string? PhoneNumberId { get; set; }\n   \n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/DTOs/LocationMessageSendDto.cs",
      "sha256": "6271589eca1e4c87f9ed1fd81a944fc8d525f1be24135bddc32a8d49936dae3f",
      "language": "csharp",
      "size": 709,
      "content": "using System;\n\nnamespace xbytechat.api.Features.MessagesEngine.DTOs\n{\n    public sealed class LocationMessageSendDto\n    {\n        public Guid BusinessId { get; set; }\n        public string RecipientNumber { get; set; } = string.Empty;\n\n        public Guid ContactId { get; set; }\n        public string? PhoneNumberId { get; set; }\n        public string? Provider { get; set; } // defaults to business sender; keep for parity with other DTOs\n        public string? Source { get; set; }   // \"agent\" | \"automation\" | etc.\n\n        public double Latitude { get; set; }\n        public double Longitude { get; set; }\n        public string? Name { get; set; }\n        public string? Address { get; set; }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/DTOs/MediaMessageSendDto.cs",
      "sha256": "fe0520f49f7183562324c8952f8e8392fe027ef986c6054276850c7c3665d152",
      "language": "csharp",
      "size": 1034,
      "content": "using System;\n\nnamespace xbytechat.api.Features.MessagesEngine.DTOs\n{\n    public sealed class MediaMessageSendDto\n    {\n        public Guid BusinessId { get; set; }\n\n        public string RecipientNumber { get; set; } = string.Empty;\n\n        /// <summary>\n        /// WhatsApp Cloud API media_id (returned by /{phone_number_id}/media).\n        /// </summary>\n        public string MediaId { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Optional caption.\n        /// </summary>\n        public string? Caption { get; set; }\n\n        /// <summary>\n        /// Optional filename (recommended for documents).\n        /// </summary>\n        public string? FileName { get; set; }\n\n        /// <summary>\n        /// Optional mime type for logging/display.\n        /// </summary>\n        public string? MimeType { get; set; }\n\n        public Guid ContactId { get; set; }\n\n        public string? PhoneNumberId { get; set; }\n\n        public string? Provider { get; set; }\n\n        public string? Source { get; set; }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/DTOs/MessageTypeEnum.cs",
      "sha256": "d3120f117dc16b8ab9901ba3726defab664b2a9b4a5414eff586e7e27f55062a",
      "language": "csharp",
      "size": 286,
      "content": "using System.Text.Json.Serialization;\n\nnamespace xbytechat.api.Features.MessagesEngine.DTOs\n{\n    [JsonConverter(typeof(JsonStringEnumConverter))] // Enables string parsing in JSON\n    public enum MessageTypeEnum\n    {\n        Text,\n        Image,\n        Template,\n        Cta\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/DTOs/SendMessageDto.cs",
      "sha256": "5121018135042d9cdd9a4a404307559a8024ffa4bc1b851f346690fedb544886",
      "language": "csharp",
      "size": 2059,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.ComponentModel.DataAnnotations;\nusing xbytechat.api.Features.MessagesEngine.DTOs.Validation;\n\nnamespace xbytechat.api.Features.MessagesEngine.DTOs\n{\n    [ValidateMessageDto] // ‚úÖ Custom validator will enforce conditional field rules\n    public class SendMessageDto\n    {\n        [Required]\n        public Guid BusinessId { get; set; }\n\n        [Required]\n        [Phone]\n        public string RecipientNumber { get; set; } = string.Empty;\n\n        [Required]\n        public MessageTypeEnum MessageType { get; set; }\n\n        // üìù Text Message\n        public string? TextContent { get; set; }\n\n        // üñºÔ∏è Image Message\n        public string? MediaUrl { get; set; }\n\n        // üìã Template Message\n        public string? TemplateName { get; set; }\n        public Dictionary<string, string>? TemplateParameters { get; set; }\n\n        // üõí CTA Message\n        public List<CtaButtonDto>? CtaButtons { get; set; }\n\n        // ‚úÖ Required: this was missing [Optional but needed for CTA/Template message sending]\n        public List<string>? ButtonParams { get; set; }\n\n        // üìä Optional Metadata\n        public Guid? CampaignId { get; set; }\n        public Guid? CTAFlowConfigId { get; set; }\n        public Guid? CTAFlowStepId { get; set; }\n\n        public string? SourceModule { get; set; }\n        public string? CustomerId { get; set; }\n        public string? CustomerName { get; set; }\n        public string? CustomerPhone { get; set; }\n        public string? BotId { get; set; }\n        public string? RefMessageId { get; set; }\n        public string? CTATriggeredFrom { get; set; }\n        public DateTime? ScheduledAt { get; set; }\n\n        // ‚úÖ Add these two for flow tracking\n        public string? TemplateBody { get; set; }  // üî• Used to render actual message body from placeholders\n\n      //  [RegularExpression(\"^(PINNACLE|META_CLOUD)$\")]\n        public string Provider { get; set; } = string.Empty;\n\n        public string? PhoneNumberId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/DTOs/SendTemplateMessageSimpleDto.cs",
      "sha256": "00dc74bb6a1b396bab6fcd63f93454cfd59671260c4da8b0afd8754e83e10ce8",
      "language": "csharp",
      "size": 478,
      "content": "namespace xbytechat.api.Features.MessagesEngine.DTOs\n{\n    public class SendTemplateMessageSimpleDto\n    {\n        public Guid BusinessId { get; set; }\n        public string RecipientNumber { get; set; }\n        public string TemplateName { get; set; }\n        public List<string> TemplateParameters { get; set; } = new();\n        // ‚úÖ Add these two for flow tracking\n        public Guid? CTAFlowConfigId { get; set; }\n        public Guid? CTAFlowStepId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/DTOs/SimpleTemplateMessageDto.cs",
      "sha256": "37ca1b507cce96ca8c1244374ede5314948283794dabc3d4af5bfc610916b868",
      "language": "csharp",
      "size": 1503,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.ComponentModel.DataAnnotations;\nusing xbytechat.api.Features.MessagesEngine.Enums;\n\nnamespace xbytechat.api.Features.MessagesEngine.DTOs\n{\n    public class SimpleTemplateMessageDto\n    {\n        //public Guid BusinessId { get; set; }\n\n        public string RecipientNumber { get; set; }\n\n        public string TemplateName { get; set; }\n\n        public List<string> TemplateParameters { get; set; } = new();\n        public bool HasStaticButtons { get; set; } = false;\n\n        // Optional: media header support (image/video/document)\n        // HeaderKind is canonical lowercase: none | image | video | document | text\n        public string? HeaderKind { get; set; }\n        public string? HeaderMediaUrl { get; set; }\n\n        // Optional: dynamic URL button params (index 0..2). Send only non-empty values.\n        public List<string> UrlButtonParams { get; set; } = new();\n\n       // [RegularExpression(\"^(PINNACLE|META_CLOUD)$\")]\n        public string Provider { get; set; } = string.Empty;\n        public string? PhoneNumberId { get; set; }\n        // ‚úÖ Add these two for flow tracking\n        public Guid? CTAFlowConfigId { get; set; }\n        public Guid? CTAFlowStepId { get; set; }\n        public string? TemplateBody { get; set; }  // üî• Used to render actual message body from placeholders\n\n        public string? LanguageCode { get; set; }\n        public DeliveryMode DeliveryMode { get; set; } = DeliveryMode.Queue;\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/DTOs/TemplateForUIResponseDto.cs",
      "sha256": "8598c768ad7f753c61a4a2c296a18db6285c872705ca0b16a479b5d5bdedde55",
      "language": "csharp",
      "size": 626,
      "content": "using xbytechat.api.WhatsAppSettings.DTOs;\n\npublic class TemplateForUIResponseDto\n{\n    public string Name { get; set; }\n    public string Language { get; set; }\n    public string Body { get; set; }\n\n    // ‚úÖ Correct naming for frontend\n    public int ParametersCount { get; set; }\n\n    public List<ButtonMetadataDto> ButtonParams { get; set; }\n    public bool HasImageHeader { get; set; } // üÜï Used to detect image templates\n\n    public string? HeaderKind { get; set; }          // \"text\" | \"image\" | \"video\" | \"document\" | \"none\"\n    public bool RequiresHeaderMediaUrl { get; set; } // true for image/video/document\n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/DTOs/TextMessageSendDto.cs",
      "sha256": "4246f4f4e9b465b9590f78f3b822e7eb06f7def4e1a90e27165a68077bc414e5",
      "language": "csharp",
      "size": 991,
      "content": "using System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.MessagesEngine.DTOs\n{\n    public class TextMessageSendDto\n    {\n        public Guid BusinessId { get; set; }\n\n        public string RecipientNumber { get; set; }\n\n        public string TextContent { get; set; }\n\n        // Optional: allows UI to provide a preferred contact name when saving a new contact.\n        public string? ContactName { get; set; }\n\n        public Guid ContactId { get; set; }\n\n        public string? PhoneNumberId { get; set; }\n        // ‚úÖ NEW: Optional source indicator (e.g., \"campaign\", \"auto-reply\", etc.)\n\n        //[RegularExpression(\"^(PINNACLE|META_CLOUD)$\")]\n        //[Required]\n        public string Provider { get; set; } = string.Empty;\n        public string? Source { get; set; }\n\n        // ‚úÖ NEW: Optional message ID for campaign tracing\n        public string? MessageId { get; set; }\n\n        public bool IsSaveContact { get; set; } = false; // default true\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/DTOs/VideoTemplateMessageDto.cs",
      "sha256": "57c4f2a9a6c884efb7c3ec74c8674e04482aaaa04428ab6232a7ea3db1adc043",
      "language": "csharp",
      "size": 941,
      "content": "using System;\nusing System.Collections.Generic;\nusing xbytechat.api.Features.CampaignModule.DTOs;\n\npublic class VideoTemplateMessageDto\n{\n    public Guid BusinessId { get; set; }\n    public string RecipientNumber { get; set; } = string.Empty;\n\n    public string TemplateName { get; set; } = string.Empty;\n    public string LanguageCode { get; set; } = \"en_US\";\n\n    // mirrors HeaderImageUrl\n    public string? HeaderVideoUrl { get; set; }\n\n    public List<string> TemplateParameters { get; set; } = new();\n    public List<CampaignButtonDto> ButtonParameters { get; set; } = new();\n\n    // for flow tracking parity\n    public Guid? CTAFlowConfigId { get; set; }\n    public Guid? CTAFlowStepId { get; set; }\n    public string? TemplateBody { get; set; }\n\n    // same explicit provider knobs you already use\n    public string Provider { get; set; } = string.Empty; // \"PINNACLE\" | \"META_CLOUD\"\n    public string? PhoneNumberId { get; set; }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/Enums/DeliveryMode.cs",
      "sha256": "34b987a3b5ca838182dc0aeec507b3ed1a0641adc6c0aac7167feb2336f9e80d",
      "language": "csharp",
      "size": 501,
      "content": "using System.Collections;\n\nnamespace xbytechat.api.Features.MessagesEngine.Enums\n{\n    public enum DeliveryMode\n    {\n        /// <summary>\n        /// Default behaviour: enqueue into Outbox/worker.\n        /// Use this for campaigns, bulk sends, and scheduled jobs.\n        /// </summary>\n        Queue = 0,\n\n        /// <summary>\n        /// High-priority conversational sends:\n        /// call the WhatsApp provider directly inside the request.\n        /// </summary>\n        Immediate = 1\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/Factory/IWhatsAppProviderFactory.cs",
      "sha256": "342d4ace84b80c735c364b8ff654502fff27f1bfeb70eb78d5469879ec57ce1f",
      "language": "csharp",
      "size": 578,
      "content": "using System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.MessagesEngine.Abstractions;\n\nnamespace xbytechat.api.Features.MessagesEngine.Factory\n{\n    public interface IWhatsAppProviderFactory\n    {\n        //Task<IWhatsAppProvider> CreateAsync(Guid businessId, CancellationToken ct = default);\n        Task<IWhatsAppProvider> CreateAsync(Guid businessId);\n       //Task<IWhatsAppProvider> CreateAsync(Guid businessId, string? phoneNumberId);\n        Task<IWhatsAppProvider> CreateAsync(Guid businessId, string provider, string? phoneNumberId);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/Factory/WhatsAppProviderFactory.cs",
      "sha256": "4277e6669492d91b902efa2b8002e0f31b0523da3c9f5f3edbb7ff45d0462513",
      "language": "csharp",
      "size": 11987,
      "content": "using System;\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api;\nusing xbytechat.api.Features.BusinessModule.Models;\nusing xbytechat.api.Features.MessagesEngine.Abstractions;\nusing xbytechat.api.Features.MessagesEngine.Providers;\nusing xbytechat_api.WhatsAppSettings.Models;\nusing static System.Net.WebRequestMethods;\nusing static System.Runtime.InteropServices.JavaScript.JSType;\n\nnamespace xbytechat.api.Features.MessagesEngine.Factory\n{\n    public class WhatsAppProviderFactory : IWhatsAppProviderFactory\n    {\n        private readonly IServiceProvider _sp;\n        private readonly AppDbContext _db;\n        private readonly ILogger<WhatsAppProviderFactory> _logger;\n\n        public WhatsAppProviderFactory(IServiceProvider sp, AppDbContext db, ILogger<WhatsAppProviderFactory> logger)\n        {\n            _sp = sp;\n            _db = db;\n            _logger = logger;\n        }\n\n        //public async Task<IWhatsAppProvider> CreateAsync(Guid businessId)\n        //{\n        //    var setting = await _db.WhatsAppSettings\n        //        .FirstOrDefaultAsync(x => x.BusinessId == businessId && x.IsActive)\n        //        ?? throw new InvalidOperationException(\"WhatsApp settings not found for this business.\");\n\n        //    var providerKey = (setting.Provider ?? \"meta_cloud\").Trim().ToLowerInvariant();\n\n        //    using var scope = _sp.CreateScope();\n\n        //    var httpClientFactory = scope.ServiceProvider.GetService<IHttpClientFactory>();\n        //    var http =\n        //        httpClientFactory != null\n        //            ? httpClientFactory.CreateClient(providerKey == \"meta_cloud\" ? \"wa:meta_cloud\" : \"wa:pinnacle\")\n        //            : scope.ServiceProvider.GetRequiredService<HttpClient>();\n\n        //    return providerKey switch\n        //    {\n        //        //\"pinnacle\" =>\n        //        //            new PinnacleProvider(http, scope.ServiceProvider.GetRequiredService<ILogger<PinnacleProvider>>(), setting),\n        //        \"pinnacle\" => new PinnacleProvider(http, scope.ServiceProvider.GetRequiredService<ILogger<PinnacleProvider>>(), setting),\n        //        \"meta_cloud\" =>\n        //            new MetaCloudProvider(_db, http, scope.ServiceProvider.GetRequiredService<ILogger<MetaCloudProvider>>(), setting),\n\n        //        _ => throw new NotSupportedException($\"Unsupported WhatsApp provider: {providerKey}\")\n        //    };\n        //}\n\n\n\n        //public async Task<IWhatsAppProvider> CreateAsync(Guid businessId, string? phoneNumberId)\n        //{\n        //    var setting = await _db.WhatsAppSettings\n        //        .FirstOrDefaultAsync(x => x.BusinessId == businessId && x.IsActive)\n        //        ?? throw new InvalidOperationException(\"WhatsApp settings not found for this business.\");\n\n        //    // per-send override of the sender number (in-memory only)\n        //    if (!string.IsNullOrWhiteSpace(phoneNumberId))\n        //        setting.PhoneNumberId = phoneNumberId.Trim();\n\n        //    var providerKey = (setting.Provider ?? \"meta_cloud\").Trim().ToLowerInvariant();\n\n        //    using var scope = _sp.CreateScope();\n\n        //    var httpClientFactory = scope.ServiceProvider.GetService<IHttpClientFactory>();\n        //    var http =\n        //        httpClientFactory != null\n        //            ? httpClientFactory.CreateClient(providerKey == \"meta_cloud\" ? \"wa:meta_cloud\" : \"wa:pinnacle\")\n        //            : scope.ServiceProvider.GetRequiredService<HttpClient>();\n\n        //    return providerKey switch\n        //    {\n        //        \"pinnacle\" => new PinnacleProvider(http, scope.ServiceProvider.GetRequiredService<ILogger<PinnacleProvider>>(), setting),\n        //        \"meta_cloud\" => new MetaCloudProvider(_db, http, scope.ServiceProvider.GetRequiredService<ILogger<MetaCloudProvider>>(), setting),\n        //        _ => throw new NotSupportedException($\"Unsupported WhatsApp provider: {providerKey}\")\n        //    };\n        //}\n\n        public async Task<IWhatsAppProvider> CreateAsync(Guid businessId)\n        {\n            var setting = await _db.WhatsAppSettings\n                .FirstOrDefaultAsync(x => x.BusinessId == businessId && x.IsActive)\n                ?? throw new InvalidOperationException(\"WhatsApp settings not found for this business.\");\n\n            // Canonical provider: META_CLOUD | PINNACLE (ALL CAPS)\n            var provider = (setting.Provider ?? \"META_CLOUD\")\n                .Trim()\n                .Replace(\"-\", \"_\")\n                .Replace(\" \", \"_\")\n                .ToUpperInvariant();\n\n            using var scope = _sp.CreateScope();\n\n            var httpFactory = scope.ServiceProvider.GetService<IHttpClientFactory>();\n            var clientName = provider == \"META_CLOUD\" ? \"wa:meta_cloud\" : \"wa:pinnacle\"; // named client key\n            var http = httpFactory != null\n                ? httpFactory.CreateClient(clientName)\n                : scope.ServiceProvider.GetRequiredService<HttpClient>();\n\n            switch (provider)\n            {\n                case \"PINNACLE\":\n                    {\n                        // Prefer WABA id; else default active number for PINNACLE\n                        string? pathIdOverride = !string.IsNullOrWhiteSpace(setting.WabaId)\n                            ? setting.WabaId!.Trim()\n                            : await _db.WhatsAppPhoneNumbers\n                                .AsNoTracking()\n                                .Where(p => p.BusinessId == businessId\n                                            && p.IsActive\n                                            && p.Provider.ToUpper() == \"PINNACLE\")\n                                .OrderByDescending(p => p.IsDefault)\n                                .ThenByDescending(p => p.UpdatedAt ?? p.CreatedAt)\n                                .Select(p => p.PhoneNumberId)\n                                .FirstOrDefaultAsync();\n\n                        return new PinnacleProvider(\n                            _db,\n                            http,\n                            scope.ServiceProvider.GetRequiredService<ILogger<PinnacleProvider>>(),\n                            setting,\n                            pathIdOverride);\n                    }\n\n                case \"META_CLOUD\":\n                    return new MetaCloudProvider(\n                        _db,\n                        http,\n                        scope.ServiceProvider.GetRequiredService<ILogger<MetaCloudProvider>>(),\n                        setting);\n\n                default:\n                    throw new NotSupportedException($\"Unsupported WhatsApp provider: {provider}\");\n            }\n        }\n\n        public async Task<IWhatsAppProvider> CreateAsync(Guid businessId, string provider, string? phoneNumberId)\n        {\n            if (string.IsNullOrWhiteSpace(provider))\n                throw new ArgumentException(\"Provider is required.\", nameof(provider));\n\n            // Canonical provider: PINNACLE | META_CLOUD (ALL CAPS)\n            provider = provider.Trim().Replace(\"-\", \"_\").Replace(\" \", \"_\").ToUpperInvariant();\n            if (provider is not (\"PINNACLE\" or \"META_CLOUD\"))\n                throw new NotSupportedException($\"Unsupported provider: {provider}\");\n\n            // If a sender was chosen, ensure it belongs to THIS business+provider\n            if (!string.IsNullOrWhiteSpace(phoneNumberId))\n            {\n                var exists = await _db.WhatsAppPhoneNumbers\n                    .AsNoTracking()\n                    .AnyAsync(n => n.BusinessId == businessId\n                                   && n.Provider.ToUpper() == provider\n                                   && n.PhoneNumberId == phoneNumberId);\n                if (!exists)\n                    throw new InvalidOperationException(\n                        \"Selected PhoneNumberId does not belong to this provider/business.\");\n            }\n\n            // Load the settings row for the exact (BusinessId, Provider)\n            var setting = await _db.WhatsAppSettings\n                .FirstOrDefaultAsync(s => s.BusinessId == businessId\n                                          && s.IsActive\n                                          && s.Provider.ToUpper() == provider)\n                ?? throw new InvalidOperationException(\n                    $\"WhatsApp settings not found for provider {provider}.\");\n\n            if (string.IsNullOrWhiteSpace(setting.ApiUrl))\n                throw new InvalidOperationException(\"API URL is empty. Save provider settings first.\");\n            if (string.IsNullOrWhiteSpace(setting.ApiKey))\n                throw new InvalidOperationException(\"API Key/Token is empty. Save provider settings first.\");\n\n            using var scope = _sp.CreateScope();\n            var http = scope.ServiceProvider\n                .GetRequiredService<IHttpClientFactory>()\n                .CreateClient(provider == \"META_CLOUD\" ? \"wa:meta_cloud\" : \"wa:pinnacle\");\n\n            // NOTE: providers accept optional overrides; do NOT write into settings\n            return provider switch\n            {\n                \"PINNACLE\" => new PinnacleProvider(\n                    _db,\n                    http,\n                    scope.ServiceProvider.GetRequiredService<ILogger<PinnacleProvider>>(),\n                    setting,\n                    pathIdOverride: string.IsNullOrWhiteSpace(phoneNumberId) ? setting.WabaId : phoneNumberId),\n\n                \"META_CLOUD\" => new MetaCloudProvider(\n                    _db,\n                    http,\n                    scope.ServiceProvider.GetRequiredService<ILogger<MetaCloudProvider>>(),\n                    setting,\n                    phoneNumberIdOverride: phoneNumberId),\n\n                _ => throw new NotSupportedException($\"Unsupported provider: {provider}\")\n            };\n        }\n\n    }\n}\n\n\n//// üìÑ File: Features/MessagesEngine/Factory/WhatsAppProviderFactory.cs\n//using System;\n//using System.Threading.Tasks;\n//using Microsoft.EntityFrameworkCore;\n//using Microsoft.Extensions.DependencyInjection;\n//using Microsoft.Extensions.Logging;\n//using xbytechat.api;\n//using xbytechat.api.Features.MessagesEngine.Abstractions;\n//using xbytechat.api.Features.MessagesEngine.Providers;\n\n//namespace xbytechat.api.Features.MessagesEngine.Factory\n//{\n\n//    public class WhatsAppProviderFactory : IWhatsAppProviderFactory\n//    {\n//        private readonly IServiceProvider _sp;\n//        private readonly AppDbContext _db;\n//        private readonly ILogger<WhatsAppProviderFactory> _logger;\n\n//        public WhatsAppProviderFactory(IServiceProvider sp, AppDbContext db, ILogger<WhatsAppProviderFactory> logger)\n//        {\n//            _sp = sp;\n//            _db = db;\n//            _logger = logger;\n//        }\n\n//        public async Task<IWhatsAppProvider> CreateAsync(Guid businessId)\n//        {\n//            var setting = await _db.WhatsAppSettings.FirstOrDefaultAsync(x => x.BusinessId == businessId && x.IsActive)\n//                          ?? throw new InvalidOperationException(\"WhatsApp settings not found for this business.\");\n\n//            var providerKey = (setting.Provider ?? \"meta_cloud\").Trim().ToLowerInvariant();\n\n//            // Create a new scope to inject the per-tenant setting into provider constructor\n//            var scope = _sp.CreateScope();\n//            var http = scope.ServiceProvider.GetRequiredService<HttpClient>();\n\n//            return providerKey switch\n//            {\n//                \"pinnacle\" => new PinbotProvider(http, scope.ServiceProvider.GetRequiredService<ILogger<PinbotProvider>>(), setting),\n//                \"meta_cloud\" => new MetaCloudProvider(_db, http, scope.ServiceProvider.GetRequiredService<ILogger<MetaCloudProvider>>(), setting),\n//                _ => throw new NotSupportedException($\"Unsupported WhatsApp provider: {providerKey}\")\n//            };\n//        }\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/Outbox/OutboxMessage.cs",
      "sha256": "caa5c09bc7c28e6aaa5bb1aa93cd76f38c41f5c2754790d9c45f6af037ed1a25",
      "language": "csharp",
      "size": 1109,
      "content": "using System;\n\nnamespace xbytechat.api.Features.MessagesEngine.Outbox\n{\n    public enum OutboxStatus\n    {\n        Queued = 0,\n        Sending = 1,\n        Sent = 2,\n        Failed = 3\n    }\n\n    public class OutboxMessage\n    {\n        public Guid Id { get; set; }\n        public Guid BusinessId { get; set; }\n        public Guid? CampaignId { get; set; }\n        public Guid? ContactId { get; set; }\n\n        public string RecipientNumber { get; set; } = \"\";\n        public string ProviderKey { get; set; } = \"\"; // \"meta_cloud\" | \"pinnacle\" (optional hint)\n        public string PayloadJson { get; set; } = \"\"; // serialized MessageEnvelope\n        public string CorrelationId { get; set; } = \"\"; // for idempotency & tracing\n\n        public OutboxStatus Status { get; set; } = OutboxStatus.Queued;\n        public int AttemptCount { get; set; }\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n        public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;\n        public DateTime? NextAttemptAt { get; set; } = DateTime.UtcNow;\n        public string? LastError { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/PayloadBuilders/CtaMessagePayloadBuilder.cs",
      "sha256": "f23794fdb8775eff63c5d249f23e74b7ff5e4497daa7b255ce94693b3ba9a6f7",
      "language": "csharp",
      "size": 1063,
      "content": "using xbytechat.api.Features.MessagesEngine.DTOs;\n\nnamespace xbytechat.api.Features.MessagesEngine.PayloadBuilders\n{\n    public class CtaMessagePayloadBuilder : IWhatsAppPayloadBuilder\n    {\n        public object BuildPayload(SendMessageDto dto)\n        {\n            return new\n            {\n                messaging_product = \"whatsapp\",\n                to = dto.RecipientNumber,\n                type = \"interactive\",\n                interactive = new\n                {\n                    type = \"button\",\n                    body = new { text = dto.TextContent },\n                    action = new\n                    {\n                        buttons = dto.CtaButtons?.Select(b => new\n                        {\n                            type = \"reply\",\n                            reply = new\n                            {\n                                id = b.Value,\n                                title = b.Title\n                            }\n                        }).ToList()\n                    }\n                }\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/PayloadBuilders/ImageMessagePayloadBuilder.cs",
      "sha256": "1400148a9ed0b32af7ece6c87b111a1407feda0f5b651819257c5b740bb01106",
      "language": "csharp",
      "size": 554,
      "content": "using xbytechat.api.Features.MessagesEngine.DTOs;\n\nnamespace xbytechat.api.Features.MessagesEngine.PayloadBuilders\n{\n    public class ImageMessagePayloadBuilder : IWhatsAppPayloadBuilder\n    {\n        public object BuildPayload(SendMessageDto dto)\n        {\n            return new\n            {\n                messaging_product = \"whatsapp\",\n                to = dto.RecipientNumber,\n                type = \"image\",\n                image = new\n                {\n                    link = dto.MediaUrl\n                }\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/PayloadBuilders/IWhatsAppPayloadBuilder.cs",
      "sha256": "89d6b688ba597eb931cd71401717698a692f3e3b645a02d60c1d73dae24731d3",
      "language": "csharp",
      "size": 225,
      "content": "using xbytechat.api.Features.MessagesEngine.DTOs;\n\nnamespace xbytechat.api.Features.MessagesEngine.PayloadBuilders\n{\n    public interface IWhatsAppPayloadBuilder\n    {\n        object BuildPayload(SendMessageDto dto);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/PayloadBuilders/MessagePayloadBuilder.cs",
      "sha256": "ec8606e744a878efdd7f12dadcc799b2aaf290e66c9e419f639672d0003b4bd0",
      "language": "csharp",
      "size": 7842,
      "content": "// Features/MessagesEngine/PayloadBuilders/MessagePayloadBuilder.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace xbytechat.api.Features.MessagesEngine.PayloadBuilders\n{\n    public static class MessagePayloadBuilder\n    {\n        // New: a single canonical builder that understands our CSV-materialized shapes.\n        public static object BuildTemplatePayload(\n            string toPhoneE164,\n            string templateName,\n            string languageCode,\n            string headerType,                 // \"none\"|\"text\"|\"image\"|\"video\"|\"document\"\n            string? headerMediaUrl,            // for image/video/document\n            IReadOnlyList<string> bodyParams,  // {{1}}..{{N}}\n            IReadOnlyList<string>? headerTextParams, // header text {{n}} if headerType==\"text\"\n            IReadOnlyDictionary<string, string>? buttonUrlParams // keys: \"button1.url_param\"..\"button3.url_param\"\n        )\n        {\n            var components = new List<object>();\n\n            // 1) HEADER\n            switch ((headerType ?? \"none\").ToLowerInvariant())\n            {\n                case \"text\":\n                    if (headerTextParams != null && headerTextParams.Count > 0)\n                    {\n                        components.Add(new\n                        {\n                            type = \"header\",\n                            parameters = headerTextParams.Select(v => new { type = \"text\", text = v ?? string.Empty }).ToArray()\n                        });\n                    }\n                    break;\n\n                case \"image\":\n                    if (!string.IsNullOrWhiteSpace(headerMediaUrl))\n                    {\n                        components.Add(new\n                        {\n                            type = \"header\",\n                            parameters = new object[]\n                            {\n                                new { type = \"image\", image = new { link = headerMediaUrl } }\n                            }\n                        });\n                    }\n                    break;\n\n                case \"video\":\n                    if (!string.IsNullOrWhiteSpace(headerMediaUrl))\n                    {\n                        components.Add(new\n                        {\n                            type = \"header\",\n                            parameters = new object[]\n                            {\n                                new { type = \"video\", video = new { link = headerMediaUrl } }\n                            }\n                        });\n                    }\n                    break;\n\n                case \"document\":\n                    if (!string.IsNullOrWhiteSpace(headerMediaUrl))\n                    {\n                        components.Add(new\n                        {\n                            type = \"header\",\n                            parameters = new object[]\n                            {\n                                new { type = \"document\", document = new { link = headerMediaUrl } }\n                            }\n                        });\n                    }\n                    break;\n            }\n\n            // 2) BODY\n            if (bodyParams != null && bodyParams.Count > 0)\n            {\n                components.Add(new\n                {\n                    type = \"body\",\n                    parameters = bodyParams.Select(v => new { type = \"text\", text = v ?? string.Empty }).ToArray()\n                });\n            }\n\n            // 3) BUTTONS (URL dynamic only)\n            // Expect buttonUrlParams: button{1..3}.url_param -> string\n            if (buttonUrlParams != null && buttonUrlParams.Count > 0)\n            {\n                var buttons = new List<object>();\n\n                for (var pos = 1; pos <= 3; pos++)\n                {\n                    var key = $\"button{pos}.url_param\";\n                    if (buttonUrlParams.TryGetValue(key, out var val) && !string.IsNullOrWhiteSpace(val))\n                    {\n                        buttons.Add(new\n                        {\n                            type = \"button\",\n                            sub_type = \"url\",\n                            index = pos - 1, // Meta expects 0-based index\n                            parameters = new object[]\n                            {\n                                new { type = \"text\", text = val }\n                            }\n                        });\n                    }\n                }\n\n                if (buttons.Count > 0)\n                {\n                    components.AddRange(buttons);\n                }\n            }\n\n            // Meta/Pinnacle style template envelope\n            var payload = new\n            {\n                messaging_product = \"whatsapp\",\n                to = toPhoneE164,\n                type = \"template\",\n                template = new\n                {\n                    name = templateName,\n                    language = new { code = languageCode }, // << not hardcoded\n                    components = components.ToArray()\n                }\n            };\n\n            return payload;\n        }\n    }\n}\n\n\n//using xbytechat.api.Features.CampaignModule.Models;\n//using xbytechat.api.Shared.utility;\n\n//namespace xbytechat.api.Features.MessagesEngine.PayloadBuilders\n//{\n//    public static class MessagePayloadBuilder\n//    {\n//        /// <summary>\n//        /// Builds a WhatsApp template message payload for image header + buttons.\n//        /// </summary>\n//        public static object BuildImageTemplatePayload(\n//            string templateName,\n//            string languageCode,\n//            string recipientNumber,\n//            List<string> templateParams,\n//            string? imageUrl,\n//            List<CampaignButton>? buttons\n//        )\n//        {\n//            var components = new List<object>();\n\n//            // ‚úÖ Body with template params\n//            if (templateParams != null && templateParams.Any())\n//            {\n//                components.Add(new\n//                {\n//                    type = \"body\",\n//                    parameters = templateParams.Select(p => new { type = \"text\", text = p }).ToArray()\n//                });\n//            }\n\n//            // ‚úÖ Header image if present\n//            if (!string.IsNullOrWhiteSpace(imageUrl))\n//            {\n//                components.Add(new\n//                {\n//                    type = \"header\",\n//                    parameters = new[]\n//                    {\n//                    new { type = \"image\", image = new { link = imageUrl } }\n//                }\n//                });\n//            }\n\n//            // ‚úÖ CTA buttons\n//            if (buttons != null && buttons.Any())\n//            {\n//                var buttonComponents = buttons\n//                    .OrderBy(b => b.Position)\n//                    .Take(3)\n//                    .Select((btn, index) => new\n//                    {\n//                        type = \"button\",\n//                        sub_type = btn.Type, // \"url\" or \"phone_number\"\n//                        index = index.ToString(),\n//                        parameters = new[]\n//                        {\n//                        new { type = \"text\", text = btn.Value }\n//                        }\n//                    });\n\n//                components.AddRange(buttonComponents);\n//            }\n\n//            // ‚úÖ Final WhatsApp Template Payload\n//            return new\n//            {\n//                messaging_product = \"whatsapp\",\n//                to = recipientNumber,\n//                type = \"template\",\n//                template = new\n//                {\n//                    name = templateName,\n//                    language = new { code = languageCode },\n//                    components = components\n//                }\n//            };\n//        }\n//    }\n\n//}"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/PayloadBuilders/TemplateMessagePayloadBuilder.cs",
      "sha256": "1beb36776f57bf30bf67df07af07052f4d5fe2609dfe6a4015bf512dff64aee8",
      "language": "csharp",
      "size": 5342,
      "content": "using xbytechat.api.Features.MessagesEngine.DTOs;\n\nnamespace xbytechat.api.Features.MessagesEngine.PayloadBuilders\n{\n    public class TemplateMessagePayloadBuilder : IWhatsAppPayloadBuilder\n    {\n        public object BuildPayload(SendMessageDto dto)\n        {\n            if (dto == null) throw new ArgumentNullException(nameof(dto));\n            if (string.IsNullOrWhiteSpace(dto.TemplateName))\n                throw new ArgumentException(\"TemplateName is required.\");\n            if (dto.TemplateParameters == null || dto.TemplateParameters.Count == 0)\n                throw new ArgumentException(\"TemplateParameters are required for template messages.\");\n\n            // Sort by placeholder index like {{1}}, {{2}}, guarding against bad keys\n            var bodyParams = dto.TemplateParameters\n                .Select(kvp =>\n                {\n                    var key = kvp.Key?.Trim('{', '}');\n                    _ = int.TryParse(key, out var idx);\n                    return (idx, kvp.Value);\n                })\n                .OrderBy(t => t.idx)\n                .Select(t => new { type = \"text\", text = t.Value })\n                .ToArray();\n\n            var components = new List<object>\n            {\n                new { type = \"body\", parameters = bodyParams }\n            };\n\n            if (dto.ButtonParams != null && dto.ButtonParams.Any())\n            {\n                for (int i = 0; i < dto.ButtonParams.Count; i++)\n                {\n                    components.Add(new\n                    {\n                        type = \"button\",\n                        sub_type = \"url\",\n                        index = i.ToString(),\n                        parameters = new[]\n                        {\n                            new { type = \"text\", text = dto.ButtonParams[i] }\n                        }\n                    });\n                }\n            }\n\n            return new\n            {\n                messaging_product = \"whatsapp\",\n                to = dto.RecipientNumber,\n                type = \"template\",\n                template = new\n                {\n                    name = dto.TemplateName,\n                    language = new { code = \"en_US\" },\n                    components\n                }\n            };\n        }\n    }\n}\n\n\n//using xbytechat.api.Features.MessagesEngine.DTOs;\n//using xbytechat.api.Helpers;\n\n//namespace xbytechat.api.Features.MessagesEngine.PayloadBuilders\n//{\n//    public class TemplateMessagePayloadBuilder : IWhatsAppPayloadBuilder\n//    {\n//        public object BuildPayload(SendMessageDto dto)\n//        {\n//            var components = new List<object>();\n\n//            // ‚úÖ BODY PARAMETERS: Insert dynamic values into the template body\n//            // WhatsApp expects these to be in order ({{1}}, {{2}}, etc.)\n//            if (dto.TemplateParameters == null || dto.TemplateParameters.Count == 0)\n//                return ResponseResult.ErrorInfo(\"‚ùå Missing template parameters.\");\n//            if (dto.TemplateParameters != null && dto.TemplateParameters.Any())\n//                {\n//                var bodyParams = dto.TemplateParameters\n//                    .OrderBy(kvp => int.Parse(kvp.Key.Trim('{', '}'))) // üî¢ Extract and sort by index\n//                    .Select(kvp => new\n//                    {\n//                        type = \"text\",\n//                        text = kvp.Value\n//                    }).ToArray();\n\n//                components.Add(new\n//                {\n//                    type = \"body\",\n//                    parameters = bodyParams\n//                });\n//            }\n\n//            // ‚úÖ BUTTON PARAMETERS: For templates with dynamic URL buttons (index-based)\n//            if (dto.ButtonParams != null && dto.ButtonParams.Any())\n//            {\n//                for (int i = 0; i < dto.ButtonParams.Count; i++)\n//                {\n//                    components.Add(new\n//                    {\n//                        type = \"button\",\n//                        sub_type = \"url\",\n//                        index = i.ToString(), // WhatsApp requires index as a string\n//                        parameters = new[]\n//                        {\n//                            new\n//                            {\n//                                type = \"text\",\n//                                text = dto.ButtonParams[i]\n//                            }\n//                        }\n//                    });\n//                }\n//            }\n\n//            // ‚úÖ FINAL WHATSAPP TEMPLATE PAYLOAD\n//            var payload = new\n//            {\n//                messaging_product = \"whatsapp\",\n//                to = dto.RecipientNumber,\n//                type = \"template\",\n//                template = new\n//                {\n//                    name = dto.TemplateName,\n//                    language = new { code = \"en_US\" },\n//                    components = components\n//                }\n//            };\n\n//            // ü™µ Debug log for developer console (optional)\n//            Console.WriteLine(\"üì¶ Built WhatsApp Template Payload:\");\n//            Console.WriteLine(System.Text.Json.JsonSerializer.Serialize(payload, new System.Text.Json.JsonSerializerOptions\n//            {\n//                WriteIndented = true\n//            }));\n\n//            return payload;\n//        }\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/PayloadBuilders/TemplateStaticButtonPayloadBuilder.cs",
      "sha256": "68979e5fa2d53ce3fa319c20377ca2022bf9e46b7244c817fb53f84594392f72",
      "language": "csharp",
      "size": 1397,
      "content": "using xbytechat.api.Features.MessagesEngine.DTOs;\n\nnamespace xbytechat.api.Features.MessagesEngine.PayloadBuilders\n{\n    public class TemplateStaticButtonPayloadBuilder\n    {\n        public static object Build(SendTemplateMessageSimpleDto dto)\n        {\n            var components = new List<object>();\n\n            // ‚úÖ Add Body Params\n            if (dto.TemplateParameters != null && dto.TemplateParameters.Any())\n            {\n                components.Add(new\n                {\n                    type = \"body\",\n                    parameters = dto.TemplateParameters.Select(p => new\n                    {\n                        type = \"text\",\n                        text = p\n                    }).ToArray()\n                });\n            }\n\n            // ‚ö†Ô∏è DO NOT add button components for static buttons\n            // Meta will render them automatically if template has static buttons defined\n            // You can later add logic here for dynamic buttons if needed\n\n            return new\n            {\n                messaging_product = \"whatsapp\",\n                to = dto.RecipientNumber,\n                type = \"template\",\n                template = new\n                {\n                    name = dto.TemplateName,\n                    language = new { code = \"en_US\" },\n                    components = components\n                }\n            };\n        }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/PayloadBuilders/TextMessagePayloadBuilder.cs",
      "sha256": "abc17e5a60e2f58ba07c610db126262040f598a15aca27d2f85d52afc2fb4766",
      "language": "csharp",
      "size": 554,
      "content": "using xbytechat.api.Features.MessagesEngine.DTOs;\n\nnamespace xbytechat.api.Features.MessagesEngine.PayloadBuilders\n{\n    public class TextMessagePayloadBuilder : IWhatsAppPayloadBuilder\n    {\n        public object BuildPayload(SendMessageDto dto)\n        {\n            return new\n            {\n                messaging_product = \"whatsapp\",\n                to = dto.RecipientNumber,\n                type = \"text\",\n                text = new\n                {\n                    body = dto.TextContent\n                }\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/Providers/MetaCloudProvider.cs",
      "sha256": "0bcab60a10252b65d74e289fbbc539e500374db9c0f3c72e405d1b60fe8b1ed0",
      "language": "csharp",
      "size": 6942,
      "content": "// üìÑ File: Features/MessagesEngine/Providers/MetaCloudProvider.cs\nusing System.Collections.Generic;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Text;\nusing System.Text.Json;\nusing System.Text.Json.Nodes;\nusing System.Text.Json.Serialization;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore; // for AsNoTracking()\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api;\nusing xbytechat.api.Features.MessagesEngine.Abstractions;\nusing xbytechat_api.WhatsAppSettings.Models;\n\nnamespace xbytechat.api.Features.MessagesEngine.Providers\n{\n    public class MetaCloudProvider : IWhatsAppProvider\n    {\n        private readonly AppDbContext _db;\n        private readonly HttpClient _http;\n        private readonly ILogger<MetaCloudProvider> _logger;\n        private readonly WhatsAppSettingEntity _setting;\n\n        // Optional per-send override injected by the factory/engine (safe to leave null)\n        private readonly string? _phoneNumberIdOverride;\n\n        private static readonly JsonSerializerOptions _jsonOpts = new()\n        {\n            // camelCase ensures typed models serialize as Meta expects (e.g. `language.code`)\n            PropertyNamingPolicy = JsonNamingPolicy.CamelCase,\n            DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull\n        };\n\n        public MetaCloudProvider(\n            AppDbContext db,\n            HttpClient http,\n            ILogger<MetaCloudProvider> logger,\n            WhatsAppSettingEntity setting,\n            string? phoneNumberIdOverride = null)\n        {\n            _db = db;\n            _http = http;\n            _logger = logger;\n            _setting = setting;\n            _phoneNumberIdOverride = phoneNumberIdOverride;\n        }\n\n        /// <summary>\n        /// Resolve the phone_number_id to use for Meta Cloud:\n        /// 1) explicit override if provided; else\n        /// 2) default active number from WhatsAppPhoneNumbers for this business+provider.\n        /// </summary>\n        private string? ResolvePhoneNumberId()\n        {\n            if (!string.IsNullOrWhiteSpace(_phoneNumberIdOverride))\n                return _phoneNumberIdOverride;\n\n            var providerKey = (_setting.Provider ?? string.Empty).Trim().ToLowerInvariant();\n\n            var pnid = _db.WhatsAppPhoneNumbers\n                .AsNoTracking()\n                .Where(n => n.BusinessId == _setting.BusinessId\n                            && n.IsActive\n                            && n.Provider.ToLower() == providerKey)\n                .OrderByDescending(n => n.IsDefault)\n                .ThenByDescending(n => n.UpdatedAt ?? n.CreatedAt)\n                .Select(n => n.PhoneNumberId)\n                .FirstOrDefault();\n\n            return pnid;\n        }\n\n        private string BuildUrl()\n        {\n            var baseUrl = string.IsNullOrWhiteSpace(_setting.ApiUrl)\n                ? \"https://graph.facebook.com/v22.0\"\n                : _setting.ApiUrl.TrimEnd('/');\n\n            var phoneNumberId = ResolvePhoneNumberId();\n            if (string.IsNullOrWhiteSpace(phoneNumberId))\n            {\n                _logger.LogError(\"MetaCloudProvider: PhoneNumberId is missing for BusinessId {BusinessId}\", _setting.BusinessId);\n                return $\"{baseUrl}/-/messages\"; // inert path; request will fail with clear logs\n            }\n\n            return $\"{baseUrl}/{phoneNumberId}/messages\";\n        }\n\n        /// <summary>\n        /// Recursively remove any `$type` discriminator properties from a JsonNode tree.\n        /// Meta rejects unknown keys like `$type` inside template.components[*].\n        /// </summary>\n        private static void StripDollarType(JsonNode? node)\n        {\n            if (node is null) return;\n\n            if (node is JsonObject obj)\n            {\n                if (obj.ContainsKey(\"$type\"))\n                    obj.Remove(\"$type\");\n\n                // safe enumeration snapshot\n                foreach (var kv in obj.ToList())\n                    StripDollarType(kv.Value);\n            }\n            else if (node is JsonArray arr)\n            {\n                foreach (var child in arr)\n                    StripDollarType(child);\n            }\n        }\n\n        private async Task<WaSendResult> PostAsync(object payload)\n        {\n            var url = BuildUrl();\n\n            // Sanitize payload to remove any $type injected by polymorphic models\n            var node = JsonSerializer.SerializeToNode(payload, _jsonOpts);\n            StripDollarType(node);\n            var json = node?.ToJsonString(_jsonOpts) ?? \"{}\";\n\n            using var req = new HttpRequestMessage(HttpMethod.Post, url)\n            {\n                Content = new StringContent(json, Encoding.UTF8, \"application/json\")\n            };\n            req.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(\"application/json\"));\n\n            if (!string.IsNullOrWhiteSpace(_setting.ApiKey))\n            {\n                req.Headers.Authorization = new AuthenticationHeaderValue(\"Bearer\", _setting.ApiKey);\n            }\n            else\n            {\n                _logger.LogWarning(\"MetaCloudProvider: ApiToken is empty for BusinessId {BusinessId}\", _setting.BusinessId);\n            }\n\n            var res = await _http.SendAsync(req);\n            var body = await res.Content.ReadAsStringAsync();\n\n            if (!res.IsSuccessStatusCode)\n            {\n                _logger.LogWarning(\"MetaCloud send failed (HTTP {Status}): {Body}\", (int)res.StatusCode, body);\n                return new WaSendResult(false, \"MetaCloud\", null, res.StatusCode, body, res.ReasonPhrase);\n            }\n\n            string? id = null;\n            try\n            {\n                var root = JsonNode.Parse(body);\n                id = root?[\"messages\"]?[0]?[\"id\"]?.GetValue<string>();\n            }\n            catch { /* keep raw */ }\n\n            return new WaSendResult(true, \"MetaCloud\", id, res.StatusCode, body, null);\n        }\n\n        public Task<WaSendResult> SendTextAsync(string to, string body)\n            => PostAsync(new\n            {\n                messaging_product = \"whatsapp\",\n                to,\n                type = \"text\",\n                text = new { preview_url = false, body }\n            });\n\n        public Task<WaSendResult> SendTemplateAsync(string to, string templateName, string languageCode, IEnumerable<object> components)\n            => PostAsync(new\n            {\n                messaging_product = \"whatsapp\",\n                to,\n                type = \"template\",\n                template = new\n                {\n                    name = templateName,\n                    language = new { code = languageCode }, // Meta expects { \"code\": \"en_US\" }\n                    components = components ?? System.Linq.Enumerable.Empty<object>()\n                }\n            });\n\n        public Task<WaSendResult> SendInteractiveAsync(object fullPayload)\n            => PostAsync(fullPayload);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/Providers/PinnacleProvider.cs",
      "sha256": "d803171cd01474f2c03261a8db09e547472a5af8272ca59d08eaffe95990051f",
      "language": "csharp",
      "size": 8325,
      "content": "// üìÑ File: Features/MessagesEngine/Providers/PinnacleProvider.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Text;\nusing System.Text.Json;\nusing System.Text.Json.Serialization;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api;\nusing xbytechat.api.Features.MessagesEngine.Abstractions;\nusing xbytechat_api.WhatsAppSettings.Models;\n\nnamespace xbytechat.api.Features.MessagesEngine.Providers\n{\n    public class PinnacleProvider : IWhatsAppProvider\n    {\n        private readonly AppDbContext _db;\n        private readonly HttpClient _http;\n        private readonly ILogger<PinnacleProvider> _logger;\n        private readonly WhatsAppSettingEntity _setting;\n\n        // optional per-send override (phone_number_id or wabaId path segment)\n        private readonly string? _pathIdOverride;\n\n        private static readonly JsonSerializerOptions _jsonOpts = new()\n        {\n            DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull\n        };\n\n        public PinnacleProvider(\n            AppDbContext db,\n            HttpClient http,\n            ILogger<PinnacleProvider> logger,\n            WhatsAppSettingEntity setting,\n            string? pathIdOverride = null)\n        {\n            _db = db;\n            _http = http;\n            _logger = logger;\n            _setting = setting;\n            _pathIdOverride = pathIdOverride;\n        }\n\n        /// <summary>\n        /// Resolve the path identifier used by Pinnacle: prefer explicit override,\n        /// then WabaId from settings, then PhoneNumberId from WhatsAppPhoneNumbers.\n        /// </summary>\n        private string? ResolvePathIdOrNull()\n        {\n            if (!string.IsNullOrWhiteSpace(_pathIdOverride))\n                return _pathIdOverride;\n\n            if (!string.IsNullOrWhiteSpace(_setting.WabaId))\n                return _setting.WabaId;\n\n            var providerKey = (_setting.Provider ?? string.Empty).Trim().ToLowerInvariant();\n\n            // fallback to default active sender for this provider\n            var phoneId = _db.WhatsAppPhoneNumbers\n                .AsNoTracking()\n                .Where(n => n.BusinessId == _setting.BusinessId\n                            && n.IsActive\n                            && n.Provider.ToLower() == providerKey)\n                .OrderByDescending(n => n.IsDefault)\n                .ThenByDescending(n => n.UpdatedAt ?? n.CreatedAt)\n                .Select(n => n.PhoneNumberId)\n                .FirstOrDefault();\n\n            return phoneId;\n        }\n\n        private string BuildBaseUrl()\n        {\n            var baseUrl = string.IsNullOrWhiteSpace(_setting.ApiUrl)\n                ? \"https://partnersv1.pinbot.ai\"\n                : _setting.ApiUrl.TrimEnd('/');\n\n            if (!baseUrl.EndsWith(\"/v3\", StringComparison.OrdinalIgnoreCase))\n                baseUrl += \"/v3\";\n\n            return baseUrl;\n        }\n\n        /// <summary>\n        /// Build the final send URL. If pathId is already a full URL, use as-is (for tracking cases).\n        /// Otherwise, compose the Pinnacle endpoint and ALWAYS append apikey in the query.\n        /// </summary>\n        private string BuildSendUrlWithApiKey(string pathId)\n        {\n            if (Uri.IsWellFormedUriString(pathId, UriKind.Absolute))\n                return pathId;\n\n            var baseUrl = BuildBaseUrl();\n            var apiKey = _setting.ApiKey ?? string.Empty;\n            return $\"{baseUrl}/{pathId}/messages?apikey={Uri.EscapeDataString(apiKey)}\";\n        }\n\n        private async Task<WaSendResult> PostAsync(object payload)\n        {\n            var pathId = ResolvePathIdOrNull();\n            if (string.IsNullOrWhiteSpace(pathId))\n            {\n                const string err = \"Pinnacle: Missing path id (need WabaId or PhoneNumberId/default sender).\";\n                _logger.LogError(err);\n                return new WaSendResult(false, \"Pinnacle\", null, null, null, err);\n            }\n\n            if (string.IsNullOrWhiteSpace(_setting.ApiKey))\n            {\n                const string err = \"Pinnacle: ApiKey is missing in WhatsApp settings.\";\n                _logger.LogError(err);\n                return new WaSendResult(false, \"Pinnacle\", null, null, null, err);\n            }\n\n            var url = BuildSendUrlWithApiKey(pathId);\n            var json = JsonSerializer.Serialize(payload, _jsonOpts);\n\n            using var req = new HttpRequestMessage(HttpMethod.Post, url);\n            req.Content = new StringContent(json, Encoding.UTF8, \"application/json\");\n\n            // Put key in all common header places (some tenants validate one or the other)\n            req.Headers.Remove(\"apikey\");\n            req.Headers.Remove(\"x-api-key\");\n            req.Headers.TryAddWithoutValidation(\"apikey\", _setting.ApiKey);\n            req.Headers.TryAddWithoutValidation(\"x-api-key\", _setting.ApiKey);\n            req.Headers.Authorization = new AuthenticationHeaderValue(\"Apikey\", _setting.ApiKey);\n            req.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(\"application/json\"));\n\n            // trace (shortened key)\n            _logger.LogInformation(\"Pinnacle POST {Url}\", url);\n\n            var res = await _http.SendAsync(req);\n            var body = await res.Content.ReadAsStringAsync();\n\n            if (!res.IsSuccessStatusCode)\n            {\n                _logger.LogWarning(\"Pinnacle send failed (HTTP {Status}): {Body}\", (int)res.StatusCode, body);\n                return new WaSendResult(false, \"Pinnacle\", null, res.StatusCode, body, res.ReasonPhrase);\n            }\n\n            string? id = TryGetPinnMessageId(body);\n            return new WaSendResult(true, \"Pinnacle\", id, res.StatusCode, body, null);\n        }\n\n        public Task<WaSendResult> SendTextAsync(string to, string body)\n            => PostAsync(new\n            {\n                messaging_product = \"whatsapp\",\n                to,\n                type = \"text\",\n                text = new { preview_url = false, body }\n            });\n\n        public Task<WaSendResult> SendTemplateAsync(string to, string templateName, string languageCode, IEnumerable<object> components)\n        {\n            components ??= Enumerable.Empty<object>();\n            // Pinnacle expects language as-is (not { code: \"xx_YY\" })\n            var langValue = languageCode;\n            return PostAsync(new\n            {\n                messaging_product = \"whatsapp\",\n                to,\n                type = \"template\",\n                template = new\n                {\n                    name = templateName,\n                    language = langValue,\n                    components\n                }\n            });\n        }\n\n        private static string? TryGetPinnMessageId(string json)\n        {\n            try\n            {\n                using var doc = JsonDocument.Parse(json);\n                var root = doc.RootElement;\n\n                if (root.TryGetProperty(\"messages\", out var msgs) &&\n                    msgs.ValueKind == JsonValueKind.Array &&\n                    msgs.GetArrayLength() > 0 &&\n                    msgs[0].TryGetProperty(\"id\", out var id0))\n                    return id0.GetString();\n\n                if (root.TryGetProperty(\"message\", out var msg) && msg.ValueKind == JsonValueKind.Object)\n                {\n                    if (msg.TryGetProperty(\"id\", out var id1)) return id1.GetString();\n                    if (msg.TryGetProperty(\"messageId\", out var id2)) return id2.GetString();\n                }\n\n                if (root.TryGetProperty(\"message_id\", out var id3)) return id3.GetString();\n                if (root.TryGetProperty(\"messageId\", out var id4)) return id4.GetString();\n                if (root.TryGetProperty(\"data\", out var data) &&\n                    data.ValueKind == JsonValueKind.Object &&\n                    data.TryGetProperty(\"messageId\", out var id5)) return id5.GetString();\n                if (root.TryGetProperty(\"id\", out var idTop)) return idTop.GetString();\n            }\n            catch { /* ignore parse errors, return null */ }\n\n            return null;\n        }\n\n        public Task<WaSendResult> SendInteractiveAsync(object fullPayload) => PostAsync(fullPayload);\n    }\n}\n\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/Services/IMessageEngineService.cs",
      "sha256": "09b825ad8c2e13d48cc66e824e1d79fecd5f2752c550e0122b4eed8e4b673701",
      "language": "csharp",
      "size": 2409,
      "content": "// ‚úÖ Step 1: Final interface\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Helpers;\nusing System.Threading.Tasks;\nusing System.IO.Pipelines;\nusing xbytechat.api.Features.MessageManagement.DTOs;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing System.Threading;\nusing xbytechat.api.Features.MessagesEngine.Enums;\n\n\nnamespace xbytechat.api.Features.MessagesEngine.Services\n{\n    public interface IMessageEngineService\n    {\n\n        Task<ResponseResult> SendTemplateMessageAsync(SendMessageDto dto); //\n        Task<ResponseResult> SendTextDirectAsync(TextMessageSendDto dto);\n        Task<ResponseResult> SendImageDirectAsync(MediaMessageSendDto dto);\n        Task<ResponseResult> SendDocumentDirectAsync(MediaMessageSendDto dto);\n        Task<ResponseResult> SendVideoDirectAsync(MediaMessageSendDto dto);\n        Task<ResponseResult> SendAudioDirectAsync(MediaMessageSendDto dto);\n        Task<ResponseResult> SendLocationDirectAsync(LocationMessageSendDto dto);\n        Task<ResponseResult> SendAutomationReply(TextMessageSendDto dto);\n        Task<ResponseResult> SendTemplateMessageSimpleAsync(Guid businessId, SimpleTemplateMessageDto dto);\n        Task<ResponseResult> SendImageCampaignAsync(Guid campaignId, Guid businessId, string triggeredBy);\n        Task<ResponseResult> SendImageTemplateMessageAsync(ImageTemplateMessageDto dto, Guid businessId);\n            Task<ResponseResult> SendPayloadAsync(\n         Guid businessId,\n         string provider,          // \"PINNACLE\" or \"META_CLOUD\"\n         object payload,\n         string? phoneNumberId = null);\n        Task<ResponseResult> SendVideoTemplateMessageAsync(VideoTemplateMessageDto dto, Guid businessId);\n        Task<ResponseResult> SendDocumentTemplateMessageAsync(\n           DocumentTemplateMessageDto dto,\n           Guid businessId);\n\n        // ‚úÖ NEW: Auto-reply helper (for webhook / AutoReplyBuilder runtime)\n        Task<ResponseResult> SendAutoReplyTextAsync(\n             Guid businessId,\n             string recipientNumber,\n             string body,\n             CancellationToken ct = default);\n\n        // ‚úÖ NEW overload ‚Äì AutoReply with explicit DeliveryMode\n        Task<ResponseResult> SendAutoReplyTextAsync(\n            Guid businessId,\n            string recipientNumber,\n            string body,\n            DeliveryMode mode,\n            CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/Services/ITemplateMessageSender.cs",
      "sha256": "7051d636ceaac1c53f50319b247f59828ed24e774132628d0e4894e65da74c87",
      "language": "csharp",
      "size": 831,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Shared;\nusing xbytechat.api.Features.CampaignModule.Models;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Features.CRM.Models;\n\nnamespace xbytechat.api.Features.MessagesEngine.Services\n{\n    public interface ITemplateMessageSender\n    {\n        Task<ResponseResult> SendTemplateMessageToContactAsync(\n           Guid businessId,\n           Contact contact,\n           string templateName,\n           List<string> templateParams,\n           string? imageUrl = null,\n           List<CampaignButton>? buttons = null,\n           string? source = null,\n           Guid? refMessageId = null\n       );\n\n        Task<ResponseResult> SendTemplateCampaignAsync(Campaign campaign);\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/Services/MessageEngineDeliveryModeExtensions.cs",
      "sha256": "4ba3a0dffa1efa78453ac6f3aa9055a7af0fc6108feef391852a8f8e9b4b61e1",
      "language": "csharp",
      "size": 2671,
      "content": "// üìÑ xbytechat-api/Features/MessagesEngine/Services/MessageEngineDeliveryModeExtensions.cs\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.MessagesEngine.Enums;\nusing xbytechat.api.Helpers; // ResponseResult\n\nnamespace xbytechat.api.Features.MessagesEngine.Services\n{\n    /// <summary>\n    /// Extension methods that add DeliveryMode-aware overloads\n    /// on top of the existing IMessageEngineService interface.\n    ///\n    /// v1 behaviour:\n    /// - These methods mostly delegate to the original overloads.\n    /// - For templates, we now copy the DeliveryMode onto the DTO.\n    /// - The core MessageEngineService can later read dto.DeliveryMode\n    ///   and decide whether to use the Outbox or send immediately.\n    /// </summary>\n    public static class MessageEngineDeliveryModeExtensions\n    {\n        /// <summary>\n        /// DeliveryMode-aware overload for sending simple template messages.\n        /// Currently sets dto.DeliveryMode = mode, then calls the existing implementation.\n        /// </summary>\n        public static Task<ResponseResult> SendTemplateMessageSimpleAsync(\n            this IMessageEngineService engine,\n            Guid businessId,\n            SimpleTemplateMessageDto dto,\n            DeliveryMode mode,\n            CancellationToken ct = default)\n        {\n            if (engine is null) throw new ArgumentNullException(nameof(engine));\n            if (dto is null) throw new ArgumentNullException(nameof(dto));\n\n            // üÜï Stamp the requested mode onto the DTO so the engine can inspect it.\n            dto.DeliveryMode = mode;\n\n            // v1: underlying implementation still behaves the same.\n            return engine.SendTemplateMessageSimpleAsync(businessId, dto);\n        }\n\n        /// <summary>\n        /// DeliveryMode-aware overload for auto-reply text messages.\n        /// For now, the mode is ignored and we delegate to the existing method.\n        /// Later we can teach the engine to branch on mode here as well.\n        /// </summary>\n        public static Task<ResponseResult> SendAutoReplyTextAsync(\n            this IMessageEngineService engine,\n            Guid businessId,\n            string recipientNumber,\n            string body,\n            DeliveryMode mode,\n            CancellationToken ct = default)\n        {\n            if (engine is null) throw new ArgumentNullException(nameof(engine));\n\n            // v1: keep existing behaviour for text; still uses the current pipeline.\n            return engine.SendAutoReplyTextAsync(businessId, recipientNumber, body, ct);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/Services/MessageEngineService.cs",
      "sha256": "e79414ced6036a9e85cd11e95590f6181ca09f5f9a9352d0143825a8485039c4",
      "language": "csharp",
      "size": 130677,
      "content": "// üìÑ File: Features/MessagesEngine/Services/MessageEngineService.cs\nusing System;\nusing System.Collections.Concurrent;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net.Http;\nusing System.Text;\nusing System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.SignalR;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing xbytechat.api.Features.CampaignModule.Models;\nusing xbytechat.api.Features.CampaignModule.SendEngine.PayloadModels.Meta;\nusing xbytechat.api.Features.CampaignModule.SendEngine.PayloadModels.Pinnacle;\nusing xbytechat.api.Features.CampaignTracking.Models;\nusing xbytechat.api.Features.CRM.Interfaces;\nusing xbytechat.api.Features.CRM.Models;\nusing xbytechat.api.Features.Inbox.Hubs;\nusing xbytechat.api.Features.MessageManagement.DTOs;\nusing xbytechat.api.Features.MessagesEngine.Abstractions;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.MessagesEngine.Enums;\nusing xbytechat.api.Features.MessagesEngine.Factory;\nusing xbytechat.api.Features.MessagesEngine.PayloadBuilders;\nusing xbytechat.api.Features.PlanManagement.Services;\nusing xbytechat.api.Features.ReportingModule.DTOs;\nusing xbytechat.api.Features.Webhooks.Services.Resolvers;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Infrastructure.Json;         // <- source-gen context (JsonCtx)\nusing xbytechat.api.Shared;\nusing xbytechat.api.Shared.utility;\nusing xbytechat.api.WhatsAppSettings.DTOs;\nusing xbytechat_api.WhatsAppSettings.Models;\n\nnamespace xbytechat.api.Features.MessagesEngine.Services\n{\n    public class MessageEngineService : IMessageEngineService\n    {\n        private readonly AppDbContext _db;\n        private readonly HttpClient _http; // kept for any internal calls\n        private readonly TextMessagePayloadBuilder _textBuilder;\n        private readonly ImageMessagePayloadBuilder _imageBuilder;\n        private readonly TemplateMessagePayloadBuilder _templateBuilder;\n        private readonly CtaMessagePayloadBuilder _ctaBuilder;\n        private readonly IPlanManager _planManager;\n        private readonly IHubContext<InboxHub> _hubContext;\n        private readonly IMessageIdResolver _messageIdResolver;\n        private readonly IHttpContextAccessor _httpContextAccessor;\n        private readonly IContactService _contactService;\n        private readonly IWhatsAppProviderFactory _providerFactory;\n        private readonly ILogger<MessageEngineService> _logger;\n\n        // Basic cache for WhatsApp settings to reduce DB load\n        private readonly ConcurrentDictionary<Guid, (IReadOnlyList<WhatsAppSettingEntity> setting, DateTime expiresAt)> _settingsCache = new();\n\n        public MessageEngineService(\n            AppDbContext db,\n            HttpClient http,\n            TextMessagePayloadBuilder textBuilder,\n            ImageMessagePayloadBuilder imageBuilder,\n            TemplateMessagePayloadBuilder templateBuilder,\n            CtaMessagePayloadBuilder ctaBuilder,\n            IPlanManager planManager,\n            IHubContext<InboxHub> hubContext,\n            IMessageIdResolver messageIdResolver,\n            IHttpContextAccessor httpContextAccessor,\n            IContactService contactService,\n            IWhatsAppProviderFactory providerFactory,\n            ILogger<MessageEngineService> logger)\n        {\n            _db = db;\n            _http = http;\n            _textBuilder = textBuilder;\n            _imageBuilder = imageBuilder;\n            _templateBuilder = templateBuilder;\n            _ctaBuilder = ctaBuilder;\n            _planManager = planManager;\n            _hubContext = hubContext;\n            _messageIdResolver = messageIdResolver;\n            _httpContextAccessor = httpContextAccessor;\n            _contactService = contactService;\n            _providerFactory = providerFactory;\n            _logger = logger;\n        }\n\n        // ---------- small helpers ----------\n        private static string ResolveGreeting(string? profileName, string? contactName)\n        {\n            var s = (profileName ?? contactName)?.Trim();\n            return string.IsNullOrEmpty(s) ? \"there\" : s;\n        }\n\n        private static void EnsureArgsLength(List<string> args, int slot1Based)\n        {\n            while (args.Count < slot1Based) args.Add(string.Empty);\n        }\n\n        // ‚úÖ Public helper so both Flow + Campaign send paths can use it\n        //public async Task<List<string>> ApplyProfileNameAsync(\n        //    Guid businessId,\n        //    Guid contactId,\n        //    bool useProfileName,\n        //    int? profileNameSlot,\n        //    List<string> args,\n        //    CancellationToken ct = default)\n        //{\n        //    if (!useProfileName || !(profileNameSlot is int slot) || slot < 1)\n        //        return args;\n\n        //    //var contact = await _db.Contacts\n        //    //    .AsNoTracking()\n        //    //    .FirstOrDefaultAsync(c => c.BusinessId == businessId && c.Id == contactId, ct);\n\n        //    var greet = ResolveGreeting(contact?.ProfileName, contact?.Name);\n        //    EnsureArgsLength(args, slot);\n        //    args[slot - 1] = greet;\n        //    return args;\n        //}\n        public async Task<List<string>> ApplyProfileNameAsync(\n    Guid businessId,\n    Guid contactId,\n    bool useProfileName,\n    int? profileNameSlot,\n    List<string> args,\n    CancellationToken ct = default)\n        {\n            // Normalize args so we never return null\n            args ??= new List<string>();\n\n            // Quick outs\n            if (!useProfileName || profileNameSlot is not int slot || slot < 1)\n                return args;\n\n            // Load the contact only when needed\n            var contact = await _db.Contacts\n                .AsNoTracking()\n                .Where(c => c.BusinessId == businessId && c.Id == contactId)\n                .Select(c => new { c.Name, c.ProfileName })\n                .FirstOrDefaultAsync(ct);\n\n            // If no contact, just return args unchanged\n            if (contact is null)\n                return args;\n\n            // Build the greeting / display name (adjust ResolveGreeting to your needs)\n            var greet = ResolveGreeting(contact.ProfileName, contact.Name);\n            if (string.IsNullOrWhiteSpace(greet))\n                return args; // nothing to apply\n\n            // Ensure args has capacity for the requested slot (1-based)\n            if (args.Count < slot)\n                args.AddRange(Enumerable.Repeat(string.Empty, slot - args.Count));\n\n            // Set the value at the requested slot\n            args[slot - 1] = greet;\n\n            return args;\n        }\n\n        // ============================================================\n        //  SOURCE-GEN PATH FOR TYPED PAYLOADS (Step 9 ‚Äì point #5)\n        // ============================================================\n        public async Task<ResponseResult> SendPayloadAsync(Guid businessId, string provider, object payload, string? phoneNumberId = null)\n        {\n            if (string.IsNullOrWhiteSpace(provider) || (provider != \"PINNACLE\" && provider != \"META_CLOUD\"))\n                return ResponseResult.ErrorInfo(\"‚ùå Invalid provider.\", \"Provider must be exactly 'PINNACLE' or 'META_CLOUD'.\");\n\n            var payloadRecipient = TryExtractRecipientFromPayload(payload);\n            if (string.IsNullOrWhiteSpace(payloadRecipient))\n            {\n                _logger.LogWarning(\n                    \"Outbound consent guard could not be applied because payload recipient is missing. businessId={BusinessId}\",\n                    businessId);\n            }\n            else\n            {\n                // Compliance guard must run before any outbound provider send call.\n                var consentBlock = await EnforceOutboundConsentGuardAsync(businessId, payloadRecipient);\n                if (consentBlock != null) return consentBlock;\n            }\n\n            // If already-typed, keep your current JsonElement path:\n            if (payload is MetaTemplateMessage m)\n            {\n                var json = JsonSerializer.Serialize(m, JsonCtx.Default.MetaTemplateMessage);\n                using var doc = JsonDocument.Parse(json);\n                return await SendViaProviderAsync(businessId, provider, p => p.SendInteractiveAsync(doc.RootElement.Clone()), phoneNumberId);\n            }\n            if (payload is PinnacleTemplateMessage pmsg)\n            {\n                var json = JsonSerializer.Serialize(pmsg, JsonCtx.Default.PinnacleTemplateMessage);\n                using var doc = JsonDocument.Parse(json);\n                return await SendViaProviderAsync(businessId, provider, p => p.SendInteractiveAsync(doc.RootElement.Clone()), phoneNumberId);\n            }\n\n            // NEW: if the anonymous payload looks like a WhatsApp \"template\" message,\n            // extract the parts and call SendTemplateAsync directly (no raw object pass-through).\n            if (payload is JsonElement je && je.ValueKind == JsonValueKind.Object &&\n                je.TryGetProperty(\"type\", out var t) && t.GetString() == \"template\" &&\n                je.TryGetProperty(\"to\", out var toProp) &&\n                je.TryGetProperty(\"template\", out var tmpl) &&\n                tmpl.TryGetProperty(\"name\", out var nameProp) &&\n                tmpl.TryGetProperty(\"language\", out var langProp) &&\n                langProp.TryGetProperty(\"code\", out var codeProp) &&\n                tmpl.TryGetProperty(\"components\", out var comps))\n            {\n                var to = toProp.GetString()!;\n                var name = nameProp.GetString()!;\n                var code = codeProp.GetString()!;\n                // Materialize components as plain anonymous objects to guarantee no $type:\n                var components = new List<object>();\n                foreach (var c in comps.EnumerateArray())\n                {\n                    var type = c.GetProperty(\"type\").GetString();\n                    if (type == \"body\")\n                    {\n                        var pars = c.TryGetProperty(\"parameters\", out var pr)\n                            ? pr.EnumerateArray().Select(p => new { type = p.GetProperty(\"type\").GetString(), text = p.GetProperty(\"text\").GetString() }).ToArray()\n                            : System.Array.Empty<object>();\n                        components.Add(new { type = \"body\", parameters = pars });\n                    }\n                    else if (type == \"header\")\n                    {\n                        // support header image\n                        if (c.TryGetProperty(\"parameters\", out var pr) && pr.GetArrayLength() > 0)\n                        {\n                            var p0 = pr[0];\n                            if (p0.TryGetProperty(\"type\", out var pt) && pt.GetString() == \"image\")\n                            {\n                                var link = p0.GetProperty(\"image\").GetProperty(\"link\").GetString();\n                                components.Add(new { type = \"header\", parameters = new object[] { new { type = \"image\", image = new { link } } } });\n                            }\n                            else\n                            {\n                                components.Add(new { type = \"header\", parameters = new object[] { } });\n                            }\n                        }\n                        else components.Add(new { type = \"header\", parameters = new object[] { } });\n                    }\n                    else if (type == \"button\")\n                    {\n                        var subType = c.GetProperty(\"sub_type\").GetString();\n                        var index = c.GetProperty(\"index\").GetString();\n                        if (subType == \"url\" && c.TryGetProperty(\"parameters\", out var pr) && pr.GetArrayLength() > 0)\n                        {\n                            var urlParam = pr[0].GetProperty(\"text\").GetString();\n                            components.Add(new { type = \"button\", sub_type = \"url\", index, parameters = new object[] { new { type = \"text\", text = urlParam } } });\n                        }\n                    }\n                }\n\n                return await SendViaProviderAsync(businessId, provider,\n                    p => p.SendTemplateAsync(to, name, code, components),\n                    phoneNumberId);\n            }\n\n            // Fallback: send as-is via interactive\n            return await SendViaProviderAsync(businessId, provider, p => p.SendInteractiveAsync(payload), phoneNumberId);\n        }\n\n\n\n\n\n        private static string NormalizeProviderOrThrow(string? p)\n        {\n            if (string.IsNullOrWhiteSpace(p))\n                throw new ArgumentException(\"Provider is required.\");\n\n            var u = p.Trim().ToUpperInvariant();\n            return u switch\n            {\n                \"META\" => \"META_CLOUD\", // internal convenience; callers should still pass exact values\n                \"META_CLOUD\" => \"META_CLOUD\",\n                \"PINNACLE\" => \"PINNACLE\",\n                _ => throw new ArgumentException($\"Invalid provider: {p}\")\n            };\n        }\n\n        private async Task<ResponseResult> SendViaProviderAsync(\n            Guid businessId,\n            string provider,                                // explicit\n            Func<IWhatsAppProvider, Task<WaSendResult>> action,\n            string? phoneNumberId = null)\n        {\n            try\n            {\n                // normalize internally (tolerate \"META\" here) but keep external API strict\n                var normalizedProvider = NormalizeProviderOrThrow(provider);\n\n                // For both META_CLOUD and PINNACLE we require a sender id here\n                if (string.IsNullOrWhiteSpace(phoneNumberId))\n                    return ResponseResult.ErrorInfo(\n                        \"‚ùå Campaign has no sender number.\",\n                        \"Missing PhoneNumberId\");\n\n                // Build provider bound to business + sender\n                var wa = await _providerFactory.CreateAsync(\n                    businessId,\n                    normalizedProvider,\n                    phoneNumberId);\n\n                // post request to http URL\n                var response = await action(wa);\n\n                if (!response.Success)\n                    return ResponseResult.ErrorInfo(\"‚ùå WhatsApp API returned an error.\", response.Error, response.RawResponse);\n\n                var rr = ResponseResult.SuccessInfo(\"‚úÖ Message sent successfully\", data: null, raw: response.RawResponse);\n                rr.MessageId = string.IsNullOrWhiteSpace(response.ProviderMessageId)\n                    ? TryExtractMetaWamid(response.RawResponse)\n                    : response.ProviderMessageId;\n                return rr;\n            }\n            catch (ArgumentException ex)\n            {\n                return ResponseResult.ErrorInfo(\"‚ùå Invalid provider.\", ex.Message);\n            }\n            catch (InvalidOperationException ex)\n            {\n                return ResponseResult.ErrorInfo(\"‚ùå Provider configuration error.\", ex.Message);\n            }\n            catch (Exception ex)\n            {\n                return ResponseResult.ErrorInfo(\"‚ùå Provider call failed.\", ex.Message);\n            }\n        }\n\n        private static string? TryExtractMetaWamid(string? raw)\n        {\n            if (string.IsNullOrWhiteSpace(raw)) return null;\n            var s = raw.TrimStart();\n            if (!s.StartsWith(\"{\")) return null;\n            try\n            {\n                using var doc = JsonDocument.Parse(s);\n                if (doc.RootElement.TryGetProperty(\"messages\", out var msgs) &&\n                    msgs.ValueKind == JsonValueKind.Array &&\n                    msgs.GetArrayLength() > 0 &&\n                    msgs[0].TryGetProperty(\"id\", out var idProp))\n                {\n                    return idProp.GetString();\n                }\n            }\n            catch { }\n            return null;\n        }\n\n        private static string NormalizeRecipientDigits(string? recipientNumber)\n        {\n            var raw = (recipientNumber ?? string.Empty).Trim();\n            if (string.IsNullOrWhiteSpace(raw))\n                return string.Empty;\n\n            var normalized = PhoneNumberNormalizer.NormalizeToE164Digits(raw, \"IN\");\n            if (!string.IsNullOrWhiteSpace(normalized))\n                return normalized;\n\n            // Defensive fallback for legacy/loosely-formatted numbers.\n            var digits = new string(raw.Where(char.IsDigit).ToArray());\n            return digits.Length is >= 7 and <= 15 ? digits : string.Empty;\n        }\n\n        private static List<string> BuildRecipientLookupCandidates(string? recipientNumber)\n        {\n            var candidates = new HashSet<string>(StringComparer.Ordinal);\n            var raw = (recipientNumber ?? string.Empty).Trim();\n            var normalized = NormalizeRecipientDigits(raw);\n            var digitsOnly = new string(raw.Where(char.IsDigit).ToArray());\n\n            if (!string.IsNullOrWhiteSpace(normalized))\n            {\n                candidates.Add(normalized);\n                candidates.Add(\"+\" + normalized);\n\n                // Legacy IN contacts may still exist as local 10-digit numbers.\n                if (normalized.Length == 12 && normalized.StartsWith(\"91\", StringComparison.Ordinal))\n                    candidates.Add(normalized.Substring(2));\n            }\n\n            if (!string.IsNullOrWhiteSpace(digitsOnly))\n            {\n                candidates.Add(digitsOnly);\n                candidates.Add(\"+\" + digitsOnly);\n\n                if (digitsOnly.Length == 10)\n                {\n                    candidates.Add(\"91\" + digitsOnly);\n                    candidates.Add(\"+91\" + digitsOnly);\n                }\n                else if (digitsOnly.Length == 12 && digitsOnly.StartsWith(\"91\", StringComparison.Ordinal))\n                {\n                    candidates.Add(digitsOnly.Substring(2));\n                }\n            }\n\n            if (!string.IsNullOrWhiteSpace(raw))\n                candidates.Add(raw);\n\n            return candidates.Where(c => !string.IsNullOrWhiteSpace(c)).ToList();\n        }\n\n        private static bool TryReadRecipientFromPayload(JsonElement root, out string? recipient)\n        {\n            recipient = null;\n            if (root.ValueKind != JsonValueKind.Object) return false;\n\n            if (root.TryGetProperty(\"to\", out var toProp) && toProp.ValueKind == JsonValueKind.String)\n            {\n                recipient = toProp.GetString();\n                return !string.IsNullOrWhiteSpace(recipient);\n            }\n\n            if (root.TryGetProperty(\"To\", out var toPascalProp) && toPascalProp.ValueKind == JsonValueKind.String)\n            {\n                recipient = toPascalProp.GetString();\n                return !string.IsNullOrWhiteSpace(recipient);\n            }\n\n            return false;\n        }\n\n        private static string? TryExtractRecipientFromPayload(object payload)\n        {\n            if (payload is JsonElement jsonElement)\n                return TryReadRecipientFromPayload(jsonElement, out var fromJsonElement) ? fromJsonElement : null;\n\n            try\n            {\n                using var payloadDoc = JsonDocument.Parse(JsonSerializer.Serialize(payload));\n                return TryReadRecipientFromPayload(payloadDoc.RootElement, out var fromPayloadObject) ? fromPayloadObject : null;\n            }\n            catch\n            {\n                return null;\n            }\n        }\n\n        private async Task<ResponseResult?> EnforceOutboundConsentGuardAsync(Guid businessId, string? recipientNumber, CancellationToken ct = default)\n        {\n            var lookupCandidates = BuildRecipientLookupCandidates(recipientNumber);\n            var normalizedPhone = NormalizeRecipientDigits(recipientNumber);\n            if (lookupCandidates.Count == 0)\n                return null;\n\n            var contact = await _db.Contacts\n                .Where(c => c.BusinessId == businessId && lookupCandidates.Contains(c.PhoneNumber))\n                .OrderByDescending(c => c.OptStatus == ContactOptStatus.OptedOut)\n                .ThenByDescending(c => c.OptStatusUpdatedAt)\n                .FirstOrDefaultAsync(ct);\n\n            if (contact == null)\n            {\n                _logger.LogWarning(\n                    \"Outbound consent guard could not be applied because contact was not found. businessId={BusinessId} phone={Phone}\",\n                    businessId,\n                    normalizedPhone);\n                return null;\n            }\n\n            if (contact.OptStatus == ContactOptStatus.OptedOut)\n            {\n                _logger.LogInformation(\n                    \"Outbound blocked by consent guard. businessId={BusinessId} phone={Phone} optStatus={OptStatus} channelStatus={ChannelStatus}\",\n                    businessId,\n                    normalizedPhone,\n                    contact.OptStatus,\n                    contact.ChannelStatus);\n                return ResponseResult.ErrorInfo(\"CONTACT_OPTED_OUT\");\n            }\n\n            if (contact.ChannelStatus != ContactChannelStatus.Valid)\n            {\n                _logger.LogInformation(\n                    \"Outbound blocked by channel guard. businessId={BusinessId} phone={Phone} optStatus={OptStatus} channelStatus={ChannelStatus}\",\n                    businessId,\n                    normalizedPhone,\n                    contact.OptStatus,\n                    contact.ChannelStatus);\n                return ResponseResult.ErrorInfo(\"CONTACT_CHANNEL_BLOCKED_OR_INVALID\");\n            }\n\n            return null;\n        }\n\n        // ---------- CSV-materialized variable helpers (for campaign recipients) ----------\n        private static string[] ReadBodyParams(string? json)\n        {\n            if (string.IsNullOrWhiteSpace(json)) return Array.Empty<string>();\n            try { return JsonSerializer.Deserialize<string[]>(json) ?? Array.Empty<string>(); }\n            catch { return Array.Empty<string>(); }\n        }\n\n        private static Dictionary<string, string> ReadVarDict(string? json)\n        {\n            if (string.IsNullOrWhiteSpace(json))\n                return new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n            try\n            {\n                return JsonSerializer.Deserialize<Dictionary<string, string>>(json)\n                       ?? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n            }\n            catch\n            {\n                return new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n            }\n        }\n\n        private static List<string> BuildHeaderTextParams(IDictionary<string, string> kv)\n        {\n            var matches = kv.Keys\n                .Select(k => new\n                {\n                    k,\n                    m = System.Text.RegularExpressions.Regex.Match(\n                        k, @\"^(?:header(?:\\.text)?\\.)?(\\d+)$|^header(?:\\.text)?\\.(\\d+)$|^headerpara(\\d+)$\",\n                        System.Text.RegularExpressions.RegexOptions.IgnoreCase)\n                })\n                .Where(x => x.m.Success)\n                .Select(x =>\n                {\n                    for (int g = 1; g < x.m.Groups.Count; g++)\n                        if (x.m.Groups[g].Success) return int.Parse(x.m.Groups[g].Value);\n                    return 0;\n                })\n                .Where(n => n > 0)\n                .Distinct()\n                .OrderBy(n => n)\n                .ToList();\n\n            if (matches.Count == 0) return new List<string>();\n\n            var list = new List<string>(new string[matches.Last()]);\n            for (int i = 1; i <= list.Count; i++)\n            {\n                var k1 = $\"header.text.{i}\";\n                var k2 = $\"headerpara{i}\";\n                if (!kv.TryGetValue(k1, out var v))\n                    kv.TryGetValue(k2, out v);\n                list[i - 1] = v ?? string.Empty;\n            }\n\n            return list;\n        }\n\n        private static IReadOnlyDictionary<string, string> BuildButtonUrlParams(IDictionary<string, string> kv)\n        {\n            var map = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n            for (int pos = 1; pos <= 3; pos++)\n            {\n                var k1 = $\"button{pos}.url_param\";\n                var k2 = $\"buttonpara{pos}\";\n                if (kv.TryGetValue(k1, out var v1) && !string.IsNullOrWhiteSpace(v1))\n                    map[k1] = v1;\n                else if (kv.TryGetValue(k2, out var v2) && !string.IsNullOrWhiteSpace(v2))\n                    map[k1] = v2;\n            }\n            return map;\n        }\n\n        // ======================================================================\n        //  SEND METHODS (kept from your file; minor tidy + consistent responses)\n        // ======================================================================\n\n        public async Task<ResponseResult> SendTemplateMessageAsync(SendMessageDto dto)\n        {\n            try\n            {\n                Console.WriteLine($\"üì® Sending template message to {dto.RecipientNumber} via BusinessId {dto.BusinessId}\");\n\n                if (dto.MessageType != MessageTypeEnum.Template)\n                    return ResponseResult.ErrorInfo(\"Only template messages are supported in this method.\");\n\n                // strict provider check at API surface\n                if (string.IsNullOrWhiteSpace(dto.Provider) ||\n                    (dto.Provider != \"PINNACLE\" && dto.Provider != \"META_CLOUD\"))\n                {\n                    return ResponseResult.ErrorInfo(\"‚ùå Invalid provider.\",\n                        \"Provider must be exactly 'PINNACLE' or 'META_CLOUD'.\");\n                }\n\n                var consentBlock = await EnforceOutboundConsentGuardAsync(dto.BusinessId, dto.RecipientNumber);\n                if (consentBlock != null) return consentBlock;\n\n                // Quota\n                var quotaCheck = await _planManager.CheckQuotaBeforeSendingAsync(dto.BusinessId);\n                if (!quotaCheck.Success) return quotaCheck;\n\n                // Build components (body only here)\n                var bodyParams = (dto.TemplateParameters?.Values?.ToList() ?? new List<string>())\n                    .Select(p => new { type = \"text\", text = p })\n                    .ToArray();\n\n                var components = new List<object>();\n                if (bodyParams.Length > 0)\n                    components.Add(new { type = \"body\", parameters = bodyParams });\n\n                // Send via provider\n                var sendResult = await SendViaProviderAsync(\n                    dto.BusinessId,\n                    dto.Provider,\n                    p => p.SendTemplateAsync(dto.RecipientNumber, dto.TemplateName!, \"en_US\", components),\n                    dto.PhoneNumberId\n                );\n\n                // Rendered body (for logs)\n                var resolvedBody = TemplateParameterHelper.FillPlaceholders(\n                    dto.TemplateBody ?? \"\",\n                    dto.TemplateParameters?.Values.ToList() ?? new List<string>());\n\n                // Log result\n                var log = new MessageLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = dto.BusinessId,\n                    RecipientNumber = dto.RecipientNumber,\n                    MessageContent = dto.TemplateName ?? \"N/A\",\n                    RenderedBody = resolvedBody,\n                    MediaUrl = null,\n                    Status = sendResult.Success ? \"Sent\" : \"Failed\",\n                    ErrorMessage = sendResult.Success ? null : sendResult.Message,\n                    RawResponse = sendResult.RawResponse,\n                    MessageId = sendResult.MessageId,\n                    CreatedAt = DateTime.UtcNow,\n                    SentAt = DateTime.UtcNow,\n                    CTAFlowConfigId = dto.CTAFlowConfigId,\n                    CTAFlowStepId = dto.CTAFlowStepId,\n                };\n\n                await _db.MessageLogs.AddAsync(log);\n                var planInfo = await _db.BusinessPlanInfos.FirstOrDefaultAsync(p => p.BusinessId == dto.BusinessId);\n                if (planInfo != null && planInfo.RemainingMessages > 0)\n                {\n                    planInfo.RemainingMessages -= 1;\n                    planInfo.UpdatedAt = DateTime.UtcNow;\n                }\n                await _db.SaveChangesAsync();\n\n                // SignalR push\n                await _hubContext.Clients\n                    .Group($\"business_{dto.BusinessId}\")\n                    .SendAsync(\"ReceiveMessage\", new\n                    {\n                        Id = log.Id,\n                        RecipientNumber = log.RecipientNumber,\n                        MessageContent = log.RenderedBody,\n                        MediaUrl = log.MediaUrl,\n                        Status = log.Status,\n                        CreatedAt = log.CreatedAt,\n                        SentAt = log.SentAt\n                    });\n\n                return ResponseResult.SuccessInfo(\"‚úÖ Template message sent successfully.\", sendResult, log.RawResponse);\n            }\n            catch (Exception ex)\n            {\n                var errorId = Guid.NewGuid();\n                Console.WriteLine($\"üß® Error ID: {errorId}\\n{ex}\");\n\n                await _db.MessageLogs.AddAsync(new MessageLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = dto.BusinessId,\n                    RecipientNumber = dto.RecipientNumber,\n                    MessageContent = dto.TemplateName ?? \"N/A\",\n                    RenderedBody = TemplateParameterHelper.FillPlaceholders(\n                        dto.TemplateBody ?? \"\",\n                        dto.TemplateParameters?.Values.ToList() ?? new List<string>()),\n                    Status = \"Failed\",\n                    ErrorMessage = ex.Message,\n                    RawResponse = ex.ToString(),\n                    CreatedAt = DateTime.UtcNow\n                });\n\n                await _db.SaveChangesAsync();\n\n                return ResponseResult.ErrorInfo(\n                    $\"‚ùå Exception occurred while sending template message. [Ref: {errorId}]\",\n                    ex.ToString());\n            }\n        }\n        [Obsolete(\"Use outbox + SendPayloadAsync via worker.\")]\n        public async Task<ResponseResult> SendVideoTemplateMessageAsync(VideoTemplateMessageDto dto, Guid businessId)\n        {\n            try\n            {\n                var provider = (dto.Provider ?? \"META_CLOUD\").Trim().ToUpperInvariant();\n                if (provider != \"PINNACLE\" && provider != \"META_CLOUD\")\n                    return ResponseResult.ErrorInfo(\"‚ùå Invalid provider.\", \"Provider must be exactly 'PINNACLE' or 'META_CLOUD'.\");\n\n                if (string.IsNullOrWhiteSpace(dto.RecipientNumber))\n                    return ResponseResult.ErrorInfo(\"‚ùå Missing recipient number.\");\n                if (string.IsNullOrWhiteSpace(dto.TemplateName))\n                    return ResponseResult.ErrorInfo(\"‚ùå Missing template name.\");\n                if (string.IsNullOrWhiteSpace(dto.HeaderVideoUrl))\n                    return ResponseResult.ErrorInfo(\"üö´ Missing HeaderVideoUrl (must be a direct HTTPS link to a video file).\");\n\n                var langCode = string.IsNullOrWhiteSpace(dto.LanguageCode) ? \"en_US\" : dto.LanguageCode!.Trim();\n\n                // components: header video + body + optional buttons\n                var components = new List<object>\n                {\n                    new\n                    {\n                        type = \"header\",\n                        parameters = new object[]\n                        {\n                            new { type = \"video\", video = new { link = dto.HeaderVideoUrl! } }\n                        }\n                    }\n                };\n\n                var bodyParams = (dto.TemplateParameters ?? new List<string>())\n                    .Select(p => new { type = \"text\", text = p })\n                    .ToArray();\n\n                components.Add(new { type = \"body\", parameters = bodyParams });\n\n                var btns = (dto.ButtonParameters ?? new List<CampaignButtonDto>()).Take(3).ToList();\n                for (int i = 0; i < btns.Count; i++)\n                {\n                    var b = btns[i];\n                    var sub = (b.ButtonType ?? \"\").Trim().ToLowerInvariant();\n                    if (string.IsNullOrEmpty(sub)) continue;\n\n                    var button = new Dictionary<string, object>\n                    {\n                        [\"type\"] = \"button\",\n                        [\"sub_type\"] = sub,\n                        [\"index\"] = i.ToString()\n                    };\n\n                    if (sub == \"url\" && !string.IsNullOrWhiteSpace(b.TargetUrl))\n                        button[\"parameters\"] = new object[] { new { type = \"text\", text = b.TargetUrl! } };\n                    else if (sub == \"quick_reply\" && !string.IsNullOrWhiteSpace(b.TargetUrl))\n                        button[\"parameters\"] = new object[] { new { type = \"payload\", payload = b.TargetUrl! } };\n\n                    components.Add(button);\n                }\n\n                // full payload object for WhatsApp template\n                var payload = new\n                {\n                    messaging_product = \"whatsapp\",\n                    to = dto.RecipientNumber!,\n                    type = \"template\",\n                    template = new\n                    {\n                        name = dto.TemplateName!,\n                        language = new { code = langCode },\n                        components = components\n                    }\n                };\n\n                var sendResult = await SendPayloadAsync(businessId, provider, payload, dto.PhoneNumberId);\n\n                var renderedBody = TemplateParameterHelper.FillPlaceholders(\n                    dto.TemplateBody ?? \"\",\n                    dto.TemplateParameters ?? new List<string>());\n\n                var log = new MessageLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    RecipientNumber = dto.RecipientNumber!,\n                    MessageContent = dto.TemplateName!,\n                    MediaUrl = dto.HeaderVideoUrl,\n                    RenderedBody = renderedBody,\n                    Status = sendResult.Success ? \"Sent\" : \"Failed\",\n                    ErrorMessage = sendResult.ErrorMessage ?? (sendResult.Success ? null : \"WhatsApp API returned an error.\"),\n                    RawResponse = sendResult.RawResponse,\n                    MessageId = sendResult.MessageId,\n                    SentAt = DateTime.UtcNow,\n                    CreatedAt = DateTime.UtcNow,\n                    CTAFlowConfigId = dto.CTAFlowConfigId,\n                    CTAFlowStepId = dto.CTAFlowStepId\n                };\n\n                await _db.MessageLogs.AddAsync(log);\n                await _db.SaveChangesAsync();\n\n                return new ResponseResult\n                {\n                    Success = sendResult.Success,\n                    Message = sendResult.Success ? \"‚úÖ Template sent successfully.\" : (sendResult.ErrorMessage ?? \"‚ùå WhatsApp API returned an error.\"),\n                    Data = new { Success = sendResult.Success, MessageId = sendResult.MessageId, LogId = log.Id },\n                    RawResponse = sendResult.RawResponse,\n                    MessageId = sendResult.MessageId,\n                    LogId = log.Id\n                };\n            }\n            catch (Exception ex)\n            {\n                try\n                {\n                    await _db.MessageLogs.AddAsync(new MessageLog\n                    {\n                        Id = Guid.NewGuid(),\n                        BusinessId = businessId,\n                        RecipientNumber = dto.RecipientNumber ?? \"\",\n                        MessageContent = dto.TemplateName ?? \"\",\n                        RenderedBody = TemplateParameterHelper.FillPlaceholders(dto.TemplateBody ?? \"\", dto.TemplateParameters ?? new List<string>()),\n                        MediaUrl = dto.HeaderVideoUrl,\n                        Status = \"Failed\",\n                        ErrorMessage = ex.Message,\n                        CreatedAt = DateTime.UtcNow,\n                        CTAFlowConfigId = dto.CTAFlowConfigId,\n                        CTAFlowStepId = dto.CTAFlowStepId\n                    });\n                    await _db.SaveChangesAsync();\n                }\n                catch { /* ignore */ }\n\n                return ResponseResult.ErrorInfo(\"‚ùå Template send failed\", ex.Message);\n            }\n        }\n\n        public async Task<ResponseResult> SendTextDirectAsync(TextMessageSendDto dto)\n        {\n            try\n            {\n                var businessId = _httpContextAccessor.HttpContext?.User?.GetBusinessId()\n                    ?? throw new UnauthorizedAccessException(\"‚ùå Cannot resolve BusinessId from context.\");\n\n                // Normalize inbound intent\n                string? providerUpper = string.IsNullOrWhiteSpace(dto.Provider)\n                    ? null\n                    : dto.Provider!.Trim().ToUpperInvariant();\n                string? providerKey = providerUpper?.ToLowerInvariant();\n                string? phoneNumberId = string.IsNullOrWhiteSpace(dto.PhoneNumberId) ? null : dto.PhoneNumberId!.Trim();\n\n                // Derive provider/sender from default phone row if needed\n                if (string.IsNullOrWhiteSpace(providerUpper))\n                {\n                    var defaultPhone = await _db.WhatsAppPhoneNumbers\n                        .AsNoTracking()\n                        .Where(n => n.BusinessId == businessId && n.IsActive)\n                        .OrderByDescending(n => n.IsDefault)\n                        .ThenByDescending(n => n.UpdatedAt ?? n.CreatedAt)\n                        .Select(n => new { n.Provider, n.PhoneNumberId })\n                        .FirstOrDefaultAsync();\n\n                    if (defaultPhone == null)\n                    {\n                        var anySetting = await _db.WhatsAppSettings\n                            .AsNoTracking()\n                            .Where(s => s.BusinessId == businessId && s.IsActive)\n                            .OrderByDescending(s => s.UpdatedAt ?? s.CreatedAt)\n                            .Select(s => s.Provider)\n                            .FirstOrDefaultAsync();\n\n                        if (string.IsNullOrWhiteSpace(anySetting))\n                            return ResponseResult.ErrorInfo(\"‚ùå WhatsApp configuration not found (no active numbers or settings).\");\n\n                        providerUpper = anySetting.Trim().ToUpperInvariant();\n                        providerKey = providerUpper.ToLowerInvariant();\n                    }\n                    else\n                    {\n                        providerUpper = (defaultPhone.Provider ?? string.Empty).Trim().ToUpperInvariant();\n                        providerKey = providerUpper.ToLowerInvariant();\n                        if (string.IsNullOrWhiteSpace(phoneNumberId))\n                            phoneNumberId = defaultPhone.PhoneNumberId;\n                    }\n                }\n\n                if (providerUpper != \"PINNACLE\" && providerUpper != \"META_CLOUD\")\n                    return ResponseResult.ErrorInfo(\"‚ùå Invalid provider. Must be 'PINNACLE' or 'META_CLOUD'.\");\n\n                if (string.IsNullOrWhiteSpace(phoneNumberId))\n                {\n                    var phoneRow = await _db.WhatsAppPhoneNumbers\n                        .AsNoTracking()\n                        .Where(n => n.BusinessId == businessId\n                                    && n.IsActive\n                                    && n.Provider.ToLower() == providerKey)\n                        .OrderByDescending(n => n.IsDefault)\n                        .ThenByDescending(n => n.UpdatedAt ?? n.CreatedAt)\n                        .Select(n => n.PhoneNumberId)\n                        .FirstOrDefaultAsync();\n\n                    if (!string.IsNullOrWhiteSpace(phoneRow))\n                        phoneNumberId = phoneRow;\n                }\n\n                if (providerUpper == \"META_CLOUD\" && string.IsNullOrWhiteSpace(phoneNumberId))\n                    return ResponseResult.ErrorInfo(\"‚ùå Missing PhoneNumberId for META_CLOUD. Configure a default sender or pass PhoneNumberId.\");\n\n                var chosenSetting = await _db.WhatsAppSettings\n                    .AsNoTracking()\n                    .Where(s => s.BusinessId == businessId\n                                && s.IsActive\n                                && s.Provider.ToLower() == providerKey)\n                    .OrderByDescending(s => s.UpdatedAt ?? s.CreatedAt)\n                    .FirstOrDefaultAsync();\n\n                if (chosenSetting == null)\n                    return ResponseResult.ErrorInfo(\"‚ùå WhatsApp settings row not found for the selected provider.\");\n\n                // Contact upsert/touch\n                Guid? contactId = null;\n\n                var recipientRaw = (dto.RecipientNumber ?? string.Empty).Trim();\n                var recipientDigits = PhoneNumberNormalizer.NormalizeToE164Digits(recipientRaw, \"IN\");\n                if (string.IsNullOrWhiteSpace(recipientDigits))\n                    return ResponseResult.ErrorInfo(\"? Invalid recipient number.\", $\"Invalid/unsupported phone: '{recipientRaw}'\");\n\n                var consentBlock = await EnforceOutboundConsentGuardAsync(businessId, recipientDigits);\n                if (consentBlock != null) return consentBlock;\n\n                // Canonical lookup: digits-only E.164 (no '+')\n                var contact = await _db.Contacts.FirstOrDefaultAsync(c =>\n                    c.BusinessId == businessId &&\n                    c.PhoneNumber == recipientDigits);\n\n                if (contact != null)\n                {\n                    contactId = contact.Id;\n                    contact.LastContactedAt = DateTime.UtcNow;\n\n                    // If caller wants to save and provided a better name, backfill placeholders only.\n                    if (dto.IsSaveContact && !string.IsNullOrWhiteSpace(dto.ContactName))\n                    {\n                        var preferredName = dto.ContactName.Trim();\n                        if (!string.IsNullOrWhiteSpace(preferredName) &&\n                            (string.IsNullOrWhiteSpace(contact.Name) ||\n                             contact.Name == \"WhatsApp User\" ||\n                             contact.Name == contact.PhoneNumber))\n                        {\n                            contact.Name = preferredName;\n                        }\n                    }\n                }\n                else if (dto.IsSaveContact)\n                {\n                    var preferredName = string.IsNullOrWhiteSpace(dto.ContactName)\n                        ? null\n                        : dto.ContactName.Trim();\n\n                    contact = new Contact\n                    {\n                        Id = Guid.NewGuid(),\n                        BusinessId = businessId,\n                        Name = preferredName ?? \"WhatsApp User\",\n                        PhoneNumber = recipientDigits,\n                        CreatedAt = DateTime.UtcNow,\n                        LastContactedAt = DateTime.UtcNow\n                    };\n                    _db.Contacts.Add(contact);\n                    contactId = contact.Id;\n                }\n\n                await _db.SaveChangesAsync();\n\n                // Send\n                var sendResult = await SendViaProviderAsync(\n                    businessId,\n                    providerUpper!,\n                    p => p.SendTextAsync(recipientDigits, dto.TextContent),\n                    phoneNumberId\n                );\n\n                // Extract provider message id if missing\n                string? messageId = sendResult.MessageId;\n                if (string.IsNullOrWhiteSpace(messageId) && !string.IsNullOrWhiteSpace(sendResult.RawResponse))\n                {\n                    try\n                    {\n                        var raw = sendResult.RawResponse!.TrimStart();\n                        if (raw.StartsWith(\"{\"))\n                        {\n                            using var parsed = JsonDocument.Parse(raw);\n                            if (parsed.RootElement.TryGetProperty(\"messages\", out var msgs)\n                                && msgs.ValueKind == JsonValueKind.Array\n                                && msgs.GetArrayLength() > 0\n                                && msgs[0].TryGetProperty(\"id\", out var idProp))\n                            {\n                                messageId = idProp.GetString();\n                            }\n                        }\n                    }\n                    catch { /* ignore parse issues */ }\n                }\n\n                // Log\n                var log = new MessageLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    RecipientNumber = recipientDigits,\n                    MessageContent = dto.TextContent,\n                    RenderedBody = dto.TextContent,\n                    ContactId = contactId,\n                    MediaUrl = null,\n                    Status = sendResult.Success ? \"Sent\" : \"Failed\",\n                    ErrorMessage = sendResult.Success ? null : sendResult.Message,\n                    RawResponse = sendResult.RawResponse,\n                    CreatedAt = DateTime.UtcNow,\n                    SentAt = DateTime.UtcNow,\n                    MessageId = messageId,\n                    ProviderMessageId = messageId\n                };\n\n                await _db.MessageLogs.AddAsync(log);\n                await _db.SaveChangesAsync();\n\n                // Optional campaign mapping\n                Guid? campaignSendLogId = null;\n                if (dto.Source == \"campaign\" && !string.IsNullOrEmpty(messageId))\n                {\n                    try { campaignSendLogId = await _messageIdResolver.ResolveCampaignSendLogIdAsync(messageId); }\n                    catch { /* non-fatal */ }\n                }\n\n                return new ResponseResult\n                {\n                    Success = sendResult.Success,\n                    Message = sendResult.Success\n                        ? \"‚úÖ Text message sent successfully.\"\n                        : (sendResult.Message ?? \"‚ùå WhatsApp API returned an error.\"),\n                    Data = new\n                    {\n                        Success = sendResult.Success,\n                        MessageId = messageId,\n                        LogId = log.Id,\n                        CampaignSendLogId = campaignSendLogId\n                    },\n                    RawResponse = sendResult.RawResponse,\n                    MessageId = messageId,\n                    LogId = log.Id\n                };\n            }\n            catch (Exception ex)\n            {\n                try\n                {\n                    var businessId = _httpContextAccessor.HttpContext?.User?.GetBusinessId();\n                    if (businessId != null)\n                    {\n                        await _db.MessageLogs.AddAsync(new MessageLog\n                        {\n                            Id = Guid.NewGuid(),\n                            BusinessId = businessId.Value,\n                            RecipientNumber = dto.RecipientNumber,\n                            MessageContent = dto.TextContent,\n                            Status = \"Failed\",\n                            ErrorMessage = ex.Message,\n                            CreatedAt = DateTime.UtcNow\n                        });\n                        await _db.SaveChangesAsync();\n                    }\n                }\n                catch { /* ignore */ }\n\n                return ResponseResult.ErrorInfo(\"‚ùå Failed to send text message.\", ex.ToString());\n            }\n        }\n\n        public Task<ResponseResult> SendImageDirectAsync(MediaMessageSendDto dto)\n            => SendMediaDirectAsync(dto, mediaType: \"image\");\n\n        public Task<ResponseResult> SendDocumentDirectAsync(MediaMessageSendDto dto)\n            => SendMediaDirectAsync(dto, mediaType: \"document\");\n\n        public Task<ResponseResult> SendVideoDirectAsync(MediaMessageSendDto dto)\n            => SendMediaDirectAsync(dto, mediaType: \"video\");\n\n        public Task<ResponseResult> SendAudioDirectAsync(MediaMessageSendDto dto)\n            => SendMediaDirectAsync(dto, mediaType: \"audio\");\n\n        private async Task<ResponseResult> SendMediaDirectAsync(MediaMessageSendDto dto, string mediaType)\n        {\n            try\n            {\n                var businessId = _httpContextAccessor.HttpContext?.User?.GetBusinessId()\n                    ?? throw new UnauthorizedAccessException(\"? Cannot resolve BusinessId from context.\");\n\n                if (dto == null) throw new ArgumentNullException(nameof(dto));\n\n                var type = (mediaType ?? string.Empty).Trim().ToLowerInvariant();\n                if (type is not (\"image\" or \"document\" or \"video\" or \"audio\"))\n                    return ResponseResult.ErrorInfo(\"? Invalid media type.\", \"Media type must be 'image', 'document', 'video', or 'audio'.\");\n\n                var recipientRaw = (dto.RecipientNumber ?? string.Empty).Trim();\n                var recipientDigits = PhoneNumberNormalizer.NormalizeToE164Digits(recipientRaw, \"IN\");\n                if (string.IsNullOrWhiteSpace(recipientDigits))\n                    return ResponseResult.ErrorInfo(\"? Invalid recipient number.\", $\"Invalid/unsupported phone: '{recipientRaw}'\");\n\n                var consentBlock = await EnforceOutboundConsentGuardAsync(businessId, recipientDigits);\n                if (consentBlock != null) return consentBlock;\n\n                var mediaId = (dto.MediaId ?? string.Empty).Trim();\n                if (string.IsNullOrWhiteSpace(mediaId))\n                    return ResponseResult.ErrorInfo(\"? Missing media id.\", \"mediaId is required.\");\n\n                // Normalize provider + resolve phone_number_id similarly to SendTextDirectAsync\n                string? providerUpper = string.IsNullOrWhiteSpace(dto.Provider)\n                    ? null\n                    : dto.Provider!.Trim().ToUpperInvariant();\n                string? providerKey = providerUpper?.ToLowerInvariant();\n                string? phoneNumberId = string.IsNullOrWhiteSpace(dto.PhoneNumberId) ? null : dto.PhoneNumberId!.Trim();\n\n                if (string.IsNullOrWhiteSpace(providerUpper))\n                {\n                    var defaultPhone = await _db.WhatsAppPhoneNumbers\n                        .AsNoTracking()\n                        .Where(n => n.BusinessId == businessId && n.IsActive)\n                        .OrderByDescending(n => n.IsDefault)\n                        .ThenByDescending(n => n.UpdatedAt ?? n.CreatedAt)\n                        .Select(n => new { n.Provider, n.PhoneNumberId })\n                        .FirstOrDefaultAsync();\n\n                    if (defaultPhone == null)\n                    {\n                        var anySetting = await _db.WhatsAppSettings\n                            .AsNoTracking()\n                            .Where(s => s.BusinessId == businessId && s.IsActive)\n                            .OrderByDescending(s => s.UpdatedAt ?? s.CreatedAt)\n                            .Select(s => s.Provider)\n                            .FirstOrDefaultAsync();\n\n                        if (string.IsNullOrWhiteSpace(anySetting))\n                            return ResponseResult.ErrorInfo(\"? WhatsApp configuration not found (no active numbers or settings).\");\n\n                        providerUpper = anySetting.Trim().ToUpperInvariant();\n                        providerKey = providerUpper.ToLowerInvariant();\n                    }\n                    else\n                    {\n                        providerUpper = (defaultPhone.Provider ?? string.Empty).Trim().ToUpperInvariant();\n                        providerKey = providerUpper.ToLowerInvariant();\n                        if (string.IsNullOrWhiteSpace(phoneNumberId))\n                            phoneNumberId = defaultPhone.PhoneNumberId;\n                    }\n                }\n\n                if (providerUpper != \"META_CLOUD\")\n                    return ResponseResult.ErrorInfo(\"? Unsupported provider for Inbox media.\", \"Inbox media is supported only for META_CLOUD.\");\n\n                if (string.IsNullOrWhiteSpace(phoneNumberId))\n                {\n                    var phoneRow = await _db.WhatsAppPhoneNumbers\n                        .AsNoTracking()\n                        .Where(n => n.BusinessId == businessId\n                                    && n.IsActive\n                                    && n.Provider.ToLower() == providerKey)\n                        .OrderByDescending(n => n.IsDefault)\n                        .ThenByDescending(n => n.UpdatedAt ?? n.CreatedAt)\n                        .Select(n => n.PhoneNumberId)\n                        .FirstOrDefaultAsync();\n\n                    if (!string.IsNullOrWhiteSpace(phoneRow))\n                        phoneNumberId = phoneRow;\n                }\n\n                if (string.IsNullOrWhiteSpace(phoneNumberId))\n                    return ResponseResult.ErrorInfo(\"? Missing PhoneNumberId for META_CLOUD. Configure a default sender or pass PhoneNumberId.\");\n\n                Guid? contactId = dto.ContactId != Guid.Empty ? dto.ContactId : null;\n                if (!contactId.HasValue)\n                {\n                    var contact = await _db.Contacts.FirstOrDefaultAsync(c =>\n                        c.BusinessId == businessId &&\n                        c.PhoneNumber == recipientDigits);\n                    contactId = contact?.Id;\n                }\n\n                var caption = string.IsNullOrWhiteSpace(dto.Caption) ? null : dto.Caption.Trim();\n                if (type == \"audio\" && !string.IsNullOrWhiteSpace(caption))\n                    return ResponseResult.ErrorInfo(\"? Audio does not support captions.\", \"Remove Caption/Text when sending an audio message.\");\n\n                object payload = type switch\n                {\n                    \"image\" => new\n                    {\n                        messaging_product = \"whatsapp\",\n                        to = recipientDigits,\n                        type = \"image\",\n                        image = new { id = mediaId, caption }\n                    },\n                    \"document\" => new\n                    {\n                        messaging_product = \"whatsapp\",\n                        to = recipientDigits,\n                        type = \"document\",\n                        document = new { id = mediaId, caption, filename = dto.FileName }\n                    },\n                    \"video\" => new\n                    {\n                        messaging_product = \"whatsapp\",\n                        to = recipientDigits,\n                        type = \"video\",\n                        video = new { id = mediaId, caption }\n                    },\n                    \"audio\" => new\n                    {\n                        messaging_product = \"whatsapp\",\n                        to = recipientDigits,\n                        type = \"audio\",\n                        audio = new { id = mediaId }\n                    },\n                    _ => throw new InvalidOperationException(\"Unsupported media type.\")\n                };\n\n                var sendResult = await SendViaProviderAsync(\n                    businessId,\n                    providerUpper!,\n                    p => p.SendInteractiveAsync(payload),\n                    phoneNumberId\n                );\n\n                string? messageId = sendResult.MessageId;\n                if (string.IsNullOrWhiteSpace(messageId) && !string.IsNullOrWhiteSpace(sendResult.RawResponse))\n                {\n                    try\n                    {\n                        var raw = sendResult.RawResponse!.TrimStart();\n                        if (raw.StartsWith(\"{\"))\n                        {\n                            using var parsed = JsonDocument.Parse(raw);\n                            if (parsed.RootElement.TryGetProperty(\"messages\", out var msgs)\n                                && msgs.ValueKind == JsonValueKind.Array\n                                && msgs.GetArrayLength() > 0\n                                && msgs[0].TryGetProperty(\"id\", out var idProp))\n                            {\n                                messageId = idProp.GetString();\n                            }\n                        }\n                    }\n                    catch { /* ignore parse issues */ }\n                }\n\n                var rendered =\n                    string.IsNullOrWhiteSpace(caption)\n                        ? type switch\n                        {\n                            \"image\" => string.IsNullOrWhiteSpace(dto.FileName) ? \"Image sent\" : $\"Image sent: {dto.FileName}\",\n                            \"document\" => string.IsNullOrWhiteSpace(dto.FileName) ? \"PDF sent\" : $\"PDF sent: {dto.FileName}\",\n                            \"video\" => string.IsNullOrWhiteSpace(dto.FileName) ? \"Video sent\" : $\"Video sent: {dto.FileName}\",\n                            \"audio\" => string.IsNullOrWhiteSpace(dto.FileName) ? \"Audio sent\" : $\"Audio sent: {dto.FileName}\",\n                            _ => \"Media sent\"\n                        }\n                        : caption!;\n\n                var log = new MessageLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    RecipientNumber = recipientDigits,\n                    MessageContent = rendered,\n                    RenderedBody = rendered,\n                    ContactId = contactId,\n                    MediaUrl = null,\n                    MediaId = mediaId,\n                    MediaType = type,\n                    FileName = dto.FileName,\n                    MimeType = dto.MimeType,\n                    Status = sendResult.Success ? \"Sent\" : \"Failed\",\n                    ErrorMessage = sendResult.Success ? null : sendResult.Message,\n                    RawResponse = sendResult.RawResponse,\n                    CreatedAt = DateTime.UtcNow,\n                    SentAt = DateTime.UtcNow,\n                    MessageId = messageId,\n                    ProviderMessageId = messageId,\n                    Source = dto.Source\n                };\n\n                await _db.MessageLogs.AddAsync(log);\n                await _db.SaveChangesAsync();\n\n                return new ResponseResult\n                {\n                    Success = sendResult.Success,\n                    Message = sendResult.Success\n                        ? \"? Media message sent successfully.\"\n                        : (sendResult.Message ?? \"? WhatsApp API returned an error.\"),\n                    Data = new\n                    {\n                        Success = sendResult.Success,\n                        MessageId = messageId,\n                        LogId = log.Id\n                    },\n                    RawResponse = sendResult.RawResponse,\n                    MessageId = messageId,\n                    LogId = log.Id\n                };\n            }\n            catch (Exception ex)\n            {\n                return ResponseResult.ErrorInfo(\"? Failed to send media message.\", ex.ToString());\n            }\n        }\n\n        public async Task<ResponseResult> SendLocationDirectAsync(LocationMessageSendDto dto)\n        {\n            try\n            {\n                var businessId = _httpContextAccessor.HttpContext?.User?.GetBusinessId()\n                    ?? throw new UnauthorizedAccessException(\"? Cannot resolve BusinessId from context.\");\n\n                if (dto == null) throw new ArgumentNullException(nameof(dto));\n\n                if (dto.Latitude < -90 || dto.Latitude > 90)\n                    return ResponseResult.ErrorInfo(\"? Invalid latitude.\", \"Latitude must be between -90 and 90.\");\n                if (dto.Longitude < -180 || dto.Longitude > 180)\n                    return ResponseResult.ErrorInfo(\"? Invalid longitude.\", \"Longitude must be between -180 and 180.\");\n\n                var recipientRaw = (dto.RecipientNumber ?? string.Empty).Trim();\n                var recipientDigits = PhoneNumberNormalizer.NormalizeToE164Digits(recipientRaw, \"IN\");\n                if (string.IsNullOrWhiteSpace(recipientDigits))\n                    return ResponseResult.ErrorInfo(\"? Invalid recipient number.\", $\"Invalid/unsupported phone: '{recipientRaw}'\");\n\n                var consentBlock = await EnforceOutboundConsentGuardAsync(businessId, recipientDigits);\n                if (consentBlock != null) return consentBlock;\n\n                string? providerUpper = string.IsNullOrWhiteSpace(dto.Provider)\n                    ? null\n                    : dto.Provider!.Trim().ToUpperInvariant();\n                string? providerKey = providerUpper?.ToLowerInvariant();\n                string? phoneNumberId = string.IsNullOrWhiteSpace(dto.PhoneNumberId) ? null : dto.PhoneNumberId!.Trim();\n\n                if (string.IsNullOrWhiteSpace(providerUpper))\n                {\n                    var defaultPhone = await _db.WhatsAppPhoneNumbers\n                        .AsNoTracking()\n                        .Where(n => n.BusinessId == businessId && n.IsActive)\n                        .OrderByDescending(n => n.IsDefault)\n                        .ThenByDescending(n => n.UpdatedAt ?? n.CreatedAt)\n                        .Select(n => new { n.Provider, n.PhoneNumberId })\n                        .FirstOrDefaultAsync();\n\n                    if (defaultPhone == null)\n                    {\n                        var anySetting = await _db.WhatsAppSettings\n                            .AsNoTracking()\n                            .Where(s => s.BusinessId == businessId && s.IsActive)\n                            .OrderByDescending(s => s.UpdatedAt ?? s.CreatedAt)\n                            .Select(s => s.Provider)\n                            .FirstOrDefaultAsync();\n\n                        if (string.IsNullOrWhiteSpace(anySetting))\n                            return ResponseResult.ErrorInfo(\"? WhatsApp configuration not found (no active numbers or settings).\");\n\n                        providerUpper = anySetting.Trim().ToUpperInvariant();\n                        providerKey = providerUpper.ToLowerInvariant();\n                    }\n                    else\n                    {\n                        providerUpper = (defaultPhone.Provider ?? string.Empty).Trim().ToUpperInvariant();\n                        providerKey = providerUpper.ToLowerInvariant();\n                        if (string.IsNullOrWhiteSpace(phoneNumberId))\n                            phoneNumberId = defaultPhone.PhoneNumberId;\n                    }\n                }\n\n                if (providerUpper != \"META_CLOUD\")\n                    return ResponseResult.ErrorInfo(\"? Unsupported provider for Inbox location.\", \"Inbox location is supported only for META_CLOUD.\");\n\n                if (string.IsNullOrWhiteSpace(phoneNumberId))\n                {\n                    var phoneRow = await _db.WhatsAppPhoneNumbers\n                        .AsNoTracking()\n                        .Where(n => n.BusinessId == businessId\n                                    && n.IsActive\n                                    && n.Provider.ToLower() == providerKey)\n                        .OrderByDescending(n => n.IsDefault)\n                        .ThenByDescending(n => n.UpdatedAt ?? n.CreatedAt)\n                        .Select(n => n.PhoneNumberId)\n                        .FirstOrDefaultAsync();\n\n                    if (!string.IsNullOrWhiteSpace(phoneRow))\n                        phoneNumberId = phoneRow;\n                }\n\n                if (string.IsNullOrWhiteSpace(phoneNumberId))\n                    return ResponseResult.ErrorInfo(\"? Missing PhoneNumberId for META_CLOUD. Configure a default sender or pass PhoneNumberId.\");\n\n                object payload = new\n                {\n                    messaging_product = \"whatsapp\",\n                    to = recipientDigits,\n                    type = \"location\",\n                    location = new\n                    {\n                        latitude = dto.Latitude,\n                        longitude = dto.Longitude,\n                        name = string.IsNullOrWhiteSpace(dto.Name) ? null : dto.Name.Trim(),\n                        address = string.IsNullOrWhiteSpace(dto.Address) ? null : dto.Address.Trim()\n                    }\n                };\n\n                var sendResult = await SendViaProviderAsync(\n                    businessId,\n                    providerUpper!,\n                    p => p.SendInteractiveAsync(payload),\n                    phoneNumberId\n                );\n\n                string? messageId = sendResult.MessageId;\n                if (string.IsNullOrWhiteSpace(messageId) && !string.IsNullOrWhiteSpace(sendResult.RawResponse))\n                {\n                    try\n                    {\n                        var raw = sendResult.RawResponse!.TrimStart();\n                        if (raw.StartsWith(\"{\"))\n                        {\n                            using var parsed = JsonDocument.Parse(raw);\n                            if (parsed.RootElement.TryGetProperty(\"messages\", out var msgs)\n                                && msgs.ValueKind == JsonValueKind.Array\n                                && msgs.GetArrayLength() > 0\n                                && msgs[0].TryGetProperty(\"id\", out var idProp))\n                            {\n                                messageId = idProp.GetString();\n                            }\n                        }\n                    }\n                    catch { /* ignore parse issues */ }\n                }\n\n                var rendered = string.IsNullOrWhiteSpace(dto.Name)\n                    ? \"Location sent\"\n                    : dto.Name!.Trim();\n\n                var log = new MessageLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    RecipientNumber = recipientDigits,\n                    MessageContent = rendered,\n                    RenderedBody = rendered,\n                    ContactId = dto.ContactId != Guid.Empty ? dto.ContactId : (Guid?)null,\n                    MediaUrl = null,\n                    MediaId = null,\n                    MediaType = \"location\",\n                    FileName = null,\n                    MimeType = null,\n                    LocationLatitude = dto.Latitude,\n                    LocationLongitude = dto.Longitude,\n                    LocationName = string.IsNullOrWhiteSpace(dto.Name) ? null : dto.Name.Trim(),\n                    LocationAddress = string.IsNullOrWhiteSpace(dto.Address) ? null : dto.Address.Trim(),\n                    Status = sendResult.Success ? \"Sent\" : \"Failed\",\n                    ErrorMessage = sendResult.Success ? null : sendResult.Message,\n                    RawResponse = sendResult.RawResponse,\n                    CreatedAt = DateTime.UtcNow,\n                    SentAt = DateTime.UtcNow,\n                    MessageId = messageId,\n                    ProviderMessageId = messageId,\n                    Source = dto.Source\n                };\n\n                await _db.MessageLogs.AddAsync(log);\n                await _db.SaveChangesAsync();\n\n                return new ResponseResult\n                {\n                    Success = sendResult.Success,\n                    Message = sendResult.Success\n                        ? \"? Location sent successfully.\"\n                        : (sendResult.Message ?? \"? WhatsApp API returned an error.\"),\n                    Data = new\n                    {\n                        Success = sendResult.Success,\n                        MessageId = messageId,\n                        LogId = log.Id\n                    },\n                    RawResponse = sendResult.RawResponse,\n                    MessageId = messageId,\n                    LogId = log.Id\n                };\n            }\n            catch (Exception ex)\n            {\n                return ResponseResult.ErrorInfo(\"? Failed to send location message.\", ex.ToString());\n            }\n        }\n\n        public async Task<ResponseResult> SendAutomationReply(TextMessageSendDto dto)\n        {\n            try\n            {\n                var businessId =\n                    dto.BusinessId != Guid.Empty\n                        ? dto.BusinessId\n                        : _httpContextAccessor.HttpContext?.User?.GetBusinessId()\n                          ?? throw new UnauthorizedAccessException(\"‚ùå Cannot resolve BusinessId from context or DTO.\");\n\n                if (string.IsNullOrWhiteSpace(dto.Provider) ||\n                    (dto.Provider != \"PINNACLE\" && dto.Provider != \"META_CLOUD\"))\n                {\n                    return ResponseResult.ErrorInfo(\"‚ùå Invalid provider.\",\n                        \"Provider must be exactly 'PINNACLE' or 'META_CLOUD'.\");\n                }\n\n                var consentBlock = await EnforceOutboundConsentGuardAsync(businessId, dto.RecipientNumber);\n                if (consentBlock != null) return consentBlock;\n\n                Guid? contactId = null;\n                try\n                {\n                    var contact = await _contactService.FindOrCreateAsync(businessId, dto.RecipientNumber);\n                    contactId = contact.Id;\n                }\n                catch (Exception ex)\n                {\n                    Console.WriteLine($\"‚ö†Ô∏è Failed to resolve or create contact: {ex.Message}\");\n                }\n\n                var sendResult = await SendViaProviderAsync(\n                    businessId,\n                    dto.Provider,\n                    p => p.SendTextAsync(dto.RecipientNumber, dto.TextContent),\n                    dto.PhoneNumberId\n                );\n\n                string? messageId = sendResult.MessageId;\n                var raw = sendResult.RawResponse;\n                if (string.IsNullOrWhiteSpace(messageId) && !string.IsNullOrWhiteSpace(raw))\n                {\n                    try\n                    {\n                        var s = raw.TrimStart();\n                        if (s.StartsWith(\"{\"))\n                        {\n                            using var parsed = JsonDocument.Parse(s);\n                            if (parsed.RootElement.TryGetProperty(\"messages\", out var messages) &&\n                                messages.ValueKind == JsonValueKind.Array &&\n                                messages.GetArrayLength() > 0 &&\n                                messages[0].TryGetProperty(\"id\", out var idProp))\n                            {\n                                messageId = idProp.GetString();\n                            }\n                        }\n                    }\n                    catch { /* ignore */ }\n                }\n\n                var log = new MessageLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    RecipientNumber = dto.RecipientNumber,\n                    MessageContent = dto.TextContent,\n                    RenderedBody = dto.TextContent,\n                    ContactId = contactId,\n                    MediaUrl = null,\n                    Status = sendResult.Success ? \"Sent\" : \"Failed\",\n                    ErrorMessage = sendResult.Success ? null : sendResult.Message,\n                    RawResponse = sendResult.RawResponse,\n                    CreatedAt = DateTime.UtcNow,\n                    SentAt = DateTime.UtcNow,\n                    MessageId = messageId\n                };\n\n                await _db.MessageLogs.AddAsync(log);\n                await _db.SaveChangesAsync();\n\n                Guid? campaignSendLogId = null;\n                if (dto.Source == \"campaign\" && !string.IsNullOrEmpty(messageId))\n                {\n                    try\n                    {\n                        campaignSendLogId = await _messageIdResolver.ResolveCampaignSendLogIdAsync(messageId);\n                        Console.WriteLine($\"üì¶ CampaignSendLog resolved: {campaignSendLogId}\");\n                    }\n                    catch (Exception ex)\n                    {\n                        Console.WriteLine($\"‚ö†Ô∏è Failed to resolve campaign log for {messageId}: {ex.Message}\");\n                    }\n                }\n\n                return new ResponseResult\n                {\n                    Success = sendResult.Success,\n                    Message = sendResult.Success\n                        ? \"‚úÖ Text message sent successfully.\"\n                        : (sendResult.Message ?? \"‚ùå WhatsApp API returned an error.\"),\n                    Data = new\n                    {\n                        Success = sendResult.Success,\n                        MessageId = messageId,\n                        LogId = log.Id,\n                        CampaignSendLogId = campaignSendLogId\n                    },\n                    RawResponse = sendResult.RawResponse,\n                    MessageId = messageId,\n                    LogId = log.Id\n                };\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"‚ùå Exception in SendAutomationReply: {ex.Message}\");\n\n                try\n                {\n                    var businessId =\n                        dto.BusinessId != Guid.Empty\n                            ? dto.BusinessId\n                            : _httpContextAccessor.HttpContext?.User?.GetBusinessId()\n                              ?? throw new UnauthorizedAccessException(\"‚ùå Cannot resolve BusinessId in failure path.\");\n\n                    await _db.MessageLogs.AddAsync(new MessageLog\n                    {\n                        Id = Guid.NewGuid(),\n                        BusinessId = businessId,\n                        RecipientNumber = dto.RecipientNumber,\n                        MessageContent = dto.TextContent,\n                        Status = \"Failed\",\n                        ErrorMessage = ex.Message,\n                        CreatedAt = DateTime.UtcNow\n                    });\n\n                    await _db.SaveChangesAsync();\n                }\n                catch { /* ignore log errors */ }\n\n                return ResponseResult.ErrorInfo(\"‚ùå Failed to send text message.\", ex.ToString());\n            }\n        }\n\n        /// <summary>\n        /// Sends a simple text auto-reply on behalf of a business.\n        /// This helper assumes Meta Cloud as the default provider and\n        /// uses the default active WhatsAppPhoneNumber to resolve PhoneNumberId.\n        /// Intended for AutoReplyBuilder / webhook runtime (no user context).\n        /// </summary>\n        public async Task<ResponseResult> SendAutoReplyTextAsync(\n       Guid businessId,\n       string recipientNumber,\n       string body,\n       CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty)\n            {\n                return ResponseResult.ErrorInfo(\n                    \"‚ùå Auto-reply failed.\",\n                    \"BusinessId is required.\");\n            }\n\n            if (string.IsNullOrWhiteSpace(recipientNumber))\n            {\n                return ResponseResult.ErrorInfo(\n                    \"‚ùå Auto-reply failed.\",\n                    \"Recipient phone number is required.\");\n            }\n\n            if (string.IsNullOrWhiteSpace(body))\n            {\n                return ResponseResult.ErrorInfo(\n                    \"‚ùå Auto-reply failed.\",\n                    \"Reply body is empty.\");\n            }\n\n            try\n            {\n                // 1) Normalize the recipient a bit (full E.164 normalization happens elsewhere)\n                var trimmedNumber = recipientNumber.Trim();\n\n                // 2) Load active WhatsApp settings for this business\n                var setting = await _db.WhatsAppSettings\n                    .AsNoTracking()\n                    .FirstOrDefaultAsync(s => s.BusinessId == businessId && s.IsActive, ct);\n\n                if (setting == null)\n                {\n                    _logger.LogWarning(\n                        \"‚ö†Ô∏è AutoReply: WhatsApp settings not found for BusinessId={BusinessId}.\",\n                        businessId);\n\n                    return ResponseResult.ErrorInfo(\n                        \"‚ùå Auto-reply failed.\",\n                        \"WhatsApp settings are not configured for this business.\");\n                }\n\n                var provider = (setting.Provider ?? string.Empty)\n                    .Trim()\n                    .ToUpperInvariant();\n\n                if (provider != \"META_CLOUD\" && provider != \"PINNACLE\")\n                {\n                    _logger.LogWarning(\n                        \"‚ö†Ô∏è AutoReply: Unsupported provider '{Provider}' for BusinessId={BusinessId}.\",\n                        provider,\n                        businessId);\n\n                    return ResponseResult.ErrorInfo(\n                        \"‚ùå Auto-reply failed.\",\n                        \"WhatsApp provider is not correctly configured for this business.\");\n                }\n\n                // 3) Resolve the default sender (PhoneNumberId) for this provider\n                var phone = await _db.WhatsAppPhoneNumbers\n                    .AsNoTracking()\n                    .Where(p => p.BusinessId == businessId\n                                && p.IsActive\n                                && p.Provider.ToLower() == provider.ToLower())\n                    .OrderByDescending(p => p.IsDefault)\n                    .ThenByDescending(p => p.UpdatedAt ?? p.CreatedAt)\n                    .Select(p => new { p.PhoneNumberId, p.WhatsAppBusinessNumber })\n                    .FirstOrDefaultAsync(ct);\n\n                string? phoneNumberId = phone?.PhoneNumberId;\n\n                if (provider == \"META_CLOUD\" && string.IsNullOrWhiteSpace(phoneNumberId))\n                {\n                    _logger.LogWarning(\n                        \"‚ö†Ô∏è AutoReply: No default PhoneNumberId configured for BusinessId={BusinessId}, Provider={Provider}.\",\n                        businessId,\n                        provider);\n\n                    return ResponseResult.ErrorInfo(\n                        \"‚ùå Auto-reply failed.\",\n                        \"No default WhatsApp sender number is configured for this business.\");\n                }\n\n                // 4) Build DTO for the core text sender\n                var dto = new TextMessageSendDto\n                {\n                    BusinessId = businessId,\n                    RecipientNumber = trimmedNumber,\n                    TextContent = body,\n                    Provider = provider,         // use provider from settings\n                    PhoneNumberId = phoneNumberId,\n                    Source = \"auto-reply\"\n                };\n\n                _logger.LogInformation(\n                    \"üì§ AutoReply: sending simple text reply for BusinessId={BusinessId}, Recipient={Recipient}, Preview={Preview}\",\n                    businessId,\n                    trimmedNumber,\n                    body.Length > 60 ? body.Substring(0, 60) + \"...\" : body);\n\n                // 5) Delegate to the existing pipeline (logs + OutboundMessageJob, etc.)\n                var result = await SendAutomationReply(dto);\n\n                if (!result.Success)\n                {\n                    _logger.LogWarning(\n                        \"‚ùå AutoReply: SendAutomationReply failed for BusinessId={BusinessId}, Recipient={Recipient}. Error={Error}\",\n                        businessId,\n                        trimmedNumber,\n                        result.Message);\n                }\n                else\n                {\n                    _logger.LogInformation(\n                        \"‚úÖ AutoReply: message sent successfully for BusinessId={BusinessId}, Recipient={Recipient}.\",\n                        businessId,\n                        trimmedNumber);\n                }\n\n                return result;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(\n                    ex,\n                    \"‚ùå AutoReply: unexpected exception while sending simple text reply for BusinessId={BusinessId}, Recipient={Recipient}.\",\n                    businessId,\n                    recipientNumber);\n\n                return ResponseResult.ErrorInfo(\n                    \"‚ùå Auto-reply failed due to an unexpected error.\",\n                    ex.Message);\n            }\n        }\n\n\n        /// <summary>\n        /// New overload for AutoReply that accepts a DeliveryMode.\n        /// Currently it delegates to the legacy implementation so\n        /// behaviour is unchanged. In the next steps we will route\n        /// Immediate vs Queued differently.\n        /// </summary>\n        public Task<ResponseResult> SendAutoReplyTextAsync(\n            Guid businessId,\n            string recipientNumber,\n            string body,\n            DeliveryMode mode,\n            CancellationToken ct = default)\n        {\n            // üîÅ Step 1: ignore mode, keep current behaviour.\n            return SendAutoReplyTextAsync(businessId, recipientNumber, body, ct);\n        }\n\n\n\n        #region SendTemplateMessageSimpleAsync Overload\n\n\n\n        //public async Task<ResponseResult> SendTemplateMessageSimpleAsync(Guid businessId, SimpleTemplateMessageDto dto)\n        //{\n        //    try\n        //    {\n        //        // Normalize inbound\n        //        string? providerUpper = string.IsNullOrWhiteSpace(dto.Provider)\n        //            ? null\n        //            : dto.Provider!.Trim().ToUpperInvariant();\n        //        string? providerKey = providerUpper?.ToLowerInvariant();\n        //        string? phoneNumberId = string.IsNullOrWhiteSpace(dto.PhoneNumberId)\n        //            ? null\n        //            : dto.PhoneNumberId!.Trim();\n\n        //        // Resolve missing provider/sender from WhatsAppPhoneNumbers\n        //        if (string.IsNullOrWhiteSpace(providerUpper))\n        //        {\n        //            var defPhone = await _db.WhatsAppPhoneNumbers\n        //                .AsNoTracking()\n        //                .Where(n => n.BusinessId == businessId && n.IsActive)\n        //                .OrderByDescending(n => n.IsDefault)\n        //                .ThenByDescending(n => n.UpdatedAt ?? n.CreatedAt)\n        //                .Select(n => new { n.Provider, n.PhoneNumberId })\n        //                .FirstOrDefaultAsync();\n\n        //            if (defPhone != null)\n        //            {\n        //                providerUpper = (defPhone.Provider ?? string.Empty).Trim().ToUpperInvariant();\n        //                providerKey = providerUpper.ToLowerInvariant();\n        //                if (string.IsNullOrWhiteSpace(phoneNumberId))\n        //                    phoneNumberId = defPhone.PhoneNumberId;\n        //            }\n        //        }\n\n        //        if (string.IsNullOrWhiteSpace(providerUpper))\n        //        {\n        //            var anySettingProvider = await _db.WhatsAppSettings\n        //                .AsNoTracking()\n        //                .Where(s => s.BusinessId == businessId && s.IsActive)\n        //                .OrderByDescending(s => s.UpdatedAt ?? s.CreatedAt)\n        //                .Select(s => s.Provider)\n        //                .FirstOrDefaultAsync();\n\n        //            if (!string.IsNullOrWhiteSpace(anySettingProvider))\n        //            {\n        //                providerUpper = anySettingProvider.Trim().ToUpperInvariant();\n        //                providerKey = providerUpper.ToLowerInvariant();\n        //            }\n        //        }\n\n        //        if (providerUpper != \"PINNACLE\" && providerUpper != \"META_CLOUD\")\n        //        {\n        //            return ResponseResult.ErrorInfo(\n        //                \"‚ùå Missing provider.\",\n        //                \"No active WhatsApp sender found. Configure a PINNACLE or META_CLOUD sender for this business.\"\n        //            );\n        //        }\n\n        //        if (string.IsNullOrWhiteSpace(phoneNumberId))\n        //        {\n        //            var pn = await _db.WhatsAppPhoneNumbers\n        //                .AsNoTracking()\n        //                .Where(n => n.BusinessId == businessId\n        //                            && n.IsActive\n        //                            && n.Provider.ToLower() == providerKey)\n        //                .OrderByDescending(n => n.IsDefault)\n        //                .ThenByDescending(n => n.UpdatedAt ?? n.CreatedAt)\n        //                .Select(n => n.PhoneNumberId)\n        //                .FirstOrDefaultAsync();\n\n        //            if (!string.IsNullOrWhiteSpace(pn))\n        //                phoneNumberId = pn;\n        //        }\n\n        //        if (providerUpper == \"META_CLOUD\" && string.IsNullOrWhiteSpace(phoneNumberId))\n        //            return ResponseResult.ErrorInfo(\"‚ùå Missing PhoneNumberId for META_CLOUD. Configure a default sender or pass PhoneNumberId.\");\n\n        //        // Build minimal components (body only)\n        //        var parameters = (dto.TemplateParameters ?? new List<string>())\n        //            .Select(p => new { type = \"text\", text = p })\n        //            .ToArray();\n\n        //        var components = new List<object>();\n        //        if (parameters.Length > 0)\n        //            components.Add(new { type = \"body\", parameters });\n\n        //        var lang = string.IsNullOrWhiteSpace(dto.LanguageCode) ? \"en_US\" : dto.LanguageCode!;\n        //        _logger?.LogInformation(\"‚û°Ô∏è SEND-INTENT tmpl={Template} to={To} provider={Provider} pnid={PhoneNumberId}\",\n        //            dto.TemplateName, dto.RecipientNumber, providerUpper, phoneNumberId ?? \"(default)\");\n\n        //        var sendResult = await SendViaProviderAsync(\n        //            businessId,\n        //            providerUpper,\n        //            p => p.SendTemplateAsync(dto.RecipientNumber, dto.TemplateName, lang, components),\n        //            phoneNumberId\n        //        );\n\n        //        var log = new MessageLog\n        //        {\n        //            Id = Guid.NewGuid(),\n        //            BusinessId = businessId,\n        //            RecipientNumber = dto.RecipientNumber,\n        //            MessageContent = dto.TemplateName,\n        //            RenderedBody = TemplateParameterHelper.FillPlaceholders(\n        //                dto.TemplateBody ?? string.Empty,\n        //                dto.TemplateParameters ?? new List<string>()),\n\n        //            CTAFlowConfigId = dto.CTAFlowConfigId,\n        //            CTAFlowStepId = dto.CTAFlowStepId,\n\n        //            Provider = providerUpper,\n        //            ProviderMessageId = sendResult.MessageId,\n\n        //            Status = sendResult.Success ? \"Sent\" : \"Failed\",\n        //            ErrorMessage = sendResult.Success ? null : sendResult.Message,\n        //            RawResponse = sendResult.RawResponse,\n        //            MessageId = sendResult.MessageId,\n        //            SentAt = sendResult.Success ? DateTime.UtcNow : (DateTime?)null,\n        //            CreatedAt = DateTime.UtcNow,\n        //            Source = \"api\"\n        //        };\n\n        //        await _db.MessageLogs.AddAsync(log);\n        //        await _db.SaveChangesAsync();\n\n        //        return new ResponseResult\n        //        {\n        //            Success = sendResult.Success,\n        //            Message = sendResult.Success\n        //                ? \"‚úÖ Template sent successfully.\"\n        //                : (sendResult.Message ?? \"‚ùå WhatsApp API returned an error.\"),\n        //            Data = new\n        //            {\n        //                Success = sendResult.Success,\n        //                MessageId = sendResult.MessageId,\n        //                LogId = log.Id\n        //            },\n        //            RawResponse = sendResult.RawResponse,\n        //            MessageId = sendResult.MessageId,\n        //            LogId = log.Id\n        //        };\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        try\n        //        {\n        //            await _db.MessageLogs.AddAsync(new MessageLog\n        //            {\n        //                Id = Guid.NewGuid(),\n        //                BusinessId = businessId,\n        //                RecipientNumber = dto.RecipientNumber,\n        //                MessageContent = dto.TemplateName,\n        //                RenderedBody = TemplateParameterHelper.FillPlaceholders(\n        //                    dto.TemplateBody ?? string.Empty,\n        //                    dto.TemplateParameters ?? new List<string>()),\n        //                Status = \"Failed\",\n        //                ErrorMessage = ex.Message,\n        //                CreatedAt = DateTime.UtcNow,\n        //                Source = \"api\"\n        //            });\n        //            await _db.SaveChangesAsync();\n        //        }\n        //        catch { /* ignore */ }\n\n        //        return ResponseResult.ErrorInfo(\"‚ùå Template send failed\", ex.Message);\n        //    }\n        //}\n        ///// <summary>\n        ///// New overload that is aware of DeliveryMode.\n        ///// For now, it simply delegates to the existing implementation\n        ///// (which behaves as immediate/direct send).\n        ///// In the next steps, we will branch on <paramref name=\"mode\"/>.\n        ///// </summary>\n        //// Over Load method\n        //public Task<ResponseResult> SendTemplateMessageSimpleAsync(\n        //    Guid businessId,\n        //    SimpleTemplateMessageDto dto,\n        //    DeliveryMode mode)\n        //{\n        //    // üîÅ Step 1: keep behaviour identical.\n        //    // We ignore `mode` for now and just call the existing method.\n        //    // Later we will:\n        //    //  - use Queued mode for outbox\n        //    //  - use Immediate mode for direct Meta Cloud sends\n        //    return SendTemplateMessageSimpleAsync(businessId, dto);\n        //}\n\n        #endregion\n\n        public async Task<ResponseResult> SendTemplateMessageSimpleAsync(Guid businessId, SimpleTemplateMessageDto dto)\n        {\n            try\n            {\n                // üîé Normalize inbound + respect DeliveryMode for logging/analytics\n                var mode = dto.DeliveryMode; // default is Queued if caller didn't set\n\n                string? providerUpper = string.IsNullOrWhiteSpace(dto.Provider)\n                    ? null\n                    : dto.Provider!.Trim().ToUpperInvariant();\n                string? providerKey = providerUpper?.ToLowerInvariant();\n                string? phoneNumberId = string.IsNullOrWhiteSpace(dto.PhoneNumberId)\n                    ? null\n                    : dto.PhoneNumberId!.Trim();\n\n                // Resolve missing provider/sender from WhatsAppPhoneNumbers\n                if (string.IsNullOrWhiteSpace(providerUpper))\n                {\n                    var defPhone = await _db.WhatsAppPhoneNumbers\n                        .AsNoTracking()\n                        .Where(n => n.BusinessId == businessId && n.IsActive)\n                        .OrderByDescending(n => n.IsDefault)\n                        .ThenByDescending(n => n.UpdatedAt ?? n.CreatedAt)\n                        .Select(n => new { n.Provider, n.PhoneNumberId })\n                        .FirstOrDefaultAsync();\n\n                    if (defPhone != null)\n                    {\n                        providerUpper = (defPhone.Provider ?? string.Empty).Trim().ToUpperInvariant();\n                        providerKey = providerUpper.ToLowerInvariant();\n                        if (string.IsNullOrWhiteSpace(phoneNumberId))\n                            phoneNumberId = defPhone.PhoneNumberId;\n                    }\n                }\n\n                if (string.IsNullOrWhiteSpace(providerUpper))\n                {\n                    var anySettingProvider = await _db.WhatsAppSettings\n                        .AsNoTracking()\n                        .Where(s => s.BusinessId == businessId && s.IsActive)\n                        .OrderByDescending(s => s.UpdatedAt ?? s.CreatedAt)\n                        .Select(s => s.Provider)\n                        .FirstOrDefaultAsync();\n\n                    if (!string.IsNullOrWhiteSpace(anySettingProvider))\n                    {\n                        providerUpper = anySettingProvider.Trim().ToUpperInvariant();\n                        providerKey = providerUpper.ToLowerInvariant();\n                    }\n                }\n\n                if (providerUpper != \"PINNACLE\" && providerUpper != \"META_CLOUD\")\n                {\n                    return ResponseResult.ErrorInfo(\n                        \"‚ùå Missing provider.\",\n                        \"No active WhatsApp sender found. Configure a PINNACLE or META_CLOUD sender for this business.\"\n                    );\n                }\n\n                if (string.IsNullOrWhiteSpace(phoneNumberId))\n                {\n                    var pn = await _db.WhatsAppPhoneNumbers\n                        .AsNoTracking()\n                        .Where(n => n.BusinessId == businessId\n                                    && n.IsActive\n                                    && n.Provider.ToLower() == providerKey)\n                        .OrderByDescending(n => n.IsDefault)\n                        .ThenByDescending(n => n.UpdatedAt ?? n.CreatedAt)\n                        .Select(n => n.PhoneNumberId)\n                        .FirstOrDefaultAsync();\n\n                    if (!string.IsNullOrWhiteSpace(pn))\n                        phoneNumberId = pn;\n                }\n\n                if (providerUpper == \"META_CLOUD\" && string.IsNullOrWhiteSpace(phoneNumberId))\n                    return ResponseResult.ErrorInfo(\n                        \"‚ùå Missing PhoneNumberId for META_CLOUD. Configure a default sender or pass PhoneNumberId.\");\n\n                var consentBlock = await EnforceOutboundConsentGuardAsync(businessId, dto.RecipientNumber);\n                if (consentBlock != null) return consentBlock;\n\n                // Build components (header + body + dynamic URL buttons)\n                var components = new List<object>();\n\n                var headerKind = (dto.HeaderKind ?? string.Empty).Trim().ToLowerInvariant();\n                var headerUrl = string.IsNullOrWhiteSpace(dto.HeaderMediaUrl) ? null : dto.HeaderMediaUrl!.Trim();\n\n                if (!string.IsNullOrWhiteSpace(headerUrl))\n                {\n                    if (headerKind == \"image\")\n                    {\n                        components.Add(new\n                        {\n                            type = \"header\",\n                            parameters = new object[]\n                            {\n                                new { type = \"image\", image = new { link = headerUrl } }\n                            }\n                        });\n                    }\n                    else if (headerKind == \"video\")\n                    {\n                        components.Add(new\n                        {\n                            type = \"header\",\n                            parameters = new object[]\n                            {\n                                new { type = \"video\", video = new { link = headerUrl } }\n                            }\n                        });\n                    }\n                    else if (headerKind == \"document\")\n                    {\n                        components.Add(new\n                        {\n                            type = \"header\",\n                            parameters = new object[]\n                            {\n                                new { type = \"document\", document = new { link = headerUrl } }\n                            }\n                        });\n                    }\n                }\n\n                var parameters = (dto.TemplateParameters ?? new List<string>())\n                    .Select(p => new { type = \"text\", text = p })\n                    .ToArray();\n\n                if (parameters.Length > 0)\n                    components.Add(new { type = \"body\", parameters });\n\n                var urlParams = dto.UrlButtonParams ?? new List<string>();\n                for (int i = 0; i < urlParams.Count && i < 3; i++)\n                {\n                    var p = (urlParams[i] ?? string.Empty).Trim();\n                    if (string.IsNullOrWhiteSpace(p)) continue;\n\n                    components.Add(new\n                    {\n                        type = \"button\",\n                        sub_type = \"url\",\n                        index = i.ToString(),\n                        parameters = new object[]\n                        {\n                            new { type = \"text\", text = p }\n                        }\n                    });\n                }\n\n                var lang = string.IsNullOrWhiteSpace(dto.LanguageCode) ? \"en_US\" : dto.LanguageCode!;\n\n                _logger?.LogInformation(\n                    \"‚û°Ô∏è SEND-INTENT tmpl={Template} to={To} provider={Provider} pnid={PhoneNumberId} mode={Mode} ctaFlowConfig={CtaFlowConfigId} ctaFlowStep={CtaFlowStepId}\",\n                    dto.TemplateName,\n                    dto.RecipientNumber,\n                    providerUpper,\n                    phoneNumberId ?? \"(default)\",\n                    mode,\n                    dto.CTAFlowConfigId,\n                    dto.CTAFlowStepId\n                );\n\n                // üßµ IMPORTANT:\n                // For now, BOTH Queued + Immediate behave the same: direct send.\n                // Later, if you wire a true Outbox, you can special-case `mode == DeliveryMode.Queued`\n                // to enqueue instead of calling SendViaProviderAsync.\n                var sendResult = await SendViaProviderAsync(\n                    businessId,\n                    providerUpper,\n                    p => p.SendTemplateAsync(dto.RecipientNumber, dto.TemplateName, lang, components),\n                    phoneNumberId\n                );\n\n                // üè∑ Smarter Source tagging:\n                // - If CTAFlowConfigId is set ‚Üí this is a CTA Flow step\n                // - Else ‚Üí normal API/template send\n                var isCtaFlow = dto.CTAFlowConfigId.HasValue;\n\n                var sourceTag = isCtaFlow\n                    ? (mode == DeliveryMode.Immediate ? \"cta-flow-immediate\" : \"cta-flow-queued\")\n                    : (mode == DeliveryMode.Immediate ? \"api-immediate\" : \"api-queued\");\n\n                var log = new MessageLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    RecipientNumber = dto.RecipientNumber,\n                    MessageContent = dto.TemplateName,\n                    MediaUrl = headerUrl,\n                    RenderedBody = TemplateParameterHelper.FillPlaceholders(\n                        dto.TemplateBody ?? string.Empty,\n                        dto.TemplateParameters ?? new List<string>()),\n\n                    CTAFlowConfigId = dto.CTAFlowConfigId,\n                    CTAFlowStepId = dto.CTAFlowStepId,\n\n                    Provider = providerUpper,\n                    ProviderMessageId = sendResult.MessageId,\n\n                    Status = sendResult.Success ? \"Sent\" : \"Failed\",\n                    ErrorMessage = sendResult.Success ? null : sendResult.Message,\n                    RawResponse = sendResult.RawResponse,\n                    MessageId = sendResult.MessageId,\n                    SentAt = sendResult.Success ? DateTime.UtcNow : (DateTime?)null,\n                    CreatedAt = DateTime.UtcNow,\n\n                    // üëá now carries CTA vs non-CTA + mode\n                    Source = sourceTag\n                };\n\n                await _db.MessageLogs.AddAsync(log);\n                await _db.SaveChangesAsync();\n\n                return new ResponseResult\n                {\n                    Success = sendResult.Success,\n                    Message = sendResult.Success\n                        ? \"‚úÖ Template sent successfully.\"\n                        : (sendResult.Message ?? \"‚ùå WhatsApp API returned an error.\"),\n                    Data = new\n                    {\n                        Success = sendResult.Success,\n                        MessageId = sendResult.MessageId,\n                        LogId = log.Id\n                    },\n                    RawResponse = sendResult.RawResponse,\n                    MessageId = sendResult.MessageId,\n                    LogId = log.Id\n                };\n            }\n            catch (Exception ex)\n            {\n                try\n                {\n                    await _db.MessageLogs.AddAsync(new MessageLog\n                    {\n                        Id = Guid.NewGuid(),\n                        BusinessId = businessId,\n                        RecipientNumber = dto.RecipientNumber,\n                        MessageContent = dto.TemplateName,\n                        MediaUrl = string.IsNullOrWhiteSpace(dto.HeaderMediaUrl) ? null : dto.HeaderMediaUrl.Trim(),\n                        RenderedBody = TemplateParameterHelper.FillPlaceholders(\n                            dto.TemplateBody ?? string.Empty,\n                            dto.TemplateParameters ?? new List<string>()),\n                        Status = \"Failed\",\n                        ErrorMessage = ex.Message,\n                        CreatedAt = DateTime.UtcNow,\n                        Source = \"api-error\"\n                    });\n                    await _db.SaveChangesAsync();\n                }\n                catch { /* ignore */ }\n\n                return ResponseResult.ErrorInfo(\"‚ùå Template send failed\", ex.Message);\n            }\n        }\n\n        /// <summary>\n        /// New overload that is aware of DeliveryMode.\n        /// Right now it just stamps the mode into the DTO\n        /// and calls the core implementation. Later, if you\n        /// implement a real outbox, this is the natural place\n        /// to branch behaviour.\n        /// </summary>\n        public Task<ResponseResult> SendTemplateMessageSimpleAsync(\n            Guid businessId,\n            SimpleTemplateMessageDto dto,\n            DeliveryMode mode)\n        {\n            // Keep DTO + intent in sync\n            dto.DeliveryMode = mode;\n\n            // For now, both modes use the same path.\n            return SendTemplateMessageSimpleAsync(businessId, dto);\n        }\n\n        public async Task<ResponseResult> SendImageCampaignAsync(Guid campaignId, Guid businessId, string sentBy)\n        {\n            try\n            {\n                var campaign = await _db.Campaigns\n                    .Include(c => c.MultiButtons)\n                    .FirstOrDefaultAsync(c => c.Id == campaignId && c.BusinessId == businessId);\n\n                if (campaign == null)\n                    return ResponseResult.ErrorInfo(\"‚ùå Campaign not found or unauthorized.\");\n\n                var recipients = await _db.CampaignRecipients\n                    .Include(r => r.Contact)\n                    .Where(r => r.CampaignId == campaignId && r.BusinessId == businessId)\n                    .ToListAsync();\n\n                if (recipients.Count == 0)\n                    return ResponseResult.ErrorInfo(\"‚ö†Ô∏è No recipients assigned to this campaign.\");\n\n                var validButtons = campaign.MultiButtons\n                    ?.Where(b => !string.IsNullOrWhiteSpace(b.Title))\n                    .Select(b => new CtaButtonDto { Title = b.Title, Value = b.Value })\n                    .ToList();\n\n                if (validButtons == null || validButtons.Count == 0)\n                    return ResponseResult.ErrorInfo(\"‚ùå At least one CTA button with a valid title is required.\");\n\n                int successCount = 0, failCount = 0;\n\n                foreach (var recipient in recipients)\n                {\n                    if (recipient.Contact == null || string.IsNullOrWhiteSpace(recipient.Contact.PhoneNumber))\n                    {\n                        recipient.Status = \"Failed\";\n                        recipient.UpdatedAt = DateTime.UtcNow;\n                        failCount++;\n                        continue;\n                    }\n\n                    var dto = new SendMessageDto\n                    {\n                        BusinessId = businessId,\n                        RecipientNumber = recipient.Contact.PhoneNumber,\n                        MessageType = MessageTypeEnum.Image,\n                        MediaUrl = campaign.ImageUrl,\n                        TextContent = campaign.MessageTemplate,\n                        CtaButtons = validButtons,\n\n                        CampaignId = campaign.Id,\n                        SourceModule = \"image-campaign\",\n                        CustomerId = recipient.Contact.Id.ToString(),\n                        CustomerName = recipient.Contact.Name,\n                        CustomerPhone = recipient.Contact.PhoneNumber,\n                        CTATriggeredFrom = \"campaign\"\n                    };\n\n                    var result = await SendImageWithCtaAsync(dto);\n\n                    var sendLog = new CampaignSendLog\n                    {\n                        Id = Guid.NewGuid(),\n                        CampaignId = campaign.Id,\n                        ContactId = recipient.Contact.Id,\n                        RecipientId = recipient.Id,\n                        MessageLogId = result?.LogId,\n                        SendStatus = result.Success ? \"Sent\" : \"Failed\",\n                        SentAt = result.Success ? DateTime.UtcNow : (DateTime?)null,\n                        CreatedBy = sentBy,\n                        BusinessId = businessId,\n                    };\n                    await _db.CampaignSendLogs.AddAsync(sendLog);\n\n                    if (result.Success)\n                    {\n                        recipient.Status = \"Sent\";\n                        recipient.SentAt = DateTime.UtcNow;\n                        recipient.UpdatedAt = DateTime.UtcNow;\n                        successCount++;\n                    }\n                    else\n                    {\n                        recipient.Status = \"Failed\";\n                        recipient.UpdatedAt = DateTime.UtcNow;\n                        failCount++;\n                    }\n                }\n\n                await _db.SaveChangesAsync();\n\n                await _db.Campaigns\n                    .Where(c => c.Id == campaign.Id && c.BusinessId == businessId)\n                    .ExecuteUpdateAsync(s => s\n                        .SetProperty(c => c.Status, _ => \"Sent\")\n                        .SetProperty(c => c.UpdatedAt, _ => DateTime.UtcNow));\n\n                return ResponseResult.SuccessInfo($\"‚úÖ Campaign sent.\\nüì§ Success: {successCount}, ‚ùå Failed: {failCount}\");\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"‚ùå Error sending image campaign: {ex.Message}\");\n                return ResponseResult.ErrorInfo(\"‚ùå Unexpected error while sending image campaign.\", ex.ToString());\n            }\n        }\n\n        public async Task<ResponseResult> SendTemplateCampaignAsync(Guid campaignId, Guid businessId, string sentBy)\n        {\n            try\n            {\n                var campaign = await _db.Campaigns\n                    .AsNoTracking()\n                    .Where(c => c.Id == campaignId && c.BusinessId == businessId)\n                    .Select(c => new\n                    {\n                        c.Id,\n                        c.BusinessId,\n                        c.MessageTemplate,\n                        c.TemplateId,\n                        c.Provider,\n                        c.PhoneNumberId,\n                        c.ImageUrl\n                    })\n                    .FirstOrDefaultAsync();\n\n                if (campaign == null)\n                    return ResponseResult.ErrorInfo(\"‚ùå Campaign not found or unauthorized.\");\n\n                var templateName = !string.IsNullOrWhiteSpace(campaign.TemplateId)\n                    ? campaign.TemplateId!\n                    : (campaign.MessageTemplate ?? \"\").Trim();\n\n                if (string.IsNullOrWhiteSpace(templateName))\n                    return ResponseResult.ErrorInfo(\"‚ùå Campaign has no template selected.\");\n\n                var lang = await _db.WhatsAppTemplates\n                    .AsNoTracking()\n                    .Where(w => w.BusinessId == businessId && w.Name == templateName)\n                    .OrderByDescending(w => (w.UpdatedAt > w.CreatedAt ? w.UpdatedAt : w.CreatedAt))\n                    .Select(w => w.LanguageCode)\n                    .FirstOrDefaultAsync();\n                if (string.IsNullOrWhiteSpace(lang)) lang = \"en_US\";\n\n                var recipients = await _db.CampaignRecipients\n                    .AsNoTracking()\n                    .Include(r => r.AudienceMember)\n                    .Include(r => r.Contact)\n                    .Where(r => r.CampaignId == campaignId && r.BusinessId == businessId)\n                    .Select(r => new\n                    {\n                        r.Id,\n                        r.ContactId,\n                        AudienceContactId = r.AudienceMember != null ? r.AudienceMember.ContactId : (Guid?)null,\n                        r.ResolvedParametersJson,\n                        r.ResolvedButtonUrlsJson,\n                        Phone = r.AudienceMember != null && !string.IsNullOrEmpty(r.AudienceMember.PhoneE164)\n                                ? r.AudienceMember.PhoneE164\n                                : (r.Contact != null ? r.Contact.PhoneNumber : null)\n                    })\n                    .ToListAsync();\n\n                if (recipients.Count == 0)\n                    return ResponseResult.ErrorInfo(\"‚ö†Ô∏è No recipients materialized for this campaign.\");\n\n                var provider = (campaign.Provider ?? \"\").Trim().ToUpperInvariant();\n                if (provider != \"PINNACLE\" && provider != \"META_CLOUD\")\n                    return ResponseResult.ErrorInfo(\"‚ùå Invalid provider on campaign. Must be 'PINNACLE' or 'META_CLOUD'.\");\n\n                var phoneNumberId = string.IsNullOrWhiteSpace(campaign.PhoneNumberId) ? null : campaign.PhoneNumberId!.Trim();\n                if (string.IsNullOrWhiteSpace(phoneNumberId))\n                    return ResponseResult.ErrorInfo(\"‚ùå Campaign has no sender number (PhoneNumberId).\");\n\n                int success = 0, fail = 0;\n                var successIds = new List<Guid>(recipients.Count);\n                var failedIds = new List<Guid>();\n                var sendLogs = new List<CampaignSendLog>(recipients.Count);\n\n                foreach (var r in recipients)\n                {\n                    if (string.IsNullOrWhiteSpace(r.Phone))\n                    {\n                        failedIds.Add(r.Id);\n                        continue;\n                    }\n\n                    string[] bodyParams;\n                    try\n                    {\n                        bodyParams = string.IsNullOrWhiteSpace(r.ResolvedParametersJson)\n                            ? Array.Empty<string>()\n                            : JsonSerializer.Deserialize<string[]>(r.ResolvedParametersJson!) ?? Array.Empty<string>();\n                    }\n                    catch { bodyParams = Array.Empty<string>(); }\n\n                    Dictionary<string, string> buttonVars;\n                    try\n                    {\n                        buttonVars = string.IsNullOrWhiteSpace(r.ResolvedButtonUrlsJson)\n                            ? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)\n                            : JsonSerializer.Deserialize<Dictionary<string, string>>(r.ResolvedButtonUrlsJson!)\n                              ?? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n                    }\n                    catch { buttonVars = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase); }\n\n                    var components = new List<object>();\n\n                    var headerImage = !string.IsNullOrWhiteSpace(campaign.ImageUrl)\n                        ? campaign.ImageUrl\n                        : (buttonVars.TryGetValue(\"header.image_url\", out var hv) && !string.IsNullOrWhiteSpace(hv) ? hv : null);\n\n                    if (!string.IsNullOrWhiteSpace(headerImage))\n                    {\n                        components.Add(new\n                        {\n                            type = \"header\",\n                            parameters = new object[]\n                            {\n                                new { type = \"image\", image = new { link = headerImage! } }\n                            }\n                        });\n                    }\n\n                    if (bodyParams.Length > 0)\n                    {\n                        components.Add(new\n                        {\n                            type = \"body\",\n                            parameters = bodyParams.Select(p => (object)new { type = \"text\", text = p }).ToArray()\n                        });\n                    }\n\n                    foreach (var pos in new[] { 1, 2, 3 })\n                    {\n                        var key = $\"button{pos}.url_param\";\n                        if (buttonVars.TryGetValue(key, out var urlParam) && !string.IsNullOrWhiteSpace(urlParam))\n                        {\n                            components.Add(new\n                            {\n                                type = \"button\",\n                                sub_type = \"url\",\n                                index = (pos - 1).ToString(),\n                                parameters = new object[] { new { type = \"text\", text = urlParam } }\n                            });\n                        }\n                    }\n\n                    var payload = new\n                    {\n                        messaging_product = \"whatsapp\",\n                        to = r.Phone!,\n                        type = \"template\",\n                        template = new\n                        {\n                            name = templateName,\n                            language = new { code = lang },\n                            components = components\n                        }\n                    };\n\n                    var result = await SendPayloadAsync(businessId, provider, payload, phoneNumberId);\n                    if (result.Success) { success++; successIds.Add(r.Id); } else { fail++; failedIds.Add(r.Id); }\n\n                    var contactId = r.ContactId ?? r.AudienceContactId;\n                    sendLogs.Add(new CampaignSendLog\n                    {\n                        Id = Guid.NewGuid(),\n                        CampaignId = campaign.Id,\n                        ContactId = contactId,\n                        RecipientId = r.Id,\n                        MessageLogId = result?.LogId,\n                        SendStatus = result.Success ? \"Sent\" : \"Failed\",\n                        SentAt = result.Success ? DateTime.UtcNow : (DateTime?)null,\n                        CreatedBy = sentBy,\n                        BusinessId = businessId,\n                    });\n                }\n\n                if (sendLogs.Count > 0)\n                    await _db.CampaignSendLogs.AddRangeAsync(sendLogs);\n\n                if (successIds.Count > 0)\n                {\n                    await _db.CampaignRecipients\n                        .Where(x => x.CampaignId == campaignId && x.BusinessId == businessId && successIds.Contains(x.Id))\n                        .ExecuteUpdateAsync(s => s\n                            .SetProperty(x => x.Status, _ => \"Sent\")\n                            .SetProperty(x => x.SentAt, _ => DateTime.UtcNow)\n                            .SetProperty(x => x.UpdatedAt, _ => DateTime.UtcNow));\n                }\n\n                if (failedIds.Count > 0)\n                {\n                    await _db.CampaignRecipients\n                        .Where(x => x.CampaignId == campaignId && x.BusinessId == businessId && failedIds.Contains(x.Id))\n                        .ExecuteUpdateAsync(s => s\n                            .SetProperty(x => x.Status, _ => \"Failed\")\n                            .SetProperty(x => x.UpdatedAt, _ => DateTime.UtcNow));\n                }\n\n                await _db.SaveChangesAsync();\n\n                await _db.Campaigns\n                    .Where(c => c.Id == campaign.Id && c.BusinessId == businessId)\n                    .ExecuteUpdateAsync(s => s\n                        .SetProperty(c => c.Status, _ => \"Sent\")\n                        .SetProperty(c => c.UpdatedAt, _ => DateTime.UtcNow));\n\n                return ResponseResult.SuccessInfo($\"‚úÖ Template campaign sent. üì§ Success: {success}, ‚ùå Failed: {fail}\");\n            }\n            catch (Exception ex)\n            {\n                return ResponseResult.ErrorInfo(\"‚ùå Error sending template campaign.\", ex.ToString());\n            }\n        }\n\n        public async Task<ResponseResult> SendImageWithCtaAsync(SendMessageDto dto)\n        {\n            try\n            {\n                Console.WriteLine($\"üì§ Sending image+CTA to {dto.RecipientNumber}\");\n\n                if (string.IsNullOrWhiteSpace(dto.TextContent))\n                    return ResponseResult.ErrorInfo(\"‚ùå Image message caption (TextContent) cannot be empty.\");\n\n                if (string.IsNullOrWhiteSpace(dto.Provider) ||\n                    (dto.Provider != \"PINNACLE\" && dto.Provider != \"META_CLOUD\"))\n                {\n                    return ResponseResult.ErrorInfo(\"‚ùå Invalid provider.\",\n                        \"Provider must be exactly 'PINNACLE' or 'META_CLOUD'.\");\n                }\n\n                var consentBlock = await EnforceOutboundConsentGuardAsync(dto.BusinessId, dto.RecipientNumber);\n                if (consentBlock != null) return consentBlock;\n\n                var validButtons = dto.CtaButtons?\n                    .Where(b => !string.IsNullOrWhiteSpace(b.Title))\n                    .Take(3)\n                    .Select((btn, index) => new\n                    {\n                        type = \"reply\",\n                        reply = new\n                        {\n                            id = $\"btn_{index + 1}_{Guid.NewGuid():N}\".Substring(0, 16),\n                            title = btn.Title\n                        }\n                    })\n                    .ToList();\n\n                if (validButtons == null || validButtons.Count == 0)\n                    return ResponseResult.ErrorInfo(\"‚ùå At least one CTA button with a valid title is required.\");\n\n                var payload = new\n                {\n                    messaging_product = \"whatsapp\",\n                    to = dto.RecipientNumber,\n                    type = \"interactive\",\n                    interactive = new\n                    {\n                        type = \"button\",\n                        body = new { text = dto.TextContent },\n                        action = new { buttons = validButtons }\n                    },\n                    image = string.IsNullOrWhiteSpace(dto.MediaUrl) ? null : new { link = dto.MediaUrl }\n                };\n\n                var sendResult = await SendViaProviderAsync(\n                    dto.BusinessId,\n                    dto.Provider,\n                    p => p.SendInteractiveAsync(payload),\n                    dto.PhoneNumberId\n                );\n\n                string? messageId = sendResult.MessageId;\n                if (string.IsNullOrWhiteSpace(messageId) && !string.IsNullOrWhiteSpace(sendResult.RawResponse))\n                {\n                    try\n                    {\n                        var raw = sendResult.RawResponse.TrimStart();\n                        if (raw.StartsWith(\"{\"))\n                        {\n                            using var doc = JsonDocument.Parse(raw);\n                            if (doc.RootElement.TryGetProperty(\"messages\", out var msgs) &&\n                                msgs.ValueKind == JsonValueKind.Array &&\n                                msgs.GetArrayLength() > 0 &&\n                                msgs[0].TryGetProperty(\"id\", out var idProp))\n                            {\n                                messageId = idProp.GetString();\n                            }\n                        }\n                    }\n                    catch { /* best-effort */ }\n                }\n\n                var log = new MessageLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = dto.BusinessId,\n                    RecipientNumber = dto.RecipientNumber,\n                    MessageContent = dto.TextContent ?? \"[Image with CTA]\",\n                    RenderedBody = dto.TextContent ?? \"\",\n                    MediaUrl = dto.MediaUrl,\n                    Status = sendResult.Success ? \"Sent\" : \"Failed\",\n                    ErrorMessage = sendResult.Success ? null : sendResult.Message,\n                    RawResponse = sendResult.RawResponse,\n                    MessageId = messageId,\n                    CreatedAt = DateTime.UtcNow,\n                    SentAt = DateTime.UtcNow,\n                    CTAFlowConfigId = dto.CTAFlowConfigId,\n                    CTAFlowStepId = dto.CTAFlowStepId,\n                };\n\n                await _db.MessageLogs.AddAsync(log);\n                await _db.SaveChangesAsync();\n\n                return new ResponseResult\n                {\n                    Success = sendResult.Success,\n                    Message = sendResult.Success\n                        ? \"‚úÖ Image+CTA message sent.\"\n                        : (sendResult.Message ?? \"‚ùå WhatsApp API returned an error.\"),\n                    Data = new\n                    {\n                        Success = sendResult.Success,\n                        MessageId = messageId,\n                        LogId = log.Id\n\n                    },\n                    RawResponse = sendResult.RawResponse,\n                    MessageId = messageId,\n                    LogId = log.Id\n                };\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(\"‚ùå Exception in SendImageWithCtaAsync: \" + ex.Message);\n\n                await _db.MessageLogs.AddAsync(new MessageLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = dto.BusinessId,\n                    RecipientNumber = dto.RecipientNumber,\n                    MessageContent = dto.TextContent ?? \"[Image CTA Failed]\",\n                    RenderedBody = dto.TextContent ?? \"[Failed image CTA]\",\n                    Status = \"Failed\",\n                    ErrorMessage = ex.Message,\n                    RawResponse = ex.ToString(),\n                    CreatedAt = DateTime.UtcNow,\n                    CTAFlowConfigId = dto.CTAFlowConfigId,\n                    CTAFlowStepId = dto.CTAFlowStepId,\n                });\n\n                await _db.SaveChangesAsync();\n\n                return ResponseResult.ErrorInfo(\"‚ùå Failed to send image+CTA.\", ex.ToString());\n            }\n        }\n        [Obsolete(\"Use outbox + SendPayloadAsync via worker.\")]\n        public async Task<ResponseResult> SendImageTemplateMessageAsync(ImageTemplateMessageDto dto, Guid businessId)\n        {\n            try\n            {\n                if (string.IsNullOrWhiteSpace(dto.Provider) ||\n                    (dto.Provider != \"PINNACLE\" && dto.Provider != \"META_CLOUD\"))\n                {\n                    return ResponseResult.ErrorInfo(\"‚ùå Invalid provider.\",\n                        \"Provider must be exactly 'PINNACLE' or 'META_CLOUD'.\");\n                }\n\n                var consentBlock = await EnforceOutboundConsentGuardAsync(businessId, dto.RecipientNumber);\n                if (consentBlock != null) return consentBlock;\n\n                var components = new List<object>();\n\n                if (!string.IsNullOrWhiteSpace(dto.HeaderImageUrl))\n                {\n                    components.Add(new\n                    {\n                        type = \"header\",\n                        parameters = new[]\n                        {\n                            new { type = \"image\", image = new { link = dto.HeaderImageUrl! } }\n                        }\n                    });\n                }\n\n                components.Add(new\n                {\n                    type = \"body\",\n                    parameters = (dto.TemplateParameters ?? new List<string>())\n                        .Select(p => new { type = \"text\", text = p })\n                        .ToArray()\n                });\n\n                var btns = dto.ButtonParameters ?? new List<CampaignButtonDto>();\n                for (int i = 0; i < btns.Count && i < 3; i++)\n                {\n                    var btn = btns[i];\n                    var subType = btn.ButtonType?.ToLowerInvariant();\n                    if (string.IsNullOrWhiteSpace(subType)) continue;\n\n                    var button = new Dictionary<string, object>\n                    {\n                        [\"type\"] = \"button\",\n                        [\"sub_type\"] = subType,\n                        [\"index\"] = i.ToString()\n                    };\n\n                    if (subType == \"quick_reply\" && !string.IsNullOrWhiteSpace(btn.TargetUrl))\n                        button[\"parameters\"] = new[] { new { type = \"payload\", payload = btn.TargetUrl! } };\n                    else if (subType == \"url\" && !string.IsNullOrWhiteSpace(btn.TargetUrl))\n                        button[\"parameters\"] = new[] { new { type = \"text\", text = btn.TargetUrl! } };\n\n                    components.Add(button);\n                }\n\n                var lang = string.IsNullOrWhiteSpace(dto.LanguageCode) ? \"en_US\" : dto.LanguageCode!;\n\n                var sendResult = await SendViaProviderAsync(\n                    businessId,\n                    dto.Provider,\n                    p => p.SendTemplateAsync(dto.RecipientNumber, dto.TemplateName, lang, components),\n                    dto.PhoneNumberId\n                );\n\n                var renderedBody = TemplateParameterHelper.FillPlaceholders(\n                    dto.TemplateBody ?? \"\",\n                    dto.TemplateParameters ?? new List<string>());\n\n                var log = new MessageLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    RecipientNumber = dto.RecipientNumber,\n                    MessageContent = dto.TemplateName,\n                    MediaUrl = dto.HeaderImageUrl,\n                    RenderedBody = renderedBody,\n                    Status = sendResult.Success ? \"Sent\" : \"Failed\",\n                    ErrorMessage = sendResult.Success ? null : sendResult.Message,\n                    RawResponse = sendResult.RawResponse,\n                    MessageId = sendResult.MessageId,\n                    CreatedAt = DateTime.UtcNow,\n                    SentAt = DateTime.UtcNow,\n                    CTAFlowConfigId = dto.CTAFlowConfigId,\n                    CTAFlowStepId = dto.CTAFlowStepId,\n                };\n\n                await _db.MessageLogs.AddAsync(log);\n                await _db.SaveChangesAsync();\n\n                return new ResponseResult\n                {\n                    Success = sendResult.Success,\n                    Message = sendResult.Success\n                        ? \"‚úÖ Image template sent successfully.\"\n                        : (sendResult.Message ?? \"‚ùå WhatsApp API returned an error.\"),\n                    Data = new { Success = sendResult.Success, MessageId = sendResult.MessageId, LogId = log.Id },\n                    RawResponse = sendResult.RawResponse,\n                    MessageId = sendResult.MessageId,\n                    LogId = log.Id\n                };\n            }\n            catch (Exception ex)\n            {\n                await _db.MessageLogs.AddAsync(new MessageLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = dto.BusinessId,\n                    RecipientNumber = dto.RecipientNumber,\n                    MessageContent = dto.TemplateName,\n                    RenderedBody = TemplateParameterHelper.FillPlaceholders(dto.TemplateBody ?? \"\", dto.TemplateParameters ?? new List<string>()),\n                    MediaUrl = dto.HeaderImageUrl,\n                    Status = \"Failed\",\n                    ErrorMessage = ex.Message,\n                    RawResponse = ex.ToString(),\n                    CreatedAt = DateTime.UtcNow,\n                    CTAFlowConfigId = dto.CTAFlowConfigId,\n                    CTAFlowStepId = dto.CTAFlowStepId,\n                });\n\n                await _db.SaveChangesAsync();\n                return ResponseResult.ErrorInfo(\"‚ùå Error sending image template.\", ex.ToString());\n            }\n        }\n\n        public async Task<IEnumerable<RecentMessageLogDto>> GetLogsByBusinessIdAsync(Guid businessId)\n        {\n            var logs = await _db.MessageLogs\n                .Where(m => m.BusinessId == businessId)\n                .OrderByDescending(m => m.CreatedAt)\n                .Take(1000)\n                .Select(m => new RecentMessageLogDto\n                {\n                    Id = m.Id,\n                    RecipientNumber = m.RecipientNumber,\n                    MessageContent = m.MessageContent,\n                    Status = m.Status,\n                    CreatedAt = m.CreatedAt,\n                    SentAt = m.SentAt,\n                    ErrorMessage = m.ErrorMessage\n                })\n                .ToListAsync();\n\n            return logs;\n        }\n\n        public Task<ResponseResult> SendDocumentTemplateMessageAsync(DocumentTemplateMessageDto dto, Guid businessId)\n        {\n            throw new NotImplementedException();\n        }\n\n        private async Task<IReadOnlyList<WhatsAppSettingEntity>> GetBusinessWhatsAppSettingsAsync(Guid businessId)\n        {\n            if (_settingsCache.TryGetValue(businessId, out var cached) && cached.expiresAt > DateTime.UtcNow)\n                return cached.setting;\n\n            var items = await _db.WhatsAppSettings\n                .Where(s => s.BusinessId == businessId)\n                .ToListAsync();\n\n            if (items == null || items.Count == 0)\n                throw new Exception(\"WhatsApp settings not found.\");\n\n            var ro = items.AsReadOnly();\n            _settingsCache[businessId] = (ro, DateTime.UtcNow.AddMinutes(5));\n            return ro;\n        }\n    }\n}\n\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/Services/SendPipeline/ProviderNormalizer.cs",
      "sha256": "b1aa904138bd23abe377835e2a4ccce78f1742142ddb717df48287d9d1e100ea",
      "language": "csharp",
      "size": 846,
      "content": "namespace xbytechat.api.Features.CampaignModule.Services.SendPipeline\n{\n    public static class ProviderNormalizer\n    {\n\n        public static string ForDb(string? providerFromSettings)\n        {\n            var v = (providerFromSettings ?? string.Empty).Trim();\n            // If you store \"meta_cloud\" / \"pinnacle\" in DB, keep it as-is:\n            return v.ToLowerInvariant(); // e.g. \"meta_cloud\", \"pinnacle\"\n        }\n\n        public static string ForSend(string? providerFromSettings)\n        {\n            var v = (providerFromSettings ?? string.Empty).Trim().ToLowerInvariant();\n            return v switch\n            {\n                \"pinnacle\" => \"PINNACLE\",\n                \"meta_cloud\" => \"META_CLOUD\",\n                _ => providerFromSettings ?? string.Empty // pass-through for future providers\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/Services/SendPipeline/TemplateHeaderInspector.cs",
      "sha256": "d6dfbd0106161bd235f70126864bcb5cf4ede304695288ffd610794077c5b428",
      "language": "csharp",
      "size": 3096,
      "content": "using System;\nusing Newtonsoft.Json.Linq;\nusing xbytechat.api.AuthModule.Models;\nusing xbytechat.api.Features.CampaignModule.Models;\n\nnamespace xbytechat.api.Features.CampaignModule.Services.SendPipeline\n{\n    public enum TemplateHeaderKind\n    {\n        Text,\n        Image,\n        Video,\n        Document\n    }\n\n    public static class TemplateHeaderInspector\n    {\n        /// <summary>\n        /// Reads a WhatsApp template row (from DB) and infers the HEADER kind quickly,\n        /// using RawJson when present, otherwise falling back to flags like HasImageHeader.\n        /// No network calls. Pure and deterministic.\n        /// </summary>\n        public static TemplateHeaderKind Infer(WhatsAppTemplate templateRow)\n        {\n            if (templateRow == null) return TemplateHeaderKind.Text;\n\n            // 1) Prefer RawJson (when available) ‚Äî read only the minimal bits we need\n            var raw = templateRow.RawJson;\n            if (!string.IsNullOrWhiteSpace(raw))\n            {\n                try\n                {\n                    var root = JObject.Parse(raw);\n                    var comps = root[\"components\"] as JArray;\n                    if (comps != null)\n                    {\n                        foreach (var comp in comps)\n                        {\n                            var type = comp?[\"type\"]?.ToString()?.Trim().ToUpperInvariant();\n                            if (type == \"HEADER\")\n                            {\n                                var format = comp?[\"format\"]?.ToString()?.Trim().ToUpperInvariant();\n                                if (!string.IsNullOrEmpty(format))\n                                {\n                                    if (format == \"IMAGE\") return TemplateHeaderKind.Image;\n                                    if (format == \"VIDEO\") return TemplateHeaderKind.Video;\n                                    if (format == \"DOCUMENT\" || format == \"PDF\") return TemplateHeaderKind.Document;\n                                    return TemplateHeaderKind.Text;\n                                }\n                                // If TYPE=HEADER but no format => treat as Text\n                                return TemplateHeaderKind.Text;\n                            }\n                        }\n                    }\n                }\n                catch\n                {\n                    // swallow; fall through to flags\n                }\n            }\n\n            // 2) Fallback: existing DB flags\n           // if (templateRow.HasImageHeader) return TemplateHeaderKind.Image;\n\n            return TemplateHeaderKind.Text;\n        }\n\n        /// <summary>\n        /// Maps a header kind to our ‚ÄúmediaType‚Äù shorthand used by send routing.\n        /// </summary>\n        public static string ToMediaType(TemplateHeaderKind kind)\n        {\n            return kind switch\n            {\n                TemplateHeaderKind.Image => \"image\",\n                TemplateHeaderKind.Video => \"video\",\n                TemplateHeaderKind.Document => \"document\",\n                _ => \"text\"\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/Services/TemplateMessageSender.cs",
      "sha256": "ccf337582a45a95cf31b6229f11d4734a66913dcdbf49f14b0499257ccc01fbe",
      "language": "csharp",
      "size": 15092,
      "content": "// üìÑ File: Features/MessagesEngine/Services/TemplateMessageSender.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Text;\nusing System.Text.Json;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.CampaignModule.Models;\nusing xbytechat.api.Features.CampaignTracking.Models;\nusing xbytechat.api.Features.CRM.Models;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.Helpers;\n\n//using xbytechat.api.Helpers;\nusing xbytechat.api.Shared;\nusing xbytechat.api.Shared.utility;\nusing xbytechat.api.WhatsAppSettings.DTOs;\nusing xbytechat_api.WhatsAppSettings.Services;\n\nnamespace xbytechat.api.Features.MessagesEngine.Services\n{\n    public class TemplateMessageSender : ITemplateMessageSender\n    {\n        private readonly AppDbContext _db;\n        private readonly HttpClient _httpClient;\n        private readonly ILogger<TemplateMessageSender> _logger;\n        private readonly IWhatsAppTemplateFetcherService _templateService;\n\n        public TemplateMessageSender(\n            AppDbContext db,\n            HttpClient httpClient,\n            ILogger<TemplateMessageSender> logger,\n            IWhatsAppTemplateFetcherService templateService)\n        {\n            _db = db;\n            _httpClient = httpClient;\n            _logger = logger;\n            _templateService = templateService;\n        }\n\n        //public async Task<ResponseResult> SendTemplateMessageToContactAsync(\n        //    Guid businessId,\n        //    Contact contact,\n        //    string templateName,\n        //    List<string> templateParams,\n        //    string? imageUrl = null,\n        //    List<CampaignButton>? buttons = null,\n        //    string? source = null,\n        //    Guid? refMessageId = null)\n        //{\n        //    var setting = await _db.WhatsAppSettings.FirstOrDefaultAsync(s => s.BusinessId == businessId && s.IsActive);\n        //    if (setting == null)\n        //        return ResponseResult.ErrorInfo(\"WhatsApp settings not found for this business.\");\n\n        //    var template = await _templateService.GetTemplateByNameAsync(businessId, templateName, includeButtons: true);\n        //    if (template == null)\n        //        return ResponseResult.ErrorInfo(\"Template not found or invalid.\");\n\n        //    var payload = new Dictionary<string, object>\n        //    {\n        //        [\"messaging_product\"] = \"whatsapp\",\n        //        [\"to\"] = contact.PhoneNumber,\n        //        [\"type\"] = \"template\",\n        //        [\"template\"] = new\n        //        {\n        //            name = template.Name,\n        //            language = new { code = template.Language },\n        //            components = BuildTemplateComponents(template, templateParams, imageUrl, buttons)\n        //        }\n        //    };\n\n        //    _httpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(\"Bearer\", setting.ApiKey);\n        //    var json = JsonSerializer.Serialize(payload);\n        //    var response = await _httpClient.PostAsync(\n        //        $\"{setting.ApiUrl?.TrimEnd('/') ?? \"https://graph.facebook.com/v22.0\"}/{setting.PhoneNumberId}/messages\",\n        //        new StringContent(json, Encoding.UTF8, \"application/json\"));\n\n        //    var responseBody = await response.Content.ReadAsStringAsync();\n        //    var status = response.IsSuccessStatusCode ? \"Sent\" : \"Failed\";\n\n        //    await _db.MessageLogs.AddAsync(new MessageLog\n        //    {\n        //        Id = Guid.NewGuid(),\n        //        BusinessId = businessId,\n        //        ContactId = contact.Id,\n        //        MessageContent = template.Name,\n        //        MediaUrl = imageUrl,\n        //        Status = status,\n        //        RawResponse = responseBody,\n        //        ErrorMessage = response.IsSuccessStatusCode ? null : responseBody,\n        //        Source = source,\n        //        RefMessageId = refMessageId,\n        //        CreatedAt = DateTime.UtcNow,\n        //        SentAt = DateTime.UtcNow\n        //    });\n\n        //    await _db.SaveChangesAsync();\n        //    return response.IsSuccessStatusCode\n        //        ? ResponseResult.SuccessInfo(\"‚úÖ Message sent successfully\", null, responseBody)\n        //        : ResponseResult.ErrorInfo(\"‚ùå Message failed\", null, responseBody);\n\n        //}\n\n        public async Task<ResponseResult> SendTemplateMessageToContactAsync(\n    Guid businessId,\n    Contact contact,\n    string templateName,\n    List<string> templateParams,\n    string? imageUrl = null,\n    List<CampaignButton>? buttons = null,\n    string? source = null,\n    Guid? refMessageId = null)\n        {\n            // 1) Load settings (provider, keys, base url, etc.)\n            var setting = await _db.WhatsAppSettings\n                .AsNoTracking()\n                .FirstOrDefaultAsync(s => s.BusinessId == businessId && s.IsActive);\n\n            if (setting == null)\n                return ResponseResult.ErrorInfo(\"‚ùå WhatsApp settings not found for this business.\");\n\n            // 2) Pick the default phone number for THIS provider from WhatsAppPhoneNumbers\n            var phone = await _db.WhatsAppPhoneNumbers\n                .AsNoTracking()\n                .Where(p => p.BusinessId == businessId\n                            && p.IsActive\n                            && p.Provider.ToLower() == (setting.Provider ?? string.Empty).ToLower())\n                .OrderByDescending(p => p.IsDefault)\n                .ThenByDescending(p => p.UpdatedAt ?? p.CreatedAt)\n                .Select(p => new { p.PhoneNumberId, p.WhatsAppBusinessNumber })\n                .FirstOrDefaultAsync();\n\n            var provider = (setting.Provider ?? string.Empty).Trim().ToUpperInvariant();\n            var phoneNumberId = phone?.PhoneNumberId;  // may be null for Pinnacle if you use WABA id\n            var baseUrl = (setting.ApiUrl ?? string.Empty).Trim().TrimEnd('/');\n\n            // 3) Template meta\n            var template = await _templateService.GetTemplateByNameAsync(\n                businessId, templateName, includeButtons: true);\n\n            if (template == null)\n                return ResponseResult.ErrorInfo(\"‚ùå Template not found or invalid.\");\n\n            // 4) Provider-specific URL + headers\n            string url;\n            using var req = new HttpRequestMessage(HttpMethod.Post, \"\");\n\n            if (provider == \"META_CLOUD\")\n            {\n                if (string.IsNullOrWhiteSpace(setting.ApiKey))\n                    return ResponseResult.ErrorInfo(\"‚ùå Meta access token (ApiKey) missing.\");\n                if (string.IsNullOrWhiteSpace(phoneNumberId))\n                    return ResponseResult.ErrorInfo(\"‚ùå PhoneNumberId not configured for Meta Cloud.\");\n\n                if (string.IsNullOrWhiteSpace(baseUrl))\n                    baseUrl = \"https://graph.facebook.com/v22.0\";\n\n                url = $\"{baseUrl}/{phoneNumberId}/messages\";\n                req.Headers.Authorization = new AuthenticationHeaderValue(\"Bearer\", setting.ApiKey);\n            }\n            else if (provider == \"PINNACLE\")\n            {\n                if (string.IsNullOrWhiteSpace(setting.ApiKey))\n                    return ResponseResult.ErrorInfo(\"‚ùå Pinnacle API key missing.\");\n\n                if (string.IsNullOrWhiteSpace(baseUrl))\n                    baseUrl = \"https://partnersv1.pinbot.ai\";\n                if (!baseUrl.EndsWith(\"/v3\", StringComparison.OrdinalIgnoreCase))\n                    baseUrl += \"/v3\";\n\n                var pathId = !string.IsNullOrWhiteSpace(setting.WabaId)\n                                ? setting.WabaId!.Trim()\n                                : (phoneNumberId ?? string.Empty).Trim();\n                if (string.IsNullOrWhiteSpace(pathId))\n                    return ResponseResult.ErrorInfo(\"‚ùå Provide WABA ID or PhoneNumberId for Pinnacle.\");\n\n                url = $\"{baseUrl}/{pathId}/messages\";\n                // put the key everywhere Pinnacle might accept it\n                req.Headers.TryAddWithoutValidation(\"apikey\", setting.ApiKey);\n                req.Headers.TryAddWithoutValidation(\"x-api-key\", setting.ApiKey);\n                req.Headers.Authorization = new AuthenticationHeaderValue(\"Apikey\", setting.ApiKey);\n            }\n            else\n            {\n                return ResponseResult.ErrorInfo($\"‚ùå Unsupported provider: {setting.Provider}\");\n            }\n\n            // 5) Payload (language field differs by provider)\n            object components = BuildTemplateComponents(template, templateParams, imageUrl, buttons);\n            object payload = (provider == \"PINNACLE\")\n                ? new\n                {\n                    messaging_product = \"whatsapp\",\n                    to = contact.PhoneNumber,\n                    type = \"template\",\n                    template = new\n                    {\n                        name = template.Name,\n                        language = template.Language,    // Pinnacle expects a string\n                        components\n                    }\n                }\n                : new\n                {\n                    messaging_product = \"whatsapp\",\n                    to = contact.PhoneNumber,\n                    type = \"template\",\n                    template = new\n                    {\n                        name = template.Name,\n                        language = new { code = template.Language }, // Meta needs { code: \"en_US\" }\n                        components\n                    }\n                };\n\n            var json = JsonSerializer.Serialize(payload, new JsonSerializerOptions\n            {\n                DefaultIgnoreCondition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull\n            });\n\n            req.RequestUri = new Uri(url);\n            req.Content = new StringContent(json, Encoding.UTF8, \"application/json\");\n\n            // 6) Send and log\n            var response = await _httpClient.SendAsync(req);\n            var responseBody = await response.Content.ReadAsStringAsync();\n            var status = response.IsSuccessStatusCode ? \"Sent\" : \"Failed\";\n\n            await _db.MessageLogs.AddAsync(new MessageLog\n            {\n                Id = Guid.NewGuid(),\n                BusinessId = businessId,\n                ContactId = contact.Id,\n                MessageContent = template.Name,\n                MediaUrl = imageUrl,\n                Status = status,\n                RawResponse = responseBody,\n                ErrorMessage = response.IsSuccessStatusCode ? null : responseBody,\n                Source = source,\n                RefMessageId = refMessageId,\n                CreatedAt = DateTime.UtcNow,\n                SentAt = DateTime.UtcNow\n            });\n\n            await _db.SaveChangesAsync();\n\n            return response.IsSuccessStatusCode\n                ? ResponseResult.SuccessInfo(\"‚úÖ Message sent successfully\", null, responseBody)\n                : ResponseResult.ErrorInfo(\"‚ùå Message failed\", null, responseBody);\n        }\n\n        public async Task<ResponseResult> SendTemplateCampaignAsync(Campaign campaign)\n        {\n            if (campaign == null || campaign.IsDeleted)\n                return ResponseResult.ErrorInfo(\"Invalid or deleted campaign.\");\n\n            var contacts = await _db.CampaignRecipients\n                .Include(r => r.Contact)\n                .Where(r => r.CampaignId == campaign.Id && r.Contact != null)\n                .ToListAsync();\n\n            if (!contacts.Any())\n                return ResponseResult.ErrorInfo(\"No contacts found for this campaign.\");\n\n            var templateName = campaign.TemplateId;\n            var templateParams = TemplateParameterHelper.ParseTemplateParams(campaign.TemplateParameters);\n            var templateMeta = await _templateService.GetTemplateByNameAsync(campaign.BusinessId, templateName, includeButtons: true);\n\n            if (templateMeta == null)\n                return ResponseResult.ErrorInfo(\"Template metadata not found.\");\n\n            int success = 0, failed = 0;\n\n            foreach (var r in contacts)\n            {\n                var result = await SendTemplateMessageToContactAsync(\n                    campaign.BusinessId,\n                    r.Contact,\n                    templateName,\n                    templateParams,\n                    campaign.ImageUrl,\n                    campaign.MultiButtons?.ToList(),\n                    source: \"campaign\",\n                    refMessageId: campaign.Id);\n\n                await _db.CampaignSendLogs.AddAsync(new CampaignSendLog\n                {\n                    Id = Guid.NewGuid(),\n                    CampaignId = campaign.Id,\n                    ContactId = r.ContactId,\n                    RecipientId = r.Id,\n                    MessageBody = campaign.MessageBody ?? templateName,\n                    TemplateId = templateName,\n                    SendStatus = result.Success ? \"Sent\" : \"Failed\",\n                    CreatedAt = DateTime.UtcNow,\n                    SentAt = DateTime.UtcNow,\n                    CreatedBy = campaign.CreatedBy\n                });\n\n                if (result.Success) success++;\n                else failed++;\n            }\n\n            await _db.SaveChangesAsync();\n            return ResponseResult.SuccessInfo($\"üì§ Sent to {success}, ‚ùå Failed for {failed}.\");\n        }\n\n        private List<object> BuildTemplateComponents(\n            TemplateMetadataDto template,\n            List<string> paramsList,\n            string? imageUrl,\n            List<CampaignButton>? buttons)\n        {\n            var components = new List<object>();\n\n            if (template.HasImageHeader && !string.IsNullOrWhiteSpace(imageUrl))\n            {\n                components.Add(new\n                {\n                    type = \"header\",\n                    parameters = new[] { new { type = \"image\", image = new { link = imageUrl } } }\n                });\n            }\n\n            if (paramsList.Any())\n            {\n                components.Add(new\n                {\n                    type = \"body\",\n                    parameters = paramsList.Select(p => new { type = \"text\", text = p }).ToList()\n                });\n            }\n\n            if (buttons != null && buttons.Any())\n            {\n                for (int i = 0; i < buttons.Count; i++)\n                {\n                    var btn = buttons[i];\n                    components.Add(new\n                    {\n                        type = \"button\",\n                        sub_type = btn.Type?.ToLower() == \"url\" ? \"url\" : \"quick_reply\",\n                        index = i.ToString(),\n                        parameters = new[] {\n                            new {\n                                type = \"text\",\n                                text = btn.Value ?? btn.Title\n                            }\n                        }\n                    });\n                }\n            }\n\n            return components;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/Validators/ValidateMessageDtoAttribute.cs",
      "sha256": "9b7355295c8cecdf6c4416a324d05f0910b3ff67e99fd35e04e397f715096a9b",
      "language": "csharp",
      "size": 1760,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\n\nnamespace xbytechat.api.Features.MessagesEngine.DTOs.Validation\n{\n    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]\n    public class ValidateMessageDtoAttribute : ValidationAttribute\n    {\n        protected override ValidationResult? IsValid(object? value, ValidationContext validationContext)\n        {\n            if (value is not SendMessageDto dto)\n                return ValidationResult.Success;\n\n            switch (dto.MessageType)\n            {\n                case MessageTypeEnum.Text:\n                    if (string.IsNullOrWhiteSpace(dto.TextContent))\n                        return new ValidationResult(\"TextContent is required for text messages.\", new[] { nameof(dto.TextContent) });\n                    break;\n\n                case MessageTypeEnum.Image:\n                    if (string.IsNullOrWhiteSpace(dto.MediaUrl))\n                        return new ValidationResult(\"MediaUrl is required for image messages.\", new[] { nameof(dto.MediaUrl) });\n                    break;\n\n                case MessageTypeEnum.Template:\n                    if (string.IsNullOrWhiteSpace(dto.TemplateName))\n                        return new ValidationResult(\"TemplateName is required for template messages.\", new[] { nameof(dto.TemplateName) });\n                    break;\n\n                case MessageTypeEnum.Cta:\n                    if (dto.CtaButtons == null || dto.CtaButtons.Count == 0)\n                        return new ValidationResult(\"CtaButtons is required for CTA messages.\", new[] { nameof(dto.CtaButtons) });\n                    break;\n            }\n\n            return ValidationResult.Success;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Controllers/AdminCouponController.cs",
      "sha256": "a7250e3bdf4896eec0bce059b867b23414630af93fb4a0bc64be94aeab683195",
      "language": "csharp",
      "size": 3449,
      "content": "#nullable enable\nusing System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Payment.Enums;\nusing xbytechat.api.Features.Payment.Models;\n\nnamespace xbytechat.api.Features.Payment.Controllers\n{\n    /// <summary>\n    /// Minimal admin-only APIs to manage coupons.\n    /// Protect via role/policy in your auth setup.\n    /// </summary>\n    [ApiController]\n    [Route(\"api/admin/payment/coupons\")]\n    [Authorize(Roles = \"SuperAdmin\")] // adjust to your actual role system\n    public sealed class AdminCouponController : ControllerBase\n    {\n        private readonly AppDbContext _db;\n\n        public AdminCouponController(AppDbContext db)\n        {\n            _db = db;\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> GetAll(CancellationToken ct)\n        {\n            var items = await _db.Coupons\n                .OrderByDescending(c => c.ValidFromUtc ?? DateTime.MinValue)\n                .ToListAsync(ct);\n\n            return Ok(new { ok = true, data = items });\n        }\n\n        public sealed class UpsertCouponRequest\n        {\n            public string Code { get; set; } = string.Empty;\n            public string? Description { get; set; }\n            public DiscountType DiscountType { get; set; }\n            public decimal DiscountValue { get; set; }\n            public DateTime? ValidFromUtc { get; set; }\n            public DateTime? ValidToUtc { get; set; }\n            public bool IsActive { get; set; } = true;\n        }\n\n        [HttpPost]\n        public async Task<IActionResult> Create([FromBody] UpsertCouponRequest req, CancellationToken ct)\n        {\n            if (string.IsNullOrWhiteSpace(req.Code))\n                return BadRequest(new { ok = false, message = \"Code is required.\" });\n\n            var exists = await _db.Coupons.AnyAsync(c => c.Code == req.Code, ct);\n            if (exists)\n                return Conflict(new { ok = false, message = \"Coupon code already exists.\" });\n\n            var coupon = new Coupon\n            {\n                Id = Guid.NewGuid(),\n                Code = req.Code,\n                Description = req.Description,\n                DiscountType = req.DiscountType,\n                DiscountValue = req.DiscountValue,\n                ValidFromUtc = req.ValidFromUtc,\n                ValidToUtc = req.ValidToUtc,\n                IsActive = req.IsActive\n            };\n\n            _db.Coupons.Add(coupon);\n            await _db.SaveChangesAsync(ct);\n\n            return Ok(new { ok = true, data = coupon });\n        }\n\n        [HttpPut(\"{id:guid}\")]\n        public async Task<IActionResult> Update(Guid id, [FromBody] UpsertCouponRequest req, CancellationToken ct)\n        {\n            var coupon = await _db.Coupons.FirstOrDefaultAsync(c => c.Id == id, ct);\n            if (coupon is null)\n                return NotFound(new { ok = false, message = \"Coupon not found.\" });\n\n            coupon.Description = req.Description;\n            coupon.DiscountType = req.DiscountType;\n            coupon.DiscountValue = req.DiscountValue;\n            coupon.ValidFromUtc = req.ValidFromUtc;\n            coupon.ValidToUtc = req.ValidToUtc;\n            coupon.IsActive = req.IsActive;\n\n            await _db.SaveChangesAsync(ct);\n\n            return Ok(new { ok = true, data = coupon });\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Controllers/AdminPaymentMaintenanceController.cs",
      "sha256": "c9aaa1660f210e61a4e34834ffeea027655539cc02ce774b08f977728521cb15",
      "language": "csharp",
      "size": 1197,
      "content": "#nullable enable\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.Payment.Services;\n\nnamespace xbytechat.api.Features.Payment.Controllers\n{\n    /// <summary>\n    /// Admin-only endpoints for running payment/subscription maintenance tasks.\n    /// In production, prefer a scheduled job instead of manual calling.\n    /// </summary>\n    [ApiController]\n    [Route(\"api/admin/payment/maintenance\")]\n    [Authorize(Roles = \"SuperAdmin\")] // adjust to your actual admin role\n    public sealed class AdminPaymentMaintenanceController : ControllerBase\n    {\n        private readonly SubscriptionLifecycleService _lifecycle;\n\n        public AdminPaymentMaintenanceController(SubscriptionLifecycleService lifecycle)\n        {\n            _lifecycle = lifecycle;\n        }\n\n        /// <summary>\n        /// Runs subscription lifecycle sync manually.\n        /// </summary>\n        [HttpPost(\"run-lifecycle\")]\n        public async Task<IActionResult> RunLifecycle(CancellationToken ct)\n        {\n            await _lifecycle.RunAsync(ct);\n            return Ok(new { ok = true });\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Controllers/PaymentController.cs",
      "sha256": "23dfec21d19333100bc4131f346e12e04cc1afed552b2909c199d79444029a98",
      "language": "csharp",
      "size": 7219,
      "content": "#nullable enable\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.Payment.DTOs;\nusing xbytechat.api.Features.Payment.Services;\nusing xbytechat.api.Shared; // assuming User.GetBusinessId() lives here or similar\n\nnamespace xbytechat.api.Features.Payment.Controllers\n{\n    [ApiController]\n    [Route(\"api/payment\")]\n    [Authorize] // must be authenticated\n    public sealed class PaymentController : ControllerBase\n    {\n        private readonly ISubscriptionService _subscriptions;\n        private readonly IInvoiceService _invoices;\n        private readonly ICouponService _coupons;\n        private readonly IPaymentGatewayService _gateway;\n        private readonly ISubscriptionCheckoutService _checkout;\n        private readonly PaymentOverviewService _overview;\n        public PaymentController(\n            ISubscriptionService subscriptions,\n            IInvoiceService invoices,\n            ICouponService coupons,\n            IPaymentGatewayService gateway,\n            ISubscriptionCheckoutService checkout,\n            PaymentOverviewService overview)\n        {\n            _subscriptions = subscriptions;\n            _invoices = invoices;\n            _coupons = coupons;\n            _gateway = gateway;\n            _checkout = checkout;\n            _overview = overview;\n        }\n\n        /// <summary>\n        /// Returns the current subscription for the logged-in business.\n        /// </summary>\n        [HttpGet(\"subscription\")]\n        public async Task<IActionResult> GetCurrentSubscription(CancellationToken ct)\n        {\n            var businessId = User.GetBusinessId(); // your existing extension\n            var sub = await _subscriptions.GetCurrentForBusinessAsync(businessId, ct);\n            return Ok(new { ok = true, data = sub });\n        }\n\n        /// <summary>\n        /// Creates or updates subscription for the logged-in business.\n        /// NOTE:\n        /// - For MVP this directly activates.\n        /// - Later, call only after payment confirmation.\n        /// </summary>\n        [HttpPost(\"subscription\")]\n        public async Task<IActionResult> CreateOrUpdateSubscription(\n            [FromBody] CreateSubscriptionRequestDto request,\n            CancellationToken ct)\n        {\n            var businessId = User.GetBusinessId();\n            var sub = await _subscriptions.CreateOrUpdateSubscriptionAsync(businessId, request, ct);\n            return Ok(new { ok = true, data = sub });\n        }\n\n        /// <summary>\n        /// Marks the current subscription to cancel at period end.\n        /// </summary>\n        [HttpPost(\"subscription/cancel-at-period-end\")]\n        public async Task<IActionResult> CancelAtPeriodEnd(CancellationToken ct)\n        {\n            var businessId = User.GetBusinessId();\n            var ok = await _subscriptions.MarkCancelAtPeriodEndAsync(businessId, ct);\n            return Ok(new { ok });\n        }\n\n        /// <summary>\n        /// Reactivates auto-renew for the current subscription.\n        /// </summary>\n        [HttpPost(\"subscription/reactivate\")]\n        public async Task<IActionResult> Reactivate(CancellationToken ct)\n        {\n            var businessId = User.GetBusinessId();\n            var ok = await _subscriptions.ReactivateAutoRenewAsync(businessId, ct);\n            return Ok(new { ok });\n        }\n\n        /// <summary>\n        /// Returns all invoices for the logged-in business.\n        /// </summary>\n        [HttpGet(\"invoices\")]\n        public async Task<IActionResult> GetInvoices(CancellationToken ct)\n        {\n            var businessId = User.GetBusinessId();\n            var items = await _invoices.GetInvoicesForBusinessAsync(businessId, ct);\n            return Ok(new { ok = true, data = items });\n        }\n\n        /// <summary>\n        /// Returns a specific invoice.\n        /// </summary>\n        [HttpGet(\"invoices/{invoiceId:guid}\")]\n        public async Task<IActionResult> GetInvoice(Guid invoiceId, CancellationToken ct)\n        {\n            var businessId = User.GetBusinessId();\n            var invoice = await _invoices.GetInvoiceAsync(businessId, invoiceId, ct);\n            if (invoice is null)\n                return NotFound(new { ok = false, message = \"Invoice not found.\" });\n\n            return Ok(new { ok = true, data = invoice });\n        }\n\n        /// <summary>\n        /// Validates a coupon code for the current context (e.g. before checkout).\n        /// </summary>\n        [HttpGet(\"coupon/validate\")]\n        public async Task<IActionResult> ValidateCoupon(\n            [FromQuery] string code,\n            [FromQuery] string currency = \"INR\",\n            CancellationToken ct = default)\n        {\n            var coupon = await _coupons.ValidateCouponAsync(code, currency, ct);\n            if (coupon is null)\n                return Ok(new { ok = false, message = \"Invalid or expired coupon.\" });\n\n            return Ok(new { ok = true, data = coupon });\n        }\n\n        /// <summary>\n        /// Creates a payment session for the given invoice and returns redirect info.\n        /// Frontend should call this before opening Razorpay checkout.\n        /// </summary>\n        [HttpPost(\"invoices/{invoiceId:guid}/checkout\")]\n        public async Task<IActionResult> CreateCheckoutForInvoice(\n            Guid invoiceId,\n            [FromBody] CreatePaymentSessionRequestDto body,\n            CancellationToken ct)\n        {\n            var businessId = User.GetBusinessId();\n\n            if (body.InvoiceId.HasValue && body.InvoiceId.Value != invoiceId)\n            {\n                return BadRequest(new { ok = false, message = \"Invoice id mismatch.\" });\n            }\n\n            var session = await _gateway.CreatePaymentSessionForInvoiceAsync(\n                businessId,\n                invoiceId,\n                body.CouponCode,\n                ct);\n\n            return Ok(new { ok = true, data = session });\n        }\n        /// <summary>\n        /// Starts subscription checkout for a selected plan:\n        /// - Creates invoice with coupon+GST\n        /// - Creates Razorpay order\n        /// - Returns session/redirect info for frontend.\n        /// </summary>\n        [HttpPost(\"subscribe/checkout\")]\n        public async Task<IActionResult> StartSubscriptionCheckout(\n            [FromBody] CreateSubscriptionRequestDto request,\n            CancellationToken ct)\n        {\n            var businessId = User.GetBusinessId();\n\n            var session = await _checkout.StartSubscriptionCheckoutAsync(\n                businessId,\n                request,\n                ct);\n\n            return Ok(new { ok = true, data = session });\n        }\n        /// <summary>\n        /// Returns a compact payment overview for the logged-in business.\n        /// Intended for Billing page + Account Insights integration.\n        /// </summary>\n        [HttpGet(\"overview\")]\n        public async Task<IActionResult> GetOverview(CancellationToken ct)\n        {\n            var businessId = User.GetBusinessId();\n            var data = await _overview.GetAsync(businessId, ct);\n            return Ok(new { ok = true, data });\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Controllers/PaymentWebhookController.cs",
      "sha256": "9e6af3395a6e0c4478a6573d677c7bc86b012c5d544459cf7b73eba9f43ae88f",
      "language": "csharp",
      "size": 6922,
      "content": "#nullable enable\nusing System;\nusing System.IO;\nusing System.Security.Cryptography;\nusing System.Text;\nusing System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Options;\nusing xbytechat.api.Features.Payment.Enums;\nusing xbytechat.api.Features.Payment.Models;\nusing xbytechat.api.Features.Payment.Options;\nusing xbytechat.api.Features.Payment.Services;\n\nnamespace xbytechat.api.Features.Payment.Controllers\n{\n    [ApiController]\n    [Route(\"api/payment/webhook/razorpay\")]\n    public sealed class PaymentWebhookController : ControllerBase\n    {\n        private readonly AppDbContext _db;\n        private readonly RazorpayOptions _opts;\n        private readonly ISubscriptionService _subscriptions;\n\n        public PaymentWebhookController(\n            AppDbContext db,\n            IOptions<RazorpayOptions> opts,\n            ISubscriptionService subscriptions)\n        {\n            _db = db;\n            _opts = opts.Value;\n            _subscriptions = subscriptions;\n        }\n\n        [HttpPost]\n        public async Task<IActionResult> Handle(CancellationToken ct)\n        {\n            // 1. Read body\n            string body;\n            using (var reader = new StreamReader(Request.Body, Encoding.UTF8))\n            {\n                body = await reader.ReadToEndAsync(ct);\n            }\n\n            // 2. Verify signature\n            var signature = Request.Headers[\"X-Razorpay-Signature\"].ToString();\n            if (!VerifySignature(body, signature, _opts.WebhookSecret))\n            {\n                return Unauthorized();\n            }\n\n            // 3. Parse minimal fields\n            using var doc = JsonDocument.Parse(body);\n            var root = doc.RootElement;\n\n            // Webhook schema differs by event; we read what we need:\n            // payment.captured / payment.failed etc.\n            var eventType = root.GetProperty(\"event\").GetString();\n\n            if (string.IsNullOrWhiteSpace(eventType))\n                return Ok(); // ignore unknown\n\n            if (eventType.StartsWith(\"payment.\"))\n            {\n                var payload = root.GetProperty(\"payload\").GetProperty(\"payment\").GetProperty(\"entity\");\n                var paymentId = payload.GetProperty(\"id\").GetString();\n                var orderId = payload.TryGetProperty(\"order_id\", out var oidEl) ? oidEl.GetString() : null;\n                var status = payload.GetProperty(\"status\").GetString();\n\n                if (!string.IsNullOrWhiteSpace(orderId))\n                {\n                    var tx = await _db.PaymentTransactions\n                        .FirstOrDefaultAsync(t => t.GatewayOrderId == orderId, ct);\n\n                    if (tx != null)\n                    {\n                        await ApplyPaymentStatusAsync(tx, paymentId, status, ct);\n                    }\n                }\n            }\n\n            // You may also handle order.paid events similarly.\n\n            return Ok();\n        }\n\n        private static bool VerifySignature(string body, string signature, string secret)\n        {\n            if (string.IsNullOrWhiteSpace(signature) || string.IsNullOrWhiteSpace(secret))\n                return false;\n\n            var keyBytes = Encoding.UTF8.GetBytes(secret);\n            var bodyBytes = Encoding.UTF8.GetBytes(body);\n\n            using var hmac = new HMACSHA256(keyBytes);\n            var hash = hmac.ComputeHash(bodyBytes);\n            var generated = BitConverter.ToString(hash).Replace(\"-\", \"\").ToLowerInvariant();\n\n            return string.Equals(generated, signature, StringComparison.OrdinalIgnoreCase);\n        }\n\n        private async Task ApplyPaymentStatusAsync(\n            PaymentTransaction tx,\n            string? paymentId,\n            string? paymentStatus,\n            CancellationToken ct)\n        {\n            // Normalize\n            paymentStatus = paymentStatus?.ToLowerInvariant();\n\n            if (paymentStatus == \"captured\" || paymentStatus == \"authorized\" || paymentStatus == \"paid\")\n            {\n                // ---- SUCCESS ----\n                tx.Status = PaymentStatus.Success;\n                tx.GatewayPaymentId = paymentId;\n                tx.CompletedAtUtc = DateTime.UtcNow;\n\n                var invoice = await _db.Invoices\n                    .Include(i => i.Plan)\n                    .FirstOrDefaultAsync(i => i.Id == tx.InvoiceId, ct);\n\n                if (invoice != null)\n                {\n                    invoice.Status = InvoiceStatus.Paid;\n                    invoice.PaidAtUtc = DateTime.UtcNow;\n                }\n\n                // If this invoice is for a subscription (has PlanId + BillingCycle),\n                // we activate/update subscription via SubscriptionService.\n                if (invoice?.PlanId != null && invoice.BillingCycle != null)\n                {\n                    await _subscriptions.CreateOrUpdateSubscriptionAsync(\n                        tx.BusinessId,\n                        new DTOs.CreateSubscriptionRequestDto\n                        {\n                            PlanId = invoice.PlanId.Value,\n                            BillingCycle = invoice.BillingCycle.Value,\n                            // Coupon already baked into invoice; no need to send here.\n                            CouponCode = null\n                        },\n                        ct);\n                }\n            }\n            else if (paymentStatus == \"failed\")\n            {\n                // ---- FAILURE ----\n                tx.Status = PaymentStatus.Failed;\n                tx.GatewayPaymentId = paymentId;\n                tx.CompletedAtUtc = DateTime.UtcNow;\n\n                var invoice = await _db.Invoices\n                    .FirstOrDefaultAsync(i => i.Id == tx.InvoiceId, ct);\n\n                if (invoice != null)\n                {\n                    // Keep invoice open for retry / dunning if it was draft.\n                    if (invoice.Status == InvoiceStatus.Draft)\n                    {\n                        invoice.Status = InvoiceStatus.Open;\n                    }\n\n                    // If this was a renewal / subscription-linked invoice,\n                    // mark subscription as PastDue so AccessGuard can block.\n                    if (invoice.SubscriptionId != null)\n                    {\n                        var sub = await _db.Subscriptions\n                            .FirstOrDefaultAsync(s => s.Id == invoice.SubscriptionId.Value, ct);\n\n                        if (sub != null &&\n                            (sub.Status == SubscriptionStatus.Active ||\n                             sub.Status == SubscriptionStatus.Grace))\n                        {\n                            sub.Status = SubscriptionStatus.PastDue;\n                        }\n                    }\n                }\n            }\n\n            await _db.SaveChangesAsync(ct);\n        }\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/DTOs/CouponDto.cs",
      "sha256": "41bbaafa2e7c60f2756dc4bf42958e2a72e070a171b411b7f9d313534cd3e94f",
      "language": "csharp",
      "size": 562,
      "content": "#nullable enable\nusing System;\nusing xbytechat.api.Features.Payment.Enums;\n\nnamespace xbytechat.api.Features.Payment.DTOs\n{\n    public class CouponDto\n    {\n        public Guid Id { get; set; }\n        public string Code { get; set; } = string.Empty;\n        public string? Description { get; set; }\n\n        public DiscountType DiscountType { get; set; }\n        public decimal DiscountValue { get; set; }\n\n        public bool IsActive { get; set; }\n        public DateTime? ValidFromUtc { get; set; }\n        public DateTime? ValidToUtc { get; set; }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/DTOs/CreatePaymentSessionRequestDto.cs",
      "sha256": "9455eaa06f4ae1ebbc9df4bde78baa270d1261b9314f5e4227ea6162563180b8",
      "language": "csharp",
      "size": 836,
      "content": "#nullable enable\nusing System;\n\nnamespace xbytechat.api.Features.Payment.DTOs\n{\n    /// <summary>\n    /// Request to start a payment for a subscription or invoice.\n    /// Maps to a gateway checkout / payment link.\n    /// </summary>\n    public class CreatePaymentSessionRequestDto\n    {\n        /// <summary>\n        /// Optional: target subscription change (upgrade/downgrade/renewal).\n        /// </summary>\n        public Guid? SubscriptionId { get; set; }\n\n        /// <summary>\n        /// Optional: invoice to pay. If null, backend can construct\n        /// a new invoice based on plan selection.\n        /// </summary>\n        public Guid? InvoiceId { get; set; }\n\n        /// <summary>\n        /// Optional coupon code to apply at time of payment.\n        /// </summary>\n        public string? CouponCode { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/DTOs/CreateSubscriptionRequestDto.cs",
      "sha256": "a6fa013d724c01c7ceb8a165e931c3722e74e4637072483a2ede13ccf46530ba",
      "language": "csharp",
      "size": 807,
      "content": "#nullable enable\nusing System;\nusing xbytechat.api.Features.Payment.Enums;\n\nnamespace xbytechat.api.Features.Payment.DTOs\n{\n    /// <summary>\n    /// Request to start or change a subscription for the current business.\n    /// Payment authorization will be handled via a separate payment flow.\n    /// </summary>\n    public class CreateSubscriptionRequestDto\n    {\n        /// <summary>\n        /// Target plan to subscribe to.\n        /// </summary>\n        public Guid PlanId { get; set; }\n\n        /// <summary>\n        /// Selected billing cycle (Monthly / Yearly).\n        /// </summary>\n        public BillingCycle BillingCycle { get; set; }\n\n        /// <summary>\n        /// Optional coupon code the user wants to apply.\n        /// </summary>\n        public string? CouponCode { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/DTOs/InvoiceDto.cs",
      "sha256": "9f69933f3b4e85863294c4806e684a8bc1b513c1ba62cb13a3920eaad9c95f95",
      "language": "csharp",
      "size": 983,
      "content": "#nullable enable\nusing System;\nusing System.Collections.Generic;\nusing xbytechat.api.Features.Payment.Enums;\n\nnamespace xbytechat.api.Features.Payment.DTOs\n{\n    public class InvoiceDto\n    {\n        public Guid Id { get; set; }\n        public string InvoiceNumber { get; set; } = string.Empty;\n\n        public Guid BusinessId { get; set; }\n        public Guid? SubscriptionId { get; set; }\n\n        public InvoiceStatus Status { get; set; }\n\n        public decimal SubtotalAmount { get; set; }\n        public decimal DiscountAmount { get; set; }\n        public decimal TaxAmount { get; set; }\n        public decimal TotalAmount { get; set; }\n\n        public string Currency { get; set; } = \"INR\";\n        public string? AppliedCouponCode { get; set; }\n\n        public DateTime IssuedAtUtc { get; set; }\n        public DateTime? DueAtUtc { get; set; }\n        public DateTime? PaidAtUtc { get; set; }\n\n        public List<InvoiceLineItemDto> LineItems { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/DTOs/InvoiceLineItemDto.cs",
      "sha256": "903f7a64b848f9c8d215a83e90a855a76e27818c57c23ecabb47c9eeb1203668",
      "language": "csharp",
      "size": 371,
      "content": "#nullable enable\nusing System;\n\nnamespace xbytechat.api.Features.Payment.DTOs\n{\n    public class InvoiceLineItemDto\n    {\n        public Guid Id { get; set; }\n        public string Description { get; set; } = string.Empty;\n        public decimal Quantity { get; set; }\n        public decimal UnitPrice { get; set; }\n        public decimal LineTotal { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/DTOs/PaymentOverviewDto.cs",
      "sha256": "dabb719741973867fa712fad3ea28e7ef6a4aeee44d2b8950671fee9cadce0df",
      "language": "csharp",
      "size": 648,
      "content": "#nullable enable\nusing System;\nusing System.Collections.Generic;\nusing xbytechat.api.Features.Payment.Enums;\n\nnamespace xbytechat.api.Features.Payment.DTOs\n{\n    public sealed class PaymentOverviewDto\n    {\n        public SubscriptionDto? CurrentSubscription { get; set; }\n\n        public decimal? LastInvoiceAmount { get; set; }\n        public DateTime? LastInvoicePaidAtUtc { get; set; }\n\n        public decimal? NextInvoiceEstimatedAmount { get; set; }\n        public DateTime? CurrentPeriodEndUtc { get; set; }\n\n        public bool CanUseCoreFeatures { get; set; }\n\n        public List<InvoiceDto> RecentInvoices { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/DTOs/PaymentSessionResponseDto.cs",
      "sha256": "7a5d87a6170743bc39d51094df42be0d45c03ed96fd09015a3c52f073bea6177",
      "language": "csharp",
      "size": 656,
      "content": "#nullable enable\n\nnamespace xbytechat.api.Features.Payment.DTOs\n{\n    /// <summary>\n    /// Response containing info needed by the frontend to redirect the user\n    /// to the payment gateway (hosted page, popup, etc.).\n    /// </summary>\n    public class PaymentSessionResponseDto\n    {\n        /// <summary>\n        /// Internal id for tracking this session/intent.\n        /// </summary>\n        public string SessionId { get; set; } = string.Empty;\n\n        /// <summary>\n        /// URL to redirect the user to (Razorpay Checkout, Stripe Checkout, etc.).\n        /// </summary>\n        public string RedirectUrl { get; set; } = string.Empty;\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/DTOs/PaymentTransactionDto.cs",
      "sha256": "89a71e90b7c469709d0ef2a6f79dd885fc8a74021c427949cd88476f1449f5f6",
      "language": "csharp",
      "size": 828,
      "content": "#nullable enable\nusing System;\nusing xbytechat.api.Features.Payment.Enums;\n\nnamespace xbytechat.api.Features.Payment.DTOs\n{\n    public class PaymentTransactionDto\n    {\n        public Guid Id { get; set; }\n        public Guid BusinessId { get; set; }\n        public Guid? SubscriptionId { get; set; }\n        public Guid? InvoiceId { get; set; }\n\n        public decimal Amount { get; set; }\n        public string Currency { get; set; } = \"INR\";\n\n        public PaymentStatus Status { get; set; }\n        public string Gateway { get; set; } = string.Empty;\n        public string? GatewayPaymentId { get; set; }\n        public string? GatewayOrderId { get; set; }\n\n        public string? FailureReason { get; set; }\n        public DateTime CreatedAtUtc { get; set; }\n        public DateTime? CompletedAtUtc { get; set; }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/DTOs/SubscriptionDto.cs",
      "sha256": "436fc732e13a70d4003832129b9324c5f880ed8876f3f97e1af5426cd9a553b1",
      "language": "csharp",
      "size": 951,
      "content": "#nullable enable\nusing System;\nusing xbytechat.api.Features.Payment.Enums;\n\nnamespace xbytechat.api.Features.Payment.DTOs\n{\n    /// <summary>\n    /// Read model for exposing subscription info to UI / API.\n    /// </summary>\n    public class SubscriptionDto\n    {\n        public Guid Id { get; set; }\n        public Guid BusinessId { get; set; }\n        public Guid PlanId { get; set; }\n\n        public string PlanName { get; set; } = string.Empty;\n        public SubscriptionStatus Status { get; set; }\n        public BillingCycle BillingCycle { get; set; }\n\n        public DateTime CurrentPeriodStartUtc { get; set; }\n        public DateTime CurrentPeriodEndUtc { get; set; }\n        public DateTime? TrialEndsAtUtc { get; set; }\n\n        public bool AutoRenew { get; set; }\n        public bool CancelAtPeriodEnd { get; set; }\n\n        public string? GatewayCustomerId { get; set; }\n        public string? GatewaySubscriptionId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Enums/BillingCycle.cs",
      "sha256": "9cb8996565e691a52d0699158ee47db0492cd78d7cde8f8cdd369e9658afa428",
      "language": "csharp",
      "size": 268,
      "content": "namespace xbytechat.api.Features.Payment.Enums\n{\n    /// <summary>\n    /// How often a subscription renews.\n    /// </summary>\n    public enum BillingCycle\n    {\n        Monthly = 1,\n        Yearly = 2\n        // Add Quarterly or other cycles later if needed.\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Enums/DiscountType.cs",
      "sha256": "567a3ce46956929d0715e847858ef74a1c7f10788dcfaba8c5dc450127da8991",
      "language": "csharp",
      "size": 415,
      "content": "namespace xbytechat.api.Features.Payment.Enums\n{\n    /// <summary>\n    /// Defines how a discount value should be applied.\n    /// </summary>\n    public enum DiscountType\n    {\n        /// <summary>\n        /// Fixed amount off (e.g. ‚Çπ500 off).\n        /// </summary>\n        FixedAmount = 1,\n\n        /// <summary>\n        /// Percentage off (e.g. 20% off).\n        /// </summary>\n        Percentage = 2\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Enums/InvoiceStatus.cs",
      "sha256": "74e0b1ffe3e333aa1c9937858e5c3f004e1b473df0fda25363636e6134afce89",
      "language": "csharp",
      "size": 256,
      "content": "namespace xbytechat.api.Features.Payment.Enums\n{\n    /// <summary>\n    /// State of an invoice in the billing lifecycle.\n    /// </summary>\n    public enum InvoiceStatus\n    {\n        Draft = 0,\n        Open = 1,\n        Paid = 2,\n        Void = 3\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Enums/PaymentStatus.cs",
      "sha256": "7655e3b36f220768e7ebee978d19075ef1481a80511d6f14a01ae6a7bdc10acc",
      "language": "csharp",
      "size": 815,
      "content": "namespace xbytechat.api.Features.Payment.Enums\n{\n    /// <summary>\n    /// Status of a single payment transaction with a gateway.\n    /// </summary>\n    public enum PaymentStatus\n    {\n        /// <summary>\n        /// Initiated but not confirmed yet (checkout created, awaiting gateway result).\n        /// </summary>\n        Pending = 0,\n\n        /// <summary>\n        /// Successfully captured/confirmed by the gateway.\n        /// </summary>\n        Success = 1,\n\n        /// <summary>\n        /// Failed/declined; no funds captured.\n        /// </summary>\n        Failed = 2,\n\n        /// <summary>\n        /// Refunded (partial or full).\n        /// </summary>\n        Refunded = 3,\n\n        /// <summary>\n        /// Chargeback/dispute or manual reversal.\n        /// </summary>\n        Reversed = 4\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Enums/SubscriptionStatus.cs",
      "sha256": "cce65de55c8f3cc221dead81b2dae70a372d248393d2095257ebd12ecee41d74",
      "language": "csharp",
      "size": 1312,
      "content": "namespace xbytechat.api.Features.Payment.Enums\n{\n    /// <summary>\n    /// Represents the lifecycle state of a business account's subscription.\n    /// This will drive access control and account insights.\n    /// </summary>\n    public enum SubscriptionStatus\n    {\n        /// <summary>\n        /// Newly created trial, within the active trial window.\n        /// </summary>\n        Trial = 0,\n\n        /// <summary>\n        /// Active and fully paid. All subscribed features are enabled.\n        /// </summary>\n        Active = 1,\n\n        /// <summary>\n        /// Payment failed or not received; retry / dunning in progress.\n        /// </summary>\n        PastDue = 2,\n\n        /// <summary>\n        /// In grace window before hard suspension.\n        /// </summary>\n        Grace = 3,\n\n        /// <summary>\n        /// Marked to cancel at the end of the current billing period.\n        /// </summary>\n        CancelAtPeriodEnd = 4,\n\n        /// <summary>\n        /// Fully cancelled with no future renewals.\n        /// </summary>\n        Cancelled = 5,\n\n        /// <summary>\n        /// Access blocked due to non-payment / policy violation.\n        /// </summary>\n        Suspended = 6,\n\n        /// <summary>\n        /// Trial ended without activation.\n        /// </summary>\n        Expired = 7\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Filters/RequireActiveSubscriptionAttribute.cs",
      "sha256": "d47615d45bb8244c929876afa5c4fa1bcae07a84a306c22a99231ca705825d3e",
      "language": "csharp",
      "size": 2129,
      "content": "#nullable enable\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.AspNetCore.Mvc.Filters;\nusing xbytechat.api.Features.Payment.Services;\nusing xbytechat.api.Shared; // for User.GetBusinessId()\n\nnamespace xbytechat.api.Features.Payment.Filters\n{\n    /// <summary>\n    /// Use [RequireActiveSubscription] on controllers/actions that should be accessible\n    /// only when the business has an allowed subscription state.\n    /// \n    /// Logic is delegated to IAccessGuard so rules stay centralized.\n    /// </summary>\n    public sealed class RequireActiveSubscriptionAttribute : TypeFilterAttribute\n    {\n        public RequireActiveSubscriptionAttribute()\n            : base(typeof(RequireActiveSubscriptionFilter))\n        {\n        }\n\n        private sealed class RequireActiveSubscriptionFilter : IAsyncActionFilter\n        {\n            private readonly IAccessGuard _accessGuard;\n\n            public RequireActiveSubscriptionFilter(IAccessGuard accessGuard)\n            {\n                _accessGuard = accessGuard;\n            }\n\n            public async Task OnActionExecutionAsync(\n     ActionExecutingContext context,\n     ActionExecutionDelegate next)\n            {\n                var user = context.HttpContext.User;\n\n                // Let [Authorize] handle unauthenticated cases.\n                if (user?.Identity is null || !user.Identity.IsAuthenticated)\n                {\n                    await next();\n                    return;\n                }\n\n                var businessId = user.GetBusinessId();\n\n                var result = await _accessGuard.CheckAsync(businessId);\n\n                if (!result.Allowed)\n                {\n                    context.Result = new ObjectResult(new\n                    {\n                        ok = false,\n                        status = result.Status?.ToString(),\n                        message = result.Message\n                    })\n                    {\n                        StatusCode = 403\n                    };\n\n                    return;\n                }\n\n                await next();\n            }\n\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Models/Coupon.cs",
      "sha256": "49fd7b2d4f6b5ca068b32f6cf499b9eb2c0b35936b119bcc6763c81108a8640c",
      "language": "csharp",
      "size": 2301,
      "content": "#nullable enable\nusing System;\nusing xbytechat.api.Features.Payment.Enums;\n\nnamespace xbytechat.api.Features.Payment.Models\n{\n    /// <summary>\n    /// Represents a promotional coupon that can apply discounts\n    /// on subscriptions or invoices (like big players do).\n    /// </summary>\n    public class Coupon\n    {\n        public Guid Id { get; set; }\n\n        /// <summary>\n        /// Unique code entered by the user, e.g. \"LAUNCH20\".\n        /// </summary>\n        public string Code { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Human-friendly description for admins.\n        /// </summary>\n        public string? Description { get; set; }\n\n        /// <summary>\n        /// How the discount is calculated (fixed / percentage).\n        /// </summary>\n        public DiscountType DiscountType { get; set; }\n\n        /// <summary>\n        /// Discount value:\n        /// - If Percentage: 10 = 10%\n        /// - If FixedAmount: absolute amount in invoice currency (e.g. 500 = ‚Çπ500).\n        /// </summary>\n        public decimal DiscountValue { get; set; }\n\n        /// <summary>\n        /// Optional: limit total number of times the coupon can be used globally.\n        /// Null = unlimited.\n        /// </summary>\n        public int? MaxRedemptions { get; set; }\n\n        /// <summary>\n        /// Optional: limit per business usage count.\n        /// Null = no per-business cap.\n        /// </summary>\n        public int? MaxRedemptionsPerBusiness { get; set; }\n\n        /// <summary>\n        /// Optional: apply only to a specific plan.\n        /// Null = can apply to any eligible plan.\n        /// </summary>\n        public Guid? PlanId { get; set; }\n\n        /// <summary>\n        /// Start time of coupon validity (UTC).\n        /// </summary>\n        public DateTime? ValidFromUtc { get; set; }\n\n        /// <summary>\n        /// End time of coupon validity (UTC).\n        /// </summary>\n        public DateTime? ValidToUtc { get; set; }\n\n        /// <summary>\n        /// Whether this coupon is currently active (admin toggle).\n        /// </summary>\n        public bool IsActive { get; set; } = true;\n\n        /// <summary>\n        /// Optional metadata or rules (JSON) for future logic.\n        /// </summary>\n        public string? MetaJson { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Models/Invoice.cs",
      "sha256": "dad830cfae5ab10bc3d1cdac0dfcbeb4b0b5c1124bb064985edf72679a3f9eac",
      "language": "csharp",
      "size": 3293,
      "content": "#nullable enable\nusing System;\nusing System.Collections.Generic;\nusing xbytechat.api.Features.Payment.Enums;\nusing xbytechat.api.Features.BusinessModule.Models;\nusing xbytechat.api.Features.AccessControl.Models;\n\nnamespace xbytechat.api.Features.Payment.Models\n{\n    /// <summary>\n    /// Represents a bill issued to a business for a period, plan, or usage.\n    /// Can be mapped to one or more payment transactions.\n    /// </summary>\n    public class Invoice\n    {\n        public Guid Id { get; set; }\n\n        /// <summary>\n        /// Business this invoice belongs to.\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// Optional related subscription for recurring charges.\n        /// </summary>\n        public Guid? SubscriptionId { get; set; }\n\n        /// <summary>\n        /// Human-readable invoice number (e.g. \"XP-2025-000123\").\n        /// </summary>\n        public string InvoiceNumber { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Current status of the invoice (Draft/Open/Paid/Void).\n        /// </summary>\n        public InvoiceStatus Status { get; set; }\n\n        /// <summary>\n        /// Total before tax.\n        /// </summary>\n        public decimal SubtotalAmount { get; set; }\n\n        /// <summary>\n        /// Total tax amount (GST/VAT etc.) if applicable.\n        /// </summary>\n        public decimal TaxAmount { get; set; }\n\n        /// <summary>\n        /// Grand total (Subtotal + Tax - Discounts).\n        /// </summary>\n        public decimal TotalAmount { get; set; }\n\n        /// <summary>\n        /// ISO currency code, e.g. \"INR\".\n        /// </summary>\n        public string Currency { get; set; } = \"INR\";\n\n        /// <summary>\n        /// When invoice was issued (UTC).\n        /// </summary>\n        public DateTime IssuedAtUtc { get; set; }\n\n        /// <summary>\n        /// When payment is due (UTC).\n        /// </summary>\n        public DateTime? DueAtUtc { get; set; }\n\n        /// <summary>\n        /// When invoice was fully paid (UTC).\n        /// </summary>\n        public DateTime? PaidAtUtc { get; set; }\n\n        /// <summary>\n        /// Optional free-form notes (e.g., terms, adjustments).\n        /// </summary>\n        public string? Notes { get; set; }\n\n        public string? AppliedCouponCode { get; set; }\n\n        /// <summary>\n        /// Total discount amount applied on this invoice (>= 0).\n        /// </summary>\n        public decimal DiscountAmount { get; set; }\n\n        public string? TaxBreakdownJson { get; set; }\n\n\n        /// <summary>\n        /// Optional: plan this invoice refers to (for subscription charges).\n        /// </summary>\n        public Guid? PlanId { get; set; }\n\n        /// <summary>\n        /// Optional: billing cycle for this invoice's subscription charge.\n        /// </summary>\n        public BillingCycle? BillingCycle { get; set; }\n        // ---- Navigation ----\n\n        public Business? Business { get; set; }\n        public Subscription? Subscription { get; set; }\n\n        public ICollection<InvoiceLineItem> LineItems { get; set; } = new List<InvoiceLineItem>();\n        public ICollection<PaymentTransaction> Payments { get; set; } = new List<PaymentTransaction>();\n\n        public Plan? Plan { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Models/InvoiceLineItem.cs",
      "sha256": "7a577bfd7803d7492400518e9efb53c110d0128b947e2fa14c66cf780bb4fa6d",
      "language": "csharp",
      "size": 1364,
      "content": "#nullable enable\nusing System;\n\nnamespace xbytechat.api.Features.Payment.Models\n{\n    /// <summary>\n    /// Represents a single line item on an invoice\n    /// (plan fee, add-on, usage charge, discount as negative, etc.).\n    /// </summary>\n    public class InvoiceLineItem\n    {\n        public Guid Id { get; set; }\n\n        /// <summary>\n        /// Parent invoice.\n        /// </summary>\n        public Guid InvoiceId { get; set; }\n\n        /// <summary>\n        /// Short description shown on the invoice.\n        /// e.g. \"Pro Plan - Monthly\", \"WhatsApp Usage - Jan 2025\"\n        /// </summary>\n        public string Description { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Logical quantity (months, message blocks, add-ons).\n        /// </summary>\n        public decimal Quantity { get; set; } = 1m;\n\n        /// <summary>\n        /// Price per unit (before tax).\n        /// </summary>\n        public decimal UnitPrice { get; set; }\n\n        /// <summary>\n        /// Computed total for this line (Quantity * UnitPrice).\n        /// </summary>\n        public decimal LineTotal { get; set; }\n\n        /// <summary>\n        /// Optional metadata (JSON) for internal reconciliation.\n        /// </summary>\n        public string? MetaJson { get; set; }\n\n        // ---- Navigation ----\n\n        public Invoice? Invoice { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Models/PaymentTransaction.cs",
      "sha256": "f8cc2aed683bd8ea7a9c9221d67d87057ad649df9daae02e7373146611ad9f9f",
      "language": "csharp",
      "size": 3043,
      "content": "#nullable enable\nusing System;\nusing xbytechat.api.Features.Payment.Enums;\nusing xbytechat.api.Features.BusinessModule.Models;\n\nnamespace xbytechat.api.Features.Payment.Models\n{\n    /// <summary>\n    /// Represents a single payment interaction with a gateway\n    /// (checkout session, order, capture, refund, etc.).\n    /// </summary>\n    public class PaymentTransaction\n    {\n        public Guid Id { get; set; }\n\n        /// <summary>\n        /// Business that owns this transaction.\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// Optional related subscription (plan change, renewal, etc.).\n        /// </summary>\n        public Guid? SubscriptionId { get; set; }\n\n        /// <summary>\n        /// Optional related invoice (if this payment settles a specific invoice).\n        /// </summary>\n        public Guid? InvoiceId { get; set; }\n\n        /// <summary>\n        /// Total amount in smallest currency unit or decimal depending on your standard.\n        /// Use decimal for INR and similar.\n        /// </summary>\n        public decimal Amount { get; set; }\n\n        /// <summary>\n        /// ISO currency code, e.g. \"INR\", \"USD\".\n        /// </summary>\n        public string Currency { get; set; } = \"INR\";\n\n        /// <summary>\n        /// Current status of the transaction (pending, success, failed, etc.).\n        /// </summary>\n        public PaymentStatus Status { get; set; }\n\n        /// <summary>\n        /// Gateway name/provider identifier (e.g. \"Razorpay\", \"Stripe\").\n        /// Kept as string for flexibility; can be enum'ed later.\n        /// </summary>\n        public string Gateway { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Payment/charge id from the gateway.\n        /// </summary>\n        public string? GatewayPaymentId { get; set; }\n\n        /// <summary>\n        /// Order/checkout/session id from the gateway (if applicable).\n        /// </summary>\n        public string? GatewayOrderId { get; set; }\n\n        /// <summary>\n        /// Optional gateway signature or verification token (for validation).\n        /// </summary>\n        public string? GatewaySignature { get; set; }\n\n        /// <summary>\n        /// In case of failure, store short reason for debugging / UI.\n        /// </summary>\n        public string? FailureReason { get; set; }\n\n        /// <summary>\n        /// Any extra metadata (JSON) for debugging or support audits.\n        /// </summary>\n        public string? MetaJson { get; set; }\n\n        /// <summary>\n        /// When this record was created (UTC).\n        /// </summary>\n        public DateTime CreatedAtUtc { get; set; }\n\n        /// <summary>\n        /// When transaction was completed (success/failure/refund), if known (UTC).\n        /// </summary>\n        public DateTime? CompletedAtUtc { get; set; }\n\n        // ---- Navigation ----\n        public Business? Business { get; set; }\n        public Subscription? Subscription { get; set; }\n        public Invoice? Invoice { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Models/Subscription.cs",
      "sha256": "dc53299428c492d66865c3bf0d2760f65ca0a62124181ac4bcb23c1d82b4aab6",
      "language": "csharp",
      "size": 3244,
      "content": "#nullable enable\nusing System;\nusing System.Collections.Generic;\nusing xbytechat.api.Features.Payment.Enums;\nusing xbytechat.api.Features.Payment.Models;\nusing xbytechat.api.Features.PlanManagement.Models;\nusing xbytechat.api.Features.BusinessModule.Models;\nusing xbytechat.api.Features.AccessControl.Models;\n\nnamespace xbytechat.api.Features.Payment.Models\n{\n    /// <summary>\n    /// Represents the subscription of a Business to a specific plan.\n    /// Drives access control, trials, renewals, and suspension.\n    /// </summary>\n    public class Subscription\n    {\n        /// <summary>\n        /// Primary key for the subscription.\n        /// </summary>\n        public Guid Id { get; set; }\n\n        /// <summary>\n        /// The business (account) this subscription belongs to.\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// The plan the business is subscribed to.\n        /// This should reference your PlanManagement module.\n        /// </summary>\n        public Guid PlanId { get; set; }\n\n        /// <summary>\n        /// Current lifecycle state of the subscription.\n        /// </summary>\n        public SubscriptionStatus Status { get; set; }\n\n        /// <summary>\n        /// Billing frequency (e.g. Monthly / Yearly).\n        /// </summary>\n        public BillingCycle BillingCycle { get; set; }\n\n        /// <summary>\n        /// When the current billing period starts (UTC).\n        /// </summary>\n        public DateTime CurrentPeriodStartUtc { get; set; }\n\n        /// <summary>\n        /// When the current billing period ends (UTC).\n        /// </summary>\n        public DateTime CurrentPeriodEndUtc { get; set; }\n\n        /// <summary>\n        /// Optional trial end (UTC). When passed and not activated -> Expired.\n        /// </summary>\n        public DateTime? TrialEndsAtUtc { get; set; }\n\n        /// <summary>\n        /// If true, subscription will auto-renew at the end of each period.\n        /// </summary>\n        public bool AutoRenew { get; set; } = true;\n\n        /// <summary>\n        /// If true, subscription will be cancelled when the current period ends.\n        /// </summary>\n        public bool CancelAtPeriodEnd { get; set; }\n\n        /// <summary>\n        /// Gateway specific customer id (Stripe, Razorpay, etc) for this business.\n        /// Stored here so multiple subscriptions can still share mapping if needed.\n        /// </summary>\n        public string? GatewayCustomerId { get; set; }\n\n        /// <summary>\n        /// Gateway specific subscription id, if managed on the gateway side.\n        /// </summary>\n        public string? GatewaySubscriptionId { get; set; }\n\n        /// <summary>\n        /// Optional internal notes (manual overrides, special deals, etc.).\n        /// </summary>\n        public string? Notes { get; set; }\n\n        // ---- Navigation properties ----\n\n        public Business? Business { get; set; }          // from BusinessModule\n        public Plan? Plan { get; set; }                  // from PlanManagement\n        public ICollection<PaymentTransaction> Payments { get; set; } = new List<PaymentTransaction>();\n        public ICollection<Invoice> Invoices { get; set; } = new List<Invoice>();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Options/RazorpayOptions.cs",
      "sha256": "b3955ae606e837242a71718a7365f4a068a66ab5c960000deb52d03867f4d313",
      "language": "csharp",
      "size": 738,
      "content": "#nullable enable\nnamespace xbytechat.api.Features.Payment.Options\n{\n    /// <summary>\n    /// Razorpay configuration bound from appsettings.\n    /// Never hard-code secrets in code.\n    /// </summary>\n    public sealed class RazorpayOptions\n    {\n        public string KeyId { get; set; } = string.Empty;\n        public string KeySecret { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Secret for validating Razorpay webhooks.\n        /// </summary>\n        public string WebhookSecret { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Base URL of your frontend where you handle success/failure (if needed).\n        /// </summary>\n        public string FrontendBaseUrl { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Options/SubscriptionLifecycleOptions.cs",
      "sha256": "acd4cdaf003dbabe03e8a2e81e657e7307201d0202953f31faf345a42dca66e3",
      "language": "csharp",
      "size": 453,
      "content": "#nullable enable\n\nnamespace xbytechat.api.Features.Payment.Options\n{\n    /// <summary>\n    /// Configuration for automatic subscription status transitions.\n    /// Values are in days unless noted.\n    /// </summary>\n    public sealed class SubscriptionLifecycleOptions\n    {\n        /// <summary>\n        /// After this many days in PastDue, move to Suspended.\n        /// </summary>\n        public int PastDueToSuspendedDays { get; set; } = 7;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Services/AccessCheckResult.cs",
      "sha256": "4f45881a7c082c9bac19582823676a818e765eb340cbd47cfd917316b6827bcf",
      "language": "csharp",
      "size": 416,
      "content": "#nullable enable\nusing xbytechat.api.Features.Payment.Enums;\n\nnamespace xbytechat.api.Features.Payment.Services\n{\n    /// <summary>\n    /// Result of an access check for core, billable features.\n    /// </summary>\n    public sealed class AccessCheckResult\n    {\n        public bool Allowed { get; init; }\n        public SubscriptionStatus? Status { get; init; }\n        public string? Message { get; init; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Services/AccessGuard.cs",
      "sha256": "d961c3456ef2fb78fb80341a4eaa6af91dc2cd92179c1a3634c046d9f9da0bf4",
      "language": "csharp",
      "size": 5346,
      "content": "#nullable enable\nusing System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Payment.Enums;\nusing xbytechat.api.Features.Payment.Models;\n\nnamespace xbytechat.api.Features.Payment.Services\n{\n    /// <summary>\n    /// Subscription-based access control:\n    /// decides if core features (like messaging, campaigns) are allowed.\n    /// All rules centralized here.\n    /// </summary>\n    public sealed class AccessGuard : IAccessGuard\n    {\n        private readonly AppDbContext _db;\n\n        public AccessGuard(AppDbContext db)\n        {\n            _db = db;\n        }\n\n        public async Task<bool> CanUseCoreFeaturesAsync(Guid businessId, CancellationToken ct = default)\n        {\n            var result = await CheckAsync(businessId, ct);\n            return result.Allowed;\n        }\n\n        public async Task<AccessCheckResult> CheckAsync(Guid businessId, CancellationToken ct = default)\n        {\n            var now = DateTime.UtcNow;\n\n            var sub = await _db.Subscriptions\n                .Where(s => s.BusinessId == businessId)\n                .OrderByDescending(s => s.CurrentPeriodStartUtc)\n                .FirstOrDefaultAsync(ct);\n\n            // Case: no subscription at all\n            if (sub is null)\n            {\n                return new AccessCheckResult\n                {\n                    Allowed = false,\n                    Status = null,\n                    Message = \"You don‚Äôt have an active plan. Choose a plan in Billing to start using messaging and campaigns.\"\n                };\n            }\n\n            var status = sub.Status;\n\n            switch (status)\n            {\n                case SubscriptionStatus.Active:\n                    return new AccessCheckResult\n                    {\n                        Allowed = true,\n                        Status = status\n                    };\n\n                case SubscriptionStatus.Trial:\n                    // Trial active\n                    if (sub.TrialEndsAtUtc is null || sub.TrialEndsAtUtc > now)\n                    {\n                        return new AccessCheckResult\n                        {\n                            Allowed = true,\n                            Status = status\n                        };\n                    }\n\n                    // Trial expired\n                    return new AccessCheckResult\n                    {\n                        Allowed = false,\n                        Status = SubscriptionStatus.Expired,\n                        Message = \"Your trial has ended. Choose a plan in Billing to continue using messaging and campaigns.\"\n                    };\n\n                case SubscriptionStatus.Grace:\n                    // Grace = still allowed; show banner via UI if you want\n                    return new AccessCheckResult\n                    {\n                        Allowed = true,\n                        Status = status\n                    };\n\n                case SubscriptionStatus.PastDue:\n                    // Payment failed / due date passed\n                    return new AccessCheckResult\n                    {\n                        Allowed = false,\n                        Status = status,\n                        Message = \"Your subscription payment is overdue. Please clear the pending invoice in Billing to restore access.\"\n                    };\n\n                case SubscriptionStatus.CancelAtPeriodEnd:\n                    if (sub.CurrentPeriodEndUtc > now)\n                    {\n                        // Still in paid period\n                        return new AccessCheckResult\n                        {\n                            Allowed = true,\n                            Status = status\n                        };\n                    }\n\n                    // Period ended -> treat as cancelled\n                    return new AccessCheckResult\n                    {\n                        Allowed = false,\n                        Status = SubscriptionStatus.Cancelled,\n                        Message = \"Your subscription has ended. Select a plan in Billing to continue using your account.\"\n                    };\n\n                case SubscriptionStatus.Cancelled:\n                case SubscriptionStatus.Expired:\n                    return new AccessCheckResult\n                    {\n                        Allowed = false,\n                        Status = status,\n                        Message = \"Your subscription is no longer active. Select a plan in Billing to continue using your account.\"\n                    };\n\n                case SubscriptionStatus.Suspended:\n                    return new AccessCheckResult\n                    {\n                        Allowed = false,\n                        Status = status,\n                        Message = \"Your account has been suspended due to payment issues. Update your payment method or contact support to restore access.\"\n                    };\n\n                default:\n                    return new AccessCheckResult\n                    {\n                        Allowed = false,\n                        Status = status,\n                        Message = \"Your subscription status does not allow access. Please check Billing or contact support.\"\n                    };\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Services/CouponPricingHelper.cs",
      "sha256": "606ce2e78f72f5929451312374fd656e0521436252e69f3eb70c99c1acd16275",
      "language": "csharp",
      "size": 1158,
      "content": "#nullable enable\nusing System;\nusing xbytechat.api.Features.Payment.Enums;\nusing xbytechat.api.Features.Payment.Models;\n\nnamespace xbytechat.api.Features.Payment.Services\n{\n    /// <summary>\n    /// Small helper to apply coupon math consistently.\n    /// This does not check validity windows or max usage - that stays in CouponService.\n    /// </summary>\n    internal static class CouponPricingHelper\n    {\n        public static (decimal discountAmount, decimal finalAmount) ApplyCoupon(\n            Coupon coupon,\n            decimal subtotal)\n        {\n            if (subtotal <= 0 || !coupon.IsActive)\n                return (0m, subtotal);\n\n            decimal discount = coupon.DiscountType switch\n            {\n                DiscountType.Percentage =>\n                    Math.Round(subtotal * (coupon.DiscountValue / 100m), 2, MidpointRounding.AwayFromZero),\n\n                DiscountType.FixedAmount =>\n                    Math.Min(coupon.DiscountValue, subtotal),\n\n                _ => 0m\n            };\n\n            var final = subtotal - discount;\n            if (final < 0) final = 0;\n\n            return (discount, final);\n        }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Services/CouponService.cs",
      "sha256": "6885d6873aaa667ac68883aab998bed6b3f967e3a772e80b5a568577e5f06406",
      "language": "csharp",
      "size": 1990,
      "content": "#nullable enable\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Payment.DTOs;\nusing xbytechat.api.Features.Payment.Enums;\nusing xbytechat.api.Features.Payment.Models;\n\nnamespace xbytechat.api.Features.Payment.Services\n{\n    /// <summary>\n    /// Minimal coupon validator:\n    /// - checks code, active flag, date range.\n    /// - does NOT yet enforce redemption limits.\n    /// </summary>\n    public sealed class CouponService : ICouponService\n    {\n        private readonly AppDbContext _db;\n\n        public CouponService(AppDbContext db)\n        {\n            _db = db;\n        }\n\n        public async Task<CouponDto?> ValidateCouponAsync(\n            string code,\n            string currency,\n            CancellationToken ct = default)\n        {\n            if (string.IsNullOrWhiteSpace(code))\n                return null;\n\n            var now = DateTime.UtcNow;\n            var coupon = await _db.Coupons\n                .AsNoTracking()\n                .FirstOrDefaultAsync(c =>\n                        c.IsActive &&\n                        c.Code == code &&\n                        (c.ValidFromUtc == null || c.ValidFromUtc <= now) &&\n                        (c.ValidToUtc == null || c.ValidToUtc >= now),\n                    ct);\n\n            if (coupon is null)\n                return null;\n\n            // Future:\n            // - Validate currency, plan scope, usage limits.\n            // - For now we trust currency compatibility implicitly.\n\n            return new CouponDto\n            {\n                Id = coupon.Id,\n                Code = coupon.Code,\n                Description = coupon.Description,\n                DiscountType = coupon.DiscountType,\n                DiscountValue = coupon.DiscountValue,\n                IsActive = coupon.IsActive,\n                ValidFromUtc = coupon.ValidFromUtc,\n                ValidToUtc = coupon.ValidToUtc\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Services/IAccessGuard.cs",
      "sha256": "a396a820f8282d2bc56f43fad75de0341d2f2c2c89371f96137bc5a834d9ee1c",
      "language": "csharp",
      "size": 492,
      "content": "#nullable enable\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Payment.Services\n{\n    /// <summary>\n    /// Central guard to decide if a business is allowed to use billable features.\n    /// </summary>\n    public interface IAccessGuard\n    {\n        Task<bool> CanUseCoreFeaturesAsync(Guid businessId, CancellationToken ct = default);\n        Task<AccessCheckResult> CheckAsync(Guid businessId, CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Services/ICouponService.cs",
      "sha256": "e9762a2227164503e672c3b167224efe6147864859ca5c11671e7f4fb52dc1e9",
      "language": "csharp",
      "size": 507,
      "content": "#nullable enable\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Payment.DTOs;\n\nnamespace xbytechat.api.Features.Payment.Services\n{\n    /// <summary>\n    /// Validates coupons and exposes safe coupon info.\n    /// Admin management can be a separate module.\n    /// </summary>\n    public interface ICouponService\n    {\n        Task<CouponDto?> ValidateCouponAsync(\n            string code,\n            string currency,\n            CancellationToken ct = default);\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Services/IInvoiceService.cs",
      "sha256": "585437bb5981309ae50ba8e00a4647199330efb4e2ea638769db662857c68e70",
      "language": "csharp",
      "size": 677,
      "content": "#nullable enable\nusing System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Payment.DTOs;\n\nnamespace xbytechat.api.Features.Payment.Services\n{\n    /// <summary>\n    /// Creates and retrieves invoices for businesses.\n    /// Actual tax/coupon/usage logic will be implemented inside.\n    /// </summary>\n    public interface IInvoiceService\n    {\n        Task<IReadOnlyList<InvoiceDto>> GetInvoicesForBusinessAsync(\n            Guid businessId,\n            CancellationToken ct = default);\n\n        Task<InvoiceDto?> GetInvoiceAsync(Guid businessId, Guid invoiceId, CancellationToken ct = default);\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Services/InvoiceService.cs",
      "sha256": "c2186e5a30552a96ae94d0251d272d8957dfffb61a0741029438b92fb0b20be3",
      "language": "csharp",
      "size": 2779,
      "content": "#nullable enable\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Payment.DTOs;\nusing xbytechat.api.Features.Payment.Models;\n\nnamespace xbytechat.api.Features.Payment.Services\n{\n    /// <summary>\n    /// Read-only invoice service for now.\n    /// Future:\n    /// - generation based on subscriptions & usage\n    /// - GST-compliant export.\n    /// </summary>\n    public sealed class InvoiceService : IInvoiceService\n    {\n        private readonly AppDbContext _db;\n\n        public InvoiceService(AppDbContext db)\n        {\n            _db = db;\n        }\n\n        public async Task<IReadOnlyList<InvoiceDto>> GetInvoicesForBusinessAsync(\n            Guid businessId,\n            CancellationToken ct = default)\n        {\n            var invoices = await _db.Invoices\n                .Include(i => i.LineItems)\n                .Where(i => i.BusinessId == businessId)\n                .OrderByDescending(i => i.IssuedAtUtc)\n                .ToListAsync(ct);\n\n            return invoices.Select(MapToDto).ToList();\n        }\n\n        public async Task<InvoiceDto?> GetInvoiceAsync(\n            Guid businessId,\n            Guid invoiceId,\n            CancellationToken ct = default)\n        {\n            var invoice = await _db.Invoices\n                .Include(i => i.LineItems)\n                .FirstOrDefaultAsync(i => i.Id == invoiceId && i.BusinessId == businessId, ct);\n\n            return invoice is null ? null : MapToDto(invoice);\n        }\n\n        private static InvoiceDto MapToDto(Invoice invoice)\n        {\n            return new InvoiceDto\n            {\n                Id = invoice.Id,\n                InvoiceNumber = invoice.InvoiceNumber,\n                BusinessId = invoice.BusinessId,\n                SubscriptionId = invoice.SubscriptionId,\n                Status = invoice.Status,\n                SubtotalAmount = invoice.SubtotalAmount,\n                DiscountAmount = invoice.DiscountAmount,\n                TaxAmount = invoice.TaxAmount,\n                TotalAmount = invoice.TotalAmount,\n                Currency = invoice.Currency,\n                AppliedCouponCode = invoice.AppliedCouponCode,\n                IssuedAtUtc = invoice.IssuedAtUtc,\n                DueAtUtc = invoice.DueAtUtc,\n                PaidAtUtc = invoice.PaidAtUtc,\n                LineItems = invoice.LineItems.Select(li => new InvoiceLineItemDto\n                {\n                    Id = li.Id,\n                    Description = li.Description,\n                    Quantity = li.Quantity,\n                    UnitPrice = li.UnitPrice,\n                    LineTotal = li.LineTotal\n                }).ToList()\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Services/IPaymentGatewayService.cs",
      "sha256": "409d1d87341a931f5ea4a5129b75d859144e06166146b1964e22084cd3310470",
      "language": "csharp",
      "size": 804,
      "content": "#nullable enable\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Payment.DTOs;\n\nnamespace xbytechat.api.Features.Payment.Services\n{\n    /// <summary>\n    /// Abstraction over the underlying payment provider (Razorpay, Stripe, etc.).\n    /// Implementation will:\n    /// - create checkout/payment sessions\n    /// - verify signatures\n    /// - map webhooks to PaymentTransaction updates.\n    /// </summary>\n    public interface IPaymentGatewayService\n    {\n        Task<PaymentSessionResponseDto> CreatePaymentSessionForInvoiceAsync(\n            Guid businessId,\n            Guid invoiceId,\n            string? couponCode,\n            CancellationToken ct = default);\n\n        // We will add webhook-handling signatures later when wiring gateway.\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Services/ISubscriptionCheckoutService.cs",
      "sha256": "70caced3708db2d78510dbc7a306b90d3cbf5928ad2de27a3915b5a5fab1dd73",
      "language": "csharp",
      "size": 563,
      "content": "#nullable enable\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Payment.DTOs;\n\nnamespace xbytechat.api.Features.Payment.Services\n{\n    /// <summary>\n    /// Orchestrates plan selection -> invoice -> payment session for subscriptions.\n    /// </summary>\n    public interface ISubscriptionCheckoutService\n    {\n        Task<PaymentSessionResponseDto> StartSubscriptionCheckoutAsync(\n            Guid businessId,\n            CreateSubscriptionRequestDto request,\n            CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Services/ISubscriptionService.cs",
      "sha256": "bb311c9360309f2f785913b2edf1fee96d7a66bbcc0784ec59392e3cc5718845",
      "language": "csharp",
      "size": 879,
      "content": "#nullable enable\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Payment.DTOs;\n\nnamespace xbytechat.api.Features.Payment.Services\n{\n    /// <summary>\n    /// Handles business-facing subscription lifecycle:\n    /// trial, activation, upgrade/downgrade, cancellation.\n    /// </summary>\n    public interface ISubscriptionService\n    {\n        Task<SubscriptionDto?> GetCurrentForBusinessAsync(Guid businessId, CancellationToken ct = default);\n\n        Task<SubscriptionDto> CreateOrUpdateSubscriptionAsync(\n            Guid businessId,\n            CreateSubscriptionRequestDto request,\n            CancellationToken ct = default);\n\n        Task<bool> MarkCancelAtPeriodEndAsync(Guid businessId, CancellationToken ct = default);\n\n        Task<bool> ReactivateAutoRenewAsync(Guid businessId, CancellationToken ct = default);\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Services/PaymentOverviewService.cs",
      "sha256": "90fc29922281ffee1c3c6140193d81efce9c482132b8ed63aebc9b269c4b546e",
      "language": "csharp",
      "size": 2140,
      "content": "#nullable enable\nusing System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Payment.DTOs;\nusing xbytechat.api.Features.Payment.Enums;\nusing xbytechat.api.Features.Payment.Models;\n\nnamespace xbytechat.api.Features.Payment.Services\n{\n    /// <summary>\n    /// Lightweight read service to power Billing/Insights UI.\n    /// Aggregates subscription + invoices + access flag.\n    /// </summary>\n    public sealed class PaymentOverviewService\n    {\n        private readonly AppDbContext _db;\n        private readonly ISubscriptionService _subscriptions;\n        private readonly IInvoiceService _invoices;\n        private readonly IAccessGuard _accessGuard;\n\n        public PaymentOverviewService(\n            AppDbContext db,\n            ISubscriptionService subscriptions,\n            IInvoiceService invoices,\n            IAccessGuard accessGuard)\n        {\n            _db = db;\n            _subscriptions = subscriptions;\n            _invoices = invoices;\n            _accessGuard = accessGuard;\n        }\n\n        public async Task<PaymentOverviewDto> GetAsync(Guid businessId, CancellationToken ct = default)\n        {\n            var sub = await _subscriptions.GetCurrentForBusinessAsync(businessId, ct);\n            var invoices = await _invoices.GetInvoicesForBusinessAsync(businessId, ct);\n\n            var lastPaid = invoices\n                .Where(i => i.Status == InvoiceStatus.Paid)\n                .OrderByDescending(i => i.PaidAtUtc ?? i.IssuedAtUtc)\n                .FirstOrDefault();\n\n            var canUse = await _accessGuard.CanUseCoreFeaturesAsync(businessId, ct);\n\n            return new PaymentOverviewDto\n            {\n                CurrentSubscription = sub,\n                LastInvoiceAmount = lastPaid?.TotalAmount,\n                LastInvoicePaidAtUtc = lastPaid?.PaidAtUtc,\n                CurrentPeriodEndUtc = sub?.CurrentPeriodEndUtc,\n                CanUseCoreFeatures = canUse,\n                RecentInvoices = invoices\n                    .Take(10)\n                    .ToList()\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Services/RazorpayPaymentGatewayService.cs",
      "sha256": "bbc11c906ea24283a7a891f205a389e6d72ca9fdf01f7dda65c50a6633d090eb",
      "language": "csharp",
      "size": 5962,
      "content": "#nullable enable\nusing System;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Text;\nusing System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing xbytechat.api.Features.Payment.DTOs;\nusing xbytechat.api.Features.Payment.Enums;\nusing xbytechat.api.Features.Payment.Models;\nusing xbytechat.api.Features.Payment.Options;\n\nnamespace xbytechat.api.Features.Payment.Services\n{\n    /// <summary>\n    /// Razorpay-based implementation of IPaymentGatewayService.\n    /// This is a minimal skeleton:\n    /// - Creates a Razorpay Order for an existing Invoice.\n    /// - Persists a Pending PaymentTransaction.\n    /// - Returns data for frontend to open Razorpay Checkout.\n    ///\n    /// Webhook handling that marks success/failure is done separately.\n    /// </summary>\n    public sealed class RazorpayPaymentGatewayService : IPaymentGatewayService\n    {\n        private readonly AppDbContext _db;\n        private readonly HttpClient _http;\n        private readonly RazorpayOptions _opts;\n        private readonly ILogger<RazorpayPaymentGatewayService> _log;\n\n        public RazorpayPaymentGatewayService(\n            AppDbContext db,\n            HttpClient httpClient,\n            IOptions<RazorpayOptions> opts,\n            ILogger<RazorpayPaymentGatewayService> log)\n        {\n            _db = db;\n            _http = httpClient;\n            _opts = opts.Value;\n            _log = log;\n\n            if (!string.IsNullOrWhiteSpace(_opts.KeyId) &&\n                !string.IsNullOrWhiteSpace(_opts.KeySecret))\n            {\n                var authToken = Convert.ToBase64String(\n                    Encoding.UTF8.GetBytes($\"{_opts.KeyId}:{_opts.KeySecret}\"));\n\n                _http.BaseAddress ??= new Uri(\"https://api.razorpay.com/v1/\");\n                _http.DefaultRequestHeaders.Authorization =\n                    new AuthenticationHeaderValue(\"Basic\", authToken);\n            }\n        }\n\n        /// <summary>\n        /// Creates a payment session (Razorpay Order) for the given invoice.\n        /// Assumes:\n        /// - Invoice is already created with TotalAmount & Currency.\n        /// - BusinessId already validated by caller.\n        /// </summary>\n        public async Task<PaymentSessionResponseDto> CreatePaymentSessionForInvoiceAsync(\n            Guid businessId,\n            Guid invoiceId,\n            string? couponCode,\n            CancellationToken ct = default)\n        {\n            var invoice = await _db.Invoices\n                .FirstOrDefaultAsync(i => i.Id == invoiceId && i.BusinessId == businessId, ct);\n\n            if (invoice is null)\n                throw new InvalidOperationException(\"Invoice not found for this business.\");\n\n            if (invoice.Status is InvoiceStatus.Paid or InvoiceStatus.Void)\n                throw new InvalidOperationException(\"Invoice is already closed.\");\n\n            if (invoice.TotalAmount <= 0)\n                throw new InvalidOperationException(\"Invoice total must be greater than zero.\");\n\n            // ---- Create PaymentTransaction record (Pending) ----\n            var tx = new PaymentTransaction\n            {\n                Id = Guid.NewGuid(),\n                BusinessId = businessId,\n                InvoiceId = invoice.Id,\n                SubscriptionId = invoice.SubscriptionId,\n                Amount = invoice.TotalAmount,\n                Currency = invoice.Currency,\n                Status = PaymentStatus.Pending,\n                Gateway = \"Razorpay\",\n                CreatedAtUtc = DateTime.UtcNow,\n                MetaJson = null\n            };\n\n            _db.PaymentTransactions.Add(tx);\n            await _db.SaveChangesAsync(ct);\n\n            // ---- Call Razorpay Orders API ----\n            // amount in paise for INR (multiply by 100)\n            var amountInMinor = (int)(invoice.TotalAmount * 100m);\n\n            var payload = new\n            {\n                amount = amountInMinor,\n                currency = invoice.Currency,\n                receipt = invoice.InvoiceNumber,\n                payment_capture = 1 // auto-capture\n            };\n\n            var json = JsonSerializer.Serialize(payload);\n            var content = new StringContent(json, Encoding.UTF8, \"application/json\");\n\n            HttpResponseMessage resp;\n            try\n            {\n                resp = await _http.PostAsync(\"orders\", content, ct);\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"Error calling Razorpay Orders API\");\n                throw new InvalidOperationException(\"Unable to create payment order at this time.\");\n            }\n\n            if (!resp.IsSuccessStatusCode)\n            {\n                var body = await resp.Content.ReadAsStringAsync(ct);\n                _log.LogError(\"Razorpay order failed: {Status} {Body}\", resp.StatusCode, body);\n                throw new InvalidOperationException(\"Failed to create payment order.\");\n            }\n\n            using var stream = await resp.Content.ReadAsStreamAsync(ct);\n            using var doc = await JsonDocument.ParseAsync(stream, cancellationToken: ct);\n\n            var orderId = doc.RootElement.GetProperty(\"id\").GetString();\n\n            // Save order id on transaction\n            tx.GatewayOrderId = orderId;\n            tx.MetaJson = json;\n            await _db.SaveChangesAsync(ct);\n\n            // ---- Return session info for frontend ----\n            // Frontend will:\n            // - Use Razorpay JS with key_id + order_id + customer info\n            // - On success, webhook will confirm and we update DB.\n            var session = new PaymentSessionResponseDto\n            {\n                SessionId = tx.Id.ToString(),\n                RedirectUrl = $\"{_opts.FrontendBaseUrl}/billing/checkout?orderId={orderId}&txId={tx.Id}\"\n            };\n\n            return session;\n        }\n    }\n}\n"
    }
  ]
}
