{
  "name": "xbytechat-api/Features/ChatInbox",
  "generatedAt": "2026-02-11 19:15:17 +00:00",
  "files": [
    {
      "path": "xbytechat-api/Features/ChatInbox/Controllers/ChatInboxController.cs",
      "sha256": "8bfc29e38e01fd26cfe273ace7ba08ea169d1f222800889f8b122cd771f84789",
      "language": "csharp",
      "size": 30906,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/Controllers/ChatInboxController.cs\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Security.Claims;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.ChatInbox.DTOs;\nusing xbytechat.api.Features.ChatInbox.Models;\nusing xbytechat.api.Features.ChatInbox.Services;\nusing xbytechat.api.Models;\n\nnamespace xbytechat.api.Features.ChatInbox.Controllers\n{\n    [ApiController]\n    [Route(\"api/chat-inbox\")]\n    [Authorize]\n    public sealed class ChatInboxController : ControllerBase\n    {\n        private readonly IChatInboxQueryService _queryService;\n        private readonly IChatInboxCommandService _commandService;\n        private readonly IChatInboxAssignmentService _assignmentService;\n        private readonly IChatInboxMediaUploadService _mediaUploadService;\n        private readonly IChatInboxMediaContentService _mediaContentService;\n        private readonly AppDbContext _db;\n        private readonly ILogger<ChatInboxController> _logger;\n\n        public ChatInboxController(\n            IChatInboxQueryService queryService,\n            IChatInboxCommandService commandService,\n            IChatInboxAssignmentService assignmentService,\n            IChatInboxMediaUploadService mediaUploadService,\n            IChatInboxMediaContentService mediaContentService,\n            AppDbContext db,\n            ILogger<ChatInboxController> logger)\n        {\n            _queryService = queryService ?? throw new ArgumentNullException(nameof(queryService));\n            _commandService = commandService ?? throw new ArgumentNullException(nameof(commandService));\n            _assignmentService = assignmentService ?? throw new ArgumentNullException(nameof(assignmentService));\n            _mediaUploadService = mediaUploadService ?? throw new ArgumentNullException(nameof(mediaUploadService));\n            _mediaContentService = mediaContentService ?? throw new ArgumentNullException(nameof(mediaContentService));\n            _db = db ?? throw new ArgumentNullException(nameof(db));\n            _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n        }\n\n        private const long MaxUploadBytes = 10 * 1024 * 1024; // 10MB\n        private const string InboxAssignPermissionCode = \"INBOX.CHAT.ASSIGN\";\n\n        private static readonly HashSet<string> AllowedContentTypes = new HashSet<string>(StringComparer.OrdinalIgnoreCase)\n        {\n            \"image/jpeg\",\n            \"image/png\",\n            \"image/webp\",\n            \"application/pdf\",\n            \"video/mp4\",\n            \"video/3gpp\",\n            \"audio/mpeg\",\n            \"audio/mp4\",\n            \"audio/aac\",\n            \"audio/ogg\"\n        };\n\n        [HttpPost(\"media/upload\")]\n        [Consumes(\"multipart/form-data\")]\n        [ProducesResponseType(typeof(ChatInboxMediaUploadResponseDto), 200)]\n        public async Task<ActionResult<ChatInboxMediaUploadResponseDto>> UploadMedia(\n            [FromForm] ChatInboxMediaUploadRequestDto form,\n            CancellationToken ct = default)\n        {\n            var tokenBiz = GetBusinessId();\n            if (!tokenBiz.HasValue) return Unauthorized(\"businessId missing in token.\");\n\n            var file = form?.File;\n            if (file == null) return BadRequest(\"file is required.\");\n            if (file.Length <= 0) return BadRequest(\"file is empty.\");\n            if (file.Length > MaxUploadBytes) return BadRequest($\"file is too large. Max allowed is {MaxUploadBytes / (1024 * 1024)}MB.\");\n\n            // Some browsers append parameters like \"audio/ogg; codecs=opus\"\n            var mimeRaw = (file.ContentType ?? string.Empty).Trim();\n            var mime = mimeRaw.Split(';', 2)[0].Trim();\n            if (string.IsNullOrWhiteSpace(mime) || !AllowedContentTypes.Contains(mime))\n                return BadRequest(\"Unsupported file type. Allowed: image/jpeg, image/png, image/webp, application/pdf, video/mp4, audio/mpeg, audio/mp4, audio/aac, audio/ogg.\");\n\n            var mediaType = string.Equals(mime, \"application/pdf\", StringComparison.OrdinalIgnoreCase)\n                ? \"document\"\n                : mime.StartsWith(\"video/\", StringComparison.OrdinalIgnoreCase)\n                    ? \"video\"\n                    : mime.StartsWith(\"audio/\", StringComparison.OrdinalIgnoreCase)\n                        ? \"audio\"\n                        : \"image\";\n\n            var safeName = Path.GetFileName(file.FileName ?? \"upload.bin\");\n\n            try\n            {\n                var mediaId = await _mediaUploadService.UploadToWhatsAppAsync(\n                    tokenBiz.Value,\n                    phoneNumberId: null,\n                    file,\n                    ct).ConfigureAwait(false);\n\n                return Ok(new ChatInboxMediaUploadResponseDto\n                {\n                    MediaId = mediaId,\n                    MediaType = mediaType,\n                    FileName = safeName,\n                    MimeType = mime,\n                    SizeBytes = file.Length\n                });\n            }\n            catch (InvalidOperationException ex)\n            {\n                return BadRequest(new { message = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"ChatInbox media upload failed. BusinessId={BusinessId}\", tokenBiz.Value);\n                return BadRequest(new { message = \"Media upload failed. Please try again.\" });\n            }\n        }\n\n        [HttpGet(\"media/{mediaId}/content\")]\n        public async Task<IActionResult> GetMediaContent(\n            [FromRoute] string mediaId,\n            CancellationToken ct = default)\n        {\n            var tokenBiz = GetBusinessId();\n            if (!tokenBiz.HasValue) return Unauthorized(\"businessId missing in token.\");\n\n            var tokenUserId = GetUserId();\n            if (!tokenUserId.HasValue) return Unauthorized(\"userId missing in token.\");\n\n            var mid = (mediaId ?? string.Empty).Trim();\n            if (string.IsNullOrWhiteSpace(mid)) return BadRequest(\"mediaId is required.\");\n\n            var row = await _db.MessageLogs\n                .AsNoTracking()\n                .Where(m =>\n                    m.BusinessId == tokenBiz.Value &&\n                    m.MediaId != null &&\n                    m.MediaId == mid &&\n                    m.ContactId != null)\n                .OrderByDescending(m => m.SentAt ?? m.CreatedAt)\n                .ThenByDescending(m => m.Id)\n                .Select(m => new\n                {\n                    ContactId = m.ContactId!.Value,\n                    m.FileName,\n                    m.MimeType,\n                    m.MediaType\n                })\n                .FirstOrDefaultAsync(ct)\n                .ConfigureAwait(false);\n\n            if (row == null) return NotFound(new { message = \"Media not found.\" });\n\n            try\n            {\n                await EnsureCanAccessContactAsync(tokenBiz.Value, tokenUserId.Value, row.ContactId, ct)\n                    .ConfigureAwait(false);\n            }\n            catch (UnauthorizedAccessException ex)\n            {\n                return StatusCode(StatusCodes.Status403Forbidden, new { message = ex.Message });\n            }\n\n            try\n            {\n                var (stream, contentType) = await _mediaContentService\n                    .DownloadFromWhatsAppAsync(tokenBiz.Value, mid, ct)\n                    .ConfigureAwait(false);\n\n                var finalType = !string.IsNullOrWhiteSpace(row.MimeType)\n                    ? row.MimeType!\n                    : (contentType ?? \"application/octet-stream\");\n\n                var fallbackName = string.Equals(row.MediaType, \"document\", StringComparison.OrdinalIgnoreCase)\n                    ? \"document.pdf\"\n                    : string.Equals(row.MediaType, \"video\", StringComparison.OrdinalIgnoreCase)\n                        ? \"video.mp4\"\n                        : string.Equals(row.MediaType, \"audio\", StringComparison.OrdinalIgnoreCase)\n                            ? \"audio\"\n                            : \"image\";\n\n                var safeName = Path.GetFileName(row.FileName ?? fallbackName);\n                Response.Headers[\"Cache-Control\"] = \"no-store\";\n                Response.Headers[\"Content-Disposition\"] = $\"inline; filename=\\\"{safeName}\\\"\";\n\n                return File(stream, finalType);\n            }\n            catch (InvalidOperationException ex)\n            {\n                return BadRequest(new { message = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"ChatInbox media proxy failed. BusinessId={BusinessId} MediaId={MediaId}\", tokenBiz.Value, mid);\n                return BadRequest(new { message = \"Failed to load media. Please try again.\" });\n            }\n        }\n\n        [HttpGet(\"conversations\")]\n        [ProducesResponseType(typeof(IReadOnlyList<ChatInboxConversationDto>), 200)]\n        public async Task<IActionResult> GetConversations(\n            [FromQuery] Guid businessId,\n            [FromQuery] Guid? currentUserId, // kept for backward compatibility; ignored (token wins)\n            [FromQuery] string? tab,\n            [FromQuery] string? numberId,\n            [FromQuery] string? search,\n            [FromQuery] int? limit,\n            [FromQuery] bool paged = false,\n            [FromQuery] string? cursor = null,\n            CancellationToken cancellationToken = default)\n        {\n            if (businessId == Guid.Empty) return BadRequest(\"businessId is required.\");\n\n            var tokenBiz = GetBusinessId();\n            if (!tokenBiz.HasValue) return Unauthorized(\"businessId missing in token.\");\n            if (tokenBiz.Value != businessId) return Forbid(\"businessId does not match your tenant.\");\n\n            var tokenUserId = GetUserId();\n            if (!tokenUserId.HasValue) return Unauthorized(\"userId missing in token.\");\n\n            var filter = new ChatInboxFilterDto\n            {\n                BusinessId = businessId,\n                CurrentUserId = tokenUserId.Value, // ‚úÖ token wins\n                Tab = tab,\n                NumberId = string.IsNullOrWhiteSpace(numberId) ? null : numberId,\n                SearchTerm = string.IsNullOrWhiteSpace(search) ? null : search,\n                Limit = limit.GetValueOrDefault(50),\n                Cursor = cursor\n            };\n\n            if (!paged)\n            {\n                var result = await _queryService.GetConversationsAsync(filter, cancellationToken);\n                return Ok(result);\n            }\n\n            var page = await _queryService.GetConversationsPageAsync(filter, cancellationToken);\n            return Ok(page);\n        }\n\n        [HttpGet(\"agents\")]\n        [ProducesResponseType(typeof(List<AgentDto>), 200)]\n        public async Task<IActionResult> GetAgents(\n            [FromQuery] Guid businessId,\n            CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty) return BadRequest(\"businessId is required.\");\n\n            var tokenBiz = GetBusinessId();\n            if (!tokenBiz.HasValue) return Unauthorized(\"businessId missing in token.\");\n            if (tokenBiz.Value != businessId) return Forbid(\"businessId does not match your tenant.\");\n\n            try\n            {\n                var rows = await _assignmentService.GetAgentsAsync(businessId, ct);\n                return Ok(rows);\n            }\n            catch (Exception ex)\n            {\n                return BadRequest(ex.Message);\n            }\n        }\n\n        [HttpGet(\"messages\")]\n        [ProducesResponseType(typeof(IReadOnlyList<ChatInboxMessageDto>), 200)]\n        public async Task<IActionResult> GetMessages(\n            [FromQuery] Guid businessId,\n            [FromQuery] Guid? contactId,\n            [FromQuery] string? contactPhone,\n            [FromQuery] int limit = 50,\n            [FromQuery] bool paged = false,\n            [FromQuery] string? cursor = null,\n            CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty) return BadRequest(\"businessId is required.\");\n\n            var tokenBiz = GetBusinessId();\n            if (!tokenBiz.HasValue) return Unauthorized(\"businessId missing in token.\");\n            if (tokenBiz.Value != businessId) return Forbid(\"businessId does not match your tenant.\");\n\n            var tokenUserId = GetUserId();\n            if (!tokenUserId.HasValue) return Unauthorized(\"userId missing in token.\");\n\n            var uid = tokenUserId.Value;\n\n            // ‚úÖ Prefer ContactId path\n            if (contactId.HasValue && contactId.Value != Guid.Empty)\n            {\n                if (!paged)\n                {\n                    // ‚úÖ SECURED overload (enforces AssignedOnly visibility)\n                    var messages = await _queryService.GetMessagesForConversationByContactIdAsync(\n                        businessId, contactId.Value, limit, uid, ct);\n\n                    return Ok(messages);\n                }\n\n                // ‚úÖ SECURED overload (enforces AssignedOnly visibility)\n                var page = await _queryService.GetMessagesPageForConversationByContactIdAsync(\n                    businessId, contactId.Value, limit, cursor, uid, ct);\n\n                return Ok(page);\n            }\n\n            // Fallback: by phone\n            if (string.IsNullOrWhiteSpace(contactPhone))\n                return BadRequest(\"Provide either contactId or contactPhone.\");\n\n            if (!paged)\n            {\n                // ‚úÖ SECURED overload (enforces AssignedOnly visibility)\n                var byPhone = await _queryService.GetMessagesForConversationAsync(\n                    businessId, contactPhone, limit, uid, ct);\n\n                return Ok(byPhone);\n            }\n\n            // ‚úÖ SECURED overload (enforces AssignedOnly visibility)\n            var byPhonePage = await _queryService.GetMessagesPageForConversationByPhoneAsync(\n                businessId, contactPhone, limit, cursor, uid, ct);\n\n            return Ok(byPhonePage);\n        }\n\n        [HttpPost(\"send-message\")]\n        [ProducesResponseType(typeof(ChatInboxMessageDto), 200)]\n        public async Task<ActionResult<ChatInboxMessageDto>> SendMessage(\n            [FromBody] ChatInboxSendMessageRequestDto request,\n            CancellationToken ct = default)\n        {\n            if (request == null) return BadRequest(\"Request body is required.\");\n\n            var tokenBiz = GetBusinessId();\n            if (!tokenBiz.HasValue) return Unauthorized(\"businessId missing in token.\");\n\n            // Multi-tenant safety: never trust BusinessId from client; token wins.\n            request.BusinessId = tokenBiz.Value;\n\n            var tokenUserId = GetUserId();\n            if (!tokenUserId.HasValue) return Unauthorized(\"userId missing in token.\");\n\n            // ‚úÖ Critical: server-side actor identity\n            request.ActorUserId = tokenUserId.Value;\n\n            try\n            {\n                var result = await _commandService.SendAgentMessageAsync(request, ct);\n                return Ok(result);\n            }\n            catch (UnauthorizedAccessException ex)\n            {\n                _logger.LogWarning(\n                    ex,\n                    \"Forbidden chat-inbox send-message. BusinessId={BusinessId} ActorUserId={ActorUserId} ConversationId={ConversationId} ContactId={ContactId}\",\n                    request.BusinessId,\n                    tokenUserId.Value,\n                    request.ConversationId,\n                    request.ContactId);\n                return StatusCode(StatusCodes.Status403Forbidden, new { message = ex.Message });\n            }\n            catch (ArgumentException ex)\n            {\n                return BadRequest(ex.Message);\n            }\n            catch (InvalidOperationException ex)\n            {\n                return BadRequest(ex.Message);\n            }\n        }\n\n        //[HttpPost(\"mark-read\")]\n        //[ProducesResponseType(204)]\n        //public async Task<IActionResult> MarkRead(\n        //    [FromBody] ChatInboxMarkReadRequestDto request,\n        //    CancellationToken ct = default)\n        //{\n        //    if (request == null) return BadRequest(\"Request body is required.\");\n        //    if (request.BusinessId == Guid.Empty || request.ContactId == Guid.Empty)\n        //        return BadRequest(\"BusinessId and ContactId are required.\");\n\n        //    // ‚úÖ BusinessId MUST match token (security boundary)\n        //    var tokenBiz = GetBusinessId();\n        //    if (!tokenBiz.HasValue) return Unauthorized(\"businessId missing in token.\");\n        //    if (tokenBiz.Value != request.BusinessId) return Forbid(\"businessId does not match your tenant.\");\n\n        //    // ‚úÖ UserId MUST come from token (never trust client)\n        //    var tokenUserId = GetUserId();\n        //    if (!tokenUserId.HasValue) return Unauthorized(\"userId missing in token.\");\n\n        //    // Backward compatible: if client sent UserId, we ignore it and force token user.\n        //    request.UserId = tokenUserId.Value;\n\n        //    try\n        //    {\n        //        await _commandService.MarkConversationAsReadAsync(request, ct);\n        //        return NoContent();\n        //    }\n        //    catch (UnauthorizedAccessException ex)\n        //    {\n        //        _logger.LogWarning(\n        //            ex,\n        //            \"Forbidden chat-inbox mark-read. BusinessId={BusinessId} ActorUserId={ActorUserId} ContactId={ContactId}\",\n        //            request.BusinessId,\n        //            tokenUserId.Value,\n        //            request.ContactId);\n\n        //        return StatusCode(StatusCodes.Status403Forbidden, new { message = ex.Message });\n        //    }\n        //    catch (ArgumentException ex)\n        //    {\n        //        return BadRequest(ex.Message);\n        //    }\n        //    catch (InvalidOperationException ex)\n        //    {\n        //        return BadRequest(ex.Message);\n        //    }\n        //}\n        [HttpPost(\"mark-read\")]\n        [ProducesResponseType(204)]\n        public async Task<IActionResult> MarkRead(\n    [FromBody] ChatInboxMarkReadRequestDto request,\n    CancellationToken ct = default)\n        {\n            if (request == null) return BadRequest(\"Request body is required.\");\n            if (request.BusinessId == Guid.Empty || request.ContactId == Guid.Empty)\n                return BadRequest(\"BusinessId and ContactId are required.\");\n\n            var tokenBiz = GetBusinessId();\n            if (!tokenBiz.HasValue) return Unauthorized(\"businessId missing in token.\");\n            if (tokenBiz.Value != request.BusinessId) return Forbid(\"businessId does not match your tenant.\");\n\n            var tokenUserId = GetUserId();\n            if (!tokenUserId.HasValue) return Unauthorized(\"userId missing in token.\");\n\n            await _commandService.MarkConversationAsReadAsync(\n                request.BusinessId,\n                request.ContactId,\n                tokenUserId.Value,          // ‚úÖ token wins\n                request.LastReadAtUtc,\n                ct);\n\n            return NoContent();\n        }\n\n\n\n        [HttpPost(\"assign\")]\n        [ProducesResponseType(200)]\n        public async Task<IActionResult> Assign(\n            [FromBody] AssignConversationDto request,\n            CancellationToken ct = default)\n        {\n            if (request == null) return BadRequest(\"Request body is required.\");\n\n            if (request.BusinessId == Guid.Empty ||\n                request.ContactId == Guid.Empty ||\n                request.UserId == Guid.Empty)\n            {\n                return BadRequest(\"BusinessId, ContactId and UserId are required.\");\n            }\n\n            var tokenBiz = GetBusinessId();\n            if (!tokenBiz.HasValue) return Unauthorized(\"businessId missing in token.\");\n            if (tokenBiz.Value != request.BusinessId) return Forbid(\"businessId does not match your tenant.\");\n\n            var actorUserId = GetUserId();\n            if (!actorUserId.HasValue) return Unauthorized(\"userId missing in token.\");\n\n            try\n            {\n                await _assignmentService.AssignAsync(\n                    request.BusinessId,\n                    request.ContactId,\n                    request.UserId,\n                    actorUserId.Value,\n                    ct);\n\n                var updated = await TryGetConversationAsync(\n                    request.BusinessId,\n                    request.ContactId,\n                    actorUserId.Value,\n                    ct);\n\n                return Ok(new { success = true, conversation = updated });\n            }\n            catch (UnauthorizedAccessException ex)\n            {\n                _logger.LogWarning(\n                    ex,\n                    \"Forbidden chat-inbox assign. BusinessId={BusinessId} ActorUserId={ActorUserId} ContactId={ContactId} AssigneeUserId={AssigneeUserId}\",\n                    request.BusinessId,\n                    actorUserId.Value,\n                    request.ContactId,\n                    request.UserId);\n                return StatusCode(StatusCodes.Status403Forbidden, new { message = ex.Message });\n            }\n            catch (InvalidOperationException ex)\n            {\n                return NotFound(ex.Message);\n            }\n            catch (ArgumentException ex)\n            {\n                return BadRequest(ex.Message);\n            }\n        }\n\n        [HttpPost(\"unassign\")]\n        [ProducesResponseType(200)]\n        public async Task<IActionResult> Unassign(\n            [FromBody] UnassignConversationDto request,\n            CancellationToken ct = default)\n        {\n            if (request == null) return BadRequest(\"Request body is required.\");\n\n            if (request.BusinessId == Guid.Empty || request.ContactId == Guid.Empty)\n                return BadRequest(\"BusinessId and ContactId are required.\");\n\n            var tokenBiz = GetBusinessId();\n            if (!tokenBiz.HasValue) return Unauthorized(\"businessId missing in token.\");\n            if (tokenBiz.Value != request.BusinessId) return Forbid(\"businessId does not match your tenant.\");\n\n            var actorUserId = GetUserId();\n            if (!actorUserId.HasValue) return Unauthorized(\"userId missing in token.\");\n\n            try\n            {\n                await _assignmentService.UnassignAsync(\n                    request.BusinessId,\n                    request.ContactId,\n                    actorUserId.Value,\n                    ct);\n\n                var updated = await TryGetConversationAsync(\n                    request.BusinessId,\n                    request.ContactId,\n                    actorUserId.Value,\n                    ct);\n\n                return Ok(new { success = true, conversation = updated });\n            }\n            catch (UnauthorizedAccessException ex)\n            {\n                _logger.LogWarning(\n                    ex,\n                    \"Forbidden chat-inbox unassign. BusinessId={BusinessId} ActorUserId={ActorUserId} ContactId={ContactId}\",\n                    request.BusinessId,\n                    actorUserId.Value,\n                    request.ContactId);\n                return StatusCode(StatusCodes.Status403Forbidden, new { message = ex.Message });\n            }\n            catch (InvalidOperationException ex)\n            {\n                return NotFound(ex.Message);\n            }\n            catch (ArgumentException ex)\n            {\n                return BadRequest(ex.Message);\n            }\n        }\n\n        [HttpPost(\"set-status\")]\n        [ProducesResponseType(200)]\n        public async Task<IActionResult> SetStatus(\n            [FromBody] SetConversationStatusDto request,\n            CancellationToken ct = default)\n        {\n            if (request == null) return BadRequest(\"Request body is required.\");\n\n            if (request.BusinessId == Guid.Empty || request.ContactId == Guid.Empty)\n                return BadRequest(\"BusinessId and ContactId are required.\");\n\n            var tokenBiz = GetBusinessId();\n            if (!tokenBiz.HasValue) return Unauthorized(\"businessId missing in token.\");\n            if (tokenBiz.Value != request.BusinessId) return Forbid(\"businessId does not match your tenant.\");\n\n            var actorUserId = GetUserId();\n            if (!actorUserId.HasValue) return Unauthorized(\"userId missing in token.\");\n\n            try\n            {\n                await _assignmentService.SetStatusAsync(\n                    request.BusinessId,\n                    request.ContactId,\n                    request.Status,\n                    actorUserId.Value,\n                    ct);\n\n                var updated = await TryGetConversationAsync(\n                    request.BusinessId,\n                    request.ContactId,\n                    actorUserId.Value,\n                    ct);\n\n                return Ok(new { success = true, conversation = updated });\n            }\n            catch (UnauthorizedAccessException ex)\n            {\n                _logger.LogWarning(\n                    ex,\n                    \"Forbidden chat-inbox set-status. BusinessId={BusinessId} ActorUserId={ActorUserId} ContactId={ContactId} Status={Status}\",\n                    request.BusinessId,\n                    actorUserId.Value,\n                    request.ContactId,\n                    request.Status);\n                return StatusCode(StatusCodes.Status403Forbidden, new { message = ex.Message });\n            }\n            catch (InvalidOperationException ex)\n            {\n                return NotFound(ex.Message);\n            }\n            catch (ArgumentException ex)\n            {\n                return BadRequest(ex.Message);\n            }\n        }\n\n        private Guid? GetBusinessId()\n        {\n            var raw = User.FindFirstValue(\"businessId\") ?? User.FindFirstValue(\"BusinessId\");\n            return Guid.TryParse(raw, out var id) ? id : null;\n        }\n\n        private Guid? GetUserId()\n        {\n            var raw = User.FindFirstValue(ClaimTypes.NameIdentifier) ?? User.FindFirstValue(\"id\");\n            return Guid.TryParse(raw, out var id) ? id : null;\n        }\n\n        private async Task EnsureCanAccessContactAsync(\n            Guid businessId,\n            Guid userId,\n            Guid contactId,\n            CancellationToken ct)\n        {\n            var visibility = await _db.Businesses\n                .AsNoTracking()\n                .Where(b => b.Id == businessId)\n                .Select(b => (InboxVisibilityMode?)b.InboxVisibilityMode)\n                .FirstOrDefaultAsync(ct)\n                .ConfigureAwait(false) ?? InboxVisibilityMode.SharedInInbox;\n\n            if (visibility != InboxVisibilityMode.AssignedOnly) return;\n\n            var canSeeAll = await CanSeeAllInRestrictedModeAsync(businessId, userId, ct).ConfigureAwait(false);\n            if (canSeeAll) return;\n\n            var allowed = await _db.Contacts\n                .AsNoTracking()\n                .AnyAsync(c =>\n                    c.BusinessId == businessId &&\n                    c.Id == contactId &&\n                    c.AssignedAgentId == userId, ct)\n                .ConfigureAwait(false);\n\n            if (!allowed)\n                throw new UnauthorizedAccessException(\"Restricted inbox: you are not assigned to this conversation.\");\n        }\n\n        private static bool IsPrivilegedRoleName(string? roleName)\n        {\n            var role = (roleName ?? string.Empty).Trim().ToLowerInvariant();\n            return role is \"admin\" or \"business\" or \"superadmin\" or \"partner\";\n        }\n\n        private async Task<bool> CanSeeAllInRestrictedModeAsync(Guid businessId, Guid userId, CancellationToken ct)\n        {\n            var userRow = await _db.Users\n                .AsNoTracking()\n                .Where(u => u.Id == userId && u.BusinessId == businessId && !u.IsDeleted && u.Status == \"Active\")\n                .Select(u => new\n                {\n                    u.RoleId,\n                    RoleName = u.Role != null ? u.Role.Name : null\n                })\n                .FirstOrDefaultAsync(ct)\n                .ConfigureAwait(false);\n\n            if (userRow == null) return false;\n\n            if (IsPrivilegedRoleName(userRow.RoleName))\n                return true;\n\n            return await HasPermissionAsync(userId, InboxAssignPermissionCode, ct).ConfigureAwait(false);\n        }\n\n        private async Task<bool> HasPermissionAsync(Guid userId, string permissionCode, CancellationToken ct)\n        {\n            var code = (permissionCode ?? string.Empty).Trim().ToUpperInvariant();\n            if (code.Length == 0) return false;\n\n            var permissionId = await _db.Permissions\n                .AsNoTracking()\n                .Where(p => p.Code != null && p.Code.ToUpper() == code)\n                .Select(p => (Guid?)p.Id)\n                .FirstOrDefaultAsync(ct)\n                .ConfigureAwait(false);\n\n            if (!permissionId.HasValue) return false;\n\n            var direct = await _db.UserPermissions\n                .AsNoTracking()\n                .AnyAsync(up =>\n                    up.UserId == userId &&\n                    up.PermissionId == permissionId.Value &&\n                    up.IsGranted &&\n                    !up.IsRevoked, ct)\n                .ConfigureAwait(false);\n\n            if (direct) return true;\n\n            var roleId = await _db.Users\n                .AsNoTracking()\n                .Where(u => u.Id == userId)\n                .Select(u => u.RoleId)\n                .FirstOrDefaultAsync(ct)\n                .ConfigureAwait(false);\n\n            if (!roleId.HasValue) return false;\n\n            return await _db.RolePermissions\n                .AsNoTracking()\n                .AnyAsync(rp =>\n                    rp.RoleId == roleId.Value &&\n                    rp.PermissionId == permissionId.Value &&\n                    rp.IsActive &&\n                    !rp.IsRevoked, ct)\n                .ConfigureAwait(false);\n        }\n\n        private async Task<ChatInboxConversationDto?> TryGetConversationAsync(\n            Guid businessId,\n            Guid contactId,\n            Guid currentUserId,\n            CancellationToken ct)\n        {\n            var rows = await _queryService.GetConversationsAsync(\n                    new ChatInboxFilterDto\n                    {\n                        BusinessId = businessId,\n                        CurrentUserId = currentUserId,\n                        ContactId = contactId,\n                        Limit = 1\n                    },\n                    ct)\n                .ConfigureAwait(false);\n\n            return rows.FirstOrDefault();\n        }\n    }\n}\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/AgentDto.cs",
      "sha256": "39fd6eeec1233fec19f32ed1469ce217e586a955f1ea169451717c0773ef8c0f",
      "language": "csharp",
      "size": 311,
      "content": "using System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    public sealed class AgentDto\n    {\n        public Guid Id { get; set; }\n        public string Name { get; set; } = string.Empty;\n        public string Email { get; set; } = string.Empty;\n        public string? RoleName { get; set; }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/AssignConversationDto.cs",
      "sha256": "b2ef282b759c81018f7a8c7d3cba0dbe28e69910dec66d2a49f34d5045a5484f",
      "language": "csharp",
      "size": 256,
      "content": "using System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    public sealed class AssignConversationDto\n    {\n        public Guid BusinessId { get; set; }\n        public Guid ContactId { get; set; }\n        public Guid UserId { get; set; }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ChatInboxAssignRequestDto.cs",
      "sha256": "1070b71e595443da5bb86c5ae223123d517333fd06193925c55359d7d2e869ae",
      "language": "csharp",
      "size": 1156,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/DTOs/ChatInboxAssignRequestDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    /// <summary>\n    /// Request payload for assigning a conversation (contact) to a specific user.\n    /// </summary>\n    public sealed class ChatInboxAssignRequestDto\n    {\n        /// <summary>\n        /// Tenant/business id.\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// Contact id representing the conversation.\n        /// </summary>\n        public Guid ContactId { get; set; }\n\n        /// <summary>\n        /// Agent/user who will own this conversation.\n        /// </summary>\n        public Guid UserId { get; set; }\n    }\n\n    /// <summary>\n    /// Request payload for unassigning a conversation.\n    /// </summary>\n    public sealed class ChatInboxUnassignRequestDto\n    {\n        /// <summary>\n        /// Tenant/business id.\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// Contact id representing the conversation.\n        /// </summary>\n        public Guid ContactId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ChatInboxChangeStatusRequestDto.cs",
      "sha256": "caa15f4feb193863671beebe56a0421fababa24609b3249d3e63742645710a2e",
      "language": "csharp",
      "size": 1063,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/DTOs/ChatInboxChangeStatusRequestDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    /// <summary>\n    /// Command payload for changing the status of an Inbox conversation.\n    /// Internally this maps to Contact.IsArchived / IsActive.\n    /// </summary>\n    public sealed class ChatInboxChangeStatusRequestDto\n    {\n        /// <summary>\n        /// Tenant / business id (required).\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// Contact whose conversation we want to change (required).\n        /// </summary>\n        public Guid ContactId { get; set; }\n\n        /// <summary>\n        /// Target status: \"Open\" | \"Closed\" (case-insensitive).\n        /// We also accept \"New\"/\"Pending\" but treat them as Open internally.\n        /// </summary>\n        public string? TargetStatus { get; set; }\n\n        // Compatibility alias for newer clients posting { status: \"Open\"|\"Pending\"|\"Closed\" }\n        public string? Status { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ChatInboxConversationDto.cs",
      "sha256": "83d1e01c8c7b6c57f0bfc96714d5ef38287e0d3e7858149adb32b9ed12636678",
      "language": "csharp",
      "size": 2559,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/DTOs/ChatInboxConversationDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    /// <summary>\n    /// Lightweight conversation summary for the Chat Inbox UI.\n    /// Mirrors the front-end ConversationSummary model.\n    /// </summary>\n    public sealed class ChatInboxConversationDto\n    {\n        /// <summary>\n        /// Conversation identifier for the UI.\n        /// For v1 this can be derived from (ContactId + NumberId).\n        /// In the future, if you create an InboxConversation table,\n        /// use its primary key here.\n        /// </summary>\n        public string Id { get; set; } = default!;\n\n        public Guid ContactId { get; set; }\n        public string ContactName { get; set; } = string.Empty;\n        public string ContactPhone { get; set; } = string.Empty;\n\n        public string LastMessagePreview { get; set; } = string.Empty;\n        public DateTime LastMessageAt { get; set; }\n\n        public int UnreadCount { get; set; }\n\n        /// <summary>\n        /// \"New\" | \"Open\" | \"Pending\" | \"Closed\"\n        /// </summary>\n        public string Status { get; set; } = \"Open\";\n\n        /// <summary>\n        /// WhatsApp number id (e.g. wa-num-1).\n        /// Later you may map this to WhatsAppPhoneNumber.Id.\n        /// </summary>\n        public string NumberId { get; set; } = string.Empty;\n\n        public string NumberLabel { get; set; } = string.Empty;\n\n        /// <summary>\n        /// True if within 24h messaging window (WhatsApp session).\n        /// </summary>\n        public bool Within24h { get; set; }\n\n        public string? AssignedToUserId { get; set; }\n        public string? AssignedToUserName { get; set; }\n        public bool IsAssignedToMe { get; set; }\n\n        /// <summary>\n        /// \"automation\" | \"agent\"\n        /// </summary>\n        public string Mode { get; set; } = \"automation\";\n\n        /// <summary>\n        /// \"AutoReply\" | \"Campaign\" | \"Manual\" | \"Unknown\"\n        /// </summary>\n        public string SourceType { get; set; } = \"Unknown\";\n\n        /// <summary>\n        /// Campaign name / AutoReply flow name / other source label.\n        /// </summary>\n        public string? SourceName { get; set; }\n\n        public DateTime? FirstSeenAt { get; set; }\n        public DateTime? LastInboundAt { get; set; }\n        public DateTime? LastOutboundAt { get; set; }\n        public int TotalMessages { get; set; }\n\n        public DateTime? LastAgentReplyAt { get; set; }\n        public DateTime? LastAutomationAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ChatInboxCursorPageDto.cs",
      "sha256": "5b9d3ba892a383e22762a110b1cbfd2038d445929c9ab4b03b9d0c339b840123",
      "language": "csharp",
      "size": 520,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/DTOs/ChatInboxCursorPageDto.cs\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    /// <summary>\n    /// Cursor-based page response (stable for chat inbox).\n    /// </summary>\n    public sealed class ChatInboxCursorPageDto<T>\n    {\n        public IReadOnlyList<T> Items { get; init; } = new List<T>();\n        public string? NextCursor { get; init; }\n        public bool HasMore { get; init; }\n        public int Limit { get; init; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ChatInboxFilterDto.cs",
      "sha256": "b99a5373eb144c852da882a680e3fb479d1a5b649af882f3465e9e30715968a0",
      "language": "csharp",
      "size": 1916,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/DTOs/ChatInboxFilterDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    /// <summary>\n    /// Filters used by the Chat Inbox conversation list endpoint.\n    /// This matches the UI needs: tab, number, search, \"my\" vs \"unassigned\".\n    /// </summary>\n    public sealed class ChatInboxFilterDto\n    {\n        /// <summary>\n        /// Business Id (tenant). Mandatory for multi-tenant isolation.\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        public string? Cursor { get; set; }\n        /// <summary>\n        /// Currently logged-in user id (for \"my\" filter).\n        /// Optional: if null, \"my\" filter is ignored.\n        /// </summary>\n        public Guid? CurrentUserId { get; set; }\n\n        /// <summary>\n        /// \"live\" | \"older\" | \"unassigned\" | \"my\" | \"closed\"\n        /// </summary>\n        public string? Tab { get; set; }\n\n        /// <summary>\n        /// Optional: fetch a single conversation by contact id.\n        /// </summary>\n        public Guid? ContactId { get; set; }\n\n        /// <summary>\n        /// WhatsApp number id, e.g. \"wa-num-1\". If null or \"all\", no filter.\n        /// </summary>\n        public string? NumberId { get; set; }\n\n        /// <summary>\n        /// Free text search over name, phone, and last message preview.\n        /// </summary>\n        public string? SearchTerm { get; set; }\n\n        /// <summary>\n        /// Max number of conversations to return. Hard-capped to 200.\n        /// </summary>\n        public int Limit { get; set; } = 50;\n\n        /// <summary>\n        /// If true: only conversations without AssignedToUserId.\n        /// </summary>\n        public bool OnlyUnassigned { get; set; }\n\n        /// <summary>\n        /// If true: only conversations assigned to CurrentUserId.\n        /// </summary>\n        public bool OnlyAssignedToMe { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ChatInboxMarkReadRequestDto.cs",
      "sha256": "a149e08b11d6e43c54066ace777250ca1a630fbe15ef812f7fdc73b6fa67d3d0",
      "language": "csharp",
      "size": 864,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/DTOs/ChatInboxMarkReadRequestDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    /// <summary>\n    /// Request payload for marking a conversation as \"read\"\n    /// in the Chat Inbox.\n    /// </summary>\n    public sealed class ChatInboxMarkReadRequestDto\n    {\n        /// <summary>\n        /// Tenant/business id (required for multi-tenant isolation).\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// CRM Contact id whose messages are being marked as read.\n        /// </summary>\n        public Guid ContactId { get; set; }\n\n        /// <summary>\n        /// Optional timestamp for \"last read\". If not supplied,\n        /// the server will use DateTime.UtcNow.\n        /// </summary>\n        public DateTime? LastReadAtUtc { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ChatInboxMediaUploadRequestDto.cs",
      "sha256": "6374d18d1fa2a5ae289a17972f84c6693d0631ce10d312053e64f62c425b8415",
      "language": "csharp",
      "size": 274,
      "content": "using System.ComponentModel.DataAnnotations;\nusing Microsoft.AspNetCore.Http;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    public sealed class ChatInboxMediaUploadRequestDto\n    {\n        [Required]\n        public IFormFile File { get; set; } = default!;\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ChatInboxMediaUploadResponseDto.cs",
      "sha256": "ae80a0e2830c284d7c7a52d12f86a10e59a9e6959951252d9e532b9c4a6d6bb6",
      "language": "csharp",
      "size": 489,
      "content": "namespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    public sealed class ChatInboxMediaUploadResponseDto\n    {\n        public string MediaId { get; set; } = string.Empty;\n\n        /// <summary>\n        /// \"image\" | \"document\"\n        /// </summary>\n        public string MediaType { get; set; } = string.Empty;\n\n        public string FileName { get; set; } = string.Empty;\n        public string MimeType { get; set; } = string.Empty;\n        public long SizeBytes { get; set; }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ChatInboxMessageDto.cs",
      "sha256": "f8f922c594dd6eab46fd6a23854879e9656d87965e61b0a7376d101d1e1b06e3",
      "language": "csharp",
      "size": 2484,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/DTOs/ChatInboxMessageDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    /// <summary>\n    /// Single message in a Chat Inbox conversation.\n    /// Kept intentionally simple and stable so the React UI\n    /// can bind to it without worrying about provider details.\n    /// </summary>\n    public sealed class ChatInboxMessageDto\n    {\n        public Guid Id { get; set; }\n\n        /// <summary>\n        /// \"in\"  = message came from customer to us.\n        /// \"out\" = message we sent to customer.\n        /// For now we only have reliable data for \"out\"; we keep\n        /// the string type so we can extend it later without schema changes.\n        /// </summary>\n        public string Direction { get; set; } = \"out\";\n\n        /// <summary>\n        /// Channel identifier (e.g. \"whatsapp\") ‚Äì future-proofing.\n        /// </summary>\n        public string Channel { get; set; } = \"whatsapp\";\n\n        /// <summary>\n        /// Rendered text content for the bubble.\n        /// For templates we'll store the final rendered body.\n        /// </summary>\n        public string Text { get; set; } = string.Empty;\n\n        /// <summary>\n        /// WhatsApp media_id (if this is a media message).\n        /// </summary>\n        public string? MediaId { get; set; }\n\n        /// <summary>\n        /// \"image\" | \"document\" | \"video\" | \"audio\" | \"location\"\n        /// </summary>\n        public string? MediaType { get; set; }\n\n        public string? FileName { get; set; }\n        public string? MimeType { get; set; }\n\n        // Location message fields (when MediaType == \"location\")\n        public double? LocationLatitude { get; set; }\n        public double? LocationLongitude { get; set; }\n        public string? LocationName { get; set; }\n        public string? LocationAddress { get; set; }\n\n        /// <summary>\n        /// When we created/sent the message (UTC).\n        /// If SentAt is missing, falls back to CreatedAt.\n        /// </summary>\n        public DateTime SentAtUtc { get; set; }\n\n        /// <summary>\n        /// Provider / delivery status (‚ÄúSent‚Äù, ‚ÄúDelivered‚Äù, ‚ÄúRead‚Äù, ‚ÄúFailed‚Äù, etc.),\n        /// mapped from MessageLog.Status.\n        /// </summary>\n        public string? Status { get; set; }\n\n        /// <summary>\n        /// For failed messages, a short error string from MessageLog.ErrorMessage.\n        /// </summary>\n        public string? ErrorMessage { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ChatInboxSendMessageRequestDto.cs",
      "sha256": "0a72e0104e08707d417ff580ebf77e10e625d9b19e431c9bca6d8efad72ef923",
      "language": "csharp",
      "size": 2198,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/DTOs/ChatInboxSendMessageRequestDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    /// <summary>\n    /// Request payload for sending an agent reply from the Chat Inbox.\n    /// NOTE: ActorUserId is ALWAYS set by the server from JWT claims.\n    /// The client should NOT send it (and we ignore it if they do).\n    /// </summary>\n    public sealed class ChatInboxSendMessageRequestDto\n    {\n        public Guid BusinessId { get; set; }\n\n        public string? ConversationId { get; set; }\n\n        public Guid? ContactId { get; set; }\n\n        public string To { get; set; } = string.Empty;\n\n        public string? NumberId { get; set; }\n\n        /// <summary>\n        /// Optional for media messages. Required when sending plain text.\n        /// For media, this becomes the optional caption.\n        /// </summary>\n        public string? Text { get; set; }\n\n        /// <summary>\n        /// WhatsApp Cloud API media id returned by /{phone_number_id}/media upload.\n        /// </summary>\n        public string? MediaId { get; set; }\n\n        /// <summary>\n        /// \"image\" | \"document\" | \"video\" | \"audio\"\n        /// For location messages, send coordinates and set MediaType to \"location\" (MediaId must be null).\n        /// </summary>\n        public string? MediaType { get; set; }\n\n        /// <summary>\n        /// Original filename for UI display (optional).\n        /// </summary>\n        public string? FileName { get; set; }\n\n        /// <summary>\n        /// Client-supplied mime type for display/logging (optional).\n        /// </summary>\n        public string? MimeType { get; set; }\n\n        /// <summary>\n        /// Optional: WhatsApp \"location\" message fields.\n        /// When provided, MediaId must be null.\n        /// </summary>\n        public double? LocationLatitude { get; set; }\n        public double? LocationLongitude { get; set; }\n        public string? LocationName { get; set; }\n        public string? LocationAddress { get; set; }\n\n        /// <summary>\n        /// Server-side only (claims). Controller will overwrite it.\n        /// </summary>\n        public Guid ActorUserId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ConversationSummaryDto.cs",
      "sha256": "8d4800233670cbca833d145eba5da1a64e0b2a520e5f5bfc65ea5a36c2c9ce86",
      "language": "csharp",
      "size": 2421,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    /// <summary>\n    /// Read model used by the Chat Inbox to show the left-hand conversation list.\n    /// Mirrors the shape used in ChatInbox.jsx (INITIAL_CONVERSATIONS).\n    /// </summary>\n    public class ConversationSummaryDto\n    {\n        public Guid ContactId { get; set; }\n\n        /// <summary>\n        /// Primary display name (CRM contact name).\n        /// </summary>\n        public string? Name { get; set; }\n\n        /// <summary>\n        /// WhatsApp phone number (normalized).\n        /// </summary>\n        public string PhoneNumber { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Latest WhatsApp profile.name we saw.\n        /// </summary>\n        public string? ProfileName { get; set; }\n\n        /// <summary>\n        /// Short preview of the last message in this conversation.\n        /// </summary>\n        public string? LastMessagePreview { get; set; }\n\n        /// <summary>\n        /// When the last message was seen/sent.\n        /// </summary>\n        public DateTime? LastMessageAt { get; set; }\n\n        /// <summary>\n        /// Count of unread inbound messages for this contact.\n        /// </summary>\n        public int UnreadCount { get; set; }\n\n        /// <summary>\n        /// Priority like \"Hot\", \"Warm\", \"Cold\" (CRM-driven, optional).\n        /// </summary>\n        public string? Priority { get; set; }\n\n        /// <summary>\n        /// True if this contact is treated as VIP or important.\n        /// </summary>\n        public bool IsVip { get; set; }\n\n        /// <summary>\n        /// Conversation mode: \"automation\" or \"agent\".\n        /// </summary>\n        public string Mode { get; set; } = \"automation\";\n\n        /// <summary>\n        /// Name of the assigned agent (if any).\n        /// </summary>\n        public string? AssignedAgentName { get; set; }\n\n        /// <summary>\n        /// CRM tags as chips for quick context (e.g. VIP, Lead, Follow-up).\n        /// </summary>\n        public List<string> Tags { get; set; } = new();\n\n        /// <summary>\n        /// Text like \"3 notes ‚Ä¢ 1 reminder today\".\n        /// </summary>\n        public string? LastActivitySummary { get; set; }\n\n        /// <summary>\n        /// Text like \"Next follow-up tomorrow at 11:30 AM\".\n        /// </summary>\n        public string? TaskSummary { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/PagedResultDto.cs",
      "sha256": "256698ff426847411942435cade73faa92f50fc27f5e7dbc7c0f762636295a9c",
      "language": "csharp",
      "size": 300,
      "content": "using System.Collections.Generic;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    public sealed class PagedResultDto<T>\n    {\n        public IReadOnlyList<T> Items { get; set; } = new List<T>();\n        public string? NextCursor { get; set; }\n        public bool HasMore { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/SetConversationStatusDto.cs",
      "sha256": "5686e967c1ba7e485a8d5f69b4da51b3a69d36cc023b4ad5fbd04d7cba000ec0",
      "language": "csharp",
      "size": 277,
      "content": "using System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    public sealed class SetConversationStatusDto\n    {\n        public Guid BusinessId { get; set; }\n        public Guid ContactId { get; set; }\n        public string Status { get; set; } = string.Empty;\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/UnassignConversationDto.cs",
      "sha256": "0b4e055e968dada296fa15e5e67504d866f3fa7f6eaef725a22ff4461a7a47cf",
      "language": "csharp",
      "size": 217,
      "content": "using System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    public sealed class UnassignConversationDto\n    {\n        public Guid BusinessId { get; set; }\n        public Guid ContactId { get; set; }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/Models/InboxVisibilityMode.cs",
      "sha256": "bc601a083f20bb953e8ea9e5ea77287d22bbe2fc6998ab7b0e6ace4658896154",
      "language": "csharp",
      "size": 154,
      "content": "namespace xbytechat.api.Features.ChatInbox.Models\n{\n    public enum InboxVisibilityMode\n    {\n        SharedInInbox = 0,\n        AssignedOnly = 1\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/Services/ChatInboxAssignmentService.cs",
      "sha256": "2f77b7126a586ad3ce50d7958c4b37735d813513c50850985f314c6247f46bdd",
      "language": "csharp",
      "size": 14600,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.SignalR;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.AuthModule.Models;\nusing xbytechat.api.Features.AccessControl.Models;\nusing xbytechat.api.Features.ChatInbox.DTOs;\nusing xbytechat.api.Features.CRM.Models;\nusing xbytechat.api.Features.Inbox.Hubs;\n\nnamespace xbytechat.api.Features.ChatInbox.Services\n{\n    public sealed class ChatInboxAssignmentService : IChatInboxAssignmentService\n    {\n        private const string InboxAssignPermissionCode = \"INBOX.CHAT.ASSIGN\";\n\n        private readonly AppDbContext _db;\n        private readonly ILogger<ChatInboxAssignmentService> _logger;\n        private readonly IHubContext<InboxHub> _hub;\n\n        public ChatInboxAssignmentService(\n            AppDbContext db,\n            ILogger<ChatInboxAssignmentService> logger,\n            IHubContext<InboxHub> hub)\n        {\n            _db = db ?? throw new ArgumentNullException(nameof(db));\n            _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n            _hub = hub ?? throw new ArgumentNullException(nameof(hub));\n        }\n\n        public async Task<List<AgentDto>> GetAgentsAsync(Guid businessId, CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty)\n                throw new ArgumentException(\"BusinessId is required.\", nameof(businessId));\n\n            var agents = await _db.Users\n                .AsNoTracking()\n                .Where(u => u.BusinessId == businessId && !u.IsDeleted && u.Status == \"Active\")\n                .Include(u => u.Role)\n                .OrderBy(u => u.Name)\n                .Select(u => new AgentDto\n                {\n                    Id = u.Id,\n                    Name = u.Name ?? u.Email,\n                    Email = u.Email,\n                    RoleName = u.Role != null ? u.Role.Name : null\n                })\n                .ToListAsync(ct)\n                .ConfigureAwait(false);\n\n            return agents;\n        }\n\n        public async Task AssignAsync(\n            Guid businessId,\n            Guid contactId,\n            Guid userId,\n            Guid actorUserId,\n            CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty) throw new ArgumentException(\"BusinessId is required.\", nameof(businessId));\n            if (contactId == Guid.Empty) throw new ArgumentException(\"ContactId is required.\", nameof(contactId));\n            if (userId == Guid.Empty) throw new ArgumentException(\"UserId is required.\", nameof(userId));\n            if (actorUserId == Guid.Empty) throw new ArgumentException(\"ActorUserId is required.\", nameof(actorUserId));\n\n            var actor = await LoadActiveBusinessUserAsync(businessId, actorUserId, ct).ConfigureAwait(false);\n            _ = await LoadActiveBusinessUserAsync(businessId, userId, ct).ConfigureAwait(false); // validate target exists + active\n\n            var isSelfAssign = actorUserId == userId;\n            var canAssignOthers = await CanAssignOthersAsync(actor, ct).ConfigureAwait(false);\n\n            // ? If assigning someone else, permission required\n            if (!isSelfAssign && !canAssignOthers)\n                throw new UnauthorizedAccessException(\"Not allowed to assign conversations to other agents.\");\n\n            // ? Atomic rules:\n            // - Privileged/assign-perm can assign/reassign freely.\n            // - Self-assign without privilege is allowed ONLY when currently unassigned (prevents stealing).\n            var q = _db.Contacts.Where(c => c.BusinessId == businessId && c.Id == contactId);\n\n            if (isSelfAssign && !canAssignOthers)\n                q = q.Where(c => c.AssignedAgentId == null);\n\n            var updated = await q\n                .ExecuteUpdateAsync(\n                    setters => setters.SetProperty(c => c.AssignedAgentId, userId),\n                    ct)\n                .ConfigureAwait(false);\n\n            if (updated == 0)\n            {\n                if (isSelfAssign && !canAssignOthers)\n                    throw new UnauthorizedAccessException(\"Not allowed to self-assign. This chat is already assigned to another agent.\");\n\n                throw new InvalidOperationException(\"Contact not found for assignment.\");\n            }\n\n            _logger.LogInformation(\n                \"ChatInbox assigned. BusinessId={BusinessId} ContactId={ContactId} AssignedToUserId={AssignedToUserId} ActorUserId={ActorUserId}\",\n                businessId, contactId, userId, actorUserId);\n\n            await BroadcastRefreshAsync(businessId).ConfigureAwait(false);\n        }\n\n\n\n        public async Task UnassignAsync(Guid businessId, Guid contactId, Guid actorUserId, CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty) throw new ArgumentException(\"BusinessId is required.\", nameof(businessId));\n            if (contactId == Guid.Empty) throw new ArgumentException(\"ContactId is required.\", nameof(contactId));\n            if (actorUserId == Guid.Empty) throw new ArgumentException(\"ActorUserId is required.\", nameof(actorUserId));\n\n            var actor = await LoadActiveBusinessUserAsync(businessId, actorUserId, ct).ConfigureAwait(false);\n            var canAssignOthers = await CanAssignOthersAsync(actor, ct).ConfigureAwait(false);\n\n            // ? Atomic rules:\n            // - Privileged/assign-perm can unassign freely.\n            // - Non-privileged can unassign ONLY if currently assigned to them (or already unassigned).\n            var q = _db.Contacts.Where(c => c.BusinessId == businessId && c.Id == contactId);\n\n            if (!canAssignOthers)\n                q = q.Where(c => c.AssignedAgentId == null || c.AssignedAgentId == actorUserId);\n\n            var updated = await q\n                .ExecuteUpdateAsync(setters => setters.SetProperty(c => c.AssignedAgentId, (Guid?)null), ct)\n                .ConfigureAwait(false);\n\n            if (updated == 0)\n            {\n                // ? Perfect distinction: not found vs not allowed\n                var exists = await _db.Contacts\n                    .AsNoTracking()\n                    .AnyAsync(c => c.BusinessId == businessId && c.Id == contactId, ct)\n                    .ConfigureAwait(false);\n\n                if (!exists)\n                    throw new InvalidOperationException(\"Contact not found.\");\n\n                throw new UnauthorizedAccessException(\"Not allowed to unassign conversations owned by another agent.\");\n            }\n\n            _logger.LogInformation(\n                \"ChatInbox unassigned. BusinessId={BusinessId} ContactId={ContactId} ActorUserId={ActorUserId}\",\n                businessId, contactId, actorUserId);\n\n            await BroadcastRefreshAsync(businessId).ConfigureAwait(false);\n        }\n\n\n        public async Task SetStatusAsync(\n            Guid businessId,\n            Guid contactId,\n            string status,\n            Guid actorUserId,\n            CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty) throw new ArgumentException(\"BusinessId is required.\", nameof(businessId));\n            if (contactId == Guid.Empty) throw new ArgumentException(\"ContactId is required.\", nameof(contactId));\n            if (actorUserId == Guid.Empty) throw new ArgumentException(\"ActorUserId is required.\", nameof(actorUserId));\n\n            var normalized = NormalizeStatus(status);\n            if (normalized == null)\n                throw new ArgumentException(\"Status must be one of: Open, Pending, Closed.\", nameof(status));\n\n            var actor = await LoadActiveBusinessUserAsync(businessId, actorUserId, ct).ConfigureAwait(false);\n            var contact = await LoadBusinessContactAsync(businessId, contactId, ct).ConfigureAwait(false);\n\n            var canUpdate =\n                IsPrivilegedRole(actor) ||\n                (contact.AssignedAgentId.HasValue && contact.AssignedAgentId.Value == actorUserId);\n\n            if (!canUpdate)\n                throw new UnauthorizedAccessException(\"Not allowed to update this conversation status.\");\n\n            contact.InboxStatus = normalized;\n\n            // Back-compat for older query logic\n            if (normalized == \"Closed\")\n            {\n                contact.IsArchived = true;\n                contact.IsActive = false;\n            }\n            else\n            {\n                contact.IsArchived = false;\n                contact.IsActive = true;\n            }\n\n            _logger.LogInformation(\n                \"ChatInbox status updated. BusinessId={BusinessId} ContactId={ContactId} Status={Status} ActorUserId={ActorUserId}\",\n                businessId, contactId, normalized, actorUserId);\n\n            await _db.SaveChangesAsync(ct).ConfigureAwait(false);\n            await BroadcastRefreshAsync(businessId).ConfigureAwait(false);\n        }\n\n        private static string? NormalizeStatus(string? status)\n        {\n            var raw = (status ?? string.Empty).Trim();\n            if (raw.Length == 0) return null;\n\n            var lower = raw.ToLowerInvariant();\n            return lower switch\n            {\n                \"open\" => \"Open\",\n                \"pending\" => \"Pending\",\n                \"closed\" => \"Closed\",\n                _ => null\n            };\n        }\n\n        private async Task<Contact> LoadBusinessContactAsync(Guid businessId, Guid contactId, CancellationToken ct)\n        {\n            var contact = await _db.Contacts\n                .FirstOrDefaultAsync(c => c.BusinessId == businessId && c.Id == contactId, ct)\n                .ConfigureAwait(false);\n\n            if (contact == null)\n                throw new InvalidOperationException(\"Contact not found.\");\n\n            return contact;\n        }\n\n        private async Task<User> LoadActiveBusinessUserAsync(Guid businessId, Guid userId, CancellationToken ct)\n        {\n            var user = await _db.Users\n                .Include(u => u.Role)\n                .FirstOrDefaultAsync(u => u.Id == userId && !u.IsDeleted, ct)\n                .ConfigureAwait(false);\n\n            if (user == null)\n                throw new InvalidOperationException(\"User not found.\");\n\n            if (user.BusinessId != businessId)\n                throw new UnauthorizedAccessException(\"User does not belong to this business.\");\n\n            if (!string.Equals(user.Status, \"Active\", StringComparison.OrdinalIgnoreCase))\n                throw new UnauthorizedAccessException(\"User is not active.\");\n\n            return user;\n        }\n\n        private static bool IsPrivilegedRole(User actor)\n        {\n            var role = (actor.Role?.Name ?? string.Empty).Trim().ToLowerInvariant();\n            return role is \"admin\" or \"business\" or \"superadmin\" or \"partner\";\n        }\n\n        private async Task<bool> CanAssignOthersAsync(User actor, CancellationToken ct)\n        {\n            if (IsPrivilegedRole(actor)) return true;\n            return await HasPermissionAsync(actor.Id, InboxAssignPermissionCode, ct).ConfigureAwait(false);\n        }\n\n        private async Task<bool> HasPermissionAsync(Guid userId, string permissionCode, CancellationToken ct)\n        {\n            // Permission sources checked:\n            // 1) UserPermissions (direct user overrides)\n            // 2) RolePermissions (business role mapping)\n            var rawCode = (permissionCode ?? string.Empty).Trim();\n            var code = rawCode.ToUpperInvariant();\n            if (code.Length == 0) return false;\n\n            var permissionId = await _db.Permissions\n                .AsNoTracking()\n                .Where(p => p.Code != null && p.Code.ToUpper() == code)\n                .Select(p => (Guid?)p.Id)\n                .FirstOrDefaultAsync(ct)\n                .ConfigureAwait(false);\n\n            if (!permissionId.HasValue) return false;\n\n            var direct = await _db.UserPermissions\n                .AsNoTracking()\n                .AnyAsync(\n                    up => up.UserId == userId\n                          && up.PermissionId == permissionId.Value\n                          && up.IsGranted\n                          && !up.IsRevoked,\n                    ct)\n                .ConfigureAwait(false);\n\n            if (direct)\n            {\n                _logger.LogDebug(\n                    \"Permission granted via UserPermissions override. UserId={UserId} PermissionCode={PermissionCode}\",\n                    userId,\n                    rawCode);\n                return true;\n            }\n\n            var roleId = await _db.Users\n                .AsNoTracking()\n                .Where(u => u.Id == userId)\n                .Select(u => u.RoleId)\n                .FirstOrDefaultAsync(ct)\n                .ConfigureAwait(false);\n\n            if (!roleId.HasValue)\n            {\n                _logger.LogDebug(\n                    \"Permission denied (no role). UserId={UserId} PermissionCode={PermissionCode}\",\n                    userId,\n                    rawCode);\n                return false;\n            }\n\n            var byRole = await _db.RolePermissions\n                .AsNoTracking()\n                .AnyAsync(\n                    rp => rp.RoleId == roleId.Value\n                          && rp.PermissionId == permissionId.Value\n                          && rp.IsActive\n                          && !rp.IsRevoked,\n                    ct)\n                .ConfigureAwait(false);\n\n            if (byRole)\n            {\n                _logger.LogDebug(\n                    \"Permission granted via RolePermissions mapping. UserId={UserId} RoleId={RoleId} PermissionCode={PermissionCode}\",\n                    userId,\n                    roleId.Value,\n                    rawCode);\n                return true;\n            }\n\n            _logger.LogDebug(\n                \"Permission denied (no direct or role grant). UserId={UserId} RoleId={RoleId} PermissionCode={PermissionCode}\",\n                userId,\n                roleId.Value,\n                rawCode);\n\n            return byRole;\n        }\n\n        private async Task BroadcastRefreshAsync(Guid businessId)\n        {\n            try\n            {\n                await _hub.Clients\n                    .Group($\"business_{businessId}\")\n                    .SendAsync(\"UnreadCountChanged\", new { refresh = true })\n                    .ConfigureAwait(false);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"Failed to broadcast inbox refresh. BusinessId={BusinessId}\", businessId);\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/Services/ChatInboxCommandService.cs",
      "sha256": "1903a47a21202dae04970f7ef082e3f9a12f5566d569d4aeaf661371d04a9fcb",
      "language": "csharp",
      "size": 20979,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/Services/ChatInboxCommandService.cs\nusing System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.AuthModule.Models;                 // User\nusing xbytechat.api.Features.AccessControl.Models;     // Permissions, RolePermissions, UserPermissions\nusing xbytechat.api.Features.ChatInbox.DTOs;\nusing xbytechat.api.Features.CRM.Models;               // Contact\nusing xbytechat.api.Features.Inbox.Models;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Models;                            // AppDbContext, MessageLog\n\nnamespace xbytechat.api.Features.ChatInbox.Services\n{\n    /// <summary>\n    /// SharedInInbox visibility + Assigned-only reply (enterprise).\n    ///\n    /// Rules (Shared visibility):\n    /// 1) Anyone can SEE chats (SharedInInbox) ‚Äî enforced on query layer/UI.\n    /// 2) Reply allowed ONLY when:\n    ///    - chat is assigned to actor, OR\n    ///    - actor is Business/Platform privileged, OR\n    ///    - actor has INBOX.CHAT.ASSIGN (manager-style override)\n    /// 3) Unassigned chats:\n    ///    - ‚úÖ Any ACTIVE agent can \"claim on reply\" (auto self-assign) and reply.\n    /// </summary>\n    public sealed class ChatInboxCommandService : IChatInboxCommandService\n    {\n        private const string InboxAssignPermissionCode = \"INBOX.CHAT.ASSIGN\";\n\n        private readonly AppDbContext _db;\n        private readonly IMessageEngineService _messageEngine;\n\n        public ChatInboxCommandService(AppDbContext db, IMessageEngineService messageEngine)\n        {\n            _db = db ?? throw new ArgumentNullException(nameof(db));\n            _messageEngine = messageEngine ?? throw new ArgumentNullException(nameof(messageEngine));\n        }\n\n        public async Task<ChatInboxMessageDto> SendAgentMessageAsync(\n            ChatInboxSendMessageRequestDto request,\n            CancellationToken ct = default)\n        {\n            if (request == null) throw new ArgumentNullException(nameof(request));\n\n            if (request.BusinessId == Guid.Empty)\n                throw new ArgumentException(\"BusinessId is required.\", nameof(request));\n\n            // NOTE: ActorUserId must be set server-side from token (do NOT trust UI).\n            if (request.ActorUserId == Guid.Empty)\n                throw new ArgumentException(\"ActorUserId is required (server-side).\", nameof(request));\n\n            if (string.IsNullOrWhiteSpace(request.To))\n                throw new ArgumentException(\"Target phone (To) is required.\", nameof(request));\n\n            var text = string.IsNullOrWhiteSpace(request.Text) ? null : request.Text.Trim();\n            var mediaId = string.IsNullOrWhiteSpace(request.MediaId) ? null : request.MediaId.Trim();\n            var mediaType = string.IsNullOrWhiteSpace(request.MediaType) ? null : request.MediaType.Trim().ToLowerInvariant();\n            var hasLocation = request.LocationLatitude.HasValue && request.LocationLongitude.HasValue;\n\n            var hasText = !string.IsNullOrWhiteSpace(text);\n            var hasMedia = !string.IsNullOrWhiteSpace(mediaId);\n\n            if (!hasText && !hasMedia && !hasLocation)\n                throw new ArgumentException(\"Either Text, MediaId, or Location is required.\", nameof(request));\n\n            if (hasMedia && mediaType is not (\"image\" or \"document\" or \"video\" or \"audio\"))\n                throw new ArgumentException(\"MediaType must be 'image', 'document', 'video', or 'audio'.\", nameof(request));\n\n            if (hasMedia && mediaType == \"audio\" && hasText)\n                throw new ArgumentException(\"Audio messages do not support captions. Please remove Text.\", nameof(request));\n\n            if (hasLocation && (hasMedia || hasText))\n                throw new ArgumentException(\"Location messages cannot include Text or MediaId.\", nameof(request));\n\n            if (hasLocation)\n            {\n                var lat = request.LocationLatitude!.Value;\n                var lon = request.LocationLongitude!.Value;\n                if (lat < -90 || lat > 90) throw new ArgumentException(\"LocationLatitude must be between -90 and 90.\", nameof(request));\n                if (lon < -180 || lon > 180) throw new ArgumentException(\"LocationLongitude must be between -180 and 180.\", nameof(request));\n            }\n\n            var businessId = request.BusinessId;\n            var actorUserId = request.ActorUserId;\n            var phone = request.To.Trim();\n\n            // ‚úÖ Load actor (must be active and belong to business)\n            var actor = await LoadActiveBusinessUserAsync(businessId, actorUserId, ct).ConfigureAwait(false);\n\n            // ‚úÖ Resolve & load contact (tracked)\n            var contact = await LoadTrackedContactAsync(businessId, request.ContactId, phone, ct).ConfigureAwait(false);\n\n            // ‚úÖ Closed / archived / inactive => block\n            EnsureConversationIsReplyable(contact);\n\n            // ‚úÖ Enforce reply rules (includes claim-on-reply for ANY agent)\n            await EnforceAssignedOnlyReplyAsync(actor, contact, ct).ConfigureAwait(false);\n\n            // üì® Send via MessagesEngine\n            var result =\n                hasMedia\n                    ? await SendMediaAsync(businessId, phone, contact.Id, request, mediaId!, mediaType!, text).ConfigureAwait(false)\n                    : hasLocation\n                        ? await SendLocationAsync(businessId, phone, contact.Id, request).ConfigureAwait(false)\n                        : await _messageEngine.SendTextDirectAsync(new TextMessageSendDto\n                        {\n                            BusinessId = businessId,\n                            RecipientNumber = phone,\n                            TextContent = text!,\n                            ContactId = contact.Id,\n                            PhoneNumberId = string.IsNullOrWhiteSpace(request.NumberId) ? null : request.NumberId.Trim(),\n                            Provider = null,\n                            Source = \"agent\"\n                        }).ConfigureAwait(false);\n\n            // Load log for richer bubble\n            MessageLog? log = null;\n            if (result.LogId.HasValue)\n            {\n                log = await _db.MessageLogs\n                    .AsNoTracking()\n                    .FirstOrDefaultAsync(m => m.Id == result.LogId.Value, ct)\n                    .ConfigureAwait(false);\n            }\n\n            // Update conversation meta (outbound)\n            var nowUtc = DateTime.UtcNow;\n            contact.LastOutboundAt = nowUtc;\n            await _db.SaveChangesAsync(ct).ConfigureAwait(false);\n\n            var bubbleId = log?.Id ?? Guid.NewGuid();\n            var bubbleText = log?.MessageContent ?? (text ?? string.Empty);\n\n            var ts = log?.SentAt ?? log?.CreatedAt ?? nowUtc;\n            var sentAtUtc = ts.Kind == DateTimeKind.Utc ? ts : ts.ToUniversalTime();\n\n            var status = log?.Status ?? (result.Success ? \"Sent\" : \"Failed\");\n            var err = log?.ErrorMessage ?? (result.Success ? null : result.Message);\n\n            return new ChatInboxMessageDto\n            {\n                Id = bubbleId,\n                Direction = \"out\",\n                Channel = \"whatsapp\",\n                Text = bubbleText,\n                MediaId = log?.MediaId,\n                MediaType = log?.MediaType,\n                FileName = log?.FileName,\n                MimeType = log?.MimeType,\n                LocationLatitude = log?.LocationLatitude,\n                LocationLongitude = log?.LocationLongitude,\n                LocationName = log?.LocationName,\n                LocationAddress = log?.LocationAddress,\n                SentAtUtc = sentAtUtc,\n                Status = status,\n                ErrorMessage = err\n            };\n        }\n\n        private async Task<ResponseResult> SendMediaAsync(\n            Guid businessId,\n            string to,\n            Guid contactId,\n            ChatInboxSendMessageRequestDto request,\n            string mediaId,\n            string mediaType,\n            string? caption)\n        {\n            var dto = new MediaMessageSendDto\n            {\n                BusinessId = businessId,\n                RecipientNumber = to,\n                MediaId = mediaId,\n                Caption = caption,\n                FileName = string.IsNullOrWhiteSpace(request.FileName) ? null : request.FileName.Trim(),\n                MimeType = string.IsNullOrWhiteSpace(request.MimeType) ? null : request.MimeType.Trim(),\n                ContactId = contactId,\n                PhoneNumberId = string.IsNullOrWhiteSpace(request.NumberId) ? null : request.NumberId.Trim(),\n                Provider = null,\n                Source = \"agent\"\n            };\n\n            return mediaType switch\n            {\n                \"image\" => await _messageEngine.SendImageDirectAsync(dto).ConfigureAwait(false),\n                \"document\" => await _messageEngine.SendDocumentDirectAsync(dto).ConfigureAwait(false),\n                \"video\" => await _messageEngine.SendVideoDirectAsync(dto).ConfigureAwait(false),\n                \"audio\" => await _messageEngine.SendAudioDirectAsync(dto).ConfigureAwait(false),\n                _ => throw new ArgumentException(\"Unsupported MediaType.\", nameof(mediaType))\n            };\n        }\n\n        private Task<ResponseResult> SendLocationAsync(\n            Guid businessId,\n            string to,\n            Guid contactId,\n            ChatInboxSendMessageRequestDto request)\n        {\n            var dto = new LocationMessageSendDto\n            {\n                BusinessId = businessId,\n                RecipientNumber = to,\n                ContactId = contactId,\n                PhoneNumberId = string.IsNullOrWhiteSpace(request.NumberId) ? null : request.NumberId.Trim(),\n                Provider = null,\n                Source = \"agent\",\n                Latitude = request.LocationLatitude!.Value,\n                Longitude = request.LocationLongitude!.Value,\n                Name = string.IsNullOrWhiteSpace(request.LocationName) ? null : request.LocationName.Trim(),\n                Address = string.IsNullOrWhiteSpace(request.LocationAddress) ? null : request.LocationAddress.Trim()\n            };\n\n            return _messageEngine.SendLocationDirectAsync(dto);\n        }\n\n        //public async Task MarkConversationAsReadAsync(ChatInboxMarkReadRequestDto request, CancellationToken ct = default)\n        //{\n        //    if (request == null) throw new ArgumentNullException(nameof(request));\n        //    if (request.BusinessId == Guid.Empty) throw new ArgumentException(\"BusinessId is required.\", nameof(request));\n        //    if (request.ContactId == Guid.Empty) throw new ArgumentException(\"ContactId is required.\", nameof(request));\n        //    if (request.UserId == Guid.Empty) throw new ArgumentException(\"UserId is required.\", nameof(request));\n\n        //    var businessId = request.BusinessId;\n        //    var contactId = request.ContactId;\n        //    var userId = request.UserId;\n        //    var nowUtc = DateTime.UtcNow;\n\n        //    var lastReadAt = request.LastReadAtUtc.HasValue\n        //        ? (request.LastReadAtUtc.Value.Kind == DateTimeKind.Utc\n        //            ? request.LastReadAtUtc.Value\n        //            : request.LastReadAtUtc.Value.ToUniversalTime())\n        //        : nowUtc;\n\n        //    var existing = await _db.ContactReads\n        //        .FirstOrDefaultAsync(\n        //            r => r.BusinessId == businessId && r.ContactId == contactId && r.UserId == userId,\n        //            ct)\n        //        .ConfigureAwait(false);\n\n        //    if (existing == null)\n        //    {\n        //        await _db.ContactReads.AddAsync(new ContactRead\n        //        {\n        //            Id = Guid.NewGuid(),\n        //            BusinessId = businessId,\n        //            ContactId = contactId,\n        //            UserId = userId,\n        //            LastReadAt = lastReadAt\n        //        }, ct).ConfigureAwait(false);\n        //    }\n        //    else\n        //    {\n        //        // Only move forward in time; never go backwards.\n        //        if (existing.LastReadAt < lastReadAt)\n        //        {\n        //            existing.LastReadAt = lastReadAt;\n        //            _db.ContactReads.Update(existing);\n        //        }\n        //    }\n\n        //    await _db.SaveChangesAsync(ct).ConfigureAwait(false);\n        //}\n        public async Task MarkConversationAsReadAsync(\n      Guid businessId,\n      Guid contactId,\n      Guid userId,\n      DateTime? lastReadAtUtc,\n      CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty) throw new ArgumentException(\"BusinessId is required.\", nameof(businessId));\n            if (contactId == Guid.Empty) throw new ArgumentException(\"ContactId is required.\", nameof(contactId));\n            if (userId == Guid.Empty) throw new ArgumentException(\"UserId is required.\", nameof(userId));\n\n            var nowUtc = DateTime.UtcNow;\n\n            var lastReadAt = lastReadAtUtc.HasValue\n                ? (lastReadAtUtc.Value.Kind == DateTimeKind.Utc\n                    ? lastReadAtUtc.Value\n                    : lastReadAtUtc.Value.ToUniversalTime())\n                : nowUtc;\n\n            var existing = await _db.ContactReads\n                .FirstOrDefaultAsync(\n                    r => r.BusinessId == businessId && r.ContactId == contactId && r.UserId == userId,\n                    ct)\n                .ConfigureAwait(false);\n\n            if (existing == null)\n            {\n                await _db.ContactReads.AddAsync(new ContactRead\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    ContactId = contactId,\n                    UserId = userId,\n                    LastReadAt = lastReadAt\n                }, ct).ConfigureAwait(false);\n            }\n            else\n            {\n                // Only move forward in time; never go backwards.\n                if (existing.LastReadAt < lastReadAt)\n                {\n                    existing.LastReadAt = lastReadAt;\n                }\n            }\n\n            await _db.SaveChangesAsync(ct).ConfigureAwait(false);\n        }\n\n        // -------------------------\n        // Helpers\n        // -------------------------\n\n        private static void EnsureConversationIsReplyable(Contact contact)\n        {\n            var inboxStatus = (contact.InboxStatus ?? string.Empty).Trim();\n\n            if (string.Equals(inboxStatus, \"Closed\", StringComparison.OrdinalIgnoreCase) ||\n                contact.IsArchived ||\n                !contact.IsActive)\n            {\n                throw new InvalidOperationException(\"Conversation is closed.\");\n            }\n        }\n\n        private async Task<Contact> LoadTrackedContactAsync(Guid businessId, Guid? contactId, string phone, CancellationToken ct)\n        {\n            if (contactId.HasValue && contactId.Value != Guid.Empty)\n            {\n                var byId = await _db.Contacts\n                    .FirstOrDefaultAsync(c => c.BusinessId == businessId && c.Id == contactId.Value, ct)\n                    .ConfigureAwait(false);\n\n                if (byId != null) return byId;\n            }\n\n            var byPhone = await _db.Contacts\n                .FirstOrDefaultAsync(c => c.BusinessId == businessId && c.PhoneNumber == phone, ct)\n                .ConfigureAwait(false);\n\n            if (byPhone == null)\n                throw new InvalidOperationException(\"Contact not found for this conversation.\");\n\n            return byPhone;\n        }\n\n        private async Task<User> LoadActiveBusinessUserAsync(Guid businessId, Guid userId, CancellationToken ct)\n        {\n            var user = await _db.Users\n                .Include(u => u.Role)\n                .FirstOrDefaultAsync(u => u.Id == userId && !u.IsDeleted, ct)\n                .ConfigureAwait(false);\n\n            if (user == null) throw new InvalidOperationException(\"User not found.\");\n            if (user.BusinessId != businessId) throw new UnauthorizedAccessException(\"User does not belong to this business.\");\n            if (!string.Equals(user.Status, \"Active\", StringComparison.OrdinalIgnoreCase))\n                throw new UnauthorizedAccessException(\"User is not active.\");\n\n            return user;\n        }\n\n        private async Task EnforceAssignedOnlyReplyAsync(User actor, Contact contact, CancellationToken ct)\n        {\n            // ‚úÖ If already assigned to actor -> OK\n            if (contact.AssignedAgentId.HasValue && contact.AssignedAgentId.Value == actor.Id)\n                return;\n\n            // ‚úÖ Shared visibility rule: unassigned chat -> claim-on-first-reply (ANY active agent)\n            if (!contact.AssignedAgentId.HasValue)\n            {\n                // Atomic claim to avoid race: two agents reply at same time\n                var claimed = await _db.Contacts\n                    .Where(c => c.BusinessId == contact.BusinessId\n                                && c.Id == contact.Id\n                                && c.AssignedAgentId == null)\n                    .ExecuteUpdateAsync(setters => setters.SetProperty(c => c.AssignedAgentId, actor.Id), ct)\n                    .ConfigureAwait(false);\n\n                if (claimed > 0)\n                {\n                    // Keep in-memory entity consistent\n                    contact.AssignedAgentId = actor.Id;\n                    return;\n                }\n\n                // Someone else claimed between read and write ‚Üí reload for correct enforcement\n                var fresh = await _db.Contacts\n                    .AsNoTracking()\n                    .Where(c => c.BusinessId == contact.BusinessId && c.Id == contact.Id)\n                    .Select(c => c.AssignedAgentId)\n                    .FirstOrDefaultAsync(ct)\n                    .ConfigureAwait(false);\n\n                contact.AssignedAgentId = fresh;\n                // Now fall through to \"assigned to someone else\" logic below\n            }\n\n            // ‚úÖ Assigned to someone else -> only Business owner OR INBOX.CHAT.ASSIGN can override\n            var isBusinessOwner = IsBusinessOwner(actor);\n            var canAssign = await HasPermissionAsync(actor.Id, InboxAssignPermissionCode, ct).ConfigureAwait(false);\n\n            if (isBusinessOwner || canAssign)\n                return;\n\n            throw new UnauthorizedAccessException(\"Not allowed to reply. This chat is assigned to another agent.\");\n        }\n\n        private static bool IsBusinessOwner(User actor)\n        {\n            var role = (actor.Role?.Name ?? string.Empty).Trim().ToLowerInvariant();\n            return role == \"business\";\n        }\n\n        /// <summary>\n        /// Privileged = Business owner or platform roles.\n        /// Manager is NOT privileged unless they have INBOX.CHAT.ASSIGN.\n        /// </summary>\n        private static bool IsBusinessOrPlatformPrivileged(User actor)\n        {\n            var role = (actor.Role?.Name ?? string.Empty).Trim().ToLowerInvariant();\n            return role is \"business\" or \"admin\" or \"superadmin\" or \"partner\";\n        }\n\n        private async Task<bool> HasPermissionAsync(Guid userId, string permissionCode, CancellationToken ct)\n        {\n            var code = (permissionCode ?? string.Empty).Trim().ToUpperInvariant();\n            if (code.Length == 0) return false;\n\n            var permissionId = await _db.Permissions\n                .AsNoTracking()\n                .Where(p => p.Code != null && p.Code.ToUpper() == code)\n                .Select(p => (Guid?)p.Id)\n                .FirstOrDefaultAsync(ct)\n                .ConfigureAwait(false);\n\n            if (!permissionId.HasValue) return false;\n\n            // Direct user permission\n            var direct = await _db.UserPermissions\n                .AsNoTracking()\n                .AnyAsync(up =>\n                    up.UserId == userId &&\n                    up.PermissionId == permissionId.Value &&\n                    up.IsGranted &&\n                    !up.IsRevoked, ct)\n                .ConfigureAwait(false);\n\n            if (direct) return true;\n\n            // Role permission\n            var roleId = await _db.Users\n                .AsNoTracking()\n                .Where(u => u.Id == userId)\n                .Select(u => u.RoleId)\n                .FirstOrDefaultAsync(ct)\n                .ConfigureAwait(false);\n\n            if (!roleId.HasValue) return false;\n\n            var byRole = await _db.RolePermissions\n                .AsNoTracking()\n                .AnyAsync(rp =>\n                    rp.RoleId == roleId.Value &&\n                    rp.PermissionId == permissionId.Value &&\n                    rp.IsActive &&\n                    !rp.IsRevoked, ct)\n                .ConfigureAwait(false);\n\n            return byRole;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/Services/ChatInboxMediaContentService.cs",
      "sha256": "f694d8f000e1492ad60c86a810580189eb190b2998dcecf7a390f7a5c5e4c430",
      "language": "csharp",
      "size": 9859,
      "content": "using System;\nusing System.IO;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.TemplateModule.Abstractions;\n\nnamespace xbytechat.api.Features.ChatInbox.Services\n{\n    /// <summary>\n    /// Streams WhatsApp media bytes from Meta Cloud API without persisting on our servers.\n    /// This exists to support secure agent-side previews (the browser cannot attach Bearer tokens to &lt;img src&gt;).\n    /// </summary>\n    public sealed class ChatInboxMediaContentService : IChatInboxMediaContentService\n    {\n        private const string DefaultGraphVersion = \"v22.0\";\n\n        private readonly IHttpClientFactory _httpFactory;\n        private readonly IMetaCredentialsResolver _metaCreds;\n        private readonly ILogger<ChatInboxMediaContentService> _logger;\n\n        public ChatInboxMediaContentService(\n            IHttpClientFactory httpFactory,\n            IMetaCredentialsResolver metaCreds,\n            ILogger<ChatInboxMediaContentService> logger)\n        {\n            _httpFactory = httpFactory ?? throw new ArgumentNullException(nameof(httpFactory));\n            _metaCreds = metaCreds ?? throw new ArgumentNullException(nameof(metaCreds));\n            _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n        }\n\n        public async Task<(Stream Stream, string ContentType)> DownloadFromWhatsAppAsync(\n            Guid businessId,\n            string mediaId,\n            CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty) throw new ArgumentException(\"BusinessId is required.\", nameof(businessId));\n            if (string.IsNullOrWhiteSpace(mediaId)) throw new ArgumentException(\"mediaId is required.\", nameof(mediaId));\n\n            var creds = await _metaCreds.ResolveAsync(businessId, ct).ConfigureAwait(false);\n            var graphBase = (creds.GraphBaseUrl ?? string.Empty).Trim().TrimEnd('/');\n            var graphVersion = string.IsNullOrWhiteSpace(creds.GraphVersion)\n                ? DefaultGraphVersion\n                : creds.GraphVersion!.Trim().Trim('/');\n\n            if (string.IsNullOrWhiteSpace(graphBase))\n                throw new InvalidOperationException(\"WhatsApp Graph API base URL is missing.\");\n\n            var token = (creds.AccessToken ?? string.Empty).Trim();\n            if (string.IsNullOrWhiteSpace(token))\n                throw new InvalidOperationException(\"WhatsApp access token is missing for this business.\");\n\n            // Step 1: resolve the temporary media URL from Meta (GET /{media-id})\n            var metaUrl = $\"{graphBase}/{graphVersion}/{mediaId.Trim()}\";\n\n            using var metaReq = new HttpRequestMessage(HttpMethod.Get, metaUrl);\n            metaReq.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(\"application/json\"));\n            metaReq.Headers.Authorization = new AuthenticationHeaderValue(\"Bearer\", token);\n\n            using var client = _httpFactory.CreateClient(\"wa:meta_cloud\");\n            using var metaResp = await client.SendAsync(metaReq, HttpCompletionOption.ResponseHeadersRead, ct).ConfigureAwait(false);\n            var metaBody = await metaResp.Content.ReadAsStringAsync(ct).ConfigureAwait(false);\n\n            if (!metaResp.IsSuccessStatusCode)\n            {\n                var clean = TryGetMetaErrorMessage(metaBody) ?? \"Failed to resolve WhatsApp media URL.\";\n                _logger.LogWarning(\n                    \"ChatInbox media resolve failed. BusinessId={BusinessId} MediaId={MediaId} Status={Status} MetaError={MetaError}\",\n                    businessId,\n                    mediaId,\n                    (int)metaResp.StatusCode,\n                    clean);\n                throw new InvalidOperationException(clean);\n            }\n\n            var downloadUrl = TryGetMetaMediaUrl(metaBody);\n            var mimeType = TryGetMetaMediaMimeType(metaBody) ?? \"application/octet-stream\";\n\n            if (string.IsNullOrWhiteSpace(downloadUrl))\n                throw new InvalidOperationException(\"Meta did not return a download URL for this media.\");\n\n            // Step 2: stream the media bytes from the resolved URL (Bearer token required)\n            var fileReq = new HttpRequestMessage(HttpMethod.Get, downloadUrl);\n            fileReq.Headers.Authorization = new AuthenticationHeaderValue(\"Bearer\", token);\n\n            var fileResp = await client.SendAsync(fileReq, HttpCompletionOption.ResponseHeadersRead, ct).ConfigureAwait(false);\n            if (!fileResp.IsSuccessStatusCode)\n            {\n                var body = await fileResp.Content.ReadAsStringAsync(ct).ConfigureAwait(false);\n                fileResp.Dispose();\n\n                var clean = TryGetMetaErrorMessage(body) ?? \"Failed to download WhatsApp media.\";\n                _logger.LogWarning(\n                    \"ChatInbox media download failed. BusinessId={BusinessId} MediaId={MediaId} Status={Status} MetaError={MetaError}\",\n                    businessId,\n                    mediaId,\n                    (int)fileResp.StatusCode,\n                    clean);\n                throw new InvalidOperationException(clean);\n            }\n\n            var contentType =\n                fileResp.Content.Headers.ContentType?.MediaType ??\n                mimeType ??\n                \"application/octet-stream\";\n\n            Stream stream;\n            try\n            {\n                stream = await fileResp.Content.ReadAsStreamAsync(ct).ConfigureAwait(false);\n            }\n            catch\n            {\n                fileResp.Dispose();\n                throw;\n            }\n\n            return (new ResponseDisposingStream(stream, fileResp), contentType);\n        }\n\n        private sealed class ResponseDisposingStream : Stream\n        {\n            private readonly Stream _inner;\n            private readonly HttpResponseMessage _resp;\n\n            public ResponseDisposingStream(Stream inner, HttpResponseMessage resp)\n            {\n                _inner = inner ?? throw new ArgumentNullException(nameof(inner));\n                _resp = resp ?? throw new ArgumentNullException(nameof(resp));\n            }\n\n            public override bool CanRead => _inner.CanRead;\n            public override bool CanSeek => _inner.CanSeek;\n            public override bool CanWrite => _inner.CanWrite;\n            public override long Length => _inner.Length;\n            public override long Position { get => _inner.Position; set => _inner.Position = value; }\n            public override void Flush() => _inner.Flush();\n            public override int Read(byte[] buffer, int offset, int count) => _inner.Read(buffer, offset, count);\n            public override long Seek(long offset, SeekOrigin origin) => _inner.Seek(offset, origin);\n            public override void SetLength(long value) => _inner.SetLength(value);\n            public override void Write(byte[] buffer, int offset, int count) => _inner.Write(buffer, offset, count);\n            public override Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken) =>\n                _inner.ReadAsync(buffer, offset, count, cancellationToken);\n            public override ValueTask<int> ReadAsync(Memory<byte> buffer, CancellationToken cancellationToken = default) =>\n                _inner.ReadAsync(buffer, cancellationToken);\n            public override Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken) =>\n                _inner.CopyToAsync(destination, bufferSize, cancellationToken);\n\n            protected override void Dispose(bool disposing)\n            {\n                if (disposing)\n                {\n                    try { _inner.Dispose(); } catch { /* ignore */ }\n                    try { _resp.Dispose(); } catch { /* ignore */ }\n                }\n                base.Dispose(disposing);\n            }\n\n            public override async ValueTask DisposeAsync()\n            {\n                try { await _inner.DisposeAsync().ConfigureAwait(false); } catch { /* ignore */ }\n                try { _resp.Dispose(); } catch { /* ignore */ }\n            }\n        }\n\n        private static string? TryGetMetaMediaUrl(string body)\n        {\n            try\n            {\n                using var doc = JsonDocument.Parse(body);\n                if (doc.RootElement.ValueKind != JsonValueKind.Object) return null;\n                if (doc.RootElement.TryGetProperty(\"url\", out var urlProp) && urlProp.ValueKind == JsonValueKind.String)\n                    return urlProp.GetString();\n            }\n            catch { /* ignore */ }\n\n            return null;\n        }\n\n        private static string? TryGetMetaMediaMimeType(string body)\n        {\n            try\n            {\n                using var doc = JsonDocument.Parse(body);\n                if (doc.RootElement.ValueKind != JsonValueKind.Object) return null;\n                if (doc.RootElement.TryGetProperty(\"mime_type\", out var mimeProp) && mimeProp.ValueKind == JsonValueKind.String)\n                    return mimeProp.GetString();\n            }\n            catch { /* ignore */ }\n\n            return null;\n        }\n\n        private static string? TryGetMetaErrorMessage(string body)\n        {\n            try\n            {\n                using var doc = JsonDocument.Parse(body);\n                if (doc.RootElement.ValueKind != JsonValueKind.Object) return null;\n\n                if (!doc.RootElement.TryGetProperty(\"error\", out var err) || err.ValueKind != JsonValueKind.Object)\n                    return null;\n\n                if (err.TryGetProperty(\"message\", out var msg) && msg.ValueKind == JsonValueKind.String)\n                    return msg.GetString();\n            }\n            catch { /* ignore */ }\n\n            return null;\n        }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/Services/ChatInboxMediaUploadService.cs",
      "sha256": "aa4d8e505de0f720cdc570b34f40e46376b281f3ece5beaf659d87034638ec74",
      "language": "csharp",
      "size": 6105,
      "content": "using System;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.TemplateModule.Abstractions;\n\nnamespace xbytechat.api.Features.ChatInbox.Services\n{\n    /// <summary>\n    /// Uploads Inbox attachments to WhatsApp Cloud API media storage and returns a media_id.\n    /// We intentionally do NOT store files on our server.\n    /// </summary>\n    public sealed class ChatInboxMediaUploadService : IChatInboxMediaUploadService\n    {\n        private const string DefaultGraphVersion = \"v22.0\";\n\n        private readonly IHttpClientFactory _httpFactory;\n        private readonly IMetaCredentialsResolver _metaCreds;\n        private readonly ILogger<ChatInboxMediaUploadService> _logger;\n\n        public ChatInboxMediaUploadService(\n            IHttpClientFactory httpFactory,\n            IMetaCredentialsResolver metaCreds,\n            ILogger<ChatInboxMediaUploadService> logger)\n        {\n            _httpFactory = httpFactory ?? throw new ArgumentNullException(nameof(httpFactory));\n            _metaCreds = metaCreds ?? throw new ArgumentNullException(nameof(metaCreds));\n            _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n        }\n\n        public async Task<string> UploadToWhatsAppAsync(\n            Guid businessId,\n            string? phoneNumberId,\n            IFormFile file,\n            CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty) throw new ArgumentException(\"BusinessId is required.\", nameof(businessId));\n            if (file == null) throw new ArgumentNullException(nameof(file));\n\n            var creds = await _metaCreds.ResolveAsync(businessId, ct).ConfigureAwait(false);\n            var graphBase = (creds.GraphBaseUrl ?? string.Empty).Trim().TrimEnd('/');\n            var graphVersion = string.IsNullOrWhiteSpace(creds.GraphVersion)\n                ? DefaultGraphVersion\n                : creds.GraphVersion!.Trim().Trim('/');\n\n            if (string.IsNullOrWhiteSpace(graphBase))\n                throw new InvalidOperationException(\"WhatsApp Graph API base URL is missing.\");\n\n            var pnid = string.IsNullOrWhiteSpace(phoneNumberId)\n                ? (creds.PhoneNumberId ?? string.Empty).Trim()\n                : phoneNumberId.Trim();\n\n            if (string.IsNullOrWhiteSpace(pnid))\n                throw new InvalidOperationException(\"WhatsApp phone_number_id is missing for this business.\");\n\n            var url = $\"{graphBase}/{graphVersion}/{pnid}/media\";\n\n            using var fileStream = file.OpenReadStream();\n            using var mp = new MultipartFormDataContent();\n\n            mp.Add(new StringContent(\"whatsapp\"), \"messaging_product\");\n            mp.Add(new StringContent(file.ContentType ?? \"application/octet-stream\"), \"type\");\n\n            var fileContent = new StreamContent(fileStream);\n            fileContent.Headers.ContentType = new MediaTypeHeaderValue(file.ContentType ?? \"application/octet-stream\");\n            mp.Add(fileContent, \"file\", file.FileName ?? \"upload.bin\");\n\n            using var req = new HttpRequestMessage(HttpMethod.Post, url) { Content = mp };\n            req.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(\"application/json\"));\n\n            var token = (creds.AccessToken ?? string.Empty).Trim();\n            if (string.IsNullOrWhiteSpace(token))\n                throw new InvalidOperationException(\"WhatsApp access token is missing for this business.\");\n\n            req.Headers.Authorization = new AuthenticationHeaderValue(\"Bearer\", token);\n\n            using var client = _httpFactory.CreateClient(\"wa:meta_cloud\");\n            using var resp = await client.SendAsync(req, HttpCompletionOption.ResponseHeadersRead, ct).ConfigureAwait(false);\n            var body = await resp.Content.ReadAsStringAsync(ct).ConfigureAwait(false);\n\n            if (!resp.IsSuccessStatusCode)\n            {\n                var clean = TryGetMetaErrorMessage(body) ?? \"WhatsApp media upload failed.\";\n                _logger.LogWarning(\n                    \"ChatInbox media upload failed. BusinessId={BusinessId} PhoneNumberId={PhoneNumberId} Status={Status} MetaError={MetaError}\",\n                    businessId,\n                    pnid,\n                    (int)resp.StatusCode,\n                    clean);\n                throw new InvalidOperationException(clean);\n            }\n\n            var mediaId = TryGetMediaId(body);\n            if (string.IsNullOrWhiteSpace(mediaId))\n            {\n                _logger.LogWarning(\n                    \"ChatInbox media upload succeeded but media id missing. BusinessId={BusinessId} PhoneNumberId={PhoneNumberId}\",\n                    businessId,\n                    pnid);\n                throw new InvalidOperationException(\"WhatsApp media upload succeeded but no media id was returned.\");\n            }\n\n            return mediaId;\n        }\n\n        private static string? TryGetMediaId(string body)\n        {\n            try\n            {\n                using var doc = JsonDocument.Parse(body);\n                if (doc.RootElement.ValueKind != JsonValueKind.Object) return null;\n                if (doc.RootElement.TryGetProperty(\"id\", out var idProp))\n                    return idProp.GetString();\n            }\n            catch { /* ignore */ }\n\n            return null;\n        }\n\n        private static string? TryGetMetaErrorMessage(string body)\n        {\n            try\n            {\n                using var doc = JsonDocument.Parse(body);\n                if (doc.RootElement.ValueKind != JsonValueKind.Object) return null;\n\n                if (!doc.RootElement.TryGetProperty(\"error\", out var err) || err.ValueKind != JsonValueKind.Object)\n                    return null;\n\n                if (err.TryGetProperty(\"message\", out var msg) && msg.ValueKind == JsonValueKind.String)\n                    return msg.GetString();\n            }\n            catch { /* ignore */ }\n\n            return null;\n        }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/Services/ChatInboxQueryService.cs",
      "sha256": "0b1498c852e77a9d8bb016781d9214116dcf87135c3d97d829c5b0b7a0bdb41c",
      "language": "csharp",
      "size": 31345,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/Services/ChatInboxQueryService.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.ChatInbox.DTOs;\nusing xbytechat.api.Features.ChatInbox.Models;\nusing xbytechat.api.Features.ChatInbox.Utils;\nusing xbytechat.api.Models;\n\nnamespace xbytechat.api.Features.ChatInbox.Services\n{\n    public sealed class ChatInboxQueryService : IChatInboxQueryService\n    {\n        private const string InboxAssignPermissionCode = \"INBOX.CHAT.ASSIGN\";\n\n        private readonly AppDbContext _db;\n\n        private sealed class ConversationsCursor\n        {\n            public DateTime LastMessageAtUtc { get; set; }\n            public Guid ContactId { get; set; }\n        }\n\n        private sealed class MessagesCursor\n        {\n            public DateTime InstantUtc { get; set; }\n            public Guid MessageId { get; set; }\n        }\n\n        public ChatInboxQueryService(AppDbContext db)\n        {\n            _db = db ?? throw new ArgumentNullException(nameof(db));\n        }\n\n        // ‚úÖ Backward compatible (old behavior)\n        public async Task<IReadOnlyList<ChatInboxConversationDto>> GetConversationsAsync(\n            ChatInboxFilterDto filter,\n            CancellationToken ct = default)\n        {\n            var page = await GetConversationsPageAsync(filter, ct).ConfigureAwait(false);\n            return page.Items;\n        }\n\n        // ‚úÖ New: cursor page\n        public async Task<PagedResultDto<ChatInboxConversationDto>> GetConversationsPageAsync(\n            ChatInboxFilterDto filter,\n            CancellationToken ct = default)\n        {\n            if (filter == null) throw new ArgumentNullException(nameof(filter));\n            if (filter.BusinessId == Guid.Empty)\n                throw new ArgumentException(\"BusinessId is required.\", nameof(filter));\n\n            var limit = filter.Limit <= 0 ? 50 : filter.Limit;\n            if (limit > 200) limit = 200;\n\n            var businessId = filter.BusinessId;\n            var currentUserId = filter.CurrentUserId;\n\n            var cursorObj = CursorCodec.Decode<ConversationsCursor>(filter.Cursor);\n            var within24hCutoffUtc = DateTime.UtcNow.AddHours(-24);\n\n            var convoAgg =\n                from m in _db.MessageLogs.AsNoTracking()\n                where m.BusinessId == businessId && m.ContactId != null\n                group m by m.ContactId!.Value\n                into g\n                select new\n                {\n                    ContactId = g.Key,\n                    LastMessageAt = g.Max(x => x.SentAt ?? x.CreatedAt),\n                    FirstSeenAt = g.Min(x => x.SentAt ?? x.CreatedAt),\n                    TotalMessages = g.Count(),\n                    LastInboundAt = g.Where(x => x.IsIncoming)\n                        .Max(x => (DateTime?)(x.SentAt ?? x.CreatedAt)),\n                    LastOutboundAt = g.Where(x => !x.IsIncoming)\n                        .Max(x => (DateTime?)(x.SentAt ?? x.CreatedAt))\n                };\n\n            var q =\n                from a in convoAgg\n                join c in _db.Contacts.AsNoTracking()\n                    on a.ContactId equals c.Id\n                where c.BusinessId == businessId\n                select new\n                {\n                    a.ContactId,\n                    a.LastMessageAt,\n                    a.FirstSeenAt,\n                    a.TotalMessages,\n                    a.LastInboundAt,\n                    a.LastOutboundAt,\n                    Contact = c\n                };\n\n            // ‚úÖ Visibility mode (Shared vs Restricted)\n            var visibility = await _db.Businesses\n                .AsNoTracking()\n                .Where(b => b.Id == businessId)\n                .Select(b => (InboxVisibilityMode?)b.InboxVisibilityMode)\n                .FirstOrDefaultAsync(ct)\n                .ConfigureAwait(false) ?? InboxVisibilityMode.SharedInInbox;\n\n            // ‚úÖ Restricted mode: non-privileged agents only see chats assigned to them\n            if (visibility == InboxVisibilityMode.AssignedOnly)\n            {\n                if (!currentUserId.HasValue || currentUserId.Value == Guid.Empty)\n                {\n                    return new PagedResultDto<ChatInboxConversationDto>\n                    {\n                        Items = Array.Empty<ChatInboxConversationDto>(),\n                        HasMore = false,\n                        NextCursor = null\n                    };\n                }\n\n                var canSeeAll = await CanSeeAllInRestrictedModeAsync(businessId, currentUserId.Value, ct)\n                    .ConfigureAwait(false);\n\n                if (!canSeeAll)\n                {\n                    q = q.Where(x => x.Contact.AssignedAgentId == currentUserId.Value);\n                }\n            }\n\n            if (filter.OnlyUnassigned)\n                q = q.Where(x => x.Contact.AssignedAgentId == null);\n\n            if (filter.OnlyAssignedToMe && currentUserId.HasValue)\n                q = q.Where(x => x.Contact.AssignedAgentId == currentUserId.Value);\n\n            if (filter.ContactId.HasValue && filter.ContactId.Value != Guid.Empty)\n                q = q.Where(x => x.ContactId == filter.ContactId.Value);\n\n            var tab = (filter.Tab ?? string.Empty).Trim().ToLowerInvariant();\n            if (!string.IsNullOrWhiteSpace(tab))\n            {\n                if (tab == \"closed\")\n                {\n                    q = q.Where(x => x.Contact.InboxStatus == \"Closed\" || x.Contact.IsArchived || !x.Contact.IsActive);\n                }\n                else\n                {\n                    q = q.Where(x => x.Contact.InboxStatus != \"Closed\" && !x.Contact.IsArchived && x.Contact.IsActive);\n\n                    if (tab == \"live\")\n                    {\n                        q = q.Where(x => x.LastInboundAt.HasValue && x.LastInboundAt.Value >= within24hCutoffUtc);\n                    }\n                    else if (tab is \"older\" or \"history\")\n                    {\n                        q = q.Where(x => !x.LastInboundAt.HasValue || x.LastInboundAt.Value < within24hCutoffUtc);\n                    }\n                    else if (tab == \"unassigned\")\n                    {\n                        q = q.Where(x => x.Contact.AssignedAgentId == null);\n                    }\n                    else if (tab == \"my\")\n                    {\n                        if (currentUserId.HasValue)\n                            q = q.Where(x => x.Contact.AssignedAgentId == currentUserId.Value);\n                        else\n                            q = q.Where(x => false);\n                    }\n                }\n            }\n\n            if (!string.IsNullOrWhiteSpace(filter.SearchTerm))\n            {\n                var raw = filter.SearchTerm.Trim();\n                var term = raw.ToLowerInvariant();\n\n                q = q.Where(x =>\n                    (!string.IsNullOrEmpty(x.Contact.Name) && x.Contact.Name.ToLower().Contains(term)) ||\n                    (!string.IsNullOrEmpty(x.Contact.ProfileName) && x.Contact.ProfileName.ToLower().Contains(term)) ||\n                    (!string.IsNullOrEmpty(x.Contact.PhoneNumber) && x.Contact.PhoneNumber.Contains(raw)));\n            }\n\n            if (cursorObj != null && cursorObj.ContactId != Guid.Empty)\n            {\n                var lm = DateTime.SpecifyKind(cursorObj.LastMessageAtUtc, DateTimeKind.Utc);\n                var cid = cursorObj.ContactId;\n\n                q = q.Where(x =>\n                    x.LastMessageAt < lm ||\n                    (x.LastMessageAt == lm && x.ContactId.CompareTo(cid) < 0));\n            }\n\n            q = q.OrderByDescending(x => x.LastMessageAt)\n                 .ThenByDescending(x => x.ContactId);\n\n            var rows = await q.Take(limit + 1).ToListAsync(ct).ConfigureAwait(false);\n\n            var hasMore = rows.Count > limit;\n            var pageRows = rows.Take(limit).ToList();\n\n            if (pageRows.Count == 0)\n            {\n                return new PagedResultDto<ChatInboxConversationDto>\n                {\n                    Items = Array.Empty<ChatInboxConversationDto>(),\n                    HasMore = false,\n                    NextCursor = null\n                };\n            }\n\n            var contactIds = pageRows.Select(x => x.ContactId).ToList();\n\n            var lastMessages = await _db.MessageLogs\n                .AsNoTracking()\n                .Where(m => m.BusinessId == businessId\n                            && m.ContactId != null\n                            && contactIds.Contains(m.ContactId.Value))\n                .GroupBy(m => m.ContactId!.Value)\n                .Select(g => g\n                    .OrderByDescending(m => m.SentAt ?? m.CreatedAt)\n                    .ThenByDescending(m => m.Id)\n                    .FirstOrDefault())\n                .ToListAsync(ct)\n                .ConfigureAwait(false);\n\n            var lastMessageByContactId = lastMessages\n                .Where(m => m != null && m.ContactId != null)\n                .ToDictionary(m => m!.ContactId!.Value, m => m!);\n\n            var assignedUserIds = pageRows\n                .Select(x => x.Contact.AssignedAgentId)\n                .Where(x => x.HasValue)\n                .Select(x => x!.Value)\n                .Distinct()\n                .ToList();\n\n            var assignedUsersById = new Dictionary<Guid, string>();\n            if (assignedUserIds.Count > 0)\n            {\n                var users = await _db.Users\n                    .AsNoTracking()\n                    .Where(u => assignedUserIds.Contains(u.Id))\n                    .Select(u => new { u.Id, Name = (u.Name ?? u.Email) })\n                    .ToListAsync(ct)\n                    .ConfigureAwait(false);\n\n                assignedUsersById = users.ToDictionary(x => x.Id, x => x.Name ?? \"Unknown\");\n            }\n\n            var unreadCounts = new Dictionary<Guid, int>();\n            if (currentUserId.HasValue)\n            {\n                var uid = currentUserId.Value;\n\n                var readsQuery = _db.ContactReads\n                    .AsNoTracking()\n                    .Where(r => r.BusinessId == businessId && r.UserId == uid);\n\n                var unreadRows = await _db.MessageLogs\n                    .AsNoTracking()\n                    .Where(m => m.BusinessId == businessId\n                                && m.ContactId != null\n                                && contactIds.Contains(m.ContactId.Value)\n                                && m.IsIncoming)\n                    .GroupJoin(\n                        readsQuery,\n                        m => m.ContactId!.Value,\n                        r => r.ContactId,\n                        (m, reads) => new\n                        {\n                            ContactId = m.ContactId!.Value,\n                            Instant = (m.SentAt ?? m.CreatedAt),\n                            LastReadAt = reads.Select(x => (DateTime?)x.LastReadAt).FirstOrDefault()\n                        })\n                    .Where(x => !x.LastReadAt.HasValue || x.Instant > x.LastReadAt.Value)\n                    .GroupBy(x => x.ContactId)\n                    .Select(g => new { ContactId = g.Key, Count = g.Count() })\n                    .ToListAsync(ct)\n                    .ConfigureAwait(false);\n\n                unreadCounts = unreadRows.ToDictionary(x => x.ContactId, x => x.Count);\n            }\n\n            var sessionStates = await _db.ChatSessionStates\n                .AsNoTracking()\n                .Where(s => s.BusinessId == businessId && contactIds.Contains(s.ContactId))\n                .ToListAsync(ct)\n                .ConfigureAwait(false);\n\n            var sessionByContactId = sessionStates.ToDictionary(s => s.ContactId, s => s);\n\n            var items = new List<ChatInboxConversationDto>(pageRows.Count);\n\n            foreach (var row in pageRows)\n            {\n                var contact = row.Contact;\n\n                lastMessageByContactId.TryGetValue(row.ContactId, out var lastMsg);\n\n                var preview = lastMsg?.RenderedBody ?? lastMsg?.MessageContent ?? string.Empty;\n                if (string.IsNullOrWhiteSpace(preview) && lastMsg != null && !string.IsNullOrWhiteSpace(lastMsg.MediaType))\n                {\n                    var mt = lastMsg.MediaType.Trim().ToLowerInvariant();\n                    var name = lastMsg.FileName ?? string.Empty;\n\n                    if (mt == \"image\")\n                        preview = \"Photo\";\n                    else if (mt == \"document\")\n                        preview = string.IsNullOrWhiteSpace(name) ? \"PDF\" : name;\n                    else if (mt == \"video\")\n                        preview = string.IsNullOrWhiteSpace(name) ? \"Video\" : name;\n                    else if (mt == \"audio\")\n                        preview = string.IsNullOrWhiteSpace(name) ? \"Audio\" : name;\n                    else if (mt == \"location\")\n                        preview = string.IsNullOrWhiteSpace(lastMsg.LocationName) ? \"Location\" : lastMsg.LocationName!;\n                }\n                if (preview.Length > 140) preview = preview.Substring(0, 140) + \"‚Ä¶\";\n\n                var unread = unreadCounts.TryGetValue(row.ContactId, out var uc) ? uc : 0;\n\n                var lastInboundAt = row.LastInboundAt ?? contact.LastInboundAt;\n                var lastOutboundAt = row.LastOutboundAt ?? contact.LastOutboundAt;\n\n                var within24h =\n                    lastInboundAt.HasValue && lastInboundAt.Value >= within24hCutoffUtc;\n\n                var statusRaw = (contact.InboxStatus ?? string.Empty).Trim();\n                var statusLower = statusRaw.ToLowerInvariant();\n                var status =\n                    statusLower switch\n                    {\n                        \"open\" => \"Open\",\n                        \"pending\" => \"Pending\",\n                        \"closed\" => \"Closed\",\n                        _ => (contact.IsArchived || !contact.IsActive) ? \"Closed\" : \"Open\"\n                    };\n\n                var assignedUserId = contact.AssignedAgentId;\n                var assignedUserIdString = assignedUserId?.ToString();\n\n                var isAssignedToMe =\n                    currentUserId.HasValue &&\n                    assignedUserId.HasValue &&\n                    assignedUserId.Value == currentUserId.Value;\n\n                string? assignedUserName = null;\n                if (assignedUserId.HasValue && assignedUsersById.TryGetValue(assignedUserId.Value, out var nm))\n                    assignedUserName = nm;\n\n                var mode = \"automation\";\n                if (sessionByContactId.TryGetValue(row.ContactId, out var session))\n                {\n                    mode = session.Mode?.ToString().ToLowerInvariant() ?? \"automation\";\n                }\n                else if (lastMsg != null)\n                {\n                    if (!lastMsg.IsIncoming &&\n                        string.Equals(lastMsg.Source, \"agent\", StringComparison.OrdinalIgnoreCase))\n                    {\n                        mode = \"agent\";\n                    }\n                }\n\n                items.Add(new ChatInboxConversationDto\n                {\n                    Id = row.ContactId.ToString(),\n                    ContactId = row.ContactId,\n                    ContactName = string.IsNullOrWhiteSpace(contact.Name)\n                        ? (contact.ProfileName ?? contact.PhoneNumber)\n                        : contact.Name,\n                    ContactPhone = contact.PhoneNumber,\n\n                    LastMessagePreview = preview,\n                    LastMessageAt = row.LastMessageAt,\n\n                    UnreadCount = unread,\n                    Status = status,\n\n                    NumberId = string.Empty,\n                    NumberLabel = string.Empty,\n\n                    Within24h = within24h,\n\n                    AssignedToUserId = assignedUserIdString,\n                    AssignedToUserName = assignedUserName,\n                    IsAssignedToMe = isAssignedToMe,\n\n                    Mode = mode,\n                    SourceType = \"Unknown\",\n                    SourceName = null,\n\n                    FirstSeenAt = row.FirstSeenAt,\n                    LastInboundAt = lastInboundAt,\n                    LastOutboundAt = lastOutboundAt,\n                    TotalMessages = row.TotalMessages,\n\n                    LastAgentReplyAt = null,\n                    LastAutomationAt = null\n                });\n            }\n\n            items.Sort((a, b) =>\n            {\n                var aUnread = a.UnreadCount > 0;\n                var bUnread = b.UnreadCount > 0;\n\n                if (aUnread && !bUnread) return -1;\n                if (!aUnread && bUnread) return 1;\n\n                return b.LastMessageAt.CompareTo(a.LastMessageAt);\n            });\n\n            string? nextCursor = null;\n            if (hasMore && items.Count > 0)\n            {\n                var last = pageRows.Last();\n                nextCursor = CursorCodec.Encode(new ConversationsCursor\n                {\n                    LastMessageAtUtc = DateTime.SpecifyKind(last.LastMessageAt, DateTimeKind.Utc),\n                    ContactId = last.ContactId\n                });\n            }\n\n            return new PagedResultDto<ChatInboxConversationDto>\n            {\n                Items = items,\n                HasMore = hasMore,\n                NextCursor = nextCursor\n            };\n        }\n\n        // =============================================================\n        // ‚úÖ SECURED MESSAGE METHODS (use these from controllers)\n        // =============================================================\n\n        public async Task<IReadOnlyList<ChatInboxMessageDto>> GetMessagesForConversationAsync(\n            Guid businessId,\n            string contactPhone,\n            int limit,\n            Guid currentUserId,\n            CancellationToken ct = default)\n        {\n            var page = await GetMessagesPageForConversationByPhoneAsync(businessId, contactPhone, limit, null, currentUserId, ct)\n                .ConfigureAwait(false);\n\n            return page.Items;\n        }\n\n        public async Task<IReadOnlyList<ChatInboxMessageDto>> GetMessagesForConversationByContactIdAsync(\n            Guid businessId,\n            Guid contactId,\n            int limit,\n            Guid currentUserId,\n            CancellationToken ct = default)\n        {\n            var page = await GetMessagesPageForConversationByContactIdAsync(businessId, contactId, limit, null, currentUserId, ct)\n                .ConfigureAwait(false);\n\n            return page.Items;\n        }\n\n        public Task<PagedResultDto<ChatInboxMessageDto>> GetMessagesPageForConversationByPhoneAsync(\n            Guid businessId,\n            string contactPhone,\n            int limit,\n            string? cursor,\n            Guid currentUserId,\n            CancellationToken ct = default)\n        {\n            // Resolve contactId then delegate\n            return GetMessagesPageForConversationByPhoneInternalAsync(businessId, contactPhone, limit, cursor, currentUserId, ct);\n        }\n\n        public Task<PagedResultDto<ChatInboxMessageDto>> GetMessagesPageForConversationByContactIdAsync(\n            Guid businessId,\n            Guid contactId,\n            int limit,\n            string? cursor,\n            Guid currentUserId,\n            CancellationToken ct = default)\n        {\n            return GetMessagesPageForConversationByContactIdInternalAsync(businessId, contactId, limit, cursor, currentUserId, ct);\n        }\n\n        // =============================================================\n        // ‚ö†Ô∏è LEGACY MESSAGE METHODS (keep for compatibility only)\n        // These DO NOT enforce restricted mode. Prefer secured overloads.\n        // =============================================================\n\n        public async Task<IReadOnlyList<ChatInboxMessageDto>> GetMessagesForConversationAsync(\n            Guid businessId,\n            string contactPhone,\n            int limit,\n            CancellationToken ct = default)\n        {\n            var page = await GetMessagesPageForConversationByPhoneAsync(businessId, contactPhone, limit, null, ct)\n                .ConfigureAwait(false);\n\n            return page.Items;\n        }\n\n        public async Task<IReadOnlyList<ChatInboxMessageDto>> GetMessagesForConversationByContactIdAsync(\n            Guid businessId,\n            Guid contactId,\n            int limit,\n            CancellationToken ct = default)\n        {\n            var page = await GetMessagesPageForConversationByContactIdAsync(businessId, contactId, limit, null, ct)\n                .ConfigureAwait(false);\n\n            return page.Items;\n        }\n\n        public Task<PagedResultDto<ChatInboxMessageDto>> GetMessagesPageForConversationByPhoneAsync(\n            Guid businessId,\n            string contactPhone,\n            int limit,\n            string? cursor,\n            CancellationToken ct = default)\n        {\n            // Legacy behavior: no visibility enforcement (Shared-like)\n            return GetMessagesPageForConversationByPhoneInternalAsync(businessId, contactPhone, limit, cursor, null, ct);\n        }\n\n        public Task<PagedResultDto<ChatInboxMessageDto>> GetMessagesPageForConversationByContactIdAsync(\n            Guid businessId,\n            Guid contactId,\n            int limit,\n            string? cursor,\n            CancellationToken ct = default)\n        {\n            // Legacy behavior: no visibility enforcement (Shared-like)\n            return GetMessagesPageForConversationByContactIdInternalAsync(businessId, contactId, limit, cursor, null, ct);\n        }\n\n        // =============================================================\n        // Internal implementations with optional enforcement\n        // =============================================================\n\n        private async Task<PagedResultDto<ChatInboxMessageDto>> GetMessagesPageForConversationByPhoneInternalAsync(\n            Guid businessId,\n            string contactPhone,\n            int limit,\n            string? cursor,\n            Guid? currentUserId,\n            CancellationToken ct)\n        {\n            if (businessId == Guid.Empty)\n                throw new ArgumentException(\"BusinessId must be a non-empty GUID.\", nameof(businessId));\n\n            if (string.IsNullOrWhiteSpace(contactPhone))\n                throw new ArgumentException(\"Contact phone is required.\", nameof(contactPhone));\n\n            var trimmedPhone = contactPhone.Trim();\n\n            var contactId = await _db.Contacts\n                .AsNoTracking()\n                .Where(c => c.BusinessId == businessId && c.PhoneNumber == trimmedPhone)\n                .Select(c => (Guid?)c.Id)\n                .FirstOrDefaultAsync(ct)\n                .ConfigureAwait(false);\n\n            if (!contactId.HasValue)\n            {\n                return new PagedResultDto<ChatInboxMessageDto>\n                {\n                    Items = Array.Empty<ChatInboxMessageDto>(),\n                    HasMore = false,\n                    NextCursor = null\n                };\n            }\n\n            return await GetMessagesPageForConversationByContactIdInternalAsync(\n                    businessId, contactId.Value, limit, cursor, currentUserId, ct)\n                .ConfigureAwait(false);\n        }\n\n        private async Task<PagedResultDto<ChatInboxMessageDto>> GetMessagesPageForConversationByContactIdInternalAsync(\n            Guid businessId,\n            Guid contactId,\n            int limit,\n            string? cursor,\n            Guid? currentUserId,\n            CancellationToken ct)\n        {\n            if (businessId == Guid.Empty)\n                throw new ArgumentException(\"BusinessId must be a non-empty GUID.\", nameof(businessId));\n\n            if (contactId == Guid.Empty)\n                throw new ArgumentException(\"ContactId must be a non-empty GUID.\", nameof(contactId));\n\n            if (limit <= 0) limit = 50;\n            if (limit > 200) limit = 200;\n\n            // ‚úÖ Visibility enforcement for messages in Restricted mode\n            await EnsureCanViewConversationAsync(businessId, contactId, currentUserId, ct)\n                .ConfigureAwait(false);\n\n            var cursorObj = CursorCodec.Decode<MessagesCursor>(cursor);\n\n            var q = _db.MessageLogs\n                .AsNoTracking()\n                .Where(x => x.BusinessId == businessId && x.ContactId == contactId);\n\n            if (cursorObj != null && cursorObj.MessageId != Guid.Empty)\n            {\n                var inst = DateTime.SpecifyKind(cursorObj.InstantUtc, DateTimeKind.Utc);\n                var mid = cursorObj.MessageId;\n\n                q = q.Where(x =>\n                    (x.SentAt ?? x.CreatedAt) < inst ||\n                    ((x.SentAt ?? x.CreatedAt) == inst && x.Id.CompareTo(mid) < 0));\n            }\n\n            var rows = await q\n                .OrderByDescending(x => x.SentAt ?? x.CreatedAt)\n                .ThenByDescending(x => x.Id)\n                .Take(limit + 1)\n                .ToListAsync(ct)\n                .ConfigureAwait(false);\n\n            var hasMore = rows.Count > limit;\n            var pageRows = rows.Take(limit).ToList();\n\n            var items = pageRows.Select(x =>\n            {\n                var instant = x.SentAt ?? x.CreatedAt;\n                var utcInstant = instant.Kind == DateTimeKind.Utc ? instant : instant.ToUniversalTime();\n\n                return new ChatInboxMessageDto\n                {\n                    Id = x.Id,\n                    Direction = x.IsIncoming ? \"in\" : \"out\",\n                    Channel = \"whatsapp\",\n                    Text = x.RenderedBody ?? x.MessageContent ?? string.Empty,\n                    MediaId = x.MediaId,\n                    MediaType = x.MediaType,\n                    FileName = x.FileName,\n                    MimeType = x.MimeType,\n                    LocationLatitude = x.LocationLatitude,\n                    LocationLongitude = x.LocationLongitude,\n                    LocationName = x.LocationName,\n                    LocationAddress = x.LocationAddress,\n                    SentAtUtc = utcInstant,\n                    Status = x.Status,\n                    ErrorMessage = x.ErrorMessage\n                };\n            }).ToList();\n\n            string? nextCursor = null;\n            if (hasMore && pageRows.Count > 0)\n            {\n                var last = pageRows.Last();\n                var instant = last.SentAt ?? last.CreatedAt;\n                var utcInstant = instant.Kind == DateTimeKind.Utc ? instant : instant.ToUniversalTime();\n\n                nextCursor = CursorCodec.Encode(new MessagesCursor\n                {\n                    InstantUtc = utcInstant,\n                    MessageId = last.Id\n                });\n            }\n\n            return new PagedResultDto<ChatInboxMessageDto>\n            {\n                Items = items,\n                HasMore = hasMore,\n                NextCursor = nextCursor\n            };\n        }\n\n        private async Task EnsureCanViewConversationAsync(\n            Guid businessId,\n            Guid contactId,\n            Guid? currentUserId,\n            CancellationToken ct)\n        {\n            // Shared mode => everyone in business can view.\n            var visibility = await _db.Businesses\n                .AsNoTracking()\n                .Where(b => b.Id == businessId)\n                .Select(b => (InboxVisibilityMode?)b.InboxVisibilityMode)\n                .FirstOrDefaultAsync(ct)\n                .ConfigureAwait(false) ?? InboxVisibilityMode.SharedInInbox;\n\n            if (visibility != InboxVisibilityMode.AssignedOnly)\n                return;\n\n            if (!currentUserId.HasValue || currentUserId.Value == Guid.Empty)\n                throw new UnauthorizedAccessException(\"Restricted inbox: user context required.\");\n\n            var canSeeAll = await CanSeeAllInRestrictedModeAsync(businessId, currentUserId.Value, ct)\n                .ConfigureAwait(false);\n\n            if (canSeeAll)\n                return;\n\n            // ‚úÖ Must be assigned to this user\n            var allowed = await _db.Contacts\n                .AsNoTracking()\n                .AnyAsync(c =>\n                    c.BusinessId == businessId &&\n                    c.Id == contactId &&\n                    c.AssignedAgentId == currentUserId.Value, ct)\n                .ConfigureAwait(false);\n\n            if (!allowed)\n                throw new UnauthorizedAccessException(\"Restricted inbox: you are not assigned to this conversation.\");\n        }\n\n        // ===========================\n        // Restricted-mode helpers\n        // ===========================\n\n        private static bool IsPrivilegedRoleName(string? roleName)\n        {\n            var role = (roleName ?? string.Empty).Trim().ToLowerInvariant();\n            return role is \"admin\" or \"business\" or \"superadmin\" or \"partner\";\n        }\n\n        private async Task<bool> CanSeeAllInRestrictedModeAsync(Guid businessId, Guid userId, CancellationToken ct)\n        {\n            var userRow = await _db.Users\n                .AsNoTracking()\n                .Where(u => u.Id == userId && u.BusinessId == businessId && !u.IsDeleted && u.Status == \"Active\")\n                .Select(u => new\n                {\n                    u.RoleId,\n                    RoleName = u.Role != null ? u.Role.Name : null\n                })\n                .FirstOrDefaultAsync(ct)\n                .ConfigureAwait(false);\n\n            if (userRow == null) return false;\n\n            if (IsPrivilegedRoleName(userRow.RoleName))\n                return true;\n\n            return await HasPermissionAsync(userId, InboxAssignPermissionCode, ct).ConfigureAwait(false);\n        }\n\n        private async Task<bool> HasPermissionAsync(Guid userId, string permissionCode, CancellationToken ct)\n        {\n            var code = (permissionCode ?? string.Empty).Trim().ToUpperInvariant();\n            if (code.Length == 0) return false;\n\n            var permissionId = await _db.Permissions\n                .AsNoTracking()\n                .Where(p => p.Code != null && p.Code.ToUpper() == code)\n                .Select(p => (Guid?)p.Id)\n                .FirstOrDefaultAsync(ct)\n                .ConfigureAwait(false);\n\n            if (!permissionId.HasValue) return false;\n\n            var direct = await _db.UserPermissions\n                .AsNoTracking()\n                .AnyAsync(up =>\n                    up.UserId == userId &&\n                    up.PermissionId == permissionId.Value &&\n                    up.IsGranted &&\n                    !up.IsRevoked, ct)\n                .ConfigureAwait(false);\n\n            if (direct) return true;\n\n            var roleId = await _db.Users\n                .AsNoTracking()\n                .Where(u => u.Id == userId)\n                .Select(u => u.RoleId)\n                .FirstOrDefaultAsync(ct)\n                .ConfigureAwait(false);\n\n            if (!roleId.HasValue) return false;\n\n            return await _db.RolePermissions\n                .AsNoTracking()\n                .AnyAsync(rp =>\n                    rp.RoleId == roleId.Value &&\n                    rp.PermissionId == permissionId.Value &&\n                    rp.IsActive &&\n                    !rp.IsRevoked, ct)\n                .ConfigureAwait(false);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/Services/IChatInboxAssignmentService.cs",
      "sha256": "6cd1d4ad791003816b2b886b52e41f5d4a892acb79ae0d5e6e06dd2674282c4e",
      "language": "csharp",
      "size": 721,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.ChatInbox.DTOs;\n\nnamespace xbytechat.api.Features.ChatInbox.Services\n{\n    public interface IChatInboxAssignmentService\n    {\n        Task<List<AgentDto>> GetAgentsAsync(Guid businessId, CancellationToken ct = default);\n\n        Task AssignAsync(Guid businessId, Guid contactId, Guid userId, Guid actorUserId, CancellationToken ct = default);\n        Task UnassignAsync(Guid businessId, Guid contactId, Guid actorUserId, CancellationToken ct = default);\n        Task SetStatusAsync(Guid businessId, Guid contactId, string status, Guid actorUserId, CancellationToken ct = default);\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/Services/IChatInboxCommandService.cs",
      "sha256": "fe1087d7e7140bbd2b8f4a8778c0ab0e53f70289ea02fb189749bc338476a848",
      "language": "csharp",
      "size": 2332,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/Services/IChatInboxCommandService.cs\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.ChatInbox.DTOs;\n\nnamespace xbytechat.api.Features.ChatInbox.Services\n{\n    public interface IChatInboxCommandService\n    {\n        /// <summary>\n        /// Sends an agent-authored text message to a contact from the Chat Inbox\n        /// and returns the resulting message DTO for the UI bubble.\n        /// </summary>\n        Task<ChatInboxMessageDto> SendAgentMessageAsync(\n            ChatInboxSendMessageRequestDto request,\n            CancellationToken ct = default);\n\n        /// <summary>\n        /// Updates per-user read state (ContactReads) for a conversation.\n        /// </summary>\n        //Task MarkConversationAsReadAsync(\n        //    ChatInboxMarkReadRequestDto request,\n        //    CancellationToken ct = default);\n\n        Task MarkConversationAsReadAsync(\n           Guid businessId,\n           Guid contactId,\n           Guid userId,\n           DateTime? lastReadAtUtc,\n           CancellationToken ct = default);\n    }\n}\n\n\n//using xbytechat.api.Features.ChatInbox.DTOs;\n\n//namespace xbytechat.api.Features.ChatInbox.Services\n//{\n//    public interface IChatInboxCommandService\n//    {\n//        /// <summary>\n//        /// Sends an agent-authored text message to a contact from the Chat Inbox\n//        /// and returns the resulting message DTO for the UI bubble.\n//        /// </summary>\n//        Task<ChatInboxMessageDto> SendAgentMessageAsync(\n//            ChatInboxSendMessageRequestDto request,\n//            CancellationToken ct = default);\n//        Task MarkConversationAsReadAsync(\n//            ChatInboxMarkReadRequestDto request,\n//            CancellationToken ct = default);\n\n//        Task AssignConversationAsync(\n//           ChatInboxAssignRequestDto request,\n//           CancellationToken ct = default);\n\n//        /// <summary>\n//        /// Unassigns a conversation (sets AssignedAgentId to null).\n//        /// </summary>\n//        Task UnassignConversationAsync(\n//            ChatInboxUnassignRequestDto request,\n//            CancellationToken ct = default);\n\n//        Task ChangeConversationStatusAsync(\n//           ChatInboxChangeStatusRequestDto request,\n//           CancellationToken ct = default);\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/Services/IChatInboxMediaContentService.cs",
      "sha256": "6c4f907fe73fbfe8ae410bb04d5f4d22d1e182dc2e9f6c01e110e4212b945f9e",
      "language": "csharp",
      "size": 385,
      "content": "using System;\nusing System.IO;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.ChatInbox.Services\n{\n    public interface IChatInboxMediaContentService\n    {\n        Task<(Stream Stream, string ContentType)> DownloadFromWhatsAppAsync(\n            Guid businessId,\n            string mediaId,\n            CancellationToken ct = default);\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/Services/IChatInboxMediaUploadService.cs",
      "sha256": "cefe534d5e5f40e1b10cd805528e4d3fe5a24a071cac7764d47e3bfb9adc6872",
      "language": "csharp",
      "size": 402,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Http;\n\nnamespace xbytechat.api.Features.ChatInbox.Services\n{\n    public interface IChatInboxMediaUploadService\n    {\n        Task<string> UploadToWhatsAppAsync(\n            Guid businessId,\n            string? phoneNumberId,\n            IFormFile file,\n            CancellationToken ct = default);\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/Services/IChatInboxQueryService.cs",
      "sha256": "963dc750087f4539b0bfeafa54493cc630b55987bf2cdd43a94f50885653de22",
      "language": "csharp",
      "size": 3320,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/Services/IChatInboxQueryService.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.ChatInbox.DTOs;\n\nnamespace xbytechat.api.Features.ChatInbox.Services\n{\n    public interface IChatInboxQueryService\n    {\n        // =========================\n        // Conversations\n        // =========================\n\n        // ‚úÖ Existing (non-paged)\n        Task<IReadOnlyList<ChatInboxConversationDto>> GetConversationsAsync(\n            ChatInboxFilterDto filter,\n            CancellationToken ct = default);\n\n        // ‚úÖ Cursor paging (used by controller when paged=true)\n        Task<PagedResultDto<ChatInboxConversationDto>> GetConversationsPageAsync(\n            ChatInboxFilterDto filter,\n            CancellationToken ct = default);\n\n        // =========================\n        // Messages (LEGACY)\n        // NOTE: These are backward compatible and DO NOT enforce restricted-mode visibility.\n        // Prefer the secured overloads below in controllers.\n        // =========================\n\n        Task<IReadOnlyList<ChatInboxMessageDto>> GetMessagesForConversationAsync(\n            Guid businessId,\n            string contactPhone,\n            int limit,\n            CancellationToken ct = default);\n\n        Task<IReadOnlyList<ChatInboxMessageDto>> GetMessagesForConversationByContactIdAsync(\n            Guid businessId,\n            Guid contactId,\n            int limit,\n            CancellationToken ct = default);\n\n        Task<PagedResultDto<ChatInboxMessageDto>> GetMessagesPageForConversationByContactIdAsync(\n            Guid businessId,\n            Guid contactId,\n            int limit,\n            string? cursor,\n            CancellationToken ct = default);\n\n        Task<PagedResultDto<ChatInboxMessageDto>> GetMessagesPageForConversationByPhoneAsync(\n            Guid businessId,\n            string contactPhone,\n            int limit,\n            string? cursor,\n            CancellationToken ct = default);\n\n        // =========================\n        // Messages (SECURED)\n        // ‚úÖ These enforce AssignedOnly restrictions using currentUserId from token.\n        // =========================\n\n        Task<IReadOnlyList<ChatInboxMessageDto>> GetMessagesForConversationAsync(\n            Guid businessId,\n            string contactPhone,\n            int limit,\n            Guid currentUserId,\n            CancellationToken ct = default);\n\n        Task<IReadOnlyList<ChatInboxMessageDto>> GetMessagesForConversationByContactIdAsync(\n            Guid businessId,\n            Guid contactId,\n            int limit,\n            Guid currentUserId,\n            CancellationToken ct = default);\n\n        Task<PagedResultDto<ChatInboxMessageDto>> GetMessagesPageForConversationByContactIdAsync(\n            Guid businessId,\n            Guid contactId,\n            int limit,\n            string? cursor,\n            Guid currentUserId,\n            CancellationToken ct = default);\n\n        Task<PagedResultDto<ChatInboxMessageDto>> GetMessagesPageForConversationByPhoneAsync(\n            Guid businessId,\n            string contactPhone,\n            int limit,\n            string? cursor,\n            Guid currentUserId,\n            CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/Utils/CursorCodec.cs",
      "sha256": "21089bac9edefd1e4a8b178491f66857b944410812a7b0ee113eec56c08bd2c9",
      "language": "csharp",
      "size": 1531,
      "content": "using System;\nusing System.Text;\nusing System.Text.Json;\n\nnamespace xbytechat.api.Features.ChatInbox.Utils\n{\n    internal static class CursorCodec\n    {\n        private static readonly JsonSerializerOptions JsonOpts = new(JsonSerializerDefaults.Web);\n\n        public static string Encode<T>(T obj)\n        {\n            var json = JsonSerializer.Serialize(obj, JsonOpts);\n            var bytes = Encoding.UTF8.GetBytes(json);\n            return Base64UrlEncode(bytes);\n        }\n\n        public static T? Decode<T>(string? cursor)\n        {\n            if (string.IsNullOrWhiteSpace(cursor)) return default;\n\n            try\n            {\n                var bytes = Base64UrlDecode(cursor.Trim());\n                var json = Encoding.UTF8.GetString(bytes);\n                return JsonSerializer.Deserialize<T>(json, JsonOpts);\n            }\n            catch\n            {\n                return default;\n            }\n        }\n\n        private static string Base64UrlEncode(byte[] input)\n        {\n            return Convert.ToBase64String(input)\n                .TrimEnd('=')\n                .Replace('+', '-')\n                .Replace('/', '_');\n        }\n\n        private static byte[] Base64UrlDecode(string input)\n        {\n            var padded = input.Replace('-', '+').Replace('_', '/');\n            switch (padded.Length % 4)\n            {\n                case 2: padded += \"==\"; break;\n                case 3: padded += \"=\"; break;\n            }\n            return Convert.FromBase64String(padded);\n        }\n    }\n}\n"
    }
  ]
}
