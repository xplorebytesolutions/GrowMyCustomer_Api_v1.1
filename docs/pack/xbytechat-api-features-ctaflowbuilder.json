{
  "name": "xbytechat-api/Features/CTAFlowBuilder",
  "generatedAt": "2026-02-11 19:15:17 +00:00",
  "files": [
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Controllers/CTAFlowController.cs",
      "sha256": "941d3a884c221e0a18355505ebd681462d87259abca4e801e091070410f16d21",
      "language": "csharp",
      "size": 9864,
      "content": "using Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Serilog;\nusing xbytechat.api.Features.CTAFlowBuilder.DTOs;\nusing xbytechat.api.Features.CTAFlowBuilder.Services;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Controllers\n{\n    [Authorize]\n    [ApiController]\n    [Route(\"api/cta-flow\")]\n    public class CTAFlowController : ControllerBase\n    {\n        private readonly ICTAFlowService _flowService;\n\n        public CTAFlowController(ICTAFlowService flowService)\n        {\n            _flowService = flowService;\n        }\n\n        // CREATE (draft-only)\n        [HttpPost(\"save-visual\")]\n        public async Task<IActionResult> SaveVisualFlow([FromBody] SaveVisualFlowDto dto)\n        {\n            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n            var createdBy = User.FindFirst(\"name\")?.Value ?? \"system\";\n            if (!Guid.TryParse(businessIdClaim, out var businessId))\n                return BadRequest(new { message = \"‚ùå Invalid business ID\" });\n\n            Log.Information(\"üì¶ Saving CTA Flow: {FlowName} by {User}\", dto.FlowName, createdBy);\n\n            var result = await _flowService.SaveVisualFlowAsync(dto, businessId, createdBy);\n            if (!result.Success)\n            {\n                var m = (result.ErrorMessage ?? \"\").Trim();\n\n                // map common validation/conflict by message text (no result.Code available)\n                if (m.Contains(\"already exists\", StringComparison.OrdinalIgnoreCase))\n                    return Conflict(new { message = \"‚ùå Duplicate flow name\", error = m });\n\n                if (m.Contains(\"required\", StringComparison.OrdinalIgnoreCase) ||\n                    m.Contains(\"empty flow\", StringComparison.OrdinalIgnoreCase) ||\n                    m.Contains(\"invalid\", StringComparison.OrdinalIgnoreCase))\n                    return BadRequest(new { message = \"‚ùå Failed to save flow\", error = m });\n\n                return StatusCode(StatusCodes.Status500InternalServerError,\n                    new { message = \"‚ùå Failed to save flow\", error = string.IsNullOrWhiteSpace(m) ? \"Unknown error\" : m });\n            }\n\n            Guid? flowId = null;\n            if (result.Data is not null)\n            {\n                try { dynamic d = result.Data; flowId = (Guid?)d.flowId; } catch { }\n            }\n\n            return Ok(new { message = \"‚úÖ Flow saved successfully\", flowId });\n        }\n\n        // UPDATE (save as draft by id)\n        [HttpPut(\"{id:guid}\")]\n        public async Task<IActionResult> Update(Guid id, [FromBody] SaveVisualFlowDto dto)\n        {\n            var biz = User.FindFirst(\"businessId\")?.Value;\n            var user = User.FindFirst(\"name\")?.Value ?? \"system\";\n            if (!Guid.TryParse(biz, out var businessId))\n                return BadRequest(new { message = \"‚ùå Invalid business.\" });\n\n            var result = await _flowService.UpdateVisualFlowAsync(id, dto, businessId, user);\n\n            return result.Status switch\n            {\n                \"notFound\" => NotFound(new { message = result.Message ?? \"‚ùå Flow not found.\" }),\n                \"requiresFork\" => Conflict(new { message = result.Message ?? \"‚ùå Edit requires fork.\", campaigns = result.Campaigns }),\n                \"error\" => BadRequest(new { message = result.Message ?? \"‚ùå Failed to update flow.\" }),\n                _ => Ok(new { message = result.Message ?? \"‚úÖ Flow updated (draft).\", needsRepublish = result.NeedsRepublish })\n            };\n        }\n\n        // FORK (create a new draft copy)\n        [HttpPost(\"{id:guid}/fork\")]\n        public async Task<IActionResult> Fork(Guid id)\n        {\n            var biz = User.FindFirst(\"businessId\")?.Value;\n            var user = User.FindFirst(\"name\")?.Value ?? \"system\";\n            if (!Guid.TryParse(biz, out var businessId))\n                return BadRequest(new { message = \"‚ùå Invalid business.\" });\n\n            var forkId = await _flowService.ForkFlowAsync(id, businessId, user);\n            if (forkId == Guid.Empty) return NotFound(new { message = \"‚ùå Flow not found.\" });\n\n            return Ok(new { flowId = forkId });\n        }\n\n        // PUBLISH (by id)\n        [HttpPost(\"{id:guid}/publish\")]\n        public async Task<IActionResult> Publish(Guid id)\n        {\n            var biz = User.FindFirst(\"businessId\")?.Value;\n            var user = User.FindFirst(\"name\")?.Value ?? \"system\";\n            if (!Guid.TryParse(biz, out var businessId))\n                return BadRequest(new { message = \"‚ùå Invalid business.\" });\n\n            var result = await _flowService.PublishFlowAsync(id, businessId, user);\n\n            if (result.Success)\n                return Ok(new { message = result.Message ?? \"‚úÖ Flow published.\" });\n\n            var msg = (result.ErrorMessage ?? result.Message ?? \"‚ùå Failed to publish.\").Trim();\n\n            if (result.Code == 404)\n                return NotFound(new { message = msg });\n\n            // Validation failures return 400 with details in payload (issue list)\n            if (result.Code == 400)\n                return BadRequest(new { message = msg, issues = result.Payload });\n\n            return BadRequest(new { message = msg });\n        }\n\n        // DELETE (only if not attached)\n        [HttpDelete(\"{id:guid}\")]\n        public async Task<IActionResult> Delete(Guid id)\n        {\n            var biz = User.FindFirst(\"businessId\")?.Value;\n            if (!Guid.TryParse(biz, out var businessId))\n                return BadRequest(new { message = \"‚ùå Invalid business.\" });\n\n            var deletedBy = User.FindFirst(\"name\")?.Value\n                          ?? User.FindFirst(\"email\")?.Value\n                          ?? User.FindFirst(\"sub\")?.Value\n                          ?? \"system\";\n\n            var result = await _flowService.DeleteFlowAsync(id, businessId, deletedBy);\n\n            if (!result.Success)\n            {\n                var msg = (result.ErrorMessage ?? result.Message ?? string.Empty).Trim();\n\n                // If message says it's attached, return 409 and include campaigns for the modal\n                if (msg.Contains(\"attached\", StringComparison.OrdinalIgnoreCase) ||\n                    msg.Contains(\"Cannot delete\", StringComparison.OrdinalIgnoreCase))\n                {\n                    var campaigns = await _flowService.GetAttachedCampaignsAsync(id, businessId);\n                    return Conflict(new { message = msg, campaigns });\n                }\n\n                if (msg.Contains(\"not found\", StringComparison.OrdinalIgnoreCase))\n                    return NotFound(new { message = msg });\n\n                return BadRequest(new { message = string.IsNullOrWhiteSpace(msg) ? \"Delete failed.\" : msg });\n            }\n\n            return Ok(new { message = result.Message ?? \"‚úÖ Flow deleted.\" });\n        }\n\n        // LISTS\n        [HttpGet(\"all-published\")]\n        public async Task<IActionResult> GetPublishedFlows()\n        {\n            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n            if (!Guid.TryParse(businessIdClaim, out var businessId))\n                return BadRequest(new { message = \"‚ùå Invalid business ID\" });\n\n            var flows = await _flowService.GetAllPublishedFlowsAsync(businessId);\n            return Ok(flows);\n        }\n\n        [HttpGet(\"all-draft\")]\n        public async Task<IActionResult> GetAllDraftFlows()\n        {\n            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n            if (!Guid.TryParse(businessIdClaim, out var businessId))\n                return BadRequest(new { message = \"‚ùå Invalid business ID\" });\n\n            var flows = await _flowService.GetAllDraftFlowsAsync(businessId);\n            return Ok(flows);\n        }\n\n        // DETAIL\n        [HttpGet(\"by-id/{id:guid}\")]\n        public async Task<IActionResult> GetById(Guid id)\n        {\n            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n            if (!Guid.TryParse(businessIdClaim, out var businessId))\n                return BadRequest(new { message = \"‚ùå Invalid business ID\" });\n\n            var dto = await _flowService.GetVisualFlowByIdAsync(id, businessId);\n            if (dto is null) return NotFound(new { message = \"‚ùå Flow not found.\" });\n\n            return Ok(dto);\n        }\n\n        [HttpGet(\"visual/{id:guid}\")]\n        public async Task<IActionResult> GetVisualFlow(Guid id)\n        {\n            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n            if (!Guid.TryParse(businessIdClaim, out var businessId))\n                return BadRequest(new { message = \"‚ùå Invalid business ID\" });\n\n            var result = await _flowService.GetVisualFlowAsync(id, businessId);\n            if (!result.Success)\n            {\n                var m = (result.ErrorMessage ?? string.Empty).Trim();\n                if (m.Contains(\"not found\", StringComparison.OrdinalIgnoreCase))\n                    return NotFound(new { message = \"‚ùå Failed to load flow\", error = m });\n\n                return StatusCode(StatusCodes.Status500InternalServerError,\n                    new { message = \"‚ùå Failed to load flow\", error = string.IsNullOrWhiteSpace(m) ? \"Unknown error\" : m });\n            }\n\n            return Ok(result.Data);\n        }\n\n        // USAGE (for delete guard)\n        [HttpGet(\"{id:guid}/usage\")]\n        public async Task<IActionResult> GetUsage(Guid id)\n        {\n            var biz = User.FindFirst(\"businessId\")?.Value;\n            if (!Guid.TryParse(biz, out var businessId))\n                return BadRequest(new { message = \"Invalid business.\" });\n\n            var campaigns = await _flowService.GetAttachedCampaignsAsync(id, businessId);\n            return Ok(new\n            {\n                canDelete = campaigns.Count == 0,\n                count = campaigns.Count,\n                campaigns\n            });\n        }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Controllers/FlowRedirectController.cs",
      "sha256": "8d5442a0a0fdb92dc7d69837cd74af882b22c6cf35ce999a7b87bfde5b27e7ca",
      "language": "csharp",
      "size": 2686,
      "content": "// üìÑ Features/CTAFlowBuilder/Controllers/FlowRedirectController.cs\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Infrastructure.Flows;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\nusing xbytechat.api.Features.CTAFlowBuilder.Services;\nusing Microsoft.AspNetCore.Authorization;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Controllers\n{\n    [ApiController]\n    [Route(\"r/flow\")]\n    public class FlowRedirectController : ControllerBase\n    {\n        private readonly IFlowClickTokenService _tokens;\n        private readonly ICTAFlowService _flows;           // service to read flow steps/links\n        private readonly IFlowRuntimeService _runtime;     // service to execute next step\n\n        public FlowRedirectController(\n            IFlowClickTokenService tokens,\n            ICTAFlowService flows,\n            IFlowRuntimeService runtime)\n        {\n            _tokens = tokens;\n            _flows = flows;\n            _runtime = runtime;\n        }\n\n        [HttpGet(\"{token}\")]\n        [AllowAnonymous] // secure by token, tenant checks inside\n        public async Task<IActionResult> RedirectByToken(string token)\n        {\n            FlowClickPayload p;\n            try\n            {\n                p = _tokens.Validate(token);\n            }\n            catch (Exception ex)\n            {\n                return BadRequest($\"Invalid or expired token: {ex.Message}\");\n            }\n\n            // üîí Tenant isolation: make sure the business in the token matches the current request context\n            // (if you have multi-tenant enforcement middleware, call it here)\n\n            // 1) Resolve the button link\n            var link = await _flows.GetLinkAsync(p.fid, p.sid, p.bi);\n            if (link is null)\n                return NotFound(\"Link not found for this flow step\");\n\n            var requestId = Guid.NewGuid(); // for idempotency\n            var exec = await _runtime.ExecuteNextAsync(new NextStepContext\n            {\n                BusinessId = p.biz,\n                FlowId = p.fid,\n                Version = p.ver,\n                SourceStepId = p.sid,\n                TargetStepId = link.NextStepId, // may be null ‚Üí terminal\n                ButtonIndex = p.bi,\n                MessageLogId = p.mlid,\n                ContactPhone = p.cp,\n                RequestId = requestId,\n\n                // üÜï Pass the clicked button for runtime decision\n                ClickedButton = link\n            });\n\n\n            // 3) Redirect the user\n            // If button was a URL, use that; else go to a generic \"thank you\" page\n            var dest = exec.RedirectUrl ?? \"/thank-you\";\n            return Redirect(dest);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/AttachedCampaignDto.cs",
      "sha256": "0d3666aab91197bf746299620d01d22712744acbbcb28b0a787a8e399eaf123f",
      "language": "csharp",
      "size": 341,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public sealed record AttachedCampaignDto(\n        Guid Id,\n        string Name,\n        string Status,\n        DateTime? ScheduledAt,\n        DateTime CreatedAt,\n        string? CreatedBy,\n        DateTime? FirstSentAt   // earliest non-null SentAt from CampaignSendLogs\n    );\n\n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/CreateFlowDto.cs",
      "sha256": "c23400a06816a2adc8886fa8d20dd77f12b8b93f993b5a772d81cb12d6612a1f",
      "language": "csharp",
      "size": 897,
      "content": "// üìÑ File: xbytechat.api/Features/CTAFlowBuilder/DTOs/CreateFlowDto.cs\nnamespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class CreateFlowDto\n    {\n        public string FlowName { get; set; } = string.Empty;\n        public List<FlowStepDto> Steps { get; set; } = new();\n        public bool IsPublished { get; set; } = false; // ‚úÖ NEW: Draft vs Published\n    }\n\n    public class FlowStepDto\n    {\n        public string TriggerButtonText { get; set; } = string.Empty;\n        public string TriggerButtonType { get; set; } = string.Empty;\n        public string TemplateToSend { get; set; } = string.Empty;\n        public int StepOrder { get; set; }\n        public List<ButtonLinkDto> ButtonLinks { get; set; } = new();\n    }\n\n    public class ButtonLinkDto\n    {\n        public string ButtonText { get; set; } = string.Empty;\n        public Guid NextStepId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/CTAButtonClickDto.cs",
      "sha256": "da355d853887193eb1d2b3e3fafcf076e6df764f0220cbf10f5c050d42b91df6",
      "language": "csharp",
      "size": 432,
      "content": "using System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class CTAButtonClickDto\n    {\n        [Required]\n        public string ButtonText { get; set; } = string.Empty;\n\n        [Required]\n        public string ButtonType { get; set; } = \"cta\"; // e.g., \"quick_reply\", \"url\", etc.\n\n        [Required]\n        public string RecipientNumber { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/CTAFlowExecutionRequest.cs",
      "sha256": "43fc0e1c1674d188b1a5385539f1314176ff81449d4547ea6665df9909a223bb",
      "language": "csharp",
      "size": 297,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class CTAFlowExecutionRequest\n    {\n        public string ButtonText { get; set; } = string.Empty;\n        public string ButtonType { get; set; } = \"cta\";\n        public string RecipientNumber { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/CtaFlowRunResult.cs",
      "sha256": "2a042b3a78e66a762ca685c50cc13508c063fd3076e291597275bbc64620e6a1",
      "language": "csharp",
      "size": 433,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public sealed class CtaFlowRunResult\n    {\n        /// <summary>\n        /// True if the CTA flow was started/executed successfully.\n        /// </summary>\n        public bool Success { get; set; }\n\n        /// <summary>\n        /// Optional human-readable error message when Success = false.\n        /// </summary>\n        public string? ErrorMessage { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/FlowEdgeDto.cs",
      "sha256": "27e76e22a8aba502d5727d9959bec58ea011d2a1f0d4388a141bfa8108043eea",
      "language": "csharp",
      "size": 272,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class FlowEdgeDto\n    {\n        public string FromNodeId { get; set; } = string.Empty;\n        public string ToNodeId { get; set; } = string.Empty;\n        public string? SourceHandle { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/FlowNodeDto.cs",
      "sha256": "8f6c4dce253e5e1d8afba5c757038643eb14fc9e168c85cb2c9f5314d5b10834",
      "language": "csharp",
      "size": 1832,
      "content": "    namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class FlowNodeDto\n    {\n        public string Id { get; set; } = string.Empty;\n\n        public string TemplateName { get; set; } = string.Empty;\n        public string? TemplateType { get; set; } // ‚úÖ e.g., \"image_template\", \"text_template\"\n\n        // For templates with a media header (image/video/document), this URL is required at runtime.\n        public string? HeaderMediaUrl { get; set; }\n\n        // Optional static values for BODY placeholders ({{1}},{{2}},...). Stored as a list where index 0 => {{1}}.\n        public List<string> BodyParams { get; set; } = new();\n\n        // Optional static values for dynamic URL button params. Index 0 => button index \"0\" (position 1).\n        // Only used when the template has URL buttons with ParameterValue like \"https://.../{{1}}\".\n        public List<string> UrlButtonParams { get; set; } = new();\n\n        public string MessageBody { get; set; } = string.Empty;\n        public string? TriggerButtonText { get; set; }\n        public string? TriggerButtonType { get; set; }\n        public float PositionX { get; set; }\n        public float PositionY { get; set; }\n\n        public string? RequiredTag { get; set; }         \n        public string? RequiredSource { get; set; }      \n        public List<LinkButtonDto> Buttons { get; set; } = new();\n        public bool UseProfileName { get; set; }\n        public int? ProfileNameSlot { get; set; }\n        //(for flow trigger mapping)\n        // ‚úÖ NEW: ReactFlow expects this structure\n        public PositionDto Position => new PositionDto\n        {\n            x = PositionX,\n            y = PositionY\n        };\n        public class PositionDto\n        {\n            public float x { get; set; }\n            public float y { get; set; }\n        }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/FlowUpdateResult.cs",
      "sha256": "54f722166617e3353652e949aa4a89c87878d4a1d30d2e208a1fb816668d0dde",
      "language": "csharp",
      "size": 443,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public sealed class FlowUpdateResult\n    {\n        // ok | requiresFork | notFound | error\n        public string Status { get; set; } = \"ok\";\n        public string? Message { get; set; }\n        public bool NeedsRepublish { get; set; } // true when we flipped published->draft to allow editing\n        public object? Campaigns { get; set; }   // list for UI when requiresFork\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/LinkButtonDto.cs",
      "sha256": "e02e2c927a96e1e02c0537fb205fd7595289bdfaa9de15c0d7a55de64a90fbc5",
      "language": "csharp",
      "size": 522,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class LinkButtonDto\n    {\n        public string Text { get; set; } = string.Empty;\n        public int Index { get; set; } = -1;\n        public string? Type { get; set; } // üî• e.g., \"URL\", \"QUICK_REPLY\"\n        public string? SubType { get; set; } // üî• e.g., \"STATIC\", \"DYNAMIC\"\n        public string? Value { get; set; } // üî• the parameter or url or payload\n\n        public string? TargetNodeId { get; set; } // üîÑ used for flow linking\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/SaveVisualFlowDto.cs",
      "sha256": "7de59d222a97efeaf9dc23dea2ef351d852087539cec12e7c946b02e11f1bd21",
      "language": "csharp",
      "size": 403,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class SaveVisualFlowDto\n    {\n        public string FlowName { get; set; } = string.Empty;\n        public bool IsPublished { get; set; }\n\n        public List<FlowNodeDto> Nodes { get; set; } = new();\n        public List<FlowEdgeDto> Edges { get; set; } = new();\n        public Guid? CampaignId { get; set; } // ‚úÖ Add this line\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/VisualFlowLoadDto.cs",
      "sha256": "10bfe378ffd4c8fb74a0746f2abafec88897072e7a974d680396bde281aaf4af",
      "language": "csharp",
      "size": 289,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class VisualFlowLoadDto\n    {\n        public string FlowName { get; set; } = string.Empty;\n        public List<FlowNodeDto> Nodes { get; set; } = new();\n        public List<FlowEdgeDto> Edges { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/VisualFlowSummaryDto.cs",
      "sha256": "70dcedd3219a474a4b38927e0f0fd4ff3e21ba16632d409f146a9d0d60d685a5",
      "language": "csharp",
      "size": 300,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class VisualFlowSummaryDto\n    {\n        public Guid Id { get; set; }\n        public string FlowName { get; set; } = string.Empty;\n        public bool IsPublished { get; set; }\n        public DateTime CreatedAt { get; set; }\n    }\n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Models/CTAFlowClickLog.cs",
      "sha256": "ecbd408e613e8ef88e2bb39fdf60bc188163e209d8242317203dfb2bff8cebb8",
      "language": "csharp",
      "size": 104,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.Models\n{\n    public class CTAFlowClickLog\n    {\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Models/CTAFlowConfig.cs",
      "sha256": "a36019c3ace9f06dcc785152a4ea8e2acc280b169f9e831a28fd6efd2f9d2551",
      "language": "csharp",
      "size": 3404,
      "content": "// üìÑ File: xbytechat.api/Features/CTAFlowBuilder/Models/CTAFlowConfig.cs\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\nusing System.Text.Json.Serialization;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Models\n{\n    /// <summary>\n    /// Represents a complete flow configuration for a business, such as \"Interested Journey\".\n    /// </summary>\n    public class CTAFlowConfig\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        [Required]\n        public Guid BusinessId { get; set; }\n\n        [Required]\n        [MaxLength(100)]\n        public string FlowName { get; set; } = string.Empty;\n\n        public bool IsActive { get; set; } = true;\n\n        public bool IsPublished { get; set; } = false; // ‚úÖ NEW: Support draft/published\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n        public string? CreatedBy { get; set; }\n        public DateTime? UpdatedAt { get; set; }  // ‚úÖ Add this line\n\n        // üîÅ Navigation to steps\n        public ICollection<CTAFlowStep> Steps { get; set; } = new List<CTAFlowStep>();\n    }\n}\n\n// üìÑ File: xbytechat.api/Features/CTAFlowBuilder/Models/CTAFlowConfig.cs\n//using System.ComponentModel.DataAnnotations;\n//using System.Text.Json.Serialization;\n//using Microsoft.EntityFrameworkCore;\n\n//namespace xbytechat.api.Features.CTAFlowBuilder.Models\n//{\n//    /// <summary>\n//    /// Represents a complete flow configuration for a business, such as \"Interested Journey\".\n//    /// </summary>\n//    [Index(nameof(BusinessId), nameof(IsActive), nameof(FlowName), Name = \"ix_ctaflowconfigs_biz_active_name\")]\n//    [Index(nameof(BusinessId), nameof(IsPublished), Name = \"ix_ctaflowconfigs_biz_published\")]\n//    public class CTAFlowConfig\n//    {\n//        [Key]\n//        public Guid Id { get; set; }\n\n//        [Required]\n//        public Guid BusinessId { get; set; }\n\n//        [Required, MaxLength(100)]\n//        public string FlowName { get; set; } = string.Empty;\n\n//        /// <summary>\n//        /// Soft ‚Äúenabled/disabled‚Äù flag for listing/selection. We still hard-delete unused flows on request.\n//        /// </summary>\n//        public bool IsActive { get; set; } = true;\n\n//        /// <summary>\n//        /// Draft vs published for the builder.\n//        /// </summary>\n//        public bool IsPublished { get; set; } = false;\n\n//        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n//        public string? CreatedBy { get; set; }\n\n//        /// <summary>\n//        /// Last modification timestamp (updated in service on edits).\n//        /// </summary>\n//        public DateTime? UpdatedAt { get; set; }\n\n//        /// <summary>\n//        /// Optimistic concurrency token to avoid race conditions (e.g., editing while someone tries to delete).\n//        /// </summary>\n//        [Timestamp]\n//        public byte[]? RowVersion { get; set; }\n\n//        // üîÅ Navigation to steps\n//        // Cascade delete is configured in OnModelCreating:\n//        // modelBuilder.Entity<CTAFlowConfig>()\n//        //   .HasMany(f => f.Steps).WithOne(s => s.Flow)\n//        //   .HasForeignKey(s => s.FlowId)\n//        //   .OnDelete(DeleteBehavior.Cascade);\n//        [JsonIgnore] // prevent huge payloads if you serialize configs somewhere else\n//        public ICollection<CTAFlowStep> Steps { get; set; } = new List<CTAFlowStep>();\n//    }\n//}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Models/CTAFlowStep.cs",
      "sha256": "442a9f56bbf8fefda20cd184a79763eb9f0472ececa17136e35242cbeeef08b9",
      "language": "csharp",
      "size": 2700,
      "content": "// üìÑ File: Features/CTAFlowBuilder/Models/CTAFlowStep.cs\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Models\n{\n    /// <summary>\n    /// Represents a single step in a CTA flow, triggered by a button.\n    /// </summary>\n    public class CTAFlowStep\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        [Required]\n        public Guid CTAFlowConfigId { get; set; }\n\n        [ForeignKey(nameof(CTAFlowConfigId))]\n        public CTAFlowConfig Flow { get; set; } = null!;\n\n        public string TriggerButtonText { get; set; } = string.Empty;\n\n        public string TriggerButtonType { get; set; } = \"cta\"; // e.g., \"quick_reply\"\n\n        public string TemplateToSend { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Optional media URL used when the selected WhatsApp template has a media header (image/video/document).\n        /// Stored per-step so click-triggered CTA sends can resolve media without relying on campaign context.\n        /// </summary>\n        public string? HeaderMediaUrl { get; set; }\n\n        /// <summary>\n        /// JSON array of body parameter values (1-based placeholders) for WhatsApp templates, e.g. [\"Alice\",\"123\"] for {{1}},{{2}}.\n        /// Stored per-step because click-triggered CTA sends don't have campaign-time personalization context.\n        /// </summary>\n        public string? BodyParamsJson { get; set; }\n\n        /// <summary>\n        /// JSON array of URL-button parameter values (max 3). Index 0 => button index \"0\" (position 1), etc.\n        /// Used only for templates with dynamic URL buttons (ParameterValue contains \"{{n}}\").\n        /// Stored per-step so CTA runtime can satisfy Meta's required button parameters on click-triggered sends.\n        /// </summary>\n        public string? UrlButtonParamsJson { get; set; }\n\n        public int StepOrder { get; set; }\n\n        public string? RequiredTag { get; set; }        // e.g., \"interested\"\n        public string? RequiredSource { get; set; }     // e.g., \"ads\", \"qr\", \"manual\"\n\n        // üîÄ Multiple buttons linking to different steps\n        public List<FlowButtonLink> ButtonLinks { get; set; } = new();\n\n        public float? PositionX { get; set; }\n        public float? PositionY { get; set; }\n        public string? TemplateType { get; set; }\n\n        // ‚úÖ Use WhatsApp Profile Name in this step's template?\n        public bool UseProfileName { get; set; } = false;\n\n        // ‚úÖ 1-based placeholder index in the template body (e.g., {{1}})\n        public int? ProfileNameSlot { get; set; } = 1;\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Models/FlowButtonLink.cs",
      "sha256": "6b265bc48b8286ca84e5937f9f8f6fe99b8b6580ca59a43aedda8290fc685aaa",
      "language": "csharp",
      "size": 807,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.Models\n{\n    public class FlowButtonLink\n    {\n        public Guid Id { get; set; } = Guid.NewGuid();\n        public string ButtonText { get; set; } = string.Empty;\n        public Guid? NextStepId { get; set; }\n        // ‚úÖ NEW FIELDS FOR FUTURE AUTOMATION\n        public string ButtonType { get; set; } = \"QUICK_REPLY\";    // e.g., URL, QUICK_REPLY, FLOW\n        public string ButtonSubType { get; set; } = \"\";            // Optional: e.g., \"Catalog\", \"PricingCTA\"\n        public string ButtonValue { get; set; } = \"\";              // e.g., URL or deep link\n\n        // Optional FK back to Step if needed\n        public Guid CTAFlowStepId { get; set; }\n        public CTAFlowStep? Step { get; set; }\n\n        public short ButtonIndex { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Models/FlowExecutionContext.cs",
      "sha256": "3b09934afbf7d4d7844c890fde23a96a3ba4d932fa506268da131b78ac6b5385",
      "language": "csharp",
      "size": 4023,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Models\n{\n    /// <summary>\n    /// Canonical context/payload for logging a single flow step execution.\n    /// This wraps all the information we want to write into FlowExecutionLogs.\n    /// </summary>\n    public sealed class FlowExecutionContext\n    {\n        /// <summary>\n        /// Tenant / business that owns this flow execution.\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// Optional contact this journey is associated with.\n        /// </summary>\n        public Guid? ContactId { get; set; }   // üëà ADD THIS\n\n        /// <summary>\n        /// Which engine started this journey (Campaign, AutoReply, etc.).\n        /// </summary>\n        public FlowExecutionOrigin Origin { get; set; } = FlowExecutionOrigin.Unknown;\n\n        /// <summary>\n        /// Logical flow definition. For CTA flows this is CTAFlowConfig.Id.\n        /// </summary>\n        public Guid? FlowId { get; set; }\n\n        /// <summary>\n        /// Step being executed.\n        /// </summary>\n        public Guid StepId { get; set; }\n\n        /// <summary>\n        /// Optional friendly name for the step.\n        /// </summary>\n        public string? StepName { get; set; }\n\n        /// <summary>\n        /// Optional correlation id for one \"run\" of a journey.\n        /// Multiple steps in the same journey can share RunId.\n        /// </summary>\n        public Guid? RunId { get; set; }\n\n        /// <summary>\n        /// Optional higher-level campaign this journey belongs to.\n        /// </summary>\n        public Guid? CampaignId { get; set; }\n\n        /// <summary>\n        /// Optional AutoReplyFlow id when journey started from keyword matching.\n        /// </summary>\n        public Guid? AutoReplyFlowId { get; set; }\n\n        /// <summary>\n        /// Optional specific send log (CampaignSendLog) if this was tied to a blast.\n        /// </summary>\n        public Guid? CampaignSendLogId { get; set; }\n\n        /// <summary>\n        /// Optional tracking log id (CTA click tracking, etc.).\n        /// </summary>\n        public Guid? TrackingLogId { get; set; }\n\n        /// <summary>\n        /// Optional link to underlying MessageLog row.\n        /// </summary>\n        public Guid? MessageLogId { get; set; }\n\n        /// <summary>\n        /// Phone number in E.164 form that this step is interacting with.\n        /// </summary>\n        public string? ContactPhone { get; set; }\n\n        /// <summary>\n        /// Human-readable label of the button that triggered the step, if any.\n        /// </summary>\n        public string? TriggeredByButton { get; set; }\n\n        /// <summary>\n        /// Index of the clicked button (0..2) where applicable.\n        /// </summary>\n        public short? ButtonIndex { get; set; }\n\n        /// <summary>\n        /// Template name that was used in this step (if any).\n        /// </summary>\n        public string? TemplateName { get; set; }\n\n        /// <summary>\n        /// Template type / category (e.g. \"image_template\", \"text_template\").\n        /// </summary>\n        public string? TemplateType { get; set; }\n\n        /// <summary>\n        /// Per-request correlation id (can come from message engine, HTTP request, etc.).\n        /// </summary>\n        public Guid? RequestId { get; set; }\n\n        /// <summary>\n        /// Whether the step action completed successfully.\n        /// </summary>\n        public bool Success { get; set; }\n\n        /// <summary>\n        /// Error message when the step failed.\n        /// </summary>\n        public string? ErrorMessage { get; set; }\n\n        /// <summary>\n        /// Raw provider response or internal payload for debugging.\n        /// </summary>\n        public string? RawResponse { get; set; }\n\n        /// <summary>\n        /// When the step was executed (UTC).\n        /// If null, the logger will default to DateTime.UtcNow.\n        /// </summary>\n        public DateTime? ExecutedAtUtc { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Models/FlowExecutionLog.cs",
      "sha256": "d859aa17be20179548d281edae56a6d0fb7b5321f5bd49144ada2ba82ad8e5a4",
      "language": "csharp",
      "size": 1635,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Models\n{\n    /// <summary>\n    /// Logs when a visual flow step is executed (useful for analytics, debugging, audit).\n    /// </summary>\n    public class FlowExecutionLog\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        public Guid? RunId { get; set; }\n        [Required]\n        public Guid BusinessId { get; set; }\n\n        [Required]\n        public Guid StepId { get; set; }\n        public string StepName { get; set; } = string.Empty;\n\n        public Guid? FlowId { get; set; }\n\n        public FlowExecutionOrigin Origin { get; set; } = FlowExecutionOrigin.Unknown; //new\n\n        public Guid? CampaignId { get; set; } // new \n        public Guid? AutoReplyFlowId { get; set; } // new\n\n        public Guid? CampaignSendLogId { get; set; }\n\n\n        public Guid? TrackingLogId { get; set; }\n\n        public string? ContactPhone { get; set; }\n\n        public string? TriggeredByButton { get; set; }\n\n        public string? TemplateName { get; set; }\n\n        public string? TemplateType { get; set; }\n\n        public bool Success { get; set; }\n\n        public string? ErrorMessage { get; set; }\n\n        public string? RawResponse { get; set; }\n\n        public DateTime ExecutedAt { get; set; } = DateTime.UtcNow;\n\n        public Guid? MessageLogId { get; set; }              // tie to originating message\n        public short? ButtonIndex { get; set; }              // which button was clicked (0..2)\n        public Guid? RequestId { get; set; }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Models/FlowExecutionOrigin.cs",
      "sha256": "34b36adc1c0b157360c81e219a5fc265c18612efb937a62fcbea1405a41280a7",
      "language": "csharp",
      "size": 1131,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Models\n{\n    /// <summary>\n    /// Describes where a flow execution was started from.\n    /// This is the key for analytics segmentation.\n    /// </summary>\n    public enum FlowExecutionOrigin\n    {\n        /// <summary>\n        /// Default / legacy rows before origin tracking was introduced.\n        /// </summary>\n        Unknown = 0,\n\n        /// <summary>\n        /// Flow started as part of a Campaign CTA (button click, deep link, etc.).\n        /// </summary>\n        Campaign = 1,\n\n        /// <summary>\n        /// Flow started from AutoReply word matching (keyword ‚Üí flow).\n        /// </summary>\n        AutoReply = 2,\n\n        /// <summary>\n        /// Flow started from a future ‚ÄúJourneyBot‚Äù or similar orchestration engine.\n        /// </summary>\n        JourneyBot = 3,\n\n        /// <summary>\n        /// Flow started manually from Inbox or agent tools.\n        /// </summary>\n        Inbox = 4,\n\n        /// <summary>\n        /// System-driven or other internal triggers (backfill, test, etc.).\n        /// </summary>\n        System = 5\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Services/CtaFlowRuntimeService.cs",
      "sha256": "380d5227b25215b5baaf9496aa9410b6dbec2b75c883bf875ec25f707dd0b5d6",
      "language": "csharp",
      "size": 19163,
      "content": "// üìÑ xbytechat-api/Features/CTAFlowBuilder/Services/CtaFlowRuntimeService.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api; // üëà Keep this if AppDbContext is in the root namespace\n// If AppDbContext lives under xbytechat.api.Data, then use:\n// using xbytechat.api.Data;\n\nusing xbytechat.api.Features.CTAFlowBuilder.DTOs;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.MessagesEngine.Enums;\nusing xbytechat.api.Features.MessagesEngine.Services;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Services\n{\n    /// <summary>\n    /// Minimal CTA flow runtime engine (v1).\n    ///\n    /// Responsibilities:\n    /// - Load CTAFlowConfig + steps from DB.\n    /// - Execute the first step (template send) using IMessageEngineService.\n    /// - Log the execution into FlowExecutionLogs via IFlowExecutionLogger.\n    ///\n    /// It uses FlowExecutionOrigin + AutoReplyFlowId / CampaignId so analytics\n    /// can later separate:\n    ///   - \"CTA flow started by AutoReply\"\n    ///   - \"CTA flow started by Campaign button\"\n    ///   - other origins (JourneyBot, Inbox, System).\n    /// </summary>\n    public sealed class CtaFlowRuntimeService : ICtaFlowRuntimeService\n    {\n        private readonly AppDbContext _db;\n        private readonly IMessageEngineService _messageEngine;\n        private readonly IFlowExecutionLogger _flowLogger;\n        private readonly ILogger<CtaFlowRuntimeService> _logger;\n\n        public CtaFlowRuntimeService(\n            AppDbContext db,\n            IMessageEngineService messageEngine,\n            IFlowExecutionLogger flowLogger,\n            ILogger<CtaFlowRuntimeService> logger)\n        {\n            _db = db ?? throw new ArgumentNullException(nameof(db));\n            _messageEngine = messageEngine ?? throw new ArgumentNullException(nameof(messageEngine));\n            _flowLogger = flowLogger ?? throw new ArgumentNullException(nameof(flowLogger));\n            _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n        }\n\n        public async Task<CtaFlowRunResult> StartFlowAsync(\n            Guid businessId,\n            Guid contactId,\n            string contactPhone,\n            Guid configId,\n            FlowExecutionOrigin origin,\n            Guid? autoReplyFlowId,\n            CancellationToken cancellationToken = default)\n        {\n            if (businessId == Guid.Empty)\n                throw new ArgumentException(\"businessId is required\", nameof(businessId));\n            if (configId == Guid.Empty)\n                throw new ArgumentException(\"configId is required\", nameof(configId));\n            if (string.IsNullOrWhiteSpace(contactPhone))\n                throw new ArgumentException(\"contactPhone is required\", nameof(contactPhone));\n\n            _logger.LogInformation(\n                \"üöÄ [CTAFlowRuntime] StartFlowAsync Biz={BusinessId}, Contact={ContactId}, Phone={Phone}, Config={ConfigId}, Origin={Origin}, AutoReplyFlowId={AutoReplyFlowId}\",\n                businessId,\n                contactId,\n                contactPhone,\n                configId,\n                origin,\n                autoReplyFlowId);\n\n            // 1Ô∏è‚É£ Load the CTA flow (must be active + published) with its steps\n            var flow = await _db.CTAFlowConfigs\n                .AsNoTracking()\n                .Include(f => f.Steps)\n                .FirstOrDefaultAsync(\n                    f => f.Id == configId\n                         && f.BusinessId == businessId\n                         && f.IsActive\n                         && f.IsPublished,\n                    cancellationToken);\n\n            if (flow == null)\n            {\n                var message =\n                    $\"CTA flow {configId} for business {businessId} not found, inactive, or not published.\";\n\n                _logger.LogWarning(\"[CTAFlowRuntime] {Message}\", message);\n\n                // Log a failed \"meta-step\" so analytics can see the failure\n                var failCtx = new FlowExecutionContext\n                {\n                    BusinessId = businessId,\n                    FlowId = configId,\n                    AutoReplyFlowId = autoReplyFlowId,\n                    Origin = origin,\n\n                    // NEW: log which contact we tried to start for\n                    ContactId = contactId,\n                    ContactPhone = contactPhone,\n\n                    StepId = configId,          // no specific step; use flow id as placeholder\n                    StepName = \"FLOW_NOT_FOUND\",\n\n                    // No template here\n                    TemplateName = null,\n                    TemplateType = null,\n\n                    Success = false,\n                    ErrorMessage = message,\n                    ExecutedAtUtc = DateTime.UtcNow\n                };\n\n                await _flowLogger.LogStepAsync(failCtx, cancellationToken);\n\n                return new CtaFlowRunResult\n                {\n                    Success = false,\n                    ErrorMessage = message\n                };\n            }\n\n            // 2Ô∏è‚É£ Pick the first step (v1 = simple linear flow)\n            var firstStep = flow.Steps\n                .OrderBy(s => s.StepOrder)\n                .FirstOrDefault();\n\n            if (firstStep == null)\n            {\n                var message =\n                    $\"CTA flow {flow.Id} ('{flow.FlowName}') has no steps configured.\";\n\n                _logger.LogWarning(\"[CTAFlowRuntime] {Message}\", message);\n\n                var failCtx = new FlowExecutionContext\n                {\n                    BusinessId = businessId,\n                    FlowId = flow.Id,\n                    AutoReplyFlowId = autoReplyFlowId,\n                    Origin = origin,\n\n                    // NEW: log contact context even on failure\n                    ContactId = contactId,\n                    ContactPhone = contactPhone,\n\n                    StepId = flow.Id,\n                    StepName = \"NO_STEPS\",\n\n                    TemplateName = null,\n                    TemplateType = null,\n\n                    Success = false,\n                    ErrorMessage = message,\n                    ExecutedAtUtc = DateTime.UtcNow\n                };\n\n                await _flowLogger.LogStepAsync(failCtx, cancellationToken);\n\n                return new CtaFlowRunResult\n                {\n                    Success = false,\n                    ErrorMessage = message\n                };\n            }\n\n            _logger.LogInformation(\n                \"[CTAFlowRuntime] Executing first step {StepId} ({Template}) of flow {FlowId} ('{FlowName}')\",\n                firstStep.Id,\n                firstStep.TemplateToSend,\n                flow.Id,\n                flow.FlowName);\n\n            // 3Ô∏è‚É£ Build SimpleTemplateMessageDto with CTA tracking fields\n            var templateDto = new SimpleTemplateMessageDto\n            {\n                RecipientNumber = contactPhone,\n                TemplateName = firstStep.TemplateToSend,\n\n                // v1: no dynamic params here ‚Äì flows can be extended later\n                TemplateParameters = new List<string>(),\n\n                // v1: let MessageEngine choose routing / provider\n                HasStaticButtons = false,\n                Provider = string.Empty,\n                PhoneNumberId = null,\n\n                // üîó Link back to CTA flow config + step\n                CTAFlowConfigId = flow.Id,\n                CTAFlowStepId = firstStep.Id,\n\n                // Optional fields ‚Äì keep null for now\n                TemplateBody = null,\n                LanguageCode = null\n            };\n\n            // 4Ô∏è‚É£ Send the message via MessageEngine (conversational ‚Üí Immediate)\n            var sendResult = await _messageEngine\n                .SendTemplateMessageSimpleAsync(\n                    businessId,\n                    templateDto,\n                    DeliveryMode.Immediate);\n\n            // 5Ô∏è‚É£ Log the step into FlowExecutionLogs\n            var logCtx = new FlowExecutionContext\n            {\n                BusinessId = businessId,\n                FlowId = flow.Id,\n                AutoReplyFlowId = autoReplyFlowId,\n                Origin = origin,\n\n                // Contact context\n                ContactId = contactId,\n                ContactPhone = contactPhone,\n\n                // Step context\n                StepId = firstStep.Id,\n                StepName = firstStep.TemplateToSend,\n\n                // Template metadata for analytics\n                TemplateName = firstStep.TemplateToSend,\n                TemplateType = firstStep.TemplateType ?? \"CTA_FLOW_TEMPLATE\",\n\n                // Result\n                Success = sendResult.Success,\n                ErrorMessage = sendResult.Success ? null : sendResult.Message,\n                ExecutedAtUtc = DateTime.UtcNow\n\n                // MessageLogId, CatalogClickLogId, CampaignId, etc.\n                // can be wired later once message engine returns those ids.\n            };\n\n            await _flowLogger.LogStepAsync(logCtx, cancellationToken);\n\n            return new CtaFlowRunResult\n            {\n                Success = sendResult.Success,\n                ErrorMessage = sendResult.Success ? null : sendResult.Message\n            };\n        }\n    }\n}\n\n\n//// üìÑ xbytechat-api/Features/CTAFlowBuilder/Services/CtaFlowRuntimeService.cs\n//using System;\n//using System.Collections.Generic;\n//using System.Linq;\n//using System.Threading;\n//using System.Threading.Tasks;\n//using Microsoft.EntityFrameworkCore;\n//using Microsoft.Extensions.Logging;\n//using xbytechat.api; // üëà Keep this if AppDbContext is in the root namespace\n//// If AppDbContext lives under xbytechat.api.Data, then use:\n//// using xbytechat.api.Data;\n\n//using xbytechat.api.Features.CTAFlowBuilder.DTOs;\n//using xbytechat.api.Features.CTAFlowBuilder.Models;\n//using xbytechat.api.Features.MessagesEngine.DTOs;\n//using xbytechat.api.Features.MessagesEngine.Services;\n\n//namespace xbytechat.api.Features.CTAFlowBuilder.Services\n//{\n//    /// <summary>\n//    /// Minimal CTA flow runtime engine (v1).\n//    ///\n//    /// Responsibilities:\n//    /// - Load CTAFlowConfig + steps from DB.\n//    /// - Execute the first step (template send) using IMessageEngineService.\n//    /// - Log the execution into FlowExecutionLogs via IFlowExecutionLogger.\n//    ///\n//    /// It uses FlowExecutionOrigin + AutoReplyFlowId / CampaignId so analytics\n//    /// can later separate:\n//    ///   - \"CTA flow started by AutoReply\"\n//    ///   - \"CTA flow started by Campaign button\"\n//    ///   - other origins (JourneyBot, Inbox, System).\n//    /// </summary>\n//    public sealed class CtaFlowRuntimeService : ICtaFlowRuntimeService\n//    {\n//        private readonly AppDbContext _db;\n//        private readonly IMessageEngineService _messageEngine;\n//        private readonly IFlowExecutionLogger _flowLogger;\n//        private readonly ILogger<CtaFlowRuntimeService> _logger;\n\n//        public CtaFlowRuntimeService(\n//            AppDbContext db,\n//            IMessageEngineService messageEngine,\n//            IFlowExecutionLogger flowLogger,\n//            ILogger<CtaFlowRuntimeService> logger)\n//        {\n//            _db = db ?? throw new ArgumentNullException(nameof(db));\n//            _messageEngine = messageEngine ?? throw new ArgumentNullException(nameof(messageEngine));\n//            _flowLogger = flowLogger ?? throw new ArgumentNullException(nameof(flowLogger));\n//            _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n//        }\n\n//        public async Task<CtaFlowRunResult> StartFlowAsync(\n//            Guid businessId,\n//            Guid contactId,\n//            string contactPhone,\n//            Guid configId,\n//            FlowExecutionOrigin origin,\n//            Guid? autoReplyFlowId,\n//            CancellationToken cancellationToken = default)\n//        {\n//            if (businessId == Guid.Empty)\n//                throw new ArgumentException(\"businessId is required\", nameof(businessId));\n//            if (configId == Guid.Empty)\n//                throw new ArgumentException(\"configId is required\", nameof(configId));\n//            if (string.IsNullOrWhiteSpace(contactPhone))\n//                throw new ArgumentException(\"contactPhone is required\", nameof(contactPhone));\n\n//            _logger.LogInformation(\n//                \"üöÄ [CTAFlowRuntime] StartFlowAsync Biz={BusinessId}, Contact={ContactId}, Phone={Phone}, Config={ConfigId}, Origin={Origin}, AutoReplyFlowId={AutoReplyFlowId}\",\n//                businessId,\n//                contactId,\n//                contactPhone,\n//                configId,\n//                origin,\n//                autoReplyFlowId);\n\n//            // 1Ô∏è‚É£ Load the CTA flow (must be active + published) with its steps\n//            var flow = await _db.CTAFlowConfigs\n//                .AsNoTracking()\n//                .Include(f => f.Steps)\n//                .FirstOrDefaultAsync(\n//                    f => f.Id == configId\n//                         && f.BusinessId == businessId\n//                         && f.IsActive\n//                         && f.IsPublished,\n//                    cancellationToken);\n\n//            if (flow == null)\n//            {\n//                var message =\n//                    $\"CTA flow {configId} for business {businessId} not found, inactive, or not published.\";\n\n//                _logger.LogWarning(\"[CTAFlowRuntime] {Message}\", message);\n\n//                // Log a failed \"meta-step\" so analytics can see the failure\n//                var failCtx = new FlowExecutionContext\n//                {\n//                    BusinessId = businessId,\n//                    FlowId = configId,\n//                    AutoReplyFlowId = autoReplyFlowId,\n//                    Origin = origin,\n\n//                    // NEW: log which contact we tried to start for\n//                    ContactId = contactId,\n//                    ContactPhone = contactPhone,\n\n//                    StepId = configId,          // no specific step; use flow id as placeholder\n//                    StepName = \"FLOW_NOT_FOUND\",\n\n//                    // No template here\n//                    TemplateName = null,\n//                    TemplateType = null,\n\n//                    Success = false,\n//                    ErrorMessage = message,\n//                    ExecutedAtUtc = DateTime.UtcNow\n//                };\n\n//                await _flowLogger.LogStepAsync(failCtx, cancellationToken);\n\n//                return new CtaFlowRunResult\n//                {\n//                    Success = false,\n//                    ErrorMessage = message\n//                };\n//            }\n\n//            // 2Ô∏è‚É£ Pick the first step (v1 = simple linear flow)\n//            var firstStep = flow.Steps\n//                .OrderBy(s => s.StepOrder)\n//                .FirstOrDefault();\n\n//            if (firstStep == null)\n//            {\n//                var message =\n//                    $\"CTA flow {flow.Id} ('{flow.FlowName}') has no steps configured.\";\n\n//                _logger.LogWarning(\"[CTAFlowRuntime] {Message}\", message);\n\n//                var failCtx = new FlowExecutionContext\n//                {\n//                    BusinessId = businessId,\n//                    FlowId = flow.Id,\n//                    AutoReplyFlowId = autoReplyFlowId,\n//                    Origin = origin,\n\n//                    // NEW: log contact context even on failure\n//                    ContactId = contactId,\n//                    ContactPhone = contactPhone,\n\n//                    StepId = flow.Id,\n//                    StepName = \"NO_STEPS\",\n\n//                    TemplateName = null,\n//                    TemplateType = null,\n\n//                    Success = false,\n//                    ErrorMessage = message,\n//                    ExecutedAtUtc = DateTime.UtcNow\n//                };\n\n//                await _flowLogger.LogStepAsync(failCtx, cancellationToken);\n\n//                return new CtaFlowRunResult\n//                {\n//                    Success = false,\n//                    ErrorMessage = message\n//                };\n//            }\n\n//            _logger.LogInformation(\n//                \"[CTAFlowRuntime] Executing first step {StepId} ({Template}) of flow {FlowId} ('{FlowName}')\",\n//                firstStep.Id,\n//                firstStep.TemplateToSend,\n//                flow.Id,\n//                flow.FlowName);\n\n//            // 3Ô∏è‚É£ Build SimpleTemplateMessageDto with CTA tracking fields\n//            var templateDto = new SimpleTemplateMessageDto\n//            {\n//                RecipientNumber = contactPhone,\n//                TemplateName = firstStep.TemplateToSend,\n\n//                // v1: no dynamic params here ‚Äì flows can be extended later\n//                TemplateParameters = new List<string>(),\n\n//                // v1: let MessageEngine choose routing / provider\n//                HasStaticButtons = false,\n//                Provider = string.Empty,\n//                PhoneNumberId = null,\n\n//                // üîó Link back to CTA flow config + step\n//                CTAFlowConfigId = flow.Id,\n//                CTAFlowStepId = firstStep.Id,\n\n//                // Optional fields ‚Äì keep null for now\n//                TemplateBody = null,\n//                LanguageCode = null\n//            };\n\n//            // 4Ô∏è‚É£ Send the message via MessageEngine\n//            var sendResult = await _messageEngine\n//                .SendTemplateMessageSimpleAsync(businessId, templateDto);\n\n//            // 5Ô∏è‚É£ Log the step into FlowExecutionLogs\n//            var logCtx = new FlowExecutionContext\n//            {\n//                BusinessId = businessId,\n//                FlowId = flow.Id,\n//                AutoReplyFlowId = autoReplyFlowId,\n//                Origin = origin,\n\n//                // Contact context\n//                ContactId = contactId,\n//                ContactPhone = contactPhone,\n\n//                // Step context\n//                StepId = firstStep.Id,\n//                StepName = firstStep.TemplateToSend,\n\n//                // Template metadata for analytics\n//                TemplateName = firstStep.TemplateToSend,\n//                TemplateType = firstStep.TemplateType ?? \"CTA_FLOW_TEMPLATE\",\n\n//                // Result\n//                Success = sendResult.Success,\n//                ErrorMessage = sendResult.Success ? null : sendResult.Message,\n//                ExecutedAtUtc = DateTime.UtcNow\n\n//                // MessageLogId, CatalogClickLogId, CampaignId, etc.\n//                // can be wired later once message engine returns those ids.\n//            };\n\n//            await _flowLogger.LogStepAsync(logCtx, cancellationToken);\n\n//            return new CtaFlowRunResult\n//            {\n//                Success = sendResult.Success,\n//                ErrorMessage = sendResult.Success ? null : sendResult.Message\n//            };\n//        }\n//    }\n//}\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Services/CTAFlowService.cs",
      "sha256": "02e12f43b542244885559938ed0d53600df3c26ba2554eb1e09890d3eaa77934",
      "language": "csharp",
      "size": 128433,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing System.Text.RegularExpressions;\nusing System.Text.Json;\nusing xbytechat.api.Features.CTAFlowBuilder.DTOs;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.Features.Tracking.Models;\nusing xbytechat.api.Helpers;\nusing xbytechat_api.WhatsAppSettings.Services;\nusing xbytechat.api.WhatsAppSettings.DTOs;\nusing xbytechat.api.Features.CRM.Models;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Services\n{\n    public class CTAFlowService : ICTAFlowService\n    {\n        private readonly AppDbContext _context;\n        private readonly IMessageEngineService _messageEngineService;\n        private readonly IWhatsAppTemplateFetcherService _templateFetcherService;\n\n        public CTAFlowService(\n            AppDbContext context,\n            IMessageEngineService messageEngineService,\n            IWhatsAppTemplateFetcherService templateFetcherService)\n        {\n            _context = context;\n            _messageEngineService = messageEngineService;\n            _templateFetcherService = templateFetcherService;\n        }\n\n        // ---------------------------\n        // CREATE (draft-only, no edit)\n        // ---------------------------\n        public async Task<ResponseResult> SaveVisualFlowAsync(\n            SaveVisualFlowDto dto,\n            Guid businessId,\n            string createdBy)\n        {\n            try\n            {\n                Log.Information(\"üß† SaveVisualFlow (create-only) | FlowName: {FlowName} | Biz: {BusinessId}\",\n                    dto.FlowName, businessId);\n\n                // 0) Validate\n                if (dto.Nodes == null || !dto.Nodes.Any())\n                    return ResponseResult.ErrorInfo(\"‚ùå Cannot save an empty flow. Please add at least one step.\");\n\n                var trimmedName = (dto.FlowName ?? \"\").Trim();\n                if (trimmedName.Length == 0)\n                    return ResponseResult.ErrorInfo(\"‚ùå Flow name is required.\");\n\n                // 1) Enforce unique active name per business (create-only)\n                var nameExists = await _context.CTAFlowConfigs\n                    .AnyAsync(f => f.BusinessId == businessId && f.FlowName == trimmedName && f.IsActive);\n                if (nameExists)\n                {\n                    Log.Warning(\"‚ö†Ô∏è Duplicate flow name '{Name}' for business {Biz}.\", trimmedName, businessId);\n                    return ResponseResult.ErrorInfo(\"‚ùå A flow with this name already exists.\");\n                }\n\n                await using var tx = await _context.Database.BeginTransactionAsync();\n\n                // 2) Insert FlowConfig AS DRAFT (force IsPublished=false)\n                var flow = new CTAFlowConfig\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    FlowName = trimmedName,\n                    CreatedBy = createdBy,\n                    CreatedAt = DateTime.UtcNow,\n                    UpdatedAt = DateTime.UtcNow,\n                    IsActive = true,\n                    IsPublished = false // << always draft on create\n                };\n                _context.CTAFlowConfigs.Add(flow);\n\n                // 3) Steps (map incoming node ids so we can wire links)\n                var stepMap = new Dictionary<string, CTAFlowStep>(StringComparer.OrdinalIgnoreCase);\n                var orderIndex = 0;\n\n                foreach (var node in dto.Nodes)\n                {\n                    if (string.IsNullOrWhiteSpace(node.Id)) continue;\n\n                    var step = new CTAFlowStep\n                    {\n                        Id = Guid.NewGuid(),\n                        CTAFlowConfigId = flow.Id,\n                        StepOrder = orderIndex++,\n                        TemplateToSend = node.TemplateName,\n                        TemplateType = node.TemplateType ?? \"UNKNOWN\",\n                        HeaderMediaUrl = string.IsNullOrWhiteSpace(node.HeaderMediaUrl) ? null : node.HeaderMediaUrl.Trim(),\n                        BodyParamsJson = SerializeBodyParams(node.BodyParams),\n                        UrlButtonParamsJson = SerializeUrlButtonParams(node.UrlButtonParams),\n                        TriggerButtonText = node.TriggerButtonText ?? \"\",\n                        TriggerButtonType = node.TriggerButtonType ?? \"cta\",\n                        PositionX = node.PositionX == 0 ? Random.Shared.Next(100, 600) : node.PositionX,\n                        PositionY = node.PositionY == 0 ? Random.Shared.Next(100, 400) : node.PositionY,\n                        UseProfileName = node.UseProfileName,\n                        ProfileNameSlot = node.ProfileNameSlot,\n                        ButtonLinks = new List<FlowButtonLink>()\n                    };\n\n                    // Only text templates may use profile name slot\n                    var isTextTemplate = string.Equals(step.TemplateType, \"text_template\", StringComparison.OrdinalIgnoreCase);\n                    if (!isTextTemplate)\n                    {\n                        step.UseProfileName = false;\n                        step.ProfileNameSlot = null;\n                    }\n                    else if (!step.UseProfileName)\n                    {\n                        step.ProfileNameSlot = null;\n                    }\n                    else if (!step.ProfileNameSlot.HasValue || step.ProfileNameSlot.Value < 1)\n                    {\n                        step.ProfileNameSlot = 1;\n                    }\n\n                    stepMap[node.Id] = step;\n                    _context.CTAFlowSteps.Add(step);\n                }\n\n                // 4) Wire links per node via edges (SourceHandle == button text)\n                var edges = dto.Edges ?? new List<FlowEdgeDto>();\n\n                foreach (var node in dto.Nodes)\n                {\n                    if (string.IsNullOrWhiteSpace(node.Id) || !stepMap.TryGetValue(node.Id, out var fromStep))\n                        continue;\n\n                    var outEdges = edges\n                        .Where(e => string.Equals(e.FromNodeId, node.Id, StringComparison.OrdinalIgnoreCase))\n                        .ToList();\n\n                    var seenTexts = new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n                    var orderedButtons = (node.Buttons ?? new List<LinkButtonDto>())\n                        .OrderBy(b => b.Index < 0 ? int.MaxValue : b.Index)\n                        .ThenBy(b => b.Text ?? string.Empty)\n                        .ToList();\n\n                    short nextIdx = 0;\n\n                    foreach (var btn in orderedButtons)\n                    {\n                        var text = (btn.Text ?? string.Empty).Trim();\n                        if (string.IsNullOrEmpty(text)) continue;\n                        if (!seenTexts.Add(text)) continue; // dedupe\n\n                        var edge = outEdges.FirstOrDefault(e =>\n                            string.Equals(e.SourceHandle ?? string.Empty, text, StringComparison.OrdinalIgnoreCase));\n                        if (edge == null) continue;\n\n                        if (!stepMap.TryGetValue(edge.ToNodeId, out var toStep)) continue;\n\n                        var finalIndex = btn.Index >= 0 ? btn.Index : nextIdx;\n                        nextIdx = (short)(finalIndex + 1);\n\n                        var link = new FlowButtonLink\n                        {\n                            Id = Guid.NewGuid(),\n                            CTAFlowStepId = fromStep.Id,\n                            NextStepId = toStep.Id,\n                            ButtonText = text,\n                            ButtonType = string.IsNullOrWhiteSpace(btn.Type) ? \"QUICK_REPLY\" : btn.Type,\n                            ButtonSubType = btn.SubType ?? string.Empty,\n                            ButtonValue = btn.Value ?? string.Empty,\n                            ButtonIndex = (short)finalIndex\n                        };\n\n                        _context.FlowButtonLinks.Add(link);\n                        fromStep.ButtonLinks.Add(link);\n\n                        // convenience: populate target's trigger info\n                        toStep.TriggerButtonText = text;\n                        toStep.TriggerButtonType = (btn.Type ?? \"QUICK_REPLY\").ToLowerInvariant();\n                    }\n                }\n\n                await _context.SaveChangesAsync();\n                await tx.CommitAsync();\n\n                Log.Information(\"‚úÖ Flow created '{Flow}' | Steps: {Steps} | Links: {Links}\",\n                    flow.FlowName, stepMap.Count, stepMap.Values.Sum(s => s.ButtonLinks.Count));\n\n                return ResponseResult.SuccessInfo(\"‚úÖ Flow created.\", new { flowId = flow.Id });\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Exception while saving (create) flow\");\n                return ResponseResult.ErrorInfo(\"‚ùå Internal error while saving flow.\");\n            }\n        }\n\n        // ---------------------------\n        // LISTS\n        // ---------------------------\n        public async Task<List<VisualFlowSummaryDto>> GetAllPublishedFlowsAsync(Guid businessId)\n        {\n            return await _context.CTAFlowConfigs\n                .Where(f => f.BusinessId == businessId && f.IsPublished)\n                .OrderByDescending(f => f.CreatedAt)\n                .Select(f => new VisualFlowSummaryDto\n                {\n                    Id = f.Id,\n                    FlowName = f.FlowName,\n                    IsPublished = f.IsPublished,\n                    CreatedAt = f.CreatedAt\n                })\n                .ToListAsync();\n        }\n\n        public async Task<List<VisualFlowSummaryDto>> GetAllDraftFlowsAsync(Guid businessId)\n        {\n            return await _context.CTAFlowConfigs\n                .Where(f => f.BusinessId == businessId && !f.IsPublished && f.IsActive)\n                .OrderByDescending(f => f.CreatedAt)\n                .Select(f => new VisualFlowSummaryDto\n                {\n                    Id = f.Id,\n                    FlowName = f.FlowName,\n                    CreatedAt = f.CreatedAt,\n                    IsPublished = f.IsPublished\n                })\n                .ToListAsync();\n        }\n\n        // ---------------------------\n        // DETAIL LOADERS\n        // ---------------------------\n        public async Task<SaveVisualFlowDto?> GetVisualFlowByIdAsync(Guid flowId, Guid businessId)\n        {\n            var flow = await _context.CTAFlowConfigs\n                .Include(c => c.Steps)\n                    .ThenInclude(s => s.ButtonLinks)\n                .FirstOrDefaultAsync(c => c.Id == flowId && c.BusinessId == businessId && c.IsActive);\n\n            if (flow == null) return null;\n\n            // Prefetch template metadata\n            var templateMap = new Dictionary<string, TemplateMetadataDto>(StringComparer.OrdinalIgnoreCase);\n            var uniqueNames = flow.Steps\n                .Select(s => s.TemplateToSend)\n                .Where(n => !string.IsNullOrWhiteSpace(n))\n                .Distinct(StringComparer.OrdinalIgnoreCase)\n                .ToList();\n\n            foreach (var name in uniqueNames)\n            {\n                try\n                {\n                    var tpl = await _templateFetcherService.GetTemplateByNameAsync(\n                        businessId, name!, includeButtons: true);\n                    if (tpl != null) templateMap[name!] = tpl;\n                }\n                catch (Exception ex)\n                {\n                    Log.Warning(ex, \"‚ö†Ô∏è Failed to fetch template metadata for {Template}\", name);\n                }\n            }\n\n                var nodes = flow.Steps.Select(step =>\n                {\n                    templateMap.TryGetValue(step.TemplateToSend ?? \"\", out var tpl);\n\n                var dbLinks = step.ButtonLinks ?? new List<FlowButtonLink>();\n                var linkByIndex = dbLinks.ToDictionary(l => (int)l.ButtonIndex, l => l);\n\n                // Canonical button list (max 3) in index order. This is important for dynamic URL button params,\n                // which are indexed by button position (\"0\",\"1\",\"2\") in Meta payloads.\n                // For linked buttons, preserve stored ButtonText so ReactFlow edges rehydrate (SourceHandle matches).\n                var buttons = (tpl?.ButtonParams ?? new List<ButtonMetadataDto>())\n                    .OrderBy(b => b.Index)\n                    .Take(3)\n                    .Select(btn =>\n                    {\n                        var idx = btn.Index;\n                        if (idx < 0 || idx > 2) return null;\n\n                        if (linkByIndex.TryGetValue(idx, out var link))\n                        {\n                            return new LinkButtonDto\n                            {\n                                Text = link.ButtonText,\n                                Type = link.ButtonType,\n                                SubType = link.ButtonSubType,\n                                Value = link.ButtonValue,\n                                Index = link.ButtonIndex,\n                                TargetNodeId = link.NextStepId?.ToString()\n                            };\n                        }\n\n                        return new LinkButtonDto\n                        {\n                            Text = btn.Text,\n                            Type = btn.Type,\n                            SubType = btn.SubType,\n                            Value = btn.ParameterValue,\n                            Index = idx,\n                            TargetNodeId = null\n                        };\n                    })\n                    .Where(x => x != null)\n                    .Select(x => x!)\n                    .ToList();\n\n                return new FlowNodeDto\n                {\n                    Id = step.Id.ToString(),\n                    TemplateName = step.TemplateToSend,\n                    TemplateType = step.TemplateType,\n                    HeaderMediaUrl = step.HeaderMediaUrl,\n                    BodyParams = TryParseBodyParams(step.BodyParamsJson),\n                    UrlButtonParams = TryParseUrlButtonParams(step.UrlButtonParamsJson),\n                    MessageBody = string.IsNullOrWhiteSpace(tpl?.Body) ? \"‚Äî no body found ‚Äî\" : tpl!.Body,\n                    TriggerButtonText = step.TriggerButtonText,\n                    TriggerButtonType = step.TriggerButtonType,\n                    PositionX = step.PositionX ?? 100,\n                    PositionY = step.PositionY ?? 100,\n                    RequiredTag = step.RequiredTag,\n                    RequiredSource = step.RequiredSource,\n                    UseProfileName = step.UseProfileName,\n                    ProfileNameSlot = step.ProfileNameSlot,\n                    Buttons = buttons\n                };\n            }).ToList();\n\n            var edges = flow.Steps\n                .SelectMany(step =>\n                    (step.ButtonLinks ?? Enumerable.Empty<FlowButtonLink>())\n                    .Where(l => l.NextStepId.HasValue)\n                    .Select(l => new FlowEdgeDto\n                    {\n                        FromNodeId = step.Id.ToString(),\n                        ToNodeId = l.NextStepId!.Value.ToString(),\n                        SourceHandle = l.ButtonText\n                    }))\n                .ToList();\n\n            return new SaveVisualFlowDto\n            {\n                FlowName = flow.FlowName,\n                IsPublished = flow.IsPublished,\n                Nodes = nodes,\n                Edges = edges\n            };\n        }\n\n        public async Task<ResponseResult> GetVisualFlowAsync(Guid flowId, Guid businessId)\n        {\n            try\n            {\n                var flow = await _context.CTAFlowConfigs\n                    .AsNoTracking()\n                    .Where(f => f.IsActive && f.BusinessId == businessId && f.Id == flowId)\n                    .Select(f => new\n                    {\n                        f.Id,\n                        f.FlowName,\n                        f.IsPublished,\n                        Steps = _context.CTAFlowSteps\n                            .Where(s => s.CTAFlowConfigId == f.Id)\n                            .OrderBy(s => s.StepOrder)\n                            .Select(s => new\n                            {\n                                s.Id,\n                                s.StepOrder,\n                                s.TemplateToSend,\n                                s.TemplateType,\n                                s.HeaderMediaUrl,\n                                s.BodyParamsJson,\n                                s.UrlButtonParamsJson,\n                                s.TriggerButtonText,\n                                s.TriggerButtonType,\n                                s.PositionX,\n                                s.PositionY,\n                                s.UseProfileName,\n                                s.ProfileNameSlot,\n                                Buttons = _context.FlowButtonLinks\n                                    .Where(b => b.CTAFlowStepId == s.Id)\n                                    .OrderBy(b => b.ButtonIndex)\n                                    .Select(b => new\n                                    {\n                                        b.ButtonText,\n                                        b.ButtonType,\n                                        b.ButtonSubType,\n                                        b.ButtonValue,\n                                        b.ButtonIndex,\n                                        b.NextStepId\n                                    })\n                                    .ToList()\n                            })\n                            .ToList()\n                    })\n                    .FirstOrDefaultAsync();\n\n                if (flow == null)\n                    return ResponseResult.ErrorInfo(\"Flow not found.\");\n\n                var nodes = flow.Steps.Select(s => new\n                {\n                    id = s.Id.ToString(),\n                    positionX = s.PositionX ?? 0,\n                    positionY = s.PositionY ?? 0,\n                    templateName = s.TemplateToSend,\n                    templateType = s.TemplateType,\n                    headerMediaUrl = s.HeaderMediaUrl,\n                    bodyParams = TryParseBodyParams(s.BodyParamsJson),\n                    urlButtonParams = TryParseUrlButtonParams(s.UrlButtonParamsJson),\n                    triggerButtonText = s.TriggerButtonText ?? string.Empty,\n                    triggerButtonType = s.TriggerButtonType ?? \"cta\",\n                    requiredTag = string.Empty,\n                    requiredSource = string.Empty,\n                    useProfileName = s.UseProfileName,\n                    profileNameSlot = (s.ProfileNameSlot.HasValue && s.ProfileNameSlot.Value > 0) ? s.ProfileNameSlot.Value : 1,\n                    buttons = s.Buttons.Select(b => new\n                    {\n                        text = b.ButtonText,\n                        type = b.ButtonType,\n                        subType = b.ButtonSubType,\n                        value = b.ButtonValue,\n                        targetNodeId = b.NextStepId == Guid.Empty ? null : b.NextStepId.ToString(),\n                        index = (int)(b.ButtonIndex)\n                    })\n                });\n\n                var edges = flow.Steps\n                    .SelectMany(s => s.Buttons\n                        .Where(b => b.NextStepId != Guid.Empty)\n                        .Select(b => new\n                        {\n                            fromNodeId = s.Id.ToString(),\n                            toNodeId = b.NextStepId.ToString(),\n                            sourceHandle = b.ButtonText\n                        }));\n\n                var payload = new\n                {\n                    flowName = flow.FlowName,\n                    isPublished = flow.IsPublished,\n                    nodes,\n                    edges\n                };\n\n                return ResponseResult.SuccessInfo(\"Flow loaded.\", payload);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Exception while loading visual flow {FlowId}\", flowId);\n                return ResponseResult.ErrorInfo(\"Internal error while loading flow.\");\n            }\n        }\n\n        private static string? SerializeBodyParams(List<string>? bodyParams)\n        {\n            if (bodyParams == null || bodyParams.Count == 0) return null;\n\n            // Persist trimmed values; keep empty strings (runtime/publish validation decides if that's allowed).\n            var cleaned = bodyParams.Select(x => (x ?? string.Empty).Trim()).ToList();\n            return JsonSerializer.Serialize(cleaned);\n        }\n\n        private static List<string> TryParseBodyParams(string? json)\n        {\n            if (string.IsNullOrWhiteSpace(json)) return new List<string>();\n            try\n            {\n                var list = JsonSerializer.Deserialize<List<string>>(json);\n                return list ?? new List<string>();\n            }\n            catch\n            {\n                // Keep flow load resilient even if older rows contain malformed data.\n                return new List<string>();\n            }\n        }\n\n        private static string? SerializeUrlButtonParams(List<string>? urlButtonParams)\n        {\n            if (urlButtonParams == null || urlButtonParams.Count == 0) return null;\n\n            // Meta supports up to 3 buttons. Persist trimmed values; keep empty strings (validation decides if that's allowed).\n            var cleaned = urlButtonParams\n                .Take(3)\n                .Select(x => (x ?? string.Empty).Trim())\n                .ToList();\n\n            return JsonSerializer.Serialize(cleaned);\n        }\n\n        private static List<string> TryParseUrlButtonParams(string? json)\n        {\n            if (string.IsNullOrWhiteSpace(json)) return new List<string>();\n            try\n            {\n                var list = JsonSerializer.Deserialize<List<string>>(json);\n                return list ?? new List<string>();\n            }\n            catch\n            {\n                return new List<string>();\n            }\n        }\n\n        // ---------------------------\n        // DELETE (only if not attached)\n        // ---------------------------\n        public async Task<ResponseResult> DeleteFlowAsync(Guid flowId, Guid businessId, string deletedBy)\n        {\n            var flow = await _context.CTAFlowConfigs\n                .Include(f => f.Steps)\n                    .ThenInclude(s => s.ButtonLinks)\n                .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId);\n\n            if (flow == null)\n                return ResponseResult.ErrorInfo(\"‚ùå Flow not found or does not belong to you.\");\n\n            var inUseQuery = _context.Campaigns\n                .Where(c => c.BusinessId == businessId &&\n                            !c.IsDeleted &&\n                            c.CTAFlowConfigId == flowId);\n\n            var inUseCount = await inUseQuery.CountAsync();\n            if (inUseCount > 0)\n            {\n                Log.Warning(\"‚ùå Delete flow blocked. Flow {FlowId} is used by {Count} campaigns.\", flowId, inUseCount);\n                // Keep message; controller will fetch campaigns for modal\n                return ResponseResult.ErrorInfo(\n                    $\"‚ùå Cannot delete. This flow is attached to {inUseCount} campaign(s). Delete those campaigns first.\");\n            }\n\n            foreach (var step in flow.Steps)\n                _context.FlowButtonLinks.RemoveRange(step.ButtonLinks);\n\n            _context.CTAFlowSteps.RemoveRange(flow.Steps);\n            _context.CTAFlowConfigs.Remove(flow);\n\n            await _context.SaveChangesAsync();\n            return ResponseResult.SuccessInfo(\"‚úÖ Flow deleted.\");\n        }\n\n        public async Task<IReadOnlyList<AttachedCampaignDto>> GetAttachedCampaignsAsync(Guid flowId, Guid businessId)\n        {\n            var q = _context.Campaigns\n                .Where(c => c.BusinessId == businessId && !c.IsDeleted && c.CTAFlowConfigId == flowId);\n\n            var firstSends = await _context.CampaignSendLogs\n                .Where(s => s.BusinessId == businessId && s.CampaignId != Guid.Empty)\n                .GroupBy(s => s.CampaignId)\n                .Select(g => new { CampaignId = g.Key, FirstSentAt = (DateTime?)g.Min(s => s.CreatedAt) })\n                .ToListAsync();\n\n            var firstSendMap = firstSends.ToDictionary(x => x.CampaignId, x => x.FirstSentAt);\n\n            var list = await q\n                .OrderByDescending(c => c.CreatedAt)\n                .Select(c => new\n                {\n                    c.Id,\n                    c.Name,\n                    c.Status,\n                    c.ScheduledAt,\n                    c.CreatedAt,\n                    c.CreatedBy\n                })\n                .ToListAsync();\n\n            return list.Select(x => new AttachedCampaignDto(\n                x.Id,\n                x.Name,\n                x.Status,\n                x.ScheduledAt,\n                x.CreatedAt,\n                x.CreatedBy,\n                firstSendMap.TryGetValue(x.Id, out var ts) ? ts : null\n            )).ToList();\n        }\n\n        public async Task<bool> HardDeleteFlowIfUnusedAsync(Guid flowId, Guid businessId)\n        {\n            var flow = await _context.CTAFlowConfigs\n                .Include(f => f.Steps)\n                    .ThenInclude(s => s.ButtonLinks)\n                .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId);\n\n            if (flow is null) return false;\n\n            var attached = await _context.Campaigns\n                .Where(c => c.BusinessId == businessId && !c.IsDeleted && c.CTAFlowConfigId == flowId)\n                .AnyAsync();\n            if (attached) return false;\n\n            foreach (var step in flow.Steps)\n                _context.FlowButtonLinks.RemoveRange(step.ButtonLinks);\n            _context.CTAFlowSteps.RemoveRange(flow.Steps);\n            _context.CTAFlowConfigs.Remove(flow);\n\n            await _context.SaveChangesAsync();\n            return true;\n        }\n\n        // ---------------------------\n        // PUBLISH (by id, flip flag)\n        // ---------------------------\n        public async Task<ResponseResult> PublishFlowAsync(Guid flowId, Guid businessId, string user)\n        {\n            var flow = await _context.CTAFlowConfigs\n                .Include(f => f.Steps)\n                .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId && f.IsActive);\n\n            if (flow is null) return ResponseResult.NotFound(\"‚ùå Flow not found.\");\n\n            // Server-side guardrails: publishing must be safe even if UI validation is bypassed.\n            // Validate required media header URL, body placeholder params, and dynamic URL button params.\n            var issues = await ValidateFlowForPublishAsync(flow, businessId);\n            if (issues.Count > 0)\n            {\n                Log.Warning(\n                    \"‚ùå CTAFlow publish blocked: validation failed biz={Biz} flow={Flow} issues={Count} first='{First}'\",\n                    businessId, flowId, issues.Count, issues[0]);\n\n                return ResponseResult.BadRequest(\n                    \"‚ùå Publish blocked: fix configuration issues in one or more steps.\",\n                    payload: issues);\n            }\n\n            flow.IsPublished = true;\n            flow.UpdatedAt = DateTime.UtcNow;\n            await _context.SaveChangesAsync();\n            return ResponseResult.Ok(\"‚úÖ Flow published.\");\n        }\n\n        // ----- Publish-time validation helpers (best-effort; must not throw) -----\n        private static readonly Regex PositionalToken =\n            new(@\"\\{\\{\\s*\\d+\\s*\\}\\}\", RegexOptions.Compiled); // {{1}}, {{ 2 }}, etc.\n\n        private static readonly Regex NamedToken =\n            new(@\"\\{\\{\\s*\\}\\}\", RegexOptions.Compiled);        // {{}} (NAMED format slot)\n\n        private static int CountBodyTokensFlexible(string? text)\n        {\n            if (string.IsNullOrEmpty(text)) return 0;\n            return PositionalToken.Matches(text).Count + NamedToken.Matches(text).Count;\n        }\n\n        private static bool IsValidHttpsUrl(string? input)\n        {\n            if (string.IsNullOrWhiteSpace(input)) return false;\n            if (!Uri.TryCreate(input.Trim(), UriKind.Absolute, out var u)) return false;\n            return string.Equals(u.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase);\n        }\n\n        private async Task<List<string>> ValidateFlowForPublishAsync(CTAFlowConfig flow, Guid businessId)\n        {\n            var issues = new List<string>();\n\n            try\n            {\n                var steps = (flow.Steps ?? new List<CTAFlowStep>())\n                    .OrderBy(s => s.StepOrder)\n                    .ToList();\n\n                if (steps.Count == 0)\n                {\n                    issues.Add(\"Flow has no steps.\");\n                    return issues;\n                }\n\n                var templateNames = steps\n                    .Select(s => (s.TemplateToSend ?? string.Empty).Trim())\n                    .Where(s => !string.IsNullOrWhiteSpace(s))\n                    .Distinct(StringComparer.OrdinalIgnoreCase)\n                    .ToList();\n\n                // Load template meta (buttons, header kind, body text) once per template.\n                var metaMap = new Dictionary<string, TemplateMetadataDto>(StringComparer.OrdinalIgnoreCase);\n                foreach (var name in templateNames)\n                {\n                    try\n                    {\n                        var meta = await _templateFetcherService.GetTemplateByNameAsync(\n                            businessId, name, includeButtons: true);\n                        if (meta != null) metaMap[name] = meta;\n                    }\n                    catch (Exception ex)\n                    {\n                        Log.Warning(ex, \"‚ö†Ô∏è CTAFlow publish validation: failed to fetch meta for {Template}\", name);\n                    }\n                }\n\n                // Canonical body var counts (buttons are separate). If missing, fall back to token counting.\n                var bodyCounts = await _context.WhatsAppTemplates\n                    .AsNoTracking()\n                    .Where(t => t.BusinessId == businessId && t.IsActive && templateNames.Contains(t.Name))\n                    .GroupBy(t => t.Name)\n                    .Select(g => new { Name = g.Key, BodyVarCount = g.Max(x => x.BodyVarCount) })\n                    .ToListAsync();\n\n                var bodyCountMap = bodyCounts.ToDictionary(x => x.Name, x => x.BodyVarCount, StringComparer.OrdinalIgnoreCase);\n\n                foreach (var step in steps)\n                {\n                    var stepLabel = $\"Step {step.StepOrder + 1}\";\n                    var templateName = (step.TemplateToSend ?? string.Empty).Trim();\n\n                    if (string.IsNullOrWhiteSpace(templateName))\n                    {\n                        issues.Add($\"{stepLabel}: missing template.\");\n                        continue;\n                    }\n\n                    if (!metaMap.TryGetValue(templateName, out var meta) || meta == null)\n                    {\n                        issues.Add($\"{stepLabel} ({templateName}): template not found/approved for this business.\");\n                        continue;\n                    }\n\n                    // Header media URL required for image/video/document templates\n                    var headerKind = (meta.HeaderKind ?? \"none\").Trim().ToLowerInvariant();\n                    var requiresMediaHeader = headerKind is \"image\" or \"video\" or \"document\";\n                    if (requiresMediaHeader && !IsValidHttpsUrl(step.HeaderMediaUrl))\n                    {\n                        issues.Add($\"{stepLabel} ({templateName}): header media URL required (https) for {headerKind} template.\");\n                    }\n\n                    // Body placeholder params\n                    var bodyVarCount = 0;\n                    if (bodyCountMap.TryGetValue(templateName, out var c) && c > 0) bodyVarCount = c;\n                    else bodyVarCount = CountBodyTokensFlexible(meta.Body);\n\n                    if (bodyVarCount > 0)\n                    {\n                        var args = TryParseBodyParams(step.BodyParamsJson);\n                        var slot = step.UseProfileName ? (step.ProfileNameSlot ?? 0) : 0;\n\n                        for (var i = 1; i <= bodyVarCount; i++)\n                        {\n                            if (slot == i) continue; // profile name slot is runtime-filled\n\n                            var v = (i - 1) < args.Count ? args[i - 1] : null;\n                            if (string.IsNullOrWhiteSpace(v))\n                            {\n                                issues.Add($\"{stepLabel} ({templateName}): missing body value for {{{{{i}}}}}.\");\n                                break;\n                            }\n                        }\n                    }\n\n                    // Dynamic URL button params\n                    if (meta.ButtonParams is { Count: > 0 })\n                    {\n                        var stored = TryParseUrlButtonParams(step.UrlButtonParamsJson);\n                        var buttons = meta.ButtonParams\n                            .OrderBy(b => b.Index)\n                            .Take(3)\n                            .ToList();\n\n                        foreach (var b in buttons)\n                        {\n                            var idx = b.Index;\n                            if (idx < 0 || idx > 2) continue;\n\n                            var isUrl =\n                                string.Equals(b.Type, \"URL\", StringComparison.OrdinalIgnoreCase) ||\n                                string.Equals(b.SubType, \"url\", StringComparison.OrdinalIgnoreCase);\n                            if (!isUrl) continue;\n\n                            var mask = (b.ParameterValue ?? string.Empty).Trim();\n                            var isDynamic = mask.Contains(\"{{\", StringComparison.Ordinal);\n                            if (!isDynamic) continue;\n\n                            var value = (idx < stored.Count ? stored[idx] : null) ?? string.Empty;\n                            if (string.IsNullOrWhiteSpace(value))\n                            {\n                                var bt = string.IsNullOrWhiteSpace(b.Text) ? $\"button {idx + 1}\" : $\"'{b.Text}'\";\n                                issues.Add($\"{stepLabel} ({templateName}): missing dynamic URL param for {bt}.\");\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            catch (Exception ex)\n            {\n                // Never block publish due to validation code crashing; instead, allow publish and log loudly.\n                // (Runtime still has hard checks + FlowExecutionLogs failures.)\n                Log.Error(ex, \"‚ùå CTAFlow publish validation crashed; allowing publish as fallback biz={Biz} flow={Flow}\", businessId, flow.Id);\n                issues.Clear();\n            }\n\n            return issues;\n        }\n\n        // ---------------------------\n        // UPDATE (save as draft by id)\n        // ---------------------------\n        public async Task<FlowUpdateResult> UpdateVisualFlowAsync(\n            Guid flowId,\n            SaveVisualFlowDto dto,\n            Guid businessId,\n            string user)\n        {\n            try\n            {\n                if (dto.Nodes == null || !dto.Nodes.Any())\n                    return new FlowUpdateResult { Status = \"error\", Message = \"‚ùå Cannot save an empty flow. Please add at least one step.\" };\n\n                var trimmedName = (dto.FlowName ?? string.Empty).Trim();\n                if (trimmedName.Length == 0)\n                    return new FlowUpdateResult { Status = \"error\", Message = \"‚ùå Flow name is required.\" };\n\n                var flow = await _context.CTAFlowConfigs\n                    .Include(f => f.Steps)\n                        .ThenInclude(s => s.ButtonLinks)\n                    .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId && f.IsActive);\n\n                if (flow == null)\n                    return new FlowUpdateResult { Status = \"notFound\", Message = \"‚ùå Flow not found.\" };\n\n                // If a live/published flow is attached, force fork to avoid changing active campaigns.\n                if (flow.IsPublished)\n                {\n                    var attachedCount = await _context.Campaigns\n                        .Where(c => c.BusinessId == businessId && !c.IsDeleted && c.CTAFlowConfigId == flowId)\n                        .CountAsync();\n\n                    if (attachedCount > 0)\n                    {\n                        var campaigns = await GetAttachedCampaignsAsync(flowId, businessId);\n                        return new FlowUpdateResult\n                        {\n                            Status = \"requiresFork\",\n                            Message = \"‚ùå This published flow is attached to campaign(s). Create a new draft version to edit.\",\n                            Campaigns = campaigns\n                        };\n                    }\n                }\n\n                // Enforce unique active name per business (excluding current flow)\n                var nameExists = await _context.CTAFlowConfigs\n                    .AnyAsync(f => f.BusinessId == businessId &&\n                                   f.IsActive &&\n                                   f.FlowName == trimmedName &&\n                                   f.Id != flowId);\n\n                if (nameExists)\n                    return new FlowUpdateResult { Status = \"error\", Message = \"‚ùå A flow with this name already exists.\" };\n\n                var needsRepublish = flow.IsPublished;\n\n                await using var tx = await _context.Database.BeginTransactionAsync();\n\n                // Update config and flip to draft on any edit\n                flow.FlowName = trimmedName;\n                flow.IsPublished = false;\n                flow.UpdatedAt = DateTime.UtcNow;\n\n                // Remove existing steps + links (we re-materialize from the visual payload)\n                foreach (var s in flow.Steps)\n                    _context.FlowButtonLinks.RemoveRange(s.ButtonLinks);\n\n                _context.CTAFlowSteps.RemoveRange(flow.Steps);\n                await _context.SaveChangesAsync();\n\n                // Recreate steps from nodes (preserve ids when possible)\n                var stepMap = new Dictionary<string, CTAFlowStep>(StringComparer.OrdinalIgnoreCase);\n                var orderIndex = 0;\n\n                foreach (var node in dto.Nodes)\n                {\n                    if (string.IsNullOrWhiteSpace(node.Id)) continue;\n\n                    var stepId = Guid.TryParse(node.Id, out var gid) ? gid : Guid.NewGuid();\n\n                    var step = new CTAFlowStep\n                    {\n                        Id = stepId,\n                        CTAFlowConfigId = flow.Id,\n                        StepOrder = orderIndex++,\n                        TemplateToSend = node.TemplateName,\n                        TemplateType = node.TemplateType ?? \"UNKNOWN\",\n                        HeaderMediaUrl = string.IsNullOrWhiteSpace(node.HeaderMediaUrl) ? null : node.HeaderMediaUrl.Trim(),\n                        BodyParamsJson = SerializeBodyParams(node.BodyParams),\n                        UrlButtonParamsJson = SerializeUrlButtonParams(node.UrlButtonParams),\n                        TriggerButtonText = node.TriggerButtonText ?? \"\",\n                        TriggerButtonType = node.TriggerButtonType ?? \"cta\",\n                        PositionX = node.PositionX == 0 ? Random.Shared.Next(100, 600) : node.PositionX,\n                        PositionY = node.PositionY == 0 ? Random.Shared.Next(100, 400) : node.PositionY,\n                        UseProfileName = node.UseProfileName,\n                        ProfileNameSlot = node.ProfileNameSlot,\n                        ButtonLinks = new List<FlowButtonLink>()\n                    };\n\n                    // Only text templates may use profile name slot\n                    var isTextTemplate = string.Equals(step.TemplateType, \"text_template\", StringComparison.OrdinalIgnoreCase);\n                    if (!isTextTemplate)\n                    {\n                        step.UseProfileName = false;\n                        step.ProfileNameSlot = null;\n                    }\n                    else if (!step.UseProfileName)\n                    {\n                        step.ProfileNameSlot = null;\n                    }\n                    else if (!step.ProfileNameSlot.HasValue || step.ProfileNameSlot.Value < 1)\n                    {\n                        step.ProfileNameSlot = 1;\n                    }\n\n                    stepMap[node.Id] = step;\n                    _context.CTAFlowSteps.Add(step);\n                }\n\n                // Wire links per node via edges (SourceHandle == button text)\n                var edges = dto.Edges ?? new List<FlowEdgeDto>();\n\n                foreach (var node in dto.Nodes)\n                {\n                    if (string.IsNullOrWhiteSpace(node.Id) || !stepMap.TryGetValue(node.Id, out var fromStep))\n                        continue;\n\n                    var outEdges = edges\n                        .Where(e => string.Equals(e.FromNodeId, node.Id, StringComparison.OrdinalIgnoreCase))\n                        .ToList();\n\n                    var seenTexts = new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n                    var orderedButtons = (node.Buttons ?? new List<LinkButtonDto>())\n                        .OrderBy(b => b.Index < 0 ? int.MaxValue : b.Index)\n                        .ThenBy(b => b.Text ?? string.Empty)\n                        .ToList();\n\n                    short nextIdx = 0;\n\n                    foreach (var btn in orderedButtons)\n                    {\n                        var text = (btn.Text ?? string.Empty).Trim();\n                        if (string.IsNullOrEmpty(text)) continue;\n                        if (!seenTexts.Add(text)) continue; // dedupe\n\n                        var edge = outEdges.FirstOrDefault(e =>\n                            string.Equals(e.SourceHandle ?? string.Empty, text, StringComparison.OrdinalIgnoreCase));\n                        if (edge == null) continue;\n\n                        if (!stepMap.TryGetValue(edge.ToNodeId, out var toStep)) continue;\n\n                        var finalIndex = btn.Index >= 0 ? btn.Index : nextIdx;\n                        nextIdx = (short)(finalIndex + 1);\n\n                        var link = new FlowButtonLink\n                        {\n                            Id = Guid.NewGuid(),\n                            CTAFlowStepId = fromStep.Id,\n                            NextStepId = toStep.Id,\n                            ButtonText = text,\n                            ButtonType = string.IsNullOrWhiteSpace(btn.Type) ? \"QUICK_REPLY\" : btn.Type,\n                            ButtonSubType = btn.SubType ?? string.Empty,\n                            ButtonValue = btn.Value ?? string.Empty,\n                            ButtonIndex = (short)finalIndex\n                        };\n\n                        _context.FlowButtonLinks.Add(link);\n                        fromStep.ButtonLinks.Add(link);\n\n                        // convenience: populate target's trigger info\n                        toStep.TriggerButtonText = text;\n                        toStep.TriggerButtonType = (btn.Type ?? \"QUICK_REPLY\").ToLowerInvariant();\n                    }\n                }\n\n                await _context.SaveChangesAsync();\n                await tx.CommitAsync();\n\n                return new FlowUpdateResult\n                {\n                    Status = \"ok\",\n                    NeedsRepublish = needsRepublish,\n                    Message = \"‚úÖ Flow updated (draft).\"\n                };\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Exception while updating visual flow {FlowId}\", flowId);\n                return new FlowUpdateResult { Status = \"error\", Message = \"‚ùå Internal error while updating flow.\" };\n            }\n        }\n\n        // ---------------------------\n        // FORK (create new draft copy)\n        // ---------------------------\n        public async Task<Guid> ForkFlowAsync(Guid flowId, Guid businessId, string user)\n        {\n            try\n            {\n                var src = await _context.CTAFlowConfigs\n                    .Include(f => f.Steps)\n                        .ThenInclude(s => s.ButtonLinks)\n                    .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId && f.IsActive);\n\n                if (src == null) return Guid.Empty;\n\n                // Ensure unique name (unique index on BusinessId+FlowName+IsActive)\n                var baseName = $\"{src.FlowName} (Copy)\";\n                var candidate = baseName;\n                var n = 2;\n                while (await _context.CTAFlowConfigs.AnyAsync(f =>\n                           f.BusinessId == businessId && f.IsActive && f.FlowName == candidate))\n                {\n                    candidate = $\"{baseName} {n++}\";\n                }\n\n                await using var tx = await _context.Database.BeginTransactionAsync();\n\n                var dst = new CTAFlowConfig\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    FlowName = candidate,\n                    CreatedBy = user,\n                    CreatedAt = DateTime.UtcNow,\n                    UpdatedAt = DateTime.UtcNow,\n                    IsActive = true,\n                    IsPublished = false\n                };\n                _context.CTAFlowConfigs.Add(dst);\n\n                var stepIdMap = new Dictionary<Guid, Guid>();\n                foreach (var s in src.Steps.OrderBy(x => x.StepOrder))\n                    stepIdMap[s.Id] = Guid.NewGuid();\n\n                var newSteps = src.Steps.OrderBy(x => x.StepOrder).Select(s => new CTAFlowStep\n                {\n                    Id = stepIdMap[s.Id],\n                    CTAFlowConfigId = dst.Id,\n                    StepOrder = s.StepOrder,\n                    TemplateToSend = s.TemplateToSend,\n                    TemplateType = s.TemplateType,\n                    HeaderMediaUrl = s.HeaderMediaUrl,\n                    BodyParamsJson = s.BodyParamsJson,\n                    UrlButtonParamsJson = s.UrlButtonParamsJson,\n                    TriggerButtonText = s.TriggerButtonText,\n                    TriggerButtonType = s.TriggerButtonType,\n                    RequiredTag = s.RequiredTag,\n                    RequiredSource = s.RequiredSource,\n                    PositionX = s.PositionX,\n                    PositionY = s.PositionY,\n                    UseProfileName = s.UseProfileName,\n                    ProfileNameSlot = s.ProfileNameSlot\n                }).ToList();\n\n                _context.CTAFlowSteps.AddRange(newSteps);\n\n                foreach (var srcStep in src.Steps)\n                {\n                    foreach (var b in srcStep.ButtonLinks)\n                    {\n                        var newLink = new FlowButtonLink\n                        {\n                            Id = Guid.NewGuid(),\n                            CTAFlowStepId = stepIdMap[srcStep.Id],\n                            NextStepId = (b.NextStepId.HasValue && stepIdMap.TryGetValue(b.NextStepId.Value, out var mapped))\n                                ? mapped\n                                : (Guid?)null,\n                            ButtonText = b.ButtonText,\n                            ButtonType = b.ButtonType,\n                            ButtonSubType = b.ButtonSubType,\n                            ButtonValue = b.ButtonValue,\n                            ButtonIndex = b.ButtonIndex\n                        };\n                        _context.FlowButtonLinks.Add(newLink);\n                    }\n                }\n\n                await _context.SaveChangesAsync();\n                await tx.CommitAsync();\n\n                return dst.Id;\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Exception while forking flow {FlowId}\", flowId);\n                return Guid.Empty;\n            }\n        }\n\n        // ---------------------------\n        // RUNTIME / Matching / Execute\n        // ---------------------------\n        public async Task<CTAFlowStep?> MatchStepByButtonAsync(\n            Guid businessId,\n            string buttonText,\n            string buttonType,\n            string templateName,\n            Guid? campaignId = null)\n        {\n            var normalizedButtonText = buttonText?.Trim().ToLower() ?? \"\";\n            var normalizedButtonType = buttonType?.Trim().ToLower() ?? \"\";\n            var normalizedTemplateName = templateName?.Trim().ToLower() ?? \"\";\n\n            if (campaignId.HasValue)\n            {\n                var overrideStep = await _context.CampaignFlowOverrides\n                    .Where(o =>\n                        o.CampaignId == campaignId &&\n                        o.ButtonText.ToLower() == normalizedButtonText &&\n                        o.TemplateName.ToLower() == normalizedTemplateName)\n                    .FirstOrDefaultAsync();\n\n                if (overrideStep != null)\n                {\n                    var overrideTemplate = overrideStep.OverrideNextTemplate?.ToLower();\n                    var matched = await _context.CTAFlowSteps\n                        .Include(s => s.Flow)\n                        .FirstOrDefaultAsync(s => s.TemplateToSend.ToLower() == overrideTemplate);\n                    if (matched != null) return matched;\n                }\n            }\n\n            var fallbackStep = await _context.CTAFlowSteps\n                .Include(s => s.Flow)\n                .Where(s =>\n                    s.Flow.BusinessId == businessId &&\n                    s.Flow.IsActive &&\n                    s.Flow.IsPublished &&\n                    s.TriggerButtonText.ToLower() == normalizedButtonText &&\n                    s.TriggerButtonType.ToLower() == normalizedButtonType)\n                .FirstOrDefaultAsync();\n\n            return fallbackStep;\n        }\n\n        public async Task<ResponseResult> ExecuteVisualFlowAsync(Guid businessId, Guid startStepId, Guid trackingLogId, Guid? campaignSendLogId)\n        {\n            try\n            {\n                var log = await _context.TrackingLogs\n                    .Include(l => l.Contact)\n                        .ThenInclude(c => c.ContactTags)\n                            .ThenInclude(ct => ct.Tag)\n                    .FirstOrDefaultAsync(l => l.Id == trackingLogId);\n\n                if (log == null) return ResponseResult.ErrorInfo(\"Tracking log not found.\");\n\n                var step = await GetChainedStepAsync(businessId, startStepId, log, log?.Contact);\n                if (step == null) return ResponseResult.ErrorInfo(\"Step conditions not satisfied.\");\n\n                var args = new List<string>();\n                if (step.UseProfileName && step.ProfileNameSlot is int slot && slot >= 1)\n                {\n                    var contact = log.Contact ?? await _context.Contacts\n                        .AsNoTracking()\n                        .FirstOrDefaultAsync(c => c.BusinessId == businessId && c.PhoneNumber == (log.ContactPhone ?? \"\"));\n                    var greet = (contact?.ProfileName ?? contact?.Name)?.Trim();\n                    if (string.IsNullOrEmpty(greet)) greet = \"there\";\n                    while (args.Count < slot) args.Add(string.Empty);\n                    args[slot - 1] = greet;\n                }\n\n                ResponseResult sendResult;\n                switch (step.TemplateType?.ToLower())\n                {\n                    case \"image_template\":\n                        var imageDto = new ImageTemplateMessageDto\n                        {\n                            BusinessId = businessId,\n                            RecipientNumber = log.ContactPhone ?? \"\",\n                            TemplateName = step.TemplateToSend,\n                            LanguageCode = \"en_US\"\n                        };\n                        sendResult = await _messageEngineService.SendImageTemplateMessageAsync(imageDto, businessId);\n                        break;\n                    case \"text_template\":\n                    default:\n                        var textDto = new SimpleTemplateMessageDto\n                        {\n                            RecipientNumber = log.ContactPhone ?? \"\",\n                            TemplateName = step.TemplateToSend,\n                            TemplateParameters = args\n                        };\n                        sendResult = await _messageEngineService.SendTemplateMessageSimpleAsync(businessId, textDto);\n                        break;\n                }\n\n                var executionLog = new FlowExecutionLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    StepId = step.Id,\n                    FlowId = step.CTAFlowConfigId,\n                    Origin = FlowExecutionOrigin.Campaign, // added fro autoreply flow\n                    CampaignSendLogId = campaignSendLogId,\n                    TrackingLogId = trackingLogId,\n                    ContactPhone = log.ContactPhone,\n                    TriggeredByButton = step.TriggerButtonText,\n                    TemplateName = step.TemplateToSend,\n                    TemplateType = step.TemplateType,\n                    Success = sendResult.Success,\n                    ErrorMessage = sendResult.ErrorMessage,\n                    RawResponse = sendResult.RawResponse,\n                    ExecutedAt = DateTime.UtcNow\n                };\n\n                _context.FlowExecutionLogs.Add(executionLog);\n                await _context.SaveChangesAsync();\n\n                return ResponseResult.SuccessInfo($\"Flow step executed. Sent: {sendResult.Success}\", null, sendResult.RawResponse);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Exception during ExecuteVisualFlowAsync()\");\n                return ResponseResult.ErrorInfo(\"Internal error during flow execution.\");\n            }\n        }\n\n        public Task<CTAFlowStep?> GetChainedStepAsync(Guid businessId, Guid? nextStepId)\n            => GetChainedStepAsync(businessId, nextStepId, null, null);\n\n        public async Task<CTAFlowStep?> GetChainedStepAsync(Guid businessId, Guid? nextStepId, TrackingLog? trackingLog, Contact? contact)\n        {\n            if (nextStepId == null) return null;\n\n            var flow = await _context.CTAFlowConfigs\n                .Include(f => f.Steps)\n                .FirstOrDefaultAsync(f =>\n                    f.BusinessId == businessId &&\n                    f.Steps.Any(s => s.Id == nextStepId));\n\n            var followUpStep = flow?.Steps.FirstOrDefault(s => s.Id == nextStepId);\n            if (followUpStep == null) return null;\n\n            if (trackingLog != null)\n            {\n                var isMatch = StepMatchingHelper.IsStepMatched(followUpStep, trackingLog, contact);\n                if (!isMatch) return null;\n            }\n\n            return followUpStep;\n        }\n\n        public async Task<CTAFlowStep?> GetChainedStepWithContextAsync(Guid businessId, Guid? nextStepId, Guid? trackingLogId)\n        {\n            var log = await _context.TrackingLogs\n                .Include(l => l.Contact)\n                    .ThenInclude(c => c.ContactTags)\n                        .ThenInclude(ct => ct.Tag)\n                .FirstOrDefaultAsync(l => l.Id == trackingLogId);\n\n            return await GetChainedStepAsync(businessId, nextStepId, log, log?.Contact);\n        }\n\n        // ‚úÖ MISSING IMPLEMENTATION (to satisfy the interface)\n        public async Task<FlowButtonLink?> GetLinkAsync(Guid flowId, Guid sourceStepId, short buttonIndex)\n        {\n            return await _context.FlowButtonLinks\n                .Where(l => l.CTAFlowStepId == sourceStepId\n                            && l.NextStepId != null\n                            && l.Step.CTAFlowConfigId == flowId\n                            && l.ButtonIndex == buttonIndex)\n                .SingleOrDefaultAsync();\n        }\n    }\n}\n\n\n//using Microsoft.AspNetCore.Authorization;\n//using Microsoft.AspNetCore.Mvc;\n//using Microsoft.EntityFrameworkCore;\n//using Serilog;\n//using xbytechat.api.AuthModule.Models;\n//using xbytechat.api.CRM.Models;\n//using xbytechat.api.Features.CTAFlowBuilder.DTOs;\n//using xbytechat.api.Features.CTAFlowBuilder.Models;\n//using xbytechat.api.Features.MessagesEngine.DTOs;\n//using xbytechat.api.Features.MessagesEngine.Services;\n//using xbytechat.api.Features.Tracking.Models;\n//using xbytechat.api.Helpers;\n//using xbytechat.api.WhatsAppSettings.DTOs;\n//using xbytechat_api.WhatsAppSettings.Services;\n\n//namespace xbytechat.api.Features.CTAFlowBuilder.Services\n//{\n//    public class CTAFlowService : ICTAFlowService\n//    {\n//        private readonly AppDbContext _context;\n//        private readonly IMessageEngineService _messageEngineService;\n//        private readonly IWhatsAppTemplateFetcherService _templateFetcherService;\n\n//        public CTAFlowService(AppDbContext context, IMessageEngineService messageEngineService,\n//            IWhatsAppTemplateFetcherService templateFetcherService\n//            )\n//        {\n//            _context = context;\n//            _messageEngineService = messageEngineService;\n//            _templateFetcherService = templateFetcherService;\n//        }\n\n//        public async Task<Guid> CreateFlowWithStepsAsync(CreateFlowDto dto, Guid businessId, string createdBy)\n//        {\n//            var flow = new CTAFlowConfig\n//            {\n//                Id = Guid.NewGuid(),\n//                FlowName = dto.FlowName,\n//                BusinessId = businessId,\n//                CreatedAt = DateTime.UtcNow,\n//                CreatedBy = createdBy,\n//                IsPublished = dto.IsPublished\n//            };\n\n//            foreach (var stepDto in dto.Steps)\n//            {\n//                var step = new CTAFlowStep\n//                {\n//                    Id = Guid.NewGuid(),\n//                    CTAFlowConfigId = flow.Id,\n//                    TriggerButtonText = stepDto.TriggerButtonText,\n//                    TriggerButtonType = stepDto.TriggerButtonType,\n//                    TemplateToSend = stepDto.TemplateToSend,\n//                    StepOrder = stepDto.StepOrder,\n//                    ButtonLinks = stepDto.ButtonLinks?.Select(link => new FlowButtonLink\n//                    {\n//                        ButtonText = link.ButtonText,\n//                        NextStepId = link.NextStepId\n//                    }).ToList() ?? new List<FlowButtonLink>()\n//                };\n\n//                flow.Steps.Add(step);\n//            }\n\n//            _context.CTAFlowConfigs.Add(flow);\n//            await _context.SaveChangesAsync();\n\n//            return flow.Id;\n//        }\n\n//        public async Task<CTAFlowConfig?> GetFlowByBusinessAsync(Guid businessId)\n//        {\n//            return await _context.CTAFlowConfigs\n//                .Include(f => f.Steps.OrderBy(s => s.StepOrder))\n//                .Where(f => f.BusinessId == businessId && f.IsActive && f.IsPublished)\n//                .FirstOrDefaultAsync();\n//        }\n\n//        public async Task<CTAFlowConfig?> GetDraftFlowByBusinessAsync(Guid businessId)\n//        {\n//            return await _context.CTAFlowConfigs\n//                .Include(f => f.Steps)\n//                    .ThenInclude(s => s.ButtonLinks)\n//                .Where(f => f.BusinessId == businessId && f.IsPublished == false)\n//                .OrderByDescending(f => f.CreatedAt)\n//                .FirstOrDefaultAsync();\n//        }\n\n\n\n//        public async Task<List<CTAFlowStep>> GetStepsForFlowAsync(Guid flowId)\n//        {\n//            return await _context.CTAFlowSteps\n//                .Where(s => s.CTAFlowConfigId == flowId)\n//                .OrderBy(s => s.StepOrder)\n//                .ToListAsync();\n//        }\n\n//        public async Task<CTAFlowStep?> MatchStepByButtonAsync(\n//            Guid businessId,\n//            string buttonText,\n//            string buttonType,\n//            string TemplateName,\n//            Guid? campaignId = null)\n//        {\n//            var normalizedButtonText = buttonText?.Trim().ToLower() ?? \"\";\n//            var normalizedButtonType = buttonType?.Trim().ToLower() ?? \"\";\n//            var normalizedTemplateName = TemplateName?.Trim().ToLower() ?? \"\";\n\n//            // 1Ô∏è‚É£ Try campaign-specific override\n//            if (campaignId.HasValue)\n//            {\n//                var overrideStep = await _context.CampaignFlowOverrides\n//                    .Where(o =>\n//                        o.CampaignId == campaignId &&\n//                        o.ButtonText.ToLower() == normalizedButtonText &&\n//                        o.TemplateName.ToLower() == normalizedTemplateName)\n//                    .FirstOrDefaultAsync();\n\n//                if (overrideStep != null)\n//                {\n//                    var overrideTemplate = overrideStep.OverrideNextTemplate?.ToLower();\n\n//                    var matched = await _context.CTAFlowSteps\n//                        .Include(s => s.Flow)\n//                        .FirstOrDefaultAsync(s => s.TemplateToSend.ToLower() == overrideTemplate);\n\n//                    if (matched != null)\n//                    {\n//                        Log.Information(\"üîÅ Override matched: Template '{Template}' ‚Üí Step '{StepId}'\", overrideStep.OverrideNextTemplate, matched.Id);\n//                        return matched;\n//                    }\n\n//                    Log.Warning(\"‚ö†Ô∏è Override found for button '{Button}' but no matching step for template '{Template}'\", normalizedButtonText, overrideStep.OverrideNextTemplate);\n//                }\n\n//                else\n//                {\n//                    Log.Information(\"üü° No campaign override found for button '{Button}' on template '{Template}'\", normalizedButtonText, normalizedTemplateName);\n//                }\n//            }\n\n//            // 2Ô∏è‚É£ Fallback to standard flow logic\n//            var fallbackStep = await _context.CTAFlowSteps\n//                .Include(s => s.Flow)\n//                .Where(s =>\n//                    s.Flow.BusinessId == businessId &&\n//                    s.Flow.IsActive &&\n//                    s.Flow.IsPublished &&\n//                    s.TriggerButtonText.ToLower() == normalizedButtonText &&\n//                    s.TriggerButtonType.ToLower() == normalizedButtonType)\n//                .FirstOrDefaultAsync();\n\n//            if (fallbackStep != null)\n//            {\n//                Log.Information(\"‚úÖ Fallback flow step matched: StepId = {StepId}, Flow = {FlowName}\", fallbackStep.Id, fallbackStep.Flow?.FlowName);\n//            }\n//            else\n//            {\n//                Log.Warning(\"‚ùå No fallback step matched for button '{ButtonText}' of type '{ButtonType}' in BusinessId: {BusinessId}\", normalizedButtonText, normalizedButtonType, businessId);\n//            }\n\n//            return fallbackStep;\n//        }\n\n\n//        public async Task<bool> PublishFlowAsync(Guid flowId, Guid businessId, string user)\n//        {\n//            var flow = await _context.CTAFlowConfigs\n//                .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId && f.IsActive);\n\n//            if (flow is null) return false;\n\n//            // Optional validation: ensure it has at least 1 step, etc.\n//            flow.IsPublished = true;\n//            flow.UpdatedAt = DateTime.UtcNow;\n//            await _context.SaveChangesAsync();\n//            return true;\n//        }\n\n//        //public async Task<ResponseResult> PublishFlowAsync(Guid businessId, List<FlowStepDto> steps, string createdBy)\n//        //{\n//        //    try\n//        //    {\n//        //        // üî• 1. Remove existing published flow for this business\n//        //        var existingFlows = await _context.CTAFlowConfigs\n//        //            .Where(f => f.BusinessId == businessId && f.IsPublished)\n//        //            .ToListAsync();\n\n//        //        if (existingFlows.Any())\n//        //        {\n//        //            _context.CTAFlowConfigs.RemoveRange(existingFlows);\n//        //        }\n\n//        //        // üå± 2. Create new flow config\n//        //        var flowConfig = new CTAFlowConfig\n//        //        {\n//        //            Id = Guid.NewGuid(),\n//        //            BusinessId = businessId,\n//        //            FlowName = \"Published Flow - \" + DateTime.UtcNow.ToString(\"yyyyMMdd-HHmm\"),\n//        //            IsPublished = true,\n//        //            IsActive = true,\n//        //            CreatedBy = createdBy,\n//        //            CreatedAt = DateTime.UtcNow,\n//        //            Steps = new List<CTAFlowStep>()\n//        //        };\n\n//        //        // üîÅ 3. Convert each step DTO to model\n//        //        foreach (var stepDto in steps)\n//        //        {\n//        //            var step = new CTAFlowStep\n//        //            {\n//        //                Id = Guid.NewGuid(),\n//        //                CTAFlowConfigId = flowConfig.Id,\n//        //                TriggerButtonText = stepDto.TriggerButtonText,\n//        //                TriggerButtonType = stepDto.TriggerButtonType,\n//        //                TemplateToSend = stepDto.TemplateToSend,\n//        //                StepOrder = stepDto.StepOrder,\n//        //                ButtonLinks = stepDto.ButtonLinks.Select(bl => new FlowButtonLink\n//        //                {\n//        //                    Id = Guid.NewGuid(),\n//        //                    ButtonText = bl.ButtonText,\n//        //                    NextStepId = bl.NextStepId,\n//        //                }).ToList()\n//        //            };\n\n//        //            flowConfig.Steps.Add(step);\n//        //        }\n\n//        //        // üíæ 4. Save to DB\n//        //        await _context.CTAFlowConfigs.AddAsync(flowConfig);\n//        //        await _context.SaveChangesAsync();\n\n//        //        return ResponseResult.SuccessInfo(\"‚úÖ Flow published successfully.\");\n//        //    }\n//        //    catch (Exception ex)\n//        //    {\n//        //        Log.Error(ex, \"‚ùå Error while publishing CTA flow.\");\n//        //        return ResponseResult.ErrorInfo(\"‚ùå Could not publish flow.\");\n//        //    }\n//        //}\n\n\n//        private static int CountBodyPlaceholders(string? body)\n//        {\n//            if (string.IsNullOrWhiteSpace(body)) return 0;\n//            // counts {{1}}, {{2}}, ... ; ignores any non-numeric moustaches\n//            var m = System.Text.RegularExpressions.Regex.Matches(body, @\"\\{\\{\\s*\\d+\\s*\\}\\}\");\n//            return m.Count;\n//        }\n//        public async Task<ResponseResult> SaveVisualFlowAsync(\n//    SaveVisualFlowDto dto,\n//    Guid businessId,\n//    string createdBy)\n//        {\n//            try\n//            {\n//                Log.Information(\"üß† SaveVisualFlow (create-only) | FlowName: {FlowName} | Biz: {BusinessId}\",\n//                    dto.FlowName, businessId);\n\n//                // 0) Basic validation\n//                if (dto.Nodes == null || !dto.Nodes.Any())\n//                    return ResponseResult.ErrorInfo(\"‚ùå Cannot save an empty flow. Please add at least one step.\");\n\n//                var trimmedName = (dto.FlowName ?? \"\").Trim();\n//                if (trimmedName.Length == 0)\n//                    return ResponseResult.ErrorInfo(\"‚ùå Flow name is required.\");\n\n//                // 1) CREATE-ONLY: refuse duplicate name for this business\n//                var nameExists = await _context.CTAFlowConfigs\n//                    .AnyAsync(f => f.BusinessId == businessId && f.FlowName == trimmedName && f.IsActive);\n\n//                if (nameExists)\n//                {\n//                    // IMPORTANT: this method is only for *new* flows.\n//                    // If the user is editing an existing flow, the UI should call PUT /cta-flow/{id}.\n//                    Log.Warning(\"‚ö†Ô∏è Duplicate flow name '{Name}' for business {Biz}.\", trimmedName, businessId);\n//                    return ResponseResult.ErrorInfo(\n//                        \"‚ùå A flow with this name already exists. Open that flow and edit it, or choose a different name.\");\n//                }\n\n//                await using var tx = await _context.Database.BeginTransactionAsync();\n\n//                // 2) Insert FlowConfig\n//                var flow = new CTAFlowConfig\n//                {\n//                    Id = Guid.NewGuid(),\n//                    BusinessId = businessId,\n//                    FlowName = trimmedName,\n//                    CreatedBy = createdBy,\n//                    CreatedAt = DateTime.UtcNow,\n//                    UpdatedAt = DateTime.UtcNow,\n//                    IsActive = true,\n//                    // You *can* allow creating as published, but most teams prefer create-as-draft:\n//                    IsPublished = dto.IsPublished\n//                };\n//                _context.CTAFlowConfigs.Add(flow);\n\n//                // 3) Build Steps\n//                var stepMap = new Dictionary<string, CTAFlowStep>(StringComparer.OrdinalIgnoreCase);\n//                var orderIndex = 0;\n\n//                foreach (var node in dto.Nodes)\n//                {\n//                    if (string.IsNullOrWhiteSpace(node.Id)) continue;\n\n//                    var step = new CTAFlowStep\n//                    {\n//                        Id = Guid.NewGuid(),\n//                        CTAFlowConfigId = flow.Id,\n//                        StepOrder = orderIndex++,\n//                        TemplateToSend = node.TemplateName,\n//                        TemplateType = node.TemplateType ?? \"UNKNOWN\",\n//                        TriggerButtonText = node.TriggerButtonText ?? \"\",\n//                        TriggerButtonType = node.TriggerButtonType ?? \"cta\",\n//                        PositionX = node.PositionX == 0 ? Random.Shared.Next(100, 600) : node.PositionX,\n//                        PositionY = node.PositionY == 0 ? Random.Shared.Next(100, 400) : node.PositionY,\n//                        UseProfileName = node.UseProfileName,\n//                        ProfileNameSlot = node.ProfileNameSlot,\n//                        ButtonLinks = new List<FlowButtonLink>()\n//                    };\n\n//                    // Harden profile-name config per template type\n//                    var isTextTemplate = string.Equals(step.TemplateType, \"text_template\", StringComparison.OrdinalIgnoreCase);\n//                    if (!isTextTemplate)\n//                    {\n//                        step.UseProfileName = false;\n//                        step.ProfileNameSlot = null;\n//                    }\n//                    else\n//                    {\n//                        if (!step.UseProfileName)\n//                        {\n//                            step.ProfileNameSlot = null;\n//                        }\n//                        else\n//                        {\n//                            if (!step.ProfileNameSlot.HasValue || step.ProfileNameSlot.Value < 1)\n//                                step.ProfileNameSlot = 1;\n//                        }\n//                    }\n\n//                    stepMap[node.Id] = step;\n//                    _context.CTAFlowSteps.Add(step);\n//                }\n\n//                // 4) Build Links (per-node buttons, matched by SourceHandle == button text)\n//                var edges = dto.Edges ?? new List<FlowEdgeDto>();\n\n//                foreach (var node in dto.Nodes)\n//                {\n//                    if (string.IsNullOrWhiteSpace(node.Id) || !stepMap.TryGetValue(node.Id, out var fromStep))\n//                        continue;\n\n//                    var outEdges = edges.Where(e => string.Equals(e.FromNodeId, node.Id, StringComparison.OrdinalIgnoreCase)).ToList();\n//                    var seenTexts = new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n\n//                    var orderedButtons = (node.Buttons ?? new List<LinkButtonDto>())\n//                        .OrderBy(b => b.Index < 0 ? int.MaxValue : b.Index)\n//                        .ThenBy(b => b.Text ?? string.Empty)\n//                        .ToList();\n\n//                    short nextIdx = 0;\n\n//                    foreach (var btn in orderedButtons)\n//                    {\n//                        var text = (btn.Text ?? string.Empty).Trim();\n//                        if (string.IsNullOrEmpty(text)) continue;\n\n//                        if (!seenTexts.Add(text))\n//                        {\n//                            Log.Warning(\"‚ö†Ô∏è Duplicate button text '{Text}' on node {NodeId}; first wins.\", text, node.Id);\n//                            continue;\n//                        }\n\n//                        var edge = outEdges.FirstOrDefault(e =>\n//                            string.Equals(e.SourceHandle ?? string.Empty, text, StringComparison.OrdinalIgnoreCase));\n//                        if (edge == null) continue;\n\n//                        if (!stepMap.TryGetValue(edge.ToNodeId, out var toStep)) continue;\n\n//                        var finalIndex = btn.Index >= 0 ? btn.Index : nextIdx;\n//                        nextIdx = (short)(finalIndex + 1);\n\n//                        var link = new FlowButtonLink\n//                        {\n//                            Id = Guid.NewGuid(),\n//                            CTAFlowStepId = fromStep.Id,\n//                            NextStepId = toStep.Id,\n//                            ButtonText = text,\n//                            ButtonType = string.IsNullOrWhiteSpace(btn.Type) ? \"QUICK_REPLY\" : btn.Type,\n//                            ButtonSubType = btn.SubType ?? string.Empty,\n//                            ButtonValue = btn.Value ?? string.Empty,\n//                            ButtonIndex = (short)finalIndex\n//                        };\n\n//                        _context.FlowButtonLinks.Add(link);\n//                        fromStep.ButtonLinks.Add(link);\n\n//                        // convenience: target step \"entry trigger\"\n//                        toStep.TriggerButtonText = text;\n//                        toStep.TriggerButtonType = (btn.Type ?? \"QUICK_REPLY\").ToLowerInvariant();\n//                    }\n//                }\n\n//                await _context.SaveChangesAsync();\n//                await tx.CommitAsync();\n\n//                Log.Information(\"‚úÖ Flow created '{Flow}' | Steps: {Steps} | Links: {Links}\",\n//                    flow.FlowName, stepMap.Count, stepMap.Values.Sum(s => s.ButtonLinks.Count));\n\n//                // Return new flowId so the FE can redirect/open it if desired\n//                return ResponseResult.SuccessInfo(\"‚úÖ Flow created.\", new { flowId = flow.Id });\n//            }\n//            catch (Exception ex)\n//            {\n//                Log.Error(ex, \"‚ùå Exception while saving (create) flow\");\n//                return ResponseResult.ErrorInfo(\"‚ùå Internal error while saving flow.\");\n//            }\n//        }\n\n//        //public async Task<ResponseResult> SaveVisualFlowAsync(SaveVisualFlowDto dto, Guid businessId, string createdBy)\n//        //{\n//        //    try\n//        //    {\n//        //        Log.Information(\"üß† SaveVisualFlow started | FlowName: {FlowName} | BusinessId: {BusinessId}\", dto.FlowName, businessId);\n\n//        //        if (dto.Nodes == null || !dto.Nodes.Any())\n//        //        {\n//        //            Log.Warning(\"‚ùå No nodes found in flow. Aborting save.\");\n//        //            return ResponseResult.ErrorInfo(\"‚ùå Cannot save an empty flow. Please add at least one step.\");\n//        //        }\n\n//        //        // 1) Upsert FlowConfig\n//        //        var flow = await _context.CTAFlowConfigs\n//        //            .FirstOrDefaultAsync(f => f.FlowName == dto.FlowName && f.BusinessId == businessId);\n\n//        //        if (flow == null)\n//        //        {\n//        //            flow = new CTAFlowConfig\n//        //            {\n//        //                Id = Guid.NewGuid(),\n//        //                BusinessId = businessId,\n//        //                FlowName = dto.FlowName,\n//        //                CreatedBy = createdBy,\n//        //                CreatedAt = DateTime.UtcNow,\n//        //                UpdatedAt = DateTime.UtcNow,\n//        //                IsActive = true,\n//        //                IsPublished = dto.IsPublished\n//        //            };\n//        //            _context.CTAFlowConfigs.Add(flow);\n//        //            Log.Information(\"‚úÖ New FlowConfig created with ID: {Id}\", flow.Id);\n//        //        }\n//        //        else\n//        //        {\n//        //            // wipe old steps+links for a clean replace\n//        //            var oldSteps = await _context.CTAFlowSteps\n//        //                .Where(s => s.CTAFlowConfigId == flow.Id)\n//        //                .Include(s => s.ButtonLinks)\n//        //                .ToListAsync();\n\n//        //            foreach (var step in oldSteps)\n//        //                _context.FlowButtonLinks.RemoveRange(step.ButtonLinks);\n\n//        //            _context.CTAFlowSteps.RemoveRange(oldSteps);\n\n//        //            flow.IsPublished = dto.IsPublished;\n//        //            flow.UpdatedAt = DateTime.UtcNow;\n//        //        }\n\n//        //        // 2) Build Steps (map by incoming node.Id string)\n//        //        var stepMap = new Dictionary<string, CTAFlowStep>(StringComparer.OrdinalIgnoreCase);\n\n//        //        foreach (var (node, index) in dto.Nodes.Select((n, i) => (n, i)))\n//        //        {\n//        //            if (string.IsNullOrWhiteSpace(node.Id))\n//        //                continue;\n\n//        //            var step = new CTAFlowStep\n//        //            {\n//        //                Id = Guid.NewGuid(),\n//        //                CTAFlowConfigId = flow.Id,\n//        //                StepOrder = index,\n//        //                TemplateToSend = node.TemplateName,\n//        //                TemplateType = node.TemplateType ?? \"UNKNOWN\",\n//        //                TriggerButtonText = node.TriggerButtonText ?? \"\",\n//        //                TriggerButtonType = node.TriggerButtonType ?? \"cta\",\n//        //                PositionX = node.PositionX == 0 ? Random.Shared.Next(100, 600) : node.PositionX,\n//        //                PositionY = node.PositionY == 0 ? Random.Shared.Next(100, 400) : node.PositionY,\n//        //                UseProfileName = node.UseProfileName,\n//        //                ProfileNameSlot = node.ProfileNameSlot,\n//        //                //ProfileNameSlot = node.ProfileNameSlot ?? 1,\n//        //                ButtonLinks = new List<FlowButtonLink>()\n//        //            };\n\n//        //            // ‚úÖ Harden profile-name config per step\n//        //            var isTextTemplate = string.Equals(step.TemplateType, \"text_template\", StringComparison.OrdinalIgnoreCase);\n//        //            if (!isTextTemplate)\n//        //            {\n//        //                // Only text templates support body placeholders; disable on others\n//        //                step.UseProfileName = false;\n//        //                step.ProfileNameSlot = null;\n//        //            }\n//        //            //else if (step.UseProfileName)\n//        //            //{\n//        //            //    // Clamp to minimum valid slot\n//        //            //    if (!step.ProfileNameSlot.HasValue || step.ProfileNameSlot.Value < 1)\n//        //            //        step.ProfileNameSlot = 1;\n//        //            //}\n//        //            else\n//        //            {\n//        //                // Text template:\n//        //                if (!step.UseProfileName)\n//        //                {\n//        //                    // Toggle OFF ‚Üí always null the slot\n//        //                    step.ProfileNameSlot = null;\n//        //                }\n//        //                else\n//        //                {\n//        //                    // Toggle ON ‚Üí clamp to minimum valid\n//        //                    if (!step.ProfileNameSlot.HasValue || step.ProfileNameSlot.Value < 1)\n//        //                        step.ProfileNameSlot = 1;\n//        //                    // (Optional) upper clamp if you want: e.g., step.ProfileNameSlot = Math.Min(step.ProfileNameSlot.Value, 50);\n//        //                }\n//        //            }\n//        //            stepMap[node.Id] = step;\n//        //            _context.CTAFlowSteps.Add(step);\n//        //        }\n\n//        //        // 3) Build Links PER NODE using buttons order (with Index), not per-edge blindly\n//        //        foreach (var node in dto.Nodes)\n//        //        {\n//        //            if (string.IsNullOrWhiteSpace(node.Id) || !stepMap.TryGetValue(node.Id, out var fromStep))\n//        //                continue;\n\n//        //            // outgoing edges from this node\n//        //            var outEdges = dto.Edges?.Where(e => string.Equals(e.FromNodeId, node.Id, StringComparison.OrdinalIgnoreCase)).ToList()\n//        //                           ?? new List<FlowEdgeDto>();\n\n//        //            // dedupe by button text to avoid ambiguous routing\n//        //            var seenTexts = new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n\n//        //            // stable ordering: by provided Index (0..N), then by Text\n//        //            var orderedButtons = (node.Buttons ?? new List<LinkButtonDto>())\n//        //                .OrderBy(b => b.Index < 0 ? int.MaxValue : b.Index)\n//        //                .ThenBy(b => b.Text ?? string.Empty)\n//        //                .ToList();\n\n//        //            short nextIdx = 0;\n\n//        //            foreach (var btn in orderedButtons)\n//        //            {\n//        //                var text = (btn.Text ?? string.Empty).Trim();\n//        //                if (string.IsNullOrEmpty(text))\n//        //                    continue;\n\n//        //                if (!seenTexts.Add(text))\n//        //                {\n//        //                    Log.Warning(\"‚ö†Ô∏è Duplicate button text '{Text}' on node {NodeId}; keeping first, skipping duplicates.\", text, node.Id);\n//        //                    continue;\n//        //                }\n\n//        //                // match edge by SourceHandle == button text (how ReactFlow wires handles)\n//        //                var edge = outEdges.FirstOrDefault(e =>\n//        //                    string.Equals(e.SourceHandle ?? string.Empty, text, StringComparison.OrdinalIgnoreCase));\n//        //                if (edge == null)\n//        //                {\n//        //                    // no wire from this button ‚Üí skip link creation but keep button metadata in UI on reload\n//        //                    continue;\n//        //                }\n\n//        //                if (!stepMap.TryGetValue(edge.ToNodeId, out var toStep))\n//        //                    continue;\n\n//        //                // final index: prefer incoming payload Index; else fallback to a sequential counter\n//        //                var finalIndex = btn.Index >= 0 ? btn.Index : nextIdx;\n//        //                nextIdx = (short)(finalIndex + 1);\n\n//        //                var link = new FlowButtonLink\n//        //                {\n//        //                    Id = Guid.NewGuid(),\n//        //                    CTAFlowStepId = fromStep.Id,\n//        //                    NextStepId = toStep.Id,\n//        //                    ButtonText = text,\n//        //                    ButtonType = string.IsNullOrWhiteSpace(btn.Type) ? \"QUICK_REPLY\" : btn.Type,\n//        //                    ButtonSubType = btn.SubType ?? string.Empty,\n//        //                    ButtonValue = btn.Value ?? string.Empty,\n//        //                    ButtonIndex = (short)finalIndex // üîë persist the index\n//        //                };\n\n//        //                _context.FlowButtonLinks.Add(link);\n//        //                fromStep.ButtonLinks.Add(link);\n\n//        //                // propagate trigger info on the target step for convenience\n//        //                toStep.TriggerButtonText = text;\n//        //                toStep.TriggerButtonType = (btn.Type ?? \"QUICK_REPLY\").ToLowerInvariant();\n//        //            }\n//        //        }\n\n//        //        await _context.SaveChangesAsync();\n\n//        //        Log.Information(\"‚úÖ Flow '{Flow}' saved | Steps: {StepCount} | Links: {LinkCount}\",\n//        //            dto.FlowName, stepMap.Count, stepMap.Values.Sum(s => s.ButtonLinks.Count));\n\n//        //        return ResponseResult.SuccessInfo(\"‚úÖ Flow saved successfully.\");\n//        //    }\n//        //    catch (Exception ex)\n//        //    {\n//        //        Log.Error(ex, \"‚ùå Exception while saving flow\");\n//        //        return ResponseResult.ErrorInfo(\"‚ùå Internal error while saving flow.\");\n//        //    }\n//        //}\n\n\n//        //public async Task<SaveVisualFlowDto?> GetVisualFlowByIdAsync(Guid flowId, Guid businessId)\n//        //{\n//        //    var flow = await _context.CTAFlowConfigs\n//        //        .Include(c => c.Steps)\n//        //            .ThenInclude(s => s.ButtonLinks)\n//        //        .FirstOrDefaultAsync(c =>\n//        //            c.Id == flowId &&\n//        //            c.BusinessId == businessId &&   // üëà tenant scoping\n//        //            c.IsActive);\n\n//        //    if (flow == null) return null;\n\n//        //    // ---- Pre-fetch unique template names (defensive) ----\n//        //    var templateMap = new Dictionary<string, TemplateMetadataDto>(StringComparer.OrdinalIgnoreCase);\n//        //    foreach (var name in flow.Steps\n//        //                             .Select(s => s.TemplateToSend)\n//        //                             .Where(n => !string.IsNullOrWhiteSpace(n))\n//        //                             .Distinct(StringComparer.OrdinalIgnoreCase))\n//        //    {\n//        //        try\n//        //        {\n//        //            var tpl = await _templateFetcherService.GetTemplateByNameAsync(\n//        //                businessId, name!, includeButtons: true);\n//        //            if (tpl != null) templateMap[name!] = tpl;\n//        //        }\n//        //        catch (Exception ex)\n//        //        {\n//        //            Log.Warning(ex, \"‚ö†Ô∏è Failed to fetch template from Meta for {Template}\", name);\n//        //        }\n//        //    }\n\n//        //    // ---- Nodes ----\n//        //    var nodes = flow.Steps.Select(step =>\n//        //    {\n//        //        templateMap.TryGetValue(step.TemplateToSend ?? \"\", out var template);\n\n//        //        IEnumerable<FlowButtonLink> links =\n//        //            step.ButtonLinks ?? Enumerable.Empty<FlowButtonLink>();\n\n//        //        var dbButtons = links.Select(link => new LinkButtonDto\n//        //        {\n//        //            Text = link.ButtonText,\n//        //            Type = link.ButtonType,\n//        //            SubType = link.ButtonSubType,\n//        //            Value = link.ButtonValue,\n//        //            TargetNodeId = link.NextStepId?.ToString() // null-safe\n//        //        });\n\n//        //        var templateButtons = (template?.ButtonParams ?? new List<ButtonMetadataDto>())\n//        //            .Where(btn => !links.Any(bl =>\n//        //                        string.Equals(bl.ButtonText, btn.Text, StringComparison.OrdinalIgnoreCase)))\n//        //            .Select(btn => new LinkButtonDto\n//        //            {\n//        //                Text = btn.Text,\n//        //                TargetNodeId = null\n//        //            });\n\n//        //        return new FlowNodeDto\n//        //        {\n//        //            Id = step.Id.ToString(),\n//        //            TemplateName = step.TemplateToSend,\n//        //            TemplateType = step.TemplateType,\n//        //            MessageBody = template?.Body ?? \"Message body preview...\",\n//        //            TriggerButtonText = step.TriggerButtonText,\n//        //            TriggerButtonType = step.TriggerButtonType,\n//        //            PositionX = step.PositionX ?? 100,\n//        //            PositionY = step.PositionY ?? 100,\n\n//        //            // Conditional logic\n//        //            RequiredTag = step.RequiredTag,\n//        //            RequiredSource = step.RequiredSource,\n\n//        //            UseProfileName = step.UseProfileName,\n//        //            ProfileNameSlot = step.ProfileNameSlot,\n\n//        //            Buttons = dbButtons.Concat(templateButtons).ToList()\n//        //        };\n//        //    }).ToList();\n\n//        //    // ---- Edges (skip links without a target) ----\n//        //    var edges = flow.Steps\n//        //        .SelectMany(step =>\n//        //            (step.ButtonLinks ?? Enumerable.Empty<FlowButtonLink>())\n//        //            .Where(link => link.NextStepId.HasValue)\n//        //            .Select(link => new FlowEdgeDto\n//        //            {\n//        //                FromNodeId = step.Id.ToString(),\n//        //                ToNodeId = link.NextStepId!.Value.ToString(),\n//        //                SourceHandle = link.ButtonText\n//        //            }))\n//        //        .ToList();\n\n//        //    return new SaveVisualFlowDto\n//        //    {\n//        //        FlowName = flow.FlowName,\n//        //        IsPublished = flow.IsPublished,\n//        //        Nodes = nodes,\n//        //        Edges = edges\n//        //    };\n//        //}\n\n//        public async Task<SaveVisualFlowDto?> GetVisualFlowByIdAsync(Guid flowId, Guid businessId)\n//        {\n//            var flow = await _context.CTAFlowConfigs\n//                .Include(c => c.Steps)\n//                    .ThenInclude(s => s.ButtonLinks)\n//                .FirstOrDefaultAsync(c => c.Id == flowId && c.BusinessId == businessId && c.IsActive);\n\n//            if (flow == null) return null;\n\n//            // 1) Prefetch template metadata for all unique names (defensive, fast)\n//            var templateMap = new Dictionary<string, TemplateMetadataDto>(StringComparer.OrdinalIgnoreCase);\n//            var uniqueNames = flow.Steps\n//                .Select(s => s.TemplateToSend)\n//                .Where(n => !string.IsNullOrWhiteSpace(n))\n//                .Distinct(StringComparer.OrdinalIgnoreCase)\n//                .ToList();\n\n//            foreach (var name in uniqueNames)\n//            {\n//                try\n//                {\n//                    var tpl = await _templateFetcherService.GetTemplateByNameAsync(\n//                        businessId, name!, includeButtons: true);\n//                    if (tpl != null) templateMap[name!] = tpl;\n//                }\n//                catch (Exception ex)\n//                {\n//                    Log.Warning(ex, \"‚ö†Ô∏è Failed to fetch template from provider for {Template}\", name);\n//                }\n//            }\n\n//            // 2) Build nodes with real body + merged buttons (DB links first, then any unlinked template buttons)\n//            var nodes = flow.Steps.Select(step =>\n//            {\n//                templateMap.TryGetValue(step.TemplateToSend ?? \"\", out var tpl);\n\n//                var dbLinks = step.ButtonLinks ?? new List<FlowButtonLink>();\n\n//                var dbButtons = dbLinks\n//                    .OrderBy(b => b.ButtonIndex)\n//                    .Select(link => new LinkButtonDto\n//                    {\n//                        Text = link.ButtonText,\n//                        Type = link.ButtonType,\n//                        SubType = link.ButtonSubType,\n//                        Value = link.ButtonValue,\n//                        Index = link.ButtonIndex,\n//                        TargetNodeId = link.NextStepId?.ToString()\n//                    });\n\n//                var templateButtons = (tpl?.ButtonParams ?? new List<ButtonMetadataDto>())\n//                    .Where(btn => !dbLinks.Any(bl => string.Equals(bl.ButtonText, btn.Text, StringComparison.OrdinalIgnoreCase)))\n//                    .Select(btn => new LinkButtonDto\n//                    {\n//                        Text = btn.Text,\n//                        // no TargetNodeId: not wired\n//                    });\n\n//                return new FlowNodeDto\n//                {\n//                    Id = step.Id.ToString(),\n//                    TemplateName = step.TemplateToSend,\n//                    TemplateType = step.TemplateType,\n//                    MessageBody = string.IsNullOrWhiteSpace(tpl?.Body) ? \"‚Äî no body found ‚Äî\" : tpl!.Body, // ‚Üê REAL BODY\n//                    TriggerButtonText = step.TriggerButtonText,\n//                    TriggerButtonType = step.TriggerButtonType,\n//                    PositionX = step.PositionX ?? 100,\n//                    PositionY = step.PositionY ?? 100,\n//                    RequiredTag = step.RequiredTag,\n//                    RequiredSource = step.RequiredSource,\n//                    UseProfileName = step.UseProfileName,\n//                    ProfileNameSlot = step.ProfileNameSlot,\n//                    Buttons = dbButtons.Concat(templateButtons).ToList()\n//                };\n//            }).ToList();\n\n//            // 3) Build edges\n//            var edges = flow.Steps\n//                .SelectMany(step => (step.ButtonLinks ?? Enumerable.Empty<FlowButtonLink>())\n//                    .Where(l => l.NextStepId.HasValue)\n//                    .Select(l => new FlowEdgeDto\n//                    {\n//                        FromNodeId = step.Id.ToString(),\n//                        ToNodeId = l.NextStepId!.Value.ToString(),\n//                        SourceHandle = l.ButtonText\n//                    }))\n//                .ToList();\n\n//            return new SaveVisualFlowDto\n//            {\n//                FlowName = flow.FlowName,\n//                IsPublished = flow.IsPublished,\n//                Nodes = nodes,\n//                Edges = edges\n//            };\n//        }\n\n//        public async Task<ResponseResult> DeleteFlowAsync(Guid flowId, Guid businessId, string deletedBy)\n//        {\n//            // Load flow with children so we can remove in the right order\n//            var flow = await _context.CTAFlowConfigs\n//                .Include(f => f.Steps)\n//                    .ThenInclude(s => s.ButtonLinks)\n//                .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId);\n\n//            if (flow == null)\n//                return ResponseResult.ErrorInfo(\"‚ùå Flow not found or does not belong to you.\");\n\n//            // Is this flow used by any active campaign?\n//            var inUseQuery = _context.Campaigns\n//                .Where(c => c.BusinessId == businessId &&\n//                            !c.IsDeleted &&\n//                            c.CTAFlowConfigId == flowId);\n\n//            var inUseCount = await inUseQuery.CountAsync();\n//            if (inUseCount > 0)\n//            {\n//                // Optional: show a few campaign names in the error for the UI\n//                var sample = await inUseQuery\n//                    .OrderByDescending(c => c.CreatedAt)\n//                    .Select(c => new { c.Id, c.Name, c.Status })\n//                    .Take(5)\n//                    .ToListAsync();\n\n//                Log.Warning(\"‚ùå Delete flow blocked. Flow {FlowId} is used by {Count} campaigns: {@Sample}\",\n//                    flowId, inUseCount, sample);\n\n//                return ResponseResult.ErrorInfo(\n//                    $\"‚ùå Cannot delete. This flow is attached to {inUseCount} campaign(s). \" +\n//                    $\"Delete those campaigns first.\"\n//                );\n//            }\n\n//            // Safe to remove: delete children first, then the flow\n//            foreach (var step in flow.Steps)\n//                _context.FlowButtonLinks.RemoveRange(step.ButtonLinks);\n\n//            _context.CTAFlowSteps.RemoveRange(flow.Steps);\n//            _context.CTAFlowConfigs.Remove(flow);\n\n//            await _context.SaveChangesAsync();\n//            return ResponseResult.SuccessInfo(\"‚úÖ Flow deleted.\");\n//        }\n\n\n//        public async Task<List<VisualFlowSummaryDto>> GetAllPublishedFlowsAsync(Guid businessId)\n//        {\n//            return await _context.CTAFlowConfigs\n//                .Where(f => f.BusinessId == businessId && f.IsPublished)\n//                .OrderByDescending(f => f.CreatedAt)\n//                .Select(f => new VisualFlowSummaryDto\n//                {\n//                    Id = f.Id,\n//                    FlowName = f.FlowName,\n//                    IsPublished = f.IsPublished,\n//                    CreatedAt = f.CreatedAt\n//                })\n//                .ToListAsync();\n//        }\n\n//        public async Task<List<VisualFlowSummaryDto>> GetAllDraftFlowsAsync(Guid businessId)\n//        {\n//            return await _context.CTAFlowConfigs\n//                .Where(f => f.BusinessId == businessId && !f.IsPublished && f.IsActive)\n//                .OrderByDescending(f => f.CreatedAt)\n//                .Select(f => new VisualFlowSummaryDto\n//                {\n//                    Id = f.Id,\n//                    FlowName = f.FlowName,\n//                    CreatedAt = f.CreatedAt,\n//                    IsPublished = f.IsPublished\n//                })\n//                .ToListAsync();\n//        }\n\n//        public async Task<ResponseResult> ExecuteFollowUpStepAsync(Guid businessId, CTAFlowStep? currentStep, string recipientNumber)\n//        {\n//            // Log.Information(\"üöÄ Executing follow-up for BusinessId: {BusinessId}, CurrentStepId: {StepId}\", businessId);\n//            if (currentStep == null)\n//            {\n//                Log.Warning(\"‚ö†Ô∏è Cannot execute follow-up. Current step is null.\");\n//                return ResponseResult.ErrorInfo(\"Current step not found.\");\n//            }\n\n//            // üß† Step: Look through all button links for a valid NextStepId\n//            var nextLink = currentStep.ButtonLinks.FirstOrDefault(link => link.NextStepId != null);\n\n//            if (nextLink == null)\n//            {\n//                Log.Information(\"‚ÑπÔ∏è No NextStepId defined in any ButtonLinks for StepId: {StepId}\", currentStep.Id);\n//                return ResponseResult.SuccessInfo(\"No follow-up step to execute.\");\n//            }\n\n//            // üîç Fetch the next step using new logic (via CTAFlowConfig + Steps)\n//            // 1Ô∏è‚É£ Try to resolve with smart condition check\n//            var followUpStep = await GetChainedStepAsync(businessId, nextLink.NextStepId, null, null);\n\n//            if (followUpStep == null)\n//            {\n//                Log.Warning(\"‚ùå Follow-up step skipped due to condition mismatch ‚Üí StepId: {StepId}\", nextLink.NextStepId);\n\n//                // 2Ô∏è‚É£ Optional fallback: Try same flow ‚Üí Any step without conditions\n//                var flow = await _context.CTAFlowConfigs\n//                    .Include(f => f.Steps)\n//                    .FirstOrDefaultAsync(f => f.BusinessId == businessId && f.IsPublished);\n\n//                followUpStep = flow?.Steps\n//                    .Where(s => string.IsNullOrEmpty(s.RequiredTag) && string.IsNullOrEmpty(s.RequiredSource))\n//                    .OrderBy(s => s.StepOrder)\n//                    .FirstOrDefault();\n\n//                if (followUpStep != null)\n//                {\n//                    Log.Information(\"üîÅ Fallback step selected ‚Üí StepId: {StepId}, Template: {Template}\",\n//                        followUpStep.Id, followUpStep.TemplateToSend);\n//                }\n//                else\n//                {\n//                    Log.Warning(\"üö´ No suitable fallback found in flow. Skipping follow-up.\");\n//                    return ResponseResult.SuccessInfo(\"No matching follow-up step based on user context.\");\n//                }\n//            }\n\n\n//            // üì® Send the follow-up message using the TemplateToSend field\n//            try\n//            {\n//                var template = followUpStep.TemplateToSend;\n\n//                Log.Information(\"üì§ Sending follow-up message ‚Üí Template: {Template}, To: {Recipient}\", template, recipientNumber);\n\n//                // üß™ Replace this with actual message engine call\n//                var sendDto = new SimpleTemplateMessageDto\n//                {\n//                    RecipientNumber = recipientNumber,\n//                    TemplateName = template,\n//                    TemplateParameters = new List<string>() // Add dynamic params later if needed\n//                };\n\n//                var sendResult = await _messageEngineService\n//     .SendTemplateMessageSimpleAsync(businessId, sendDto);\n\n//                if (!sendResult.Success)\n//                {\n//                    Log.Warning(\"‚ùå Follow-up message send failed ‚Üí {Template}\", template);\n//                    return ResponseResult.ErrorInfo(\"Follow-up send failed.\", sendResult.ErrorMessage);\n//                }\n\n\n//                return ResponseResult.SuccessInfo($\"Follow-up message sent using template: {template}\", null, sendResult.RawResponse);\n\n//            }\n//            catch (Exception ex)\n//            {\n//                Log.Error(ex, \"‚ùå Error sending follow-up message for StepId: {StepId}\", followUpStep.Id);\n//                return ResponseResult.ErrorInfo(\"Failed to send follow-up.\");\n//            }\n//        }\n//        public Task<CTAFlowStep?> GetChainedStepAsync(Guid businessId, Guid? nextStepId)\n//        {\n//            return GetChainedStepAsync(businessId, nextStepId, null, null); // Forward to full logic\n//        }\n\n//        // ‚úÖ Extended logic with condition check (Tag + Source)\n//        public async Task<CTAFlowStep?> GetChainedStepAsync(\n//            Guid businessId,\n//            Guid? nextStepId,\n//            TrackingLog? trackingLog = null,\n//            Contact? contact = null)\n//        {\n//            if (nextStepId == null)\n//            {\n//                Log.Information(\"‚ÑπÔ∏è No NextStepId provided ‚Äî skipping follow-up.\");\n//                return null;\n//            }\n\n//            try\n//            {\n//                var flow = await _context.CTAFlowConfigs\n//                    .Include(f => f.Steps)\n//                    .FirstOrDefaultAsync(f =>\n//                        f.BusinessId == businessId &&\n//                        f.Steps.Any(s => s.Id == nextStepId));\n\n//                if (flow == null)\n//                {\n//                    Log.Warning(\"‚ö†Ô∏è No flow found containing NextStepId: {NextStepId} for business: {BusinessId}\", nextStepId, businessId);\n//                    return null;\n//                }\n\n//                var followUpStep = flow.Steps.FirstOrDefault(s => s.Id == nextStepId);\n\n//                if (followUpStep == null)\n//                {\n//                    Log.Warning(\"‚ùå Step matched in flow but not found in step list: {NextStepId}\", nextStepId);\n//                    return null;\n//                }\n\n//                // ‚úÖ Check RequiredTag / Source match\n//                if (trackingLog != null)\n//                {\n//                    var isMatch = StepMatchingHelper.IsStepMatched(followUpStep, trackingLog, contact);\n\n//                    if (!isMatch)\n//                    {\n//                        Log.Information(\"üö´ Step {StepId} skipped due to condition mismatch [Tag: {Tag}, Source: {Source}]\",\n//                            followUpStep.Id, followUpStep.RequiredTag, followUpStep.RequiredSource);\n//                        return null;\n//                    }\n//                }\n\n//                Log.Information(\"‚úÖ Follow-up step found and matched ‚Üí StepId: {StepId}, Template: {Template}\",\n//                    followUpStep.Id, followUpStep.TemplateToSend);\n\n//                return followUpStep;\n//            }\n//            catch (Exception ex)\n//            {\n//                Log.Error(ex, \"‚ùå Exception while fetching chained step for NextStepId: {NextStepId}\", nextStepId);\n//                throw;\n//            }\n//        }\n\n//        // ‚úÖ Optional helper for resolving from TrackingLogId\n//        public async Task<CTAFlowStep?> GetChainedStepWithContextAsync(\n//            Guid businessId,\n//            Guid? nextStepId,\n//            Guid? trackingLogId)\n//        {\n//            var log = await _context.TrackingLogs\n//                .Include(l => l.Contact)\n//                    .ThenInclude(c => c.ContactTags)\n//                        .ThenInclude(ct => ct.Tag)\n//                .FirstOrDefaultAsync(l => l.Id == trackingLogId);\n\n//            return await GetChainedStepAsync(businessId, nextStepId, log, log?.Contact);\n//        }\n\n\n//        public async Task<ResponseResult> ExecuteVisualFlowAsync(Guid businessId, Guid startStepId, Guid trackingLogId, Guid? campaignSendLogId)\n//        {\n//            try\n//            {\n//                Log.Information(\"üö¶ Executing Visual Flow ‚Üí StepId: {StepId} | TrackingLogId: {TrackingLogId}\", startStepId, trackingLogId);\n\n//                // ‚îÄ‚îÄ local helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n//                static string ResolveGreeting(string? profileName, string? contactName)\n//                {\n//                    var s = (profileName ?? contactName)?.Trim();\n//                    return string.IsNullOrEmpty(s) ? \"there\" : s;\n//                }\n//                static void EnsureArgsLength(List<string> args, int slot1Based)\n//                {\n//                    while (args.Count < slot1Based) args.Add(string.Empty);\n//                }\n//                // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n//                var log = await _context.TrackingLogs\n//                    .Include(l => l.Contact)\n//                        .ThenInclude(c => c.ContactTags)\n//                            .ThenInclude(ct => ct.Tag)\n//                    .FirstOrDefaultAsync(l => l.Id == trackingLogId);\n\n//                if (log == null)\n//                {\n//                    Log.Warning(\"‚ùå TrackingLog not found for ID: {TrackingLogId}\", trackingLogId);\n//                    return ResponseResult.ErrorInfo(\"Tracking log not found.\");\n//                }\n\n//                var step = await GetChainedStepAsync(businessId, startStepId, log, log?.Contact);\n\n//                if (step == null)\n//                {\n//                    Log.Warning(\"‚ùå No flow step matched or conditions failed ‚Üí StepId: {StepId}\", startStepId);\n//                    return ResponseResult.ErrorInfo(\"Step conditions not satisfied.\");\n//                }\n\n//                // ‚úÖ Build profile-aware args for this step (used for text templates)\n//                var args = new List<string>();\n//                if (step.UseProfileName && step.ProfileNameSlot is int slot && slot >= 1)\n//                {\n//                    // Prefer the already-loaded contact on the tracking log; fallback to DB lookup\n//                    var contact = log.Contact ?? await _context.Contacts\n//                        .AsNoTracking()\n//                        .FirstOrDefaultAsync(c => c.BusinessId == businessId && c.PhoneNumber == (log.ContactPhone ?? \"\"));\n\n//                    var greet = ResolveGreeting(contact?.ProfileName, contact?.Name);\n//                    EnsureArgsLength(args, slot);\n//                    args[slot - 1] = greet; // 1-based slot -> 0-based index\n//                }\n\n//                ResponseResult sendResult;\n\n//                // This switch block remains unchanged, except we pass args for text templates\n//                switch (step.TemplateType?.ToLower())\n//                {\n//                    case \"image_template\":\n//                        var imageDto = new ImageTemplateMessageDto\n//                        {\n//                            BusinessId = businessId,\n//                            RecipientNumber = log.ContactPhone ?? \"\",\n//                            TemplateName = step.TemplateToSend,\n//                            LanguageCode = \"en_US\"\n//                            // If your image templates support body params, you can also pass args here.\n//                        };\n//                        sendResult = await _messageEngineService.SendImageTemplateMessageAsync(imageDto, businessId);\n//                        break;\n\n//                    case \"text_template\":\n//                    default:\n//                        var textDto = new SimpleTemplateMessageDto\n//                        {\n//                            RecipientNumber = log.ContactPhone ?? \"\",\n//                            TemplateName = step.TemplateToSend,\n//                            TemplateParameters = args // ‚úÖ inject ProfileName here when configured\n//                        };\n//                        sendResult = await _messageEngineService.SendTemplateMessageSimpleAsync(businessId, textDto);\n//                        break;\n//                }\n\n//                // ‚úÖ 2. SAVE the new ID to the log\n//                var executionLog = new FlowExecutionLog\n//                {\n//                    Id = Guid.NewGuid(),\n//                    BusinessId = businessId,\n//                    StepId = step.Id,\n//                    FlowId = step.CTAFlowConfigId,\n//                    CampaignSendLogId = campaignSendLogId, // <-- THE NEW VALUE IS SAVED HERE\n//                    TrackingLogId = trackingLogId,\n//                    ContactPhone = log.ContactPhone,\n//                    TriggeredByButton = step.TriggerButtonText,\n//                    TemplateName = step.TemplateToSend,\n//                    TemplateType = step.TemplateType,\n//                    Success = sendResult.Success,\n//                    ErrorMessage = sendResult.ErrorMessage,\n//                    RawResponse = sendResult.RawResponse,\n//                    ExecutedAt = DateTime.UtcNow\n//                };\n\n//                _context.FlowExecutionLogs.Add(executionLog);\n//                await _context.SaveChangesAsync();\n\n//                if (sendResult.Success)\n//                {\n//                    Log.Information(\"‚úÖ Flow step executed ‚Üí Template: {Template} sent to {To}\", step.TemplateToSend, log.ContactPhone);\n//                }\n//                else\n//                {\n//                    Log.Warning(\"‚ùå Failed to send template from flow ‚Üí {Reason}\", sendResult.ErrorMessage);\n//                }\n\n//                return ResponseResult.SuccessInfo($\"Flow step executed. Sent: {sendResult.Success}\", null, sendResult.RawResponse);\n//            }\n//            catch (Exception ex)\n//            {\n//                Log.Error(ex, \"‚ùå Exception during ExecuteVisualFlowAsync()\");\n//                return ResponseResult.ErrorInfo(\"Internal error during flow execution.\");\n//            }\n//        }\n\n//        public async Task<FlowButtonLink?> GetLinkAsync(Guid flowId, Guid sourceStepId, short buttonIndex)\n//        {\n//            return await _context.FlowButtonLinks\n//                 .Where(l => l.CTAFlowStepId == sourceStepId\n//              && l.NextStepId != null\n//              && l.Step.CTAFlowConfigId == flowId\n//              && l.ButtonIndex == buttonIndex)\n//                .SingleOrDefaultAsync();\n\n//        }\n//        //public async Task<IReadOnlyList<AttachedCampaignDto>> GetAttachedCampaignsAsync(Guid flowId, Guid businessId)\n//        //{\n//        //    return await _context.Campaigns\n//        //        .Where(c => c.BusinessId == businessId\n//        //                    && !c.IsDeleted\n//        //                    && c.CTAFlowConfigId == flowId)\n//        //        .OrderByDescending(c => c.CreatedAt)\n//        //        .Select(c => new AttachedCampaignDto(c.Id, c.Name, c.Status, c.ScheduledAt))\n//        //        .ToListAsync();\n//        //}\n\n//        public async Task<ResponseResult> GetVisualFlowAsync(Guid flowId, Guid businessId)\n//        {\n//            try\n//            {\n//                // Load the flow + steps + button links (no tracking for view)\n//                var flow = await _context.CTAFlowConfigs\n//                    .AsNoTracking()\n//                    .Where(f => f.IsActive && f.BusinessId == businessId && f.Id == flowId)\n//                    .Select(f => new\n//                    {\n//                        f.Id,\n//                        f.FlowName,\n//                        f.IsPublished,\n//                        Steps = _context.CTAFlowSteps\n//                            .Where(s => s.CTAFlowConfigId == f.Id)\n//                            .OrderBy(s => s.StepOrder)\n//                            .Select(s => new\n//                            {\n//                                s.Id,\n//                                s.StepOrder,\n//                                s.TemplateToSend,\n//                                s.TemplateType,\n//                                s.TriggerButtonText,\n//                                s.TriggerButtonType,\n//                                s.PositionX,\n//                                s.PositionY,\n//                                s.UseProfileName,\n//                                s.ProfileNameSlot,\n//                                Buttons = _context.FlowButtonLinks\n//                                    .Where(b => b.CTAFlowStepId == s.Id)\n//                                    .OrderBy(b => b.ButtonIndex)\n//                                    .Select(b => new\n//                                    {\n//                                        b.ButtonText,\n//                                        b.ButtonType,\n//                                        b.ButtonSubType,\n//                                        b.ButtonValue,\n//                                        b.ButtonIndex,\n//                                        b.NextStepId\n//                                    })\n//                                    .ToList()\n//                            })\n//                            .ToList()\n//                    })\n//                    .FirstOrDefaultAsync();\n\n//                if (flow == null)\n//                {\n//                    return ResponseResult.ErrorInfo(\"Flow not found.\");\n//                }\n\n//                // Map to FE shape\n//                var nodes = flow.Steps.Select(s => new\n//                {\n//                    id = s.Id.ToString(), // node id = step id\n//                    positionX = s.PositionX ?? 0,\n//                    positionY = s.PositionY ?? 0,\n//                    templateName = s.TemplateToSend,\n//                    templateType = s.TemplateType,\n//                    triggerButtonText = s.TriggerButtonText ?? string.Empty,\n//                    triggerButtonType = s.TriggerButtonType ?? \"cta\",\n//                    requiredTag = string.Empty,       // not used in your model; keep empty\n//                    requiredSource = string.Empty,    // not used; keep empty\n//                    useProfileName = s.UseProfileName,\n//                    profileNameSlot = (s.ProfileNameSlot.HasValue && s.ProfileNameSlot.Value > 0) ? s.ProfileNameSlot.Value : 1,\n//                    buttons = s.Buttons.Select(b => new\n//                    {\n//                        text = b.ButtonText,\n//                        type = b.ButtonType,\n//                        subType = b.ButtonSubType,\n//                        value = b.ButtonValue,\n//                        targetNodeId = b.NextStepId == Guid.Empty ? null : b.NextStepId.ToString(),\n//                        index = (int)(b.ButtonIndex)\n//                    })\n//                });\n\n//                // Build edges from button links\n//                var edges = flow.Steps\n//                    .SelectMany(s => s.Buttons\n//                        .Where(b => b.NextStepId != Guid.Empty)\n//                        .Select(b => new\n//                        {\n//                            fromNodeId = s.Id.ToString(),\n//                            toNodeId = b.NextStepId.ToString(),\n//                            sourceHandle = b.ButtonText // label/handle = button text\n//                        }));\n\n//                var payload = new\n//                {\n//                    flowName = flow.FlowName,\n//                    isPublished = flow.IsPublished,\n//                    nodes,\n//                    edges\n//                };\n\n//                return ResponseResult.SuccessInfo(\"Flow loaded.\", payload);\n//            }\n//            catch (Exception ex)\n//            {\n//                Log.Error(ex, \"‚ùå Exception while loading visual flow {FlowId}\", flowId);\n//                return ResponseResult.ErrorInfo(\"Internal error while loading flow.\");\n//            }\n//        }\n//        public async Task<IReadOnlyList<AttachedCampaignDto>> GetAttachedCampaignsAsync(Guid flowId, Guid businessId)\n//        {\n//            // base query: attached, non-deleted\n//            var q = _context.Campaigns\n//                .Where(c => c.BusinessId == businessId && !c.IsDeleted && c.CTAFlowConfigId == flowId);\n\n//            // earliest send per campaign\n//            var firstSends = await _context.CampaignSendLogs\n//                .Where(s => s.BusinessId == businessId && s.CampaignId != Guid.Empty)\n//                .GroupBy(s => s.CampaignId)\n//                .Select(g => new { CampaignId = g.Key, FirstSentAt = (DateTime?)g.Min(s => s.CreatedAt) })\n//                .ToListAsync();\n\n//            var firstSendMap = firstSends.ToDictionary(x => x.CampaignId, x => x.FirstSentAt);\n\n//            var list = await q\n//                .OrderByDescending(c => c.CreatedAt)\n//                .Select(c => new\n//                {\n//                    c.Id,\n//                    c.Name,\n//                    c.Status,\n//                    c.ScheduledAt,\n//                    c.CreatedAt,\n//                    c.CreatedBy\n//                })\n//                .ToListAsync();\n\n//            return list.Select(x => new AttachedCampaignDto(\n//                x.Id,\n//                x.Name,\n//                x.Status,\n//                x.ScheduledAt,\n//                x.CreatedAt,\n//                x.CreatedBy,\n//                firstSendMap.TryGetValue(x.Id, out var ts) ? ts : null\n//            )).ToList();\n//        }\n//        public async Task<bool> HardDeleteFlowIfUnusedAsync(Guid flowId, Guid businessId)\n//        {\n//            // Load flow + children\n//            var flow = await _context.CTAFlowConfigs\n//                .Include(f => f.Steps)\n//                    .ThenInclude(s => s.ButtonLinks)\n//                .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId);\n\n//            if (flow is null) return false;\n\n//            // Guard: any active campaign still attached?\n//            var attached = await _context.Campaigns\n//                .Where(c => c.BusinessId == businessId\n//                            && !c.IsDeleted\n//                            && c.CTAFlowConfigId == flowId)\n//                .Select(c => c.Id)\n//                .Take(1)\n//                .AnyAsync();\n\n//            if (attached) return false;\n\n//            // Hard delete (children first; FK-safe)\n//            foreach (var step in flow.Steps)\n//                _context.FlowButtonLinks.RemoveRange(step.ButtonLinks);\n\n//            _context.CTAFlowSteps.RemoveRange(flow.Steps);\n//            _context.CTAFlowConfigs.Remove(flow);\n\n//            await _context.SaveChangesAsync();\n//            return true;\n//        }\n\n//        //public async Task<FlowUpdateResult> UpdateVisualFlowAsync(Guid flowId, SaveVisualFlowDto dto, Guid businessId, string user)\n//        //{\n//        //    var flow = await _context.CTAFlowConfigs\n//        //        .Include(f => f.Steps)\n//        //            .ThenInclude(s => s.ButtonLinks)\n//        //        .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId);\n\n//        //    if (flow is null)\n//        //        return new FlowUpdateResult { Status = \"notFound\", Message = \"Flow not found.\" };\n\n//        //    var attached = await _context.Campaigns\n//        //        .Where(c => !c.IsDeleted && c.BusinessId == businessId && c.CTAFlowConfigId == flowId)\n//        //        .Select(c => new { c.Id, c.Name, c.Status, c.ScheduledAt, c.CreatedAt, c.CreatedBy })\n//        //        .ToListAsync();\n\n//        //    if (flow.IsPublished && attached.Count > 0)\n//        //    {\n//        //        return new FlowUpdateResult\n//        //        {\n//        //            Status = \"requiresFork\",\n//        //            Message = \"This flow is published and attached to campaign(s). Create a new draft version.\",\n//        //            Campaigns = attached\n//        //        };\n//        //    }\n\n//        //    var needsRepublish = flow.IsPublished && attached.Count == 0;\n//        //    if (needsRepublish) flow.IsPublished = false; // flip to draft during edit\n\n//        //    // wipe & rebuild steps (simplest and consistent with your builder payload)\n//        //    _context.FlowButtonLinks.RemoveRange(flow.Steps.SelectMany(s => s.ButtonLinks));\n//        //    _context.CTAFlowSteps.RemoveRange(flow.Steps);\n//        //    await _context.SaveChangesAsync();\n\n//        //    flow.FlowName = string.IsNullOrWhiteSpace(dto.FlowName) ? flow.FlowName : dto.FlowName.Trim();\n//        //    flow.UpdatedAt = DateTime.UtcNow;\n\n//        //    var newSteps = new List<CTAFlowStep>();\n//        //    var nodeIdToNewGuid = new Dictionary<string, Guid>();\n\n//        //    // 1) create steps with new IDs but keep mapping from incoming node.Id\n//        //    foreach (var n in dto.Nodes)\n//        //    {\n//        //        var stepId = Guid.TryParse(n.Id, out var parsed) ? parsed : Guid.NewGuid();\n//        //        nodeIdToNewGuid[n.Id] = stepId;\n\n//        //        var s = new CTAFlowStep\n//        //        {\n//        //            Id = stepId,\n//        //            CTAFlowConfigId = flow.Id,\n//        //            TemplateToSend = n.TemplateName ?? string.Empty,\n//        //            TemplateType = n.TemplateType,\n//        //            TriggerButtonText = n.TriggerButtonText ?? \"\",\n//        //            TriggerButtonType = n.TriggerButtonType ?? \"\",\n//        //            StepOrder = 0,\n//        //            RequiredTag = n.RequiredTag,\n//        //            RequiredSource = n.RequiredSource,\n//        //            PositionX = n.PositionX,\n//        //            PositionY = n.PositionY,\n//        //            UseProfileName = n.UseProfileName,\n//        //            ProfileNameSlot = n.ProfileNameSlot\n//        //        };\n\n//        //        s.ButtonLinks = (n.Buttons ?? new List<LinkButtonDto>())\n//        //            .Select((b, idx) => new FlowButtonLink\n//        //            {\n//        //                Id = Guid.NewGuid(),\n//        //                CTAFlowStepId = s.Id,\n//        //                Step = s,\n//        //                ButtonText = b.Text ?? \"\",\n//        //                ButtonType = b.Type ?? \"QUICK_REPLY\",\n//        //                ButtonSubType = b.SubType ?? \"\",\n//        //                ButtonValue = b.Value ?? \"\",\n//        //                ButtonIndex = (short)(b.Index >= 0 ? b.Index : idx),\n//        //                NextStepId = string.IsNullOrWhiteSpace(b.TargetNodeId) ? null :\n//        //                             (Guid.TryParse(b.TargetNodeId, out var t) ? t : null)\n//        //            }).ToList();\n\n//        //        newSteps.Add(s);\n//        //    }\n\n//        //    flow.Steps = newSteps;\n//        //    await _context.SaveChangesAsync();\n\n//        //    return new FlowUpdateResult { Status = \"ok\", NeedsRepublish = needsRepublish };\n//        //}\n\n//        //public async Task<bool> PublishFlowAsync(Guid flowId, Guid businessId, string user)\n//        //{\n//        //    var flow = await _context.CTAFlowConfigs\n//        //        .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId);\n\n//        //    if (flow is null) return false;\n\n//        //    // sanity: basic validation can be added here (has steps, etc.)\n//        //    flow.IsPublished = true;\n//        //    flow.UpdatedAt = DateTime.UtcNow;\n//        //    await _context.SaveChangesAsync();\n//        //    return true;\n//        //}\n\n//        // ---------- FORK (create draft copy) ----------\n//        //public async Task<Guid> ForkFlowAsync(Guid flowId, Guid businessId, string user)\n//        //{\n//        //    var src = await _context.CTAFlowConfigs\n//        //        .Include(f => f.Steps)\n//        //            .ThenInclude(s => s.ButtonLinks)\n//        //        .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId);\n\n//        //    if (src is null) return Guid.Empty;\n\n//        //    var dst = new CTAFlowConfig\n//        //    {\n//        //        Id = Guid.NewGuid(),\n//        //        BusinessId = src.BusinessId,\n//        //        FlowName = src.FlowName + \" (copy)\",\n//        //        IsActive = true,\n//        //        IsPublished = false, // new draft\n//        //        CreatedAt = DateTime.UtcNow,\n//        //        CreatedBy = user,\n//        //        UpdatedAt = DateTime.UtcNow\n//        //    };\n\n//        //    var oldToNew = new Dictionary<Guid, Guid>();\n\n//        //    // Clone steps first\n//        //    foreach (var s in src.Steps)\n//        //    {\n//        //        var nsId = Guid.NewGuid();\n//        //        oldToNew[s.Id] = nsId;\n\n//        //        var ns = new CTAFlowStep\n//        //        {\n//        //            Id = nsId,\n//        //            CTAFlowConfigId = dst.Id,\n//        //            TriggerButtonText = s.TriggerButtonText,\n//        //            TriggerButtonType = s.TriggerButtonType,\n//        //            TemplateToSend = s.TemplateToSend,\n//        //            TemplateType = s.TemplateType,\n//        //            StepOrder = s.StepOrder,\n//        //            RequiredTag = s.RequiredTag,\n//        //            RequiredSource = s.RequiredSource,\n//        //            PositionX = s.PositionX,\n//        //            PositionY = s.PositionY,\n//        //            UseProfileName = s.UseProfileName,\n//        //            ProfileNameSlot = s.ProfileNameSlot,\n//        //            ButtonLinks = new List<FlowButtonLink>()\n//        //        };\n\n//        //        dst.Steps.Add(ns);\n//        //    }\n\n//        //    // Clone links and rewire targets if possible\n//        //    foreach (var s in src.Steps)\n//        //    {\n//        //        var ns = dst.Steps.First(x => x.Id == oldToNew[s.Id]);\n//        //        foreach (var b in s.ButtonLinks.OrderBy(x => x.ButtonIndex))\n//        //        {\n//        //            ns.ButtonLinks.Add(new FlowButtonLink\n//        //            {\n//        //                Id = Guid.NewGuid(),\n//        //                CTAFlowStepId = ns.Id,\n//        //                Step = ns,\n//        //                ButtonText = b.ButtonText,\n//        //                ButtonType = b.ButtonType,\n//        //                ButtonSubType = b.ButtonSubType,\n//        //                ButtonValue = b.ButtonValue,\n//        //                ButtonIndex = b.ButtonIndex,\n//        //                NextStepId = b.NextStepId.HasValue && oldToNew.ContainsKey(b.NextStepId.Value)\n//        //                    ? oldToNew[b.NextStepId.Value]\n//        //                    : null\n//        //            });\n//        //        }\n//        //    }\n\n//        //    _context.CTAFlowConfigs.Add(dst);\n//        //    await _context.SaveChangesAsync();\n//        //    return dst.Id;\n//        //}\n\n\n//    }\n//}\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Services/ExtrackAllFiles.bat",
      "sha256": "3d14ccc013b9fd82ff0759820acc71da52821878e664cb4daa9418062278e799",
      "language": "bat",
      "size": 922,
      "content": "@echo off\nREM This script will find all files and output their name and content into one file.\nREM The output file will be named [FolderName]_AllFileDump.txt.\n\nREM Get the current folder's name and set it as the output file name with the custom suffix\nfor %%I in (\"%cd%\") do set \"outputFile=%%~nI_AllFileDump.txt\"\n\nREM Clear the output file to start fresh\n> \"%outputFile%\" (echo Folder and File Content Report)\necho. >> \"%outputFile%\"\n\nREM Loop through all files in the current directory and subdirectories\nfor /R . %%F in (*.*) do (\n    echo ====================================================== >> \"%outputFile%\"\n    echo FILE: %%F >> \"%outputFile%\"\n    echo ====================================================== >> \"%outputFile%\"\n    echo. >> \"%outputFile%\"\n    type \"%%F\" >> \"%outputFile%\" 2>nul\n    echo. >> \"%outputFile%\"\n    echo. >> \"%outputFile%\"\n)\n\necho Finished! All content has been extracted to %outputFile%"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Services/FlowExecutionLogger.cs",
      "sha256": "3b6ad9e86868b5c7f7f39fca399fb43a86693d088ae149f2ea9d14b7adb7a933",
      "language": "csharp",
      "size": 6046,
      "content": "// üìÑ xbytechat-api/Features/CTAFlowBuilder/Services/FlowExecutionLogger.cs\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Serilog;\nusing xbytechat.api; // ‚úÖ Needed so AppDbContext is in scope\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Services\n{\n    /// <summary>\n    /// Default implementation of IFlowExecutionLogger.\n    /// Writes origin-tagged rows into FlowExecutionLogs.\n    /// </summary>\n    public sealed class FlowExecutionLogger : IFlowExecutionLogger\n    {\n        private readonly AppDbContext _db;\n\n        public FlowExecutionLogger(AppDbContext db)\n        {\n            _db = db ?? throw new ArgumentNullException(nameof(db));\n        }\n\n        public async Task LogStepAsync(FlowExecutionContext context, CancellationToken cancellationToken = default)\n        {\n            if (context == null) throw new ArgumentNullException(nameof(context));\n\n            try\n            {\n                var entity = new FlowExecutionLog\n                {\n                    Id = Guid.NewGuid(),\n\n                    // core identifiers\n                    RunId = context.RunId,\n                    BusinessId = context.BusinessId,\n                    FlowId = context.FlowId,\n                    StepId = context.StepId,\n                    StepName = context.StepName ?? string.Empty,\n\n                    // origin + linkage\n                    Origin = context.Origin,\n                    CampaignId = context.CampaignId,\n                    AutoReplyFlowId = context.AutoReplyFlowId,\n                    CampaignSendLogId = context.CampaignSendLogId,\n                    TrackingLogId = context.TrackingLogId,\n                    MessageLogId = context.MessageLogId,\n\n                    // contact + button context\n                    ContactPhone = context.ContactPhone,\n                    TriggeredByButton = context.TriggeredByButton,\n                    ButtonIndex = context.ButtonIndex,\n\n                    // template / execution info\n                    TemplateName = context.TemplateName,\n                    TemplateType = context.TemplateType,\n                    Success = context.Success,\n                    ErrorMessage = context.ErrorMessage,\n                    RawResponse = context.RawResponse,\n\n                    // timestamps + tracing\n                    ExecutedAt = context.ExecutedAtUtc ?? DateTime.UtcNow,\n                    RequestId = context.RequestId\n                };\n\n                _db.FlowExecutionLogs.Add(entity);\n                await _db.SaveChangesAsync(cancellationToken);\n            }\n            catch (Exception ex)\n            {\n                // Never let logging failures break main flow execution.\n                Log.Error(\n                    ex,\n                    \"‚ùå Failed to write FlowExecutionLog | Biz={BusinessId} Origin={Origin} Flow={FlowId} Step={StepId}\",\n                    context.BusinessId,\n                    context.Origin,\n                    context.FlowId,\n                    context.StepId\n                );\n            }\n        }\n    }\n}\n\n\n//using System;\n//using System.Threading;\n//using System.Threading.Tasks;\n//using Serilog;\n//using xbytechat.api.Features.AutoReplyBuilder.DTOs;\n//using xbytechat.api.Features.CTAFlowBuilder.Models;\n\n//namespace xbytechat.api.Features.CTAFlowBuilder.Services\n//{\n//    /// <summary>\n//    /// Default implementation of IFlowExecutionLogger.\n//    /// Writes origin-tagged rows into FlowExecutionLogs.\n//    /// </summary>\n//    public sealed class FlowExecutionLogger : IFlowExecutionLogger\n//    {\n//        private readonly AppDbContext _db;\n\n//        public FlowExecutionLogger(AppDbContext db)\n//        {\n//            _db = db ?? throw new ArgumentNullException(nameof(db));\n//        }\n\n//        public async Task LogStepAsync(FlowExecutionContext context, CancellationToken cancellationToken = default)\n//        {\n//            if (context == null) throw new ArgumentNullException(nameof(context));\n\n//            try\n//            {\n//                var entity = new FlowExecutionLog\n//                {\n//                    Id = Guid.NewGuid(),\n//                    RunId = context.RunId,\n//                    BusinessId = context.BusinessId,\n//                    StepId = context.StepId,\n//                    StepName = context.StepName ?? string.Empty,\n//                    FlowId = context.FlowId,\n//                    Origin = context.Origin,\n//                    CampaignId = context.CampaignId,\n//                    AutoReplyFlowId = context.AutoReplyFlowId,\n//                    CampaignSendLogId = context.CampaignSendLogId,\n//                    TrackingLogId = context.TrackingLogId,\n//                    ContactPhone = context.ContactPhone,\n//                    TriggeredByButton = context.TriggeredByButton,\n//                    TemplateName = context.TemplateName,\n//                    TemplateType = context.TemplateType,\n//                    Success = context.Success,\n//                    ErrorMessage = context.ErrorMessage,\n//                    RawResponse = context.RawResponse,\n//                    ExecutedAt = context.ExecutedAtUtc ?? DateTime.UtcNow,\n//                    MessageLogId = context.MessageLogId,\n//                    ButtonIndex = context.ButtonIndex,\n//                    RequestId = context.RequestId\n//                };\n\n//                _db.FlowExecutionLogs.Add(entity);\n//                await _db.SaveChangesAsync(cancellationToken);\n//            }\n//            catch (Exception ex)\n//            {\n//                // We never want logging failures to break the main flow.\n//                Log.Error(ex,\n//                    \"‚ùå Failed to write FlowExecutionLog | Biz={BusinessId} Origin={Origin} Flow={FlowId} Step={StepId}\",\n//                    context.BusinessId,\n//                    context.Origin,\n//                    context.FlowId,\n//                    context.StepId);\n//            }\n//        }\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Services/FlowRuntimeService.cs",
      "sha256": "87e5773c5b57ae97fec595755c6c89b12b7c48122ec7925bf2a926dcfe591f57",
      "language": "csharp",
      "size": 50764,
      "content": "using Microsoft.EntityFrameworkCore;\nusing System.Text.Json;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.Features.Webhooks.Services.Processors;\nusing xbytechat.api.WhatsAppSettings.Services;\nusing xbytechat_api.WhatsAppSettings.Services;\nusing xbytechat.api.Features.CustomeApi.Services;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Services\n{\n    public class FlowRuntimeService : IFlowRuntimeService\n    {\n        private readonly AppDbContext _dbContext;\n        private readonly IMessageEngineService _messageEngineService;\n        private readonly IWhatsAppTemplateFetcherService _templateFetcherService;\n        private readonly ILogger<FlowRuntimeService> _logger;\n        private readonly ICtaJourneyPublisher _ctaPublisher;\n        private readonly IWhatsAppSettingsService _whatsAppSettingsService;\n        private readonly IWhatsAppSenderService _whatsAppSenderService;\n        public FlowRuntimeService(\n            AppDbContext dbContext,\n            IMessageEngineService messageEngineService,\n            IWhatsAppTemplateFetcherService templateFetcherService,\n            ILogger<FlowRuntimeService> logger,\n            ICtaJourneyPublisher ctaPublisher,\n            IWhatsAppSettingsService whatsAppSettingsService,\n            IWhatsAppSenderService whatsAppSenderService)\n        {\n            _dbContext = dbContext;\n            _messageEngineService = messageEngineService;\n            _templateFetcherService = templateFetcherService;\n            _logger = logger;\n            _ctaPublisher = ctaPublisher;\n            _whatsAppSettingsService = whatsAppSettingsService;\n            _whatsAppSenderService = whatsAppSenderService;\n        }\n\n        private static string ResolveGreeting(string? profileName, string? contactName)\n        {\n            var s = (profileName ?? contactName)?.Trim();\n            return string.IsNullOrEmpty(s) ? \"there\" : s;\n        }\n        private static void EnsureArgsLength(List<string> args, int slot1Based)\n        {\n            while (args.Count < slot1Based) args.Add(string.Empty);\n        }\n\n        // NOTE: Keep provider normalization consistent across settings/campaign/webhook/runtime paths.\n        // Also enforces \"META\" -> \"META_CLOUD\" canonical mapping.\n        private static string NormalizeProvider(string? raw)\n        {\n            if (string.IsNullOrWhiteSpace(raw)) return string.Empty;\n            var p = raw.Trim().Replace(\"-\", \"_\").Replace(\" \", \"_\").ToUpperInvariant();\n            return p == \"META\" ? \"META_CLOUD\" : p;\n        }\n\n\n        //public async Task<NextStepResult> ExecuteNextAsync(NextStepContext context)\n        //{\n        //    try\n        //    {\n        //        // ‚îÄ‚îÄ local helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n        //        string ResolveGreeting(string? profileName, string? contactName)\n        //        {\n        //            var s = (profileName ?? contactName)?.Trim();\n        //            return string.IsNullOrEmpty(s) ? \"there\" : s;\n        //        }\n        //        void EnsureArgsLength(List<string> args, int slot1Based)\n        //        {\n        //            while (args.Count < slot1Based) args.Add(string.Empty);\n        //        }\n        //        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n        //        // 1) URL-only buttons ‚Üí no WA send, just record and return redirect\n        //        if (context.ClickedButton != null &&\n        //            context.ClickedButton.ButtonType?.Equals(\"URL\", StringComparison.OrdinalIgnoreCase) == true)\n        //        {\n        //            _dbContext.FlowExecutionLogs.Add(new FlowExecutionLog\n        //            {\n        //                Id = Guid.NewGuid(),\n        //                BusinessId = context.BusinessId,\n        //                FlowId = context.FlowId,\n        //                StepId = context.SourceStepId,\n        //                StepName = \"URL_REDIRECT\",\n        //                MessageLogId = context.MessageLogId,\n        //                ButtonIndex = context.ButtonIndex,\n        //                ContactPhone = context.ContactPhone,\n        //                Success = true,\n        //                ExecutedAt = DateTime.UtcNow,\n        //                RequestId = context.RequestId\n        //            });\n        //            await _dbContext.SaveChangesAsync();\n\n        //            return new NextStepResult { Success = true, RedirectUrl = context.ClickedButton.ButtonValue };\n\n\n\n        //        }\n\n        //        // 2) Load next step in the same flow (no dedupe/loop guard ‚Äî always proceed)\n        //        var targetStep = await _dbContext.CTAFlowSteps\n        //            .Include(s => s.ButtonLinks)\n        //            .FirstOrDefaultAsync(s => s.Id == context.TargetStepId &&\n        //                                      s.CTAFlowConfigId == context.FlowId);\n\n        //        if (targetStep == null)\n        //            return new NextStepResult { Success = false, Error = \"Target step not found.\" };\n\n        //        if (string.IsNullOrWhiteSpace(targetStep.TemplateToSend))\n        //            return new NextStepResult { Success = false, Error = \"Target step has no template assigned.\" };\n\n        //        var templateName = targetStep.TemplateToSend.Trim();\n\n        //        // 3) Preflight the template (resolve language and catch 132001 early)\n        //        var meta = await _templateFetcherService.GetTemplateByNameAsync(\n        //            context.BusinessId, templateName, includeButtons: true);\n\n        //        if (meta == null)\n        //        {\n        //            _dbContext.FlowExecutionLogs.Add(new FlowExecutionLog\n        //            {\n        //                Id = Guid.NewGuid(),\n        //                BusinessId = context.BusinessId,\n        //                FlowId = context.FlowId,\n        //                StepId = targetStep.Id,\n        //                StepName = templateName,\n        //                MessageLogId = null,\n        //                ButtonIndex = context.ButtonIndex,\n        //                ContactPhone = context.ContactPhone,\n        //                Success = false,\n        //                ErrorMessage = $\"Template '{templateName}' not found for this WABA.\",\n        //                RawResponse = null,\n        //                ExecutedAt = DateTime.UtcNow,\n        //                RequestId = context.RequestId\n        //            });\n        //            await _dbContext.SaveChangesAsync();\n\n        //            return new NextStepResult { Success = false, Error = $\"Template '{templateName}' not found or not approved.\" };\n        //        }\n\n        //        var languageCode = string.IsNullOrWhiteSpace(meta.Language) ? \"en_US\" : meta.Language;\n\n        //        // 3.1) üî• Determine sender with failsafes (NO early return for missing context)\n        //        var provider = (context.Provider ?? string.Empty).Trim().ToUpperInvariant();\n        //        var phoneNumberId = context.PhoneNumberId;\n\n        //        // If provider missing/invalid ‚Üí try active WhatsAppSettings (fast path)\n        //        if (provider != \"PINNACLE\" && provider != \"META_CLOUD\")\n        //        {\n        //            var w = await _dbContext.WhatsAppSettings\n        //                .AsNoTracking()\n        //                .Where(x => x.BusinessId == context.BusinessId && x.IsActive)\n        //                .OrderByDescending(x => x.UpdatedAt ?? x.CreatedAt)\n        //                .FirstOrDefaultAsync();\n\n        //            if (w != null)\n        //            {\n        //                provider = (w.Provider ?? \"\").Trim().ToUpperInvariant();\n        //                if (string.IsNullOrWhiteSpace(phoneNumberId))\n        //                    phoneNumberId = null; // legacy WhatsAppSettings.PhoneNumberId is intentionally not used (ESU split)\n        //            }\n        //        }\n\n        //        // If still missing provider ‚Üí hard resolve via numbers table\n        //        if (provider != \"PINNACLE\" && provider != \"META_CLOUD\")\n        //        {\n        //            var pn = await _dbContext.WhatsAppPhoneNumbers\n        //                .AsNoTracking()\n        //                .Where(n => n.BusinessId == context.BusinessId && n.IsActive)\n        //                .OrderByDescending(n => n.IsDefault)\n        //                .ThenBy(n => n.WhatsAppBusinessNumber)\n        //                .Select(n => new { n.Provider, n.PhoneNumberId })\n        //                .FirstOrDefaultAsync();\n\n        //            if (pn != null)\n        //            {\n        //                provider = (pn.Provider ?? \"\").Trim().ToUpperInvariant();\n        //                if (string.IsNullOrWhiteSpace(phoneNumberId))\n        //                    phoneNumberId = pn.PhoneNumberId;\n        //            }\n        //        }\n\n        //        if (provider != \"PINNACLE\" && provider != \"META_CLOUD\")\n        //            return new NextStepResult { Success = false, Error = \"No active WhatsApp sender configured (provider could not be resolved).\" };\n\n        //        // Ensure we have a sender id\n        //        if (string.IsNullOrWhiteSpace(phoneNumberId))\n        //        {\n        //            phoneNumberId = await _dbContext.WhatsAppPhoneNumbers\n        //                .AsNoTracking()\n        //                .Where(n => n.BusinessId == context.BusinessId\n        //                            && n.IsActive\n        //                            && n.Provider.ToUpper() == provider)\n        //                .OrderByDescending(n => n.IsDefault)\n        //                .ThenBy(n => n.WhatsAppBusinessNumber)\n        //                .Select(n => n.PhoneNumberId)\n        //                .FirstOrDefaultAsync();\n\n        //            if (string.IsNullOrWhiteSpace(phoneNumberId))\n        //                return new NextStepResult { Success = false, Error = \"Missing PhoneNumberId (no default sender configured for this provider).\" };\n        //        }\n\n        //        // ‚îÄ‚îÄ Profile-name injection into body params (optional) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n        //        var args = new List<string>();\n        //        if (targetStep.UseProfileName && targetStep.ProfileNameSlot is int slot && slot >= 1)\n        //        {\n        //            var contact = await _dbContext.Contacts\n        //                .AsNoTracking()\n        //                .FirstOrDefaultAsync(c => c.BusinessId == context.BusinessId\n        //                                          && c.PhoneNumber == context.ContactPhone);\n\n        //            var greet = ResolveGreeting(contact?.ProfileName, contact?.Name);\n        //            EnsureArgsLength(args, slot);\n        //            args[slot - 1] = greet;\n        //        }\n\n        //        var components = new List<object>();\n        //        if (args.Count > 0)\n        //        {\n        //            components.Add(new\n        //            {\n        //                type = \"body\",\n        //                parameters = args.Select(a => new { type = \"text\", text = a ?? string.Empty }).ToList()\n        //            });\n        //        }\n        //        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n        //        var payload = new\n        //        {\n        //            messaging_product = \"whatsapp\",\n        //            to = context.ContactPhone,\n        //            type = \"template\",\n        //            template = new\n        //            {\n        //                name = templateName,\n        //                language = new { code = languageCode },\n        //                components\n        //            }\n        //        };\n\n        //        // 4) SEND (explicit provider + sender) ‚Äî always attempt the POST\n        //        _logger.LogInformation(\"‚û°Ô∏è SEND-INTENT flow={Flow} step={Step} tmpl={T} to={To} provider={Prov}/{Pnid}\",\n        //            context.FlowId, targetStep.Id, templateName, context.ContactPhone, provider, phoneNumberId);\n\n        //        var sendResult = await _messageEngineService.SendPayloadAsync(\n        //            context.BusinessId,\n        //            provider,               // explicit\n        //            payload,\n        //            phoneNumberId           // explicit\n        //        );\n\n        //        // 5) Snapshot buttons for robust click mapping later\n        //        string? buttonBundleJson = null;\n        //        if (targetStep.ButtonLinks?.Count > 0)\n        //        {\n        //            var bundle = targetStep.ButtonLinks\n        //                .OrderBy(b => b.ButtonIndex)\n        //                .Select(b => new\n        //                {\n        //                    i = b.ButtonIndex,\n        //                    t = b.ButtonText ?? \"\",\n        //                    ty = b.ButtonType ?? \"QUICK_REPLY\",\n        //                    v = b.ButtonValue ?? \"\",\n        //                    ns = b.NextStepId\n        //                })\n        //                .ToList();\n\n        //            buttonBundleJson = JsonSerializer.Serialize(bundle);\n        //        }\n\n        //        // 6) Write MessageLog\n        //        var messageLog = new MessageLog\n        //        {\n        //            Id = Guid.NewGuid(),\n        //            BusinessId = context.BusinessId,\n        //            RecipientNumber = context.ContactPhone,\n        //            CTAFlowConfigId = context.FlowId,\n        //            CTAFlowStepId = targetStep.Id,\n        //            FlowVersion = context.Version,\n        //            Source = \"flow\",\n        //            RefMessageId = context.MessageLogId,\n        //            CreatedAt = DateTime.UtcNow,\n        //            Status = sendResult.Success ? \"Sent\" : \"Failed\",\n        //            MessageId = sendResult.MessageId,\n        //            ErrorMessage = sendResult.ErrorMessage,\n        //            RawResponse = sendResult.RawResponse,\n        //            ButtonBundleJson = buttonBundleJson,\n        //            MessageContent = templateName,\n        //            SentAt = sendResult.Success ? DateTime.UtcNow : (DateTime?)null\n        //        };\n\n        //        _dbContext.MessageLogs.Add(messageLog);\n\n        //        // 7) Flow execution audit row\n        //        _dbContext.FlowExecutionLogs.Add(new FlowExecutionLog\n        //        {\n        //            Id = Guid.NewGuid(),\n        //            BusinessId = context.BusinessId,\n        //            FlowId = context.FlowId,\n        //            StepId = targetStep.Id,\n        //            StepName = templateName,\n        //            MessageLogId = messageLog.Id,\n        //            ButtonIndex = context.ButtonIndex,\n        //            ContactPhone = context.ContactPhone,\n        //            Success = sendResult.Success,\n        //            ErrorMessage = sendResult.ErrorMessage,\n        //            RawResponse = sendResult.RawResponse,\n        //            ExecutedAt = DateTime.UtcNow,\n        //            RequestId = context.RequestId\n        //        });\n\n        //        await _dbContext.SaveChangesAsync();\n\n        //        return new NextStepResult\n        //        {\n        //            Success = sendResult.Success,\n        //            Error = sendResult.ErrorMessage,\n        //            RedirectUrl = null\n        //        };\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        return new NextStepResult { Success = false, Error = ex.Message };\n        //    }\n        //}\n        public async Task<NextStepResult> ExecuteNextAsync(NextStepContext context)\n        {\n            // Capture state for exception logging + failure persistence (updated as we resolve sender/template).\n            var providerForLog = NormalizeProvider(context.Provider);\n            string? phoneNumberIdForLog = string.IsNullOrWhiteSpace(context.PhoneNumberId) ? null : context.PhoneNumberId!.Trim();\n            string? templateNameForLog = null;\n            Guid? targetStepIdForLog = context.TargetStepId;\n\n            try\n            {\n                // ‚îÄ‚îÄ local helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n                string ResolveGreeting(string? profileName, string? contactName)\n                {\n                    var s = (profileName ?? contactName)?.Trim();\n                    return string.IsNullOrEmpty(s) ? \"there\" : s;\n                }\n                void EnsureArgsLength(List<string> args, int slot1Based)\n                {\n                    while (args.Count < slot1Based) args.Add(string.Empty);\n                }\n                // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n                // 1) URL-only buttons ‚Üí no WA send, just record and return redirect\n                if (context.ClickedButton != null &&\n                    context.ClickedButton.ButtonType?.Equals(\"URL\", StringComparison.OrdinalIgnoreCase) == true)\n                {\n                    _dbContext.FlowExecutionLogs.Add(new FlowExecutionLog\n                    {\n                        Id = Guid.NewGuid(),\n                        BusinessId = context.BusinessId,\n                        FlowId = context.FlowId,\n                        StepId = context.SourceStepId,\n                        StepName = \"URL_REDIRECT\",\n                        MessageLogId = context.MessageLogId,\n                        ButtonIndex = context.ButtonIndex,\n                        ContactPhone = context.ContactPhone,\n                        Success = true,\n                        ExecutedAt = DateTime.UtcNow,\n                        RequestId = context.RequestId\n                    });\n                    await _dbContext.SaveChangesAsync();\n\n                    return new NextStepResult { Success = true, RedirectUrl = context.ClickedButton.ButtonValue };\n                }\n\n                // Helpful for webhook-click observability (may be null for non-click paths).\n                var clickedBtnText = context.ClickedButton?.ButtonText;\n\n                // 2) Load next step in the same flow\n                var targetStep = await _dbContext.CTAFlowSteps\n                    .Include(s => s.ButtonLinks)\n                    .FirstOrDefaultAsync(s => s.Id == context.TargetStepId &&\n                                              s.CTAFlowConfigId == context.FlowId);\n\n                if (targetStep == null)\n                {\n                    // NOTE: Added for ESU-era click-triggered flows so failures are observable (not silent).\n                    var err = \"Target step not found.\";\n                    _logger.LogWarning(\n                        \"CTAFlow ExecuteNextAsync failed: {Error} biz={Biz} flow={Flow} srcStep={Src} targetStep={Target} to={To} btnIdx={BtnIdx} btnText='{BtnText}' providerHint={Provider}/{PhoneNumberId}\",\n                        err, context.BusinessId, context.FlowId, context.SourceStepId, context.TargetStepId, context.ContactPhone, context.ButtonIndex, clickedBtnText, context.Provider, context.PhoneNumberId);\n\n                    await RecordFailureAsync(\n                        context,\n                        // TargetStepId is nullable; store failure against SourceStepId and include target in the error message/logs.\n                        stepId: context.SourceStepId,\n                        stepName: \"TARGET_STEP_NOT_FOUND\",\n                        error: err);\n\n                    return new NextStepResult { Success = false, Error = err };\n                }\n\n                if (string.IsNullOrWhiteSpace(targetStep.TemplateToSend))\n                {\n                    var err = \"Target step has no template assigned.\";\n                    _logger.LogWarning(\n                        \"CTAFlow ExecuteNextAsync failed: {Error} biz={Biz} flow={Flow} srcStep={Src} targetStep={Target} to={To} btnIdx={BtnIdx} btnText='{BtnText}' providerHint={Provider}/{PhoneNumberId}\",\n                        err, context.BusinessId, context.FlowId, context.SourceStepId, context.TargetStepId, context.ContactPhone, context.ButtonIndex, clickedBtnText, context.Provider, context.PhoneNumberId);\n\n                    await RecordFailureAsync(\n                        context,\n                        stepId: targetStep.Id,\n                        stepName: \"NO_TEMPLATE_ASSIGNED\",\n                        error: err);\n\n                    return new NextStepResult { Success = false, Error = err };\n                }\n\n                var templateName = targetStep.TemplateToSend.Trim();\n                templateNameForLog = templateName;\n                targetStepIdForLog = targetStep.Id;\n\n                // 3) Preflight the template (you can replace with a DB read later if desired)\n                var meta = await _templateFetcherService.GetTemplateByNameAsync(\n                    context.BusinessId, templateName, includeButtons: true);\n\n                if (meta == null)\n                {\n                    _dbContext.FlowExecutionLogs.Add(new FlowExecutionLog\n                    {\n                        Id = Guid.NewGuid(),\n                        BusinessId = context.BusinessId,\n                        FlowId = context.FlowId,\n                        StepId = targetStep.Id,\n                        StepName = templateName,\n                        MessageLogId = null,\n                        ButtonIndex = context.ButtonIndex,\n                        ContactPhone = context.ContactPhone,\n                        Success = false,\n                        ErrorMessage = $\"Template '{templateName}' not found for this WABA.\",\n                        RawResponse = null,\n                        ExecutedAt = DateTime.UtcNow,\n                        RequestId = context.RequestId\n                    });\n                    await _dbContext.SaveChangesAsync();\n\n                    return new NextStepResult { Success = false, Error = $\"Template '{templateName}' not found or not approved.\" };\n                }\n\n                var languageCode = string.IsNullOrWhiteSpace(meta.Language) ? \"en_US\" : meta.Language;\n\n                // 3.1) Sender resolution (single source of truth via DTO, with context overrides)\n                string provider = NormalizeProvider(context.Provider);\n                string? phoneNumberId = string.IsNullOrWhiteSpace(context.PhoneNumberId) ? null : context.PhoneNumberId!.Trim();\n                providerForLog = provider;\n                phoneNumberIdForLog = phoneNumberId;\n\n                if (provider != \"PINNACLE\" && provider != \"META_CLOUD\" || string.IsNullOrWhiteSpace(phoneNumberId))\n                {\n                    // Pull unified settings (provider + default phone for that provider)\n                    var wa = await _whatsAppSettingsService.GetSettingsByBusinessIdAsync(context.BusinessId);\n                    if (wa == null)\n                    {\n                        var err = \"No active WhatsApp settings found.\";\n                        _logger.LogWarning(\n                            \"CTAFlow ExecuteNextAsync failed: {Error} biz={Biz} flow={Flow} srcStep={Src} targetStep={Target} tmpl={T} to={To} btnIdx={BtnIdx} btnText='{BtnText}' providerHint={Provider}/{PhoneNumberId}\",\n                            err, context.BusinessId, context.FlowId, context.SourceStepId, context.TargetStepId, templateName, context.ContactPhone, context.ButtonIndex, clickedBtnText, context.Provider, context.PhoneNumberId);\n\n                        await RecordFailureAsync(context, stepId: targetStep.Id, stepName: templateName, error: err);\n                        return new NextStepResult { Success = false, Error = err };\n                    }\n\n                    // Context wins if valid, else fall back to DTO\n                    if (provider != \"PINNACLE\" && provider != \"META_CLOUD\")\n                    {\n                        var key = (wa.Provider ?? string.Empty).Trim().ToLowerInvariant();\n                        provider = key switch\n                        {\n                            \"meta\" => \"META_CLOUD\",\n                            \"meta_cloud\" => \"META_CLOUD\",\n                            \"meta-cloud\" => \"META_CLOUD\",\n                            \"meta cloud\" => \"META_CLOUD\",\n                            \"pinnacle\" => \"PINNACLE\",\n                            _ => NormalizeProvider(wa.Provider)\n                        };\n                        providerForLog = provider;\n                    }\n\n                    if (string.IsNullOrWhiteSpace(phoneNumberId))\n                    {\n                        // ESU constraint: PhoneNumberId must come ONLY from WhatsAppPhoneNumbers.\n                        // Never read WhatsAppSettings.PhoneNumberId (legacy column).\n                        var sender = await _whatsAppSenderService.ResolveDefaultSenderAsync(\n                            context.BusinessId,\n                            providerHint: provider,\n                            ct: default);\n\n                        if (!sender.Success)\n                        {\n                            var err = sender.Error ?? \"Failed to resolve WhatsApp sender.\";\n                            _logger.LogWarning(\n                                \"CTAFlow ExecuteNextAsync failed: {Error} biz={Biz} flow={Flow} srcStep={Src} targetStep={Target} tmpl={T} to={To} btnIdx={BtnIdx} btnText='{BtnText}' provider={Provider}\",\n                                err, context.BusinessId, context.FlowId, context.SourceStepId, context.TargetStepId, templateName, context.ContactPhone, context.ButtonIndex, clickedBtnText, provider);\n\n                            await RecordFailureAsync(context, stepId: targetStep.Id, stepName: templateName, error: err);\n                            return new NextStepResult { Success = false, Error = err };\n                        }\n\n                        // Keep provider stable if already known; if not known, align to the resolved sender provider.\n                        if (provider != \"PINNACLE\" && provider != \"META_CLOUD\" && !string.IsNullOrWhiteSpace(sender.Provider))\n                            provider = NormalizeProvider(sender.Provider);\n\n                        phoneNumberId = sender.PhoneNumberId;\n                        providerForLog = provider;\n                        phoneNumberIdForLog = phoneNumberId;\n                    }\n                }\n\n                if (provider != \"PINNACLE\" && provider != \"META_CLOUD\")\n                {\n                    var err = \"No active WhatsApp sender configured (provider could not be resolved).\";\n                    _logger.LogWarning(\n                        \"CTAFlow ExecuteNextAsync failed: {Error} biz={Biz} flow={Flow} srcStep={Src} targetStep={Target} tmpl={T} to={To} btnIdx={BtnIdx} btnText='{BtnText}' provider={Provider}/{PhoneNumberId}\",\n                        err, context.BusinessId, context.FlowId, context.SourceStepId, context.TargetStepId, templateName, context.ContactPhone, context.ButtonIndex, clickedBtnText, provider, phoneNumberId);\n\n                    await RecordFailureAsync(context, stepId: targetStep.Id, stepName: templateName, error: err);\n                    return new NextStepResult { Success = false, Error = err };\n                }\n\n                if (provider == \"META_CLOUD\" && string.IsNullOrWhiteSpace(phoneNumberId))\n                {\n                    // This should only happen if WhatsAppPhoneNumbers has no active sender; log + persist to avoid silent click failures.\n                    var err = \"Missing PhoneNumberId (no default Meta sender configured).\";\n                    _logger.LogWarning(\n                        \"CTAFlow ExecuteNextAsync failed: {Error} biz={Biz} flow={Flow} srcStep={Src} targetStep={Target} tmpl={T} to={To} btnIdx={BtnIdx} btnText='{BtnText}' provider={Provider}\",\n                        err, context.BusinessId, context.FlowId, context.SourceStepId, context.TargetStepId, templateName, context.ContactPhone, context.ButtonIndex, clickedBtnText, provider);\n\n                    await RecordFailureAsync(context, stepId: targetStep.Id, stepName: templateName, error: err);\n                    return new NextStepResult { Success = false, Error = err };\n                }\n\n                // ‚îÄ‚îÄ BODY placeholder resolution (static step params + optional profile-name injection) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n                // CTA flows run from webhook clicks and do not have campaign-time personalization context, so\n                // we persist body parameter values per step (CTAFlowSteps.BodyParamsJson).\n                // NOTE: TemplateMetadataDto.PlaceholderCount includes button tokens too; use WhatsAppTemplates.BodyVarCount.\n                var bodyVarCount = await ResolveBodyVarCountAsync(context.BusinessId, templateName, meta);\n                var args = new List<string>(Math.Max(0, bodyVarCount));\n                if (bodyVarCount > 0)\n                {\n                    args.AddRange(Enumerable.Repeat(string.Empty, bodyVarCount));\n                    var stored = TryParseBodyParams(targetStep.BodyParamsJson);\n                    for (var i = 0; i < bodyVarCount && i < stored.Count; i++)\n                        args[i] = (stored[i] ?? string.Empty).Trim();\n                }\n\n                if (targetStep.UseProfileName && targetStep.ProfileNameSlot is int slot && slot >= 1)\n                {\n                    if (bodyVarCount <= 0)\n                    {\n                        _logger.LogWarning(\n                            \"CTAFlow profile-name slot configured but template has no body vars biz={Biz} flow={Flow} step={Step} tmpl={T} slot={Slot}\",\n                            context.BusinessId, context.FlowId, targetStep.Id, templateName, slot);\n                    }\n                    else if (slot <= bodyVarCount)\n                    {\n                        var contact = await _dbContext.Contacts\n                            .AsNoTracking()\n                            .FirstOrDefaultAsync(c => c.BusinessId == context.BusinessId\n                                                      && c.PhoneNumber == context.ContactPhone);\n\n                        var greet = ResolveGreeting(contact?.ProfileName, contact?.Name);\n                        args[slot - 1] = greet;\n                    }\n                }\n\n                if (bodyVarCount > 0 && args.Any(a => string.IsNullOrWhiteSpace(a)))\n                {\n                    var err = $\"Template '{templateName}' requires {bodyVarCount} body parameter(s), but one or more values are missing.\";\n                    _logger.LogWarning(\n                        \"CTAFlow ExecuteNextAsync failed: {Error} biz={Biz} flow={Flow} srcStep={Src} targetStep={Target} tmpl={T} to={To} btnIdx={BtnIdx} btnText='{BtnText}'\",\n                        err, context.BusinessId, context.FlowId, context.SourceStepId, targetStep.Id, templateName, context.ContactPhone, context.ButtonIndex, clickedBtnText);\n\n                    await RecordFailureAsync(context, stepId: targetStep.Id, stepName: templateName, error: err);\n                    return new NextStepResult { Success = false, Error = err };\n                }\n\n                var components = new List<object>();\n\n                // ‚îÄ‚îÄ Media header support (phase 1) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n                // CTA flow runtime previously sent only BODY components. For templates whose header kind is\n                // image/video/document, WhatsApp (Meta Cloud) requires a header component with a media link.\n                // Phase 2: HeaderMediaUrl is persisted per step (CTAFlowSteps.HeaderMediaUrl). We still accept an\n                // execution-context override (e.g., campaign/runtime) and keep a temporary fallback from clicked\n                // button value to avoid breaking older flows until the UI starts populating the step field.\n                var headerKind = (meta.HeaderKind ?? \"none\").Trim().ToLowerInvariant();\n                var requiresMediaHeader = headerKind is \"image\" or \"video\" or \"document\";\n                string? headerMediaUrl = string.IsNullOrWhiteSpace(context.HeaderMediaUrl) ? null : context.HeaderMediaUrl!.Trim();\n\n                if (requiresMediaHeader && string.IsNullOrWhiteSpace(headerMediaUrl))\n                {\n                    // Phase 2: Prefer persisted per-step configuration.\n                    headerMediaUrl = string.IsNullOrWhiteSpace(targetStep.HeaderMediaUrl) ? null : targetStep.HeaderMediaUrl!.Trim();\n                }\n\n                if (requiresMediaHeader && string.IsNullOrWhiteSpace(headerMediaUrl))\n                {\n                    // Temporary fallback: treat a clicked button value that looks like a URL as the media link.\n                    // This is best-effort for backward compatibility; UI should persist HeaderMediaUrl on the step.\n                    if (TryGetHttpUrl(context.ClickedButton?.ButtonValue, out var fallbackUrl))\n                    {\n                        headerMediaUrl = fallbackUrl;\n                        _logger.LogInformation(\n                            \"CTAFlow header media URL sourced from clicked button value biz={Biz} flow={Flow} srcStep={Src} targetStep={Target} tmpl={T} kind={Kind}\",\n                            context.BusinessId, context.FlowId, context.SourceStepId, targetStep.Id, templateName, headerKind);\n                    }\n                }\n\n                if (requiresMediaHeader)\n                {\n                    if (!string.Equals(provider, \"META_CLOUD\", StringComparison.OrdinalIgnoreCase))\n                    {\n                        var err = $\"CTAFlow media-header templates are not supported for provider '{provider}' yet.\";\n                        _logger.LogWarning(\n                            \"CTAFlow ExecuteNextAsync failed: {Error} biz={Biz} flow={Flow} srcStep={Src} targetStep={Target} tmpl={T} to={To} btnIdx={BtnIdx} btnText='{BtnText}' provider={Prov}\",\n                            err, context.BusinessId, context.FlowId, context.SourceStepId, targetStep.Id, templateName, context.ContactPhone, context.ButtonIndex, clickedBtnText, provider);\n\n                        await RecordFailureAsync(context, stepId: targetStep.Id, stepName: templateName, error: err);\n                        return new NextStepResult { Success = false, Error = err };\n                    }\n\n                    if (string.IsNullOrWhiteSpace(headerMediaUrl))\n                    {\n                        var err = $\"Template '{templateName}' requires a {headerKind} header, but no HeaderMediaUrl was provided.\";\n                        _logger.LogWarning(\n                            \"CTAFlow ExecuteNextAsync failed: {Error} biz={Biz} flow={Flow} srcStep={Src} targetStep={Target} tmpl={T} to={To} btnIdx={BtnIdx} btnText='{BtnText}' provider={Prov}/{Pnid}\",\n                            err, context.BusinessId, context.FlowId, context.SourceStepId, targetStep.Id, templateName, context.ContactPhone, context.ButtonIndex, clickedBtnText, provider, phoneNumberId);\n\n                        await RecordFailureAsync(context, stepId: targetStep.Id, stepName: templateName, error: err);\n                        return new NextStepResult { Success = false, Error = err };\n                    }\n\n                    object mediaParam = headerKind switch\n                    {\n                        \"image\" => new { type = \"image\", image = new { link = headerMediaUrl } },\n                        \"video\" => new { type = \"video\", video = new { link = headerMediaUrl } },\n                        \"document\" => new { type = \"document\", document = new { link = headerMediaUrl } },\n                        _ => new { type = \"text\", text = \"\" } // should not happen due to requiresMediaHeader guard\n                    };\n\n                    components.Add(new\n                    {\n                        type = \"header\",\n                        parameters = new object[] { mediaParam }\n                    });\n                }\n                // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n                if (bodyVarCount > 0)\n                {\n                    components.Add(new\n                    {\n                        type = \"body\",\n                        parameters = args.Select(a => new { type = \"text\", text = a ?? string.Empty }).ToList()\n                    });\n                }\n                // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n                // ‚îÄ‚îÄ Dynamic URL button parameters (Meta Cloud) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n                // WhatsApp Cloud requires \"button\" components when a template has dynamic URL buttons.\n                // We store per-step values in CTAFlowSteps.UrlButtonParamsJson (index 0 => button index \"0\").\n                if (string.Equals(provider, \"META_CLOUD\", StringComparison.OrdinalIgnoreCase) &&\n                    meta.ButtonParams is { Count: > 0 })\n                {\n                    var storedUrlParams = TryParseUrlButtonParams(targetStep.UrlButtonParamsJson);\n\n                    var buttons = meta.ButtonParams\n                        .OrderBy(b => b.Index)\n                        .Take(3)\n                        .ToList();\n\n                    foreach (var b in buttons)\n                    {\n                        var idx = b.Index;\n                        if (idx < 0 || idx > 2) continue;\n\n                        var isUrl =\n                            string.Equals(b.Type, \"URL\", StringComparison.OrdinalIgnoreCase) ||\n                            string.Equals(b.SubType, \"url\", StringComparison.OrdinalIgnoreCase);\n                        if (!isUrl) continue;\n\n                        var mask = (b.ParameterValue ?? string.Empty).Trim();\n                        var isDynamic = mask.Contains(\"{{\", StringComparison.Ordinal);\n                        if (!isDynamic) continue;\n\n                        var param = (idx < storedUrlParams.Count ? storedUrlParams[idx] : null) ?? string.Empty;\n                        param = param.Trim();\n\n                        if (string.IsNullOrWhiteSpace(param))\n                        {\n                            var err = $\"Template '{templateName}' requires a dynamic URL parameter for button {idx + 1} ('{b.Text}').\";\n                            _logger.LogWarning(\n                                \"CTAFlow ExecuteNextAsync failed: {Error} biz={Biz} flow={Flow} srcStep={Src} targetStep={Target} tmpl={T} to={To} btnIdx={BtnIdx} btnText='{BtnText}' provider={Prov}/{Pnid} urlBtnIdx={UrlIdx} urlBtnText='{UrlText}'\",\n                                err, context.BusinessId, context.FlowId, context.SourceStepId, targetStep.Id, templateName, context.ContactPhone, context.ButtonIndex, clickedBtnText, provider, phoneNumberId, idx, b.Text);\n\n                            await RecordFailureAsync(context, stepId: targetStep.Id, stepName: templateName, error: err);\n                            return new NextStepResult { Success = false, Error = err };\n                        }\n\n                        components.Add(new\n                        {\n                            type = \"button\",\n                            sub_type = \"url\",\n                            index = idx.ToString(),\n                            parameters = new object[]\n                            {\n                                new { type = \"text\", text = param }\n                            }\n                        });\n                    }\n                }\n\n\n                var payload = new\n                {\n                    messaging_product = \"whatsapp\",\n                    to = context.ContactPhone,\n                    type = \"template\",\n                    template = new\n                    {\n                        name = templateName,\n                        language = new { code = languageCode },\n                        components\n                    }\n                };\n\n                // 4) SEND (explicit provider + sender)\n                _logger.LogInformation(\"‚û°Ô∏è SEND-INTENT flow={Flow} step={Step} tmpl={T} to={To} provider={Prov}/{Pnid}\",\n                    context.FlowId, targetStep.Id, templateName, context.ContactPhone, provider, phoneNumberId);\n\n                var sendResult = await _messageEngineService.SendPayloadAsync(\n                    context.BusinessId,\n                    provider,\n                    payload,\n                    phoneNumberId\n                );\n\n                if (!sendResult.Success)\n                {\n                    // NOTE: Added so webhook-driven flows can't fail silently; DB already captures Status=Failed below.\n                    _logger.LogWarning(\n                        \"CTAFlow send failed biz={Biz} flow={Flow} srcStep={Src} targetStep={Target} tmpl={T} to={To} btnIdx={BtnIdx} btnText='{BtnText}' provider={Prov}/{Pnid} err={Err}\",\n                        context.BusinessId, context.FlowId, context.SourceStepId, targetStep.Id, templateName, context.ContactPhone, context.ButtonIndex, clickedBtnText, provider, phoneNumberId, sendResult.ErrorMessage);\n                }\n\n                // 5) Snapshot buttons for click mapping\n                string? buttonBundleJson = null;\n                if (targetStep.ButtonLinks?.Count > 0)\n                {\n                    var bundle = targetStep.ButtonLinks\n                        .OrderBy(b => b.ButtonIndex)\n                        .Select(b => new\n                        {\n                            i = b.ButtonIndex,\n                            t = b.ButtonText ?? \"\",\n                            ty = b.ButtonType ?? \"QUICK_REPLY\",\n                            v = b.ButtonValue ?? \"\",\n                            ns = b.NextStepId\n                        })\n                        .ToList();\n\n                    buttonBundleJson = JsonSerializer.Serialize(bundle);\n                }\n\n                // 6) MessageLog\n                var messageLog = new MessageLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = context.BusinessId,\n                    RecipientNumber = context.ContactPhone,\n                    CTAFlowConfigId = context.FlowId,\n                    CTAFlowStepId = targetStep.Id,\n                    FlowVersion = context.Version,\n                    Source = \"flow\",\n                    RefMessageId = context.MessageLogId,\n                    CreatedAt = DateTime.UtcNow,\n                    Status = sendResult.Success ? \"Sent\" : \"Failed\",\n                    MessageId = sendResult.MessageId,\n                    ErrorMessage = sendResult.ErrorMessage,\n                    RawResponse = sendResult.RawResponse,\n                    ButtonBundleJson = buttonBundleJson,\n                    MessageContent = templateName,\n                    SentAt = sendResult.Success ? DateTime.UtcNow : (DateTime?)null\n                };\n\n                _dbContext.MessageLogs.Add(messageLog);\n\n                // 7) Flow execution audit\n                _dbContext.FlowExecutionLogs.Add(new FlowExecutionLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = context.BusinessId,\n                    FlowId = context.FlowId,\n                    StepId = targetStep.Id,\n                    StepName = templateName,\n                    MessageLogId = messageLog.Id,\n                    ButtonIndex = context.ButtonIndex,\n                    ContactPhone = context.ContactPhone,\n                    Success = sendResult.Success,\n                    ErrorMessage = sendResult.ErrorMessage,\n                    RawResponse = sendResult.RawResponse,\n                    ExecutedAt = DateTime.UtcNow,\n                    RequestId = context.RequestId\n                });\n\n                await _dbContext.SaveChangesAsync();\n\n                return new NextStepResult\n                {\n                    Success = sendResult.Success,\n                    Error = sendResult.ErrorMessage\n                };\n            }\n            catch (Exception ex)\n            {\n                var err = ex.Message;\n                _logger.LogError(ex,\n                    \"CTAFlow ExecuteNextAsync exception biz={Biz} flow={Flow} srcStep={Src} targetStep={Target} tmpl={T} to={To} btnIdx={BtnIdx} provider={Provider}/{PhoneNumberId}\",\n                    context.BusinessId, context.FlowId, context.SourceStepId, targetStepIdForLog, templateNameForLog, context.ContactPhone, context.ButtonIndex, providerForLog, phoneNumberIdForLog);\n\n                await RecordFailureAsync(\n                    context,\n                    stepId: targetStepIdForLog ?? context.SourceStepId,\n                    stepName: templateNameForLog ?? \"EXCEPTION\",\n                    error: err);\n\n                return new NextStepResult { Success = false, Error = err };\n            }\n        }\n\n        private static readonly System.Text.RegularExpressions.Regex PositionalToken =\n            new(@\"\\{\\{\\s*\\d+\\s*\\}\\}\", System.Text.RegularExpressions.RegexOptions.Compiled); // {{1}}, {{ 2 }}, etc.\n\n        private static readonly System.Text.RegularExpressions.Regex NamedToken =\n            new(@\"\\{\\{\\s*\\}\\}\", System.Text.RegularExpressions.RegexOptions.Compiled);        // {{}} (NAMED format slot)\n\n        private static int CountBodyTokensFlexible(string? text)\n        {\n            if (string.IsNullOrEmpty(text)) return 0;\n            return PositionalToken.Matches(text).Count + NamedToken.Matches(text).Count;\n        }\n\n        private static List<string> TryParseBodyParams(string? json)\n        {\n            if (string.IsNullOrWhiteSpace(json)) return new List<string>();\n            try\n            {\n                var list = JsonSerializer.Deserialize<List<string>>(json);\n                return list ?? new List<string>();\n            }\n            catch\n            {\n                return new List<string>();\n            }\n        }\n\n        private static List<string> TryParseUrlButtonParams(string? json)\n        {\n            if (string.IsNullOrWhiteSpace(json)) return new List<string>();\n            try\n            {\n                var list = JsonSerializer.Deserialize<List<string>>(json);\n                return list ?? new List<string>();\n            }\n            catch\n            {\n                return new List<string>();\n            }\n        }\n\n        private async Task<int> ResolveBodyVarCountAsync(Guid businessId, string templateName, xbytechat.api.WhatsAppSettings.DTOs.TemplateMetadataDto meta)\n        {\n            try\n            {\n                // WhatsAppTemplates.BodyVarCount is the canonical body placeholder count (buttons are separate).\n                var count = await _dbContext.WhatsAppTemplates\n                    .AsNoTracking()\n                    .Where(t => t.BusinessId == businessId && t.IsActive && t.Name == templateName)\n                    .OrderByDescending(t => t.UpdatedAt)\n                    .Select(t => t.BodyVarCount)\n                    .FirstOrDefaultAsync();\n\n                if (count > 0) return count;\n            }\n            catch (Exception ex)\n            {\n                // Best-effort; fall back to counting tokens in the template preview body.\n                _logger.LogWarning(ex,\n                    \"CTAFlow ResolveBodyVarCountAsync failed, falling back to token count biz={Biz} tmpl={T}\",\n                    businessId, templateName);\n            }\n\n            return CountBodyTokensFlexible(meta?.Body);\n        }\n\n        private static bool TryGetHttpUrl(string? maybeUrl, out string url)\n        {\n            url = string.Empty;\n            if (string.IsNullOrWhiteSpace(maybeUrl)) return false;\n            if (!Uri.TryCreate(maybeUrl.Trim(), UriKind.Absolute, out var u)) return false;\n            if (!string.Equals(u.Scheme, Uri.UriSchemeHttp, StringComparison.OrdinalIgnoreCase) &&\n                !string.Equals(u.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n                return false;\n            url = u.ToString();\n            return true;\n        }\n\n        private async Task RecordFailureAsync(NextStepContext context, Guid stepId, string stepName, string error)\n        {\n            try\n            {\n                _dbContext.FlowExecutionLogs.Add(new FlowExecutionLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = context.BusinessId,\n                    FlowId = context.FlowId,\n                    StepId = stepId,\n                    StepName = stepName,\n                    MessageLogId = context.MessageLogId == Guid.Empty ? null : context.MessageLogId,\n                    ButtonIndex = context.ButtonIndex,\n                    ContactPhone = context.ContactPhone,\n                    Success = false,\n                    ErrorMessage = error,\n                    ExecutedAt = DateTime.UtcNow,\n                    RequestId = context.RequestId\n                });\n\n                await _dbContext.SaveChangesAsync();\n            }\n            catch (Exception ex)\n            {\n                // NOTE: Do not throw from webhook runtime; log only (best-effort observability).\n                _logger.LogError(ex,\n                    \"CTAFlow RecordFailureAsync failed biz={Biz} flow={Flow} step={Step} to={To} error={Err}\",\n                    context.BusinessId, context.FlowId, stepId, context.ContactPhone, error);\n            }\n        }\n\n\n    }\n}\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Services/ICtaFlowRuntimeService.cs",
      "sha256": "ba7f6a253e9b5e3af197db5060f0879595cef09e7e8e7e796b9fae4028c0f284",
      "language": "csharp",
      "size": 1518,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CTAFlowBuilder.DTOs;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Services\n{\n    /// <summary>\n    /// Runtime engine for executing CTA flows (journey flows).\n    /// \n    /// This is the single entry point used by other modules:\n    /// - AutoReply (CTA_FLOW nodes)\n    /// - Campaigns (button-click journeys)\n    /// - Future JourneyBot / Inbox actions\n    /// </summary>\n    public interface ICtaFlowRuntimeService\n    {\n        /// <summary>\n        /// Starts a CTA flow journey for a given contact.\n        /// </summary>\n        /// <param name=\"businessId\">Tenant business id.</param>\n        /// <param name=\"contactId\">Contact id in CRM (if known).</param>\n        /// <param name=\"contactPhone\">Contact phone number (WhatsApp).</param>\n        /// <param name=\"configId\">CTA flow config id (visual flow definition).</param>\n        /// <param name=\"origin\">Where this journey was triggered from.</param>\n        /// <param name=\"autoReplyFlowId\">\n        /// Optional AutoReplyFlow id when origin = AutoReply; otherwise null.\n        /// </param>\n        Task<CtaFlowRunResult> StartFlowAsync(\n            Guid businessId,\n            Guid contactId,\n            string contactPhone,\n            Guid configId,\n            FlowExecutionOrigin origin,\n            Guid? autoReplyFlowId,\n            CancellationToken cancellationToken = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Services/ICTAFlowService.cs",
      "sha256": "ea564ff162310a68224cdc57a047aa45a900fc613e40a06e7d0a22780ef35ee2",
      "language": "csharp",
      "size": 5223,
      "content": "using xbytechat.api.Features.CTAFlowBuilder.DTOs;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Services\n{\n    public interface ICTAFlowService\n    {\n        // Create-only (draft)\n        Task<ResponseResult> SaveVisualFlowAsync(SaveVisualFlowDto dto, Guid businessId, string createdBy);\n\n        // Load flows (lists)\n        Task<List<VisualFlowSummaryDto>> GetAllPublishedFlowsAsync(Guid businessId);\n        Task<List<VisualFlowSummaryDto>> GetAllDraftFlowsAsync(Guid businessId);\n\n        // Load flow (detail)\n        Task<SaveVisualFlowDto?> GetVisualFlowByIdAsync(Guid flowId, Guid businessId);  // for editor/view\n        Task<ResponseResult> GetVisualFlowAsync(Guid flowId, Guid businessId);          // alt payload\n\n        // Runtime\n        Task<CTAFlowStep?> MatchStepByButtonAsync(Guid businessId, string buttonText, string buttonType, string currentTemplateName, Guid? campaignId = null);\n        Task<ResponseResult> ExecuteVisualFlowAsync(Guid businessId, Guid startStepId, Guid trackingLogId, Guid? campaignSendLogId);\n        Task<CTAFlowStep?> GetChainedStepAsync(Guid businessId, Guid? nextStepId);\n        Task<CTAFlowStep?> GetChainedStepWithContextAsync(Guid businessId, Guid? nextStepId, Guid? trackingLogId);\n        Task<FlowButtonLink?> GetLinkAsync(Guid flowId, Guid sourceStepId, short buttonIndex);\n\n        // Delete (only if not attached)\n        Task<ResponseResult> DeleteFlowAsync(Guid flowId, Guid businessId, string deletedBy);\n\n        // Publish\n        Task<ResponseResult> PublishFlowAsync(Guid flowId, Guid businessId, string user);\n\n        // Update (save as draft) + fork (create new draft copy)\n        Task<FlowUpdateResult> UpdateVisualFlowAsync(Guid flowId, SaveVisualFlowDto dto, Guid businessId, string user);\n        Task<Guid> ForkFlowAsync(Guid flowId, Guid businessId, string user);\n\n        // Attached campaigns (for usage checks / modal)\n        Task<IReadOnlyList<AttachedCampaignDto>> GetAttachedCampaignsAsync(Guid flowId, Guid businessId);\n\n        // (Optional utility)\n        Task<bool> HardDeleteFlowIfUnusedAsync(Guid flowId, Guid businessId);\n    }\n}\n\n\n//using xbytechat.api.Features.CTAFlowBuilder.DTOs;\n//using xbytechat.api.Features.CTAFlowBuilder.Models;\n//using xbytechat.api.Helpers;\n\n//namespace xbytechat.api.Features.CTAFlowBuilder.Services\n//{\n//    public interface ICTAFlowService\n//    {\n//        // ‚úÖ Used for flow creation and saving\n//        Task<Guid> CreateFlowWithStepsAsync(CreateFlowDto dto, Guid businessId, string createdBy);\n//        Task<ResponseResult> SaveVisualFlowAsync(SaveVisualFlowDto dto, Guid businessId, string createdBy);\n\n//        // ‚úÖ Load flows\n//        Task<CTAFlowConfig?> GetFlowByBusinessAsync(Guid businessId);\n//        Task<CTAFlowConfig?> GetDraftFlowByBusinessAsync(Guid businessId);\n//        Task<List<VisualFlowSummaryDto>> GetAllPublishedFlowsAsync(Guid businessId);\n//        Task<List<VisualFlowSummaryDto>> GetAllDraftFlowsAsync(Guid businessId);\n\n//        // ‚úÖ Load and manage flow steps\n//        Task<List<CTAFlowStep>> GetStepsForFlowAsync(Guid flowId);\n\n\n//        Task<CTAFlowStep?> MatchStepByButtonAsync(Guid businessId, string buttonText,string buttonType,string currentTemplateName,Guid? campaignId = null);\n\n\n//        Task<CTAFlowStep?> GetChainedStepAsync(Guid businessId, Guid? nextStepId);\n//        Task<CTAFlowStep?> GetChainedStepWithContextAsync(Guid businessId, Guid? nextStepId, Guid? trackingLogId);\n//        // ‚úÖ Runtime logic\n//        Task<ResponseResult> ExecuteFollowUpStepAsync(Guid businessId, CTAFlowStep? currentStep, string recipientNumber);\n\n//        // ‚úÖ Flow management\n//        Task<ResponseResult> PublishFlowAsync(Guid businessId, List<FlowStepDto> steps, string createdBy);\n\n//        Task<ResponseResult> DeleteFlowAsync(Guid flowId, Guid businessId, string deletedBy);\n\n//        // ‚úÖ Editor loading (visual builder)\n//       // Task<SaveVisualFlowDto?> GetVisualFlowByIdAsync(Guid id, Guid businessId);\n//        Task<SaveVisualFlowDto?> GetVisualFlowByIdAsync(Guid flowId, Guid businessId);\n//        Task<ResponseResult> GetVisualFlowAsync(Guid flowId, Guid businessId);\n//        Task<ResponseResult> ExecuteVisualFlowAsync(Guid businessId, Guid startStepId, Guid trackingLogId, Guid? campaignSendLogId);\n//        Task<FlowButtonLink?> GetLinkAsync(Guid flowId, Guid sourceStepId, short buttonIndex);\n\n//        public interface IFlowRuntimeService\n//        {\n//            Task<NextStepResult> ExecuteNextAsync(NextStepContext context);\n//        }\n//        Task<IReadOnlyList<AttachedCampaignDto>> GetAttachedCampaignsAsync(Guid flowId, Guid businessId);\n//        Task<bool> HardDeleteFlowIfUnusedAsync(Guid flowId, Guid businessId);\n//        //Task<FlowUpdateResult> UpdateVisualFlowAsync(Guid flowId, SaveVisualFlowDto dto, Guid businessId, string user);\n\n//        // Explicit publish after edits\n//        Task<bool> PublishFlowAsync(Guid flowId, Guid businessId, string user);\n\n//        // Create a new draft copy when live flow is attached\n//        Task<Guid> ForkFlowAsync(Guid flowId, Guid businessId, string user);\n//    }\n//}\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Services/IFlowExecutionLogger.cs",
      "sha256": "f55acecb74866f1c84445d8583541fd60f0436c02f1f1e87815fce4ce5acf9b9",
      "language": "csharp",
      "size": 717,
      "content": "using System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.AutoReplyBuilder.DTOs;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\n\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Services\n{\n    /// <summary>\n    /// Abstraction for writing origin-tagged FlowExecutionLog rows.\n    /// Different engines (Campaign, AutoReply, Inbox, JourneyBot)\n    /// will call this with a FlowExecutionContext.\n    /// </summary>\n    public interface IFlowExecutionLogger\n    {\n        /// <summary>\n        /// Persist a single step execution into FlowExecutionLogs.\n        /// </summary>\n        Task LogStepAsync(FlowExecutionContext context, CancellationToken cancellationToken = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Services/IFlowRuntimeService.cs",
      "sha256": "02883161ca81dc88c13dcc8d599794a62f59a3641643696423a75cca4c36b1e7",
      "language": "csharp",
      "size": 1573,
      "content": "using xbytechat.api.Features.CTAFlowBuilder.Models;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Services\n{\n    public interface IFlowRuntimeService\n    {\n        Task<NextStepResult> ExecuteNextAsync(NextStepContext context);\n\n    }\n    public record NextStepContext\n    {\n        public Guid BusinessId { get; set; }\n        public Guid FlowId { get; set; }\n        public int Version { get; set; }\n        public Guid SourceStepId { get; set; }\n        public Guid? TargetStepId { get; set; }\n        public short ButtonIndex { get; set; }\n        public Guid MessageLogId { get; set; }\n        public string ContactPhone { get; set; } = string.Empty;\n        public Guid RequestId { get; set; }\n        public FlowButtonLink? ClickedButton { get; set; }\n        public string? Provider { get; set; }          // \"META_CLOUD\" | \"PINNACLE\"\n        public string? PhoneNumberId { get; set; }\n            public bool AlwaysSend { get; set; } = true;\n\n        // CTA media-header support (step 1/phase 1):\n        // When a template requires a media header (image/video/document), WhatsApp requires a header component with a link.\n        // In phase 2/3 we will persist this per-step (CTAFlowStep.HeaderMediaUrl) via UI + DB.\n        // For now this is an optional override input so runtime can attach the header when available.\n        public string? HeaderMediaUrl { get; set; }\n    }\n\n    public record NextStepResult\n    {\n        public bool Success { get; set; }\n        public string? Error { get; set; }\n        public string? RedirectUrl { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Services/StepMatchingHelper.cs",
      "sha256": "4bd66fa2f33211a05e7a5a3c49de0886ae0859cbb081cacd2f4dd431be005182",
      "language": "csharp",
      "size": 1827,
      "content": "using Serilog;\nusing xbytechat.api.Features.CRM.Models;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\nusing xbytechat.api.Features.Tracking.Models;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Services\n{\n    public static class StepMatchingHelper\n    {\n        public static bool IsStepMatched(CTAFlowStep step, TrackingLog log, Contact? contact)\n        {\n            if (!string.IsNullOrWhiteSpace(step.RequiredSource) &&\n                !string.Equals(step.RequiredSource, log.SourceType, StringComparison.OrdinalIgnoreCase))\n            {\n                Log.Information(\"üö´ Step [{StepId}] skipped: RequiredSource '{Required}' ‚â† ClickedSource '{Actual}'\",\n                    step.Id, step.RequiredSource, log.SourceType);\n                return false;\n            }\n\n            if (!string.IsNullOrWhiteSpace(step.RequiredTag))\n            {\n                if (contact == null || contact.ContactTags == null || !contact.ContactTags.Any())\n                {\n                    Log.Information(\"üö´ Step [{StepId}] skipped: Contact or Tags missing (RequiredTag: {RequiredTag})\",\n                        step.Id, step.RequiredTag);\n                    return false;\n                }\n\n                var hasTag = contact.ContactTags.Any(ct =>\n                    string.Equals(ct.Tag.Name, step.RequiredTag, StringComparison.OrdinalIgnoreCase));\n\n                if (!hasTag)\n                {\n                    var contactTags = string.Join(\", \", contact.ContactTags.Select(ct => ct.Tag.Name));\n                    Log.Information(\"üö´ Step [{StepId}] skipped: Contact tags [{Tags}] do not include RequiredTag '{Required}'\",\n                        step.Id, contactTags, step.RequiredTag);\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n    }\n}\n"
    }
  ]
}
