{
  "name": "xbytechat-api/Features/CampaignModule",
  "part": 2,
  "of": 2,
  "generatedAt": "2026-02-11 19:15:17 +00:00",
  "files": [
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/CsvBatchService.cs",
      "sha256": "e384bad82c7e9ccd676f053de057e91a5d3b5b41c0f189477d35952ee8d72c1c",
      "language": "csharp",
      "size": 57445,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing xbytechat.api;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing xbytechat.api.Features.CampaignModule.Models;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    public class CsvBatchService : ICsvBatchService\n    {\n        private readonly AppDbContext _db;\n\n        public CsvBatchService(AppDbContext db)\n        {\n            _db = db;\n        }\n\n        // ----------------------------\n        // Upload + ingest\n        // ----------------------------\n        public async Task<CsvBatchUploadResultDto> CreateAndIngestAsync(\n            Guid businessId,\n            string fileName,\n            Stream stream,\n            Guid? audienceId = null,\n            Guid? campaignId = null,\n            CancellationToken ct = default)\n        {\n            // If we’re in a campaign context and no audience was supplied, create one now.\n            Audience? audience = null;\n            if (audienceId is null && campaignId is not null)\n            {\n                var campaignExists = await _db.Campaigns\n                    .AnyAsync(c => c.Id == campaignId && c.BusinessId == businessId, ct);\n\n                if (!campaignExists)\n                    throw new InvalidOperationException(\"Campaign not found for this business.\");\n\n                audience = new Audience\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                  //  CampaignId = campaignId,\n                    Name = Path.GetFileNameWithoutExtension(fileName) + \" (CSV)\",\n                    CreatedAt = DateTime.UtcNow,\n                    IsDeleted = false\n                };\n\n                _db.Audiences.Add(audience);\n                await _db.SaveChangesAsync(ct);\n                audienceId = audience.Id;\n            }\n\n            // 1) Create batch shell\n            var batch = new CsvBatch\n            {\n                Id = Guid.NewGuid(),\n                BusinessId = businessId,\n                AudienceId = audienceId,\n                FileName = fileName,\n                CreatedAt = DateTime.UtcNow,\n                Status = \"ingesting\",\n                RowCount = 0,\n                SkippedCount = 0,\n                HeadersJson = null\n            };\n\n            _db.CsvBatches.Add(batch);\n            await _db.SaveChangesAsync(ct);\n\n            // Keep both sides in sync if we created the audience here.\n            if (audience is not null)\n            {\n                audience.CsvBatchId = batch.Id;\n                await _db.SaveChangesAsync(ct);\n            }\n\n            try\n            {\n                stream.Position = 0;\n                using var reader = new StreamReader(\n                    stream,\n                    Encoding.UTF8,\n                    detectEncodingFromByteOrderMarks: true,\n                    bufferSize: 1024,\n                    leaveOpen: true);\n\n                string? headerLine = await reader.ReadLineAsync();\n                if (string.IsNullOrWhiteSpace(headerLine))\n                {\n                    var headers = new List<string> { \"phone\" };\n                    batch.HeadersJson = JsonSerializer.Serialize(headers);\n                    batch.Status = \"ready\";\n                    await _db.SaveChangesAsync(ct);\n                    if (campaignId.HasValue && batch.AudienceId.HasValue)\n                    {\n                        await UpsertCampaignAttachmentAsync(\n                            businessId: businessId,\n                            campaignId: campaignId.Value,\n                            audienceId: batch.AudienceId.Value,\n                            csvBatchId: batch.Id,\n                            fileName: fileName,\n                            ct: ct);\n                    }\n\n                    Log.Warning(\"CSV had no header line. Created batch {BatchId} with fallback 'phone' header.\", batch.Id);\n\n                    return new CsvBatchUploadResultDto\n                    {\n                        BatchId = batch.Id,\n                        AudienceId = batch.AudienceId,\n                        FileName = batch.FileName ?? string.Empty,\n                        RowCount = 0,\n                        Headers = headers\n                    };\n                }\n\n                var delim = DetectDelimiter(headerLine);\n                var headersParsed = ParseCsvLine(headerLine, delim)\n                    .Select(h => h.Trim())\n                    .Where(h => !string.IsNullOrEmpty(h))\n                    .ToList();\n\n                if (headersParsed.Count == 0)\n                    headersParsed = new List<string> { \"phone\" };\n\n                batch.HeadersJson = JsonSerializer.Serialize(headersParsed);\n                await _db.SaveChangesAsync(ct);\n\n                var rowsBuffer = new List<CsvRow>(capacity: 1024);\n                int rowIndex = 0;\n\n                // Detect the phone column once from header\n                string? phoneHeader =\n                    headersParsed.FirstOrDefault(h =>\n                        PhoneHeaderCandidates.Any(c => c.Equals(h, StringComparison.OrdinalIgnoreCase)))\n                    ?? headersParsed.FirstOrDefault(h => h.Equals(\"phone\", StringComparison.OrdinalIgnoreCase));\n\n                if (phoneHeader == null)\n                {\n                    Log.Warning(\"CsvBatch {BatchId}: no phone-like header found. Headers={Headers}\",\n                        batch.Id, string.Join(\", \", headersParsed));\n                }\n\n                while (!reader.EndOfStream)\n                {\n                    var line = await reader.ReadLineAsync();\n                    if (line is null) break;\n                    if (string.IsNullOrWhiteSpace(line)) continue;\n\n                    var cols = ParseCsvLine(line, delim);\n\n                    var dict = new Dictionary<string, string?>(StringComparer.OrdinalIgnoreCase);\n                    for (int i = 0; i < headersParsed.Count; i++)\n                    {\n                        var key = headersParsed[i];\n                        var val = i < cols.Count ? cols[i]?.Trim() : null;\n                        dict[key] = val;\n                    }\n\n                    // Pull phone value\n                    string? phoneRaw = null;\n                    if (!string.IsNullOrEmpty(phoneHeader))\n                        dict.TryGetValue(phoneHeader, out phoneRaw);\n\n                    // ✅ Canonical phone identity: E.164 digits-only (NO '+')\n                    var phoneE164Digits = PhoneNumberNormalizer.NormalizeToE164Digits(phoneRaw, \"IN\");\n                    var phoneErr = (phoneE164Digits is null && !string.IsNullOrWhiteSpace(phoneRaw))\n                        ? \"Invalid phone (could not normalize to E.164 digits-only).\"\n                        : \"\";\n\n                    rowsBuffer.Add(new CsvRow\n                    {\n                        Id = Guid.NewGuid(),\n                        BusinessId = businessId,\n                        BatchId = batch.Id,\n                        RowIndex = rowIndex++,\n\n                        PhoneRaw = phoneRaw,\n                        PhoneE164 = phoneE164Digits, // ✅ digits-only canonical\n                        ValidationError = (phoneE164Digits is null && !string.IsNullOrWhiteSpace(phoneRaw)) ? phoneErr : null,\n\n                        // Persist entire row as JSON\n                        RowJson = JsonSerializer.Serialize(dict)\n                    });\n\n                    if (rowsBuffer.Count >= 1000)\n                    {\n                        _db.CsvRows.AddRange(rowsBuffer);\n                        await _db.SaveChangesAsync(ct);\n                        rowsBuffer.Clear();\n                    }\n                }\n\n                if (rowsBuffer.Count > 0)\n                {\n                    _db.CsvRows.AddRange(rowsBuffer);\n                    await _db.SaveChangesAsync(ct);\n                }\n\n                batch.RowCount = rowIndex;\n                batch.Status = \"ready\";\n                await _db.SaveChangesAsync(ct);\n\n                // ✅ STEP 3: Promote valid CSV rows into AudienceMembers (only when AudienceId exists)\n                if (batch.AudienceId.HasValue)\n                {\n                    await PromoteRowsToAudienceMembersAsync(\n                        businessId: businessId,\n                        batchId: batch.Id,\n                        audienceId: batch.AudienceId.Value,\n                        ct: ct);\n                }\n\n                // FIX: campaign attachment upsert must run regardless of header branch (when in campaign context).\n                if (campaignId.HasValue && batch.AudienceId.HasValue)\n                {\n                    await UpsertCampaignAttachmentAsync(\n                        businessId: businessId,\n                        campaignId: campaignId.Value,\n                        audienceId: batch.AudienceId.Value,\n                        csvBatchId: batch.Id,\n                        fileName: fileName,\n                        ct: ct);\n                }\n\n                Log.Information(\"CsvBatch {BatchId} ingested: {Rows} rows; headers={HeaderCount}\",\n                    batch.Id, batch.RowCount, headersParsed.Count);\n\n                return new CsvBatchUploadResultDto\n                {\n                    BatchId = batch.Id,\n                    AudienceId = batch.AudienceId,\n                    FileName = batch.FileName ?? string.Empty,\n                    RowCount = batch.RowCount,\n                    Headers = headersParsed\n                };\n            }\n            catch (Exception ex)\n            {\n                batch.Status = \"failed\";\n                batch.ErrorMessage = ex.Message;\n                await _db.SaveChangesAsync(ct);\n                Log.Error(ex, \"CSV ingest failed for batch {BatchId}\", batch.Id);\n                throw;\n            }\n        }\n\n        // ✅ Step 3 implementation\n        // Promote CsvRows -> AudienceMembers (upsert + reactivate soft-deletes)\n        private async Task PromoteRowsToAudienceMembersAsync(\n            Guid businessId,\n            Guid batchId,\n            Guid audienceId,\n            CancellationToken ct)\n        {\n            var now = DateTime.UtcNow;\n\n            // Build a first-seen map per unique phone (so we can keep a representative PhoneRaw)\n            // NOTE: This streams from DB, memory cost = #unique phones (acceptable for MVP).\n            var firstByPhone = new Dictionary<string, string?>(StringComparer.Ordinal);\n            var phoneSet = new HashSet<string>(StringComparer.Ordinal);\n\n            var rowsQuery = _db.CsvRows\n                .AsNoTracking()\n                .Where(r => r.BusinessId == businessId && r.BatchId == batchId && r.PhoneE164 != null && r.PhoneE164 != \"\")\n                .OrderBy(r => r.RowIndex)\n                .Select(r => new { r.PhoneE164, r.PhoneRaw });\n\n            await foreach (var r in rowsQuery.AsAsyncEnumerable().WithCancellation(ct))\n            {\n                var phone = r.PhoneE164!;\n                if (phoneSet.Add(phone))\n                {\n                    firstByPhone[phone] = r.PhoneRaw;\n                }\n            }\n\n            if (phoneSet.Count == 0)\n            {\n                Log.Information(\"CsvBatch {BatchId}: no valid phones to promote to AudienceMembers.\", batchId);\n                return;\n            }\n\n            // Load existing members for this audience (so we can skip duplicates / reactivate)\n            var existing = await _db.Set<AudienceMember>()\n                .Where(m => m.BusinessId == businessId && m.AudienceId == audienceId && m.PhoneE164 != null)\n                .ToListAsync(ct);\n\n            var existingByPhone = existing\n                .Where(m => !string.IsNullOrWhiteSpace(m.PhoneE164))\n                .GroupBy(m => m.PhoneE164!)\n                .ToDictionary(g => g.Key, g => g.First(), StringComparer.Ordinal);\n\n            var toInsert = new List<AudienceMember>();\n\n            foreach (var phone in phoneSet)\n            {\n                if (existingByPhone.TryGetValue(phone, out var m))\n                {\n                    // Reactivate if soft-deleted\n                    if (m.IsDeleted)\n                    {\n                        m.IsDeleted = false;\n                        m.UpdatedAt = now;\n                    }\n\n                    // Keep raw for audit/debug (optional)\n                    if (string.IsNullOrWhiteSpace(m.PhoneRaw))\n                        m.PhoneRaw = firstByPhone.TryGetValue(phone, out var pr) ? pr : null;\n\n                    continue;\n                }\n\n                toInsert.Add(new AudienceMember\n                {\n                    Id = Guid.NewGuid(),\n                    AudienceId = audienceId,\n                    BusinessId = businessId,\n\n                    // CSV members might not be real CRM Contacts yet\n                    ContactId = null,\n                    IsTransientContact = true,\n\n                    Name = null,\n                    Email = null,\n                    PhoneRaw = firstByPhone.TryGetValue(phone, out var raw) ? raw : null,\n                    PhoneE164 = phone,\n\n                    AttributesJson = null,\n                    IsDeleted = false,\n                    CreatedAt = now,\n                    UpdatedAt = now\n                });\n            }\n\n            if (toInsert.Count > 0)\n            {\n                await _db.Set<AudienceMember>().AddRangeAsync(toInsert, ct);\n                await _db.SaveChangesAsync(ct);\n            }\n\n            Log.Information(\n                \"Promoted CsvRows -> AudienceMembers | biz={Biz} audience={AudienceId} batch={BatchId} uniquePhones={Unique} inserted={Inserted}\",\n                businessId, audienceId, batchId, phoneSet.Count, toInsert.Count);\n        }\n\n        // ----------------------------\n        // Batch info\n        // ----------------------------\n        public async Task<CsvBatchInfoDto?> GetBatchAsync(Guid businessId, Guid batchId, CancellationToken ct = default)\n        {\n            var batch = await _db.CsvBatches\n                .AsNoTracking()\n                .FirstOrDefaultAsync(b => b.Id == batchId && b.BusinessId == businessId, ct);\n\n            if (batch == null) return null;\n\n            var headers = SafeParseHeaderArray(batch.HeadersJson);\n\n            return new CsvBatchInfoDto\n            {\n                BatchId = batch.Id,\n                AudienceId = batch.AudienceId,\n                RowCount = batch.RowCount,\n                Headers = headers,\n                CreatedAt = batch.CreatedAt\n            };\n        }\n\n        // ----------------------------\n        // Samples\n        // ----------------------------\n        public async Task<IReadOnlyList<CsvRowSampleDto>> GetSamplesAsync(\n            Guid businessId,\n            Guid batchId,\n            int take = 20,\n            CancellationToken ct = default)\n        {\n            if (take <= 0) take = 20;\n            if (take > 100) take = 100;\n\n            var batch = await _db.CsvBatches\n                .AsNoTracking()\n                .Where(b => b.Id == batchId && b.BusinessId == businessId)\n                .Select(b => new { b.Id, b.HeadersJson, b.RowCount })\n                .FirstOrDefaultAsync(ct);\n\n            if (batch is null)\n                throw new KeyNotFoundException(\"Batch not found.\");\n\n            if (batch.RowCount <= 0)\n                return Array.Empty<CsvRowSampleDto>();\n\n            var headerList = SafeParseHeaderArray(batch.HeadersJson);\n\n            var rows = await _db.CsvRows\n                .AsNoTracking()\n                .Where(r => r.BusinessId == businessId && r.BatchId == batchId)\n                .OrderBy(r => r.RowIndex)\n                .Take(take)\n                .Select(r => new { r.RowIndex, r.DataJson })\n                .ToListAsync(ct);\n\n            var result = new List<CsvRowSampleDto>(rows.Count);\n            foreach (var r in rows)\n            {\n                var dict = SafeParseDict(r.DataJson);\n\n                var ordered = new Dictionary<string, string?>(headerList.Count, StringComparer.OrdinalIgnoreCase);\n                foreach (var h in headerList)\n                {\n                    dict.TryGetValue(h, out var v);\n                    ordered[h] = v;\n                }\n\n                result.Add(new CsvRowSampleDto\n                {\n                    RowIndex = r.RowIndex,\n                    Data = ordered\n                });\n            }\n\n            return result;\n        }\n\n        // ----------------------------\n        // List / Page / Delete / Validate\n        // ----------------------------\n        public async Task<List<CsvBatchListItemDto>> ListBatchesAsync(Guid businessId, int limit = 20, CancellationToken ct = default)\n        {\n            if (limit <= 0) limit = 20;\n            if (limit > 100) limit = 100;\n\n            return await _db.CsvBatches\n                .AsNoTracking()\n                .Where(b => b.BusinessId == businessId)\n                .OrderByDescending(b => b.CreatedAt)\n                .Take(limit)\n                .Select(b => new CsvBatchListItemDto\n                {\n                    BatchId = b.Id,\n                    FileName = b.FileName,\n                    RowCount = b.RowCount,\n                    Status = b.Status,\n                    CreatedAt = b.CreatedAt\n                })\n                .ToListAsync(ct);\n        }\n\n        public async Task<CsvBatchRowsPageDto> GetRowsPageAsync(Guid businessId, Guid batchId, int skip, int take, CancellationToken ct = default)\n        {\n            if (take <= 0) take = 50;\n            if (take > 200) take = 200;\n            if (skip < 0) skip = 0;\n\n            var exists = await _db.CsvBatches.AsNoTracking()\n                .AnyAsync(b => b.Id == batchId && b.BusinessId == businessId, ct);\n            if (!exists) throw new KeyNotFoundException(\"CSV batch not found.\");\n\n            var total = await _db.CsvRows.AsNoTracking()\n                .Where(r => r.BusinessId == businessId && r.BatchId == batchId)\n                .CountAsync(ct);\n\n            var rows = await _db.CsvRows.AsNoTracking()\n                .Where(r => r.BusinessId == businessId && r.BatchId == batchId)\n                .OrderBy(r => r.RowIndex)\n                .Skip(skip)\n                .Take(take)\n                .Select(r => new CsvRowSampleDto\n                {\n                    RowIndex = r.RowIndex,\n                    Data = SafeParseDict(r.DataJson)\n                })\n                .ToListAsync(ct);\n\n            return new CsvBatchRowsPageDto\n            {\n                BatchId = batchId,\n                TotalRows = total,\n                Skip = skip,\n                Take = take,\n                Rows = rows\n            };\n        }\n\n        public async Task<bool> DeleteBatchAsync(Guid businessId, Guid batchId, CancellationToken ct = default)\n        {\n            var batch = await _db.CsvBatches\n                .FirstOrDefaultAsync(b => b.Id == batchId && b.BusinessId == businessId, ct);\n\n            if (batch == null) return false;\n\n            using var tx = await _db.Database.BeginTransactionAsync(ct);\n            try\n            {\n                var rows = _db.CsvRows.Where(r => r.BusinessId == businessId && r.BatchId == batchId);\n                _db.CsvRows.RemoveRange(rows);\n\n                _db.CsvBatches.Remove(batch);\n\n                await _db.SaveChangesAsync(ct);\n                await tx.CommitAsync(ct);\n                return true;\n            }\n            catch\n            {\n                await tx.RollbackAsync(ct);\n                throw;\n            }\n        }\n\n        private static readonly string[] PhoneHeaderCandidates =\n        {\n            \"phone\", \"phone_number\", \"phonenumber\", \"phoneNumber\", \"phone-no\", \"phone_no\",\n            \"mobile\", \"mobile_number\", \"mobilenumber\", \"whatsapp\", \"whatsapp_no\", \"whatsapp_number\"\n        };\n\n        public async Task<CsvBatchValidationResultDto> ValidateAsync(\n            Guid businessId,\n            Guid batchId,\n            CsvBatchValidationRequestDto request,\n            CancellationToken ct = default)\n        {\n            if (request is null) throw new ArgumentNullException(nameof(request));\n            if (request.SampleSize <= 0) request.SampleSize = 20;\n            if (request.SampleSize > 100) request.SampleSize = 100;\n\n            var batch = await _db.CsvBatches.AsNoTracking()\n                .Where(b => b.BusinessId == businessId && b.Id == batchId)\n                .Select(b => new { b.Id, b.HeadersJson, b.RowCount })\n                .FirstOrDefaultAsync(ct);\n\n            if (batch == null) throw new KeyNotFoundException(\"CSV batch not found.\");\n\n            var headers = SafeParseHeaderArray(batch.HeadersJson);\n            var headerSet = new HashSet<string>(headers, StringComparer.OrdinalIgnoreCase);\n\n            var result = new CsvBatchValidationResultDto\n            {\n                BatchId = batchId,\n                TotalRows = batch.RowCount\n            };\n\n            if (request.RequiredHeaders != null && request.RequiredHeaders.Count > 0)\n            {\n                foreach (var req in request.RequiredHeaders)\n                {\n                    if (!headerSet.Contains(req))\n                        result.MissingRequiredHeaders.Add(req);\n                }\n\n                if (result.MissingRequiredHeaders.Count > 0)\n                    result.Errors.Add(\"Required headers are missing.\");\n            }\n\n            var phoneField = request.PhoneField;\n            if (string.IsNullOrWhiteSpace(phoneField))\n                phoneField = PhoneHeaderCandidates.FirstOrDefault(headerSet.Contains);\n\n            result.PhoneField = phoneField;\n\n            if (string.IsNullOrWhiteSpace(phoneField))\n            {\n                result.Errors.Add(\"No phone field provided or detected.\");\n                return result;\n            }\n\n            var seenPhones = new HashSet<string>(StringComparer.Ordinal);\n            var problemSamples = new List<CsvRowSampleDto>();\n\n            var rowsQuery = _db.CsvRows.AsNoTracking()\n                .Where(r => r.BusinessId == businessId && r.BatchId == batchId)\n                .OrderBy(r => r.RowIndex)\n                .Select(r => new { r.RowIndex, r.DataJson });\n\n            await foreach (var row in rowsQuery.AsAsyncEnumerable().WithCancellation(ct))\n            {\n                var dict = SafeParseDict(row.DataJson);\n                dict.TryGetValue(phoneField, out var rawPhone);\n\n                var normalized = PhoneNumberNormalizer.NormalizeToE164Digits(rawPhone, \"IN\");\n                var phoneErr = normalized is null ? \"Invalid phone (could not normalize to E.164 digits-only).\" : \"\";\n\n                if (string.IsNullOrWhiteSpace(normalized))\n                {\n                    result.MissingPhoneCount++;\n\n                    if (problemSamples.Count < request.SampleSize)\n                    {\n                        var dictWithErr = SafeParseDict(row.DataJson);\n                        dictWithErr[\"__phone_error__\"] = phoneErr;\n                        problemSamples.Add(new CsvRowSampleDto { RowIndex = row.RowIndex, Data = dictWithErr });\n                    }\n                    continue;\n                }\n\n                if (request.Deduplicate && !seenPhones.Add(normalized))\n                {\n                    result.DuplicatePhoneCount++;\n\n                    if (problemSamples.Count < request.SampleSize)\n                    {\n                        var dictWithErr = SafeParseDict(row.DataJson);\n                        dictWithErr[\"__phone_error__\"] = \"Duplicate phone after normalization.\";\n                        problemSamples.Add(new CsvRowSampleDto { RowIndex = row.RowIndex, Data = dictWithErr });\n                    }\n                }\n            }\n\n            result.ProblemSamples = problemSamples;\n\n            if (result.MissingPhoneCount > 0)\n                result.Errors.Add(\"Some rows are missing phone numbers.\");\n            if (result.DuplicatePhoneCount > 0)\n                result.Warnings.Add(\"Duplicate phone numbers detected (after normalization).\");\n\n            return result;\n        }\n\n        // ----------------------------\n        // helpers\n        // ----------------------------\n        private static List<string> SafeParseHeaderArray(string? json)\n        {\n            try\n            {\n                return string.IsNullOrWhiteSpace(json)\n                    ? new List<string>()\n                    : (JsonSerializer.Deserialize<List<string>>(json) ?? new List<string>());\n            }\n            catch { return new List<string>(); }\n        }\n\n        private static Dictionary<string, string?> SafeParseDict(string? json)\n        {\n            try\n            {\n                return string.IsNullOrWhiteSpace(json)\n                    ? new Dictionary<string, string?>()\n                    : (JsonSerializer.Deserialize<Dictionary<string, string?>>(json) ??\n                       new Dictionary<string, string?>());\n            }\n            catch { return new Dictionary<string, string?>(); }\n        }\n\n        private static char DetectDelimiter(string headerLine)\n        {\n            var candidates = new[] { ',', ';', '\\t' };\n            var counts = candidates.Select(c => (c, count: headerLine.Count(ch => ch == c))).ToList();\n            var best = counts.OrderByDescending(x => x.count).First();\n            return best.count > 0 ? best.c : ',';\n        }\n\n        private static List<string> ParseCsvLine(string line, char delimiter)\n        {\n            var result = new List<string>();\n            if (line == null) return result;\n\n            var sb = new StringBuilder();\n            bool inQuotes = false;\n\n            for (int i = 0; i < line.Length; i++)\n            {\n                var c = line[i];\n\n                if (inQuotes)\n                {\n                    if (c == '\"')\n                    {\n                        if (i + 1 < line.Length && line[i + 1] == '\"')\n                        {\n                            sb.Append('\"');\n                            i++;\n                        }\n                        else\n                        {\n                            inQuotes = false;\n                        }\n                    }\n                    else\n                    {\n                        sb.Append(c);\n                    }\n                }\n                else\n                {\n                    if (c == delimiter)\n                    {\n                        result.Add(sb.ToString());\n                        sb.Clear();\n                    }\n                    else if (c == '\"')\n                    {\n                        inQuotes = true;\n                    }\n                    else\n                    {\n                        sb.Append(c);\n                    }\n                }\n            }\n\n            result.Add(sb.ToString());\n            return result;\n        }\n\n        private async Task UpsertCampaignAttachmentAsync(\n    Guid businessId,\n    Guid campaignId,\n    Guid audienceId,\n    Guid csvBatchId,\n    string? fileName,\n    CancellationToken ct)\n        {\n            // 1) deactivate current active attachment (if any)\n            var active = await _db.CampaignAudienceAttachments\n                .FirstOrDefaultAsync(x =>\n                    x.BusinessId == businessId &&\n                    x.CampaignId == campaignId &&\n                    x.IsActive, ct);\n\n            if (active != null)\n            {\n                active.IsActive = false;\n                active.DeactivatedAt = DateTime.UtcNow;\n                active.DeactivatedBy ??= \"system\";\n            }\n\n            // 2) create new active attachment\n            var attach = new CampaignAudienceAttachment\n            {\n                Id = Guid.NewGuid(),\n                BusinessId = businessId,\n                CampaignId = campaignId,\n                AudienceId = audienceId,\n                CsvBatchId = csvBatchId,\n                FileName = fileName,\n                IsActive = true,\n                CreatedAt = DateTime.UtcNow\n            };\n\n            _db.CampaignAudienceAttachments.Add(attach);\n\n            await _db.SaveChangesAsync(ct);\n        }\n\n    }\n}\n\n\n\n//using System;\n//using System.Collections.Generic;\n//using System.IO;\n//using System.Linq;\n//using System.Text;\n//using System.Text.Json;\n//using System.Text.RegularExpressions;\n//using System.Threading;\n//using System.Threading.Tasks;\n//using Microsoft.EntityFrameworkCore;\n//using Serilog;\n//using xbytechat.api;\n//using xbytechat.api.Features.CampaignModule.DTOs;\n//using xbytechat.api.Features.CampaignModule.Models;\n//using Microsoft.Extensions.Options;\n//using xbytechat.api.Features.CampaignModule.CountryCodes;\n//namespace xbytechat.api.Features.CampaignModule.Services\n//{\n//    public class CsvBatchService : ICsvBatchService\n//    {\n//        private readonly AppDbContext _db;\n\n//        public CsvBatchService(AppDbContext db)\n//        {\n//            _db = db;\n\n//        }\n\n//        // ----------------------------\n//        // Upload + ingest\n//        // ----------------------------\n//        public async Task<CsvBatchUploadResultDto> CreateAndIngestAsync(\n//        Guid businessId,\n//        string fileName,\n//        Stream stream,\n//        Guid? audienceId = null,\n//        Guid? campaignId = null,\n//        CancellationToken ct = default)\n//        {\n//            // If we’re in a campaign context and no audience was supplied, create one now.\n//            Audience? audience = null;\n//            if (audienceId is null && campaignId is not null)\n//            {\n//                var campaignExists = await _db.Campaigns\n//                    .AnyAsync(c => c.Id == campaignId && c.BusinessId == businessId, ct);\n//                if (!campaignExists)\n//                    throw new InvalidOperationException(\"Campaign not found for this business.\");\n\n//                audience = new Audience\n//                {\n//                    Id = Guid.NewGuid(),\n//                    BusinessId = businessId,\n//                    CampaignId = campaignId,                  // ← link to campaign (so delete cascades)\n//                    Name = Path.GetFileNameWithoutExtension(fileName) + \" (CSV)\",\n//                    CreatedAt = DateTime.UtcNow,\n//                    IsDeleted = false\n//                };\n\n//                _db.Audiences.Add(audience);\n//                await _db.SaveChangesAsync(ct);              // get Audience.Id\n//                audienceId = audience.Id;                    // feed it into the batch\n//            }\n\n//            // 1) Create batch shell (now with a guaranteed AudienceId if campaignId was provided)\n//            var batch = new CsvBatch\n//            {\n//                Id = Guid.NewGuid(),\n//                BusinessId = businessId,\n//                AudienceId = audienceId,                     // ← no longer null for campaign CSVs\n//                FileName = fileName,\n//                CreatedAt = DateTime.UtcNow,\n//                Status = \"ingesting\",\n//                RowCount = 0,\n//                SkippedCount = 0,\n//                HeadersJson = null\n//            };\n\n//            _db.CsvBatches.Add(batch);\n//            await _db.SaveChangesAsync(ct);\n\n//            // Keep both sides in sync if we created the audience here.\n//            if (audience is not null)\n//            {\n//                audience.CsvBatchId = batch.Id;              // ← your model maps this too\n//                await _db.SaveChangesAsync(ct);\n//            }\n\n//            try\n//            {\n//                // ───── your existing parsing logic (unchanged) ─────\n//                stream.Position = 0;\n//                using var reader = new StreamReader(stream, Encoding.UTF8, detectEncodingFromByteOrderMarks: true, bufferSize: 1024, leaveOpen: true);\n\n//                string? headerLine = await reader.ReadLineAsync();\n//                if (string.IsNullOrWhiteSpace(headerLine))\n//                {\n//                    var headers = new List<string> { \"phone\" };\n//                    batch.HeadersJson = JsonSerializer.Serialize(headers);\n//                    batch.Status = \"ready\";\n//                    await _db.SaveChangesAsync(ct);\n\n//                    Log.Warning(\"CSV had no header line. Created batch {BatchId} with fallback 'phone' header.\", batch.Id);\n\n//                    return new CsvBatchUploadResultDto\n//                    {\n//                        BatchId = batch.Id,\n//                        AudienceId = batch.AudienceId,\n//                        FileName = batch.FileName ?? string.Empty,\n//                        RowCount = 0,\n//                        Headers = headers\n//                    };\n//                }\n\n//                var delim = DetectDelimiter(headerLine);\n//                var headersParsed = ParseCsvLine(headerLine, delim)\n//                    .Select(h => h.Trim())\n//                    .Where(h => !string.IsNullOrEmpty(h))\n//                    .ToList();\n\n//                if (headersParsed.Count == 0)\n//                    headersParsed = new List<string> { \"phone\" };\n\n//                //batch.HeadersJson = JsonSerializer.Serialize(headersParsed);\n//                //await _db.SaveChangesAsync(ct);\n\n//                //var rowsBuffer = new List<CsvRow>(capacity: 1024);\n//                //int rowIndex = 0;\n//                batch.HeadersJson = JsonSerializer.Serialize(headersParsed);\n//                await _db.SaveChangesAsync(ct);\n\n//                var rowsBuffer = new List<CsvRow>(capacity: 1024);\n//                int rowIndex = 0;\n\n//                // Detect the phone column once from the header row.\n//                // We try common names; falls back to exact \"phone\" if present.\n//                string? phoneHeader =\n//                    headersParsed.FirstOrDefault(h =>\n//                        PhoneHeaderCandidates.Any(c => c.Equals(h, StringComparison.OrdinalIgnoreCase)))\n//                    ?? headersParsed.FirstOrDefault(h => h.Equals(\"phone\", StringComparison.OrdinalIgnoreCase));\n\n//                if (phoneHeader == null)\n//                {\n//                    Log.Warning(\"CsvBatch {BatchId}: no phone-like header found. Headers={Headers}\",\n//                        batch.Id, string.Join(\", \", headersParsed));\n//                }\n\n//                while (!reader.EndOfStream)\n//                {\n//                    var line = await reader.ReadLineAsync();\n//                    if (line is null) break;\n//                    if (string.IsNullOrWhiteSpace(line)) continue;\n\n//                    var cols = ParseCsvLine(line, delim);\n\n//                    var dict = new Dictionary<string, string?>(StringComparer.OrdinalIgnoreCase);\n//                    for (int i = 0; i < headersParsed.Count; i++)\n//                    {\n//                        var key = headersParsed[i];\n//                        var val = i < cols.Count ? cols[i]?.Trim() : null;\n//                        dict[key] = val;\n//                    }\n\n//                    // Pull phone value (if we detected a phone header)\n//                    string? phoneRaw = null;\n//                    if (!string.IsNullOrEmpty(phoneHeader))\n//                    {\n//                        dict.TryGetValue(phoneHeader, out phoneRaw);\n//                    }\n\n//                    // Normalize using your existing validator (E.164); capture error if any\n//                    string? phoneErr;\n//                    var phoneE164 = NormalizeToE164OrError(phoneRaw, out phoneErr);\n\n//                    // Buffer the row with both raw + normalized phone and the whole row JSON\n//                    rowsBuffer.Add(new CsvRow\n//                    {\n//                        Id = Guid.NewGuid(),\n//                        BusinessId = businessId,\n//                        BatchId = batch.Id,\n//                        RowIndex = rowIndex++,\n\n//                        PhoneRaw = phoneRaw,\n//                        PhoneE164 = phoneE164,\n//                        ValidationError = (phoneE164 is null && !string.IsNullOrWhiteSpace(phoneRaw)) ? phoneErr : null,\n\n//                        // Persist the entire row as JSON (your model maps DataJson -> RowJson)\n//                        RowJson = JsonSerializer.Serialize(dict)\n//                    });\n\n\n//                    if (rowsBuffer.Count >= 1000)\n//                    {\n//                        _db.CsvRows.AddRange(rowsBuffer);\n//                        await _db.SaveChangesAsync(ct);\n//                        rowsBuffer.Clear();\n//                    }\n//                }\n\n//                if (rowsBuffer.Count > 0)\n//                {\n//                    _db.CsvRows.AddRange(rowsBuffer);\n//                    await _db.SaveChangesAsync(ct);\n//                }\n\n//                batch.RowCount = rowIndex;\n//                batch.Status = \"ready\";\n//                await _db.SaveChangesAsync(ct);\n\n//                Log.Information(\"CsvBatch {BatchId} ingested: {Rows} rows; headers={HeaderCount}\", batch.Id, batch.RowCount, headersParsed.Count);\n\n//                return new CsvBatchUploadResultDto\n//                {\n//                    BatchId = batch.Id,\n//                    AudienceId = batch.AudienceId,           // now reliably set for campaign CSVs\n//                    FileName = batch.FileName ?? string.Empty,\n//                    RowCount = batch.RowCount,\n//                    Headers = headersParsed\n//                };\n//            }\n//            catch (Exception ex)\n//            {\n//                batch.Status = \"failed\";\n//                batch.ErrorMessage = ex.Message;\n//                await _db.SaveChangesAsync(ct);\n//                Log.Error(ex, \"CSV ingest failed for batch {BatchId}\", batch.Id);\n//                throw;\n//            }\n//        }\n\n//        // ----------------------------\n//        // Batch info\n//        // ----------------------------\n//        private async Task<CsvBatchUploadResultDto> IngestCoreAsync(\n//            Guid businessId,\n//            string fileName,\n//            Stream stream,\n//            CancellationToken ct)\n//        {\n//            // Minimal “stage only” helper (kept in case other code calls it)\n//            var batch = new CsvBatch\n//            {\n//                Id = Guid.NewGuid(),\n//                BusinessId = businessId,\n//                FileName = fileName,\n//                CreatedAt = DateTime.UtcNow,\n//                Status = \"ready\",\n//                HeadersJson = null,\n//                RowCount = 0,\n//                SkippedCount = 0,\n//                ErrorMessage = null\n//            };\n//            _db.CsvBatches.Add(batch);\n//            await _db.SaveChangesAsync(ct);\n\n//            Log.Information(\"CsvBatch {BatchId} staged for business {Biz}\", batch.Id, businessId);\n\n//            return new CsvBatchUploadResultDto\n//            {\n//                BatchId = batch.Id,\n//                AudienceId = null,\n//                FileName = fileName,\n//                RowCount = 0,\n//                Headers = new List<string>(),\n//                Message = \"CSV batch created.\"\n//            };\n//        }\n\n//        public async Task<CsvBatchInfoDto?> GetBatchAsync(Guid businessId, Guid batchId, CancellationToken ct = default)\n//        {\n//            var batch = await _db.CsvBatches\n//                .AsNoTracking()\n//                .FirstOrDefaultAsync(b => b.Id == batchId && b.BusinessId == businessId, ct);\n\n//            if (batch == null) return null;\n\n//            var headers = SafeParseHeaderArray(batch.HeadersJson);\n\n//            return new CsvBatchInfoDto\n//            {\n//                BatchId = batch.Id,\n//                AudienceId = batch.AudienceId,\n//                RowCount = batch.RowCount,\n//                Headers = headers,\n//                CreatedAt = batch.CreatedAt\n//            };\n//        }\n\n//        // ----------------------------\n//        // Samples (single implementation)\n//        // ----------------------------\n//        public async Task<IReadOnlyList<CsvRowSampleDto>> GetSamplesAsync(\n//            Guid businessId,\n//            Guid batchId,\n//            int take = 20,\n//            CancellationToken ct = default)\n//        {\n//            if (take <= 0) take = 20;\n//            if (take > 100) take = 100;\n\n//            var batch = await _db.CsvBatches\n//                .AsNoTracking()\n//                .Where(b => b.Id == batchId && b.BusinessId == businessId)\n//                .Select(b => new { b.Id, b.HeadersJson, b.RowCount })\n//                .FirstOrDefaultAsync(ct);\n\n//            if (batch is null)\n//                throw new KeyNotFoundException(\"Batch not found.\");\n\n//            // If no rows yet, return empty samples gracefully\n//            if (batch.RowCount <= 0)\n//                return Array.Empty<CsvRowSampleDto>();\n\n//            var headerList = SafeParseHeaderArray(batch.HeadersJson);\n\n//            var rows = await _db.CsvRows\n//                .AsNoTracking()\n//                .Where(r => r.BusinessId == businessId && r.BatchId == batchId)\n//                .OrderBy(r => r.RowIndex)\n//                .Take(take)\n//                .Select(r => new { r.RowIndex, r.DataJson })\n//                .ToListAsync(ct);\n\n//            var result = new List<CsvRowSampleDto>(rows.Count);\n//            foreach (var r in rows)\n//            {\n//                var dict = SafeParseDict(r.DataJson);\n\n//                // Ensure consistent header order (fill missing with null)\n//                var ordered = new Dictionary<string, string?>(headerList.Count, StringComparer.OrdinalIgnoreCase);\n//                foreach (var h in headerList)\n//                {\n//                    dict.TryGetValue(h, out var v);\n//                    ordered[h] = v;\n//                }\n\n//                result.Add(new CsvRowSampleDto\n//                {\n//                    RowIndex = r.RowIndex,\n//                    Data = ordered\n//                });\n//            }\n\n//            return result;\n//        }\n\n//        // ----------------------------\n//        // List / Page / Delete / Validate\n//        // ----------------------------\n//        public async Task<List<CsvBatchListItemDto>> ListBatchesAsync(Guid businessId, int limit = 20, CancellationToken ct = default)\n//        {\n//            if (limit <= 0) limit = 20;\n//            if (limit > 100) limit = 100;\n\n//            return await _db.CsvBatches\n//                .AsNoTracking()\n//                .Where(b => b.BusinessId == businessId)\n//                .OrderByDescending(b => b.CreatedAt)\n//                .Take(limit)\n//                .Select(b => new CsvBatchListItemDto\n//                {\n//                    BatchId = b.Id,\n//                    FileName = b.FileName,\n//                    RowCount = b.RowCount,\n//                    Status = b.Status,\n//                    CreatedAt = b.CreatedAt\n//                })\n//                .ToListAsync(ct);\n//        }\n\n//        public async Task<CsvBatchRowsPageDto> GetRowsPageAsync(Guid businessId, Guid batchId, int skip, int take, CancellationToken ct = default)\n//        {\n//            if (take <= 0) take = 50;\n//            if (take > 200) take = 200;\n//            if (skip < 0) skip = 0;\n\n//            var exists = await _db.CsvBatches.AsNoTracking()\n//                .AnyAsync(b => b.Id == batchId && b.BusinessId == businessId, ct);\n//            if (!exists) throw new KeyNotFoundException(\"CSV batch not found.\");\n\n//            var total = await _db.CsvRows.AsNoTracking()\n//                .Where(r => r.BusinessId == businessId && r.BatchId == batchId)\n//                .CountAsync(ct);\n\n//            var rows = await _db.CsvRows.AsNoTracking()\n//                .Where(r => r.BusinessId == businessId && r.BatchId == batchId)\n//                .OrderBy(r => r.RowIndex)\n//                .Skip(skip)\n//                .Take(take)\n//                .Select(r => new CsvRowSampleDto\n//                {\n//                    RowIndex = r.RowIndex,\n//                    Data = SafeParseDict(r.DataJson)\n//                })\n//                .ToListAsync(ct);\n\n//            return new CsvBatchRowsPageDto\n//            {\n//                BatchId = batchId,\n//                TotalRows = total,\n//                Skip = skip,\n//                Take = take,\n//                Rows = rows\n//            };\n//        }\n\n//        public async Task<bool> DeleteBatchAsync(Guid businessId, Guid batchId, CancellationToken ct = default)\n//        {\n//            var batch = await _db.CsvBatches\n//                .FirstOrDefaultAsync(b => b.Id == batchId && b.BusinessId == businessId, ct);\n\n//            if (batch == null) return false;\n\n//            using var tx = await _db.Database.BeginTransactionAsync(ct);\n//            try\n//            {\n//                var rows = _db.CsvRows.Where(r => r.BusinessId == businessId && r.BatchId == batchId);\n//                _db.CsvRows.RemoveRange(rows);\n\n//                _db.CsvBatches.Remove(batch);\n\n//                await _db.SaveChangesAsync(ct);\n//                await tx.CommitAsync(ct);\n//                return true;\n//            }\n//            catch\n//            {\n//                await tx.RollbackAsync(ct);\n//                throw;\n//            }\n//        }\n\n//        private static readonly string[] PhoneHeaderCandidates =\n//        {  \"phone\", \"phone_number\", \"phonenumber\", \"phoneNumber\", \"phone-no\", \"phone_no\",\n//             \"mobile\", \"mobile_number\", \"mobilenumber\", \"whatsapp\", \"whatsapp_no\", \"whatsapp_number\" };\n\n//        public async Task<CsvBatchValidationResultDto> ValidateAsync(\n//            Guid businessId,\n//            Guid batchId,\n//            CsvBatchValidationRequestDto request,\n//            CancellationToken ct = default)\n//        {\n//            if (request is null) throw new ArgumentNullException(nameof(request));\n//            if (request.SampleSize <= 0) request.SampleSize = 20;\n//            if (request.SampleSize > 100) request.SampleSize = 100;\n\n//            var batch = await _db.CsvBatches.AsNoTracking()\n//                .Where(b => b.BusinessId == businessId && b.Id == batchId)\n//                .Select(b => new { b.Id, b.HeadersJson, b.RowCount })\n//                .FirstOrDefaultAsync(ct);\n\n//            if (batch == null) throw new KeyNotFoundException(\"CSV batch not found.\");\n\n//            var headers = SafeParseHeaderArray(batch.HeadersJson);\n//            var headerSet = new HashSet<string>(headers, StringComparer.OrdinalIgnoreCase);\n\n//            var result = new CsvBatchValidationResultDto\n//            {\n//                BatchId = batchId,\n//                TotalRows = batch.RowCount\n//            };\n\n//            // Required headers check\n//            if (request.RequiredHeaders != null && request.RequiredHeaders.Count > 0)\n//            {\n//                foreach (var req in request.RequiredHeaders)\n//                {\n//                    if (!headerSet.Contains(req))\n//                        result.MissingRequiredHeaders.Add(req);\n//                }\n\n//                if (result.MissingRequiredHeaders.Count > 0)\n//                    result.Errors.Add(\"Required headers are missing.\");\n//            }\n\n//            // Determine phone field\n//            var phoneField = request.PhoneField;\n//            if (string.IsNullOrWhiteSpace(phoneField))\n//                phoneField = PhoneHeaderCandidates.FirstOrDefault(headerSet.Contains);\n\n//            result.PhoneField = phoneField;\n\n//            if (string.IsNullOrWhiteSpace(phoneField))\n//            {\n//                result.Errors.Add(\"No phone field provided or detected.\");\n//                return result; // cannot scan rows without a phone column\n//            }\n\n//            // Scan rows for phone presence & duplicates\n//            var seenPhones = new HashSet<string>(StringComparer.Ordinal);\n//            var problemSamples = new List<CsvRowSampleDto>();\n\n//            var rowsQuery = _db.CsvRows.AsNoTracking()\n//                .Where(r => r.BusinessId == businessId && r.BatchId == batchId)\n//                .OrderBy(r => r.RowIndex)\n//                .Select(r => new { r.RowIndex, r.DataJson });\n\n//            await foreach (var row in rowsQuery.AsAsyncEnumerable().WithCancellation(ct))\n//            {\n//                var dict = SafeParseDict(row.DataJson);\n//                dict.TryGetValue(phoneField, out var rawPhone);\n\n//                // var normalized = NormalizePhoneMaybe(rawPhone, request.NormalizePhones);\n//                var normalized = NormalizeToE164OrError(rawPhone, out var phoneErr);\n//                var isProblem = false;\n\n//                if (string.IsNullOrWhiteSpace(normalized))\n//                {\n//                    // failed normalization → treat as missing/invalid phone\n//                    result.MissingPhoneCount++;\n//                    isProblem = true;\n//                    if (problemSamples.Count < request.SampleSize)\n//                    {\n//                        // include the error text in the sample row so UI can show why it failed\n//                        var dictWithErr = SafeParseDict(row.DataJson);\n//                        dictWithErr[\"__phone_error__\"] = phoneErr;\n//                        problemSamples.Add(new CsvRowSampleDto { RowIndex = row.RowIndex, Data = dictWithErr });\n//                    }\n//                }\n//                else if (request.Deduplicate && !seenPhones.Add(normalized))\n//                {\n//                    result.DuplicatePhoneCount++;\n//                    isProblem = true;\n//                }\n\n//                if (isProblem && problemSamples.Count < request.SampleSize)\n//                {\n//                    problemSamples.Add(new CsvRowSampleDto\n//                    {\n//                        RowIndex = row.RowIndex,\n//                        Data = dict\n//                    });\n//                }\n//            }\n\n//            result.ProblemSamples = problemSamples;\n\n//            if (result.MissingPhoneCount > 0)\n//                result.Errors.Add(\"Some rows are missing phone numbers.\");\n//            if (result.DuplicatePhoneCount > 0)\n//                result.Warnings.Add(\"Duplicate phone numbers detected (after normalization).\");\n\n//            return result;\n//        }\n\n//        // ----------------------------\n//        // helpers\n//        // ----------------------------\n//        private static List<string> SafeParseHeaderArray(string? json)\n//        {\n//            try\n//            {\n//                return string.IsNullOrWhiteSpace(json)\n//                    ? new List<string>()\n//                    : (JsonSerializer.Deserialize<List<string>>(json) ?? new List<string>());\n//            }\n//            catch { return new List<string>(); }\n//        }\n\n//        private static Dictionary<string, string?> SafeParseDict(string? json)\n//        {\n//            try\n//            {\n//                return string.IsNullOrWhiteSpace(json)\n//                    ? new Dictionary<string, string?>()\n//                    : (JsonSerializer.Deserialize<Dictionary<string, string?>>(json) ??\n//                       new Dictionary<string, string?>());\n//            }\n//            catch { return new Dictionary<string, string?>(); }\n//        }\n\n//        private static char DetectDelimiter(string headerLine)\n//        {\n//            var candidates = new[] { ',', ';', '\\t' };\n//            var counts = candidates.Select(c => (c, count: headerLine.Count(ch => ch == c))).ToList();\n//            var best = counts.OrderByDescending(x => x.count).First();\n//            return best.count > 0 ? best.c : ',';\n//        }\n\n//        /// <summary>\n//        /// CSV parser with delimiter support: handles commas/semicolons/tabs, double quotes,\n//        /// and escaped quotes (\"\"). It does NOT support embedded newlines inside quoted fields.\n//        /// </summary>\n//        private static List<string> ParseCsvLine(string line, char delimiter)\n//        {\n//            var result = new List<string>();\n//            if (line == null) return result;\n\n//            var sb = new StringBuilder();\n//            bool inQuotes = false;\n\n//            for (int i = 0; i < line.Length; i++)\n//            {\n//                var c = line[i];\n\n//                if (inQuotes)\n//                {\n//                    if (c == '\"')\n//                    {\n//                        // Handle escaped quote \"\"\n//                        if (i + 1 < line.Length && line[i + 1] == '\"')\n//                        {\n//                            sb.Append('\"');\n//                            i++;\n//                        }\n//                        else\n//                        {\n//                            inQuotes = false;\n//                        }\n//                    }\n//                    else\n//                    {\n//                        sb.Append(c);\n//                    }\n//                }\n//                else\n//                {\n//                    if (c == delimiter)\n//                    {\n//                        result.Add(sb.ToString());\n//                        sb.Clear();\n//                    }\n//                    else if (c == '\"')\n//                    {\n//                        inQuotes = true;\n//                    }\n//                    else\n//                    {\n//                        sb.Append(c);\n//                    }\n//                }\n//            }\n\n//            result.Add(sb.ToString());\n//            return result;\n//        }\n\n\n//        private static readonly HashSet<string> VALID_CC = new(StringComparer.Ordinal)\n//        {\n//            // 1-digit\n//            \"1\",          // NANP (US/CA)\n//            // 2-digit - common targets\n//            \"20\",\"27\",\"30\",\"31\",\"32\",\"33\",\"34\",\"36\",\"39\",\"40\",\"41\",\"43\",\"44\",\"45\",\"46\",\"47\",\"48\",\"49\",\n//            \"51\",\"52\",\"53\",\"54\",\"55\",\"56\",\"57\",\"58\",\"60\",\"61\",\"62\",\"63\",\"64\",\"65\",\"66\",\n//            \"81\",\"82\",\"84\",\"86\",\"90\",\"91\",\"92\",\"93\",\"94\",\"95\",\"98\",\n//            // 3-digit - GCC & a few others you likely need\n//            \"966\",\"971\"   // SA, AE\n//        };\n\n//        private static string? NormalizeToE164OrError(string? input, out string error)\n//        {\n//            error = \"\";\n//            if (string.IsNullOrWhiteSpace(input)) { error = \"Empty phone.\"; return null; }\n\n//            var s = input.Trim();\n\n//            // Case A: already +E.164\n//            if (s.StartsWith(\"+\", StringComparison.Ordinal))\n//            {\n//                if (!IsE164(s)) { error = \"Must be +E.164: '+' followed by 8–15 digits.\"; return null; }\n\n//                var noPlus = s.Substring(1);\n//                var cc = ExtractCcByLongestPrefix(noPlus);\n//                if (string.IsNullOrEmpty(cc)) { error = \"Unsupported country code.\"; return null; }\n\n//                // basic NN sanity for a few big markets; keep permissive otherwise\n//                var nn = noPlus.Substring(cc.Length);\n//                if (!PassesBasicNationalLength(cc, nn)) { error = $\"Invalid national length for +{cc}.\"; return null; }\n\n//                return s;\n//            }\n\n//            // Case B: digits only\n//            var digits = new string(s.Where(char.IsDigit).ToArray());\n//            if (digits.Length < 11 || digits.Length > 15)\n//            { error = \"Include country code (11–15 digits if no '+').\"; return null; }\n\n//            var cc2 = ExtractCcByLongestPrefix(digits);\n//            if (string.IsNullOrEmpty(cc2))\n//            { error = \"Unsupported country code.\"; return null; }\n\n//            var nn2 = digits.Substring(cc2.Length);\n//            if (!PassesBasicNationalLength(cc2, nn2))\n//            { error = $\"Invalid national length for +{cc2}.\"; return null; }\n\n//            return \"+\" + digits;\n//        }\n\n//        private static bool IsE164(string s)\n//        {\n//            if (s.Length < 9 || s.Length > 16) return false; // '+' + 8..15 digits\n//            for (int i = 1; i < s.Length; i++) if (!char.IsDigit(s[i])) return false;\n//            return true;\n//        }\n\n//        private static string ExtractCcByLongestPrefix(string digitsNoPlus)\n//        {\n//            if (digitsNoPlus.Length >= 3 && VALID_CC.Contains(digitsNoPlus[..3])) return digitsNoPlus[..3];\n//            if (digitsNoPlus.Length >= 2 && VALID_CC.Contains(digitsNoPlus[..2])) return digitsNoPlus[..2];\n//            if (digitsNoPlus.Length >= 1 && VALID_CC.Contains(digitsNoPlus[..1])) return digitsNoPlus[..1];\n//            return \"\";\n//        }\n\n\n//        // Pragmatic checks for common markets; keep permissive for others (4..12)\n//        private static bool PassesBasicNationalLength(string cc, string nn)\n//        {\n//            if (cc == \"1\") return nn.Length == 10; // NANP\n//            if (cc == \"91\") return nn.Length == 10; // India\n//            if (cc == \"94\") return nn.Length == 9;  // Sri Lanka\n//            if (cc == \"966\") return nn.Length == 9;  // Saudi Arabia\n//            return nn.Length >= 4 && nn.Length <= 12;\n//        }\n\n//    }\n//}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/CsvExportService.cs",
      "sha256": "98366ed493eba2967478ea12bedd43b2d0c3a355667e89f23db3a6dd734554a9",
      "language": "csharp",
      "size": 7057,
      "content": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Serilog;\nusing xbytechat.api.Features.CampaignModule.Services;\nusing xbytechat.api.Features.CampaignModule.DTOs;\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    public interface ICsvExportService\n    {\n        Task<byte[]> BuildMaterializedCsvAsync(Guid businessId, Guid campaignId, int limit = 200, CancellationToken ct = default);\n        Task<byte[]> BuildDispatchPlanCsvAsync(Guid businessId, Guid campaignId, int limit = 2000, CancellationToken ct = default);\n    }\n\n    /// <summary>\n    /// Small CSV builder for exporting materialized rows and dispatch plans.\n    /// Uses UTF-8 with BOM for Excel friendliness. Escapes fields per RFC4180.\n    /// </summary>\n    public class CsvExportService : ICsvExportService\n    {\n        private readonly ICampaignMaterializationService _materializer;\n        private readonly ICampaignDispatchPlannerService _planner;\n\n        public CsvExportService(\n            ICampaignMaterializationService materializer,\n            ICampaignDispatchPlannerService planner)\n        {\n            _materializer = materializer;\n            _planner = planner;\n        }\n\n        public async Task<byte[]> BuildMaterializedCsvAsync(Guid businessId, Guid campaignId, int limit = 200, CancellationToken ct = default)\n        {\n            var data = await _materializer.MaterializeAsync(businessId, campaignId, limit, ct);\n\n            // Header is dynamic based on placeholder count and button count.\n            // Columns:\n            // RecipientId,ContactId,Phone,Param1..ParamN,Btn1Text,Btn1Url,...,Warnings,Errors\n            var maxParam = data.PlaceholderCount;\n            var maxButtons = data.Rows.Max(r => r.Buttons.Count);\n\n            var sb = new StringBuilder();\n            using var writer = new StringWriter(sb);\n\n            // Write header\n            writer.Write(\"RecipientId,ContactId,Phone\");\n            for (int i = 1; i <= maxParam; i++) writer.Write($\",Param{i}\");\n            for (int b = 1; b <= maxButtons; b++) writer.Write($\",Btn{b}Text,Btn{b}Url\");\n            writer.Write(\",Warnings,Errors\");\n            writer.WriteLine();\n\n            foreach (var row in data.Rows)\n            {\n                WriteCsv(writer, row.RecipientId?.ToString());\n                writer.Write(\",\");\n                WriteCsv(writer, row.ContactId?.ToString());\n                writer.Write(\",\");\n                WriteCsv(writer, row.Phone);\n\n                // Params 1..N (pad missing)\n                for (int i = 1; i <= maxParam; i++)\n                {\n                    writer.Write(\",\");\n                    var val = row.Parameters.FirstOrDefault(p => p.Index == i)?.Value;\n                    WriteCsv(writer, val);\n                }\n\n                // Buttons (pad missing)\n                for (int b = 0; b < maxButtons; b++)\n                {\n                    var btn = b < row.Buttons.Count ? row.Buttons[b] : null;\n                    writer.Write(\",\");\n                    WriteCsv(writer, btn?.ButtonText);\n                    writer.Write(\",\");\n                    WriteCsv(writer, btn?.ResolvedUrl);\n                }\n\n                writer.Write(\",\");\n                WriteCsv(writer, string.Join(\" | \", row.Warnings));\n                writer.Write(\",\");\n                WriteCsv(writer, string.Join(\" | \", row.Errors));\n                writer.WriteLine();\n            }\n\n            // Return as UTF-8 with BOM for Excel compatibility\n            var utf8withBom = new UTF8Encoding(encoderShouldEmitUTF8Identifier: true);\n            return utf8withBom.GetBytes(sb.ToString());\n        }\n\n        public async Task<byte[]> BuildDispatchPlanCsvAsync(Guid businessId, Guid campaignId, int limit = 2000, CancellationToken ct = default)\n        {\n            var plan = await _planner.PlanAsync(businessId, campaignId, limit, ct);\n\n            var sb = new StringBuilder();\n            using var writer = new StringWriter(sb);\n\n            // Plan metadata preface (comment-style rows start with '#')\n            writer.WriteLine($\"# CampaignId,{plan.CampaignId}\");\n            writer.WriteLine($\"# TemplateName,{Escape(plan.TemplateName)}\");\n            writer.WriteLine($\"# Language,{Escape(plan.Language)}\");\n            writer.WriteLine($\"# PlaceholderCount,{plan.PlaceholderCount}\");\n            writer.WriteLine($\"# TotalRecipients,{plan.TotalRecipients}\");\n            writer.WriteLine($\"# ProviderPlan,{Escape(plan.Throttle.Plan)}\");\n            writer.WriteLine($\"# Provider,{Escape(plan.Throttle.Provider)}\");\n            writer.WriteLine($\"# MaxBatchSize,{plan.Throttle.MaxBatchSize}\");\n            writer.WriteLine($\"# MaxPerMinute,{plan.Throttle.MaxPerMinute}\");\n            writer.WriteLine($\"# ComputedBatches,{plan.Throttle.ComputedBatches}\");\n            writer.WriteLine($\"# EstimatedMinutes,{plan.Throttle.EstimatedMinutes}\");\n            if (plan.GlobalWarnings.Any())\n                writer.WriteLine($\"# GlobalWarnings,{Escape(string.Join(\" | \", plan.GlobalWarnings))}\");\n            if (plan.Throttle.Warnings.Any())\n                writer.WriteLine($\"# ThrottleWarnings,{Escape(string.Join(\" | \", plan.Throttle.Warnings))}\");\n\n            writer.WriteLine(); // blank line\n\n            // Batches table header\n            writer.WriteLine(\"BatchNumber,OffsetSeconds,StartIndex,Count,ApproxBytes,Phones,RecipientIds,Notes\");\n\n            foreach (var b in plan.Batches)\n            {\n                WriteCsv(writer, b.BatchNumber.ToString());\n                writer.Write(\",\");\n                WriteCsv(writer, b.OffsetSeconds.ToString());\n                writer.Write(\",\");\n                WriteCsv(writer, b.StartIndex.ToString());\n                writer.Write(\",\");\n                WriteCsv(writer, b.Count.ToString());\n                writer.Write(\",\");\n                WriteCsv(writer, b.ApproxBytes.ToString());\n                writer.Write(\",\");\n                WriteCsv(writer, string.Join(\" \", b.Phones.Select(p => p ?? \"\")));\n                writer.Write(\",\");\n                WriteCsv(writer, string.Join(\" \", b.RecipientIds.Select(id => id?.ToString() ?? \"\")));\n                writer.Write(\",\");\n                WriteCsv(writer, string.Join(\" | \", b.Notes));\n                writer.WriteLine();\n            }\n\n            var utf8withBom = new UTF8Encoding(encoderShouldEmitUTF8Identifier: true);\n            return utf8withBom.GetBytes(sb.ToString());\n        }\n\n        private static void WriteCsv(TextWriter writer, string? value)\n        {\n            writer.Write(Escape(value ?? \"\"));\n        }\n\n        private static string Escape(string input)\n        {\n            // RFC4180-style: quote if contains comma, quote or newline; escape quotes by doubling\n            var needsQuote = input.Contains(',') || input.Contains('\"') || input.Contains('\\n') || input.Contains('\\r');\n            if (!needsQuote) return input;\n            return $\"\\\"{input.Replace(\"\\\"\", \"\\\"\\\"\")}\\\"\";\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/ICampaignAudienceAttachmentService.cs",
      "sha256": "b9ccbfca837478429ebbd9dba1bdcf2520ce82cc03aaa45a16763823dbe44892",
      "language": "csharp",
      "size": 2135,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Http;\nusing xbytechat.api.Features.CampaignModule.DTOs;\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    public interface ICampaignAudienceAttachmentService\n    {\n        Task<CampaignAudienceDto> GetActiveAsync(Guid businessId, Guid campaignId, CancellationToken ct = default);\n        Task<IReadOnlyList<CampaignAudienceHistoryItemDto>> GetHistoryAsync(Guid businessId, Guid campaignId, CancellationToken ct = default);\n\n        /// <summary>\n        /// Replaces the active CSV audience before send. This deactivates the previous attachment (history is preserved),\n        /// rebuilds ONLY CSV-derived recipients (AudienceMemberId != null), and leaves manual recipients intact.\n        /// </summary>\n        Task<CampaignAudienceReplaceResponseDto> ReplaceAsync(\n            Guid businessId,\n            Guid campaignId,\n            IFormFile csvFile,\n            string? audienceName,\n            string actor,\n            CancellationToken ct = default);\n\n        /// <summary>\n        /// Removes/detaches the active CSV audience before send. This deactivates the attachment (history is preserved)\n        /// and deletes ONLY CSV-derived recipients (AudienceMemberId != null).\n        /// </summary>\n        Task<CampaignAudienceRemoveResponseDto> RemoveAsync(\n            Guid businessId,\n            Guid campaignId,\n            string actor,\n            CancellationToken ct = default);\n\n        /// <summary>\n        /// Shared persist path for POST /api/campaigns/{campaignId}/materialize when Persist=true.\n        /// This keeps attachments + CSV-derived recipients aligned with what the user just materialized.\n        /// </summary>\n        Task<CampaignAudienceReplaceResponseDto> ReplaceFromMaterializationAsync(\n            Guid businessId,\n            Guid campaignId,\n            CampaignCsvMaterializeRequestDto request,\n            IReadOnlyList<CsvMaterializedRowDto> materializedRows,\n            string actor,\n            CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/ICampaignDispatcher.cs",
      "sha256": "7ea08b6385a5f9c2861a417d0ba9ed59f386c613614b462ffbaa53ace5cb56e8",
      "language": "csharp",
      "size": 652,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CampaignModule.DTOs;\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    public interface ICampaignDispatcher\n    {\n        /// <summary>\n        /// mode: \"canary\" (use count) or \"full\" (ignore count, select all ready).\n        /// count: when mode=canary, number of recipients to enqueue (default 25).\n        /// </summary>\n        Task<CampaignDispatchResponseDto> DispatchAsync(\n            Guid businessId,\n            Guid campaignId,\n            string mode,\n            int count,\n            CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/ICampaignDryRunService.cs",
      "sha256": "8ee4671e2a7d2ac659e127e72121295904129c5d31e82fad35401dc50f10a717",
      "language": "csharp",
      "size": 662,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CampaignModule.DTOs;\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    /// <summary>\n    /// Validates a campaign for send safety without actually sending any message.\n    /// </summary>\n    public interface ICampaignDryRunService\n    {\n        /// <summary>\n        /// Run dry-run validation for a campaign. Should not mutate state.\n        /// </summary>\n        Task<CampaignDryRunResultDto> ValidateAsync(\n            Guid businessId,\n            Guid campaignId,\n            int limit = 200,\n            CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/ICampaignMaterializationService.cs",
      "sha256": "45174c0e9b318f8f145ffd682ecf042a166872989ec0a9637342c3fe47d8fa6d",
      "language": "csharp",
      "size": 358,
      "content": "using xbytechat.api.Features.CampaignModule.DTOs;\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    public interface ICampaignMaterializationService\n    {\n        Task<CampaignMaterializeResultDto> MaterializeAsync(\n        Guid businessId,\n        Guid campaignId,\n        int limit = 200,\n            CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/ICampaignMaterializer.cs",
      "sha256": "98d32de9d130b65ea77f9381f92fb27bdbd3750a534fc8f6579854bd4201cc94",
      "language": "csharp",
      "size": 479,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CampaignModule.DTOs;\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    public interface ICampaignMaterializer\n    {\n        Task<CampaignCsvMaterializeResponseDto> CreateAsync(\n            Guid businessId,\n            Guid campaignId,\n            CampaignCsvMaterializeRequestDto request,\n            string actor,\n            CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/ICampaignRecipientService.cs",
      "sha256": "5e8fc7101147a1ce4ef9a7aa408f53df15d24e1007bdd060e227ba4346b98e7e",
      "language": "csharp",
      "size": 833,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CampaignModule.DTOs;\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    public interface ICampaignRecipientService\n    {\n        Task<CampaignRecipientDto?> GetByIdAsync(Guid businessId, Guid id);\n        Task<List<CampaignRecipientDto>> GetByCampaignIdAsync(Guid businessId, Guid campaignId);\n\n        Task<bool> UpdateStatusAsync(Guid businessId, Guid recipientId, string newStatus);\n        Task<bool> TrackReplyAsync(Guid businessId, Guid recipientId, string replyText);\n        Task<List<CampaignRecipientDto>> SearchRecipientsAsync(Guid businessId, string? status = null, string? keyword = null);\n\n        Task AssignContactsToCampaignAsync(Guid businessId, Guid campaignId, List<Guid> contactIds);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/ICampaignRetargetService.cs",
      "sha256": "a56b1279013a76edce5098e6fc02cf37a7bae51bcc75d7c5c9641128a0246d5f",
      "language": "csharp",
      "size": 447,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CampaignModule.DTOs;\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    public interface ICampaignRetargetService\n    {\n        Task<RetargetCampaignResponseDto> CreateRetargetCampaignAsync(\n            Guid businessId,\n            RetargetCampaignRequestDto dto,\n            string createdBy,\n            CancellationToken ct);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/ICampaignRetryService.cs",
      "sha256": "77b2d8c8b67c691891ba7e6e1b014af847932714edcd60acfd419c092aa3c4bc",
      "language": "csharp",
      "size": 274,
      "content": "using xbytechat.api.Features.CampaignModule.DTOs;\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    public interface ICampaignRetryService\n    {\n        Task<CampaignRetryResultDto> RetryFailedAsync(Guid businessId, Guid campaignId, int limit = 200);\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/ICampaignService.cs",
      "sha256": "9e06f9bf595c8415ff43f4f1af6bfab07085dcf77d740b06debdc2e2901bef23",
      "language": "csharp",
      "size": 2979,
      "content": "using System;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing xbytechat.api.Shared;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Features.CampaignModule.Models;\nusing xbytechat.api.Features.CRM.Dtos;\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    public interface ICampaignService\n    {\n        /// 🆕 Create a new campaign with recipients\n        Task<Guid?> CreateTextCampaignAsync(CampaignCreateDto dto, Guid businessId, string createdBy);\n\n        /// ✏️ Update an existing draft campaign\n        Task<bool> UpdateCampaignAsync(Guid id, CampaignCreateDto dto);\n\n      \n        /// 📋 Get all campaigns for the business\n        //Task<List<CampaignSummaryDto>> GetAllCampaignsAsync(Guid businessId);\n\n        /// 📄 Get paginated campaigns\n        Task<PaginatedResponse<CampaignSummaryDto>> GetPaginatedCampaignsAsync(Guid businessId, PaginatedRequest request);\n        /// 🚀 Trigger campaign send flow (template message to all recipients)\n        Task<bool> SendCampaignAsync(Guid campaignId, string ipAddress, string userAgent);\n        Task<Guid> CreateImageCampaignAsync(Guid businessId, CampaignCreateDto dto, string createdBy);\n        Task<List<CampaignSummaryDto>> GetAllCampaignsAsync(Guid businessId, string? type = null);\n        Task<List<ContactDto>> GetRecipientsByCampaignIdAsync(Guid campaignId, Guid businessId);\n        Task<bool> RemoveRecipientAsync(Guid businessId, Guid campaignId, Guid contactId);\n        Task<CampaignDto?> GetCampaignByIdAsync(Guid campaignId, Guid businessId);\n        Task<bool> AssignContactsToCampaignAsync(Guid campaignId, Guid businessId, List<Guid> contactIds);\n\n        Task<ResponseResult> SendTemplateCampaignAsync(Guid campaignId);\n\n        Task<ResponseResult> SendTemplateCampaignWithTypeDetectionAsync(Guid campaignId, CancellationToken ct = default);\n\n        Task<ResponseResult> SendTextTemplateCampaignAsync(Campaign campaign);\n        Task<ResponseResult> SendImageTemplateCampaignAsync(Campaign campaign);\n\n        Task<List<FlowListItemDto>> GetAvailableFlowsAsync(Guid businessId, bool onlyPublished = true);\n\n        Task<CampaignDryRunResponseDto> DryRunTemplateCampaignAsync(Guid campaignId, int maxRecipients = 20);\n        Task<object> SendVideoTemplateMessageAsync(VideoTemplateMessageDto dto, Guid businessId);\n\n        Task<bool> CheckNameAvailableAsync(Guid businessId, string name);\n        Task RescheduleAsync(Guid businessId, Guid campaignId, DateTime newUtcTime);\n        Task EnqueueNowAsync(Guid businessId, Guid campaignId);\n        Task CancelScheduleAsync(Guid businessId, Guid campaignId);\n        Task<CampaignDeletionResult> DeleteCampaignAsync(\n            Guid businessId,\n            Guid id,\n            CampaignDeletionOptions options,\n            CancellationToken ct = default);\n        Task<CampaignUsageDto?> GetCampaignUsageAsync(Guid businessId, Guid campaignId);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/ICsvBatchService.cs",
      "sha256": "354a34ab57d057ccd0d3fade616e9e149d7e6a5c697c3d81a1d0347999f14d6f",
      "language": "csharp",
      "size": 1601,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CampaignModule.DTOs;\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    public interface ICsvBatchService\n    {\n        //Task<CsvBatchUploadResultDto> CreateAndIngestAsync(\n        //    Guid businessId,\n        //    string fileName,\n        //    Stream stream,\n        //    Guid? audienceId = null,\n        //    CancellationToken ct = default\n        //);\n    \n            Task<CsvBatchUploadResultDto> CreateAndIngestAsync(\n                Guid businessId,\n                string fileName,\n                Stream stream,\n                Guid? audienceId = null,\n                Guid? campaignId = null,\n                CancellationToken ct = default);\n      \n\n        Task<CsvBatchInfoDto?> GetBatchAsync(Guid businessId, Guid batchId, CancellationToken ct = default);\n        Task<IReadOnlyList<CsvRowSampleDto>> GetSamplesAsync(Guid businessId, Guid batchId, int take = 20, CancellationToken ct = default);\n        Task<CsvBatchValidationResultDto> ValidateAsync(Guid businessId, Guid batchId, CsvBatchValidationRequestDto request, CancellationToken ct = default);\n        Task<List<CsvBatchListItemDto>> ListBatchesAsync(Guid businessId, int limit = 20, CancellationToken ct = default);\n        Task<CsvBatchRowsPageDto> GetRowsPageAsync(Guid businessId, Guid batchId, int skip, int take, CancellationToken ct = default);\n        Task<bool> DeleteBatchAsync(Guid businessId, Guid batchId, CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/IMappingSuggestionService.cs",
      "sha256": "010ea9f12699609fa3addd18141bfba7bcf3ec585a43200b86cf3a2f8f0ef038",
      "language": "csharp",
      "size": 641,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    /// <summary>\n    /// Suggests a token->source mapping (\"csv:Header\" or \"static:\") given a campaign and CSV batch.\n    /// Uses Campaign.TemplateParameters if present; otherwise derives tokens from CSV headers.\n    /// </summary>\n    public interface IMappingSuggestionService\n    {\n        Task<Dictionary<string, string>> SuggestAsync(\n            Guid businessId,\n            Guid campaignId,\n            Guid batchId,\n            CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/Interface.cs",
      "sha256": "b499bed78d394052736ab9f463d1f5737462a52f755329e27050b2f72a1b846c",
      "language": "csharp",
      "size": 104,
      "content": "namespace xbytechat.api.Features.CampaignModule.Services\n{\n    public interface Interface\n    {\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/IOutboundCampaignQueueService.cs",
      "sha256": "a085fb2166af4a18a8f3499aa61280313e0c0dbd358fbaa54eb9562e8337fc80",
      "language": "csharp",
      "size": 1044,
      "content": "using System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CampaignModule.Models;\nusing xbytechat.api.Features.Queueing.DTOs;\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    public interface IOutboundCampaignQueueService\n    {\n        Task<Guid> EnqueueAsync(Guid businessId, Guid campaignId, bool forceDuplicate = false);\n        Task<bool> MarkSucceededAsync(Guid jobId);\n        Task<bool> MarkFailedAsync(Guid jobId, string error, bool scheduleRetry = true);\n\n        Task<List<OutboundCampaignJob>> GetJobsForCampaignAsync(Guid businessId, Guid campaignId);\n        Task<OutboundCampaignJob?> GetActiveJobForCampaignAsync(Guid businessId, Guid campaignId);\n        Task<bool> CancelAsync(Guid businessId, Guid jobId);     // set to \"canceled\" (if queued/running)\n        Task<bool> ForceRetryNowAsync(Guid businessId, Guid jobId); // set to \"queued\", NextAttemptAt=now (no attempt++)\n        Task<int> EnqueueBulkAsync(IEnumerable<OutboundCampaignJobCreateDto> jobs, CancellationToken ct = default);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/IVariableMappingService.cs",
      "sha256": "dcf57112809de6e4dc9c3b7957cc9d591c65cace2d51cd24fc0795b6b12b8c5a",
      "language": "csharp",
      "size": 992,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    /// <summary>\n    /// Loads saved variable mappings for a campaign (e.g., token -> CSV header or \"constant:...\").\n    /// Current project does not require this to complete 2.4; this is a seam for future use.\n    /// </summary>\n    public interface IVariableMappingService\n    {\n        /// <returns>\n        /// Dictionary mapping variable token -> source (CSV header name or \"constant:Value\").\n        /// Return an empty dictionary when nothing is saved.\n        /// </returns>\n        Task<Dictionary<string, string>> GetForCampaignAsync(\n            Guid businessId,\n            Guid campaignId,\n            CancellationToken ct = default);\n        Task SaveAsync(\n           Guid businessId,\n           Guid campaignId,\n           Dictionary<string, string> mappings,\n           CancellationToken ct = default);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/MappingSuggestionService.cs",
      "sha256": "e6a82a860c5406f0e22ef3c89577a8c06081e49d21add5f9bc6682c0dc974dd3",
      "language": "csharp",
      "size": 5965,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.Json;\nusing System.Text.RegularExpressions;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api;\nusing xbytechat.api.Features.CampaignModule.Models;\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    /// <summary>\n    /// Heuristics:\n    /// - If Campaign.TemplateParameters is a JSON array of tokens, suggest for those tokens.\n    /// - Else, derive tokens by normalizing CSV headers (lowercase, alnum only, '_' joined).\n    /// - Match by normalized equality/contains; special-case phone names.\n    /// - Unmatched tokens get \"static:\" so UI shows a clear placeholder.\n    /// </summary>\n    public sealed class MappingSuggestionService : IMappingSuggestionService\n    {\n        private readonly AppDbContext _db;\n\n        private static readonly string[] PhoneHeaderCandidates =\n        {\n            \"phone\", \"mobile\", \"whatsapp\", \"msisdn\", \"whatsapp_number\", \"contact\", \"contact_number\"\n        };\n\n        public MappingSuggestionService(AppDbContext db) => _db = db;\n\n        public async Task<Dictionary<string, string>> SuggestAsync(\n            Guid businessId,\n            Guid campaignId,\n            Guid batchId,\n            CancellationToken ct = default)\n        {\n            // Load campaign to read TemplateParameters (if present)\n            var campaign = await _db.Campaigns.AsNoTracking()\n                .Where(c => c.Id == campaignId && c.BusinessId == businessId)\n                .Select(c => new { c.Id, c.BusinessId, c.TemplateParameters })\n                .FirstOrDefaultAsync(ct);\n\n            if (campaign == null) throw new KeyNotFoundException(\"Campaign not found.\");\n\n            // Load batch headers\n            var batch = await _db.CsvBatches.AsNoTracking()\n                .Where(b => b.Id == batchId && b.BusinessId == businessId)\n                .Select(b => new { b.HeadersJson })\n                .FirstOrDefaultAsync(ct);\n\n            if (batch == null) throw new KeyNotFoundException(\"CSV batch not found.\");\n\n            var headers = ParseHeaders(batch.HeadersJson);\n            var normHeaders = headers.ToDictionary(h => Normalize(h), h => h, StringComparer.OrdinalIgnoreCase);\n\n            // Determine tokens\n            var tokens = ParseTemplateTokens(campaign.TemplateParameters);\n            if (tokens.Count == 0)\n            {\n                // Fall back: derive tokens directly from headers\n                tokens = headers.Select(Normalize).Where(s => !string.IsNullOrWhiteSpace(s)).Distinct(StringComparer.OrdinalIgnoreCase).ToList();\n            }\n\n            // Suggestion: token -> source\n            var suggestions = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n\n            foreach (var token in tokens)\n            {\n                var normToken = Normalize(token);\n\n                // 1) direct equality with header\n                if (normHeaders.TryGetValue(normToken, out var exactHeader))\n                {\n                    suggestions[token] = $\"csv:{exactHeader}\";\n                    continue;\n                }\n\n                // 2) phone special-case\n                if (IsPhoneToken(normToken))\n                {\n                    var headerPick = headers.FirstOrDefault(h => PhoneHeaderCandidates.Contains(Normalize(h)));\n                    if (!string.IsNullOrEmpty(headerPick))\n                    {\n                        suggestions[token] = $\"csv:{headerPick}\";\n                        continue;\n                    }\n                }\n\n                // 3) contains / fuzzy-lite\n                var contains = headers.FirstOrDefault(h => Normalize(h).Contains(normToken, StringComparison.OrdinalIgnoreCase));\n                if (!string.IsNullOrEmpty(contains))\n                {\n                    suggestions[token] = $\"csv:{contains}\";\n                    continue;\n                }\n\n                // 4) default: static placeholder (UI can highlight to user)\n                suggestions[token] = \"static:\";\n            }\n\n            return suggestions;\n        }\n\n        private static List<string> ParseHeaders(string? headersJson)\n        {\n            if (string.IsNullOrWhiteSpace(headersJson)) return new List<string>();\n            try\n            {\n                var arr = JsonSerializer.Deserialize<List<string>>(headersJson);\n                return arr?.Where(h => !string.IsNullOrWhiteSpace(h)).ToList() ?? new List<string>();\n            }\n            catch\n            {\n                // Fallback: maybe comma-separated\n                return headersJson.Split(',').Select(s => s.Trim()).Where(s => s.Length > 0).ToList();\n            }\n        }\n\n        private static List<string> ParseTemplateTokens(string? templateParametersJson)\n        {\n            if (string.IsNullOrWhiteSpace(templateParametersJson)) return new List<string>();\n            try\n            {\n                var arr = JsonSerializer.Deserialize<List<string>>(templateParametersJson);\n                return arr?.Where(t => !string.IsNullOrWhiteSpace(t)).ToList() ?? new List<string>();\n            }\n            catch\n            {\n                return new List<string>();\n            }\n        }\n\n        private static bool IsPhoneToken(string normToken)\n        {\n            if (string.IsNullOrWhiteSpace(normToken)) return false;\n            if (PhoneHeaderCandidates.Contains(normToken)) return true;\n            return normToken.Contains(\"phone\") || normToken.Contains(\"mobile\") || normToken.Contains(\"whatsapp\");\n        }\n\n        private static string Normalize(string s)\n        {\n            var lowered = (s ?? \"\").Trim().ToLowerInvariant();\n            if (lowered.Length == 0) return lowered;\n            var alnum = Regex.Replace(lowered, @\"[^a-z0-9]+\", \"_\");\n            alnum = Regex.Replace(alnum, \"_{2,}\", \"_\").Trim('_');\n            return alnum;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/NoopVariableMappingService.cs",
      "sha256": "24a343d03f2ab867121a8ebfe09ebcf7672fb7a3261095b6dc2322633e1ae722",
      "language": "csharp",
      "size": 984,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    /// <summary>\n    /// Default stub: returns no saved mappings.\n    /// Swap this out later with a DB-backed implementation that reads CampaignVariableMap.\n    /// </summary>\n    public sealed class NoopVariableMappingService : IVariableMappingService\n    {\n        public Task<Dictionary<string, string>> GetForCampaignAsync(\n            Guid businessId,\n            Guid campaignId,\n            CancellationToken ct = default)\n        {\n            return Task.FromResult(new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase));\n        }\n\n        public Task SaveAsync(\n           Guid businessId,\n           Guid campaignId,\n           Dictionary<string, string> mappings,\n           CancellationToken ct = default)\n        {\n            // no-op\n            return Task.CompletedTask;\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/OutboundCampaignQueueService.cs",
      "sha256": "b81f57bff9d0409d1f72e2347814800b56d2a94f6696ce7a5ae1500b38c9648b",
      "language": "csharp",
      "size": 8110,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;                       // <-- add\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api;\nusing xbytechat.api.Features.CampaignModule.Models;\nusing xbytechat.api.Features.Queueing.DTOs;    // <-- add for OutboundCampaignJobCreateDto\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    public class OutboundCampaignQueueService : IOutboundCampaignQueueService\n    {\n        private readonly AppDbContext _db;\n        private readonly ILogger<OutboundCampaignQueueService> _log;\n\n        public OutboundCampaignQueueService(AppDbContext db, ILogger<OutboundCampaignQueueService> log)\n        {\n            _db = db; _log = log;\n        }\n\n        public async Task<Guid> EnqueueAsync(Guid businessId, Guid campaignId, bool forceDuplicate = false)\n        {\n            if (!forceDuplicate)\n            {\n                var existing = await _db.OutboundCampaignJobs\n                    .Where(j => j.CampaignId == campaignId && (j.Status == \"queued\" || j.Status == \"running\"))\n                    .OrderByDescending(j => j.CreatedAt)\n                    .FirstOrDefaultAsync();\n\n                if (existing != null)\n                {\n                    var found = await _db.Campaigns\n                        .FirstOrDefaultAsync(c => c.Id == campaignId && c.BusinessId == businessId);\n\n                    if (found != null && found.Status != \"Queued\")\n                    {\n                        found.Status = \"Queued\";\n                        found.UpdatedAt = DateTime.UtcNow;\n                        await _db.SaveChangesAsync();\n                    }\n\n                    _log.LogInformation(\"Campaign {CampaignId} already queued/running. Job={JobId}\", campaignId, existing.Id);\n                    return existing.Id;\n                }\n            }\n\n            var job = new OutboundCampaignJob\n            {\n                BusinessId = businessId,\n                CampaignId = campaignId,\n                Status = \"queued\",\n                Attempt = 0,\n                MaxAttempts = 5,\n                NextAttemptAt = DateTimeOffset.UtcNow\n            };\n\n            _db.OutboundCampaignJobs.Add(job);\n\n            var row = await _db.Campaigns\n                .FirstOrDefaultAsync(c => c.Id == campaignId && c.BusinessId == businessId);\n\n            if (row != null)\n            {\n                row.Status = \"Queued\";\n                row.UpdatedAt = DateTime.UtcNow;\n            }\n\n            await _db.SaveChangesAsync();\n            return job.Id;\n        }\n\n        public async Task<bool> MarkSucceededAsync(Guid jobId)\n        {\n            var j = await _db.OutboundCampaignJobs.FindAsync(jobId);\n            if (j == null) return false;\n\n            j.Attempt += 1;\n            j.Status = \"succeeded\";\n            j.UpdatedAt = DateTime.UtcNow;\n\n            await _db.SaveChangesAsync();\n            return true;\n        }\n\n        public async Task<bool> MarkFailedAsync(Guid jobId, string error, bool scheduleRetry = true)\n        {\n            var j = await _db.OutboundCampaignJobs.FindAsync(jobId);\n            if (j == null) return false;\n\n            j.Attempt += 1;\n            j.LastError = Truncate(error, 3900);\n            j.UpdatedAt = DateTime.UtcNow;\n\n            if (!scheduleRetry || j.Attempt >= j.MaxAttempts)\n            {\n                j.Status = \"failed\";\n            }\n            else\n            {\n                var backoff = j.Attempt switch\n                {\n                    1 => TimeSpan.FromMinutes(1),\n                    2 => TimeSpan.FromMinutes(5),\n                    3 => TimeSpan.FromMinutes(15),\n                    4 => TimeSpan.FromMinutes(60),\n                    _ => TimeSpan.FromMinutes(180)\n                };\n                j.Status = \"queued\";\n                j.NextAttemptAt = DateTimeOffset.UtcNow.Add(backoff);\n            }\n\n            await _db.SaveChangesAsync();\n            return true;\n        }\n\n        public async Task<List<OutboundCampaignJob>> GetJobsForCampaignAsync(Guid businessId, Guid campaignId)\n        {\n            return await _db.OutboundCampaignJobs\n                .Where(j => j.BusinessId == businessId && j.CampaignId == campaignId)\n                .OrderByDescending(j => j.CreatedAt)\n                .ToListAsync();\n        }\n\n        public async Task<OutboundCampaignJob?> GetActiveJobForCampaignAsync(Guid businessId, Guid campaignId)\n        {\n            return await _db.OutboundCampaignJobs\n                .Where(j => j.BusinessId == businessId && j.CampaignId == campaignId &&\n                            (j.Status == \"queued\" || j.Status == \"running\"))\n                .OrderBy(j => j.CreatedAt)\n                .FirstOrDefaultAsync();\n        }\n\n        public async Task<bool> CancelAsync(Guid businessId, Guid jobId)\n        {\n            var j = await _db.OutboundCampaignJobs.FirstOrDefaultAsync(x => x.Id == jobId && x.BusinessId == businessId);\n            if (j == null) return false;\n\n            if (j.Status == \"queued\" || j.Status == \"running\")\n            {\n                j.Status = \"canceled\";\n                j.UpdatedAt = DateTime.UtcNow;\n                await _db.SaveChangesAsync();\n\n                var campaign = await _db.Campaigns.FirstOrDefaultAsync(c => c.Id == j.CampaignId && c.BusinessId == businessId);\n                if (campaign != null)\n                {\n                    var hasActive = await _db.OutboundCampaignJobs.AnyAsync(x =>\n                        x.CampaignId == j.CampaignId &&\n                        x.BusinessId == businessId &&\n                        (x.Status == \"queued\" || x.Status == \"running\"));\n\n                    if (!hasActive && (campaign.Status == \"Queued\" || campaign.Status == \"Sending\"))\n                    {\n                        campaign.Status = \"Draft\";\n                        campaign.UpdatedAt = DateTime.UtcNow;\n                        await _db.SaveChangesAsync();\n                    }\n                }\n                return true;\n            }\n            return false;\n        }\n\n        public async Task<bool> ForceRetryNowAsync(Guid businessId, Guid jobId)\n        {\n            var j = await _db.OutboundCampaignJobs.FirstOrDefaultAsync(x => x.Id == jobId && x.BusinessId == businessId);\n            if (j == null) return false;\n\n            j.Status = \"queued\";\n            j.NextAttemptAt = DateTimeOffset.UtcNow;\n            j.UpdatedAt = DateTime.UtcNow;\n\n            var campaign = await _db.Campaigns.FirstOrDefaultAsync(c => c.Id == j.CampaignId && c.BusinessId == businessId);\n            if (campaign != null && campaign.Status != \"Queued\")\n            {\n                campaign.Status = \"Queued\";\n                campaign.UpdatedAt = DateTime.UtcNow;\n            }\n\n            await _db.SaveChangesAsync();\n            return true;\n        }\n\n        // NEW: bulk enqueue used by CampaignDispatcher\n        public Task<int> EnqueueBulkAsync(IEnumerable<OutboundCampaignJobCreateDto> jobs, CancellationToken ct = default)\n        {\n            // For now, just log & return a deduped count. Replace with real queue later.\n            var list = (jobs ?? Enumerable.Empty<OutboundCampaignJobCreateDto>()).ToList();\n\n            // Deduplicate by provided IdempotencyKey (or fallback to a stable composite)\n            var enqueuedCount = list\n                .GroupBy(j => string.IsNullOrWhiteSpace(j.IdempotencyKey)\n                                ? $\"{j.CampaignId}:{j.CampaignRecipientId}\"\n                                : j.IdempotencyKey)\n                .Count();\n\n            _log.LogInformation(\"Bulk enqueue requested: {Requested} jobs, deduped to {Enqueued}\",\n                list.Count, enqueuedCount);\n\n            // TODO: push to a real queue/bus and persist queue records as needed.\n            return Task.FromResult(enqueuedCount);\n        }\n\n        private static string Truncate(string s, int max) =>\n            string.IsNullOrEmpty(s) ? s : (s.Length <= max ? s : s.Substring(0, max));\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/OutboundCampaignSendWorker.cs",
      "sha256": "87b84f4ac6b994c6b307f46968b63be7090fa022a3681ae696e01ae348432261",
      "language": "csharp",
      "size": 13092,
      "content": "using System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api;\nusing xbytechat.api.Features.CampaignModule.Services;\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    /// <summary>\n    /// Claims due OutboundCampaignJobs and invokes the campaign sender.\n    /// Uses ExecuteUpdateAsync to flip Campaign.Status without tracking entities,\n    /// eliminating \"already being tracked\" conflicts.\n    /// </summary>\n    public class OutboundCampaignSendWorker : BackgroundService\n    {\n        private readonly IServiceProvider _sp;\n        private readonly ILogger<OutboundCampaignSendWorker> _log;\n\n        // Global cap & polling cadence\n        private const int MaxParallel = 3;\n        private static readonly TimeSpan SweepEvery = TimeSpan.FromSeconds(10);\n\n        public OutboundCampaignSendWorker(IServiceProvider sp, ILogger<OutboundCampaignSendWorker> log)\n        {\n            _sp = sp;\n            _log = log;\n        }\n\n        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n        {\n            // small warm-up delay\n            await Task.Delay(TimeSpan.FromSeconds(5), stoppingToken);\n\n            while (!stoppingToken.IsCancellationRequested)\n            {\n                try\n                {\n                    using var scope = _sp.CreateScope();\n                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n\n                    var now = DateTime.UtcNow;\n\n                    // Find up to MaxParallel due jobs\n                    var due = await db.OutboundCampaignJobs\n                        .Where(j => j.Status == \"queued\" && j.NextAttemptAt <= now)\n                        .OrderBy(j => j.NextAttemptAt)\n                        .ThenBy(j => j.CreatedAt)\n                        .Take(MaxParallel)\n                        .ToListAsync(stoppingToken);\n\n                    // Claim jobs (do NOT increment Attempt here)\n                    foreach (var job in due)\n                    {\n                        job.Status = \"running\";\n                        job.UpdatedAt = DateTime.UtcNow;\n                    }\n\n                    if (due.Count > 0)\n                        await db.SaveChangesAsync(stoppingToken);\n\n                    // Process in parallel within this sweep\n                    var tasks = due.Select(job => ProcessJobAsync(job.Id, stoppingToken)).ToArray();\n                    await Task.WhenAll(tasks);\n                }\n                catch (Exception ex)\n                {\n                    _log.LogWarning(ex, \"Send queue sweep failed\");\n                }\n\n                await Task.Delay(SweepEvery, stoppingToken);\n            }\n        }\n\n        private async Task ProcessJobAsync(Guid jobId, CancellationToken ct)\n        {\n            using var scope = _sp.CreateScope();\n            var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n            var queue = scope.ServiceProvider.GetRequiredService<IOutboundCampaignQueueService>();\n            var campaignService = scope.ServiceProvider.GetRequiredService<ICampaignService>();\n            var log = scope.ServiceProvider.GetRequiredService<ILogger<OutboundCampaignSendWorker>>();\n\n            var job = await db.OutboundCampaignJobs.FirstOrDefaultAsync(j => j.Id == jobId, ct);\n            if (job == null) return;\n\n            // Flip to \"Sending\" (no entity tracked)\n            await db.Campaigns\n                .Where(c => c.Id == job.CampaignId && c.BusinessId == job.BusinessId && c.Status != \"Sending\")\n                .ExecuteUpdateAsync(s => s\n                    .SetProperty(c => c.Status, _ => \"Sending\")\n                    .SetProperty(c => c.UpdatedAt, _ => DateTime.UtcNow),\n                    ct);\n\n            try\n            {\n                // Call by ID only – service manages its own DbContext/queries\n                var result = await campaignService.SendTemplateCampaignWithTypeDetectionAsync(job.CampaignId);\n\n                if (result.Success)\n                {\n                    await db.Campaigns\n                        .Where(c => c.Id == job.CampaignId && c.BusinessId == job.BusinessId)\n                        .ExecuteUpdateAsync(s => s\n                            .SetProperty(c => c.Status, _ => \"Sent\")\n                            .SetProperty(c => c.UpdatedAt, _ => DateTime.UtcNow),\n                            ct);\n\n                    await queue.MarkSucceededAsync(job.Id);\n                    log.LogInformation(\"Job {Job} succeeded for campaign {Campaign}\", jobId, job.CampaignId);\n                }\n                else\n                {\n                    var willRetry = job.Attempt + 1 < job.MaxAttempts;\n                    var nextStatus = willRetry ? \"Queued\" : \"Failed\";\n\n                    await db.Campaigns\n                        .Where(c => c.Id == job.CampaignId && c.BusinessId == job.BusinessId)\n                        .ExecuteUpdateAsync(s => s\n                            .SetProperty(c => c.Status, _ => nextStatus)\n                            .SetProperty(c => c.UpdatedAt, _ => DateTime.UtcNow),\n                            ct);\n\n                    await queue.MarkFailedAsync(job.Id, result.Message ?? \"Unknown send error\", scheduleRetry: true);\n                    log.LogWarning(\"Job {Job} failed for campaign {Campaign}: {Msg}\", jobId, job.CampaignId, result.Message);\n                }\n            }\n            catch (Exception ex)\n            {\n                var willRetry = job.Attempt + 1 < job.MaxAttempts;\n                var nextStatus = willRetry ? \"Queued\" : \"Failed\";\n\n                await db.Campaigns\n                    .Where(c => c.Id == job.CampaignId && c.BusinessId == job.BusinessId)\n                    .ExecuteUpdateAsync(s => s\n                        .SetProperty(c => c.Status, _ => nextStatus)\n                        .SetProperty(c => c.UpdatedAt, _ => DateTime.UtcNow),\n                        ct);\n\n                await queue.MarkFailedAsync(job.Id, ex.ToString(), scheduleRetry: true);\n                log.LogWarning(ex, \"Job {Job} exception for campaign {Campaign}\", jobId, job.CampaignId);\n            }\n        }\n    }\n}\n\n\n//////using System;\n//////using System.Linq;\n//////using System.Threading;\n//////using System.Threading.Tasks;\n//////using Microsoft.EntityFrameworkCore;\n//////using Microsoft.Extensions.DependencyInjection;\n//////using Microsoft.Extensions.Hosting;\n//////using Microsoft.Extensions.Logging;\n//////using xbytechat.api;\n//////using xbytechat.api.Features.CampaignModule.Services;\n\n//////namespace xbytechat.api.Features.CampaignModule.Services\n//////{\n//////    /// <summary>\n//////    /// Background worker that claims due jobs and invokes CampaignService to send.\n//////    /// Flips Campaign.Status for truthful UI: Queued -> Sending -> Sent / Queued / Failed\n//////    /// </summary>\n//////    public class OutboundCampaignSendWorker : BackgroundService\n//////    {\n//////        private readonly IServiceProvider _sp;\n//////        private readonly ILogger<OutboundCampaignSendWorker> _log;\n\n//////        // Simple global concurrency cap & polling cadence\n//////        private const int MaxParallel = 3;\n//////        private static readonly TimeSpan SweepEvery = TimeSpan.FromSeconds(10);\n//////        private readonly IDbContextFactory<AppDbContext> _dbFactory;\n\n//////        public OutboundCampaignSendWorker(IServiceProvider sp, ILogger<OutboundCampaignSendWorker> log, IDbContextFactory<AppDbContext> dbFactory)\n//////        {\n//////            _sp = sp; _log = log;\n//////            _dbFactory = dbFactory;\n//////        }\n\n//////        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n//////        {\n//////            await Task.Delay(TimeSpan.FromSeconds(5), stoppingToken);\n\n//////            while (!stoppingToken.IsCancellationRequested)\n//////            {\n//////                try\n//////                {\n//////                    using var scope = _sp.CreateScope();\n//////                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n\n//////                    var now = DateTimeOffset.UtcNow;\n\n//////                    // Find up to MaxParallel due jobs\n//////                    var due = await db.OutboundCampaignJobs\n//////                        .Where(j => j.Status == \"queued\" && j.NextAttemptAt <= now)\n//////                        .OrderBy(j => j.NextAttemptAt)\n//////                        .ThenBy(j => j.CreatedAt)\n//////                        .Take(MaxParallel)\n//////                        .ToListAsync(stoppingToken);\n\n//////                    // Claim jobs (do NOT increment Attempt here)\n//////                    foreach (var job in due)\n//////                    {\n//////                        job.Status = \"running\";\n//////                        job.UpdatedAt = DateTime.UtcNow;\n//////                    }\n//////                    if (due.Count > 0)\n//////                        await db.SaveChangesAsync(stoppingToken);\n\n//////                    var tasks = due.Select(job => ProcessJobAsync(job.Id, stoppingToken)).ToArray();\n//////                    await Task.WhenAll(tasks);\n//////                }\n//////                catch (Exception ex)\n//////                {\n//////                    _log.LogWarning(ex, \"Send queue sweep failed\");\n//////                }\n\n//////                await Task.Delay(SweepEvery, stoppingToken);\n//////            }\n//////        }\n\n//////        private async Task ProcessJobAsync(Guid jobId, CancellationToken ct)\n//////        {\n//////            using var scope = _sp.CreateScope();\n//////            var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n//////            var queue = scope.ServiceProvider.GetRequiredService<IOutboundCampaignQueueService>();\n//////            var campaignService = scope.ServiceProvider.GetRequiredService<ICampaignService>();\n//////            var log = scope.ServiceProvider.GetRequiredService<ILogger<OutboundCampaignSendWorker>>();\n\n//////            var job = await db.OutboundCampaignJobs.FirstOrDefaultAsync(j => j.Id == jobId, ct);\n//////            if (job == null) return;\n\n//////            // Mark Campaign -> Sending\n//////            var campaign = await db.Campaigns\n//////                .FirstOrDefaultAsync(c => c.Id == job.CampaignId && c.BusinessId == job.BusinessId, ct);\n\n//////            if (campaign != null && campaign.Status != \"Sending\")\n//////            {\n//////                campaign.Status = \"Sending\";\n//////                campaign.UpdatedAt = DateTime.UtcNow;\n//////                await db.SaveChangesAsync(ct);\n//////            }\n\n//////            try\n//////            {\n//////                var result = await campaignService.SendTemplateCampaignWithTypeDetectionAsync(job.CampaignId);\n\n//////                if (result.Success)\n//////                {\n//////                    if (campaign != null)\n//////                    {\n//////                        campaign.Status = \"Sent\";\n//////                        campaign.UpdatedAt = DateTime.UtcNow;\n//////                        await db.SaveChangesAsync(ct);\n//////                    }\n\n//////                    await queue.MarkSucceededAsync(job.Id);\n//////                    log.LogInformation(\"Job {Job} succeeded for campaign {Campaign}\", jobId, job.CampaignId);\n//////                }\n//////                else\n//////                {\n//////                    // Compute whether we will retry BEFORE calling MarkFailed (Attempt not yet incremented)\n//////                    var willRetry = job.Attempt + 1 < job.MaxAttempts;\n\n//////                    if (campaign != null)\n//////                    {\n//////                        campaign.Status = willRetry ? \"Queued\" : \"Failed\";\n//////                        campaign.UpdatedAt = DateTime.UtcNow;\n//////                        await db.SaveChangesAsync(ct);\n//////                    }\n\n//////                    await queue.MarkFailedAsync(job.Id, result.Message ?? \"Unknown send error\", scheduleRetry: true);\n//////                    log.LogWarning(\"Job {Job} failed for campaign {Campaign}: {Msg}\", jobId, job.CampaignId, result.Message);\n//////                }\n//////            }\n//////            catch (Exception ex)\n//////            {\n//////                var willRetry = job.Attempt + 1 < job.MaxAttempts;\n\n//////                if (campaign != null)\n//////                {\n//////                    campaign.Status = willRetry ? \"Queued\" : \"Failed\";\n//////                    campaign.UpdatedAt = DateTime.UtcNow;\n//////                    await db.SaveChangesAsync(ct);\n//////                }\n\n//////                await queue.MarkFailedAsync(job.Id, ex.ToString(), scheduleRetry: true);\n//////                log.LogWarning(ex, \"Job {Job} exception for campaign {Campaign}\", jobId, job.CampaignId);\n//////            }\n//////        }\n//////    }\n//////}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Workers/OutboundSenderWorker.cs",
      "sha256": "331cf2348d4034bdd995f63bc3a02151a27a3e4853a280a60994e8c68913ab50",
      "language": "csharp",
      "size": 32501,
      "content": "// 📄 File: Features/CampaignModule/Workers/OutboundSenderWorker.cs\nusing System;\nusing System.Collections.Concurrent;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Text.Json;\nusing System.Text.RegularExpressions;\nusing System.Threading;\nusing System.Threading.Channels;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Logging;\nusing Npgsql;\n\nusing xbytechat.api;\nusing xbytechat.api.Features.CampaignModule.Models;\nusing xbytechat.api.Features.CampaignTracking.Logging;\nusing xbytechat.api.Features.CampaignTracking.Models;\nusing xbytechat.api.Features.MessageLogging.Services;\nusing xbytechat.api.Features.MessagesEngine.Abstractions;\nusing xbytechat.api.Features.CampaignModule.SendEngine;\nusing xbytechat_api.Features.Billing.Services;\nusing xbytechat.api.Infrastructure.Observability;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.WhatsAppSettings.Helpers;\nusing xbytechat.api.AuthModule.Models;\n\nnamespace xbytechat.api.Features.CampaignModule.Workers\n{\n    public class OutboundSenderWorker : BackgroundService\n    {\n        private readonly IServiceProvider _sp;\n        private readonly ILogger<OutboundSenderWorker> _log;\n        private readonly Channel<OutboundMessageJob> _channel;\n        private const int DEFAULT_MAX_ATTEMPTS = 3;\n\n        // Concurrency caps\n        private readonly int _globalDop = 32;   // total parallel consumers\n        private readonly int _perNumberDop = 8; // per (provider, PhoneNumberId)\n\n        private readonly TimeSpan _pollInterval = TimeSpan.FromSeconds(1);\n        private static readonly TimeSpan _flightTimeout = TimeSpan.FromMinutes(5);\n\n        private int _inChannel;\n        private readonly Random _rand = new();\n\n        // =========================[ Template Button Cache + Parsers ]=========================\n        private static readonly ConcurrentDictionary<string, IReadOnlyList<ButtonMeta>> _btnCache =\n            new(StringComparer.Ordinal);\n\n        private static readonly Regex RxButtonTypeMeta = new(@\"^\\s*url\\s*$\", RegexOptions.IgnoreCase | RegexOptions.Compiled);\n        private static readonly Regex RxButtonTypePinn = new(@\"^\\s*url\\s*$\", RegexOptions.IgnoreCase | RegexOptions.Compiled);\n\n        private static string CacheKeyForTemplate(WhatsAppTemplate tpl)\n            => $\"{tpl.BusinessId}|{tpl.Provider}|{tpl.Name}|{tpl.LanguageCode}\".ToUpperInvariant();\n\n        private static IReadOnlyList<ButtonMeta> GetTemplateButtonsCached(WhatsAppTemplate tpl)\n            => _btnCache.GetOrAdd(CacheKeyForTemplate(tpl), _ => ParseButtonsFromTemplateRow(tpl));\n\n        private static IReadOnlyList<ButtonMeta> ParseButtonsFromTemplateRow(WhatsAppTemplate tpl)\n        {\n            if (!string.IsNullOrWhiteSpace(tpl.UrlButtons))\n            {\n                try\n                {\n                    using var doc = JsonDocument.Parse(tpl.UrlButtons);\n                    if (doc.RootElement.ValueKind == JsonValueKind.Array)\n                    {\n                        var list = new List<ButtonMeta>(capacity: 3);\n                        foreach (var el in doc.RootElement.EnumerateArray())\n                        {\n                            var text = el.TryGetProperty(\"ButtonText\", out var pText) ? pText.GetString() ?? \"\" :\n                                       el.TryGetProperty(\"Text\", out var pText2) ? pText2.GetString() ?? \"\" : \"\";\n                            var type = el.TryGetProperty(\"ButtonType\", out var pType) ? pType.GetString() ?? \"\" :\n                                       el.TryGetProperty(\"Type\", out var pType2) ? pType2.GetString() ?? \"\" : \"\";\n                            var url = el.TryGetProperty(\"TargetUrl\", out var pUrl) ? pUrl.GetString() : null;\n\n                            if (!string.IsNullOrWhiteSpace(text) && !string.IsNullOrWhiteSpace(type))\n                                list.Add(new ButtonMeta(text, type, url));\n                        }\n                        return list;\n                    }\n                }\n                catch { /* fallthrough */ }\n            }\n\n            if (!string.IsNullOrWhiteSpace(tpl.RawJson))\n            {\n                try\n                {\n                    using var doc = JsonDocument.Parse(tpl.RawJson);\n\n                    JsonElement comps = default;\n                    if (doc.RootElement.TryGetProperty(\"template\", out var tplNode) &&\n                        tplNode.TryGetProperty(\"components\", out var comps1))\n                    {\n                        comps = comps1;\n                    }\n                    else if (doc.RootElement.TryGetProperty(\"components\", out var comps2))\n                    {\n                        comps = comps2;\n                    }\n\n                    if (comps.ValueKind == JsonValueKind.Array)\n                    {\n                        var list = new List<ButtonMeta>(capacity: 3);\n\n                        foreach (var c in comps.EnumerateArray())\n                        {\n                            if (!c.TryGetProperty(\"type\", out var tProp)) continue;\n                            if (!string.Equals(tProp.GetString(), \"button\", StringComparison.OrdinalIgnoreCase)) continue;\n\n                            var isUrl =\n                                (c.TryGetProperty(\"sub_type\", out var st) && RxButtonTypeMeta.IsMatch(st.GetString() ?? \"\")) ||\n                                (c.TryGetProperty(\"subType\", out var st2) && RxButtonTypePinn.IsMatch(st2.GetString() ?? \"\"));\n\n                            if (!isUrl) continue;\n\n                            string text = \"Open\";\n                            string type = \"url\";\n                            string? url = null;\n\n                            if (c.TryGetProperty(\"parameters\", out var pars) && pars.ValueKind == JsonValueKind.Array)\n                            {\n                                foreach (var p in pars.EnumerateArray())\n                                {\n                                    if (p.TryGetProperty(\"text\", out var txtProp))\n                                    {\n                                        var v = txtProp.GetString();\n                                        if (!string.IsNullOrWhiteSpace(v)) { url = v; break; }\n                                    }\n                                }\n                            }\n\n                            list.Add(new ButtonMeta(text, type, url));\n                            if (list.Count >= 3) break;\n                        }\n\n                        return list;\n                    }\n                }\n                catch { /* ignore */ }\n            }\n\n            return Array.Empty<ButtonMeta>();\n        }\n        // =====================================================================================\n\n        public OutboundSenderWorker(IServiceProvider sp, ILogger<OutboundSenderWorker> log)\n        {\n            _sp = sp;\n            _log = log;\n\n            _channel = Channel.CreateBounded<OutboundMessageJob>(new BoundedChannelOptions(5000)\n            {\n                SingleReader = false,\n                SingleWriter = false,\n                FullMode = BoundedChannelFullMode.Wait\n            });\n        }\n\n\n\n        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n        {\n            using var cts = CancellationTokenSource.CreateLinkedTokenSource(stoppingToken);\n            var ct = cts.Token;\n\n            var consumers = Enumerable.Range(0, _globalDop)\n                .Select(_ => Task.Run(() => ConsumeAsync(ct), ct))\n                .ToArray();\n\n            var producer = Task.Run(() => ProduceAsync(ct), ct);\n\n            var all = consumers.Append(producer).ToArray();\n\n            try\n            {\n                await Task.WhenAll(all);\n            }\n            catch\n            {\n                try { cts.Cancel(); } catch { /* ignore */ }\n                throw;\n            }\n        }\n\n        private async Task ProduceAsync(CancellationToken ct)\n        {\n            const int ChannelCapacity = 5000;\n\n            var idleDelay = _pollInterval;\n            var maxIdleDelay = TimeSpan.FromSeconds(1);\n            var longIdleDelay = TimeSpan.FromSeconds(30);\n            int consecutiveEmpty = 0;\n\n            const string sql = @\"\nWITH cte AS (\n    SELECT \"\"Id\"\"\n    FROM \"\"OutboundMessageJobs\"\"\n    WHERE \"\"Status\"\" = 'Pending'\n      AND (\"\"NextAttemptAt\"\" IS NULL OR \"\"NextAttemptAt\"\" <= NOW())\n    ORDER BY \"\"NextAttemptAt\"\" NULLS FIRST, \"\"CreatedAt\"\"\n    FOR UPDATE SKIP LOCKED\n    LIMIT @take\n)\nUPDATE \"\"OutboundMessageJobs\"\" j\nSET \"\"Status\"\" = 'InFlight',\n    \"\"NextAttemptAt\"\" = NOW() + make_interval(secs => @flight),\n    \"\"LastError\"\" = NULL\nWHERE j.\"\"Id\"\" IN (SELECT \"\"Id\"\" FROM cte)\nRETURNING j.*;\";\n\n            try { await Task.Delay(_rand.Next(100, 500), ct); } catch { /* ignore */ }\n\n            while (!ct.IsCancellationRequested)\n            {\n                try\n                {\n                    using var scope = _sp.CreateScope();\n                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n\n                    var approxCount = Volatile.Read(ref _inChannel);\n                    var budget = Math.Max(0, ChannelCapacity - approxCount);\n\n                    if (budget <= 0)\n                    {\n                        await Task.Delay(idleDelay, ct);\n                        idleDelay = TimeSpan.FromMilliseconds(\n                            Math.Min(maxIdleDelay.TotalMilliseconds, idleDelay.TotalMilliseconds * 1.25)\n                        );\n                        continue;\n                    }\n\n                    // idleDelay = _pollInterval; // ❌ BAD: This was resetting the backoff every time!\n\n                    var take = Math.Min(budget, 2000);\n                    var flightSecs = (int)Math.Ceiling(_flightTimeout.TotalSeconds);\n\n                    var takeParam = new NpgsqlParameter<int>(\"take\", take);\n                    var flightParam = new NpgsqlParameter<int>(\"flight\", flightSecs);\n\n                    var prevTimeout = db.Database.GetCommandTimeout();\n                    db.Database.SetCommandTimeout(5);\n\n                    List<OutboundMessageJob> jobs;\n                    try\n                    {\n                        jobs = await db.OutboundMessageJobs\n                            .FromSqlRaw(sql, takeParam, flightParam)\n                            .AsNoTracking()\n                            .ToListAsync(ct);\n                    }\n                    finally\n                    {\n                        db.Database.SetCommandTimeout(prevTimeout);\n                    }\n\n                    foreach (var job in jobs)\n                    {\n                        await _channel.Writer.WriteAsync(job, ct);\n                        Interlocked.Increment(ref _inChannel);\n                    }\n\n                    if (jobs.Count == 0)\n                    {\n                        consecutiveEmpty++;\n                        var jitterMs = _rand.Next(0, 200);\n                        var delay = idleDelay + TimeSpan.FromMilliseconds(jitterMs);\n\n                        if (consecutiveEmpty >= 8 && idleDelay >= maxIdleDelay)\n                            delay = longIdleDelay + TimeSpan.FromMilliseconds(jitterMs);\n\n                        await Task.Delay(delay, ct);\n\n                        if (idleDelay < maxIdleDelay)\n                        {\n                            idleDelay = TimeSpan.FromMilliseconds(\n                                Math.Min(maxIdleDelay.TotalMilliseconds, idleDelay.TotalMilliseconds * 2)\n                            );\n                        }\n                    }\n                    else\n                    {\n                        consecutiveEmpty = 0;\n                        idleDelay = _pollInterval; // ✅ Correct: Reset only when we found work\n                    }\n                }\n                catch (TaskCanceledException)\n                {\n                }\n                catch (Exception ex)\n                {\n                    _log.LogError(ex, \"[Outbox] Producer loop error\");\n                    try { await Task.Delay(TimeSpan.FromSeconds(2), ct); } catch { /* ignore */ }\n                }\n            }\n        }\n\n        // ---- keyed concurrency gate (per sender) ---------------------------------------\n        private sealed class KeyedSemaphore\n        {\n            private readonly ConcurrentDictionary<string, SemaphoreSlim> _map = new();\n            public async Task<IDisposable> AcquireAsync(string key, int dop, CancellationToken ct)\n            {\n                var sem = _map.GetOrAdd(key, _ => new SemaphoreSlim(dop));\n                await sem.WaitAsync(ct);\n                return new Releaser(sem);\n            }\n            private sealed class Releaser : IDisposable\n            {\n                private readonly SemaphoreSlim _s;\n                public Releaser(SemaphoreSlim s) => _s = s;\n                public void Dispose() => _s.Release();\n            }\n        }\n        private static readonly KeyedSemaphore _perSenderGate = new();\n        // -------------------------------------------------------------------------------\n\n        // Best-effort extraction of provider message id from a Meta success body\n        private static string? TryExtractProviderMessageId(string? raw)\n        {\n            if (string.IsNullOrWhiteSpace(raw)) return null;\n            try\n            {\n                using var doc = JsonDocument.Parse(raw);\n                if (doc.RootElement.TryGetProperty(\"messages\", out var msgs) &&\n                    msgs.ValueKind == JsonValueKind.Array &&\n                    msgs.GetArrayLength() > 0 &&\n                    msgs[0].TryGetProperty(\"id\", out var idProp))\n                {\n                    return idProp.GetString();\n                }\n            }\n            catch { /* ignore */ }\n            return null;\n        }\n\n        private async Task ConsumeAsync(CancellationToken ct)\n        {\n            static async Task<(string Phone, Guid? ContactId, string? ContactName)> ResolveRecipientAsync(\n     AppDbContext db, Guid recipientId, CancellationToken ct2)\n            {\n                var row = await db.CampaignRecipients\n                    .AsNoTracking()\n                    .Where(r => r.Id == recipientId)\n                    .Select(r => new\n                    {\n                        Phone = r.Contact != null\n                            ? r.Contact.PhoneNumber\n                            : (r.AudienceMember != null ? (r.AudienceMember.PhoneE164 ?? r.AudienceMember.PhoneRaw) : null),\n\n                        ContactId = (Guid?)(r.Contact != null ? r.Contact.Id : null),\n                        ContactName = r.Contact != null ? r.Contact.Name : null\n                    })\n                    .FirstOrDefaultAsync(ct2);\n\n                return (row?.Phone ?? string.Empty, row?.ContactId, row?.ContactName);\n            }\n\n            while (await _channel.Reader.WaitToReadAsync(ct))\n            {\n                if (!_channel.Reader.TryRead(out var job))\n                    continue;\n\n                Interlocked.Decrement(ref _inChannel);\n\n                try\n                {\n                    using var scope = _sp.CreateScope();\n                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n                    var engine = scope.ServiceProvider.GetRequiredService<IMessageEngineService>();\n                    var billing = scope.ServiceProvider.GetRequiredService<IBillingIngestService>();\n                    var logger = scope.ServiceProvider.GetRequiredService<ILogger<OutboundSenderWorker>>();\n                    var logSink = scope.ServiceProvider.GetRequiredService<ICampaignLogSink>();\n                    var limiter = scope.ServiceProvider.GetRequiredService<xbytechat.api.Infrastructure.RateLimiting.IPhoneNumberRateLimiter>();\n                    var messageLogSink = scope.ServiceProvider.GetRequiredService<IMessageLogSink>();\n                    var builder = scope.ServiceProvider.GetRequiredService<ITemplatePayloadBuilder>();\n                    var validator = scope.ServiceProvider.GetRequiredService<ICampaignSendValidator>();\n\n                    var senderKey = $\"{job.Provider}|{job.PhoneNumberId}\";\n\n                    using (await _perSenderGate.AcquireAsync(senderKey, _perNumberDop, ct))\n                    {\n                        var lease = await limiter.AcquireAsync(senderKey, ct);\n                        if (!lease.IsAcquired)\n                        {\n                            await Task.Delay(50, ct);\n                            continue;\n                        }\n\n                        var (recipientPhone, contactId, contactName) = await ResolveRecipientAsync(db, job.RecipientId, ct);\n\n                        if (string.IsNullOrWhiteSpace(recipientPhone))\n                        {\n                            job.Status = \"Failed\";\n                            job.Attempt += 1;\n                            job.LastError = \"Recipient phone not found.\";\n                            var backoff1 = (int)Math.Min(60, Math.Pow(2, job.Attempt) * 2);\n                            job.NextAttemptAt = DateTime.UtcNow.AddSeconds(backoff1);\n                            db.Update(job);\n                            await db.SaveChangesAsync(ct);\n\n                            logger.LogWarning(\"[Outbox] Recipient phone not found. job={JobId} recipient={RecipientId}\", job.Id, job.RecipientId);\n                            MetricsRegistry.MessagesFailed.Add(1);\n                            continue;\n                        }\n\n                        var lang = job.LanguageCode ?? \"en_US\";\n                        var tmplRow = await db.WhatsAppTemplates\n                            .AsNoTracking()\n                            .FirstOrDefaultAsync(t =>\n                                t.BusinessId == job.BusinessId &&\n                                t.Provider == job.Provider &&\n                                t.Name == job.TemplateName &&\n                                t.LanguageCode == lang,\n                                ct);\n\n                        if (tmplRow == null)\n                        {\n                            job.Status = \"Failed\";\n                            job.Attempt += 1;\n                            job.LastError = $\"Template not found: {job.TemplateName} ({lang}) for {job.Provider}.\";\n                            var backoff = (int)Math.Min(60, Math.Pow(2, job.Attempt) * 2);\n                            job.NextAttemptAt = DateTime.UtcNow.AddSeconds(backoff);\n                            db.Update(job);\n                            await db.SaveChangesAsync(ct);\n\n                            logger.LogWarning(\"[Outbox] Template not found. job={JobId} template={Template} lang={Lang} provider={Provider}\",\n                                job.Id, job.TemplateName, lang, job.Provider);\n                            MetricsRegistry.MessagesFailed.Add(1);\n                            continue;\n                        }\n\n                        HeaderKind headerKind = tmplRow.HeaderKind?.ToLowerInvariant() switch\n                        {\n                            \"text\" => HeaderKind.Text,\n                            \"image\" => HeaderKind.Image,\n                            \"video\" => HeaderKind.Video,\n                            \"document\" => HeaderKind.Document,\n                            \"none\" or null => HeaderKind.None,\n                            _ => HeaderKind.None\n                        };\n                        if (headerKind == HeaderKind.None && !string.IsNullOrWhiteSpace(job.MediaType))\n                        {\n                            headerKind = job.MediaType.ToLowerInvariant() switch\n                            {\n                                \"text\" => HeaderKind.Text,\n                                \"image\" => HeaderKind.Image,\n                                \"video\" => HeaderKind.Video,\n                                \"document\" => HeaderKind.Document,\n                                _ => HeaderKind.None\n                            };\n                        }\n\n                        var providerEnum = ProviderUtil.Parse(job.Provider);\n                        var buttonsFromTemplate = GetTemplateButtonsCached(tmplRow);\n\n                        var plan = new SendPlan(\n                            BusinessId: job.BusinessId,\n                            Provider: providerEnum,\n                            PhoneNumberId: job.PhoneNumberId!,\n                            TemplateName: job.TemplateName!,\n                            LanguageCode: lang,\n                            HeaderKind: headerKind,\n                            HeaderUrl: job.HeaderMediaUrl,\n                            Buttons: buttonsFromTemplate\n                        );\n\n                        var recipient = new RecipientPlan(\n                            RecipientId: job.RecipientId,\n                            ToPhoneE164: recipientPhone,\n                            ParametersJson: job.ResolvedParamsJson ?? \"[]\",\n                            ButtonParamsJson: job.ResolvedButtonUrlsJson,\n                            IdempotencyKey: job.IdempotencyKey ?? $\"{job.CampaignId}:{recipientPhone}:{job.TemplateName}\"\n                        );\n\n                        var envelope = builder.Build(plan, recipient);\n\n                        var (ok, error) = validator.Validate(plan, recipient, envelope, tmplRow);\n                        if (!ok)\n                        {\n                            job.Status = \"Failed\";\n                            job.Attempt += 1;\n                            job.LastError = error ?? \"Validation failed.\";\n                            var backoff = (int)Math.Min(60, Math.Pow(2, job.Attempt) * 2);\n                            job.NextAttemptAt = DateTime.UtcNow.AddSeconds(backoff);\n                            db.Update(job);\n                            await db.SaveChangesAsync(ct);\n\n                            logger.LogWarning(\"[Outbox] Validation failed job={JobId} error={Error}\", job.Id, job.LastError);\n                            MetricsRegistry.MessagesFailed.Add(1);\n                            continue;\n                        }\n\n                        object payload = providerEnum switch\n                        {\n                            Provider.MetaCloud =>\n                                scope.ServiceProvider.GetRequiredService<MetaCloudPayloadMapper>()\n                                    .BuildPayload(plan, recipient, envelope),\n\n                            Provider.Pinnacle =>\n                                scope.ServiceProvider.GetRequiredService<PinnaclePayloadMapper>()\n                                    .BuildPayload(plan, recipient, envelope),\n\n                            _ => throw new InvalidOperationException(\"Unknown provider\")\n                        };\n\n                        var sw = Stopwatch.StartNew();\n                        var engineResult = await engine.SendPayloadAsync(job.BusinessId, job.Provider, payload, job.PhoneNumberId);\n                        sw.Stop();\n                        MetricsRegistry.SendLatencyMs.Record(sw.Elapsed.TotalMilliseconds);\n\n                        if (!engineResult.Success)\n                        {\n                            var err = engineResult.ErrorMessage ?? string.Empty;\n                            if (err.Contains(\"429\", StringComparison.Ordinal) ||\n                                err.Contains(\"Too Many Requests\", StringComparison.OrdinalIgnoreCase))\n                            {\n                                limiter.UpdateLimits(senderKey, permitsPerSecond: 5, burst: 5);\n                                MetricsRegistry.RateLimited429s.Add(1);\n                            }\n                        }\n\n                        // ✅ Surface provider ID and raw body for visibility\n                        var providerMsgId = !string.IsNullOrWhiteSpace(engineResult.MessageId)\n                            ? engineResult.MessageId\n                            : TryExtractProviderMessageId(engineResult.RawResponse);\n\n                        if (engineResult.Success)\n                        {\n                            logger.LogInformation(\"Provider send OK | providerMessageId={ProviderId} job={JobId} to={To}\",\n                                providerMsgId, job.Id, recipientPhone);\n                        }\n                        else\n                        {\n                            logger.LogWarning(\"Provider send FAILED | job={JobId} to={To} error={Error} body={Body}\",\n                                job.Id, recipientPhone, engineResult.ErrorMessage, engineResult.RawResponse);\n                        }\n\n                        // Persist MessageLogs (COPY sink)\n                        var now = DateTime.UtcNow;\n                        var runId = Guid.NewGuid();\n                        var logId = Guid.NewGuid();\n\n                        logger.LogInformation(\n                            \"[OutboundSenderWorker] Enqueue MessageLog id={LogId} recipient={RecipientId} job={JobId}\",\n                            logId, job.RecipientId, job.Id);\n\n                        messageLogSink.Enqueue(new MessageLog\n                        {\n                            Id = logId,\n                            BusinessId = job.BusinessId,\n                            CampaignId = job.CampaignId,\n                            ContactId = contactId,                 // ✅ ADD\n                            RecipientNumber = recipientPhone,\n                            MessageContent = job.TemplateName,\n                            MediaUrl = job.HeaderMediaUrl,\n                            Status = engineResult.Success ? \"Sent\" : \"Failed\",\n                            MessageId = providerMsgId,\n                            ErrorMessage = engineResult.ErrorMessage,\n                            RawResponse = engineResult.RawResponse,\n                            CreatedAt = now,\n                            SentAt = engineResult.Success ? now : (DateTime?)null,\n                            Source = \"campaign\",\n                            RunId = runId,\n                            Provider = job.Provider,\n                            ProviderMessageId = providerMsgId,\n                            IsIncoming = false,\n                            IsChargeable = false\n                        });\n\n                        // Batched CampaignSendLog (COPY via sink)\n                        logSink.Enqueue(new CampaignLogRecord(\n                            Id: Guid.NewGuid(),\n                            RunId: runId,\n                            MessageId: providerMsgId,\n                            CampaignId: job.CampaignId,\n                           \n                            ContactId: contactId,\n                            RecipientId: job.RecipientId,\n                            MessageBody: job.MessageBody ?? job.TemplateName,\n                            TemplateId: job.TemplateName,\n                            SendStatus: engineResult.Success ? \"Sent\" : \"Failed\",\n                            ErrorMessage: engineResult.ErrorMessage,\n                            CreatedAt: now,\n                            CreatedBy: \"system\",\n                            SentAt: engineResult.Success ? now : (DateTime?)null,\n                            DeliveredAt: null,\n                            ReadAt: null,\n                            IpAddress: null,\n                            DeviceInfo: null,\n                            MacAddress: null,\n                            SourceChannel: \"campaign\",\n                            DeviceType: null,\n                            Browser: null,\n                            Country: null,\n                            City: null,\n                            IsClicked: false,\n                            ClickedAt: null,\n                            ClickType: null,\n                            RetryCount: job.Attempt,\n                            LastRetryAt: now,\n                            LastRetryStatus: engineResult.Success ? \"Success\" : \"Failed\",\n                            AllowRetry: job.Attempt < DEFAULT_MAX_ATTEMPTS,\n                            MessageLogId: logId,\n                            BusinessId: job.BusinessId,\n                            CTAFlowConfigId: null,\n                            CTAFlowStepId: null,\n                            ButtonBundleJson: null\n                        ));\n                        logger.LogDebug(\"[Outbox] Resolved recipient. recipientId={RecipientId} phone={Phone} contactId={ContactId} name={Name}\",\n                      job.RecipientId, recipientPhone, contactId, contactName);\n\n                        // Update job (retry/backoff if needed)\n                        job.Status = engineResult.Success ? \"Sent\" : \"Failed\";\n                        job.Attempt += 1;\n                        job.LastError = engineResult.ErrorMessage;\n\n                        if (!engineResult.Success)\n                        {\n                            var backoffSecs = (int)Math.Min(60, Math.Pow(2, job.Attempt) * 2);\n                            job.NextAttemptAt = DateTime.UtcNow.AddSeconds(backoffSecs);\n                            MetricsRegistry.MessagesFailed.Add(1);\n                        }\n                        else\n                        {\n                            job.NextAttemptAt = null;\n                            MetricsRegistry.MessagesSent.Add(1);\n                        }\n\n                        db.Update(job);\n                        await db.SaveChangesAsync(ct);\n\n                        // 🔍 Check if all messages for this campaign are done\n                        try \n                        {\n                            var hasPending = await db.OutboundMessageJobs\n                                .AnyAsync(j => j.CampaignId == job.CampaignId \n                                            && j.Status != \"Sent\" \n                                            && j.Status != \"Failed\", ct);\n\n                            if (!hasPending)\n                            {\n                                 var cmp = await db.Campaigns.FindAsync(new object[] { job.CampaignId }, ct);\n                                 if (cmp != null && cmp.Status != \"Sent\" && cmp.Status != \"Completed\")\n                                 {\n                                     cmp.Status = \"Sent\"; \n                                     cmp.UpdatedAt = DateTime.UtcNow;\n                                     db.Update(cmp);\n                                     await db.SaveChangesAsync(ct);\n                                     logger.LogInformation(\"✅ Campaign {CampaignId} marked as SENT (all jobs done).\", job.CampaignId);\n                                 }\n                            }\n                        }\n                        catch (Exception ex)\n                        {\n                            logger.LogError(ex, \"⚠️ Campaign status update failed for {CampaignId}\", job.CampaignId);\n                        }\n\n                        await billing.IngestFromSendResponseAsync(\n                            job.BusinessId,\n                            logId,\n                            job.Provider,\n                            engineResult.RawResponse ?? \"{}\"\n                        );\n                    }\n                }\n                catch (TaskCanceledException)\n                {\n                }\n                catch (Exception ex)\n                {\n                    try\n                    {\n                        using var scope = _sp.CreateScope();\n                        var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n                        job.Status = \"Failed\";\n                        job.Attempt += 1;\n                        job.LastError = ex.Message;\n                        var backoffSecs = (int)Math.Min(60, Math.Pow(2, job.Attempt) * 2);\n                        job.NextAttemptAt = DateTime.UtcNow.AddSeconds(backoffSecs);\n                        db.Update(job);\n                        await db.SaveChangesAsync(ct);\n                    }\n                    catch { /* swallow */ }\n\n                    MetricsRegistry.MessagesFailed.Add(1);\n                    _log.LogError(ex, \"[Outbox] Consume error job={JobId}\", job.Id);\n                }\n            }\n        }\n    }\n}\n\n\n\n\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Workers/OutboxReaperWorker.cs",
      "sha256": "62e23d9733ccd68ae2166ca2bc11a9b2024183cf0b91163984e6d7e40e7d2f15",
      "language": "csharp",
      "size": 3194,
      "content": "using Microsoft.EntityFrameworkCore;\n\nnamespace xbytechat.api.Features.CampaignModule.Workers\n{\n    public sealed class OutboxReaperWorker : BackgroundService\n    {\n        private readonly IServiceProvider _sp;\n        private readonly ILogger<OutboxReaperWorker> _log;\n\n        // How often we sweep\n        private static readonly TimeSpan SweepEvery = TimeSpan.FromSeconds(30);\n\n        // Keep in sync with your sender logic / DEFAULT_MAX_ATTEMPTS\n        private const int MAX_ATTEMPTS = 3;\n\n        public OutboxReaperWorker(IServiceProvider sp, ILogger<OutboxReaperWorker> log)\n        {\n            _sp = sp;\n            _log = log;\n        }\n\n        // OutboxReaperWorker.cs\n        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n        {\n            while (!stoppingToken.IsCancellationRequested)\n            {\n                try\n                {\n                    using var scope = _sp.CreateScope();\n                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n                    var now = DateTime.UtcNow;\n\n                    // ---- Recover stale InFlight jobs (no Random in the expression) ----\n                    var jitterSeconds = 2 + (int)((ulong)DateTime.UtcNow.Ticks % 3); // 2..4s\n                    var backoffAt = now.AddSeconds(jitterSeconds);\n\n                    var recovered = await db.OutboundMessageJobs\n                        .Where(j => j.Status == \"InFlight\" &&\n                                    j.NextAttemptAt != null &&\n                                    j.NextAttemptAt < now)\n                        .ExecuteUpdateAsync(s => s\n                            .SetProperty(j => j.Status, _ => \"Pending\")\n                            .SetProperty(j => j.NextAttemptAt, _ => backoffAt)\n                            .SetProperty(j => j.LastError, _ => \"Recovered from stale in-flight\"),\n                            stoppingToken);\n\n                    // ---- Kill over-retried jobs ----\n                    const int MAX_ATTEMPTS = 3;\n                    var killed = await db.OutboundMessageJobs\n                        .Where(j => (j.Status == \"Pending\" || j.Status == \"Failed\" || j.Status == \"InFlight\") &&\n                                    j.Attempt >= MAX_ATTEMPTS)\n                        .ExecuteUpdateAsync(s => s\n                            .SetProperty(j => j.Status, _ => \"Dead\")\n                            .SetProperty(j => j.NextAttemptAt, _ => (DateTime?)null)\n                            .SetProperty(j => j.LastError, _ => \"Max attempts exceeded\"),\n                            stoppingToken);\n\n                    if (recovered > 0 || killed > 0)\n                        _log.LogInformation(\"[OutboxReaper] recovered={Recovered} killed={Killed}\", recovered, killed);\n                }\n                catch (TaskCanceledException) { /* shutdown */ }\n                catch (Exception ex)\n                {\n                    _log.LogError(ex, \"[OutboxReaper] sweep failed\");\n                }\n\n                try { await Task.Delay(TimeSpan.FromSeconds(30), stoppingToken); }\n                catch (TaskCanceledException) { /* shutdown */ }\n            }\n        }\n\n    }\n}\n"
    }
  ]
}
