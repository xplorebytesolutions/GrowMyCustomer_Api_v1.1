Folder and File Content Report
Root folder: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks
Generated at: 07-12-2025 15:15:17.67
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\MakeDump.bat 
====================================================== 
 
@echo off
REM This script will find relevant source files and output their names and contents into one file.
REM The output file will be named [FolderName]_AllFileDump.txt.

REM Get the current folder's name and set it as the output file name with the custom suffix
for %%I in ("%cd%") do set "outputFile=%%~nI_AllFileDump.txt"

REM Clear the output file to start fresh and write a small header
> "%outputFile%" (
    echo Folder and File Content Report
    echo Root folder: %cd%
    echo Generated at: %date% %time%
)
echo. >> "%outputFile%"

REM NOTE:
REM We now only dump RELEVANT text/code files (no binaries, no images, no node_modules, etc.)
REM This keeps the file smaller and much easier to review.

REM Loop through all relevant files in the current directory and subdirectories
REM Extensions included: C#, JS/TS/React, JSON, config, SQL, Markdown, YAML
for /R . %%F in (*.cs *.csproj *.jsx *.tsx *.js *.ts *.json *.config *.sql *.md *.yml *.yaml *.bat) do (

    REM Skip some noisy folders by path substring (node_modules, bin, obj, .git, dist, .vs)
    echo "%%F" | findstr /I /C:"\node_modules\" /C:"\bin\" /C:"\obj\" /C:"\.git\" /C:"\dist\" /C:"\.vs\" >nul
    if errorlevel 1 (
        echo ====================================================== >> "%outputFile%"
        echo FILE: %%F >> "%outputFile%"
        echo ====================================================== >> "%outputFile%"
        echo. >> "%outputFile%"
        type "%%F" >> "%outputFile%" 2>nul
        echo. >> "%outputFile%"
        echo. >> "%outputFile%"
    )
)

echo Finished! All content has been extracted to %outputFile%
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\BackgroundWorkers\WebhookAutoCleanupWorker.cs 
====================================================== 
 
Ôªøusing xbytechat.api.Features.Webhooks.Services;

namespace xbytechat.api.Features.Webhooks.BackgroundWorkers
{
    public class WebhookAutoCleanupWorker : BackgroundService
    {
        private readonly ILogger<WebhookAutoCleanupWorker> _logger;
        private readonly IServiceProvider _services;

        public WebhookAutoCleanupWorker(IServiceProvider services, ILogger<WebhookAutoCleanupWorker> logger)
        {
            _services = services;
            _logger = logger;
        }

        protected override async Task ExecuteAsync(CancellationToken stoppingToken)
        {
            while (!stoppingToken.IsCancellationRequested)
            {
                using var scope = _services.CreateScope();
                var maintenanceService = scope.ServiceProvider.GetRequiredService<IMaintenanceService>();

                if (await maintenanceService.IsAutoCleanupEnabledAsync())
                {
                    var count = await maintenanceService.RunCleanupAsync();
                    _logger.LogInformation($"üßπ Auto-cleaned {count} old webhook logs.");
                }

                await Task.Delay(TimeSpan.FromHours(12), stoppingToken);
            }
        }
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\BackgroundWorkers\WebhookQueueWorker.cs 
====================================================== 
 
Ôªøusing System;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using xbytechat.api.Features.Webhooks.DTOs;
using xbytechat.api.Features.Webhooks.Services;

public class WebhookQueueWorker : BackgroundService
{
    private readonly IWebhookQueueService _queueService;
    private readonly IServiceScopeFactory _scopeFactory;
    private readonly ILogger<WebhookQueueWorker> _logger;

    public WebhookQueueWorker(
        IWebhookQueueService queueService,
        IServiceScopeFactory scopeFactory,
        ILogger<WebhookQueueWorker> logger)
    {
        _queueService = queueService;
        _scopeFactory = scopeFactory;
        _logger = logger;
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        _logger.LogInformation("üöÄ Webhook Queue Worker started.");

        while (!stoppingToken.IsCancellationRequested)
        {
            try
            {
                // Dequeue and clone once at the edge
                var payload = await _queueService.DequeueAsync(stoppingToken);
                var cloned = payload.Clone(); // keep independent of pooled reader
                var rawJson = cloned.GetRawText(); // üëà capture raw JSON up-front

                using var scope = _scopeFactory.CreateScope();

                var dispatcher = scope.ServiceProvider.GetRequiredService<IWhatsAppWebhookDispatcher>();
                var failureLogger = scope.ServiceProvider.GetRequiredService<IFailedWebhookLogService>();

                try
                {
                    await dispatcher.DispatchAsync(cloned);
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "‚ùå Error while dispatching webhook payload.");
                    // Persist the full raw JSON so we can replay/debug later
                    var fallback = new FailedWebhookLogDto
                    {
                        SourceModule = "WebhookQueueWorker",
                        FailureType = "DispatchError",
                        ErrorMessage = ex.Message,
                        RawJson = string.IsNullOrWhiteSpace(rawJson) ? "{}" : rawJson,
                        CreatedAt = DateTime.UtcNow
                    };
                    try
                    {
                        await failureLogger.LogFailureAsync(fallback);
                    }
                    catch (Exception innerEx)
                    {
                        _logger.LogError(innerEx, "‚ö†Ô∏è Failed to write to FailedWebhookLogs.");
                    }
                }
            }
            catch (OperationCanceledException)
            {
                _logger.LogInformation("üõë Graceful shutdown requested.");
                break;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "‚ùå Queue loop error (will retry shortly).");
                try { await Task.Delay(TimeSpan.FromSeconds(2), stoppingToken); } catch { /* ignore */ }
            }
        }

        _logger.LogInformation("üõë Webhook Queue Worker stopped.");
    }
}


 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Controllers\FailedWebhookLogsController.cs 
====================================================== 
 
Ôªøusing Microsoft.AspNetCore.Mvc;
using xbytechat.api.Features.Tracking.Services;
using xbytechat.api.Features.Tracking.Models;
using Microsoft.EntityFrameworkCore;
using xbytechat.api.Features.Webhooks.Services;

namespace xbytechat.api.Features.Tracking.Controllers
{
    [ApiController]
    [Route("api/failed-webhooks")]
    public class FailedWebhookLogsController : ControllerBase
    {
        private readonly IFailedWebhookLogService _service;

        public FailedWebhookLogsController(IFailedWebhookLogService service)
        {
            _service = service;
        }

        [HttpGet]
        public async Task<IActionResult> GetAllAsync()
        {
            var logs = await _service.GetAllAsync();
            return Ok(logs);
        }

        [HttpGet("{id}")]
        public async Task<IActionResult> GetById(Guid id)
        {
            var log = await _service.GetByIdAsync(id);
            if (log == null)
                return NotFound();

            return Ok(log);
        }
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Controllers\MaintenanceController.cs 
====================================================== 
 
Ôªøusing Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using xbytechat.api.Features.Webhooks.Models;
using xbytechat.api.Features.Webhooks.Services;

namespace xbytechat.api.Features.Webhooks.Controllers
{
    [ApiController]
    [Route("api/webhooks")]
    public class MaintenanceController : ControllerBase
    {
        private readonly AppDbContext _context;
        private readonly IMaintenanceService _maintenance;

        public MaintenanceController(AppDbContext context, IMaintenanceService maintenance)
        {
            _context = context;
            _maintenance = maintenance;
        }

        // ‚úÖ Injected Test Log for Dev Testing
        [HttpPost("inject-test-log")]
        public async Task<IActionResult> InjectTestLog()
        {
            var testLog = new FailedWebhookLog
            {
                SourceModule = "WebhookQueueWorker",
                FailureType = "DispatchError",
                ErrorMessage = "üß™ Simulated webhook dispatch failure for testing.",
                RawJson = "{\"sample\":\"test_payload\",\"reason\":\"unit_test\"}",
                CreatedAt = DateTime.UtcNow
            };

            _context.FailedWebhookLogs.Add(testLog);
            await _context.SaveChangesAsync();

            return Ok(new { message = "‚úÖ Injected test log successfully." });
        }

        // ‚úÖ Manual Cleanup Trigger
        [HttpPost("cleanup-now")]
        public async Task<IActionResult> CleanupNow()
        {
            var cutoff = DateTime.UtcNow.AddDays(-7);
            var oldLogs = await _context.FailedWebhookLogs
                .Where(x => x.CreatedAt < cutoff)
                .ToListAsync();

            if (!oldLogs.Any())
                return Ok(new { message = "‚úÖ No logs to delete." });

            _context.FailedWebhookLogs.RemoveRange(oldLogs);
            await _context.SaveChangesAsync();

            return Ok(new { message = $"‚úÖ Deleted {oldLogs.Count} old logs." });
        }

        // ‚úÖ Count of all failed logs
        [HttpGet("failed/count")]
        public async Task<IActionResult> GetFailedCount()
        {
            var count = await _context.FailedWebhookLogs.CountAsync();
            return Ok(count);
        }

        // ‚úÖ Cleanup Setting Status
             [HttpGet("settings")]
        public async Task<IActionResult> GetCleanupStatus()
        {
            var enabled = await _maintenance.IsAutoCleanupEnabledAsync();
            var lastRun = await _maintenance.GetLastCleanupTimeAsync();

            return Ok(new
            {
                enabled,
                lastCleanupAt = lastRun
            });
        }

        // ‚úÖ Enable Auto Cleanup
        [HttpPost("enable-cleanup")]
        public async Task<IActionResult> EnableCleanup()
        {
            await _maintenance.EnableAutoCleanupAsync();
            return Ok(new { message = "‚úÖ Auto-cleanup enabled." });
        }

        // ‚úÖ Disable Auto Cleanup
        [HttpPost("disable-cleanup")]
        public async Task<IActionResult> DisableCleanup()
        {
            await _maintenance.DisableAutoCleanupAsync();
            return Ok(new { message = "‚úÖ Auto-cleanup disabled." });
        }
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Controllers\WebhookCallback.cs 
====================================================== 
 
Ôªø// üìÑ File: Features/Webhooks/Controllers/WebhookCallbackController.cs
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Logging;
using System;
using System.Text.Json;
using System.Threading;
using xbytechat.api.Features.Webhooks.Services;

namespace xbytechat.api.Features.Webhooks.Controllers
{
    [ApiController]
    [Route("api/webhookcallback")]
    public class WebhookCallbackController : ControllerBase
    {
        private readonly ILogger<WebhookCallbackController> _logger;
        private readonly IWebhookQueueService _queue;

        public WebhookCallbackController(
            ILogger<WebhookCallbackController> logger,
            IWebhookQueueService queue)
        {
            _logger = logger;
            _queue = queue;
        }

        // ‚úÖ Single POST endpoint: Pinnacle (and others) send responses here
        [HttpPost]
        [Consumes("application/json")]
        [Produces("application/json")]
        public IActionResult Post([FromBody] JsonElement payload, CancellationToken ct)
        {
            if (!Request.HasJsonContentType())
            {
                return BadRequest(new { error = "Content-Type must be application/json" });
            }

            try
            {
                var raw = payload.GetRawText();
                _logger.LogInformation("üì• Webhook received. bytes={Len}", raw.Length);

                // Clone JsonElement before queueing
                _queue.Enqueue(payload.Clone());

                // Return 200 OK so Pinnacle won‚Äôt retry unnecessarily
                return Ok(new { received = true });
            }
            catch (OperationCanceledException)
            {
                _logger.LogWarning("‚ö†Ô∏è Webhook processing cancelled by client.");
                return StatusCode(499);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "‚ùå Failed to enqueue webhook payload.");
                // 500 lets BSP retry later
                return StatusCode(500, new { error = "webhook_enqueue_failed" });
            }
        }
    }

    // Small helper for JSON content-type
    internal static class HttpRequestContentTypeExtensions
    {
        public static bool HasJsonContentType(this HttpRequest request)
        {
            if (request?.ContentType is null) return false;
            return request.ContentType.StartsWith("application/json", StringComparison.OrdinalIgnoreCase);
        }
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Controllers\WebhookTestController.cs 
====================================================== 
 
Ôªøusing Microsoft.AspNetCore.Mvc;
using System.Text.Json;
using xbytechat.api.Features.Webhooks.Services;

namespace xbytechat.api.Features.Webhooks.Controllers
{
    [ApiController]
    [Route("api/webhooks/test")]
    public class WebhookTestController : ControllerBase
    {
        private readonly IWebhookQueueService _queue;

        public WebhookTestController(IWebhookQueueService queue)
        {
            _queue = queue;
        }

        [HttpPost("simulate-failure")]
        public IActionResult SimulateWebhookFailure()
        {
            var fakePayload = new
            {
                entry = new[]
                {
                    new
                    {
                        changes = new[]
                        {
                            new
                            {
                                value = new
                                {
                                    // This will cause dispatcher to throw due to invalid structure
                                    unexpected = "üß™ Simulated bad structure"
                                }
                            }
                        }
                    }
                }
            };

            var json = JsonSerializer.Serialize(fakePayload);
            var element = JsonDocument.Parse(json).RootElement;

            _queue.Enqueue(element);

            return Ok(new
            {
                message = "‚úÖ Test payload enqueued to simulate failure.",
                enqueued = true
            });
        }
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Controllers\WhatsAppWebhookController.cs 
====================================================== 
 
Ôªøusing Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using System.Text.Json;
using xbytechat.api.Features.Tracking.DTOs;
using xbytechat.api.Features.Webhooks.Services;

namespace xbytechat.api.Features.Webhooks.Controllers
{
    [ApiController]
    [Route("api/webhooks/whatsapp")]
    public class WhatsAppWebhookController : ControllerBase
    {
        private readonly ILogger<WhatsAppWebhookController> _logger;
        private readonly IConfiguration _config;
        private readonly AppDbContext _context;
        private readonly IWhatsAppWebhookService _webhookService;
        private readonly IWebhookQueueService _queue;

        public WhatsAppWebhookController(
            ILogger<WhatsAppWebhookController> logger,
            IConfiguration config,
            AppDbContext context,
            IWhatsAppWebhookService webhookService,
            IWebhookQueueService queue)
        {
            _logger = logger;
            _config = config;
            _context = context;
            _webhookService = webhookService;
            _queue = queue;
        }

        // ‚úÖ Step 1: Meta verification endpoint (GET)
        // Meta calls this to verify your webhook with hub.verify_token and expects you to return hub.challenge
        [HttpGet]
        public IActionResult VerifyWebhook(
            [FromQuery(Name = "hub.mode")] string mode,
            [FromQuery(Name = "hub.verify_token")] string token,
            [FromQuery(Name = "hub.challenge")] string challenge)
        {
            _logger.LogInformation(
                "üîé WhatsApp webhook verification request received. mode={Mode}, tokenLength={TokenLength}",
                mode,
                string.IsNullOrEmpty(token) ? 0 : token.Length);

            // üîê Load your secret token from config or environment.
            // Support multiple keys for safety/backward-compat:
            //  - WhatsApp:MetaVerifyToken  (matches your appsettings)
            //  - WhatsApp:MetaToken        (older name)
            //  - WhatsApp:VerifyWebHookToken (what this code was using)
            var expectedToken = _config["WhatsApp:VerifyWebHookToken"];

            if (string.IsNullOrWhiteSpace(expectedToken))
            {
                _logger.LogError(
                    "‚ùå WhatsApp webhook verification failed: no verify token configured. " +
                    "Set WhatsApp:MetaVerifyToken (or WhatsApp:MetaToken / WhatsApp:VerifyWebHookToken) in configuration.");
                return Forbid("Server verify token not configured.");
            }

            if (mode == "subscribe" && token == expectedToken)
            {
                _logger.LogInformation("‚úÖ WhatsApp webhook verified successfully.");
                return Ok(challenge); // Meta expects a 200 OK with the challenge value
            }

            _logger.LogWarning(
                "‚ùå WhatsApp webhook verification failed. Mode={Mode}, token did not match configured value.",
                mode);
            return Forbid("Token mismatch.");
        }

        //[HttpPost]
        //public IActionResult HandleStatus([FromBody] JsonElement payload)
        //{
        //    try
        //    {
        //        // Log that we actually got a POST. This is what we care about for inbound messages.
        //        var bodyString = payload.ToString();
        //        _logger.LogInformation(
        //            "üì• WhatsApp webhook POST received at controller. Payload length={Length} chars.",
        //            bodyString?.Length ?? 0);

        //        // Important: clone before enqueue
        //        var cloned = payload.Clone();
        //        _queue.Enqueue(cloned);

        //        _logger.LogInformation("üì• Webhook payload enqueued successfully.");
        //        return Ok(new { received = true });
        //    }
        //    catch (Exception ex)
        //    {
        //        _logger.LogError(ex, "‚ùå Failed to enqueue WhatsApp webhook payload.");
        //        return StatusCode(500, new { error = "Webhook queue failed" });
        //    }
        //}

        [HttpPost]
        public IActionResult HandleStatus([FromBody] JsonElement payload)
        {
            try
            {
                var bodyString = payload.ToString();

                _logger.LogInformation(
                    "üì• WhatsApp webhook POST received. Path={Path}, Query={Query}, Length={Length} chars.",
                    HttpContext.Request.Path,
                    HttpContext.Request.QueryString.ToString(),
                    bodyString?.Length ?? 0
                );

                var cloned = payload.Clone();
                _queue.Enqueue(cloned);

                _logger.LogInformation("üì• Webhook payload enqueued successfully.");
                return Ok(new { received = true });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "‚ùå Failed to enqueue WhatsApp webhook payload.");
                return StatusCode(500, new { error = "Webhook queue failed" });
            }
        }

    }
}


 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Directory\IProviderDirectory.cs 
====================================================== 
 
Ôªøusing System;
using System.Threading;
using System.Threading.Tasks;

namespace xbytechat.api.Features.Webhooks.Directory
{
    /// <summary>
    /// Resolves BusinessId from provider-specific webhook identifiers.
    /// </summary>
    public interface IProviderDirectory
    {
        /// <param name="provider">"meta" or "pinnacle" (lowercase preferred)</param>
        /// <param name="phoneNumberId">Meta/Pinnacle phone_number_id (strongest key)</param>
        /// <param name="displayPhoneNumber">Formatted sending number (e.g. "+91XXXXXXXXXX")</param>
        /// <param name="wabaId">WhatsApp Business Account ID (Meta)</param>
        /// <param name="waId">Optional WA ID (recipient); used only as a last-ditch heuristic</param>
        Task<Guid?> ResolveBusinessIdAsync(
            string? provider,
            string? phoneNumberId,
            string? displayPhoneNumber,
            string? wabaId,
            string? waId,
            CancellationToken ct = default);
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Directory\ProviderDirectory.cs 
====================================================== 
 
Ôªøusing System;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Caching.Memory;
using Microsoft.Extensions.Logging;
using xbytechat_api.WhatsAppSettings.Models;

namespace xbytechat.api.Features.Webhooks.Directory
{
    /// <summary>
    /// EF-backed resolver for mapping provider identifiers to BusinessId, with a short cache.
    /// </summary>
    public class ProviderDirectory : IProviderDirectory
    {
        private readonly AppDbContext _db;
        private readonly ILogger<ProviderDirectory> _logger;
        private readonly IMemoryCache _cache;

        // reduce DB hits during webhook bursts
        private static readonly TimeSpan CacheTtl = TimeSpan.FromMinutes(2);

        public ProviderDirectory(AppDbContext db, ILogger<ProviderDirectory> logger, IMemoryCache cache)
        {
            _db = db;
            _logger = logger;
            _cache = cache;
        }
        private static string NormalizeProviderKey(string? raw)
        {
            var p = (raw ?? "").Trim().ToLowerInvariant();
            return p switch
            {
                "meta" or "meta-cloud" or "meta_cloud" => "meta_cloud",
                "pinnacle" => "pinnacle",
                _ => p
            };
        }
        public async Task<Guid?> ResolveBusinessIdAsync(
            string? provider,
            string? phoneNumberId,
            string? displayPhoneNumber,
            string? wabaId,
            string? waId,
            CancellationToken ct = default)
        {
            provider = NormalizeProviderKey(provider);
            if (provider is "meta" or "meta-cloud") provider = "meta_cloud";
            var cacheKey = $"provdir:{provider}:{phoneNumberId}:{Normalize(displayPhoneNumber)}:{wabaId}";
            if (_cache.TryGetValue<Guid?>(cacheKey, out var cached))
                return cached;

            try
            {
                // ‚öì 1) Strongest match: provider + phone_number_id
                if (!string.IsNullOrWhiteSpace(provider) && !string.IsNullOrWhiteSpace(phoneNumberId))
                {
                    var hit = await QueryByAsync(provider, phoneNumberId: phoneNumberId, ct: ct);
                    if (hit.HasValue) return CacheAndReturn(cacheKey, hit);
                }

                // ‚öì 2) Next: provider + display_phone_number (normalized)
                var normalizedDisplay = Normalize(displayPhoneNumber);
                if (!string.IsNullOrWhiteSpace(provider) && !string.IsNullOrWhiteSpace(normalizedDisplay))
                {
                    var hit = await QueryByAsync(provider, displayPhoneNumber: normalizedDisplay, ct: ct);
                    if (hit.HasValue) return CacheAndReturn(cacheKey, hit);
                }

                // ‚öì 3) Next: provider + wabaId (Meta)
                if (!string.IsNullOrWhiteSpace(provider) && !string.IsNullOrWhiteSpace(wabaId))
                {
                    var hit = await QueryByAsync(provider, wabaId: wabaId, ct: ct);
                    if (hit.HasValue) return CacheAndReturn(cacheKey, hit);
                }

                _logger.LogWarning(
                    "ProviderDirectory: No match for provider={Provider}, pnid={PhoneId}, disp={Display}, waba={Waba}",
                    provider, phoneNumberId, normalizedDisplay, wabaId
                );
                return CacheAndReturn(cacheKey, null);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "ProviderDirectory lookup failed.");
                return null;
            }
        }

        private Guid? CacheAndReturn(string key, Guid? value)
        {
            _cache.Set(key, value, CacheTtl);
            return value;
        }

        /// <summary>
        /// Centralized query; now materializes candidates so Normalize() runs in-memory.
        /// </summary>
        private async Task<Guid?> QueryByAsync(
         string provider,
         string? phoneNumberId = null,
         string? displayPhoneNumber = null,
         string? wabaId = null,
         CancellationToken ct = default)
        {
            // Canonical provider (we always store in DB as CAPS)
            provider = (provider ?? string.Empty)
                .Trim()
                .Replace("-", "_")
                .Replace(" ", "_")
                .ToUpperInvariant();

            if (provider is not ("PINNACLE" or "META_CLOUD"))
                return null;

            var normDisp = Normalize(displayPhoneNumber); // your existing normalization (digits-only etc.)

            // 1) Prefer exact match by sender (PhoneNumberId or display number) from WhatsAppPhoneNumbers
            if (!string.IsNullOrWhiteSpace(phoneNumberId) || !string.IsNullOrWhiteSpace(normDisp))
            {
                var byNumber = await _db.WhatsAppPhoneNumbers
                    .AsNoTracking()
                    .Where(n => n.Provider == provider)
                    .Where(n =>
                        (!string.IsNullOrWhiteSpace(phoneNumberId) && n.PhoneNumberId == phoneNumberId) ||
                        (!string.IsNullOrWhiteSpace(normDisp) && Normalize(n.WhatsAppBusinessNumber) == normDisp))
                    .OrderByDescending(n => n.IsDefault)
                    .ThenByDescending(n => n.UpdatedAt ?? n.CreatedAt)
                    .Select(n => (Guid?)n.BusinessId)
                    .FirstOrDefaultAsync(ct);

                if (byNumber.HasValue)
                    return byNumber;
            }

            // 2) Fallback: match by WABA on the settings row (still lives on settings)
            if (!string.IsNullOrWhiteSpace(wabaId))
            {
                var byWaba = await _db.WhatsAppSettings
                    .AsNoTracking()
                    .Where(s => s.IsActive
                                && s.Provider.ToUpper() == provider
                                && s.WabaId == wabaId)
                    .OrderByDescending(s => s.UpdatedAt ?? s.CreatedAt)
                    .Select(s => (Guid?)s.BusinessId)
                    .FirstOrDefaultAsync(ct);

                if (byWaba.HasValue)
                    return byWaba;
            }

            return null;
        }

        /// <summary>
        /// Normalize phone formatting for robust comparisons.
        /// </summary>
        private static string? Normalize(string? phone)
        {
            if (string.IsNullOrWhiteSpace(phone)) return null;
            var trimmed = phone.Trim();
            var hasPlus = trimmed.StartsWith("+");
            var digits = new string(trimmed.Where(char.IsDigit).ToArray());
            return hasPlus ? "+" + digits : digits;
        }
    }
}



 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\DTOs\FailedWebhookLogDto.cs 
====================================================== 
 
Ôªøusing System;

namespace xbytechat.api.Features.Webhooks.DTOs
{
    public class FailedWebhookLogDto
    {
        public string? ErrorMessage { get; set; }
        public string? SourceModule { get; set; }
        public string? FailureType { get; set; }
        public string RawJson { get; set; } = string.Empty;
        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Models\FailedWebhookLog.cs 
====================================================== 
 
Ôªøusing System;

namespace xbytechat.api.Features.Webhooks.Models
{
    public class FailedWebhookLog
    {
        public Guid Id { get; set; } = Guid.NewGuid();

        // üß† Debug Metadata
        public string? ErrorMessage { get; set; }
        public string? SourceModule { get; set; } // e.g., StatusProcessor, ClickProcessor
        public string? FailureType { get; set; }  // e.g., JSON_PARSE_ERROR, DB_LOOKUP_FAILED

        // üì¶ Raw Data Snapshot
        public string RawJson { get; set; } = string.Empty;

        // üïí Timeline
        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Models\WebhookSettings.cs 
====================================================== 
 
Ôªønamespace xbytechat.api.Features.Webhooks.Models
{
    public class WebhookSettings
    {
        public Guid Id { get; set; } = Guid.NewGuid();
        public bool AutoCleanupEnabled { get; set; } = true;
        public DateTime? LastCleanupAt { get; set; }
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Pinnacle\Controllers\PinnacleWebhookController.cs 
====================================================== 
 
Ôªøusing Microsoft.AspNetCore.Mvc;
using System.Text.Json;
using xbytechat.api.Features.Webhooks.Pinnacle.Services.Adapters;
using xbytechat.api.Features.Webhooks.Services;

namespace xbytechat.api.Features.Webhooks.Pinnacle.Controllers
{
    [ApiController]
    [Route("api/pinnacle/callback")]
    public sealed class PinnacleWebhookController : ControllerBase
    {
        private readonly IWebhookQueueService _queue;
        private readonly IPinnacleToMetaAdapter _adapter;
        private readonly ILogger<PinnacleWebhookController> _logger;

        public PinnacleWebhookController(IWebhookQueueService queue, IPinnacleToMetaAdapter adapter, ILogger<PinnacleWebhookController> logger)
        {
            _queue = queue;
            _adapter = adapter;
            _logger = logger;
        }

        [HttpPost]
        public IActionResult Post([FromBody] JsonElement body)
        {
            // Transform to the envelope WhatsAppWebhookDispatcher already expects
            var metaEnvelope = _adapter.ToMetaEnvelope(body);
            _queue.Enqueue(metaEnvelope);
            _logger.LogInformation("üì® Pinnacle payload transformed and enqueued.");
            return Ok(new { received = true });
        }
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Pinnacle\Services\Adapters\IPinnacleToMetaAdapter.cs 
====================================================== 
 
Ôªøusing System.Text.Json;

namespace xbytechat.api.Features.Webhooks.Pinnacle.Services.Adapters
{
    public interface IPinnacleToMetaAdapter
    {
        /// <summary>Converts provider-native payload to Meta-like envelope:
        /// { "entry":[{ "changes":[{ "value": { ... } }]}] }</summary>
        JsonElement ToMetaEnvelope(JsonElement pinnPayload);
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Pinnacle\Services\Adapters\PinnacleToMetaAdapter.cs 
====================================================== 
 
Ôªøusing System.Buffers;
using System.Text.Json;

namespace xbytechat.api.Features.Webhooks.Pinnacle.Services.Adapters;

public sealed class PinnacleToMetaAdapter : IPinnacleToMetaAdapter
{
    public JsonElement ToMetaEnvelope(JsonElement p)
    {
        var buf = new ArrayBufferWriter<byte>();
        using var w = new Utf8JsonWriter(buf);

        w.WriteStartObject();
        w.WritePropertyName("entry");
        w.WriteStartArray();
        w.WriteStartObject(); // entry[0]
        w.WritePropertyName("changes");
        w.WriteStartArray();
        w.WriteStartObject(); // changes[0]
        w.WritePropertyName("value");
        w.WriteStartObject();

        // NEW: try to emit metadata up-front (harmless if not found)
        WriteMetadata(p, w);

        if (!TryMapStatuses(p, w) && !TryMapMessages(p, w))
        {
            w.WritePropertyName("provider_raw");
            p.WriteTo(w);
        }

        w.WriteEndObject(); // value
        w.WriteEndObject(); // change
        w.WriteEndArray();  // changes
        w.WriteEndObject(); // entry[0]
        w.WriteEndArray();  // entry
        w.WriteEndObject(); // root
        w.Flush();

        var ros = new ReadOnlySequence<byte>(buf.WrittenMemory);
        using var doc = JsonDocument.Parse(ros);
        return doc.RootElement.Clone();
    }

    // ---- NEW ----
    // Best-effort extraction; tolerate any Pinnacle layout you have.
    // We only write fields if we can resolve them.
    private static void WriteMetadata(JsonElement p, Utf8JsonWriter w)
    {
        string? displayPhone = null;
        string? phoneNumberId = null;
        string? wabaId = null;

        // common guesses; add/rename to match your Pinnacle payload
        // 1) flat
        if (p.TryGetProperty("display_phone_number", out var d1) && d1.ValueKind == JsonValueKind.String) displayPhone = d1.GetString();
        if (p.TryGetProperty("phone_number_id", out var pid1) && pid1.ValueKind == JsonValueKind.String) phoneNumberId = pid1.GetString();
        if (p.TryGetProperty("waba_id", out var wa1) && wa1.ValueKind == JsonValueKind.String) wabaId = wa1.GetString();

        // 2) channel
        if (p.TryGetProperty("channel", out var ch) && ch.ValueKind == JsonValueKind.Object)
        {
            if (displayPhone is null && ch.TryGetProperty("display_phone_number", out var d2) && d2.ValueKind == JsonValueKind.String) displayPhone = d2.GetString();
            if (displayPhone is null && ch.TryGetProperty("phone", out var d3) && d3.ValueKind == JsonValueKind.String) displayPhone = d3.GetString();

            if (phoneNumberId is null && ch.TryGetProperty("phone_number_id", out var pid2) && pid2.ValueKind == JsonValueKind.String) phoneNumberId = pid2.GetString();
            if (phoneNumberId is null && ch.TryGetProperty("id", out var pid3) && pid3.ValueKind == JsonValueKind.String) phoneNumberId = pid3.GetString();

            if (wabaId is null && ch.TryGetProperty("waba_id", out var wa2) && wa2.ValueKind == JsonValueKind.String) wabaId = wa2.GetString();
        }

        // 3) meta-style wrapper
        if (p.TryGetProperty("metadata", out var meta) && meta.ValueKind == JsonValueKind.Object)
        {
            if (displayPhone is null && meta.TryGetProperty("display_phone_number", out var d4) && d4.ValueKind == JsonValueKind.String) displayPhone = d4.GetString();
            if (phoneNumberId is null && meta.TryGetProperty("phone_number_id", out var pid4) && pid4.ValueKind == JsonValueKind.String) phoneNumberId = pid4.GetString();
            if (wabaId is null && meta.TryGetProperty("waba_id", out var wa3) && wa3.ValueKind == JsonValueKind.String) wabaId = wa3.GetString();
        }

        if (displayPhone is null && p.TryGetProperty("business", out var biz) && biz.ValueKind == JsonValueKind.Object)
        {
            if (biz.TryGetProperty("phone", out var d5) && d5.ValueKind == JsonValueKind.String) displayPhone = d5.GetString();
            if (biz.TryGetProperty("phone_id", out var pid5) && pid5.ValueKind == JsonValueKind.String) phoneNumberId = pid5.GetString();
        }

        // Only emit if we have at least one of them.
        if (displayPhone is not null || phoneNumberId is not null || wabaId is not null)
        {
            w.WritePropertyName("metadata");
            w.WriteStartObject();
            if (displayPhone is not null) w.WriteString("display_phone_number", displayPhone);
            if (phoneNumberId is not null) w.WriteString("phone_number_id", phoneNumberId);
            if (wabaId is not null) w.WriteString("waba_id", wabaId);
            w.WriteEndObject();
        }
    }
    // ---- NEW END ----

    private static bool TryMapStatuses(JsonElement p, Utf8JsonWriter w)
    {
        string? id = null, status = null;
        long? ts = null;

        if (p.TryGetProperty("messageId", out var mid) && mid.ValueKind == JsonValueKind.String) id = mid.GetString();
        if (p.TryGetProperty("id", out var pid) && pid.ValueKind == JsonValueKind.String) id ??= pid.GetString();
        if (p.TryGetProperty("status", out var st) && st.ValueKind == JsonValueKind.String) status = st.GetString();

        if (p.TryGetProperty("timestamp", out var t))
        {
            if (t.ValueKind == JsonValueKind.Number) ts = t.GetInt64();
            else if (t.ValueKind == JsonValueKind.String && long.TryParse(t.GetString(), out var n)) ts = n;
        }

        if (p.TryGetProperty("data", out var d) && d.ValueKind == JsonValueKind.Object)
        {
            if (id is null && d.TryGetProperty("id", out var did) && did.ValueKind == JsonValueKind.String) id = did.GetString();
            if (status is null && d.TryGetProperty("status", out var ds) && ds.ValueKind == JsonValueKind.String) status = ds.GetString();
            if (ts is null && d.TryGetProperty("ts", out var dts) && dts.ValueKind == JsonValueKind.Number) ts = dts.GetInt64();
        }

        if (id is null || status is null) return false;

        w.WritePropertyName("statuses");
        w.WriteStartArray();
        w.WriteStartObject();
        w.WriteString("id", id);
        w.WriteString("status", status);
        if (ts.HasValue) w.WriteNumber("timestamp", ts.Value);
        w.WriteEndObject();
        w.WriteEndArray();
        return true;
    }

    
    private static bool TryMapMessages(JsonElement p, Utf8JsonWriter w)
    {
        // { "click": { "title":"Flow Test", "contextId":"wamid..", "from":"<biz_phone?>" , "user":"<customer_wa_id?>" } }
        if (p.TryGetProperty("click", out var c) && c.ValueKind == JsonValueKind.Object)
        {
            var title = c.TryGetProperty("title", out var t) ? t.GetString() : null;
            var ctxId = c.TryGetProperty("contextId", out var ctx) ? ctx.GetString() : null;

            // customer who clicked
            var customerFrom = c.TryGetProperty("user", out var u) && u.ValueKind == JsonValueKind.String
                ? u.GetString()
                : (c.TryGetProperty("from", out var f1) && f1.ValueKind == JsonValueKind.String ? f1.GetString() : null);

            // **business** number that sent the message (Meta provides this as context.from)
            var businessFrom =
                (p.TryGetProperty("display_phone_number", out var d1) && d1.ValueKind == JsonValueKind.String) ? d1.GetString() :
                (p.TryGetProperty("channel", out var ch) && ch.ValueKind == JsonValueKind.Object &&
                 ch.TryGetProperty("phone", out var d2) && d2.ValueKind == JsonValueKind.String) ? d2.GetString() :
                (c.TryGetProperty("from", out var f2) && f2.ValueKind == JsonValueKind.String ? f2.GetString() : null); // last resort

            if (!string.IsNullOrWhiteSpace(title) && !string.IsNullOrWhiteSpace(ctxId))
            {
                w.WritePropertyName("messages");
                w.WriteStartArray();
                w.WriteStartObject();
                w.WriteString("type", "button");
                w.WriteString("from", customerFrom ?? "");          // customer wa_id
                w.WritePropertyName("button");
                w.WriteStartObject();
                w.WriteString("text", title!);
                w.WriteEndObject();
                w.WritePropertyName("context");
                w.WriteStartObject();
                w.WriteString("id", ctxId!);
                if (!string.IsNullOrWhiteSpace(businessFrom))
                    w.WriteString("from", businessFrom!);           // **important for directory resolution**
                w.WriteEndObject();
                w.WriteEndObject();
                w.WriteEndArray();
                return true;
            }
        }

        // { "message": { "from":"<customer_wa_id>", "body":"hi", "type":"text" }, "channel":{ "phone":"<biz_phone>" } }
        if (p.TryGetProperty("message", out var m) && m.ValueKind == JsonValueKind.Object)
        {
            var type = m.TryGetProperty("type", out var tp) ? tp.GetString() : "text";
            var from = m.TryGetProperty("from", out var fr) ? fr.GetString() : "";

            w.WritePropertyName("messages");
            w.WriteStartArray();
            w.WriteStartObject();
            w.WriteString("type", type ?? "text");
            w.WriteString("from", from ?? "");
            if ((type ?? "text") == "text")
            {
                var body = m.TryGetProperty("body", out var bd) ? bd.GetString() : "";
                w.WritePropertyName("text");
                w.WriteStartObject();
                w.WriteString("body", body ?? "");
                w.WriteEndObject();
            }
            w.WriteEndObject();
            w.WriteEndArray();
            return true;
        }

        return false;
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Services\FailedWebhookLogCleanupService.cs 
====================================================== 
 
Ôªøusing System;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using xbytechat.api;

namespace xbytechat.api.Features.Webhooks.Services
{
    /// <summary>
    /// Periodic cleanup of old failed webhook logs.
    /// Runs as a background service and exits cleanly on shutdown.
    /// </summary>
    public sealed class FailedWebhookLogCleanupService : BackgroundService
    {
        private readonly ILogger<FailedWebhookLogCleanupService> _logger;
        private readonly IServiceScopeFactory _scopeFactory;
        private readonly TimeSpan _interval = TimeSpan.FromHours(24); // daily run

        public FailedWebhookLogCleanupService(
            ILogger<FailedWebhookLogCleanupService> logger,
            IServiceScopeFactory scopeFactory)
        {
            _logger = logger;
            _scopeFactory = scopeFactory;
        }

        protected override async Task ExecuteAsync(CancellationToken stoppingToken)
        {
            _logger.LogInformation("üßπ FailedWebhookLogCleanupService started.");

            while (!stoppingToken.IsCancellationRequested)
            {
                try
                {
                    // If shutdown requested, bail out before touching DI / DbContext
                    stoppingToken.ThrowIfCancellationRequested();

                    using var scope = _scopeFactory.CreateScope();
                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();

                    var cutoff = DateTime.UtcNow.AddDays(-7);

                    var oldLogs = await db.FailedWebhookLogs
                        .Where(x => x.CreatedAt < cutoff)
                        .ToListAsync(stoppingToken);

                    if (oldLogs.Count > 0)
                    {
                        db.FailedWebhookLogs.RemoveRange(oldLogs);
                        await db.SaveChangesAsync(stoppingToken);
                        _logger.LogInformation(
                            "üßπ Deleted {Count} old failed webhook logs.",
                            oldLogs.Count
                        );
                    }
                }
                catch (OperationCanceledException) when (stoppingToken.IsCancellationRequested)
                {
                    // Normal shutdown ‚Äì just break the loop
                    _logger.LogDebug(
                        "FailedWebhookLogCleanupService cancellation requested, exiting loop."
                    );
                    break;
                }
                catch (ObjectDisposedException) when (stoppingToken.IsCancellationRequested)
                {
                    // DI container / DbContext got disposed during shutdown; safe to ignore
                    _logger.LogDebug(
                        "AppDbContext/ServiceProvider disposed during shutdown in FailedWebhookLogCleanupService."
                    );
                    break;
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "‚ùå Failed to clean up old webhook logs.");
                }

                try
                {
                    await Task.Delay(_interval, stoppingToken);
                }
                catch (OperationCanceledException) when (stoppingToken.IsCancellationRequested)
                {
                    _logger.LogDebug(
                        "FailedWebhookLogCleanupService delay cancelled, exiting loop."
                    );
                    break;
                }
            }

            _logger.LogInformation("üõë FailedWebhookLogCleanupService stopped.");
        }
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Services\FailedWebhookLogService.cs 
====================================================== 
 
Ôªøusing System;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using xbytechat.api.Features.Webhooks.DTOs;
using xbytechat.api.Features.Webhooks.Models;

namespace xbytechat.api.Features.Webhooks.Services
{
    public class FailedWebhookLogService : IFailedWebhookLogService
    {
        private readonly AppDbContext _context;
        private readonly ILogger<FailedWebhookLogService> _logger;

        public FailedWebhookLogService(AppDbContext context, ILogger<FailedWebhookLogService> logger)
        {
            _context = context;
            _logger = logger;
        }

        public async Task LogFailureAsync(FailedWebhookLogDto dto)
        {
            try
            {
                var log = new FailedWebhookLog
                {
                    ErrorMessage = dto.ErrorMessage,
                    SourceModule = dto.SourceModule,
                    FailureType = dto.FailureType,
                    RawJson = dto.RawJson,
                    CreatedAt = dto.CreatedAt
                };

                await _context.FailedWebhookLogs.AddAsync(log);
                await _context.SaveChangesAsync();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "‚ùå Failed to persist webhook error log");
            }
        }

        public async Task<List<FailedWebhookLog>> GetAllAsync()
        {
            return await _context.FailedWebhookLogs
                .OrderByDescending(x => x.CreatedAt)
                .Take(100) // prevent DB overload
                .ToListAsync();
        }

        public async Task<FailedWebhookLog?> GetByIdAsync(Guid id)
        {
            return await _context.FailedWebhookLogs.FindAsync(id);
        }

    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Services\IFailedWebhookLogService.cs 
====================================================== 
 
Ôªøusing System.Threading.Tasks;
using xbytechat.api.Features.Webhooks.DTOs;
using xbytechat.api.Features.Webhooks.Models;

namespace xbytechat.api.Features.Webhooks.Services
{
    public interface IFailedWebhookLogService
    {
        Task LogFailureAsync(FailedWebhookLogDto dto);
        Task<List<FailedWebhookLog>> GetAllAsync();
        Task<FailedWebhookLog?> GetByIdAsync(Guid id);
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Services\IMaintenanceService.cs 
====================================================== 
 
Ôªønamespace xbytechat.api.Features.Webhooks.Services
{
    public interface IMaintenanceService
    {
        Task<bool> IsAutoCleanupEnabledAsync();
        Task EnableAutoCleanupAsync();
        Task DisableAutoCleanupAsync();
        Task<DateTime?> GetLastCleanupTimeAsync();
        Task<int> RunCleanupAsync();
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Services\IWebhookQueueService.cs 
====================================================== 
 
Ôªøusing System.Text.Json;
using xbytechat.api.Features.Tracking.DTOs;

namespace xbytechat.api.Features.Webhooks.Services
{
    public interface IWebhookQueueService
    {
        void Enqueue(JsonElement payload);
        ValueTask<JsonElement> DequeueAsync(CancellationToken cancellationToken);
        int GetQueueLength();
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Services\IWhatsAppWebhookDispatcher.cs 
====================================================== 
 
Ôªøusing System.Text.Json;
using System.Threading.Tasks;

namespace xbytechat.api.Features.Webhooks.Services
{
    public interface IWhatsAppWebhookDispatcher
    {
        Task DispatchAsync(JsonElement payload);
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Services\IWhatsAppWebhookService.cs 
====================================================== 
 
Ôªøusing System.Text.Json;
using System.Threading.Tasks;

namespace xbytechat.api.Features.Webhooks.Services
{
    public interface IWhatsAppWebhookService
    {
        Task ProcessStatusUpdateAsync(Guid businessId, string provider, JsonElement payload, CancellationToken ct = default);
   
    
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Services\MaintenanceService.cs 
====================================================== 
 
Ôªøusing Microsoft.EntityFrameworkCore;
using xbytechat.api.Features.Webhooks.Models;

namespace xbytechat.api.Features.Webhooks.Services
{
    public class MaintenanceService : IMaintenanceService
    {
        private readonly AppDbContext _context;

        public MaintenanceService(AppDbContext context)
        {
            _context = context;
        }

        public async Task<bool> IsAutoCleanupEnabledAsync()
        {
            var setting = await _context.WebhookSettings
                .AsNoTracking()
                .FirstOrDefaultAsync();

            return setting?.AutoCleanupEnabled ?? false;
        }

        public async Task<DateTime?> GetLastCleanupTimeAsync()
        {
            return await _context.WebhookSettings
                .AsNoTracking()
                .Select(s => s.LastCleanupAt)
                .FirstOrDefaultAsync();
        }

        public async Task EnableAutoCleanupAsync()
        {
            var setting = await GetOrCreateAsync();
            setting.AutoCleanupEnabled = true;
            await _context.SaveChangesAsync();
        }

        public async Task DisableAutoCleanupAsync()
        {
            var setting = await GetOrCreateAsync();
            setting.AutoCleanupEnabled = false;
            await _context.SaveChangesAsync();
        }

        public async Task<int> RunCleanupAsync()
        {
            var threshold = DateTime.UtcNow.AddDays(-7);
            var oldLogs = await _context.FailedWebhookLogs
                .Where(l => l.CreatedAt < threshold)
                .ToListAsync();

            if (oldLogs.Any())
                _context.FailedWebhookLogs.RemoveRange(oldLogs);

            var setting = await GetOrCreateAsync();
            setting.LastCleanupAt = DateTime.UtcNow;

            await _context.SaveChangesAsync();
            return oldLogs.Count;
        }

        private async Task<WebhookSettings> GetOrCreateAsync()
        {
            var setting = await _context.WebhookSettings.FirstOrDefaultAsync();
            if (setting == null)
            {
                setting = new WebhookSettings
                {
                    AutoCleanupEnabled = false,
                    LastCleanupAt = null
                };
                _context.WebhookSettings.Add(setting);
                await _context.SaveChangesAsync();
            }
            return setting;
        }
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Services\WebhookQueueService.cs 
====================================================== 
 
Ôªøusing System.Text.Json;
using System.Threading.Channels;
using Microsoft.Extensions.Logging;

namespace xbytechat.api.Features.Webhooks.Services
{
    public class WebhookQueueService : IWebhookQueueService
    {
        private readonly Channel<JsonElement> _queue;
        private readonly ILogger<WebhookQueueService> _logger;

        public WebhookQueueService(ILogger<WebhookQueueService> logger)
        {
            _logger = logger;

            var options = new BoundedChannelOptions(5000)
            {
                FullMode = BoundedChannelFullMode.Wait,
                SingleReader = true,
                SingleWriter = false
            };

            _queue = Channel.CreateBounded<JsonElement>(options);

            _logger.LogInformation(
                "‚úÖ WebhookQueueService initialized with capacity {Capacity}, FullMode={FullMode}, SingleReader={SingleReader}, SingleWriter={SingleWriter}.",
                5000,
                options.FullMode,
                options.SingleReader,
                options.SingleWriter
            );
        }

        public void Enqueue(JsonElement item)
        {
            // Optional: log size instead of full content to avoid noisy logs
            var length = item.ToString()?.Length ?? 0;

            if (!_queue.Writer.TryWrite(item))
            {
                _logger.LogError(
                    "‚ùå Failed to enqueue webhook payload: queue is full. CurrentCount={Count}, PayloadLength={PayloadLength}.",
                    _queue.Reader.Count,
                    length
                );
                throw new InvalidOperationException("‚ö†Ô∏è Webhook queue is full.");
            }

            _logger.LogInformation(
                "üì• Enqueued webhook payload successfully. CurrentCount={Count}, PayloadLength={PayloadLength}.",
                _queue.Reader.Count,
                length
            );
        }

        public async ValueTask<JsonElement> DequeueAsync(CancellationToken cancellationToken)
        {
            var item = await _queue.Reader.ReadAsync(cancellationToken);

            // Again, just log length, not the full JSON, to keep logs readable
            var length = item.ToString()?.Length ?? 0;

            _logger.LogInformation(
                "üì§ Dequeued webhook payload for processing. RemainingCount={Count}, PayloadLength={PayloadLength}.",
                _queue.Reader.Count,
                length
            );

            return item;
        }

        public int GetQueueLength() => _queue.Reader.Count;
    }
}


//using System.Text.Json;
//using System.Threading.Channels;

//namespace xbytechat.api.Features.Webhooks.Services
//{
//    public class WebhookQueueService : IWebhookQueueService
//    {
//        private readonly Channel<JsonElement> _queue;

//        public WebhookQueueService()
//        {
//            var options = new BoundedChannelOptions(5000)
//            {
//                FullMode = BoundedChannelFullMode.Wait,
//                SingleReader = true,
//                SingleWriter = false
//            };

//            _queue = Channel.CreateBounded<JsonElement>(options);
//        }

//        public void Enqueue(JsonElement item)
//        {
//            if (!_queue.Writer.TryWrite(item))
//            {
//                throw new InvalidOperationException("‚ö†Ô∏è Webhook queue is full.");
//            }
//        }

//        public async ValueTask<JsonElement> DequeueAsync(CancellationToken cancellationToken)
//        {
//            return await _queue.Reader.ReadAsync(cancellationToken);
//        }

//        public int GetQueueLength() => _queue.Reader.Count;
//    }
//}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Services\WhatsAppWebhookDispatcher.cs 
====================================================== 
 
Ôªøusing System;
using System.Linq;
using System.Text.Json;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using xbytechat.api.Features.Webhooks.Directory;
using xbytechat.api.Features.Webhooks.Pinnacle.Services.Adapters;
using xbytechat.api.Features.Webhooks.Services.Processors;
using xbytechat_api.Features.Billing.Services;

namespace xbytechat.api.Features.Webhooks.Services
{
    public class WhatsAppWebhookDispatcher : IWhatsAppWebhookDispatcher
    {
        // Removed legacy _statusProcessor on purpose
        private readonly ITemplateWebhookProcessor _templateProcessor;
        private readonly IClickWebhookProcessor _clickProcessor;
        private readonly IInboundMessageProcessor _inboundMessageProcessor;
        private readonly IWhatsAppWebhookService _webhookService;
        private readonly IProviderDirectory _directory;
        private readonly ILogger<WhatsAppWebhookDispatcher> _logger;
        private readonly IPinnacleToMetaAdapter _pinnacleToMetaAdapter;
        private readonly IBillingIngestService _billingIngest;

        public WhatsAppWebhookDispatcher(
            ITemplateWebhookProcessor templateProcessor,
            ILogger<WhatsAppWebhookDispatcher> logger,
            IClickWebhookProcessor clickProcessor,
            IInboundMessageProcessor inboundMessageProcessor,
            IWhatsAppWebhookService webhookService,
            IProviderDirectory directory,
            IPinnacleToMetaAdapter pinnacleToMetaAdapter,
            IBillingIngestService billingIngest)
        {
            _templateProcessor = templateProcessor;
            _logger = logger;
            _clickProcessor = clickProcessor;
            _inboundMessageProcessor = inboundMessageProcessor;
            _webhookService = webhookService;
            _directory = directory;
            _pinnacleToMetaAdapter = pinnacleToMetaAdapter;
            _billingIngest = billingIngest;
        }

        public async Task DispatchAsync(JsonElement payload)
        {
            // Keep raw payload at Debug to avoid log spam in prod
            _logger.LogDebug("üì¶ Dispatcher raw payload:\n{Payload}", payload.GetRawText());

            try
            {
                // 0) Detect provider & normalize into a Meta-like "entry[].changes[].value" envelope
                var provider = DetectProvider(payload); // "meta" | "pinnacle" | null
                _logger.LogInformation("üåê Dispatcher: detected provider={Provider}", provider ?? "(auto/meta)");

                var envelope = provider == "pinnacle"
                    ? _pinnacleToMetaAdapter.ToMetaEnvelope(payload)
                    : payload;

                if (!envelope.TryGetProperty("entry", out var entries) || entries.ValueKind != JsonValueKind.Array)
                {
                    _logger.LogWarning("‚ö†Ô∏è Dispatcher: No 'entry' array found on envelope; skipping payload.");
                    return;
                }

                // Compute once per envelope (micro-optimization)
                var isStatus = IsStatusPayload(envelope);
                _logger.LogInformation("üîé Dispatcher: isStatusPayload={IsStatus}", isStatus);

                foreach (var entry in entries.EnumerateArray())
                {
                    if (!entry.TryGetProperty("changes", out var changes) || changes.ValueKind != JsonValueKind.Array)
                    {
                        _logger.LogDebug("‚ÑπÔ∏è Dispatcher: 'entry' without 'changes' array; skipping entry.");
                        continue;
                    }

                    foreach (var change in changes.EnumerateArray())
                    {
                        if (!change.TryGetProperty("value", out var value) || value.ValueKind != JsonValueKind.Object)
                        {
                            _logger.LogDebug("‚ÑπÔ∏è Dispatcher: 'change' without object 'value'; skipping change.");
                            continue;
                        }

                        // 1) STATUS UPDATES
                        if (isStatus)
                        {
                            _logger.LogInformation("üì¶ Dispatcher: treating envelope as STATUS payload (provider={Provider}).", provider ?? "meta");

                            // Resolve BusinessId using *envelope* metadata (works for Meta and adapted Pinnacle)
                            Guid resolvedBiz = Guid.Empty;
                            try
                            {
                                var hints = ExtractNumberHints(envelope, provider);
                                _logger.LogDebug(
                                    "üî¢ Dispatcher: Number hints extracted. PhoneNumberId={PhoneNumberId}, DisplayPhone={DisplayPhone}, WabaId={WabaId}, WaId={WaId}",
                                    hints.PhoneNumberId,
                                    hints.DisplayPhoneNumber,
                                    hints.WabaId,
                                    hints.WaId);

                                var bid = await _directory.ResolveBusinessIdAsync(
                                    provider: provider,
                                    phoneNumberId: hints.PhoneNumberId,
                                    displayPhoneNumber: hints.DisplayPhoneNumber,
                                    wabaId: hints.WabaId,
                                    waId: hints.WaId
                                );
                                if (bid.HasValue) resolvedBiz = bid.Value;
                            }
                            catch (Exception ex)
                            {
                                _logger.LogWarning(ex, "ProviderDirectory lookup failed; proceeding without BusinessId.");
                            }

                            // Canonical provider label for billing
                            var providerCanonical = string.Equals(provider, "pinnacle", StringComparison.OrdinalIgnoreCase)
                                ? "PINNACLE"
                                : "META_CLOUD";

                            // Only call billing ingest when BusinessId was resolved
                            if (resolvedBiz != Guid.Empty)
                            {
                                try
                                {
                                    _logger.LogInformation(
                                        "üí∞ Dispatcher: routing status payload to BillingIngest for BusinessId={BusinessId}, Provider={ProviderCanonical}",
                                        resolvedBiz,
                                        providerCanonical);

                                    await _billingIngest.IngestFromWebhookAsync(
                                        resolvedBiz,
                                        providerCanonical,
                                        envelope.GetRawText());
                                }
                                catch (Exception ex)
                                {
                                    _logger.LogWarning(ex, "Billing ingest from webhook failed (non-fatal).");
                                }
                            }
                            else
                            {
                                _logger.LogWarning(
                                    "‚ö†Ô∏è Dispatcher: status payload had no resolved BusinessId; billing ingest will be skipped.");
                            }

                            // Unified status updater (no legacy fallback)
                            _logger.LogInformation(
                                "üì¶ Dispatcher: routing to Unified Status Updater (provider={Provider}, businessId={BusinessId})",
                                provider,
                                resolvedBiz == Guid.Empty ? "(unknown)" : resolvedBiz.ToString());

                            await _webhookService.ProcessStatusUpdateAsync(
                                resolvedBiz,
                                provider ?? "meta",
                                envelope);

                            // Note: continue to next change ‚Äî even if envelope is status-oriented,
                            // other changes in the same webhook could be non-status in some providers.
                            continue;
                        }

                        // 2) TEMPLATE EVENTS
                        if (value.TryGetProperty("event", out var eventType) &&
                            eventType.GetString()?.StartsWith("template_", StringComparison.Ordinal) == true)
                        {
                            _logger.LogInformation("üì¶ Dispatcher: routing to Template Processor (event={Event})", eventType.GetString());
                            await _templateProcessor.ProcessTemplateUpdateAsync(envelope);
                            continue;
                        }

                        // 3) MESSAGES (clicks + inbound)
                        if (!value.TryGetProperty("messages", out var msgs) || msgs.GetArrayLength() == 0)
                        {
                            _logger.LogDebug("‚ÑπÔ∏è Dispatcher: 'value' has no 'messages' array or it is empty; skipping.");
                            continue;
                        }

                        foreach (var m in msgs.EnumerateArray())
                        {
                            if (!m.TryGetProperty("type", out var typeProp))
                            {
                                _logger.LogDebug("‚ÑπÔ∏è Dispatcher: message without 'type' field; skipping message.");
                                continue;
                            }

                            var type = typeProp.GetString();
                            _logger.LogDebug("üîç Dispatcher: inspecting message of type '{Type}'.", type);

                            // (A) Legacy quick-reply button ‚Üí CLICK
                            if (type == "button")
                            {
                                _logger.LogInformation("üëâ Dispatcher: routing to Click Processor (legacy 'button').");
                                await _clickProcessor.ProcessClickAsync(value);
                                continue;
                            }

                            // (B) Interactive (button_reply / list_reply) ‚Üí CLICK
                            if (type == "interactive" && m.TryGetProperty("interactive", out var interactive))
                            {
                                if (interactive.TryGetProperty("type", out var interactiveType) &&
                                    interactiveType.GetString() == "button_reply")
                                {
                                    _logger.LogInformation("üëâ Dispatcher: routing to Click Processor (interactive/button_reply).");
                                    await _clickProcessor.ProcessClickAsync(value);
                                    continue;
                                }

                                if (interactive.TryGetProperty("list_reply", out _))
                                {
                                    _logger.LogInformation("üëâ Dispatcher: routing to Click Processor (interactive/list_reply).");
                                    await _clickProcessor.ProcessClickAsync(value);
                                    continue;
                                }
                            }

                            // (C) Inbound plain message types ‚Üí INBOUND
                            if (type is "text" or "image" or "audio")
                            {
                                _logger.LogInformation(
                                    "üí¨ Dispatcher: routing to InboundMessageProcessor (message type: {Type}, provider={Provider}).",
                                    type,
                                    provider ?? "meta");

                                await _inboundMessageProcessor.ProcessChatAsync(value);
                                continue;
                            }

                            _logger.LogDebug("‚ÑπÔ∏è Dispatcher: message type '{Type}' not handled by dispatcher.", type);
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "‚ùå Dispatcher failed to process WhatsApp webhook.");
            }
        }

        private static bool IsStatusPayload(JsonElement root)
        {
            // Meta-like: entry[].changes[].value.statuses
            if (TryGetMetaValue(root, out var val) && val.Value.TryGetProperty("statuses", out _))
                return true;

            // Some providers mark with "status" or event containing "status"
            if (root.TryGetProperty("status", out _)) return true;
            if (root.TryGetProperty("event", out var ev) &&
                (ev.GetString()?.Contains("status", StringComparison.OrdinalIgnoreCase) ?? false))
                return true;

            return false;
        }

        private static string? DetectProvider(JsonElement root)
        {
            // Heuristics by envelope
            if (root.TryGetProperty("object", out var obj) && obj.GetString() == "whatsapp_business_account")
                return "meta";
            if (root.TryGetProperty("entry", out _))
                return "meta";
            if (root.TryGetProperty("event", out _))
                return "pinnacle";
            return null;
        }

        private static bool TryGetMetaValue(JsonElement root, out (JsonElement Value, JsonElement? Change, JsonElement? Entry) res)
        {
            res = default;
            if (!root.TryGetProperty("entry", out var entries) || entries.ValueKind != JsonValueKind.Array || entries.GetArrayLength() == 0)
                return false;

            var entry = entries[0];
            if (!entry.TryGetProperty("changes", out var changes) || changes.ValueKind != JsonValueKind.Array || changes.GetArrayLength() == 0)
                return false;

            var change = changes[0];
            if (!change.TryGetProperty("value", out var value))
                return false;

            res = (value, change, entry);
            return true;
        }

        private static NumberHints ExtractNumberHints(JsonElement root, string? provider)
        {
            var hints = new NumberHints();

            // Meta (or unknown ‚Üí treat as Meta envelope)
            if (string.Equals(provider, "meta", StringComparison.OrdinalIgnoreCase) || provider is null)
            {
                if (TryGetMetaValue(root, out var v))
                {
                    if (v.Value.TryGetProperty("metadata", out var md))
                    {
                        if (md.TryGetProperty("phone_number_id", out var pnid))
                            hints.PhoneNumberId = pnid.GetString();

                        if (md.TryGetProperty("display_phone_number", out var disp))
                            hints.DisplayPhoneNumber = NormalizePhone(disp.GetString());

                        if (md.TryGetProperty("waba_id", out var wabaFromMeta))
                            hints.WabaId = wabaFromMeta.GetString();
                    }

                    // Some adapters put waba_id at value-level
                    if (string.IsNullOrWhiteSpace(hints.WabaId) &&
                        v.Value.TryGetProperty("waba_id", out var wabaTop))
                    {
                        hints.WabaId = wabaTop.GetString();
                    }

                    // First status often carries recipient_id (WA ID)
                    if (v.Value.TryGetProperty("statuses", out var statuses) &&
                        statuses.ValueKind == JsonValueKind.Array && statuses.GetArrayLength() > 0)
                    {
                        var s0 = statuses[0];
                        if (s0.TryGetProperty("recipient_id", out var rid))
                            hints.WaId = rid.GetString();
                    }
                }
            }
            // Pinnacle (raw or adapted)
            else if (string.Equals(provider, "pinnacle", StringComparison.OrdinalIgnoreCase))
            {
                // If your adapter produced a Meta-like envelope, this will work too:
                if (TryGetMetaValue(root, out var v2) && v2.Value.TryGetProperty("metadata", out var md2))
                {
                    if (md2.TryGetProperty("phone_number_id", out var pnid2))
                        hints.PhoneNumberId = pnid2.GetString();

                    if (md2.TryGetProperty("display_phone_number", out var disp2))
                        hints.DisplayPhoneNumber = NormalizePhone(disp2.GetString());
                }

                // Raw Pinnacle-style fields on the envelope
                if (string.IsNullOrWhiteSpace(hints.PhoneNumberId) &&
                    root.TryGetProperty("phone_number_id", out var pn))
                    hints.PhoneNumberId = pn.GetString();

                if (string.IsNullOrWhiteSpace(hints.DisplayPhoneNumber))
                {
                    if (root.TryGetProperty("from", out var from))
                        hints.DisplayPhoneNumber = NormalizePhone(from.GetString());
                    else if (root.TryGetProperty("msisdn", out var msisdn))
                        hints.DisplayPhoneNumber = NormalizePhone(msisdn.GetString());
                }

                if (root.TryGetProperty("wabaId", out var waba))
                    hints.WabaId = waba.GetString();
            }

            return hints;
        }

        private static string? NormalizePhone(string? v)
        {
            if (string.IsNullOrWhiteSpace(v)) return null;
            var t = v.Trim();
            var keepPlus = t.StartsWith("+");
            var digits = new string(t.Where(char.IsDigit).ToArray());
            return keepPlus ? "+" + digits : digits;
        }

        private struct NumberHints
        {
            public string? PhoneNumberId { get; set; }
            public string? DisplayPhoneNumber { get; set; }
            public string? WabaId { get; set; }
            public string? WaId { get; set; }
        }
    }
}


//using System;
//using System.Linq;
//using System.Text.Json;
//using System.Threading.Tasks;
//using Microsoft.Extensions.Logging;
//using xbytechat.api.Features.Webhooks.Directory;
//using xbytechat.api.Features.Webhooks.Pinnacle.Services.Adapters;
//using xbytechat.api.Features.Webhooks.Services.Processors;
//using xbytechat_api.Features.Billing.Services;

//namespace xbytechat.api.Features.Webhooks.Services
//{
//    public class WhatsAppWebhookDispatcher : IWhatsAppWebhookDispatcher
//    {
//        // Removed legacy _statusProcessor on purpose
//        private readonly ITemplateWebhookProcessor _templateProcessor;
//        private readonly IClickWebhookProcessor _clickProcessor;
//        private readonly IInboundMessageProcessor _inboundMessageProcessor;
//        private readonly IWhatsAppWebhookService _webhookService;
//        private readonly IProviderDirectory _directory;
//        private readonly ILogger<WhatsAppWebhookDispatcher> _logger;
//        private readonly IPinnacleToMetaAdapter _pinnacleToMetaAdapter;
//        private readonly IBillingIngestService _billingIngest;

//        public WhatsAppWebhookDispatcher(
//            ITemplateWebhookProcessor templateProcessor,
//            ILogger<WhatsAppWebhookDispatcher> logger,
//            IClickWebhookProcessor clickProcessor,
//            IInboundMessageProcessor inboundMessageProcessor,
//            IWhatsAppWebhookService webhookService,
//            IProviderDirectory directory,
//            IPinnacleToMetaAdapter pinnacleToMetaAdapter,
//            IBillingIngestService billingIngest)
//        {
//            _templateProcessor = templateProcessor;
//            _logger = logger;
//            _clickProcessor = clickProcessor;
//            _inboundMessageProcessor = inboundMessageProcessor;
//            _webhookService = webhookService;
//            _directory = directory;
//            _pinnacleToMetaAdapter = pinnacleToMetaAdapter;
//            _billingIngest = billingIngest;
//        }

//        public async Task DispatchAsync(JsonElement payload)
//        {
//            // Keep raw payload at Debug to avoid log spam in prod
//            _logger.LogDebug("üì¶ Dispatcher raw payload:\n{Payload}", payload.GetRawText());

//            try
//            {
//                // 0) Detect provider & normalize into a Meta-like "entry[].changes[].value" envelope
//                var provider = DetectProvider(payload); // "meta" | "pinnacle" | null

//                var envelope = provider == "pinnacle"
//                    ? _pinnacleToMetaAdapter.ToMetaEnvelope(payload)
//                    : payload;

//                if (!envelope.TryGetProperty("entry", out var entries) || entries.ValueKind != JsonValueKind.Array)
//                    return;

//                // Compute once per envelope (micro-optimization)
//                var isStatus = IsStatusPayload(envelope);

//                foreach (var entry in entries.EnumerateArray())
//                {
//                    if (!entry.TryGetProperty("changes", out var changes) || changes.ValueKind != JsonValueKind.Array)
//                        continue;

//                    foreach (var change in changes.EnumerateArray())
//                    {
//                        if (!change.TryGetProperty("value", out var value) || value.ValueKind != JsonValueKind.Object)
//                            continue;

//                        // 1) STATUS UPDATES
//                        if (isStatus)
//                        {
//                            // Resolve BusinessId using *envelope* metadata (works for Meta and adapted Pinnacle)
//                            Guid resolvedBiz = Guid.Empty;
//                            try
//                            {
//                                var hints = ExtractNumberHints(envelope, provider);
//                                var bid = await _directory.ResolveBusinessIdAsync(
//                                    provider: provider,
//                                    phoneNumberId: hints.PhoneNumberId,
//                                    displayPhoneNumber: hints.DisplayPhoneNumber,
//                                    wabaId: hints.WabaId,
//                                    waId: hints.WaId
//                                );
//                                if (bid.HasValue) resolvedBiz = bid.Value;
//                            }
//                            catch (Exception ex)
//                            {
//                                _logger.LogWarning(ex, "ProviderDirectory lookup failed; proceeding without BusinessId.");
//                            }

//                            // Canonical provider label for billing
//                            var providerCanonical = string.Equals(provider, "pinnacle", StringComparison.OrdinalIgnoreCase)
//                                ? "PINNACLE"
//                                : "META_CLOUD";

//                            // Only call billing ingest when BusinessId was resolved
//                            if (resolvedBiz != Guid.Empty)
//                            {
//                                try
//                                {
//                                    await _billingIngest.IngestFromWebhookAsync(
//                                        resolvedBiz,
//                                        providerCanonical,
//                                        envelope.GetRawText());
//                                }
//                                catch (Exception ex)
//                                {
//                                    _logger.LogWarning(ex, "Billing ingest from webhook failed (non-fatal).");
//                                }
//                            }

//                            // Unified status updater (no legacy fallback)
//                            _logger.LogInformation(
//                                "üì¶ Routing to Unified Status Updater (provider={Provider}, businessId={BusinessId})",
//                                provider, resolvedBiz == Guid.Empty ? "(unknown)" : resolvedBiz.ToString());

//                            await _webhookService.ProcessStatusUpdateAsync(
//                                resolvedBiz,
//                                provider ?? "meta",
//                                envelope);

//                            // Note: continue to next change ‚Äî even if envelope is status-oriented,
//                            // other changes in the same webhook could be non-status in some providers.
//                            continue;
//                        }

//                        // 2) TEMPLATE EVENTS
//                        if (value.TryGetProperty("event", out var eventType) &&
//                            eventType.GetString()?.StartsWith("template_", StringComparison.Ordinal) == true)
//                        {
//                            _logger.LogInformation("üì¶ Routing to Template Processor");
//                            await _templateProcessor.ProcessTemplateUpdateAsync(envelope);
//                            continue;
//                        }

//                        // 3) MESSAGES (clicks + inbound)
//                        if (!value.TryGetProperty("messages", out var msgs) || msgs.GetArrayLength() == 0)
//                        {
//                            _logger.LogDebug("‚ÑπÔ∏è No 'messages' array present.");
//                            continue;
//                        }

//                        foreach (var m in msgs.EnumerateArray())
//                        {
//                            if (!m.TryGetProperty("type", out var typeProp))
//                            {
//                                _logger.LogDebug("‚ÑπÔ∏è Message without 'type' field.");
//                                continue;
//                            }

//                            var type = typeProp.GetString();

//                            // (A) Legacy quick-reply button ‚Üí CLICK
//                            if (type == "button")
//                            {
//                                _logger.LogInformation("üëâ Routing to Click Processor (legacy 'button')");
//                                await _clickProcessor.ProcessClickAsync(value);
//                                continue;
//                            }

//                            // (B) Interactive (button_reply / list_reply) ‚Üí CLICK
//                            if (type == "interactive" && m.TryGetProperty("interactive", out var interactive))
//                            {
//                                if (interactive.TryGetProperty("type", out var interactiveType) &&
//                                    interactiveType.GetString() == "button_reply")
//                                {
//                                    _logger.LogInformation("üëâ Routing to Click Processor (interactive/button_reply)");
//                                    await _clickProcessor.ProcessClickAsync(value);
//                                    continue;
//                                }

//                                if (interactive.TryGetProperty("list_reply", out _))
//                                {
//                                    _logger.LogInformation("üëâ Routing to Click Processor (interactive/list_reply)");
//                                    await _clickProcessor.ProcessClickAsync(value);
//                                    continue;
//                                }
//                            }

//                            // (C) Inbound plain message types ‚Üí INBOUND
//                            if (type is "text" or "image" or "audio")
//                            {
//                                _logger.LogInformation("üí¨ Routing to InboundMessageProcessor (type: {Type})", type);
//                                await _inboundMessageProcessor.ProcessChatAsync(value);
//                                continue;
//                            }

//                            _logger.LogDebug("‚ÑπÔ∏è Message type '{Type}' not handled by dispatcher.", type);
//                        }
//                    }
//                }
//            }
//            catch (Exception ex)
//            {
//                _logger.LogError(ex, "‚ùå Dispatcher failed to process WhatsApp webhook.");
//            }
//        }

//        private static bool IsStatusPayload(JsonElement root)
//        {
//            // Meta-like: entry[].changes[].value.statuses
//            if (TryGetMetaValue(root, out var val) && val.Value.TryGetProperty("statuses", out _))
//                return true;

//            // Some providers mark with "status" or event containing "status"
//            if (root.TryGetProperty("status", out _)) return true;
//            if (root.TryGetProperty("event", out var ev) &&
//                (ev.GetString()?.Contains("status", StringComparison.OrdinalIgnoreCase) ?? false))
//                return true;

//            return false;
//        }

//        private static string? DetectProvider(JsonElement root)
//        {
//            // Heuristics by envelope
//            if (root.TryGetProperty("object", out var obj) && obj.GetString() == "whatsapp_business_account")
//                return "meta";
//            if (root.TryGetProperty("entry", out _))
//                return "meta";
//            if (root.TryGetProperty("event", out _))
//                return "pinnacle";
//            return null;
//        }

//        private static bool TryGetMetaValue(JsonElement root, out (JsonElement Value, JsonElement? Change, JsonElement? Entry) res)
//        {
//            res = default;
//            if (!root.TryGetProperty("entry", out var entries) || entries.ValueKind != JsonValueKind.Array || entries.GetArrayLength() == 0)
//                return false;

//            var entry = entries[0];
//            if (!entry.TryGetProperty("changes", out var changes) || changes.ValueKind != JsonValueKind.Array || changes.GetArrayLength() == 0)
//                return false;

//            var change = changes[0];
//            if (!change.TryGetProperty("value", out var value))
//                return false;

//            res = (value, change, entry);
//            return true;
//        }

//        private static NumberHints ExtractNumberHints(JsonElement root, string? provider)
//        {
//            var hints = new NumberHints();

//            // Meta (or unknown ‚Üí treat as Meta envelope)
//            if (string.Equals(provider, "meta", StringComparison.OrdinalIgnoreCase) || provider is null)
//            {
//                if (TryGetMetaValue(root, out var v))
//                {
//                    if (v.Value.TryGetProperty("metadata", out var md))
//                    {
//                        if (md.TryGetProperty("phone_number_id", out var pnid))
//                            hints.PhoneNumberId = pnid.GetString();

//                        if (md.TryGetProperty("display_phone_number", out var disp))
//                            hints.DisplayPhoneNumber = NormalizePhone(disp.GetString());

//                        if (md.TryGetProperty("waba_id", out var wabaFromMeta))
//                            hints.WabaId = wabaFromMeta.GetString();
//                    }

//                    // Some adapters put waba_id at value-level
//                    if (string.IsNullOrWhiteSpace(hints.WabaId) &&
//                        v.Value.TryGetProperty("waba_id", out var wabaTop))
//                    {
//                        hints.WabaId = wabaTop.GetString();
//                    }

//                    // First status often carries recipient_id (WA ID)
//                    if (v.Value.TryGetProperty("statuses", out var statuses) &&
//                        statuses.ValueKind == JsonValueKind.Array && statuses.GetArrayLength() > 0)
//                    {
//                        var s0 = statuses[0];
//                        if (s0.TryGetProperty("recipient_id", out var rid))
//                            hints.WaId = rid.GetString();
//                    }
//                }
//            }
//            // Pinnacle (raw or adapted)
//            else if (string.Equals(provider, "pinnacle", StringComparison.OrdinalIgnoreCase))
//            {
//                // If your adapter produced a Meta-like envelope, this will work too:
//                if (TryGetMetaValue(root, out var v2) && v2.Value.TryGetProperty("metadata", out var md2))
//                {
//                    if (md2.TryGetProperty("phone_number_id", out var pnid2))
//                        hints.PhoneNumberId = pnid2.GetString();

//                    if (md2.TryGetProperty("display_phone_number", out var disp2))
//                        hints.DisplayPhoneNumber = NormalizePhone(disp2.GetString());
//                }

//                // Raw Pinnacle-style fields on the envelope
//                if (string.IsNullOrWhiteSpace(hints.PhoneNumberId) &&
//                    root.TryGetProperty("phone_number_id", out var pn))
//                    hints.PhoneNumberId = pn.GetString();

//                if (string.IsNullOrWhiteSpace(hints.DisplayPhoneNumber))
//                {
//                    if (root.TryGetProperty("from", out var from))
//                        hints.DisplayPhoneNumber = NormalizePhone(from.GetString());
//                    else if (root.TryGetProperty("msisdn", out var msisdn))
//                        hints.DisplayPhoneNumber = NormalizePhone(msisdn.GetString());
//                }

//                if (root.TryGetProperty("wabaId", out var waba))
//                    hints.WabaId = waba.GetString();
//            }

//            return hints;
//        }

//        private static string? NormalizePhone(string? v)
//        {
//            if (string.IsNullOrWhiteSpace(v)) return null;
//            var t = v.Trim();
//            var keepPlus = t.StartsWith("+");
//            var digits = new string(t.Where(char.IsDigit).ToArray());
//            return keepPlus ? "+" + digits : digits;
//        }

//        private struct NumberHints
//        {
//            public string? PhoneNumberId { get; set; }
//            public string? DisplayPhoneNumber { get; set; }
//            public string? WabaId { get; set; }
//            public string? WaId { get; set; }
//        }
//    }
//}





 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Services\WhatsAppWebhookService.cs 
====================================================== 
 
Ôªøusing System.Text.Json;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using xbytechat.api.Features.CampaignTracking.Models; // CampaignSendLog (optional if you keep only MessageLogs lookup)
using xbytechat.api.Features.MessageManagement.Services; // IMessageStatusUpdater
using xbytechat.api.Features.Webhooks.Status;
using xbytechat.api.Infrastructure; // your AppDbContext namespace (adjust if different)
using xbytechat.api.Infrastructure.Observability; // MetricsRegistry

namespace xbytechat.api.Features.Webhooks.Services
{
    

    public sealed class WhatsAppWebhookService : IWhatsAppWebhookService
    {
        private readonly AppDbContext _context;
        private readonly ILogger<WhatsAppWebhookService> _logger;
        private readonly IMessageStatusUpdater _updater;

        public WhatsAppWebhookService(
            AppDbContext context,
            ILogger<WhatsAppWebhookService> logger,
            IMessageStatusUpdater updater)
        {
            _context = context;
            _logger = logger;
            _updater = updater;
        }

        /// <summary>
        /// Single modern entrypoint. Assumes payload is Meta-shaped (entry[].changes[].value.statuses[]).
        /// If you ingest other providers, adapt them to this shape before calling here.
        /// </summary>
        public async Task ProcessStatusUpdateAsync(Guid businessId, string provider, JsonElement payload, CancellationToken ct = default)
        {
            provider = (provider ?? "").Trim().ToLowerInvariant();

            // Normalize status text to what the updater expects
            static string NormalizeStatus(string? s)
            {
                s = (s ?? "").Trim().ToLowerInvariant();
                return s switch
                {
                    "sent" => "sent",
                    "delivered" => "delivered",
                    "read" => "read",
                    "failed" => "failed",
                    _ => s
                };
            }

            // Parse Meta-like envelope: entry[].changes[].value.statuses[]
            if (!payload.TryGetProperty("entry", out var entries) || entries.ValueKind != JsonValueKind.Array)
            {
                _logger.LogWarning("Status payload missing 'entry' array.");
                return;
            }

            foreach (var entry in entries.EnumerateArray())
            {
                if (!entry.TryGetProperty("changes", out var changes) || changes.ValueKind != JsonValueKind.Array)
                    continue;

                foreach (var change in changes.EnumerateArray())
                {
                    if (!change.TryGetProperty("value", out var value) || value.ValueKind != JsonValueKind.Object)
                        continue;

                    if (!value.TryGetProperty("statuses", out var statuses) || statuses.ValueKind != JsonValueKind.Array)
                        continue;

                    foreach (var st in statuses.EnumerateArray())
                    {
                        // Fields: id (WAMID or provider id), status, timestamp
                        string? providerOrWaId = st.TryGetProperty("id", out var idProp) ? idProp.GetString() : null;
                        string? statusText = st.TryGetProperty("status", out var statusProp) ? statusProp.GetString() : null;

                        long unixTs = 0;
                        if (st.TryGetProperty("timestamp", out var tsProp))
                        {
                            if (tsProp.ValueKind == JsonValueKind.String && long.TryParse(tsProp.GetString(), out var parsed))
                                unixTs = parsed;
                            else if (tsProp.ValueKind == JsonValueKind.Number)
                                unixTs = tsProp.GetInt64();
                        }

                        if (string.IsNullOrWhiteSpace(providerOrWaId) || string.IsNullOrWhiteSpace(statusText))
                        {
                            _logger.LogWarning("Status item missing id or status: {Item}", st.GetRawText());
                            continue;
                        }

                        // Resolve canonical MessageId (WAMID) from DB; fallback to provider id if not found.
                        // 1) Try MessageLogs
                        string? messageId = await _context.MessageLogs.AsNoTracking()
                            .Where(m => m.ProviderMessageId == providerOrWaId || m.MessageId == providerOrWaId)
                            .OrderByDescending(m => m.CreatedAt)
                            .Select(m => m.MessageId ?? m.ProviderMessageId)
                            .FirstOrDefaultAsync(ct);

                        // 2) Optional: also look in CampaignSendLogs if desired
                        if (string.IsNullOrWhiteSpace(messageId))
                        {
                            messageId = await _context.CampaignSendLogs.AsNoTracking()
                                .Where(c => c.MessageId == providerOrWaId)
                                .OrderByDescending(c => c.CreatedAt)
                                .Select(c => c.MessageId)
                                .FirstOrDefaultAsync(ct);
                        }

                        messageId ??= providerOrWaId;

                        var tsUtc = unixTs > 0
                            ? DateTimeOffset.FromUnixTimeSeconds(unixTs).UtcDateTime
                            : DateTime.UtcNow;

                        var norm = NormalizeStatus(statusText);

                        // Updater signature: (messageId, status, tsUtc, error, ct)
                        await _updater.UpdateAsync(messageId, norm, tsUtc, null, ct);

                        _logger.LogInformation("Status updated: msg={MessageId} status={Status} ts={Ts}", messageId, norm, tsUtc);
                    }
                }
            }
        }
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Services\Processors\ClickWebhookProcessor.cs 
====================================================== 
 
Ôªøusing Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using System;
using System.IO.Pipelines;
using System.Text.Json;
using System.Threading.Tasks;
using xbytechat.api;
using xbytechat.api.DTOs.Messages;
using xbytechat.api.Features.CampaignTracking.Models;
using xbytechat.api.Features.CRM.Models;
using xbytechat.api.Features.CRM.Services;
using xbytechat.api.Features.CTAFlowBuilder.Models;
using xbytechat.api.Features.CTAFlowBuilder.Services;
using xbytechat.api.Features.CustomeApi.Models;
using xbytechat.api.Features.CustomeApi.Services;
using xbytechat.api.Features.MessagesEngine.DTOs;
using xbytechat.api.Features.MessagesEngine.Services;
using xbytechat.api.Features.Tracking.DTOs;
using xbytechat.api.Features.Tracking.Models;
using xbytechat.api.Features.Tracking.Services;
using xbytechat.api.Features.Webhooks.Services.Resolvers;
using xbytechat.api.Helpers;
using xbytechat.api.Shared.TrackingUtils;

namespace xbytechat.api.Features.Webhooks.Services.Processors
{
    public class ClickWebhookProcessor : IClickWebhookProcessor
    {
        private readonly ILogger<ClickWebhookProcessor> _logger;
        private readonly IMessageIdResolver _messageIdResolver;
        private readonly ITrackingService _trackingService;
        private readonly AppDbContext _context;
        private readonly IMessageEngineService _messageEngine;
        private readonly ICTAFlowService _flowService;
        private readonly IFlowRuntimeService _flowRuntime;
        private readonly IContactProfileService _contactProfile;
        private readonly ICtaJourneyPublisher _journeyPublisher;
        public ClickWebhookProcessor(
            ILogger<ClickWebhookProcessor> logger,
            IMessageIdResolver messageIdResolver,
            ITrackingService trackingService,
            AppDbContext context,
            IMessageEngineService messageEngine,
            ICTAFlowService flowService,
                        IFlowRuntimeService flowRuntime,
                         IContactProfileService contactProfile,
                          ICtaJourneyPublisher journeyPublisher
            )
        {
            _logger = logger;
            _messageIdResolver = messageIdResolver;
            _trackingService = trackingService;
            _context = context;
            _messageEngine = messageEngine;
            _flowService = flowService;
            _flowRuntime = flowRuntime;
            _contactProfile = contactProfile;
            _journeyPublisher = journeyPublisher;

        }

        // working code

        //public async Task ProcessClickAsync(JsonElement value)
        //{
        //    _logger.LogWarning("üì• [ENTERED CLICK PROCESSOR]");

        //    try
        //    {
        //        if (!value.TryGetProperty("messages", out var messages) || messages.GetArrayLength() == 0)
        //            return;

        //        static string Norm(string? s)
        //        {
        //            if (string.IsNullOrWhiteSpace(s)) return string.Empty;
        //            return string.Join(' ', s.Split(new[] { ' ', '\t', '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries))
        //                         .Trim()
        //                         .ToLowerInvariant();
        //        }

        //        // ‚úÖ Canonical phone: keep only digits (matches how we store & search contacts)
        //        static string NormalizePhone(string? raw)
        //            => new string((raw ?? string.Empty).Where(char.IsDigit).ToArray());

        //        // ‚úÖ contacts[0].profile.name (Meta shape)
        //        static string? TryGetProfileName(JsonElement root)
        //        {
        //            if (root.TryGetProperty("contacts", out var contactsEl) &&
        //                contactsEl.ValueKind == JsonValueKind.Array &&
        //                contactsEl.GetArrayLength() > 0)
        //            {
        //                var c0 = contactsEl[0];
        //                if (c0.TryGetProperty("profile", out var profEl) &&
        //                    profEl.ValueKind == JsonValueKind.Object &&
        //                    profEl.TryGetProperty("name", out var nameEl) &&
        //                    nameEl.ValueKind == JsonValueKind.String)
        //                {
        //                    var n = nameEl.GetString();
        //                    return string.IsNullOrWhiteSpace(n) ? null : n!.Trim();
        //                }
        //            }
        //            return null;
        //        }

        //        // >>> BEGIN MOD: helpers for CTAJourney key + botId extraction
        //        static string ToKey(string? s)
        //        {
        //            if (string.IsNullOrWhiteSpace(s)) return "unknown";
        //            var t = s.Trim().ToLowerInvariant();
        //            var sb = new System.Text.StringBuilder(t.Length);
        //            foreach (var ch in t)
        //            {
        //                if (char.IsLetterOrDigit(ch)) sb.Append(ch);
        //                else if (char.IsWhiteSpace(ch) || ch == '-' || ch == '_' || ch == '.') sb.Append('_');
        //            }
        //            var k = sb.ToString().Trim('_');
        //            return string.IsNullOrEmpty(k) ? "unknown" : k;
        //        }

        //        // read WA display number once (used as botId)
        //        string botIdFromWebhook = "";
        //        if (value.TryGetProperty("metadata", out var md) &&
        //            md.TryGetProperty("display_phone_number", out var dpnEl) &&
        //            dpnEl.ValueKind == JsonValueKind.String)
        //        {
        //            botIdFromWebhook = NormalizePhone(dpnEl.GetString());
        //        }
        //        // >>> END MOD

        //        foreach (var msg in messages.EnumerateArray())
        //        {
        //            if (!msg.TryGetProperty("type", out var typeProp))
        //                continue;

        //            var type = typeProp.GetString();

        //            string? clickMessageId = msg.TryGetProperty("id", out var idProp) ? idProp.GetString() : null;
        //            string? originalMessageId = msg.TryGetProperty("context", out var ctx) && ctx.TryGetProperty("id", out var ctxId)
        //                ? ctxId.GetString()
        //                : null;
        //            var fromRaw = msg.TryGetProperty("from", out var fromProp) ? (fromProp.GetString() ?? "") : "";
        //            var fromDigits = NormalizePhone(fromRaw);

        //            // ‚Äî‚Äî‚Äî button label extraction
        //            string? buttonText = null;
        //            if (string.Equals(type, "button", StringComparison.OrdinalIgnoreCase))
        //            {
        //                buttonText = msg.TryGetProperty("button", out var btn) &&
        //                             btn.TryGetProperty("text", out var textProp)
        //                               ? textProp.GetString()?.Trim()
        //                               : null;
        //            }
        //            else if (string.Equals(type, "interactive", StringComparison.OrdinalIgnoreCase) &&
        //                     msg.TryGetProperty("interactive", out var interactive))
        //            {
        //                if (interactive.TryGetProperty("type", out var intrType) &&
        //                    string.Equals(intrType.GetString(), "button_reply", StringComparison.OrdinalIgnoreCase) &&
        //                    interactive.TryGetProperty("button_reply", out var br) &&
        //                    br.TryGetProperty("title", out var titleProp))
        //                {
        //                    buttonText = titleProp.GetString()?.Trim();
        //                }
        //                else if (interactive.TryGetProperty("list_reply", out var lr) &&
        //                         lr.TryGetProperty("title", out var listTitleProp))
        //                {
        //                    buttonText = listTitleProp.GetString()?.Trim();
        //                }
        //            }

        //            if (string.IsNullOrWhiteSpace(buttonText) || string.IsNullOrWhiteSpace(originalMessageId))
        //            {
        //                _logger.LogDebug("‚ÑπÔ∏è Not a recognized click or missing context.id. type={Type}", type);
        //                continue;
        //            }

        //            _logger.LogInformation("üñ±Ô∏è Button Click ‚Üí From: {From}, ClickId: {ClickId}, OrigMsgId: {OrigId}, Text: {Text}",
        //                fromDigits, clickMessageId, originalMessageId, buttonText);

        //            // ‚Äî‚Äî Try 1: originating MessageLog (for flow-sent messages)
        //            var origin = await _context.MessageLogs
        //                .AsNoTracking()
        //                .FirstOrDefaultAsync(m =>
        //                    m.MessageId == originalMessageId &&
        //                    m.CTAFlowConfigId != null &&
        //                    m.CTAFlowStepId != null);

        //            Guid businessId;
        //            Guid flowId;
        //            Guid stepId;
        //            string? bundleJson = null;
        //            int? flowVersion = null;

        //            Guid? campaignSendLogId = null; // link the click to the shown message
        //            Guid? runId = null;             // copy from parent CSL when available

        //            if (origin != null)
        //            {
        //                businessId = origin.BusinessId;
        //                flowId = origin.CTAFlowConfigId!.Value;
        //                stepId = origin.CTAFlowStepId!.Value;
        //                bundleJson = origin.ButtonBundleJson;
        //                flowVersion = origin.FlowVersion;

        //                // Map back to CSL via MessageLogId or WAMID and fetch RunId
        //                var cslInfo = await _context.CampaignSendLogs
        //                    .AsNoTracking()
        //                    .Where(csl => (csl.MessageLogId == origin.Id) || (csl.MessageId == originalMessageId))
        //                    .OrderByDescending(csl => csl.CreatedAt)
        //                    .Select(csl => new { csl.Id, csl.RunId })
        //                    .FirstOrDefaultAsync();

        //                campaignSendLogId = cslInfo?.Id;
        //                runId = cslInfo?.RunId;
        //            }
        //            else
        //            {
        //                // ‚Äî‚Äî Try 2: first campaign message (CampaignSendLogs)
        //                var sendLog = await _context.CampaignSendLogs
        //                    .Include(sl => sl.Campaign)
        //                    .AsNoTracking()
        //                    .FirstOrDefaultAsync(sl => sl.MessageId == originalMessageId);

        //                if (sendLog == null)
        //                {
        //                    _logger.LogWarning("‚ùå No MessageLog or CampaignSendLog for original WAMID {Orig}", originalMessageId);
        //                    continue;
        //                }

        //                businessId = sendLog.BusinessId != Guid.Empty
        //                    ? sendLog.BusinessId
        //                    : (sendLog.Campaign?.BusinessId ?? Guid.Empty);

        //                if (businessId == Guid.Empty)
        //                {
        //                    _logger.LogWarning("‚ùå Could not resolve BusinessId for WAMID {Orig}", originalMessageId);
        //                    continue;
        //                }

        //                campaignSendLogId = sendLog.Id;
        //                runId = sendLog.RunId;

        //                if (sendLog.CTAFlowConfigId.HasValue && sendLog.CTAFlowStepId.HasValue)
        //                {
        //                    flowId = sendLog.CTAFlowConfigId.Value;
        //                    stepId = sendLog.CTAFlowStepId.Value;
        //                }
        //                else if (sendLog.Campaign?.CTAFlowConfigId != null)
        //                {
        //                    flowId = sendLog.Campaign.CTAFlowConfigId.Value;

        //                    var entry = await _context.CTAFlowSteps
        //                        .Where(s => s.CTAFlowConfigId == flowId)
        //                        .OrderBy(s => s.StepOrder)
        //                        .Select(s => s.Id)
        //                        .FirstOrDefaultAsync();

        //                    if (entry == Guid.Empty)
        //                    {
        //                        _logger.LogWarning("‚ùå No entry step found for flow {Flow}", flowId);
        //                        continue;
        //                    }

        //                    stepId = entry;
        //                }
        //                else
        //                {
        //                    _logger.LogWarning("‚ùå No flow context on CampaignSendLog for WAMID {Orig}", originalMessageId);
        //                    continue;
        //                }

        //                bundleJson = sendLog.ButtonBundleJson;
        //            }

        //            // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        //            // ‚úÖ UPSERT PROFILE NAME (create-or-update) *before* next step
        //            //    and make sure we look up by digits-only phone.
        //            // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        //            try
        //            {
        //                var profileName = TryGetProfileName(value);
        //                if (!string.IsNullOrWhiteSpace(profileName))
        //                {
        //                    var now = DateTime.UtcNow;
        //                    var contact = await _context.Contacts
        //                        .FirstOrDefaultAsync(c => c.BusinessId == businessId &&
        //                                                  (c.PhoneNumber == fromDigits || c.PhoneNumber == fromRaw));

        //                    if (contact == null)
        //                    {
        //                        profileName = profileName ?? "User";
        //                        contact = new Contact
        //                        {
        //                            Id = Guid.NewGuid(),
        //                            BusinessId = businessId,
        //                            PhoneNumber = fromDigits, // store canonical
        //                            Name = profileName,
        //                            ProfileName = profileName,
        //                            ProfileNameUpdatedAt = now,
        //                            CreatedAt = now,
        //                        };
        //                        _context.Contacts.Add(contact);
        //                        await _context.SaveChangesAsync();
        //                        _logger.LogInformation("üë§ Created contact + stored WA profile '{Name}' for {Phone} (biz {Biz})",
        //                            profileName, fromDigits, businessId);
        //                    }
        //                    else
        //                    {
        //                        var changed = false;

        //                        if (!string.Equals(contact.ProfileName, profileName, StringComparison.Ordinal))
        //                        {
        //                            contact.ProfileName = profileName;
        //                            contact.ProfileNameUpdatedAt = now;
        //                            changed = true;
        //                        }

        //                        if (string.IsNullOrWhiteSpace(contact.Name) ||
        //                            contact.Name == "WhatsApp User" ||
        //                            contact.Name == contact.PhoneNumber)
        //                        {
        //                            if (!string.Equals(contact.Name, profileName, StringComparison.Ordinal))
        //                            {
        //                                contact.Name = profileName;
        //                                changed = true;
        //                            }
        //                        }

        //                        if (changed)
        //                        {
        //                            contact.ProfileNameUpdatedAt = now;
        //                            await _context.SaveChangesAsync();
        //                            _logger.LogInformation("üë§ Updated WA profile name to '{Name}' for {Phone} (biz {Biz})",
        //                                profileName, fromDigits, businessId);
        //                        }
        //                    }
        //                }
        //            }
        //            catch (Exception exProf)
        //            {
        //                _logger.LogWarning(exProf, "‚ö†Ô∏è Failed to upsert WA profile name on click webhook.");
        //            }

        //            // ‚Äî‚Äî Map clicked text -> button index via the shown bundle
        //            short? buttonIndex = null;
        //            FlowBtnBundleNode? hit = null;

        //            if (!string.IsNullOrWhiteSpace(bundleJson))
        //            {
        //                try
        //                {
        //                    var nodes = System.Text.Json.JsonSerializer
        //                        .Deserialize<List<FlowBtnBundleNode>>(bundleJson) ?? new();

        //                    hit = nodes.FirstOrDefault(n =>
        //                              string.Equals(n.t ?? "", buttonText, StringComparison.OrdinalIgnoreCase))
        //                          ?? nodes.FirstOrDefault(n => Norm(n.t) == Norm(buttonText));

        //                    if (hit != null)
        //                        buttonIndex = (short)hit.i;
        //                }
        //                catch (Exception ex)
        //                {
        //                    _logger.LogWarning(ex, "‚ö†Ô∏è Failed to parse ButtonBundleJson");
        //                }
        //            }

        //            // ‚Äî‚Äî Fallback: find link by TEXT for this step
        //            FlowButtonLink? linkMatchedByText = null;
        //            if (buttonIndex == null)
        //            {
        //                var stepLinks = await _context.FlowButtonLinks
        //                    .Where(l => l.CTAFlowStepId == stepId)
        //                    .OrderBy(l => l.ButtonIndex)
        //                    .ToListAsync();

        //                if (stepLinks.Count > 0)
        //                {
        //                    linkMatchedByText = stepLinks.FirstOrDefault(l =>
        //                        string.Equals(l.ButtonText ?? "", buttonText, StringComparison.OrdinalIgnoreCase))
        //                        ?? stepLinks.FirstOrDefault(l => Norm(l.ButtonText) == Norm(buttonText));

        //                    if (linkMatchedByText == null && stepLinks.Count == 1)
        //                    {
        //                        linkMatchedByText = stepLinks[0];
        //                        _logger.LogInformation("üü® Falling back to single available link for step {Step}", stepId);
        //                    }

        //                    if (linkMatchedByText != null)
        //                    {
        //                        buttonIndex = (short?)linkMatchedByText.ButtonIndex;
        //                        _logger.LogInformation("‚úÖ Mapped click by TEXT to index {Idx} (flow={Flow}, step={Step})",
        //                            buttonIndex, flowId, stepId);
        //                    }
        //                }
        //            }

        //            if (buttonIndex == null)
        //            {
        //                _logger.LogInformation("üü° Button text not found in bundle or flow links. Ref={Ref}, Text='{Text}'",
        //                    originalMessageId, buttonText);
        //                continue;
        //            }

        //            // ‚Äî‚Äî Prefer exact link by index; otherwise use the text-matched link
        //            var link = await _flowService.GetLinkAsync(flowId, stepId, buttonIndex.Value)
        //                       ?? linkMatchedByText;

        //            if (link == null)
        //            {
        //                _logger.LogInformation("üü° No button link for (flow={Flow}, step={Step}, idx={Idx})",
        //                    flowId, stepId, buttonIndex);
        //                continue;
        //            }

        //            // ‚Äî‚Äî Resolve index + step name (for logging)
        //            short resolvedIndex = buttonIndex ?? Convert.ToInt16(link.ButtonIndex);
        //            var stepName = await _context.CTAFlowSteps
        //                .Where(s => s.Id == stepId)
        //                .Select(s => s.TemplateToSend)
        //                .FirstOrDefaultAsync() ?? string.Empty;

        //            // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
        //            // üìù WRITE CLICK LOG (always, even if terminal)
        //            // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
        //            try
        //            {
        //                var clickExec = new FlowExecutionLog
        //                {
        //                    Id = Guid.NewGuid(),
        //                    BusinessId = businessId,
        //                    FlowId = flowId,
        //                    StepId = stepId,
        //                    StepName = stepName,
        //                    CampaignSendLogId = campaignSendLogId,
        //                    MessageLogId = origin?.Id,
        //                    ContactPhone = fromDigits,      // ‚úÖ digits-only, consistent
        //                    ButtonIndex = resolvedIndex,
        //                    TriggeredByButton = buttonText,
        //                    TemplateName = null,
        //                    TemplateType = "quick_reply",
        //                    Success = true,
        //                    ExecutedAt = DateTime.UtcNow,
        //                    RequestId = Guid.NewGuid(),
        //                    RunId = runId
        //                };

        //                _context.FlowExecutionLogs.Add(clickExec);
        //                await _context.SaveChangesAsync();
        //            }
        //            catch (Exception exSave)
        //            {
        //                _logger.LogWarning(exSave, "‚ö†Ô∏è Failed to persist FlowExecutionLog (click). Continuing‚Ä¶");
        //            }
        //            // ===== RUNNING CTA JOURNEY STATE UPSERT (ONLY IF THIS BIZ IS CONFIGURED) =====
        //            string runningJourney;

        //            // Check once if this business is configured to receive CTAJourney.
        //            // If not, we won't touch ContactJourneyStates at all.
        //            bool shouldTrackState = await _context.CustomerWebhookConfigs
        //                .AsNoTracking()
        //                .AnyAsync(x => x.BusinessId == businessId && x.IsActive);

        //            if (shouldTrackState)
        //            {
        //                try
        //                {
        //                    // load current state for (business, flow, phone)
        //                    var state = await _context.ContactJourneyStates
        //                        .SingleOrDefaultAsync(s =>
        //                            s.BusinessId == businessId &&
        //                            s.FlowId == flowId &&
        //                            s.ContactPhone == fromDigits);

        //                    if (state == null)
        //                    {
        //                        // first click -> start with this button text (original casing)
        //                        state = new ContactJourneyState
        //                        {
        //                            Id = Guid.NewGuid(),
        //                            BusinessId = businessId,
        //                            FlowId = flowId,
        //                            ContactPhone = fromDigits,
        //                            JourneyText = buttonText ?? string.Empty,
        //                            ClickCount = 1,
        //                            LastButtonText = buttonText,
        //                            CreatedAt = DateTime.UtcNow,
        //                            UpdatedAt = DateTime.UtcNow
        //                        };
        //                        _context.ContactJourneyStates.Add(state);
        //                        await _context.SaveChangesAsync();
        //                        runningJourney = state.JourneyText;
        //                        _logger.LogInformation("üßµ Journey init: {Journey} (biz={Biz}, flow={Flow}, phone={Phone})",
        //                            runningJourney, businessId, flowId, fromDigits);
        //                    }
        //                    else
        //                    {
        //                        // append EVERY press (duplicates allowed), keep original casing
        //                        var parts = (state.JourneyText ?? string.Empty)
        //                            .Split('/', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries)
        //                            .ToList();

        //                        if (!string.IsNullOrWhiteSpace(buttonText))
        //                            parts.Add(buttonText!);

        //                        // optional safety: cap growth
        //                        const int cap = 15;
        //                        if (parts.Count > cap) parts = parts.Skip(parts.Count - cap).ToList();

        //                        state.JourneyText = string.Join('/', parts);
        //                        state.ClickCount += 1;
        //                        state.LastButtonText = buttonText;
        //                        state.UpdatedAt = DateTime.UtcNow;

        //                        await _context.SaveChangesAsync();
        //                        runningJourney = state.JourneyText ?? string.Empty;

        //                        _logger.LogInformation("üßµ Journey update: {Journey} (biz={Biz}, flow={Flow}, phone={Phone})",
        //                            runningJourney, businessId, flowId, fromDigits);
        //                    }
        //                }
        //                catch (Exception exState)
        //                {
        //                    _logger.LogWarning(exState, "‚ö†Ô∏è Failed to upsert ContactJourneyState.");
        //                    // fall back to this click only
        //                    runningJourney = buttonText ?? string.Empty;
        //                }
        //            }
        //            else
        //            {
        //                // Business not configured ‚Üí do NOT save any state. Just use the current button for emit.
        //                runningJourney = buttonText ?? string.Empty;
        //            }
        //            // ===== END RUNNING CTA JOURNEY STATE UPSERT =====


        //            // ===== CTAJourney EMIT (running journey) =====
        //            try
        //            {
        //                // contact (for userName / userPhone)
        //                var contact = await _context.Contacts
        //                    .AsNoTracking()
        //                    .FirstOrDefaultAsync(c => c.BusinessId == businessId && c.PhoneNumber == fromDigits);

        //                // prefer PhoneNumberId (botId) from the originating send; otherwise pick any active one
        //                string? phoneNumberId = null;
        //                if (campaignSendLogId.HasValue)
        //                {
        //                    phoneNumberId = await _context.CampaignSendLogs
        //                        .AsNoTracking()
        //                        .Where(s => s.Id == campaignSendLogId.Value)
        //                        .Select(s => s.Campaign.PhoneNumberId)
        //                        .FirstOrDefaultAsync();
        //                }
        //                if (string.IsNullOrWhiteSpace(phoneNumberId) && origin?.CampaignId != null)
        //                {
        //                    phoneNumberId = await _context.Campaigns
        //                        .AsNoTracking()
        //                        .Where(c => c.Id == origin.CampaignId.Value)
        //                        .Select(c => c.PhoneNumberId)
        //                        .FirstOrDefaultAsync();
        //                }

        //                //if (string.IsNullOrWhiteSpace(phoneNumberId))
        //                //{
        //                //    phoneNumberId = await _context.WhatsAppSettings
        //                //        .AsNoTracking()
        //                //        .Where(s => s.BusinessId == businessId && s.IsActive && s.PhoneNumberId != null)
        //                //        .OrderByDescending(s => s.UpdatedAt ?? s.CreatedAt)
        //                //        .Select(s => s.PhoneNumberId)
        //                //        .FirstOrDefaultAsync();
        //                //}
        //                // 2) Map PhoneNumberId -> WhatsAppBusinessNumber
        //                string? botWaNumber = null;
        //                if (!string.IsNullOrWhiteSpace(phoneNumberId))
        //                {
        //                    botWaNumber = await _context.WhatsAppPhoneNumbers
        //                        .AsNoTracking()
        //                        .Where(n => n.BusinessId == businessId && n.PhoneNumberId == phoneNumberId)
        //                        .Select(n => n.WhatsAppBusinessNumber)
        //                        .FirstOrDefaultAsync();
        //                }
        //                // business WA display number (fallback botId if no PhoneNumberId)
        //                var displayProfilename = await _context.WhatsAppSettings
        //                    .AsNoTracking()
        //                    .Where(s => s.BusinessId == businessId && s.IsActive && s.WhatsAppBusinessNumber != null)
        //                    .OrderByDescending(s => s.UpdatedAt ?? s.CreatedAt)
        //                    .Select(s => s.WhatsAppBusinessNumber)
        //                    .FirstOrDefaultAsync();

        //                // Build DTO and POST (CTAJourney = the running slash-joined string with original casing)
        //                var dto = CtaJourneyMapper.Build(
        //                    journeyKey: runningJourney,                    // <<‚Äî‚Äî use the running state
        //                    contact: contact,
        //                    profileName: contact?.ProfileName ?? contact?.Name,
        //                    userId: null,
        //                    phoneNumberId: botWaNumber,                  // preferred botId
        //                    businessDisplayPhone: displayProfilename,               // fallback botId if above missing
        //                    categoryBrowsed: null,
        //                    productBrowsed: null
        //                );

        //                await _journeyPublisher.PublishAsync(businessId, dto, CancellationToken.None);
        //                _logger.LogInformation("üì§ CTAJourney posted (running): {Journey} (biz={Biz}, phone={Phone})",
        //                    dto.CTAJourney, businessId, dto.userPhone);
        //            }
        //            catch (Exception ex)
        //            {
        //                _logger.LogWarning(ex, "‚ö†Ô∏è Failed to post CTAJourney (click). Continuing‚Ä¶");
        //            }

        //            // ===== end CTAJourney EMIT =====


        //            // ===== CTAJourney EMIT (button name) =====
        //            //try
        //            //{
        //            //    CTAJourney must be the button name now
        //            //   var journeyKey = ToKey(buttonText);
        //            //    var journeyKey = buttonText?.Trim();
        //            //    contact(for userName / userPhone)
        //            //        var contact = await _context.Contacts
        //            //            .AsNoTracking()
        //            //            .FirstOrDefaultAsync(c => c.BusinessId == businessId && c.PhoneNumber == fromDigits);

        //            //    prefer PhoneNumberId(botId) from the originating send; otherwise pick any active one
        //            //    string? phoneNumberId = null;
        //            //    if (campaignSendLogId.HasValue)
        //            //    {
        //            //        phoneNumberId = await _context.CampaignSendLogs
        //            //            .AsNoTracking()
        //            //            .Where(s => s.Id == campaignSendLogId.Value)
        //            //            .Select(s => s.Campaign.PhoneNumberId)
        //            //            .FirstOrDefaultAsync();
        //            //    }
        //            //    if (string.IsNullOrWhiteSpace(phoneNumberId) && origin?.CampaignId != null)
        //            //    {
        //            //        phoneNumberId = await _context.Campaigns
        //            //            .AsNoTracking()
        //            //            .Where(c => c.Id == origin.CampaignId.Value)
        //            //            .Select(c => c.PhoneNumberId)
        //            //            .FirstOrDefaultAsync();
        //            //    }
        //            //    if (string.IsNullOrWhiteSpace(phoneNumberId))
        //            //    {
        //            //        phoneNumberId = await _context.WhatsAppSettings
        //            //            .AsNoTracking()
        //            //            .Where(s => s.BusinessId == businessId && s.IsActive && s.PhoneNumberId != null)
        //            //            .OrderByDescending(s => s.UpdatedAt ?? s.CreatedAt)
        //            //            .Select(s => s.PhoneNumberId)
        //            //            .FirstOrDefaultAsync();
        //            //    }

        //            //    business WA display number(fallback botId if no PhoneNumberId)
        //            //    var displayWa = await _context.WhatsAppSettings
        //            //        .AsNoTracking()
        //            //        .Where(s => s.BusinessId == businessId && s.IsActive && s.WhatsAppBusinessNumber != null)
        //            //        .OrderByDescending(s => s.UpdatedAt ?? s.CreatedAt)
        //            //        .Select(s => s.WhatsAppBusinessNumber)
        //            //        .FirstOrDefaultAsync();

        //            //    build DTO and POST(maps to: userName / profileName, userPhone, botId, CTAJourney)
        //            //    var dto = CtaJourneyMapper.Build(
        //            //        journeyKey: journeyKey,                         // <<‚Äî‚Äî button name
        //            //        contact: contact,
        //            //        profileName: contact?.ProfileName ?? contact?.Name,
        //            //        userId: null,                                   // we don't have external user id
        //            //        phoneNumberId: phoneNumberId,                   // preferred botId
        //            //        businessDisplayPhone: displayWa,                // fallback botId if above missing
        //            //        categoryBrowsed: null,
        //            //        productBrowsed: null
        //            //    );

        //            //    await _journeyPublisher.PublishAsync(businessId, dto, CancellationToken.None);
        //            //    _logger.LogInformation("üì§ CTAJourney posted (button): {Journey} (biz={Biz}, phone={Phone})",
        //            //        dto.CTAJourney, businessId, dto.userPhone);
        //            //}
        //            //catch (Exception ex)
        //            //{
        //            //    _logger.LogWarning(ex, "‚ö†Ô∏è Failed to post CTAJourney (click). Continuing‚Ä¶");
        //            //}





        //            // ‚Äî‚Äî If terminal/URL button: already logged the click
        //            if (link.NextStepId == null)
        //            {
        //                _logger.LogInformation("üîö Terminal/URL button: no NextStepId. flow={Flow}, step={Step}, idx={Idx}, text='{Text}'",
        //                    flowId, stepId, resolvedIndex, link.ButtonText);
        //                continue;
        //            }

        //            if (_flowRuntime == null)
        //            {
        //                _logger.LogError("‚ùå _flowRuntime is null. Cannot execute next step. flow={Flow}, step={Step}, idx={Idx}", flowId, stepId, resolvedIndex);
        //                continue;
        //            }

        //            // ‚Äî‚Äî üîé Resolve sender from the originating campaign/send (use SAME WABA)
        //            string? providerFromCampaign = null;
        //            string? phoneNumberIdFromCampaign = null;

        //            if (campaignSendLogId.HasValue)
        //            {
        //                var originSend = await _context.CampaignSendLogs
        //                    .AsNoTracking()
        //                    .Include(s => s.Campaign)
        //                    .Where(s => s.Id == campaignSendLogId.Value)
        //                    .Select(s => new
        //                    {
        //                        s.Campaign.Provider,
        //                        s.Campaign.PhoneNumberId
        //                    })
        //                    .FirstOrDefaultAsync();

        //                providerFromCampaign = originSend?.Provider;
        //                phoneNumberIdFromCampaign = originSend?.PhoneNumberId;
        //            }
        //            else if (origin != null && origin.CampaignId.HasValue)
        //            {
        //                var originCamp = await _context.Campaigns
        //                    .AsNoTracking()
        //                    .Where(c => c.Id == origin.CampaignId.Value)
        //                    .Select(c => new { c.Provider, c.PhoneNumberId })
        //                    .FirstOrDefaultAsync();

        //                providerFromCampaign = originCamp?.Provider;
        //                phoneNumberIdFromCampaign = originCamp?.PhoneNumberId;
        //            }

        //            // ‚Äî‚Äî Execute next (carry sender forward)
        //            var ctxObj = new NextStepContext
        //            {
        //                BusinessId = businessId,
        //                FlowId = flowId,
        //                Version = flowVersion ?? 1,
        //                SourceStepId = stepId,
        //                TargetStepId = link.NextStepId!.Value,
        //                ButtonIndex = resolvedIndex,
        //                MessageLogId = origin?.Id ?? Guid.Empty,
        //                ContactPhone = fromDigits,     // ‚úÖ digits-only, so runtime finds the Contact
        //                RequestId = Guid.NewGuid(),
        //                ClickedButton = link,

        //                // üß∑ Sender from campaign so runtime won‚Äôt guess or fail with ‚ÄúMissing PhoneNumberId‚Äù
        //                Provider = providerFromCampaign,
        //                PhoneNumberId = phoneNumberIdFromCampaign,
        //                AlwaysSend = true // üî• force runtime to send even if it‚Äôs a loopback/same step
        //            };

        //            try
        //            {
        //                var result = await _flowRuntime.ExecuteNextAsync(ctxObj);

        //                if (result.Success && !string.IsNullOrWhiteSpace(result.RedirectUrl))
        //                {
        //                    _logger.LogInformation("üîó URL button redirect (logical): {Url}", result.RedirectUrl);
        //                }
        //            }
        //            catch (Exception exRun)
        //            {
        //                _logger.LogError(exRun,
        //                    "‚ùå ExecuteNextAsync failed. ctx: flow={Flow} step={Step} next={Next} idx={Idx} from={From} orig={Orig} text='{Text}'",
        //                    ctxObj.FlowId, ctxObj.SourceStepId, ctxObj.TargetStepId, ctxObj.ButtonIndex, fromDigits, originalMessageId, buttonText);
        //            }
        //        }
        //    }
        //    catch (Exception ex)
        //    {
        //        _logger.LogError(ex, "‚ùå Failed to process CTA button click.");
        //    }
        //}

        public async Task ProcessClickAsync(JsonElement value)
        {
            _logger.LogWarning("üì• [ENTERED CLICK PROCESSOR]");

            try
            {
                if (!value.TryGetProperty("messages", out var messages) || messages.GetArrayLength() == 0)
                    return;

                // ‚îÄ‚îÄ local helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                static string Norm(string? s)
                {
                    if (string.IsNullOrWhiteSpace(s)) return string.Empty;
                    return string.Join(' ', s.Split(new[] { ' ', '\t', '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries))
                                 .Trim()
                                 .ToLowerInvariant();
                }

                // canonical phone: keep only digits (matches how we store & search contacts)
                static string NormalizePhone(string? raw)
                    => new string((raw ?? string.Empty).Where(char.IsDigit).ToArray());

                // contacts[0].profile.name (Meta shape)
                static string? TryGetProfileName(JsonElement root)
                {
                    if (root.TryGetProperty("contacts", out var contactsEl) &&
                        contactsEl.ValueKind == JsonValueKind.Array &&
                        contactsEl.GetArrayLength() > 0)
                    {
                        var c0 = contactsEl[0];
                        if (c0.TryGetProperty("profile", out var profEl) &&
                            profEl.ValueKind == JsonValueKind.Object &&
                            profEl.TryGetProperty("name", out var nameEl) &&
                            nameEl.ValueKind == JsonValueKind.String)
                        {
                            var n = nameEl.GetString();
                            return string.IsNullOrWhiteSpace(n) ? null : n!.Trim();
                        }
                    }
                    return null;
                }

                // optional helper (kept for future use)
                static string ToKey(string? s)
                {
                    if (string.IsNullOrWhiteSpace(s)) return "unknown";
                    var t = s.Trim().ToLowerInvariant();
                    var sb = new System.Text.StringBuilder(t.Length);
                    foreach (var ch in t)
                    {
                        if (char.IsLetterOrDigit(ch)) sb.Append(ch);
                        else if (char.IsWhiteSpace(ch) || ch == '-' || ch == '_' || ch == '.') sb.Append('_');
                    }
                    var k = sb.ToString().Trim('_');
                    return string.IsNullOrEmpty(k) ? "unknown" : k;
                }
                // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

                // read WA display number once (used as botId) ‚Äì optional, not strictly required
                string botIdFromWebhook = "";
                if (value.TryGetProperty("metadata", out var md) &&
                    md.TryGetProperty("display_phone_number", out var dpnEl) &&
                    dpnEl.ValueKind == JsonValueKind.String)
                {
                    botIdFromWebhook = NormalizePhone(dpnEl.GetString());
                }

                foreach (var msg in messages.EnumerateArray())
                {
                    if (!msg.TryGetProperty("type", out var typeProp))
                        continue;

                    var type = typeProp.GetString();

                    string? clickMessageId = msg.TryGetProperty("id", out var idProp) ? idProp.GetString() : null;
                    string? originalMessageId = msg.TryGetProperty("context", out var ctx) && ctx.TryGetProperty("id", out var ctxId)
                        ? ctxId.GetString()
                        : null;

                    var fromRaw = msg.TryGetProperty("from", out var fromProp) ? (fromProp.GetString() ?? "") : "";
                    var fromDigits = NormalizePhone(fromRaw);

                    // ‚Äî‚Äî‚Äî button label extraction
                    string? buttonText = null;
                    if (string.Equals(type, "button", StringComparison.OrdinalIgnoreCase))
                    {
                        buttonText = msg.TryGetProperty("button", out var btn) &&
                                     btn.TryGetProperty("text", out var textProp)
                                       ? textProp.GetString()?.Trim()
                                       : null;
                    }
                    else if (string.Equals(type, "interactive", StringComparison.OrdinalIgnoreCase) &&
                             msg.TryGetProperty("interactive", out var interactive))
                    {
                        if (interactive.TryGetProperty("type", out var intrType) &&
                            string.Equals(intrType.GetString(), "button_reply", StringComparison.OrdinalIgnoreCase) &&
                            interactive.TryGetProperty("button_reply", out var br) &&
                            br.TryGetProperty("title", out var titleProp))
                        {
                            buttonText = titleProp.GetString()?.Trim();
                        }
                        else if (interactive.TryGetProperty("list_reply", out var lr) &&
                                 lr.TryGetProperty("title", out var listTitleProp))
                        {
                            buttonText = listTitleProp.GetString()?.Trim();
                        }
                    }

                    if (string.IsNullOrWhiteSpace(buttonText) || string.IsNullOrWhiteSpace(originalMessageId))
                    {
                        _logger.LogDebug("‚ÑπÔ∏è Not a recognized click or missing context.id. type={Type}", type);
                        continue;
                    }

                    _logger.LogInformation("üñ±Ô∏è Button Click ‚Üí From: {From}, ClickId: {ClickId}, OrigMsgId: {OrigId}, Text: {Text}",
                        fromDigits, clickMessageId, originalMessageId, buttonText);

                    // ‚Äî‚Äî Try 1: originating MessageLog (for flow-sent messages)
                    var origin = await _context.MessageLogs
                        .AsNoTracking()
                        .FirstOrDefaultAsync(m =>
                            m.MessageId == originalMessageId &&
                            m.CTAFlowConfigId != null &&
                            m.CTAFlowStepId != null);

                    Guid businessId;
                    Guid flowId;
                    Guid stepId;
                    string? bundleJson = null;
                    int? flowVersion = null;

                    Guid? campaignSendLogId = null; // link the click to the shown message
                    Guid? runId = null;             // copy from parent CSL when available

                    if (origin != null)
                    {
                        businessId = origin.BusinessId;
                        flowId = origin.CTAFlowConfigId!.Value;
                        stepId = origin.CTAFlowStepId!.Value;
                        bundleJson = origin.ButtonBundleJson;
                        flowVersion = origin.FlowVersion;

                        // Map back to CSL via MessageLogId or WAMID and fetch RunId
                        var cslInfo = await _context.CampaignSendLogs
                            .AsNoTracking()
                            .Where(csl => (csl.MessageLogId == origin.Id) || (csl.MessageId == originalMessageId))
                            .OrderByDescending(csl => csl.CreatedAt)
                            .Select(csl => new { csl.Id, csl.RunId })
                            .FirstOrDefaultAsync();

                        campaignSendLogId = cslInfo?.Id;
                        runId = cslInfo?.RunId;
                    }
                    else
                    {
                        // ‚Äî‚Äî Try 2: first campaign message (CampaignSendLogs)
                        var sendLog = await _context.CampaignSendLogs
                            .Include(sl => sl.Campaign)
                            .AsNoTracking()
                            .FirstOrDefaultAsync(sl => sl.MessageId == originalMessageId);

                        if (sendLog == null)
                        {
                            _logger.LogWarning("‚ùå No MessageLog or CampaignSendLog for original WAMID {Orig}", originalMessageId);
                            continue;
                        }

                        businessId = sendLog.BusinessId != Guid.Empty
                            ? sendLog.BusinessId
                            : (sendLog.Campaign?.BusinessId ?? Guid.Empty);

                        if (businessId == Guid.Empty)
                        {
                            _logger.LogWarning("‚ùå Could not resolve BusinessId for WAMID {Orig}", originalMessageId);
                            continue;
                        }

                        campaignSendLogId = sendLog.Id;
                        runId = sendLog.RunId;

                        if (sendLog.CTAFlowConfigId.HasValue && sendLog.CTAFlowStepId.HasValue)
                        {
                            flowId = sendLog.CTAFlowConfigId.Value;
                            stepId = sendLog.CTAFlowStepId.Value;
                        }
                        else if (sendLog.Campaign?.CTAFlowConfigId != null)
                        {
                            flowId = sendLog.Campaign.CTAFlowConfigId.Value;

                            var entry = await _context.CTAFlowSteps
                                .Where(s => s.CTAFlowConfigId == flowId)
                                .OrderBy(s => s.StepOrder)
                                .Select(s => s.Id)
                                .FirstOrDefaultAsync();

                            if (entry == Guid.Empty)
                            {
                                _logger.LogWarning("‚ùå No entry step found for flow {Flow}", flowId);
                                continue;
                            }

                            stepId = entry;
                        }
                        else
                        {
                            _logger.LogWarning("‚ùå No flow context on CampaignSendLog for WAMID {Orig}", originalMessageId);
                            continue;
                        }

                        bundleJson = sendLog.ButtonBundleJson;
                    }

                    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                    // ‚úÖ UPSERT PROFILE NAME (create-or-update) *before* next step
                    //    ensure we look up by digits-only phone.
                    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                    try
                    {
                        var profileName = TryGetProfileName(value);
                        if (!string.IsNullOrWhiteSpace(profileName))
                        {
                            var now = DateTime.UtcNow;
                            var contact = await _context.Contacts
                                .FirstOrDefaultAsync(c => c.BusinessId == businessId &&
                                                          (c.PhoneNumber == fromDigits || c.PhoneNumber == fromRaw));

                            if (contact == null)
                            {
                                profileName = profileName ?? "User";
                                contact = new Contact
                                {
                                    Id = Guid.NewGuid(),
                                    BusinessId = businessId,
                                    PhoneNumber = fromDigits, // store canonical
                                    Name = profileName,
                                    ProfileName = profileName,
                                    ProfileNameUpdatedAt = now,
                                    CreatedAt = now,
                                };
                                _context.Contacts.Add(contact);
                                await _context.SaveChangesAsync();
                                _logger.LogInformation("üë§ Created contact + stored WA profile '{Name}' for {Phone} (biz {Biz})",
                                    profileName, fromDigits, businessId);
                            }
                            else
                            {
                                var changed = false;

                                if (!string.Equals(contact.ProfileName, profileName, StringComparison.Ordinal))
                                {
                                    contact.ProfileName = profileName;
                                    contact.ProfileNameUpdatedAt = now;
                                    changed = true;
                                }

                                if (string.IsNullOrWhiteSpace(contact.Name) ||
                                    contact.Name == "WhatsApp User" ||
                                    contact.Name == contact.PhoneNumber)
                                {
                                    if (!string.Equals(contact.Name, profileName, StringComparison.Ordinal))
                                    {
                                        contact.Name = profileName;
                                        changed = true;
                                    }
                                }

                                if (changed)
                                {
                                    contact.ProfileNameUpdatedAt = now;
                                    await _context.SaveChangesAsync();
                                    _logger.LogInformation("üë§ Updated WA profile name to '{Name}' for {Phone} (biz {Biz})",
                                        profileName, fromDigits, businessId);
                                }
                            }
                        }
                    }
                    catch (Exception exProf)
                    {
                        _logger.LogWarning(exProf, "‚ö†Ô∏è Failed to upsert WA profile name on click webhook.");
                    }

                    // ‚Äî‚Äî Map clicked text -> button index via the shown bundle
                    short? buttonIndex = null;
                    FlowBtnBundleNode? hit = null;

                    if (!string.IsNullOrWhiteSpace(bundleJson))
                    {
                        try
                        {
                            var nodes = System.Text.Json.JsonSerializer
                                .Deserialize<List<FlowBtnBundleNode>>(bundleJson) ?? new();

                            hit = nodes.FirstOrDefault(n =>
                                      string.Equals(n.t ?? "", buttonText, StringComparison.OrdinalIgnoreCase))
                                  ?? nodes.FirstOrDefault(n => Norm(n.t) == Norm(buttonText));

                            if (hit != null)
                                buttonIndex = (short)hit.i;
                        }
                        catch (Exception ex)
                        {
                            _logger.LogWarning(ex, "‚ö†Ô∏è Failed to parse ButtonBundleJson");
                        }
                    }

                    // ‚Äî‚Äî Fallback: find link by TEXT for this step
                    FlowButtonLink? linkMatchedByText = null;
                    if (buttonIndex == null)
                    {
                        var stepLinks = await _context.FlowButtonLinks
                            .Where(l => l.CTAFlowStepId == stepId)
                            .OrderBy(l => l.ButtonIndex)
                            .ToListAsync();

                        if (stepLinks.Count > 0)
                        {
                            linkMatchedByText = stepLinks.FirstOrDefault(l =>
                                string.Equals(l.ButtonText ?? "", buttonText, StringComparison.OrdinalIgnoreCase))
                                ?? stepLinks.FirstOrDefault(l => Norm(l.ButtonText) == Norm(buttonText));

                            if (linkMatchedByText == null && stepLinks.Count == 1)
                            {
                                linkMatchedByText = stepLinks[0];
                                _logger.LogInformation("üü® Falling back to single available link for step {Step}", stepId);
                            }

                            if (linkMatchedByText != null)
                            {
                                buttonIndex = (short?)linkMatchedByText.ButtonIndex;
                                _logger.LogInformation("‚úÖ Mapped click by TEXT to index {Idx} (flow={Flow}, step={Step})",
                                    buttonIndex, flowId, stepId);
                            }
                        }
                    }

                    if (buttonIndex == null)
                    {
                        _logger.LogInformation("üü° Button text not found in bundle or flow links. Ref={Ref}, Text='{Text}'",
                            originalMessageId, buttonText);
                        continue;
                    }

                    // ‚Äî‚Äî Prefer exact link by index; otherwise use the text-matched link
                    var link = await _flowService.GetLinkAsync(flowId, stepId, buttonIndex.Value)
                               ?? linkMatchedByText;

                    if (link == null)
                    {
                        _logger.LogInformation("üü° No button link for (flow={Flow}, step={Step}, idx={Idx})",
                            flowId, stepId, buttonIndex);
                        continue;
                    }

                    // ‚Äî‚Äî Resolve index + step name (for logging)
                    short resolvedIndex = buttonIndex ?? Convert.ToInt16(link.ButtonIndex);
                    var stepName = await _context.CTAFlowSteps
                        .Where(s => s.Id == stepId)
                        .Select(s => s.TemplateToSend)
                        .FirstOrDefaultAsync() ?? string.Empty;

                    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
                    // üìù WRITE CLICK LOG (always, even if terminal)
                    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
                    try
                    {
                        var clickExec = new FlowExecutionLog
                        {
                            Id = Guid.NewGuid(),
                            BusinessId = businessId,
                            FlowId = flowId,
                            StepId = stepId,
                            StepName = stepName,
                            CampaignSendLogId = campaignSendLogId,
                            MessageLogId = origin?.Id,
                            ContactPhone = fromDigits,      // digits-only
                            ButtonIndex = resolvedIndex,
                            TriggeredByButton = buttonText,
                            TemplateName = null,
                            TemplateType = "quick_reply",
                            Success = true,
                            ExecutedAt = DateTime.UtcNow,
                            RequestId = Guid.NewGuid(),
                            RunId = runId
                        };

                        _context.FlowExecutionLogs.Add(clickExec);
                        await _context.SaveChangesAsync();
                    }
                    catch (Exception exSave)
                    {
                        _logger.LogWarning(exSave, "‚ö†Ô∏è Failed to persist FlowExecutionLog (click). Continuing‚Ä¶");
                    }

                    // ===== RUNNING CTA JOURNEY STATE UPSERT (ONLY IF THIS BIZ IS CONFIGURED) =====
                    string runningJourney;

                    // Check once if this business is configured to receive CTAJourney.
                    bool shouldTrackState = await _context.CustomerWebhookConfigs
                        .AsNoTracking()
                        .AnyAsync(x => x.BusinessId == businessId && x.IsActive);

                    if (shouldTrackState)
                    {
                        try
                        {
                            // load current state for (business, flow, phone)
                            var state = await _context.ContactJourneyStates
                                .SingleOrDefaultAsync(s =>
                                    s.BusinessId == businessId &&
                                    s.FlowId == flowId &&
                                    s.ContactPhone == fromDigits);

                            if (state == null)
                            {
                                // first click -> start with this button text (original casing)
                                state = new ContactJourneyState
                                {
                                    Id = Guid.NewGuid(),
                                    BusinessId = businessId,
                                    FlowId = flowId,
                                    ContactPhone = fromDigits,
                                    JourneyText = buttonText ?? string.Empty,
                                    ClickCount = 1,
                                    LastButtonText = buttonText,
                                    CreatedAt = DateTime.UtcNow,
                                    UpdatedAt = DateTime.UtcNow
                                };
                                _context.ContactJourneyStates.Add(state);
                                await _context.SaveChangesAsync();
                                runningJourney = state.JourneyText;
                                _logger.LogInformation("üßµ Journey init: {Journey} (biz={Biz}, flow={Flow}, phone={Phone})",
                                    runningJourney, businessId, flowId, fromDigits);
                            }
                            else
                            {
                                // append EVERY press (duplicates allowed), keep original casing
                                var parts = (state.JourneyText ?? string.Empty)
                                    .Split('/', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries)
                                    .ToList();

                                if (!string.IsNullOrWhiteSpace(buttonText))
                                    parts.Add(buttonText!);

                                // cap growth
                                const int cap = 15;
                                if (parts.Count > cap) parts = parts.Skip(parts.Count - cap).ToList();

                                state.JourneyText = string.Join('/', parts);
                                state.ClickCount += 1;
                                state.LastButtonText = buttonText;
                                state.UpdatedAt = DateTime.UtcNow;

                                await _context.SaveChangesAsync();
                                runningJourney = state.JourneyText ?? string.Empty;

                                _logger.LogInformation("üßµ Journey update: {Journey} (biz={Biz}, flow={Flow}, phone={Phone})",
                                    runningJourney, businessId, flowId, fromDigits);
                            }
                        }
                        catch (Exception exState)
                        {
                            _logger.LogWarning(exState, "‚ö†Ô∏è Failed to upsert ContactJourneyState.");
                            // fall back to this click only
                            runningJourney = buttonText ?? string.Empty;
                        }
                    }
                    else
                    {
                        // Business not configured ‚Üí do NOT save any state. Just use the current button for emit.
                        runningJourney = buttonText ?? string.Empty;
                    }
                    // ===== END RUNNING CTA JOURNEY STATE UPSERT =====

                    // ===== CTAJourney EMIT (running journey) =====
                    try
                    {
                        // contact (for userName / userPhone)
                        var contact = await _context.Contacts
                            .AsNoTracking()
                            .FirstOrDefaultAsync(c => c.BusinessId == businessId && c.PhoneNumber == fromDigits);

                        // Prefer sender from the originating send (keeps the same WABA)
                        string? senderProvider = null;
                        string? senderPhoneNumberId = null;

                        if (campaignSendLogId.HasValue)
                        {
                            var originSend = await _context.CampaignSendLogs
                                .AsNoTracking()
                                .Include(s => s.Campaign)
                                .Where(s => s.Id == campaignSendLogId.Value)
                                .Select(s => new { s.Campaign.Provider, s.Campaign.PhoneNumberId })
                                .FirstOrDefaultAsync();

                            senderProvider = originSend?.Provider;
                            senderPhoneNumberId = originSend?.PhoneNumberId;
                        }
                        if (string.IsNullOrWhiteSpace(senderPhoneNumberId) && origin?.CampaignId != null)
                        {
                            var originCamp = await _context.Campaigns
                                .AsNoTracking()
                                .Where(c => c.Id == origin.CampaignId.Value)
                                .Select(c => new { c.Provider, c.PhoneNumberId })
                                .FirstOrDefaultAsync();

                            senderProvider ??= originCamp?.Provider;
                            senderPhoneNumberId = originCamp?.PhoneNumberId;
                        }

                        // Map PhoneNumberId -> WhatsAppBusinessNumber, or choose a default for the same provider
                        string? waBusinessNumber = null;

                        if (!string.IsNullOrWhiteSpace(senderPhoneNumberId))
                        {
                            waBusinessNumber = await _context.WhatsAppPhoneNumbers
                                .AsNoTracking()
                                .Where(n => n.BusinessId == businessId && n.PhoneNumberId == senderPhoneNumberId)
                                .Select(n => n.WhatsAppBusinessNumber)
                                .FirstOrDefaultAsync();
                        }

                        if (string.IsNullOrWhiteSpace(waBusinessNumber))
                        {
                            var row = await _context.WhatsAppPhoneNumbers
                                .AsNoTracking()
                                .Where(n => n.BusinessId == businessId &&
                                            n.IsActive &&
                                            (string.IsNullOrEmpty(senderProvider) || n.Provider == senderProvider))
                                .OrderByDescending(n => n.IsDefault)
                                .ThenByDescending(n => n.UpdatedAt ?? n.CreatedAt)
                                .Select(n => new { n.PhoneNumberId, n.WhatsAppBusinessNumber })
                                .FirstOrDefaultAsync();

                            senderPhoneNumberId ??= row?.PhoneNumberId;
                            waBusinessNumber = row?.WhatsAppBusinessNumber;
                        }

                        var dto = CtaJourneyMapper.Build(
                            journeyKey: runningJourney,                      // running state with original casing
                            contact: contact,
                            profileName: contact?.ProfileName ?? contact?.Name,
                            userId: null,
                            phoneNumberId: waBusinessNumber,                 // publish WA display number as bot id
                            businessDisplayPhone: waBusinessNumber,          // same as above
                            categoryBrowsed: null,
                            productBrowsed: null
                        );

                        await _journeyPublisher.PublishAsync(businessId, dto, CancellationToken.None);
                        _logger.LogInformation("üì§ CTAJourney posted (running): {Journey} (biz={Biz}, phone={Phone})",
                            dto.CTAJourney, businessId, dto.userPhone);
                    }
                    catch (Exception ex)
                    {
                        _logger.LogWarning(ex, "‚ö†Ô∏è Failed to post CTAJourney (click). Continuing‚Ä¶");
                    }
                    // ===== end CTAJourney EMIT =====

                    // ‚Äî‚Äî If terminal/URL button: already logged the click
                    if (link.NextStepId == null)
                    {
                        _logger.LogInformation("üîö Terminal/URL button: no NextStepId. flow={Flow}, step={Step}, idx={Idx}, text='{Text}'",
                            flowId, stepId, resolvedIndex, link.ButtonText);
                        continue;
                    }

                    if (_flowRuntime == null)
                    {
                        _logger.LogError("‚ùå _flowRuntime is null. Cannot execute next step. flow={Flow}, step={Step}, idx={Idx}", flowId, stepId, resolvedIndex);
                        continue;
                    }

                    // ‚Äî‚Äî üîé Resolve sender from the originating campaign/send (use SAME WABA) for next step
                    string? providerFromCampaign = null;
                    string? phoneNumberIdFromCampaign = null;

                    if (campaignSendLogId.HasValue)
                    {
                        var originSend = await _context.CampaignSendLogs
                            .AsNoTracking()
                            .Include(s => s.Campaign)
                            .Where(s => s.Id == campaignSendLogId.Value)
                            .Select(s => new
                            {
                                s.Campaign.Provider,
                                s.Campaign.PhoneNumberId
                            })
                            .FirstOrDefaultAsync();

                        providerFromCampaign = originSend?.Provider;
                        phoneNumberIdFromCampaign = originSend?.PhoneNumberId;
                    }
                    else if (origin != null && origin.CampaignId.HasValue)
                    {
                        var originCamp = await _context.Campaigns
                            .AsNoTracking()
                            .Where(c => c.Id == origin.CampaignId.Value)
                            .Select(c => new { c.Provider, c.PhoneNumberId })
                            .FirstOrDefaultAsync();

                        providerFromCampaign = originCamp?.Provider;
                        phoneNumberIdFromCampaign = originCamp?.PhoneNumberId;
                    }

                    // ‚Äî‚Äî Execute next (carry sender forward)
                    var ctxObj = new NextStepContext
                    {
                        BusinessId = businessId,
                        FlowId = flowId,
                        Version = flowVersion ?? 1,
                        SourceStepId = stepId,
                        TargetStepId = link.NextStepId!.Value,
                        ButtonIndex = resolvedIndex,
                        MessageLogId = origin?.Id ?? Guid.Empty,
                        ContactPhone = fromDigits,     // digits-only
                        RequestId = Guid.NewGuid(),
                        ClickedButton = link,

                        // carry same sender into the next step
                        Provider = providerFromCampaign,
                        PhoneNumberId = phoneNumberIdFromCampaign,
                        AlwaysSend = true // force runtime to send even if it‚Äôs a loopback/same step
                    };

                    try
                    {
                        var result = await _flowRuntime.ExecuteNextAsync(ctxObj);

                        if (result.Success && !string.IsNullOrWhiteSpace(result.RedirectUrl))
                        {
                            _logger.LogInformation("üîó URL button redirect (logical): {Url}", result.RedirectUrl);
                        }
                    }
                    catch (Exception exRun)
                    {
                        _logger.LogError(exRun,
                            "‚ùå ExecuteNextAsync failed. ctx: flow={Flow} step={Step} next={Next} idx={Idx} from={From} orig={Orig} text='{Text}'",
                            ctxObj.FlowId, ctxObj.SourceStepId, ctxObj.TargetStepId, ctxObj.ButtonIndex, fromDigits, originalMessageId, buttonText);
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "‚ùå Failed to process CTA button click.");
            }
        }

        private sealed class FlowBtnBundleNode
        {
            public int i { get; init; }
            public string? t { get; init; }   // button text/title
            public string? ty { get; init; }  // button type (URL/QUICK_REPLY/FLOW)
            public string? v { get; init; }   // value/payload (e.g., URL)
            public Guid? ns { get; init; }    // next step id
        }
        private static string ToKey(string? s)
        {
            if (string.IsNullOrWhiteSpace(s)) return "unknown";
            // letters/digits ‚Üí lower, spaces/._- ‚Üí underscore, strip the rest
            var chars = s.Trim().ToLowerInvariant()
                .Select(ch => char.IsLetterOrDigit(ch) ? ch : '_')
                .ToArray();
            var key = new string(chars);
            // squeeze duplicate underscores
            while (key.Contains("__")) key = key.Replace("__", "_");
            return key.Trim('_');
        }

    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Services\Processors\IClickWebhookProcessor.cs 
====================================================== 
 
Ôªøusing System.Text.Json;
using System.Threading.Tasks;

namespace xbytechat.api.Features.Webhooks.Services.Processors
{
    public interface IClickWebhookProcessor
    {
        Task ProcessClickAsync(JsonElement value);
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Services\Processors\IInboundMessageProcessor.cs 
====================================================== 
 
Ôªøusing System.Text.Json;
using System.Threading.Tasks;

namespace xbytechat.api.Features.Webhooks.Services.Processors
{
    public interface IInboundMessageProcessor
    {
        Task ProcessChatAsync(JsonElement value);
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Services\Processors\InboundMessageProcessor.cs 
====================================================== 
 
Ôªøusing System;
using System.Text.Json;
using System.Threading.Tasks;
using Microsoft.AspNetCore.SignalR;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using xbytechat.api;
using xbytechat.api.Features.Inbox.DTOs;
using xbytechat.api.Features.CRM.Models;
using xbytechat.api.Features.Inbox.Hubs;
using Microsoft.Extensions.DependencyInjection;
using xbytechat.api.Features.AutoReplyBuilder.Services;
using xbytechat.api.Features.Inbox.Services;
using xbytechat.api.Features.MessagesEngine.DTOs;
using xbytechat.api.Features.MessagesEngine.Services;
using xbytechat.api.Features.CRM.Services;
using xbytechat.api.Features.Automation.Services;
using xbytechat.api.Features.Webhooks.Directory;
using xbytechat.api.Features.CRM.Interfaces;
using xbytechat.api.Features.CRM.Services; // üîπ NEW: provider directory

namespace xbytechat.api.Features.Webhooks.Services.Processors
{
    public class InboundMessageProcessor : IInboundMessageProcessor
    {
        private readonly AppDbContext _context;
        private readonly IHubContext<InboxHub> _hubContext;
        private readonly ILogger<InboundMessageProcessor> _logger;
        private readonly IInboxService _inboxService;
        private readonly IServiceScopeFactory _serviceScopeFactory;
        private readonly IHubContext<InboxHub> _hub;
        private readonly IContactProfileService _contactProfile;
        private readonly IProviderDirectory _providerDirectory; // üîπ NEW

        public InboundMessageProcessor(
            AppDbContext context,
            IHubContext<InboxHub> hubContext,
            ILogger<InboundMessageProcessor> logger,
            IInboxService inboxService,
            IServiceScopeFactory serviceScopeFactory,
            IHubContext<InboxHub> hub,
            IContactProfileService contactProfile,
            IProviderDirectory providerDirectory // üîπ NEW
        )
        {
            _context = context;
            _hubContext = hubContext;
            _logger = logger;
            _inboxService = inboxService;
            _serviceScopeFactory = serviceScopeFactory;
            _hub = hub;
            _contactProfile = contactProfile;
            _providerDirectory = providerDirectory; // üîπ NEW
        }

        public async Task ProcessChatAsync(JsonElement value)
        {
            try
            {
                using var scope = _serviceScopeFactory.CreateScope();
                var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();
                var contactService = scope.ServiceProvider.GetRequiredService<IContactService>();
                var chatSessionStateService = scope.ServiceProvider.GetRequiredService<IChatSessionStateService>();
                var automationService = scope.ServiceProvider.GetRequiredService<IAutomationService>();
                var autoReplyRuntime = scope.ServiceProvider.GetRequiredService<IAutoReplyRuntimeService>();
                var logger = scope.ServiceProvider.GetRequiredService<ILogger<InboundMessageProcessor>>();
                var contactProfileService = scope.ServiceProvider.GetRequiredService<IContactProfileService>();

                // digits-only normalizer (matches how we store/search phones)
                static string Normalize(string? s) =>
                    string.IsNullOrWhiteSpace(s) ? "" : new string(s.Where(char.IsDigit).ToArray());

                // 1) Extract WA metadata + message (Meta Cloud shape)
                if (!value.TryGetProperty("messages", out var messages) || messages.GetArrayLength() == 0)
                {
                    logger.LogWarning("Inbound WA payload has no messages array.");
                    return;
                }

                var msg = messages[0];

                var msgType = msg.TryGetProperty("type", out var typeProp)
                    ? typeProp.GetString()
                    : "unknown";

                var rawContactPhone = msg.GetProperty("from").GetString() ?? "";
                var contactPhone = Normalize(rawContactPhone);

                string? content = msgType switch
                {
                    "text" when msg.TryGetProperty("text", out var t) &&
                                t.TryGetProperty("body", out var b)
                                => b.GetString(),

                    "image" when msg.TryGetProperty("image", out var img) &&
                                 img.TryGetProperty("caption", out var cap)
                                 => cap.GetString(),

                    _ => null
                };

                logger.LogInformation(
                    "üì• Inbound WA message: type={MsgType}, from={From}, preview={Preview}",
                    msgType,
                    rawContactPhone,
                    content?.Length > 50 ? content[..50] : content
                );

                // 2) Resolve business via ProviderDirectory first, then fallback to WhatsAppPhoneNumbers
                if (!value.TryGetProperty("metadata", out var metadata))
                {
                    logger.LogWarning("Inbound: metadata missing on webhook payload.");
                    return;
                }

                string? displayNumber = metadata.TryGetProperty("display_phone_number", out var dn)
                    ? dn.GetString()
                    : null;

                string? phoneNumberId = metadata.TryGetProperty("phone_number_id", out var pn)
                    ? pn.GetString()
                    : null;

                string? wabaId = metadata.TryGetProperty("waba_id", out var we)
                    ? we.GetString()
                    : null;

                // 2.1 Prefer provider directory (uses provider + phone_number_id + waba_id)
                Guid? businessId = await _providerDirectory.ResolveBusinessIdAsync(
                    provider: "meta_cloud",          // canonical provider key for Meta Cloud
                    phoneNumberId: phoneNumberId,
                    displayPhoneNumber: displayNumber,
                    wabaId: wabaId,
                    waId: rawContactPhone           // the WA user id ("from")
                );

                // 2.2 Fallback to legacy WhatsAppPhoneNumbers by display number if needed
                if (businessId == null && !string.IsNullOrWhiteSpace(displayNumber))
                {
                    var cleanIncomingBiz = Normalize(displayNumber);

                    var candidates = await db.WhatsAppPhoneNumbers
                        .AsNoTracking()
                        .Where(n => n.IsActive)
                        .Select(n => new { n.BusinessId, n.WhatsAppBusinessNumber })
                        .ToListAsync();

                    var numHit = candidates.FirstOrDefault(n =>
                        Normalize(n.WhatsAppBusinessNumber) == cleanIncomingBiz);

                    if (numHit != null)
                        businessId = numHit.BusinessId;
                }

                // 2.3 Still nothing ‚Üí log and bail
                if (businessId == null || businessId == Guid.Empty)
                {
                    logger.LogWarning(
                        "‚ùå Inbound: business not resolved. phone_number_id={PhoneId}, display={Display}, waba={Waba}, from={From}",
                        phoneNumberId,
                        displayNumber,
                        wabaId,
                        rawContactPhone
                    );
                    return;
                }

                var resolvedBusinessId = businessId.Value;

                // 3) Find or create contact
                var contact = await contactService.FindOrCreateAsync(resolvedBusinessId, contactPhone);
                if (contact == null)
                {
                    logger.LogWarning("‚ùå Could not resolve contact for phone: {Phone}", contactPhone);
                    return;
                }

                // Extract profile name (contacts[0].profile.name) and upsert into Contacts
                static string? TryGetProfileName(JsonElement root)
                {
                    if (root.TryGetProperty("contacts", out var contactsEl) &&
                        contactsEl.ValueKind == JsonValueKind.Array &&
                        contactsEl.GetArrayLength() > 0)
                    {
                        var c0 = contactsEl[0];
                        if (c0.TryGetProperty("profile", out var prof) &&
                            prof.ValueKind == JsonValueKind.Object &&
                            prof.TryGetProperty("name", out var nm) &&
                            nm.ValueKind == JsonValueKind.String)
                        {
                            var n = nm.GetString();
                            return string.IsNullOrWhiteSpace(n) ? null : n!.Trim();
                        }
                    }
                    return null;
                }

                var profileName = TryGetProfileName(value);
                if (!string.IsNullOrWhiteSpace(profileName))
                {
                    try
                    {
                        await contactProfileService.UpsertProfileNameAsync(
                            resolvedBusinessId,
                            contactPhone,
                            profileName!,
                            CancellationToken.None);
                    }
                    catch (Exception ex)
                    {
                        logger.LogWarning(ex, "‚ö†Ô∏è Failed to upsert ProfileName for {Phone}", contactPhone);
                    }
                }

                // 4) Check chat mode‚Ä¶
                var mode = await chatSessionStateService.GetChatModeAsync(resolvedBusinessId, contact.Id);
                var isAgentMode = mode == "agent";

                // 5) Log incoming message
                var messageLog = new MessageLog
                {
                    Id = Guid.NewGuid(),
                    BusinessId = resolvedBusinessId,
                    ContactId = contact.Id,
                    RecipientNumber = contactPhone,
                    MessageContent = content,
                    Status = "received",
                    CreatedAt = DateTime.UtcNow,
                    SentAt = DateTime.UtcNow,
                    IsIncoming = true
                };

                db.MessageLogs.Add(messageLog);
                await db.SaveChangesAsync();

                await _hub.Clients
                    .Group($"business_{resolvedBusinessId}")
                    .SendAsync("ReceiveInboxMessage", new
                    {
                        contactId = contact.Id,
                        message = messageLog.MessageContent,
                        isIncoming = true,
                        senderId = (Guid?)null,
                        sentAt = messageLog.CreatedAt
                    });

                // 6) Try AutoReply runtime first, then fall back to legacy automation
                try
                {
                    var triggerRaw = (content ?? string.Empty).Trim();
                    var triggerKeyword = triggerRaw.ToLowerInvariant();

                    var autoHandled = false;

                    // 6.1 ‚Äì New AutoReply runtime (keyword ‚Üí simple reply or CTA flow)
                    if (!string.IsNullOrWhiteSpace(triggerRaw))
                    {
                        var autoResult = await autoReplyRuntime.TryHandleAsync(
                            resolvedBusinessId,
                            contact.Id,
                            contact.PhoneNumber,
                            triggerRaw,                // pass original text (not forced lowercase)
                            CancellationToken.None     // you can thread a real ct later if you extend the method
                        );

                        autoHandled = autoResult.Handled;

                        if (autoResult.Handled)
                        {
                            logger.LogInformation(
                                "ü§ñ AutoReply runtime handled inbound message. BusinessId={BusinessId}, ContactId={ContactId}, Keyword={Keyword}, SentSimpleReply={SentSimpleReply}, StartedCtaFlow={StartedCtaFlow}, AutoReplyFlowId={FlowId}, CtaFlowConfigId={CtaId}",
                                resolvedBusinessId,
                                contact.Id,
                                triggerKeyword,
                                autoResult.SentSimpleReply,
                                autoResult.StartedCtaFlow,
                                autoResult.AutoReplyFlowId,
                                autoResult.CtaFlowConfigId
                            );
                        }
                        else
                        {
                            logger.LogInformation(
                                "ü§ñ AutoReply runtime did not handle message. Falling back to legacy automation. Keyword={Keyword}",
                                triggerKeyword
                            );
                        }
                    }

                    // 6.2 ‚Äì Legacy AutomationService fallback (only if AutoReply did NOT handle)
                    if (!autoHandled)
                    {
                        var handledByLegacy = await automationService.TryRunFlowByKeywordAsync(
                            resolvedBusinessId,
                            triggerKeyword,
                            contact.PhoneNumber,
                            sourceChannel: "whatsapp",
                            industryTag: "default");

                        if (!handledByLegacy)
                        {
                            logger.LogInformation("üïµÔ∏è No automation flow matched keyword (legacy): {Keyword}", triggerKeyword);
                        }
                    }
                }
                catch (Exception ex)
                {
                    logger.LogError(ex, "‚ùå AutoReply / Automation flow execution failed.");
                }


                // 7) Sync to inbox only if agent mode
                if (isAgentMode)
                {
                    try
                    {
                        var inboxService = scope.ServiceProvider.GetRequiredService<IInboxService>();

                        logger.LogInformation(
                            "üì• Inbound: syncing message to inbox for BusinessId={BusinessId}, ContactId={ContactId}",
                            resolvedBusinessId,
                            contact.Id);

                        await inboxService.SaveIncomingMessageAsync(new InboxMessageDto
                        {
                            BusinessId = resolvedBusinessId,
                            ContactId = contact.Id,
                            RecipientPhone = contact.PhoneNumber,
                            MessageBody = messageLog.MessageContent,
                            IsIncoming = true,
                            Status = messageLog.Status,
                            SentAt = messageLog.CreatedAt
                        });

                        logger.LogInformation("‚úÖ Message synced to inbox for contact {Phone}", contactPhone);
                    }
                    catch (Exception ex)
                    {
                        logger.LogError(ex, "‚ùå Failed to sync inbound message to inbox.");
                    }
                }
                else
                {
                    logger.LogInformation("üö´ Skipping inbox sync: chat mode is not 'agent'");
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "‚ùå Failed to process inbound WhatsApp chat.");
            }
        }

        public async Task ProcessInteractiveAsync(JsonElement value, CancellationToken ct = default)
        {
            using var scope = _serviceScopeFactory.CreateScope();
            var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();
            var contactProfileService = scope.ServiceProvider.GetRequiredService<IContactProfileService>();
            var logger = scope.ServiceProvider.GetRequiredService<ILogger<InboundMessageProcessor>>();

            static string Normalize(string? number) =>
                string.IsNullOrWhiteSpace(number) ? "" : new string(number.Where(char.IsDigit).ToArray());

            // Safe extract of profile name (Meta Cloud shape)
            static string? TryGetProfileName(JsonElement root)
            {
                if (root.TryGetProperty("contacts", out var contactsEl) &&
                    contactsEl.ValueKind == JsonValueKind.Array &&
                    contactsEl.GetArrayLength() > 0)
                {
                    var c0 = contactsEl[0];
                    if (c0.TryGetProperty("profile", out var profileEl) &&
                        profileEl.ValueKind == JsonValueKind.Object &&
                        profileEl.TryGetProperty("name", out var nameEl) &&
                        nameEl.ValueKind == JsonValueKind.String)
                    {
                        var n = nameEl.GetString();
                        return string.IsNullOrWhiteSpace(n) ? null : n!.Trim();
                    }
                }
                return null;
            }

            // messages[0].from is always present for interactive/button
            if (!value.TryGetProperty("messages", out var msgs) || msgs.GetArrayLength() == 0)
                return;

            var msg0 = msgs[0];
            var fromRaw = msg0.GetProperty("from").GetString() ?? "";
            var fromE164 = Normalize(fromRaw);

            // Resolve Business via metadata.display_phone_number ‚Üí WhatsAppPhoneNumbers
            var displayNumberRaw = value.GetProperty("metadata").GetProperty("display_phone_number").GetString() ?? "";
            var displayNumber = Normalize(displayNumberRaw);

            // Look up the business by matching the normalized number in WhatsAppPhoneNumbers
            var candidates = await db.WhatsAppPhoneNumbers
                .AsNoTracking()
                .Where(n => n.IsActive)
                .Select(n => new { n.BusinessId, n.WhatsAppBusinessNumber })
                .ToListAsync(ct);

            var numHit = candidates.FirstOrDefault(n => Normalize(n.WhatsAppBusinessNumber) == displayNumber);
            if (numHit == null)
            {
                logger.LogWarning("‚ùå Business not found for interactive webhook number: {Num}", displayNumberRaw);
                return;
            }

            var businessId = numHit.BusinessId;

            // Upsert profile name if present
            var profileName = TryGetProfileName(value);
            if (!string.IsNullOrWhiteSpace(profileName))
            {
                try
                {
                    await contactProfileService.UpsertProfileNameAsync(businessId, fromE164, profileName!, ct);
                }
                catch (Exception ex)
                {
                    logger.LogWarning(ex, "‚ö†Ô∏è Failed to upsert ProfileName on interactive webhook for {Phone}", fromE164);
                }
            }

            // ‚Ä¶ continue your existing interactive handling (routing to next step, etc.)
        }
    }
}


//using System;
//using System.Text.Json;
//using System.Threading.Tasks;
//using Microsoft.AspNetCore.SignalR;
//using Microsoft.EntityFrameworkCore;
//using Microsoft.Extensions.Logging;
//using xbytechat.api;
//using xbytechat.api.Features.Inbox.DTOs;
//using xbytechat.api.CRM.Models;
//using xbytechat.api.Features.Inbox.Hubs;
//using Microsoft.Extensions.DependencyInjection;
//using xbytechat.api.CRM.Interfaces;
//using xbytechat.api.Features.AutoReplyBuilder.Services;
//using xbytechat.api.Features.Inbox.Services;
//using xbytechat.api.Features.MessagesEngine.DTOs;
//using xbytechat.api.Features.MessagesEngine.Services;
//using xbytechat.api.CRM.Services;
//using xbytechat.api.Features.Automation.Services;
//using xbytechat.api.Features.Contacts.Services;

//namespace xbytechat.api.Features.Webhooks.Services.Processors
//{
//    public class InboundMessageProcessor : IInboundMessageProcessor
//    {
//        private readonly AppDbContext _context;
//        private readonly IHubContext<InboxHub> _hubContext;
//        private readonly ILogger<InboundMessageProcessor> _logger;
//        private readonly IInboxService _inboxService;
//        private readonly IServiceScopeFactory _serviceScopeFactory;
//        private readonly IHubContext<InboxHub> _hub;
//        private readonly IContactProfileService _contactProfile;

//        public InboundMessageProcessor(
//            AppDbContext context,
//            IHubContext<InboxHub> hubContext,
//            ILogger<InboundMessageProcessor> logger,
//            IInboxService inboxService,
//            IServiceScopeFactory serviceScopeFactory,
//            IHubContext<InboxHub> hub,
//            IContactProfileService contactProfile)
//        {
//            _context = context;
//            _hubContext = hubContext;
//            _logger = logger;
//            _inboxService = inboxService;
//            _serviceScopeFactory = serviceScopeFactory;
//            _hub = hub;
//            _contactProfile = contactProfile;
//        }

//        //public async Task ProcessChatAsync(JsonElement value)
//        //{
//        //    // High-level trace for every inbound chat
//        //    try
//        //    {
//        //        var rawText = value.GetRawText();
//        //        _logger.LogInformation(
//        //            "üí¨ InboundMessageProcessor.ProcessChatAsync started. PayloadLength={Length}",
//        //            rawText?.Length ?? 0);
//        //    }
//        //    catch
//        //    {
//        //        // ignore any GetRawText failures ‚Äì not critical
//        //    }

//        //    try
//        //    {
//        //        using var scope = _serviceScopeFactory.CreateScope();
//        //        var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();
//        //        var contactService = scope.ServiceProvider.GetRequiredService<IContactService>();
//        //        var chatSessionStateService = scope.ServiceProvider.GetRequiredService<IChatSessionStateService>();
//        //        var automationService = scope.ServiceProvider.GetRequiredService<IAutomationService>();
//        //        var logger = scope.ServiceProvider.GetRequiredService<ILogger<InboundMessageProcessor>>();
//        //        var contactProfileService = scope.ServiceProvider.GetRequiredService<IContactProfileService>();

//        //        // digits-only normalizer (matches how we store/search phones)
//        //        static string Normalize(string? s) =>
//        //            string.IsNullOrWhiteSpace(s) ? "" : new string(s.Where(char.IsDigit).ToArray());

//        //        // 1) Extract WA metadata + message (Meta Cloud shape)
//        //        if (!value.TryGetProperty("messages", out var msgs) || msgs.GetArrayLength() == 0)
//        //        {
//        //            logger.LogWarning("‚ùå Inbound payload has no 'messages' array or it is empty.");
//        //            return;
//        //        }

//        //        var msg = msgs[0];

//        //        var rawContactPhone = msg.GetProperty("from").GetString() ?? "";
//        //        var contactPhone = Normalize(rawContactPhone);
//        //        var content = msg.TryGetProperty("text", out var t) && t.TryGetProperty("body", out var b)
//        //            ? b.GetString()
//        //            : null;

//        //        if (!value.TryGetProperty("metadata", out var metadata))
//        //        {
//        //            logger.LogWarning("‚ùå Inbound payload missing 'metadata' field.");
//        //            return;
//        //        }

//        //        var rawBusinessNumber = metadata.GetProperty("display_phone_number").GetString() ?? "";
//        //        var cleanIncomingBiz = Normalize(rawBusinessNumber);

//        //        logger.LogInformation(
//        //            "üîé Inbound extract: rawContactPhone={RawContact}, normalizedContact={Contact}, rawBusinessNumber={RawBiz}, normalizedBiz={Biz}",
//        //            rawContactPhone,
//        //            contactPhone,
//        //            rawBusinessNumber,
//        //            cleanIncomingBiz);

//        //        // 2) Resolve business  ‚úÖ now via WhatsAppPhoneNumbers (NOT WhatsAppSettings)
//        //        Guid? businessIdHit = null;

//        //        // Pull active numbers (small table; client-side normalization for reliability)
//        //        var candidates = await db.WhatsAppPhoneNumbers
//        //            .AsNoTracking()
//        //            .Where(n => n.IsActive)
//        //            .Select(n => new { n.BusinessId, n.WhatsAppBusinessNumber })
//        //            .ToListAsync();

//        //        logger.LogDebug("üìä Inbound: Loaded {Count} active WhatsAppPhoneNumbers candidates.", candidates.Count);

//        //        var numHit = candidates.FirstOrDefault(n => Normalize(n.WhatsAppBusinessNumber) == cleanIncomingBiz);
//        //        if (numHit != null)
//        //        {
//        //            businessIdHit = numHit.BusinessId;
//        //            logger.LogInformation(
//        //                "‚úÖ Inbound: resolved BusinessId={BusinessId} for display_phone_number={RawBiz}",
//        //                businessIdHit,
//        //                rawBusinessNumber);
//        //        }

//        //        if (businessIdHit == null || businessIdHit == Guid.Empty)
//        //        {
//        //            logger.LogWarning(
//        //                "‚ùå Business not found for WhatsApp number: {Number} (normalized={Norm})",
//        //                rawBusinessNumber,
//        //                cleanIncomingBiz);
//        //            return;
//        //        }

//        //        var businessId = businessIdHit.Value;

//        //        // 3) Find or create contact
//        //        logger.LogInformation(
//        //            "üë§ Inbound: resolving contact for BusinessId={BusinessId}, Phone={Phone}",
//        //            businessId,
//        //            contactPhone);

//        //        var contact = await contactService.FindOrCreateAsync(businessId, contactPhone);
//        //        if (contact == null)
//        //        {
//        //            logger.LogWarning("‚ùå Could not resolve contact for phone: {Phone}", contactPhone);
//        //            return;
//        //        }

//        //        logger.LogInformation("‚úÖ Inbound: contact resolved. ContactId={ContactId}", contact.Id);

//        //        // Extract profile name (contacts[0].profile.name) and upsert into Contacts
//        //        static string? TryGetProfileName(JsonElement root)
//        //        {
//        //            if (root.TryGetProperty("contacts", out var contactsEl) &&
//        //                contactsEl.ValueKind == JsonValueKind.Array &&
//        //                contactsEl.GetArrayLength() > 0)
//        //            {
//        //                var c0 = contactsEl[0];
//        //                if (c0.TryGetProperty("profile", out var prof) &&
//        //                    prof.ValueKind == JsonValueKind.Object &&
//        //                    prof.TryGetProperty("name", out var nm) &&
//        //                    nm.ValueKind == JsonValueKind.String)
//        //                {
//        //                    var n = nm.GetString();
//        //                    return string.IsNullOrWhiteSpace(n) ? null : n!.Trim();
//        //                }
//        //            }
//        //            return null;
//        //        }

//        //        var profileName = TryGetProfileName(value);
//        //        if (!string.IsNullOrWhiteSpace(profileName))
//        //        {
//        //            try
//        //            {
//        //                logger.LogInformation(
//        //                    "üßæ Inbound: upserting profile name for BusinessId={BusinessId}, Phone={Phone}, Name={Name}",
//        //                    businessId,
//        //                    contactPhone,
//        //                    profileName);

//        //                await contactProfileService.UpsertProfileNameAsync(
//        //                    businessId,
//        //                    contactPhone,
//        //                    profileName!,
//        //                    CancellationToken.None);
//        //            }
//        //            catch (Exception ex)
//        //            {
//        //                logger.LogWarning(ex, "‚ö†Ô∏è Failed to upsert ProfileName for {Phone}", contactPhone);
//        //            }
//        //        }

//        //        // 4) Check chat mode‚Ä¶
//        //        var mode = await chatSessionStateService.GetChatModeAsync(businessId, contact.Id);
//        //        var isAgentMode = mode == "agent";

//        //        logger.LogInformation(
//        //            "üí¨ Inbound: chat mode for contact {ContactId} is '{Mode}' (isAgentMode={IsAgentMode})",
//        //            contact.Id,
//        //            mode,
//        //            isAgentMode);

//        //        // 5) Log incoming message
//        //        var messageLog = new MessageLog
//        //        {
//        //            Id = Guid.NewGuid(),
//        //            BusinessId = businessId,
//        //            ContactId = contact.Id,
//        //            RecipientNumber = contactPhone,
//        //            MessageContent = content,
//        //            Status = "received",
//        //            CreatedAt = DateTime.UtcNow,
//        //            SentAt = DateTime.UtcNow,
//        //            IsIncoming = true
//        //        };

//        //        db.MessageLogs.Add(messageLog);
//        //        await db.SaveChangesAsync();

//        //        logger.LogInformation(
//        //            "üìù Inbound: MessageLog saved. MessageLogId={MessageLogId}, BusinessId={BusinessId}, ContactId={ContactId}",
//        //            messageLog.Id,
//        //            businessId,
//        //            contact.Id);

//        //        // 6) Notify Inbox clients via SignalR
//        //        try
//        //        {
//        //            var groupName = $"business_{businessId}";
//        //            logger.LogInformation(
//        //                "üì° Inbound: broadcasting ReceiveInboxMessage to SignalR group {GroupName} for ContactId={ContactId}",
//        //                groupName,
//        //                contact.Id);

//        //            await _hub.Clients
//        //                .Group(groupName)
//        //                .SendAsync("ReceiveInboxMessage", new
//        //                {
//        //                    contactId = contact.Id,
//        //                    message = messageLog.MessageContent,
//        //                    isIncoming = true,
//        //                    senderId = (Guid?)null,
//        //                    sentAt = messageLog.CreatedAt
//        //                });
//        //        }
//        //        catch (Exception ex)
//        //        {
//        //            logger.LogWarning(ex, "‚ö†Ô∏è Inbound: failed to broadcast ReceiveInboxMessage to SignalR.");
//        //        }

//        //        // 7) Try to trigger automation by keyword
//        //        try
//        //        {
//        //            var triggerKeyword = (content ?? string.Empty).Trim().ToLowerInvariant();
//        //            logger.LogInformation(
//        //                "‚öôÔ∏è Inbound: attempting automation flow match for keyword='{Keyword}'",
//        //                triggerKeyword);

//        //            var handled = await automationService.TryRunFlowByKeywordAsync(
//        //                businessId,
//        //                triggerKeyword,
//        //                contact.PhoneNumber,
//        //                sourceChannel: "whatsapp",
//        //                industryTag: "default");

//        //            if (!handled)
//        //                logger.LogInformation("üïµÔ∏è No automation flow matched keyword: {Keyword}", triggerKeyword);
//        //            else
//        //                logger.LogInformation("‚úÖ Automation flow handled inbound keyword: {Keyword}", triggerKeyword);
//        //        }
//        //        catch (Exception ex)
//        //        {
//        //            logger.LogError(ex, "‚ùå Automation flow execution failed.");
//        //        }

//        //        // 8) Sync to inbox only if agent mode
//        //        if (isAgentMode)
//        //        {
//        //            try
//        //            {
//        //                var inboxService = scope.ServiceProvider.GetRequiredService<IInboxService>();

//        //                logger.LogInformation(
//        //                    "üì• Inbound: syncing message to inbox for BusinessId={BusinessId}, ContactId={ContactId}",
//        //                    businessId,
//        //                    contact.Id);

//        //                await inboxService.SaveIncomingMessageAsync(new InboxMessageDto
//        //                {
//        //                    BusinessId = businessId,
//        //                    ContactId = contact.Id,
//        //                    RecipientPhone = contact.PhoneNumber,
//        //                    MessageBody = messageLog.MessageContent,
//        //                    IsIncoming = true,
//        //                    Status = messageLog.Status,
//        //                    SentAt = messageLog.CreatedAt
//        //                });

//        //                logger.LogInformation("‚úÖ Message synced to inbox for contact {Phone}", contactPhone);
//        //            }
//        //            catch (Exception ex)
//        //            {
//        //                logger.LogError(ex, "‚ùå Failed to sync inbound message to inbox.");
//        //            }
//        //        }
//        //        else
//        //        {
//        //            logger.LogInformation("üö´ Skipping inbox sync: chat mode is not 'agent'");
//        //        }
//        //    }
//        //    catch (Exception ex)
//        //    {
//        //        _logger.LogError(ex, "‚ùå Failed to process inbound WhatsApp chat.");
//        //    }
//        //}

//        public async Task ProcessInteractiveAsync(JsonElement value, CancellationToken ct = default)
//        {
//            _logger.LogInformation("üí¨ InboundMessageProcessor.ProcessInteractiveAsync started.");

//            using var scope = _serviceScopeFactory.CreateScope();
//            var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();
//            var contactProfileService = scope.ServiceProvider.GetRequiredService<IContactProfileService>();
//            var logger = scope.ServiceProvider.GetRequiredService<ILogger<InboundMessageProcessor>>();

//            static string Normalize(string? number) =>
//                string.IsNullOrWhiteSpace(number) ? "" : new string(number.Where(char.IsDigit).ToArray());

//            // Safe extract of profile name (Meta Cloud shape)
//            static string? TryGetProfileName(JsonElement root)
//            {
//                if (root.TryGetProperty("contacts", out var contactsEl) &&
//                    contactsEl.ValueKind == JsonValueKind.Array &&
//                    contactsEl.GetArrayLength() > 0)
//                {
//                    var c0 = contactsEl[0];
//                    if (c0.TryGetProperty("profile", out var profileEl) &&
//                        profileEl.ValueKind == JsonValueKind.Object &&
//                        profileEl.TryGetProperty("name", out var nameEl) &&
//                        nameEl.ValueKind == JsonValueKind.String)
//                    {
//                        var n = nameEl.GetString();
//                        return string.IsNullOrWhiteSpace(n) ? null : n!.Trim();
//                    }
//                }
//                return null;
//            }

//            // messages[0].from is always present for interactive/button
//            if (!value.TryGetProperty("messages", out var msgs) || msgs.GetArrayLength() == 0)
//            {
//                logger.LogWarning("‚ùå Interactive payload has no 'messages' array or it is empty.");
//                return;
//            }

//            var msg0 = msgs[0];
//            var fromRaw = msg0.GetProperty("from").GetString() ?? "";
//            var fromE164 = Normalize(fromRaw);

//            logger.LogInformation(
//                "üîé Interactive: fromRaw={FromRaw}, normalized={FromNorm}",
//                fromRaw,
//                fromE164);

//            // Resolve Business via metadata.display_phone_number ‚Üí WhatsAppPhoneNumbers
//            if (!value.TryGetProperty("metadata", out var metadata))
//            {
//                logger.LogWarning("‚ùå Interactive payload missing 'metadata' field.");
//                return;
//            }

//            var displayNumberRaw = metadata.GetProperty("display_phone_number").GetString() ?? "";
//            var displayNumber = Normalize(displayNumberRaw);

//            logger.LogInformation(
//                "üîé Interactive: display_phone_number raw={Raw}, normalized={Norm}",
//                displayNumberRaw,
//                displayNumber);

//            // Look up the business by matching the normalized number in WhatsAppPhoneNumbers
//            var candidates = await db.WhatsAppPhoneNumbers
//                .AsNoTracking()
//                .Where(n => n.IsActive)
//                .Select(n => new { n.BusinessId, n.WhatsAppBusinessNumber })
//                .ToListAsync(ct);

//            logger.LogDebug("üìä Interactive: Loaded {Count} active WhatsAppPhoneNumbers candidates.", candidates.Count);

//            var numHit = candidates.FirstOrDefault(n => Normalize(n.WhatsAppBusinessNumber) == displayNumber);
//            if (numHit == null)
//            {
//                logger.LogWarning(
//                    "‚ùå Business not found for interactive webhook number: {NumRaw} (normalized={Norm})",
//                    displayNumberRaw,
//                    displayNumber);
//                return;
//            }

//            var businessId = numHit.BusinessId;
//            logger.LogInformation(
//                "‚úÖ Interactive: resolved BusinessId={BusinessId} for number={NumRaw}",
//                businessId,
//                displayNumberRaw);

//            // Upsert profile name if present
//            var profileName = TryGetProfileName(value);
//            if (!string.IsNullOrWhiteSpace(profileName))
//            {
//                try
//                {
//                    logger.LogInformation(
//                        "üßæ Interactive: upserting profile name for BusinessId={BusinessId}, Phone={Phone}, Name={Name}",
//                        businessId,
//                        fromE164,
//                        profileName);

//                    await contactProfileService.UpsertProfileNameAsync(
//                        businessId,
//                        fromE164,
//                        profileName!,
//                        ct);
//                }
//                catch (Exception ex)
//                {
//                    logger.LogWarning(
//                        ex,
//                        "‚ö†Ô∏è Failed to upsert ProfileName on interactive webhook for {Phone}",
//                        fromE164);
//                }
//            }

//            // ‚Ä¶ your existing interactive handling continues (routing to next step, etc.)
//        }
//    }
//}


////using System;
////using System.Text.Json;
////using System.Threading.Tasks;
////using Microsoft.AspNetCore.SignalR;
////using Microsoft.EntityFrameworkCore;
////using Microsoft.Extensions.Logging;
////using xbytechat.api;
////using xbytechat.api.Features.Inbox.DTOs;
////using xbytechat.api.CRM.Models;
////using xbytechat.api.Features.Inbox.Hubs;
////using Microsoft.Extensions.DependencyInjection;
////using xbytechat.api.CRM.Interfaces;
////using xbytechat.api.Features.AutoReplyBuilder.Services;
////using xbytechat.api.Features.Inbox.Services;
////using xbytechat.api.Features.MessagesEngine.DTOs;
////using xbytechat.api.Features.MessagesEngine.Services;
////using xbytechat.api.CRM.Services;
////using xbytechat.api.Features.Automation.Services;
////using xbytechat.api.Features.Contacts.Services;


////namespace xbytechat.api.Features.Webhooks.Services.Processors
////{
////    public class InboundMessageProcessor : IInboundMessageProcessor
////    {
////        private readonly AppDbContext _context;
////        private readonly IHubContext<InboxHub> _hubContext;
////        private readonly ILogger<InboundMessageProcessor> _logger;
////        private readonly IInboxService _inboxService;
////        private readonly IServiceScopeFactory _serviceScopeFactory;
////        private readonly IHubContext<InboxHub> _hub;
////        private readonly IContactProfileService _contactProfile;
////        public InboundMessageProcessor(
////            AppDbContext context,
////            IHubContext<InboxHub> hubContext,
////            ILogger<InboundMessageProcessor> logger,
////            IInboxService inboxService,
////            IServiceScopeFactory serviceScopeFactory,
////            IHubContext<InboxHub> hub, IContactProfileService contactProfile)
////        {
////            _context = context;
////            _hubContext = hubContext;
////            _logger = logger;
////            _inboxService = inboxService;
////            _serviceScopeFactory = serviceScopeFactory;
////            _hub = hub;
////            _contactProfile = contactProfile;
////        }

////        public async Task ProcessChatAsync(JsonElement value)
////        {
////            try
////            {
////                using var scope = _serviceScopeFactory.CreateScope();
////                var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();
////                var contactService = scope.ServiceProvider.GetRequiredService<IContactService>();
////                var chatSessionStateService = scope.ServiceProvider.GetRequiredService<IChatSessionStateService>();
////                var automationService = scope.ServiceProvider.GetRequiredService<IAutomationService>();
////                var logger = scope.ServiceProvider.GetRequiredService<ILogger<InboundMessageProcessor>>();
////                var contactProfileService = scope.ServiceProvider.GetRequiredService<IContactProfileService>();

////                // digits-only normalizer (matches how we store/search phones)
////                static string Normalize(string? s) =>
////                    string.IsNullOrWhiteSpace(s) ? "" : new string(s.Where(char.IsDigit).ToArray());

////                // 1) Extract WA metadata + message (Meta Cloud shape)
////                var msg = value.GetProperty("messages")[0];
////                var rawContactPhone = msg.GetProperty("from").GetString() ?? "";
////                var contactPhone = Normalize(rawContactPhone);
////                var content = msg.TryGetProperty("text", out var t) && t.TryGetProperty("body", out var b) ? b.GetString() : null;

////                var rawBusinessNumber = value.GetProperty("metadata").GetProperty("display_phone_number").GetString() ?? "";
////                var cleanIncomingBiz = Normalize(rawBusinessNumber);

////                // 2) Resolve business  ‚úÖ now via WhatsAppPhoneNumbers (NOT WhatsAppSettings)
////                Guid? businessIdHit = null;

////                // Pull active numbers (small table; client-side normalization for reliability)
////                var candidates = await db.WhatsAppPhoneNumbers
////                    .AsNoTracking()
////                    .Where(n => n.IsActive)
////                    .Select(n => new { n.BusinessId, n.WhatsAppBusinessNumber })
////                    .ToListAsync();

////                var numHit = candidates.FirstOrDefault(n => Normalize(n.WhatsAppBusinessNumber) == cleanIncomingBiz);
////                if (numHit != null) businessIdHit = numHit.BusinessId;

////                if (businessIdHit == null || businessIdHit == Guid.Empty)
////                {
////                    logger.LogWarning("‚ùå Business not found for WhatsApp number: {Number}", rawBusinessNumber);
////                    return;
////                }

////                var businessId = businessIdHit.Value;

////                // 3) Find or create contact
////                var contact = await contactService.FindOrCreateAsync(businessId, contactPhone);
////                if (contact == null)
////                {
////                    logger.LogWarning("‚ùå Could not resolve contact for phone: {Phone}", contactPhone);
////                    return;
////                }

////                // Extract profile name (contacts[0].profile.name) and upsert into Contacts
////                static string? TryGetProfileName(JsonElement root)
////                {
////                    if (root.TryGetProperty("contacts", out var contactsEl) &&
////                        contactsEl.ValueKind == JsonValueKind.Array &&
////                        contactsEl.GetArrayLength() > 0)
////                    {
////                        var c0 = contactsEl[0];
////                        if (c0.TryGetProperty("profile", out var prof) &&
////                            prof.ValueKind == JsonValueKind.Object &&
////                            prof.TryGetProperty("name", out var nm) &&
////                            nm.ValueKind == JsonValueKind.String)
////                        {
////                            var n = nm.GetString();
////                            return string.IsNullOrWhiteSpace(n) ? null : n!.Trim();
////                        }
////                    }
////                    return null;
////                }

////                var profileName = TryGetProfileName(value);
////                if (!string.IsNullOrWhiteSpace(profileName))
////                {
////                    try
////                    {
////                        await contactProfileService.UpsertProfileNameAsync(businessId, contactPhone, profileName!, CancellationToken.None);
////                    }
////                    catch (Exception ex)
////                    {
////                        logger.LogWarning(ex, "‚ö†Ô∏è Failed to upsert ProfileName for {Phone}", contactPhone);
////                    }
////                }

////                // 4) Check chat mode‚Ä¶
////                var mode = await chatSessionStateService.GetChatModeAsync(businessId, contact.Id);
////                var isAgentMode = mode == "agent";

////                // 5) Log incoming message
////                var messageLog = new MessageLog
////                {
////                    Id = Guid.NewGuid(),
////                    BusinessId = businessId,
////                    ContactId = contact.Id,
////                    RecipientNumber = contactPhone,
////                    MessageContent = content,
////                    Status = "received",
////                    CreatedAt = DateTime.UtcNow,
////                    SentAt = DateTime.UtcNow,
////                    IsIncoming = true
////                };

////                db.MessageLogs.Add(messageLog);
////                await db.SaveChangesAsync();

////                await _hub.Clients
////                    .Group($"business_{businessId}")
////                    .SendAsync("ReceiveInboxMessage", new
////                    {
////                        contactId = contact.Id,
////                        message = messageLog.MessageContent,
////                        isIncoming = true,
////                        senderId = (Guid?)null,
////                        sentAt = messageLog.CreatedAt
////                    });

////                // 6) Try to trigger automation by keyword
////                try
////                {
////                    var triggerKeyword = (content ?? string.Empty).Trim().ToLowerInvariant();
////                    var handled = await automationService.TryRunFlowByKeywordAsync(
////                        businessId,
////                        triggerKeyword,
////                        contact.PhoneNumber,
////                        sourceChannel: "whatsapp",
////                        industryTag: "default");

////                    if (!handled)
////                        logger.LogInformation("üïµÔ∏è No automation flow matched keyword: {Keyword}", triggerKeyword);
////                }
////                catch (Exception ex)
////                {
////                    logger.LogError(ex, "‚ùå Automation flow execution failed.");
////                }

////                // 7) Sync to inbox only if agent mode
////                if (isAgentMode)
////                {
////                    var inboxService = scope.ServiceProvider.GetRequiredService<IInboxService>();
////                    await inboxService.SaveIncomingMessageAsync(new InboxMessageDto
////                    {
////                        BusinessId = businessId,
////                        ContactId = contact.Id,
////                        RecipientPhone = contact.PhoneNumber,
////                        MessageBody = messageLog.MessageContent,
////                        IsIncoming = true,
////                        Status = messageLog.Status,
////                        SentAt = messageLog.CreatedAt
////                    });

////                    logger.LogInformation("üì• Message synced to inbox for contact {Phone}", contactPhone);
////                }
////                else
////                {
////                    logger.LogInformation("üö´ Skipping inbox sync: chat mode is not 'agent'");
////                }
////            }
////            catch (Exception ex)
////            {
////                _logger.LogError(ex, "‚ùå Failed to process inbound WhatsApp chat.");
////            }
////        }

////        public async Task ProcessInteractiveAsync(JsonElement value, CancellationToken ct = default)
////        {
////            using var scope = _serviceScopeFactory.CreateScope();
////            var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();
////            var contactProfileService = scope.ServiceProvider.GetRequiredService<IContactProfileService>();
////            var logger = scope.ServiceProvider.GetRequiredService<ILogger<InboundMessageProcessor>>();

////            static string Normalize(string? number) =>
////                string.IsNullOrWhiteSpace(number) ? "" : new string(number.Where(char.IsDigit).ToArray());

////            // Safe extract of profile name (Meta Cloud shape)
////            static string? TryGetProfileName(JsonElement root)
////            {
////                if (root.TryGetProperty("contacts", out var contactsEl) &&
////                    contactsEl.ValueKind == JsonValueKind.Array &&
////                    contactsEl.GetArrayLength() > 0)
////                {
////                    var c0 = contactsEl[0];
////                    if (c0.TryGetProperty("profile", out var profileEl) &&
////                        profileEl.ValueKind == JsonValueKind.Object &&
////                        profileEl.TryGetProperty("name", out var nameEl) &&
////                        nameEl.ValueKind == JsonValueKind.String)
////                    {
////                        var n = nameEl.GetString();
////                        return string.IsNullOrWhiteSpace(n) ? null : n!.Trim();
////                    }
////                }
////                return null;
////            }

////            // messages[0].from is always present for interactive/button
////            if (!value.TryGetProperty("messages", out var msgs) || msgs.GetArrayLength() == 0)
////                return;

////            var msg0 = msgs[0];
////            var fromRaw = msg0.GetProperty("from").GetString() ?? "";
////            var fromE164 = Normalize(fromRaw);

////            // Resolve Business via metadata.display_phone_number ‚Üí WhatsAppPhoneNumbers
////            var displayNumberRaw = value.GetProperty("metadata").GetProperty("display_phone_number").GetString() ?? "";
////            var displayNumber = Normalize(displayNumberRaw);

////            // Look up the business by matching the normalized number in WhatsAppPhoneNumbers
////            var candidates = await db.WhatsAppPhoneNumbers
////                .AsNoTracking()
////                .Where(n => n.IsActive)
////                .Select(n => new { n.BusinessId, n.WhatsAppBusinessNumber })
////                .ToListAsync(ct);

////            var numHit = candidates.FirstOrDefault(n => Normalize(n.WhatsAppBusinessNumber) == displayNumber);
////            if (numHit == null)
////            {
////                logger.LogWarning("‚ùå Business not found for interactive webhook number: {Num}", displayNumberRaw);
////                return;
////            }

////            var businessId = numHit.BusinessId;

////            // Upsert profile name if present
////            var profileName = TryGetProfileName(value);
////            if (!string.IsNullOrWhiteSpace(profileName))
////            {
////                try
////                {
////                    await contactProfileService.UpsertProfileNameAsync(businessId, fromE164, profileName!, ct);
////                }
////                catch (Exception ex)
////                {
////                    logger.LogWarning(ex, "‚ö†Ô∏è Failed to upsert ProfileName on interactive webhook for {Phone}", fromE164);
////                }
////            }

////            // ‚Ä¶ continue your existing interactive handling (routing to next step, etc.)
////        }

////    }
////}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Services\Processors\IStatusWebhookProcessor.cs 
====================================================== 
 
Ôªøusing System.Text.Json;
using System.Threading.Tasks;

namespace xbytechat.api.Features.Webhooks.Services.Processors
{
    public interface IStatusWebhookProcessor
    {
        Task ProcessStatusUpdateAsync(JsonElement payload, CancellationToken ct = default);
    }
    
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Services\Processors\ITemplateWebhookProcessor.cs 
====================================================== 
 
Ôªøusing System.Text.Json;
using System.Threading.Tasks;

namespace xbytechat.api.Features.Webhooks.Services.Processors
{
    public interface ITemplateWebhookProcessor
    {
        Task ProcessTemplateUpdateAsync(JsonElement payload);
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Services\Processors\StatusWebhookProcessor.cs 
====================================================== 
 
Ôªøusing Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using System;
using System.Text.Json;
using System.Threading.Tasks;

// üëá where your AppDbContext lives
using xbytechat.api;

using xbytechat.api.Features.CampaignTracking.Models;   // CampaignSendLog
using xbytechat.api.Features.MessageManagement.DTOs;    // MessageLog
using xbytechat.api.Features.Webhooks.Services.Resolvers;
using xbytechat.api.Features.Webhooks.Status;
using xbytechat.api.Infrastructure.Observability;

namespace xbytechat.api.Features.Webhooks.Services.Processors
{
    /// <summary>
    /// Legacy status processor (back-compat).
    /// - Extracts statuses from the payload
    /// - Resolves CampaignSendLog via IMessageIdResolver when possible
    /// - Updates CampaignSendLog / MessageLog idempotently
    /// New provider-aware flow should go through the dispatcher -> WhatsAppWebhookService.
    /// </summary>
    public class StatusWebhookProcessor : IStatusWebhookProcessor
    {
        private readonly AppDbContext _context;
        private readonly ILogger<StatusWebhookProcessor> _logger;
        private readonly IMessageIdResolver _messageIdResolver;
        private readonly IMessageStatusUpdater _updater;
        public StatusWebhookProcessor(
            AppDbContext context,
            ILogger<StatusWebhookProcessor> logger,
            IMessageIdResolver messageIdResolver,
            IMessageStatusUpdater updater)
        {
            _context = context;
            _logger = logger;
            _messageIdResolver = messageIdResolver;
            _updater = updater;
        }

        /// <summary>
        /// Entry point from dispatcher (legacy path).
        /// Normalizes Meta envelope to a "value" object, then processes.
        /// </summary>
        public async Task ProcessStatusUpdateAsync(JsonElement payload, CancellationToken ct = default)
        {
            _logger.LogDebug("status_webhook_in (legacy)\n{Payload}", payload.ToString());

            // 0) Batch payloads: recurse per item
            if (payload.ValueKind == JsonValueKind.Array)
            {
                foreach (var item in payload.EnumerateArray())
                    await ProcessStatusUpdateAsync(item, ct);
                return;
            }

            // 1) Canonical Meta envelope: { entry:[{ changes:[{ value:{...} }]}] }
            if (payload.ValueKind == JsonValueKind.Object &&
                payload.TryGetProperty("entry", out var entry) &&
                entry.ValueKind == JsonValueKind.Array)
            {
                foreach (var e in entry.EnumerateArray())
                {
                    if (e.TryGetProperty("changes", out var changes) && changes.ValueKind == JsonValueKind.Array)
                    {
                        foreach (var ch in changes.EnumerateArray())
                        {
                            if (ch.TryGetProperty("value", out var v))
                                await ProcessAsync(v.GetRawText(), ct); // <- pass string + ct
                        }
                    }
                }
                return;
            }

            // 2) Envelope ‚Üí value via helper (back-compat)
            if (TryExtractValue(payload, out var value))
            {
                await ProcessAsync(value.GetRawText(), ct);            // <- pass string + ct
                return;
            }

            // 3) Already value-like (adapter flattened)
            if (payload.ValueKind == JsonValueKind.Object &&
                (payload.TryGetProperty("statuses", out _) || payload.TryGetProperty("messages", out _)))
            {
                await ProcessAsync(payload.GetRawText(), ct);          // <- pass string + ct
                return;
            }

            // 4) Minimal single-status object (id/status)
            if (payload.ValueKind == JsonValueKind.Object &&
                payload.TryGetProperty("id", out _) &&
                payload.TryGetProperty("status", out _))
            {
                await ProcessAsync(payload.GetRawText(), ct);          // <- pass string + ct
                return;
            }

            _logger.LogWarning("Unrecognized status payload shape (legacy path).");
            MetricsRegistry.MessagesFailed.Add(1);
        }

        /// <summary>
        /// Extract statuses from a Meta-like "value" object and update DB.
        /// </summary>
        //public async Task ProcessAsync(JsonElement value)
        //{
        //    if (!value.TryGetProperty("statuses", out var statuses) || statuses.ValueKind != JsonValueKind.Array)
        //    {
        //        _logger.LogWarning("‚ö†Ô∏è 'statuses' array missing in webhook payload (legacy path).");
        //        return;
        //    }

        //    foreach (var status in statuses.EnumerateArray())
        //    {
        //        if (status.ValueKind != JsonValueKind.Object) continue;

        //        // message id (WAMID)
        //        var messageId = status.TryGetProperty("id", out var idEl) && idEl.ValueKind == JsonValueKind.String
        //            ? idEl.GetString()
        //            : null;

        //        // status text
        //        var statusText = status.TryGetProperty("status", out var stEl) && stEl.ValueKind == JsonValueKind.String
        //            ? stEl.GetString()
        //            : null;

        //        if (string.IsNullOrWhiteSpace(messageId) || string.IsNullOrWhiteSpace(statusText))
        //        {
        //            _logger.LogWarning("‚ö†Ô∏è Missing messageId or status in webhook payload (legacy path).");
        //            continue;
        //        }

        //        // timestamp (string or number)
        //        DateTime? eventTime = null;
        //        if (status.TryGetProperty("timestamp", out var tsEl))
        //        {
        //            if (tsEl.ValueKind == JsonValueKind.String && long.TryParse(tsEl.GetString(), out var epochS))
        //                eventTime = DateTimeOffset.FromUnixTimeSeconds(epochS).UtcDateTime;
        //            else if (tsEl.ValueKind == JsonValueKind.Number && tsEl.TryGetInt64(out var epochN))
        //                eventTime = DateTimeOffset.FromUnixTimeSeconds(epochN).UtcDateTime;
        //        }

        //        _logger.LogDebug("üïì Parsed timestamp: {Time} (raw kind={Kind})",
        //            eventTime?.ToString("o") ?? "n/a", status.TryGetProperty("timestamp", out var tsDbg) ? tsDbg.ValueKind.ToString() : "n/a");

        //        // ‚úÖ First try resolving a CampaignSendLog row via resolver
        //        Guid? sendLogId = null;
        //        try
        //        {
        //            sendLogId = await _messageIdResolver.ResolveCampaignSendLogIdAsync(messageId);
        //        }
        //        catch (Exception ex)
        //        {
        //            _logger.LogWarning(ex, "MessageId resolver failed for {MessageId}", messageId);
        //        }

        //        if (sendLogId is Guid sid)
        //        {
        //            var log = await _context.Set<CampaignSendLog>()
        //                                    .FirstOrDefaultAsync(l => l.Id == sid);

        //            if (log != null)
        //            {
        //                bool changed = false;

        //                var newStatus = MapMetaStatus(statusText);
        //                if (!string.IsNullOrEmpty(newStatus) &&
        //                    !string.Equals(log.SendStatus, newStatus, StringComparison.Ordinal))
        //                {
        //                    log.SendStatus = newStatus;
        //                    changed = true;
        //                }

        //                if (statusText == "sent" && (log.SentAt == null || log.SentAt == default) && eventTime.HasValue)
        //                {
        //                    log.SentAt = eventTime.Value;
        //                    changed = true;
        //                }
        //                if (statusText == "delivered" && (log.DeliveredAt == null || log.DeliveredAt == default) && eventTime.HasValue)
        //                {
        //                    log.DeliveredAt = eventTime.Value;
        //                    changed = true;
        //                }
        //                if (statusText == "read" && (log.ReadAt == null || log.ReadAt == default) && eventTime.HasValue)
        //                {
        //                    log.ReadAt = eventTime.Value;
        //                    changed = true;
        //                }

        //                if (changed)
        //                {
        //                    await _context.SaveChangesAsync();
        //                    _logger.LogInformation("‚úÖ CampaignSendLog updated (legacy) for MessageId: {MessageId} ‚Üí {Status}", messageId, newStatus ?? statusText);
        //                }
        //                else
        //                {
        //                    _logger.LogInformation("üîÅ Duplicate status '{Status}' skipped for MessageId: {MessageId} (legacy)", statusText, messageId);
        //                }

        //                continue; // done with this status item
        //            }
        //        }

        //        // üîÅ Fallback: update MessageLog when there‚Äôs no CampaignSendLog
        //        var msg = await _context.Set<MessageLog>()
        //                                .FirstOrDefaultAsync(m => m.MessageId == messageId);

        //        if (msg != null)
        //        {
        //            bool changed = false;

        //            switch (statusText)
        //            {
        //                case "sent":
        //                    if (!EqualsIgnoreCase(msg.Status, "Sent"))
        //                    {
        //                        msg.Status = "Sent";
        //                        changed = true;
        //                    }
        //                    if ((msg.SentAt == null || msg.SentAt == default) && eventTime.HasValue)
        //                    {
        //                        msg.SentAt = eventTime.Value;
        //                        changed = true;
        //                    }
        //                    break;

        //                case "delivered":
        //                    // no DeliveredAt column on MessageLog; just progression
        //                    if (!EqualsIgnoreCase(msg.Status, "Read") &&
        //                        !EqualsIgnoreCase(msg.Status, "Delivered"))
        //                    {
        //                        msg.Status = "Delivered";
        //                        changed = true;
        //                    }
        //                    if ((msg.SentAt == null || msg.SentAt == default) && eventTime.HasValue)
        //                    {
        //                        msg.SentAt = eventTime.Value; // ensure SentAt eventually set
        //                        changed = true;
        //                    }
        //                    break;

        //                case "read":
        //                    if (!EqualsIgnoreCase(msg.Status, "Read"))
        //                    {
        //                        msg.Status = "Read";
        //                        changed = true;
        //                    }
        //                    if ((msg.SentAt == null || msg.SentAt == default) && eventTime.HasValue)
        //                    {
        //                        msg.SentAt = eventTime.Value;
        //                        changed = true;
        //                    }
        //                    break;

        //                default:
        //                    // leave as-is for unknown statuses
        //                    break;
        //            }

        //            if (changed)
        //            {
        //                await _context.SaveChangesAsync();
        //                _logger.LogInformation("‚ÑπÔ∏è MessageLog updated (legacy) for MessageId: {MessageId} ‚Üí {Status}", messageId, msg.Status);
        //            }
        //            else
        //            {
        //                _logger.LogInformation("üîÅ Duplicate status '{Status}' skipped for MessageId: {MessageId} (legacy)", statusText, messageId);
        //            }
        //        }
        //        else
        //        {
        //            // lower severity; common when a send failed before obtaining a message id
        //            _logger.LogInformation("‚ìò No matching CampaignSendLog/MessageLog for MessageId: {MessageId} (legacy)", messageId);
        //        }
        //    }
        //}
        public sealed class MetaStatusEnvelope
        {
            public Entry[]? entry { get; set; }
            public sealed class Entry { public Change[]? changes { get; set; } }
            public sealed class Change { public Value? value { get; set; } }
            public sealed class Value { public Status[]? statuses { get; set; } }
            public sealed class Status
            {
                public string? id { get; set; }          // WAMID
                public string? status { get; set; }      // sent|delivered|read|failed
                public long? timestamp { get; set; }     // epoch seconds
                public StatusError[]? errors { get; set; }
            }
            public sealed class StatusError { public string? message { get; set; } public string? code { get; set; } }
        }

        // Fallback "simple" event for manual tests/tools
        public sealed class SimpleStatusEvent
        {
            public string? MessageId { get; set; }
            public string? Status { get; set; }
            public long? Timestamp { get; set; }
            public string? ErrorMessage { get; set; }
        }

      
                // make sure this is injected too

        public async Task<int> ProcessAsync(string rawJson, CancellationToken ct)
        {
            // Try Meta-like envelope first
            try
            {
                var env = System.Text.Json.JsonSerializer.Deserialize<MetaStatusEnvelope>(rawJson);
                if (env?.entry is { Length: > 0 })
                {
                    var total = 0;
                    foreach (var e in env.entry)
                        foreach (var ch in e.changes ?? Array.Empty<MetaStatusEnvelope.Change>())
                            foreach (var st in ch.value?.statuses ?? Array.Empty<MetaStatusEnvelope.Status>())
                            {
                                var providerMsgId = st.id ?? string.Empty;
                                var wamid = await _messageIdResolver.ResolveAsync(providerMsgId, ct) ?? providerMsgId; // no-op if already WAMID
                                var status = (st.status ?? "").Trim().ToLowerInvariant();
                                var ts = st.timestamp.HasValue
                                    ? DateTimeOffset.FromUnixTimeSeconds(st.timestamp.Value).UtcDateTime
                                    : DateTime.UtcNow;
                                var err = st.errors?.FirstOrDefault()?.message;

                                if (!string.IsNullOrWhiteSpace(wamid) && !string.IsNullOrWhiteSpace(status))
                                {
                                    total += await _updater.UpdateAsync(wamid, status, ts, err, ct);
                                }
                            }
                    return total;
                }
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "[StatusWebhookProcessor] Meta envelope parse failed; trying simple shape.");
            }

            // Fallback: simple shape (handy for cURL testing)
            try
            {
                var ev = System.Text.Json.JsonSerializer.Deserialize<SimpleStatusEvent>(rawJson);
                if (ev?.MessageId is not null && ev.Status is not null)
                {
                    var ts = ev.Timestamp.HasValue
                        ? DateTimeOffset.FromUnixTimeSeconds(ev.Timestamp.Value).UtcDateTime
                        : DateTime.UtcNow;
                    return await _updater.UpdateAsync(ev.MessageId, ev.Status, ts, ev.ErrorMessage, ct);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "[StatusWebhookProcessor] Simple shape parse failed");
            }

            _logger.LogWarning("[StatusWebhookProcessor] Unsupported payload");
            return 0;
        }

        // ----------------- helpers -----------------

        private static bool TryExtractValue(JsonElement payload, out JsonElement value)
        {
            value = default;
            if (payload.ValueKind != JsonValueKind.Object) return false;
            if (!payload.TryGetProperty("entry", out var entry) || entry.ValueKind != JsonValueKind.Array || entry.GetArrayLength() == 0) return false;

            var e0 = entry[0];
            if (!e0.TryGetProperty("changes", out var changes) || changes.ValueKind != JsonValueKind.Array || changes.GetArrayLength() == 0) return false;

            var c0 = changes[0];
            if (!c0.TryGetProperty("value", out var v) || v.ValueKind != JsonValueKind.Object) return false;

            value = v;
            return true;
        }

        private static string? MapMetaStatus(string? s) =>
            (s ?? "").ToLowerInvariant() switch
            {
                "sent" => "Sent",
                "delivered" => "Delivered",
                "read" => "Read",
                "failed" => "Failed",
                "deleted" => "Deleted",
                _ => null
            };

        private static bool EqualsIgnoreCase(string? a, string? b) =>
            string.Equals(a, b, StringComparison.OrdinalIgnoreCase);
    }
}


 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Services\Processors\TemplateWebhookProcessor.cs 
====================================================== 
 
Ôªøusing System;
using System.Text.Json;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace xbytechat.api.Features.Webhooks.Services.Processors
{
    public class TemplateWebhookProcessor : ITemplateWebhookProcessor
    {
        private readonly ILogger<TemplateWebhookProcessor> _logger;

        public TemplateWebhookProcessor(ILogger<TemplateWebhookProcessor> logger)
        {
            _logger = logger;
        }

        public async Task ProcessTemplateUpdateAsync(JsonElement payload)
        {
            try
            {
                var entry = payload.GetProperty("entry")[0];
                var changes = entry.GetProperty("changes")[0];
                var value = changes.GetProperty("value");

                var eventType = value.GetProperty("event").GetString();
                var templateId = value.TryGetProperty("message_template_id", out var idProp)
                                 ? idProp.GetString() : "(unknown)";

                _logger.LogInformation($"üßæ Template Event Received: {eventType} for ID: {templateId}");

                // üß† You can store in DB or show in admin logs in the future

                await Task.CompletedTask;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "‚ùå Failed to process template webhook update.");
            }
        }
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Services\Resolvers\IMessageIdResolver.cs 
====================================================== 
 
Ôªøusing System;
using System.Threading.Tasks;

namespace xbytechat.api.Features.Webhooks.Services.Resolvers
{
    public interface IMessageIdResolver
    {
        Task<Guid?> ResolveCampaignSendLogIdAsync(string messageId);
        Task<Guid?> ResolveMessageLogIdAsync(string messageId);
        Task<Guid?> ResolveBusinessIdByMessageIdAsync(string messageId);
        Task<string?> ResolveAsync(string providerMessageId, CancellationToken ct = default);

    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Services\Resolvers\MessageIdResolver.cs 
====================================================== 
 
Ôªøusing Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using Serilog;
using System;
using System.Threading.Tasks;
using xbytechat.api;

namespace xbytechat.api.Features.Webhooks.Services.Resolvers
{
    public class MessageIdResolver : IMessageIdResolver
    {
        private readonly AppDbContext _context;
        private readonly ILogger<MessageIdResolver> _logger;

        public MessageIdResolver(AppDbContext context, ILogger<MessageIdResolver> logger)
        {
            _context = context;
            _logger = logger;
        }
        public async Task<string?> ResolveAsync(string providerMessageId, CancellationToken ct = default)
        {
            if (string.IsNullOrWhiteSpace(providerMessageId))
                return null;

            // 1) Already a WAMID? Return as-is.
            if (providerMessageId.StartsWith("wamid.", StringComparison.OrdinalIgnoreCase))
                return providerMessageId;

            // 2) Try MessageLogs mapping (most reliable)
            //    We pick any field that looks like a WAMID if present; otherwise fall back to MessageId.
            var mlHit = await _context.MessageLogs.AsNoTracking()
                .Where(m => m.ProviderMessageId == providerMessageId || m.MessageId == providerMessageId)
                .OrderByDescending(m => m.CreatedAt)
                .Select(m =>
                    m.ProviderMessageId.StartsWith("wamid.", StringComparison.OrdinalIgnoreCase)
                        ? m.ProviderMessageId
                        : (m.MessageId ?? m.ProviderMessageId))
                .FirstOrDefaultAsync(ct);

            if (!string.IsNullOrEmpty(mlHit))
                return mlHit;

            // 3) Some paths write WAMID straight into CampaignSendLogs.MessageId (no mapping required)
            var cslHit = await _context.CampaignSendLogs.AsNoTracking()
                .Where(c => c.MessageId == providerMessageId)
                .OrderByDescending(c => c.CreatedAt)
                .Select(c => c.MessageId)
                .FirstOrDefaultAsync(ct);

            if (!string.IsNullOrEmpty(cslHit))
                return cslHit;

            // 4) Fallback: return original (keeps pipeline flowing even if we can‚Äôt map)
            _logger.LogDebug("MessageIdResolver: passthrough for provider id {ProviderMessageId}", providerMessageId);
            return providerMessageId;
        }

        public async Task<Guid?> ResolveCampaignSendLogIdAsync(string messageId)
        {
            var log = await _context.CampaignSendLogs
                                .FirstOrDefaultAsync(l => l.MessageId == messageId);

            if (log == null)
            {
                _logger.LogWarning("‚ö†Ô∏è CampaignSendLog not found for MessageId: {MessageId}", messageId);
                return null;
            }

            return log.Id;
        }

        public async Task<Guid?> ResolveMessageLogIdAsync(string messageId)
        {
            var log = await _context.MessageLogs
                .AsNoTracking()
                .FirstOrDefaultAsync(l => l.MessageId == messageId);

            if (log == null)
            {
                _logger.LogWarning("‚ö†Ô∏è MessageLog not found for MessageId: {MessageId}", messageId);
                return null;
            }

            return log.Id;
        }

        public async Task<Guid?> ResolveBusinessIdByMessageIdAsync(string messageId)
        {
            var log = await _context.MessageLogs
                .AsNoTracking()
                .FirstOrDefaultAsync(l => l.MessageId == messageId);

            if (log == null)
            {
                _logger.LogWarning("‚ö†Ô∏è MessageLog not found for MessageId: {MessageId}", messageId);
                return null;
            }

            return log.BusinessId;
        }

    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Status\IMessageStatusUpdater.cs 
====================================================== 
 
Ôªøusing System;
using System.Threading;
using System.Threading.Tasks;

namespace xbytechat.api.Features.Webhooks.Status
{
    public interface IMessageStatusUpdater
    {
       // Task UpdateAsync(StatusEvent ev, CancellationToken ct = default);
        Task<int> UpdateAsync(string messageId, string status, DateTime tsUtc, string? error, CancellationToken ct);
    }

    public sealed class StatusEvent
    {
        public Guid BusinessId { get; init; }
        public string Provider { get; init; } = "";          // "meta" | "pinnacle"

        // Provider message id (Meta "id", Pinnacle equivalent) ‚Üí maps to MessageId in your DB
        public string ProviderMessageId { get; init; } = "";

        // Optional hints (not required in your current lookups)
        public Guid? CampaignSendLogId { get; init; }
        public string? RecipientWaId { get; init; }

        public MessageDeliveryState State { get; init; }     // Sent/Delivered/Read/Failed/Deleted
        public DateTimeOffset OccurredAt { get; init; }      // from provider timestamp when available

        public string? ErrorCode { get; init; }
        public string? ErrorMessage { get; init; }
        public string? ConversationId { get; init; }
    }

    public enum MessageDeliveryState
    {
        Sent,
        Delivered,
        Read,
        Failed,
        Deleted
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Status\MessageStatusContracts.cs 
====================================================== 
 
Ôªønamespace xbytechat.api.Features.Webhooks.Status
{
    public class MessageStatusContracts
    {
        public enum CanonicalMessageStatus
        {
            Unknown = 0,
            Submitted,   // API accepted (optional)
            Sent,        // provider accepted / sent
            Delivered,
            Read,
            Failed
        }
        public sealed class UpdateMessageStatusRequest
        {
            public Guid BusinessId { get; set; }
            public string Provider { get; set; } = "";              // "meta_cloud" | "pinnacle" | etc.
            public string MessageId { get; set; } = "";             // provider message id (WAMID / id)
            public string RawStatus { get; set; } = "";             // provider-specific (e.g., "sent", "delivered")
            public DateTimeOffset? EventTime { get; set; }          // provider timestamp, if any

            public string? RecipientNumber { get; set; }            // optional sanity context
            public string? ErrorCode { get; set; }                  // optional error info
            public string? ErrorMessage { get; set; }               // optional error info
            public string? RawPayloadJson { get; set; }             // optional audit/debug
        }

        public interface IMessageStatusUpdater
        {
            Task<bool> UpdateAsync(UpdateMessageStatusRequest req, CancellationToken ct = default);
        }
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Status\MessageStatusUpdater.cs 
====================================================== 
 
Ôªøusing System;
using System.Linq;
using System.Reflection;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;

// üëá make sure this is where your AppDbContext lives
using xbytechat.api;

using xbytechat.api.Features.CampaignTracking.Models; // CampaignSendLog
using xbytechat.api.Features.CampaignModule.Models;   // Campaign (nav)
using xbytechat.api.Features.CRM.Models;                      // Contact (nav)
using xbytechat.api.Features.MessageManagement.DTOs;  // MessageLog

// üëá Billing ingest
using xbytechat_api.Features.Billing.Services;        // IBillingIngestService
using xbytechat.api.Infrastructure.Observability;
using Channel = System.Threading.Channels.Channel;
using System.Threading.RateLimiting;
using Serilog;
namespace xbytechat.api.Features.Webhooks.Status
{
    /// <summary>
    /// Idempotent updater touching CampaignSendLogs and MessageLogs using your actual schema.
    /// Also forwards raw Meta webhook payloads to Billing ingest for pricing/billing capture.
    /// </summary>
    public class MessageStatusUpdater : IMessageStatusUpdater
    {
        private readonly AppDbContext _db;
        private readonly ILogger<MessageStatusUpdater> _log;
        private readonly IBillingIngestService _billing;

        public MessageStatusUpdater(AppDbContext db,
                                    ILogger<MessageStatusUpdater> log,
                                    IBillingIngestService billing)
        {
            _db = db;
            _log = log;
            _billing = billing;
        }

        //public async Task UpdateAsync(StatusEvent ev, CancellationToken ct = default)
        //{
        //    // üîé Guard: we need Business + ProviderMessageId (WAMID) to reconcile reliably
        //    if (ev.BusinessId == Guid.Empty || string.IsNullOrWhiteSpace(ev.ProviderMessageId))
        //    {
        //        _log.LogWarning("Status update missing key fields (BusinessId or ProviderMessageId). Skip.");
        //        return;
        //    }

        //    // 1) Pull candidates (scoped to business + WAMID)
        //    var sendLogQ = _db.Set<CampaignSendLog>()
        //                      .AsTracking()
        //                      .Where(s => s.BusinessId == ev.BusinessId && s.MessageId == ev.ProviderMessageId);

        //    // NOTE: some rows set both MessageId and ProviderMessageId to the wamid; be flexible.
        //    var msgLogQ = _db.Set<MessageLog>()
        //                     .AsTracking()
        //                     .Where(m => m.BusinessId == ev.BusinessId &&
        //                                (m.ProviderMessageId == ev.ProviderMessageId ||
        //                                 m.MessageId == ev.ProviderMessageId));

        //    // If caller passed a specific CampaignSendLogId, narrow further
        //    if (ev.CampaignSendLogId is Guid sid)
        //        sendLogQ = sendLogQ.Where(s => s.Id == sid);

        //    var sendLog = await sendLogQ.FirstOrDefaultAsync(ct);
        //    var msgLog = await msgLogQ.FirstOrDefaultAsync(ct);

        //    // 2) Apply transition (idempotent)
        //    var changed = ApplyTransition(sendLog, msgLog, ev);

        //    // 3) Persist only if something actually changed
        //    if (changed > 0)
        //        await _db.SaveChangesAsync(ct);

        //    // 4) Always forward Meta status webhook payloads to Billing ingest (for pricing events).
        //    await TryForwardToBillingAsync(ev, ct);
        //}


        public async Task<int> UpdateAsync(string messageId, string status, DateTime tsUtc, string? error, CancellationToken ct)
        {
            if (string.IsNullOrWhiteSpace(messageId)) return 0;

            status = status.Trim().ToLowerInvariant();

            // 1) Update CampaignSendLogs by MessageId (idempotent)
            var cslQuery = _db.CampaignSendLogs.Where(x => x.MessageId == messageId);

            int affected;
            if (status == "delivered")
            {
                affected = await cslQuery.ExecuteUpdateAsync(s => s
                    .SetProperty(x => x.ErrorMessage, error)
                    .SetProperty(x => x.DeliveredAt, tsUtc)
                    .SetProperty(x => x.SendStatus, "Delivered")
                    .SetProperty(x => x.SentAt, x => x.SentAt ?? tsUtc), ct);
            }
            else if (status == "read")
            {
                affected = await cslQuery.ExecuteUpdateAsync(s => s
                    .SetProperty(x => x.ErrorMessage, error)
                    .SetProperty(x => x.ReadAt, tsUtc)
                    .SetProperty(x => x.SendStatus, "Read")
                    .SetProperty(x => x.SentAt, x => x.SentAt ?? tsUtc)
                    .SetProperty(x => x.DeliveredAt, x => x.DeliveredAt ?? tsUtc), ct);
            }
            else if (status == "failed")
            {
                affected = await cslQuery.ExecuteUpdateAsync(s => s
                    .SetProperty(x => x.ErrorMessage, error)
                    .SetProperty(x => x.SendStatus, "Failed")
                    .SetProperty(x => x.SentAt, x => x.SentAt ?? tsUtc), ct);
            }
            else if (status == "sent")
            {
                affected = await cslQuery.ExecuteUpdateAsync(s => s
                    .SetProperty(x => x.ErrorMessage, error)
                    .SetProperty(x => x.SentAt, x => x.SentAt ?? tsUtc)
                    .SetProperty(x => x.SendStatus, "Sent"), ct);
            }
            else
            {
                // Unknown status: only persist the error text (harmless)
                affected = await cslQuery.ExecuteUpdateAsync(s => s
                    .SetProperty(x => x.ErrorMessage, error), ct);
            }

            // 2) Mirror onto MessageLogs (optional but useful for parity)
            var mlQuery = _db.MessageLogs.Where(m => m.ProviderMessageId == messageId);

            if (status == "delivered")
            {
                await mlQuery.ExecuteUpdateAsync(s => s
                    .SetProperty(m => m.Status, "Delivered")
                    .SetProperty(m => m.SentAt, m => m.SentAt ?? tsUtc), ct);
            }
            else if (status == "read")
            {
                await mlQuery.ExecuteUpdateAsync(s => s
                    .SetProperty(m => m.Status, "Read")
                    .SetProperty(m => m.SentAt, m => m.SentAt ?? tsUtc), ct);
            }
            else if (status == "failed")
            {
                await mlQuery.ExecuteUpdateAsync(s => s
                    .SetProperty(m => m.Status, "Failed")
                    .SetProperty(m => m.SentAt, m => m.SentAt ?? tsUtc), ct);
            }
            else if (status == "sent")
            {
                await mlQuery.ExecuteUpdateAsync(s => s
                    .SetProperty(m => m.Status, "Sent")
                    .SetProperty(m => m.SentAt, m => m.SentAt ?? tsUtc), ct);
            }
            // else: ignore unknown statuses for MessageLogs

            // 3) Side-effects & metrics
            if (affected == 0)
            {
                _log.LogWarning("[StatusUpdater] No CampaignSendLog row for messageId={MessageId}", messageId);
            }
            else
            {
                if (status == "failed") MetricsRegistry.MessagesFailed.Add(1);
                else if (status == "sent") MetricsRegistry.MessagesSent.Add(1);
                // delivered/read are visible in analytics; counters optional
            }

            // Optional: billing for delivered/read goes here if required

            return affected;
        }

        /// <summary>Returns number of entities modified.</summary>
        private int ApplyTransition(CampaignSendLog? sendLog, MessageLog? msgLog, StatusEvent ev)
        {
            int modified = 0;

            // --- CampaignSendLog updates ---
            if (sendLog != null)
            {
                if (!string.Equals(sendLog.MessageId, ev.ProviderMessageId, StringComparison.Ordinal))
                {
                    sendLog.MessageId = ev.ProviderMessageId;
                    modified++;
                }

                switch (ev.State)
                {
                    case MessageDeliveryState.Sent:
                        if (!EqualsIgnoreCase(sendLog.SendStatus, "Sent"))
                        {
                            sendLog.SendStatus = "Sent";
                            modified++;
                        }
                        if (sendLog.SentAt == null || sendLog.SentAt == default)
                            sendLog.SentAt = ev.OccurredAt.UtcDateTime;
                        break;

                    case MessageDeliveryState.Delivered:
                        if (!EqualsIgnoreCase(sendLog.SendStatus, "Read") &&
                            !EqualsIgnoreCase(sendLog.SendStatus, "Delivered"))
                        {
                            sendLog.SendStatus = "Delivered";
                            modified++;
                        }
                        if (sendLog.DeliveredAt == null || sendLog.DeliveredAt == default)
                            sendLog.DeliveredAt = ev.OccurredAt.UtcDateTime;
                        break;

                    case MessageDeliveryState.Read:
                        if (!EqualsIgnoreCase(sendLog.SendStatus, "Read"))
                        {
                            sendLog.SendStatus = "Read";
                            modified++;
                        }
                        if (sendLog.ReadAt == null || sendLog.ReadAt == default)
                            sendLog.ReadAt = ev.OccurredAt.UtcDateTime;
                        break;

                    case MessageDeliveryState.Failed:
                        if (!EqualsIgnoreCase(sendLog.SendStatus, "Failed"))
                        {
                            sendLog.SendStatus = "Failed";
                            modified++;
                        }
                        if (sendLog.ErrorMessage != ev.ErrorMessage)
                        {
                            sendLog.ErrorMessage = ev.ErrorMessage;
                            modified++;
                        }
                        break;

                    case MessageDeliveryState.Deleted:
                        if (!EqualsIgnoreCase(sendLog.SendStatus, "Deleted"))
                        {
                            sendLog.SendStatus = "Deleted";
                            modified++;
                        }
                        break;
                }
            }

            // --- MessageLog updates ---
            if (msgLog != null)
            {
                if (!string.Equals(msgLog.MessageId, ev.ProviderMessageId, StringComparison.Ordinal))
                {
                    msgLog.MessageId = ev.ProviderMessageId;
                    modified++;
                }

                switch (ev.State)
                {
                    case MessageDeliveryState.Sent:
                        if (!EqualsIgnoreCase(msgLog.Status, "Sent"))
                        {
                            msgLog.Status = "Sent";
                            modified++;
                        }
                        if (msgLog.SentAt == null || msgLog.SentAt == default)
                            msgLog.SentAt = ev.OccurredAt.UtcDateTime;
                        break;

                    case MessageDeliveryState.Delivered:
                        if (!EqualsIgnoreCase(msgLog.Status, "Read") &&
                            !EqualsIgnoreCase(msgLog.Status, "Delivered"))
                        {
                            msgLog.Status = "Delivered";
                            modified++;
                        }
                        break;

                    case MessageDeliveryState.Read:
                        if (!EqualsIgnoreCase(msgLog.Status, "Read"))
                        {
                            msgLog.Status = "Read";
                            modified++;
                        }
                        break;

                    case MessageDeliveryState.Failed:
                        if (!EqualsIgnoreCase(msgLog.Status, "Failed"))
                        {
                            msgLog.Status = "Failed";
                            modified++;
                        }
                        if (msgLog.ErrorMessage != ev.ErrorMessage)
                        {
                            msgLog.ErrorMessage = ev.ErrorMessage;
                            modified++;
                        }
                        break;

                    case MessageDeliveryState.Deleted:
                        if (!EqualsIgnoreCase(msgLog.Status, "Deleted"))
                        {
                            msgLog.Status = "Deleted";
                            modified++;
                        }
                        break;
                }
            }

            if (sendLog == null && msgLog == null)
            {
                _log.LogWarning("No matching rows for BusinessId={BusinessId}, MessageId={MessageId}, State={State}",
                    ev.BusinessId, ev.ProviderMessageId, ev.State);
            }

            return modified;
        }

        private static bool EqualsIgnoreCase(string? a, string? b) =>
            string.Equals(a, b, StringComparison.OrdinalIgnoreCase);

        // ---------------- Billing forwarder ----------------

        private async Task TryForwardToBillingAsync(StatusEvent ev, CancellationToken ct)
        {
            try
            {
                if (ev.BusinessId == Guid.Empty) return;

                // Pull Provider (via reflection to avoid changing your StatusEvent contract)
                var provider = GetStringProp(ev, "Provider")
                               ?? GetStringProp(ev, "ChannelProvider")
                               ?? GetStringProp(ev, "SourceProvider")
                               ?? GetStringProp(ev, "ProviderNormalized");

                // Try to get raw JSON payload from common property names
                string? rawJson =
                    GetStringProp(ev, "RawPayloadJson") ??
                    GetStringProp(ev, "PayloadJson") ??
                    TryGetJsonElementText(ev, "Body") ??
                    TryGetJsonElementText(ev, "RawBody");

                // If provider missing, use a lightweight sniff (Meta sends "whatsapp_business_account")
                if (string.IsNullOrWhiteSpace(provider) && !string.IsNullOrWhiteSpace(rawJson) &&
                    rawJson.IndexOf("\"whatsapp_business_account\"", StringComparison.OrdinalIgnoreCase) >= 0)
                {
                    provider = "META_CLOUD";
                }

                // Normalize provider for billing
                var normalized = NormalizeProvider(provider);
                if (normalized != "META_CLOUD") return; // only forward Meta to billing ingest for now

                if (string.IsNullOrWhiteSpace(rawJson))
                {
                    _log.LogDebug("Billing forward skipped: no raw payload JSON available on StatusEvent.");
                    return;
                }

                await _billing.IngestFromWebhookAsync(ev.BusinessId, normalized, rawJson);
            }
            catch (Exception ex)
            {
                _log.LogWarning(ex, "Billing ingest (status webhook) failed. businessId={BusinessId}", ev.BusinessId);
            }
        }

        private static string NormalizeProvider(string? provider)
        {
            if (string.IsNullOrWhiteSpace(provider)) return "";
            var p = provider.Trim();
            if (p.Equals("META_CLOUD", StringComparison.OrdinalIgnoreCase)) return "META_CLOUD";
            if (p.Equals("meta", StringComparison.OrdinalIgnoreCase)) return "META_CLOUD";
            if (p.Equals("meta_cloud", StringComparison.OrdinalIgnoreCase)) return "META_CLOUD";
            return p; // other providers unchanged
        }

        private static string? GetStringProp(object obj, string propName)
        {
            var pi = obj.GetType().GetProperty(propName, BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase);
            if (pi == null) return null;
            var val = pi.GetValue(obj);
            return val as string;
        }

        private static string? TryGetJsonElementText(object obj, string propName)
        {
            var pi = obj.GetType().GetProperty(propName, BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase);
            if (pi == null) return null;
            var val = pi.GetValue(obj);
            if (val is JsonElement je) return je.GetRawText();
            return null;
        }
    }
}


//using System;
//using System.Linq;
//using System.Threading;
//using System.Threading.Tasks;
//using Microsoft.EntityFrameworkCore;
//using Microsoft.Extensions.Logging;

//// üëá make sure this is where your AppDbContext lives
//using xbytechat.api;

//using xbytechat.api.Features.CampaignTracking.Models; // CampaignSendLog
//using xbytechat.api.Features.CampaignModule.Models;   // Campaign (nav)
//using xbytechat.api.CRM.Models;                       // Contact (nav)
//using xbytechat.api.Features.MessageManagement.DTOs;  // MessageLog

//namespace xbytechat.api.Features.Webhooks.Status
//{
//    /// <summary>
//    /// Idempotent updater touching CampaignSendLogs and MessageLogs using your actual schema.
//    /// </summary>
//    public class MessageStatusUpdater : IMessageStatusUpdater
//    {
//        private readonly AppDbContext _db;
//        private readonly ILogger<MessageStatusUpdater> _log;

//        public MessageStatusUpdater(AppDbContext db, ILogger<MessageStatusUpdater> log)
//        {
//            _db = db;
//            _log = log;
//        }

//        public async Task UpdateAsync(StatusEvent ev, CancellationToken ct = default)
//        {
//            // üîé Guard: we need Business + ProviderMessageId (WAMID) to reconcile reliably
//            if (ev.BusinessId == Guid.Empty || string.IsNullOrWhiteSpace(ev.ProviderMessageId))
//            {
//                _log.LogWarning("Status update missing key fields (BusinessId or ProviderMessageId). Skip.");
//                return;
//            }

//            // 1) Pull candidates (scoped to business + WAMID)
//            var sendLogQ = _db.Set<CampaignSendLog>()
//                              .AsTracking()
//                              .Where(s => s.BusinessId == ev.BusinessId && s.MessageId == ev.ProviderMessageId);

//            var msgLogQ = _db.Set<MessageLog>()
//                             .AsTracking()
//                             .Where(m => m.BusinessId == ev.BusinessId && m.MessageId == ev.ProviderMessageId);

//            // If caller passed a specific CampaignSendLogId, narrow further
//            if (ev.CampaignSendLogId is Guid sid)
//                sendLogQ = sendLogQ.Where(s => s.Id == sid);

//            var sendLog = await sendLogQ.FirstOrDefaultAsync(ct);
//            var msgLog = await msgLogQ.FirstOrDefaultAsync(ct);

//            // 2) Apply transition (idempotent)
//            var changed = ApplyTransition(sendLog, msgLog, ev);

//            // 3) Persist only if something actually changed
//            if (changed > 0)
//                await _db.SaveChangesAsync(ct);
//        }

//        /// <summary>Returns number of entities modified.</summary>
//        private int ApplyTransition(CampaignSendLog? sendLog, MessageLog? msgLog, StatusEvent ev)
//        {
//            int modified = 0;

//            // --- CampaignSendLog updates ---
//            if (sendLog != null)
//            {
//                if (!string.Equals(sendLog.MessageId, ev.ProviderMessageId, StringComparison.Ordinal))
//                {
//                    sendLog.MessageId = ev.ProviderMessageId;
//                    modified++;
//                }

//                switch (ev.State)
//                {
//                    case MessageDeliveryState.Sent:
//                        if (!EqualsIgnoreCase(sendLog.SendStatus, "Sent"))
//                        {
//                            sendLog.SendStatus = "Sent";
//                            modified++;
//                        }
//                        if (sendLog.SentAt == null || sendLog.SentAt == default)
//                            sendLog.SentAt = ev.OccurredAt.UtcDateTime;
//                        break;

//                    case MessageDeliveryState.Delivered:
//                        if (!EqualsIgnoreCase(sendLog.SendStatus, "Read") &&
//                            !EqualsIgnoreCase(sendLog.SendStatus, "Delivered"))
//                        {
//                            sendLog.SendStatus = "Delivered";
//                            modified++;
//                        }
//                        if (sendLog.DeliveredAt == null || sendLog.DeliveredAt == default)
//                            sendLog.DeliveredAt = ev.OccurredAt.UtcDateTime;
//                        break;

//                    case MessageDeliveryState.Read:
//                        if (!EqualsIgnoreCase(sendLog.SendStatus, "Read"))
//                        {
//                            sendLog.SendStatus = "Read";
//                            modified++;
//                        }
//                        if (sendLog.ReadAt == null || sendLog.ReadAt == default)
//                            sendLog.ReadAt = ev.OccurredAt.UtcDateTime;
//                        break;

//                    case MessageDeliveryState.Failed:
//                        if (!EqualsIgnoreCase(sendLog.SendStatus, "Failed"))
//                        {
//                            sendLog.SendStatus = "Failed";
//                            modified++;
//                        }
//                        if (sendLog.ErrorMessage != ev.ErrorMessage)
//                        {
//                            sendLog.ErrorMessage = ev.ErrorMessage;
//                            modified++;
//                        }
//                        break;

//                    case MessageDeliveryState.Deleted:
//                        if (!EqualsIgnoreCase(sendLog.SendStatus, "Deleted"))
//                        {
//                            sendLog.SendStatus = "Deleted";
//                            modified++;
//                        }
//                        break;
//                }
//            }

//            // --- MessageLog updates ---
//            if (msgLog != null)
//            {
//                if (!string.Equals(msgLog.MessageId, ev.ProviderMessageId, StringComparison.Ordinal))
//                {
//                    msgLog.MessageId = ev.ProviderMessageId;
//                    modified++;
//                }

//                switch (ev.State)
//                {
//                    case MessageDeliveryState.Sent:
//                        if (!EqualsIgnoreCase(msgLog.Status, "Sent"))
//                        {
//                            msgLog.Status = "Sent";
//                            modified++;
//                        }
//                        if (msgLog.SentAt == null || msgLog.SentAt == default)
//                            msgLog.SentAt = ev.OccurredAt.UtcDateTime;
//                        break;

//                    case MessageDeliveryState.Delivered:
//                        if (!EqualsIgnoreCase(msgLog.Status, "Read") &&
//                            !EqualsIgnoreCase(msgLog.Status, "Delivered"))
//                        {
//                            msgLog.Status = "Delivered";
//                            modified++;
//                        }
//                        break;

//                    case MessageDeliveryState.Read:
//                        if (!EqualsIgnoreCase(msgLog.Status, "Read"))
//                        {
//                            msgLog.Status = "Read";
//                            modified++;
//                        }
//                        break;

//                    case MessageDeliveryState.Failed:
//                        if (!EqualsIgnoreCase(msgLog.Status, "Failed"))
//                        {
//                            msgLog.Status = "Failed";
//                            modified++;
//                        }
//                        if (msgLog.ErrorMessage != ev.ErrorMessage)
//                        {
//                            msgLog.ErrorMessage = ev.ErrorMessage;
//                            modified++;
//                        }
//                        break;

//                    case MessageDeliveryState.Deleted:
//                        if (!EqualsIgnoreCase(msgLog.Status, "Deleted"))
//                        {
//                            msgLog.Status = "Deleted";
//                            modified++;
//                        }
//                        break;
//                }
//            }

//            if (sendLog == null && msgLog == null)
//            {
//                _log.LogWarning("No matching rows for BusinessId={BusinessId}, MessageId={MessageId}, State={State}",
//                    ev.BusinessId, ev.ProviderMessageId, ev.State);
//            }

//            return modified;
//        }

//        private static bool EqualsIgnoreCase(string? a, string? b) =>
//            string.Equals(a, b, StringComparison.OrdinalIgnoreCase);
//    }
//}
 
 
